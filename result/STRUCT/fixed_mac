struct kcdata_item {
	uint32_t type;
	uint32_t size; 
	               
	uint64_t flags;
	char data[]; 
};
struct kcdata_subtype_descriptor {
	uint8_t kcs_flags;

	uint8_t kcs_elem_type;                              
	uint16_t kcs_elem_offset;                           
	uint32_t kcs_elem_size;                             
	char                 kcs_name[KCDATA_DESC_MAXLEN];  
};
struct kcdata_type_definition {
	uint32_t kct_type_identifier;
	uint32_t kct_num_elements;
	char kct_name[KCDATA_DESC_MAXLEN];
	struct kcdata_subtype_descriptor kct_elements[];
};
struct stack_snapshot_frame32 {
	uint32_t lr;
	uint32_t sp;
};
struct stack_snapshot_frame64 {
	uint64_t lr;
	uint64_t sp;
};
struct dyld_uuid_info_32 {
	uint32_t imageLoadAddress; 
	uuid_t   imageUUID;
};
struct dyld_uuid_info_64 {
	uint64_t imageLoadAddress; 
	uuid_t   imageUUID;
};
struct dyld_uuid_info_64_v2 {
	uint64_t imageLoadAddress; 
	uuid_t   imageUUID;
	uint64_t imageSlidBaseAddress; 
};
struct dyld_shared_cache_loadinfo_v2 {
	uint64_t sharedCacheSlide;      
	uuid_t   sharedCacheUUID;
	uint64_t sharedCacheUnreliableSlidBaseAddress;  
	uint64_t sharedCacheSlidFirstMapping; 
	uint32_t sharedCacheID; 
	uint32_t sharedCacheFlags;
};
struct dyld_shared_cache_loadinfo {
	uint64_t sharedCacheSlide;      
	uuid_t   sharedCacheUUID;
	uint64_t sharedCacheUnreliableSlidBaseAddress;  
	uint64_t sharedCacheSlidFirstMapping; 
};
struct dyld_aot_cache_uuid_info {
	uint64_t x86SlidBaseAddress; 
	uuid_t x86UUID; 
	uint64_t aotSlidBaseAddress; 
	uuid_t aotUUID; 
};
struct user32_dyld_uuid_info {
	uint32_t        imageLoadAddress;       
	uuid_t                  imageUUID;                      
};
struct user64_dyld_uuid_info {
	uint64_t        imageLoadAddress;       
	uuid_t                  imageUUID;                      
};
struct user64_dyld_aot_info {
	uint64_t x86LoadAddress;
	uint64_t aotLoadAddress;
	uint64_t aotImageSize;
	uint8_t  aotImageKey[DYLD_AOT_IMAGE_KEY_SIZE];
};
struct mem_and_io_snapshot {
	uint32_t        snapshot_magic;
	uint32_t        free_pages;
	uint32_t        active_pages;
	uint32_t        inactive_pages;
	uint32_t        purgeable_pages;
	uint32_t        wired_pages;
	uint32_t        speculative_pages;
	uint32_t        throttled_pages;
	uint32_t        filebacked_pages;
	uint32_t        compressions;
	uint32_t        decompressions;
	uint32_t        compressor_size;
	int32_t         busy_buffer_count;
	uint32_t        pages_wanted;
	uint32_t        pages_reclaimed;
	uint8_t         pages_wanted_reclaimed_valid; 
} __attribute__((packed));
struct thread_snapshot_v2 {
	uint64_t  ths_thread_id;
	uint64_t  ths_wait_event;
	uint64_t  ths_continuation;
	uint64_t  ths_total_syscalls;
	uint64_t  ths_voucher_identifier;
	uint64_t  ths_dqserialnum;
	uint64_t  ths_user_time;
	uint64_t  ths_sys_time;
	uint64_t  ths_ss_flags;
	uint64_t  ths_last_run_time;
	uint64_t  ths_last_made_runnable_time;
	uint32_t  ths_state;
	uint32_t  ths_sched_flags;
	int16_t   ths_base_priority;
	int16_t   ths_sched_priority;
	uint8_t   ths_eqos;
	uint8_t ths_rqos;
	uint8_t ths_rqos_override;
	uint8_t ths_io_tier;
} __attribute__((packed));
struct thread_snapshot_v3 {
	uint64_t ths_thread_id;
	uint64_t ths_wait_event;
	uint64_t ths_continuation;
	uint64_t ths_total_syscalls;
	uint64_t ths_voucher_identifier;
	uint64_t ths_dqserialnum;
	uint64_t ths_user_time;
	uint64_t ths_sys_time;
	uint64_t ths_ss_flags;
	uint64_t ths_last_run_time;
	uint64_t ths_last_made_runnable_time;
	uint32_t ths_state;
	uint32_t ths_sched_flags;
	int16_t ths_base_priority;
	int16_t ths_sched_priority;
	uint8_t ths_eqos;
	uint8_t ths_rqos;
	uint8_t ths_rqos_override;
	uint8_t ths_io_tier;
	uint64_t ths_thread_t;
} __attribute__((packed));
struct thread_snapshot_v4 {
	uint64_t ths_thread_id;
	uint64_t ths_wait_event;
	uint64_t ths_continuation;
	uint64_t ths_total_syscalls;
	uint64_t ths_voucher_identifier;
	uint64_t ths_dqserialnum;
	uint64_t ths_user_time;
	uint64_t ths_sys_time;
	uint64_t ths_ss_flags;
	uint64_t ths_last_run_time;
	uint64_t ths_last_made_runnable_time;
	uint32_t ths_state;
	uint32_t ths_sched_flags;
	int16_t ths_base_priority;
	int16_t ths_sched_priority;
	uint8_t ths_eqos;
	uint8_t ths_rqos;
	uint8_t ths_rqos_override;
	uint8_t ths_io_tier;
	uint64_t ths_thread_t;
	uint64_t ths_requested_policy;
	uint64_t ths_effective_policy;
} __attribute__((packed));
struct thread_group_snapshot {
	uint64_t tgs_id;
	char tgs_name[16];
} __attribute__((packed));
struct thread_group_snapshot_v2 {
	uint64_t tgs_id;
	char tgs_name[16];
	uint64_t tgs_flags;
} __attribute__((packed));
struct thread_group_snapshot_v3 {
	uint64_t tgs_id;
	char tgs_name[16];
	uint64_t tgs_flags;
	char tgs_name_cont[16];
} __attribute__((packed));
struct jetsam_coalition_snapshot {
	uint64_t jcs_id;
	uint64_t jcs_flags;
	uint64_t jcs_thread_group;
	uint64_t jcs_leader_task_uniqueid;
} __attribute__((packed));
struct instrs_cycles_snapshot {
	uint64_t ics_instructions;
	uint64_t ics_cycles;
} __attribute__((packed));
struct instrs_cycles_snapshot_v2 {
	uint64_t ics_instructions;
	uint64_t ics_cycles;
	uint64_t ics_p_instructions;
	uint64_t ics_p_cycles;
} __attribute__((packed));
struct thread_delta_snapshot_v2 {
	uint64_t  tds_thread_id;
	uint64_t  tds_voucher_identifier;
	uint64_t  tds_ss_flags;
	uint64_t  tds_last_made_runnable_time;
	uint32_t  tds_state;
	uint32_t  tds_sched_flags;
	int16_t   tds_base_priority;
	int16_t   tds_sched_priority;
	uint8_t   tds_eqos;
	uint8_t   tds_rqos;
	uint8_t   tds_rqos_override;
	uint8_t   tds_io_tier;
} __attribute__ ((packed));
struct thread_delta_snapshot_v3 {
	uint64_t  tds_thread_id;
	uint64_t  tds_voucher_identifier;
	uint64_t  tds_ss_flags;
	uint64_t  tds_last_made_runnable_time;
	uint32_t  tds_state;
	uint32_t  tds_sched_flags;
	int16_t   tds_base_priority;
	int16_t   tds_sched_priority;
	uint8_t   tds_eqos;
	uint8_t   tds_rqos;
	uint8_t   tds_rqos_override;
	uint8_t   tds_io_tier;
	uint64_t  tds_requested_policy;
	uint64_t  tds_effective_policy;
} __attribute__ ((packed));
struct io_stats_snapshot {
	uint64_t         ss_disk_reads_count;
	uint64_t         ss_disk_reads_size;
	uint64_t         ss_disk_writes_count;
	uint64_t         ss_disk_writes_size;
	uint64_t         ss_io_priority_count[STACKSHOT_IO_NUM_PRIORITIES];
	uint64_t         ss_io_priority_size[STACKSHOT_IO_NUM_PRIORITIES];
	uint64_t         ss_paging_count;
	uint64_t         ss_paging_size;
	uint64_t         ss_non_paging_count;
	uint64_t         ss_non_paging_size;
	uint64_t         ss_data_count;
	uint64_t         ss_data_size;
	uint64_t         ss_metadata_count;
	uint64_t         ss_metadata_size;
} __attribute__ ((packed));
struct task_snapshot_v2 {
	uint64_t  ts_unique_pid;
	uint64_t  ts_ss_flags;
	uint64_t  ts_user_time_in_terminated_threads;
	uint64_t  ts_system_time_in_terminated_threads;
	uint64_t  ts_p_start_sec;
	uint64_t  ts_task_size;
	uint64_t  ts_max_resident_size;
	uint32_t  ts_suspend_count;
	uint32_t  ts_faults;
	uint32_t  ts_pageins;
	uint32_t  ts_cow_faults;
	uint32_t  ts_was_throttled;
	uint32_t  ts_did_throttle;
	uint32_t  ts_latency_qos;
	int32_t   ts_pid;
	char      ts_p_comm[32];
} __attribute__ ((packed));
struct transitioning_task_snapshot {
	uint64_t  tts_unique_pid;
	uint64_t  tts_ss_flags;
	uint64_t  tts_transition_type;
	int32_t   tts_pid;
	char      tts_p_comm[32];
} __attribute__ ((packed));
struct task_delta_snapshot_v2 {
	uint64_t  tds_unique_pid;
	uint64_t  tds_ss_flags;
	uint64_t  tds_user_time_in_terminated_threads;
	uint64_t  tds_system_time_in_terminated_threads;
	uint64_t  tds_task_size;
	uint64_t  tds_max_resident_size;
	uint32_t  tds_suspend_count;
	uint32_t  tds_faults;
	uint32_t  tds_pageins;
	uint32_t  tds_cow_faults;
	uint32_t  tds_was_throttled;
	uint32_t  tds_did_throttle;
	uint32_t  tds_latency_qos;
} __attribute__ ((packed));
struct stackshot_task_codesigning_info {
	uint64_t csflags;
	uint32_t cs_trust_level;
} __attribute__ ((packed));
struct stackshot_cpu_times {
	uint64_t user_usec;
	uint64_t system_usec;
} __attribute__((packed));
struct stackshot_cpu_times_v2 {
	uint64_t user_usec;
	uint64_t system_usec;
	uint64_t runnable_usec;
} __attribute__((packed));
struct stackshot_duration {
	uint64_t stackshot_duration;
	uint64_t stackshot_duration_outer;
} __attribute__((packed));
struct stackshot_duration_v2 {
	uint64_t stackshot_duration;
	uint64_t stackshot_duration_outer;
	uint64_t stackshot_duration_prior;
} __attribute__((packed));
struct stackshot_fault_stats {
	uint32_t sfs_pages_faulted_in;      
	uint64_t sfs_time_spent_faulting;   
	uint64_t sfs_system_max_fault_time; 
	uint8_t  sfs_stopped_faulting;      
} __attribute__((packed));
struct stackshot_thread_waitinfo {
	uint64_t owner;         
	uint64_t waiter;        
	uint64_t context;       
	uint8_t wait_type;      
} __attribute__((packed)) thread_waitinfo_t;
struct stackshot_thread_waitinfo_v2 {
	uint64_t owner;         
	uint64_t waiter;        
	uint64_t context;       
	uint8_t wait_type;      
	int16_t portlabel_id;   
	uint32_t wait_flags;    
} __attribute__((packed)) thread_waitinfo_v2_t;
struct stackshot_thread_turnstileinfo {
	uint64_t waiter;        
	uint64_t turnstile_context; 
	uint8_t turnstile_priority;
	uint8_t number_of_hops;
	uint64_t turnstile_flags;               
} __attribute__((packed)) thread_turnstileinfo_t;
struct stackshot_thread_turnstileinfo_v2 {
	uint64_t waiter;        
	uint64_t turnstile_context; 
	uint8_t turnstile_priority;
	uint8_t number_of_hops;
	uint64_t turnstile_flags; 
	int16_t portlabel_id;   
} __attribute__((packed)) thread_turnstileinfo_v2_t;
struct portlabel_info {
	int16_t portlabel_id;         
	uint16_t portlabel_flags;           
	uint8_t portlabel_domain;           
} __attribute__((packed));
struct stackshot_cpu_architecture {
	int32_t cputype;
	int32_t cpusubtype;
} __attribute__((packed));
struct stack_snapshot_stacktop {
	uint64_t sp;
	uint8_t stack_contents[8];
};
struct stackshot_latency_collection {
	uint64_t latency_version;
	uint64_t setup_latency;
	uint64_t total_task_iteration_latency;
	uint64_t total_terminated_task_iteration_latency;
} __attribute__((packed));
struct stackshot_latency_collection_v2 {
	uint64_t latency_version;
	uint64_t setup_latency_mt;
	uint64_t total_task_iteration_latency_mt;
	uint64_t total_terminated_task_iteration_latency_mt;
	uint64_t task_queue_building_latency_mt;
	uint64_t terminated_task_queue_building_latency_mt;
	uint64_t cpu_wait_latency_mt;
	int32_t  main_cpu_number;
	int32_t  calling_cpu_number;
	uint64_t buffer_size;
	uint64_t buffer_used;
	uint64_t buffer_overhead;
	uint64_t buffer_count;
} __attribute__((packed));
struct stackshot_latency_cpu {
	int32_t  cpu_number;
	int32_t  cluster_type;
	uint64_t init_latency_mt;
	uint64_t workqueue_latency_mt;
	uint64_t total_latency_mt;
	uint64_t total_cycles;
	uint64_t total_instrs;
	uint64_t tasks_processed;
	uint64_t threads_processed;
	uint64_t faulting_time_mt;
	uint64_t total_buf;
	uint64_t intercluster_buf_used;
} __attribute__((packed));
struct stackshot_latency_task {
	uint64_t task_uniqueid;
	uint64_t setup_latency;
	uint64_t task_thread_count_loop_latency;
	uint64_t task_thread_data_loop_latency;
	uint64_t cur_tsnap_latency;
	uint64_t pmap_latency;
	uint64_t bsd_proc_ids_latency;
	uint64_t misc_latency;
	uint64_t misc2_latency;
	uint64_t end_latency;
} __attribute__((packed));
struct stackshot_latency_thread {
	uint64_t thread_id;
	uint64_t cur_thsnap1_latency;
	uint64_t dispatch_serial_latency;
	uint64_t dispatch_label_latency;
	uint64_t cur_thsnap2_latency;
	uint64_t thread_name_latency;
	uint64_t sur_times_latency;
	uint64_t user_stack_latency;
	uint64_t kernel_stack_latency;
	uint64_t misc_latency;
} __attribute__((packed));
struct stackshot_suspension_info {
	uint64_t tss_last_start; 
	uint64_t tss_last_end;   
	uint64_t tss_count;      
	uint64_t tss_duration;   
} __attribute__((packed));
struct stackshot_suspension_source {
	uint64_t tss_time;     
	uint64_t tss_tid;      
	int tss_pid;           
	char tss_procname[65]; 
} __attribute__((packed));
struct thread_exclaves_info {
	uint64_t tei_scid;              
	uint32_t tei_thread_offset;     
	uint32_t tei_flags;             
} __attribute__((packed));
struct thread_crash_exclaves_info {
	uint64_t tcei_scid;              
	uint64_t tcei_thread_id;         
	uint32_t tcei_flags;             
} __attribute__((packed));
struct exclave_scresult_info {
	uint64_t esc_id;
	uint64_t esc_flags;             
} __attribute__((packed));
struct exclave_ipcstackentry_info {
	uint64_t eise_asid;                     
	uint64_t eise_tnid;                     
	uint64_t eise_invocationid;             
	uint64_t eise_flags;                    
} __attribute__((packed));
struct exclave_addressspace_info {
	uint64_t eas_id;                        
	uint64_t eas_flags;                     
	uint64_t eas_layoutid;                  
	uint64_t eas_slide;                     
	uint64_t eas_asroot;                    
} __attribute__((packed));
struct exclave_textlayout_info_v1 {
	uint64_t layout_id;
	uint64_t etl_flags;                     
} __attribute__((packed));
struct exclave_textlayout_info {
	uint64_t layout_id;
	uint64_t etl_flags;                     
	uint32_t sharedcache_index;             
} __attribute__((packed));
struct exclave_textlayout_segment {
	uuid_t layoutSegment_uuid;
	uint64_t layoutSegment_loadAddress;     
} __attribute__((packed));
struct exclave_textlayout_segment_v2 {
	uuid_t layoutSegment_uuid;
	uint64_t layoutSegment_loadAddress;     
	uint64_t layoutSegment_rawLoadAddress;  
} __attribute__((packed));
struct crashinfo_proc_uniqidentifierinfo {
	uint8_t                 p_uuid[16];             
	uint64_t                p_uniqueid;             
	uint64_t                p_puniqueid;            
	uint64_t                p_reserve2;             
	uint64_t                p_reserve3;             
	uint64_t                p_reserve4;             
} __attribute__((packed));
struct kernel_triage_info_v1 {
	char triage_string1[MAX_TRIAGE_STRING_LEN];
	char triage_string2[MAX_TRIAGE_STRING_LEN];
	char triage_string3[MAX_TRIAGE_STRING_LEN];
	char triage_string4[MAX_TRIAGE_STRING_LEN];
	char triage_string5[MAX_TRIAGE_STRING_LEN];
} __attribute__((packed));
struct crashinfo_jit_address_range {
	uint64_t start_address;
	uint64_t end_address;
} __attribute__((packed));
struct crashinfo_mb {
	uint64_t start_address;
	uint64_t data[64];
} __attribute__((packed));
struct btinfo_thread_state_data_t {
	uint32_t flavor;
	uint32_t count;
	int tstate[];
};
struct btinfo_sc_load_info64 {
	uint64_t sharedCacheSlide;
	uuid_t   sharedCacheUUID;
	uint64_t sharedCacheBaseAddress;
};
struct btinfo_sc_load_info {
	uint32_t sharedCacheSlide;
	uuid_t   sharedCacheUUID;
	uint32_t sharedCacheBaseAddress;
};
struct exit_reason_snapshot {
	uint32_t ers_namespace;
	uint64_t ers_code;
	uint64_t ers_flags;
} __attribute__((packed));
struct codesigning_exit_reason_info {
	uint64_t  ceri_virt_addr;
	uint64_t  ceri_file_offset;
	char      ceri_pathname[EXIT_REASON_CODESIG_PATH_MAX];
	char      ceri_filename[EXIT_REASON_CODESIG_PATH_MAX];
	uint64_t  ceri_codesig_modtime_secs;
	uint64_t  ceri_codesig_modtime_nsecs;
	uint64_t  ceri_page_modtime_secs;
	uint64_t  ceri_page_modtime_nsecs;
	uint8_t   ceri_path_truncated;
	uint8_t   ceri_object_codesigned;
	uint8_t   ceri_page_codesig_validated;
	uint8_t   ceri_page_codesig_tainted;
	uint8_t   ceri_page_codesig_nx;
	uint8_t   ceri_page_wpmapped;
	uint8_t   ceri_page_slid;
	uint8_t   ceri_page_dirty;
	uint32_t  ceri_page_shadow_depth;
} __attribute__((packed));
struct encode_state {
	int lchild[N + 1], rchild[N + 257], parent[N + 1];

	u_int8_t text_buf[N + F - 1];

	int match_position, match_length;
};
struct _DeviceTreeBuffer {
	uint32_t paddr;
	uint32_t length;
} _DeviceTreeBuffer;
struct mac {
	size_t           m_buflen;
	char            *m_string;
};
struct user_mac {
	user_size_t     m_buflen;
	user_addr_t     m_string;
};
struct user32_mac {
	uint32_t        m_buflen;
	uint32_t        m_string;
};
struct user64_mac {
	uint64_t        m_buflen;
	uint64_t        m_string;
};
struct mac_module_data_element {
	unsigned int key_size;
	unsigned int value_size;
	unsigned int value_type;
	char *key;
	char *value;
};
struct mac_module_data_list {
	unsigned int count;
	unsigned int type;
	struct mac_module_data_element list[1];
};
struct mac_module_data {
	void *base_addr;                
	unsigned int size;
	unsigned int count;
	struct mac_module_data_element data[1]; 
};
struct mac_policy_list_element {
	struct mac_policy_conf *mpc;
};
struct mac_policy_list {
	u_int                           numloaded;
	u_int                           max;
	u_int                           maxindex;
	u_int                           staticmax;
	u_int                           chunks;
	u_int                           freehint;
	struct mac_policy_list_element  *entries;
};
struct mac_label_listener {
	mac_policy_handle_t             mll_handle;
	SLIST_ENTRY(mac_label_listener) mll_list;
};
struct mac_label_element {
	char                            mle_name[MAC_MAX_LABEL_ELEMENT_NAME];
	struct mac_label_listeners_t    mle_listeners;
	SLIST_ENTRY(mac_label_element)  mle_list;
};
struct mac_policy_ops {
	mpo_audit_check_postselect_t            *mpo_audit_check_postselect;
	mpo_audit_check_preselect_t             *mpo_audit_check_preselect;

	mpo_reserved_hook_t                     *mpo_reserved01;
	mpo_reserved_hook_t                     *mpo_reserved02;
	mpo_reserved_hook_t                     *mpo_reserved03;
	mpo_reserved_hook_t                     *mpo_reserved04;

	mpo_cred_check_label_update_execve_t    *mpo_cred_check_label_update_execve;
	mpo_cred_check_label_update_t           *mpo_cred_check_label_update;
	mpo_cred_check_visible_t                *mpo_cred_check_visible;
	mpo_cred_label_associate_fork_t         *mpo_cred_label_associate_fork;
	mpo_cred_label_associate_kernel_t       *mpo_cred_label_associate_kernel;
	mpo_cred_label_associate_t              *mpo_cred_label_associate;
	mpo_cred_label_associate_user_t         *mpo_cred_label_associate_user;
	mpo_cred_label_destroy_t                *mpo_cred_label_destroy;
	mpo_cred_label_externalize_audit_t      *mpo_cred_label_externalize_audit;
	mpo_cred_label_externalize_t            *mpo_cred_label_externalize;
	mpo_cred_label_init_t                   *mpo_cred_label_init;
	mpo_cred_label_internalize_t            *mpo_cred_label_internalize;
	mpo_cred_label_update_execve_t          *mpo_cred_label_update_execve;
	mpo_cred_label_update_t                 *mpo_cred_label_update;

	mpo_devfs_label_associate_device_t      *mpo_devfs_label_associate_device;
	mpo_devfs_label_associate_directory_t   *mpo_devfs_label_associate_directory;
	mpo_devfs_label_copy_t                  *mpo_devfs_label_copy;
	mpo_devfs_label_destroy_t               *mpo_devfs_label_destroy;
	mpo_devfs_label_init_t                  *mpo_devfs_label_init;
	mpo_devfs_label_update_t                *mpo_devfs_label_update;

	mpo_file_check_change_offset_t          *mpo_file_check_change_offset;
	mpo_file_check_create_t                 *mpo_file_check_create;
	mpo_file_check_dup_t                    *mpo_file_check_dup;
	mpo_file_check_fcntl_t                  *mpo_file_check_fcntl;
	mpo_file_check_get_offset_t             *mpo_file_check_get_offset;
	mpo_file_check_get_t                    *mpo_file_check_get;
	mpo_file_check_inherit_t                *mpo_file_check_inherit;
	mpo_file_check_ioctl_t                  *mpo_file_check_ioctl;
	mpo_file_check_lock_t                   *mpo_file_check_lock;
	mpo_file_check_mmap_downgrade_t         *mpo_file_check_mmap_downgrade;
	mpo_file_check_mmap_t                   *mpo_file_check_mmap;
	mpo_file_check_receive_t                *mpo_file_check_receive;
	mpo_file_check_set_t                    *mpo_file_check_set;
	mpo_file_label_init_t                   *mpo_file_label_init;       
	mpo_file_label_destroy_t                *mpo_file_label_destroy;    
	mpo_file_label_associate_t              *mpo_file_label_associate;  
	mpo_file_notify_close_t                 *mpo_file_notify_close;

	mpo_proc_check_launch_constraints_t     *mpo_proc_check_launch_constraints;
	mpo_proc_notify_service_port_derive_t   *mpo_proc_notify_service_port_derive;
	mpo_proc_check_set_task_exception_port_t *mpo_proc_check_set_task_exception_port;
	mpo_proc_check_set_thread_exception_port_t *mpo_proc_check_set_thread_exception_port;

	mpo_reserved_hook_t                     *mpo_reserved08;
	mpo_reserved_hook_t                     *mpo_reserved09;
	mpo_reserved_hook_t                     *mpo_reserved10;
	mpo_reserved_hook_t                     *mpo_reserved11;
	mpo_reserved_hook_t                     *mpo_reserved12;
	mpo_reserved_hook_t                     *mpo_reserved13;
	mpo_reserved_hook_t                     *mpo_reserved14;
	mpo_reserved_hook_t                     *mpo_reserved15;
	mpo_reserved_hook_t                     *mpo_reserved16;
	mpo_reserved_hook_t                     *mpo_reserved17;
	mpo_reserved_hook_t                     *mpo_reserved18;
	mpo_reserved_hook_t                     *mpo_reserved19;
	mpo_reserved_hook_t                     *mpo_reserved20;
	mpo_reserved_hook_t                     *mpo_reserved21;
	mpo_reserved_hook_t                     *mpo_reserved22;

	mpo_necp_check_open_t                   *mpo_necp_check_open;
	mpo_necp_check_client_action_t          *mpo_necp_check_client_action;

	mpo_file_check_library_validation_t     *mpo_file_check_library_validation;

	mpo_vnode_notify_setacl_t               *mpo_vnode_notify_setacl;
	mpo_vnode_notify_setattrlist_t          *mpo_vnode_notify_setattrlist;
	mpo_vnode_notify_setextattr_t           *mpo_vnode_notify_setextattr;
	mpo_vnode_notify_setflags_t             *mpo_vnode_notify_setflags;
	mpo_vnode_notify_setmode_t              *mpo_vnode_notify_setmode;
	mpo_vnode_notify_setowner_t             *mpo_vnode_notify_setowner;
	mpo_vnode_notify_setutimes_t            *mpo_vnode_notify_setutimes;
	mpo_vnode_notify_truncate_t             *mpo_vnode_notify_truncate;
	mpo_vnode_check_getattrlistbulk_t       *mpo_vnode_check_getattrlistbulk;

	mpo_proc_check_get_task_special_port_t  *mpo_proc_check_get_task_special_port;
	mpo_proc_check_set_task_special_port_t  *mpo_proc_check_set_task_special_port;

	mpo_vnode_notify_swap_t                 *mpo_vnode_notify_swap;
	mpo_vnode_notify_unlink_t               *mpo_vnode_notify_unlink;
	mpo_vnode_check_swap_t                  *mpo_vnode_check_swap;
	mpo_reserved_hook_t                     *mpo_reserved33;
	mpo_reserved_hook_t                     *mpo_reserved34;
	mpo_mount_notify_mount_t                *mpo_mount_notify_mount;
	mpo_vnode_check_copyfile_t              *mpo_vnode_check_copyfile;

	mpo_mount_check_quotactl_t              *mpo_mount_check_quotactl;
	mpo_mount_check_fsctl_t                 *mpo_mount_check_fsctl;
	mpo_mount_check_getattr_t               *mpo_mount_check_getattr;
	mpo_mount_check_label_update_t          *mpo_mount_check_label_update;
	mpo_mount_check_mount_t                 *mpo_mount_check_mount;
	mpo_mount_check_remount_t               *mpo_mount_check_remount;
	mpo_mount_check_setattr_t               *mpo_mount_check_setattr;
	mpo_mount_check_stat_t                  *mpo_mount_check_stat;
	mpo_mount_check_umount_t                *mpo_mount_check_umount;
	mpo_mount_label_associate_t             *mpo_mount_label_associate;
	mpo_mount_label_destroy_t               *mpo_mount_label_destroy;
	mpo_mount_label_externalize_t           *mpo_mount_label_externalize;
	mpo_mount_label_init_t                  *mpo_mount_label_init;
	mpo_mount_label_internalize_t           *mpo_mount_label_internalize;

	mpo_proc_check_expose_task_with_flavor_t *mpo_proc_check_expose_task_with_flavor;
	mpo_proc_check_get_task_with_flavor_t   *mpo_proc_check_get_task_with_flavor;
	mpo_proc_check_task_id_token_get_task_t *mpo_proc_check_task_id_token_get_task;

	mpo_pipe_check_ioctl_t                  *mpo_pipe_check_ioctl;
	mpo_pipe_check_kqfilter_t               *mpo_pipe_check_kqfilter;
	mpo_reserved_hook_t                     *mpo_reserved41;
	mpo_pipe_check_read_t                   *mpo_pipe_check_read;
	mpo_pipe_check_select_t                 *mpo_pipe_check_select;
	mpo_pipe_check_stat_t                   *mpo_pipe_check_stat;
	mpo_pipe_check_write_t                  *mpo_pipe_check_write;
	mpo_pipe_label_associate_t              *mpo_pipe_label_associate;
	mpo_reserved_hook_t                     *mpo_reserved42;
	mpo_pipe_label_destroy_t                *mpo_pipe_label_destroy;
	mpo_reserved_hook_t                     *mpo_reserved43;
	mpo_pipe_label_init_t                   *mpo_pipe_label_init;
	mpo_reserved_hook_t                     *mpo_reserved44;
	mpo_proc_check_syscall_mac_t            *mpo_proc_check_syscall_mac;

	mpo_policy_destroy_t                    *mpo_policy_destroy;
	mpo_policy_init_t                       *mpo_policy_init;
	mpo_policy_initbsd_t                    *mpo_policy_initbsd;
	mpo_policy_syscall_t                    *mpo_policy_syscall;

	mpo_system_check_sysctlbyname_t         *mpo_system_check_sysctlbyname;
	mpo_proc_check_inherit_ipc_ports_t      *mpo_proc_check_inherit_ipc_ports;
	mpo_vnode_check_rename_t                *mpo_vnode_check_rename;
	mpo_kext_check_query_t                  *mpo_kext_check_query;
	mpo_proc_notify_exec_complete_t         *mpo_proc_notify_exec_complete;
	mpo_proc_notify_cs_invalidated_t        *mpo_proc_notify_cs_invalidated;
	mpo_proc_check_syscall_unix_t           *mpo_proc_check_syscall_unix;
	mpo_reserved_hook_t                     *mpo_reserved45;
	mpo_proc_check_set_host_special_port_t  *mpo_proc_check_set_host_special_port;
	mpo_proc_check_set_host_exception_port_t *mpo_proc_check_set_host_exception_port;
	mpo_exc_action_check_exception_send_t   *mpo_exc_action_check_exception_send;
	mpo_exc_action_label_associate_t        *mpo_exc_action_label_associate;
	mpo_exc_action_label_populate_t         *mpo_exc_action_label_populate;
	mpo_exc_action_label_destroy_t          *mpo_exc_action_label_destroy;
	mpo_exc_action_label_init_t             *mpo_exc_action_label_init;
	mpo_exc_action_label_update_t           *mpo_exc_action_label_update;

	mpo_vnode_check_trigger_resolve_t       *mpo_vnode_check_trigger_resolve;
	mpo_mount_check_mount_late_t            *mpo_mount_check_mount_late;
	mpo_mount_check_snapshot_mount_t        *mpo_mount_check_snapshot_mount;
	mpo_vnode_notify_reclaim_t              *mpo_vnode_notify_reclaim;
	mpo_skywalk_flow_check_connect_t        *mpo_skywalk_flow_check_connect;
	mpo_skywalk_flow_check_listen_t         *mpo_skywalk_flow_check_listen;

	mpo_posixsem_check_create_t             *mpo_posixsem_check_create;
	mpo_posixsem_check_open_t               *mpo_posixsem_check_open;
	mpo_posixsem_check_post_t               *mpo_posixsem_check_post;
	mpo_posixsem_check_unlink_t             *mpo_posixsem_check_unlink;
	mpo_posixsem_check_wait_t               *mpo_posixsem_check_wait;
	mpo_posixsem_label_associate_t          *mpo_posixsem_label_associate;
	mpo_posixsem_label_destroy_t            *mpo_posixsem_label_destroy;
	mpo_posixsem_label_init_t               *mpo_posixsem_label_init;
	mpo_posixshm_check_create_t             *mpo_posixshm_check_create;
	mpo_posixshm_check_mmap_t               *mpo_posixshm_check_mmap;
	mpo_posixshm_check_open_t               *mpo_posixshm_check_open;
	mpo_posixshm_check_stat_t               *mpo_posixshm_check_stat;
	mpo_posixshm_check_truncate_t           *mpo_posixshm_check_truncate;
	mpo_posixshm_check_unlink_t             *mpo_posixshm_check_unlink;
	mpo_posixshm_label_associate_t          *mpo_posixshm_label_associate;
	mpo_posixshm_label_destroy_t            *mpo_posixshm_label_destroy;
	mpo_posixshm_label_init_t               *mpo_posixshm_label_init;

	mpo_proc_check_debug_t                  *mpo_proc_check_debug;
	mpo_proc_check_fork_t                   *mpo_proc_check_fork;
	mpo_reserved_hook_t                     *mpo_reserved61;
	mpo_reserved_hook_t                     *mpo_reserved62;
	mpo_proc_check_getaudit_t               *mpo_proc_check_getaudit;
	mpo_proc_check_getauid_t                *mpo_proc_check_getauid;
	mpo_reserved_hook_t                     *mpo_reserved63;
	mpo_proc_check_mprotect_t               *mpo_proc_check_mprotect;
	mpo_proc_check_sched_t                  *mpo_proc_check_sched;
	mpo_proc_check_setaudit_t               *mpo_proc_check_setaudit;
	mpo_proc_check_setauid_t                *mpo_proc_check_setauid;
	mpo_reserved_hook_t                     *mpo_reserved64;
	mpo_proc_check_signal_t                 *mpo_proc_check_signal;
	mpo_proc_check_wait_t                   *mpo_proc_check_wait;
	mpo_proc_check_dump_core_t              *mpo_proc_check_dump_core;
	mpo_proc_check_remote_thread_create_t   *mpo_proc_check_remote_thread_create;

	mpo_socket_check_accept_t               *mpo_socket_check_accept;
	mpo_socket_check_accepted_t             *mpo_socket_check_accepted;
	mpo_socket_check_bind_t                 *mpo_socket_check_bind;
	mpo_socket_check_connect_t              *mpo_socket_check_connect;
	mpo_socket_check_create_t               *mpo_socket_check_create;
	mpo_reserved_hook_t                     *mpo_reserved46;
	mpo_reserved_hook_t                     *mpo_reserved47;
	mpo_reserved_hook_t                     *mpo_reserved48;
	mpo_socket_check_listen_t               *mpo_socket_check_listen;
	mpo_socket_check_receive_t              *mpo_socket_check_receive;
	mpo_socket_check_received_t             *mpo_socket_check_received;
	mpo_reserved_hook_t                     *mpo_reserved49;
	mpo_socket_check_send_t                 *mpo_socket_check_send;
	mpo_socket_check_stat_t                 *mpo_socket_check_stat;
	mpo_socket_check_setsockopt_t           *mpo_socket_check_setsockopt;
	mpo_socket_check_getsockopt_t           *mpo_socket_check_getsockopt;

	mpo_proc_check_get_movable_control_port_t *mpo_proc_check_get_movable_control_port;
	mpo_proc_check_dyld_process_info_notify_register_t *mpo_proc_check_dyld_process_info_notify_register;
	mpo_proc_check_setuid_t                 *mpo_proc_check_setuid;
	mpo_proc_check_seteuid_t                *mpo_proc_check_seteuid;
	mpo_proc_check_setreuid_t               *mpo_proc_check_setreuid;
	mpo_proc_check_setgid_t                 *mpo_proc_check_setgid;
	mpo_proc_check_setegid_t                *mpo_proc_check_setegid;
	mpo_proc_check_setregid_t               *mpo_proc_check_setregid;
	mpo_proc_check_settid_t                 *mpo_proc_check_settid;
	mpo_proc_check_memorystatus_control_t   *mpo_proc_check_memorystatus_control;
	mpo_reserved_hook_t                     *mpo_reserved60;

	mpo_thread_telemetry_t                  *mpo_thread_telemetry;

	mpo_iokit_check_open_service_t          *mpo_iokit_check_open_service;

	mpo_system_check_acct_t                 *mpo_system_check_acct;
	mpo_system_check_audit_t                *mpo_system_check_audit;
	mpo_system_check_auditctl_t             *mpo_system_check_auditctl;
	mpo_system_check_auditon_t              *mpo_system_check_auditon;
	mpo_system_check_host_priv_t            *mpo_system_check_host_priv;
	mpo_system_check_nfsd_t                 *mpo_system_check_nfsd;
	mpo_system_check_reboot_t               *mpo_system_check_reboot;
	mpo_system_check_settime_t              *mpo_system_check_settime;
	mpo_system_check_swapoff_t              *mpo_system_check_swapoff;
	mpo_system_check_swapon_t               *mpo_system_check_swapon;
	mpo_socket_check_ioctl_t                *mpo_socket_check_ioctl;

	mpo_sysvmsg_label_associate_t           *mpo_sysvmsg_label_associate;
	mpo_sysvmsg_label_destroy_t             *mpo_sysvmsg_label_destroy;
	mpo_sysvmsg_label_init_t                *mpo_sysvmsg_label_init;
	mpo_sysvmsg_label_recycle_t             *mpo_sysvmsg_label_recycle;
	mpo_sysvmsq_check_enqueue_t             *mpo_sysvmsq_check_enqueue;
	mpo_sysvmsq_check_msgrcv_t              *mpo_sysvmsq_check_msgrcv;
	mpo_sysvmsq_check_msgrmid_t             *mpo_sysvmsq_check_msgrmid;
	mpo_sysvmsq_check_msqctl_t              *mpo_sysvmsq_check_msqctl;
	mpo_sysvmsq_check_msqget_t              *mpo_sysvmsq_check_msqget;
	mpo_sysvmsq_check_msqrcv_t              *mpo_sysvmsq_check_msqrcv;
	mpo_sysvmsq_check_msqsnd_t              *mpo_sysvmsq_check_msqsnd;
	mpo_sysvmsq_label_associate_t           *mpo_sysvmsq_label_associate;
	mpo_sysvmsq_label_destroy_t             *mpo_sysvmsq_label_destroy;
	mpo_sysvmsq_label_init_t                *mpo_sysvmsq_label_init;
	mpo_sysvmsq_label_recycle_t             *mpo_sysvmsq_label_recycle;
	mpo_sysvsem_check_semctl_t              *mpo_sysvsem_check_semctl;
	mpo_sysvsem_check_semget_t              *mpo_sysvsem_check_semget;
	mpo_sysvsem_check_semop_t               *mpo_sysvsem_check_semop;
	mpo_sysvsem_label_associate_t           *mpo_sysvsem_label_associate;
	mpo_sysvsem_label_destroy_t             *mpo_sysvsem_label_destroy;
	mpo_sysvsem_label_init_t                *mpo_sysvsem_label_init;
	mpo_sysvsem_label_recycle_t             *mpo_sysvsem_label_recycle;
	mpo_sysvshm_check_shmat_t               *mpo_sysvshm_check_shmat;
	mpo_sysvshm_check_shmctl_t              *mpo_sysvshm_check_shmctl;
	mpo_sysvshm_check_shmdt_t               *mpo_sysvshm_check_shmdt;
	mpo_sysvshm_check_shmget_t              *mpo_sysvshm_check_shmget;
	mpo_sysvshm_label_associate_t           *mpo_sysvshm_label_associate;
	mpo_sysvshm_label_destroy_t             *mpo_sysvshm_label_destroy;
	mpo_sysvshm_label_init_t                *mpo_sysvshm_label_init;
	mpo_sysvshm_label_recycle_t             *mpo_sysvshm_label_recycle;

	mpo_proc_notify_exit_t                  *mpo_proc_notify_exit;
	mpo_mount_check_snapshot_revert_t       *mpo_mount_check_snapshot_revert;
	mpo_vnode_check_getattr_t               *mpo_vnode_check_getattr;
	mpo_mount_check_snapshot_create_t       *mpo_mount_check_snapshot_create;
	mpo_mount_check_snapshot_delete_t       *mpo_mount_check_snapshot_delete;
	mpo_vnode_check_clone_t                 *mpo_vnode_check_clone;
	mpo_proc_check_get_cs_info_t            *mpo_proc_check_get_cs_info;
	mpo_proc_check_set_cs_info_t            *mpo_proc_check_set_cs_info;

	mpo_iokit_check_hid_control_t           *mpo_iokit_check_hid_control;

	mpo_vnode_check_access_t                *mpo_vnode_check_access;
	mpo_vnode_check_chdir_t                 *mpo_vnode_check_chdir;
	mpo_vnode_check_chroot_t                *mpo_vnode_check_chroot;
	mpo_vnode_check_create_t                *mpo_vnode_check_create;
	mpo_vnode_check_deleteextattr_t         *mpo_vnode_check_deleteextattr;
	mpo_vnode_check_exchangedata_t          *mpo_vnode_check_exchangedata;
	mpo_vnode_check_exec_t                  *mpo_vnode_check_exec;
	mpo_vnode_check_getattrlist_t           *mpo_vnode_check_getattrlist;
	mpo_vnode_check_getextattr_t            *mpo_vnode_check_getextattr;
	mpo_vnode_check_ioctl_t                 *mpo_vnode_check_ioctl;
	mpo_vnode_check_kqfilter_t              *mpo_vnode_check_kqfilter;
	mpo_vnode_check_label_update_t          *mpo_vnode_check_label_update;
	mpo_vnode_check_link_t                  *mpo_vnode_check_link;
	mpo_vnode_check_listextattr_t           *mpo_vnode_check_listextattr;
	mpo_vnode_check_lookup_t                *mpo_vnode_check_lookup;
	mpo_vnode_check_open_t                  *mpo_vnode_check_open;
	mpo_vnode_check_read_t                  *mpo_vnode_check_read;
	mpo_vnode_check_readdir_t               *mpo_vnode_check_readdir;
	mpo_vnode_check_readlink_t              *mpo_vnode_check_readlink;
	mpo_vnode_check_rename_from_t           *mpo_vnode_check_rename_from;
	mpo_vnode_check_rename_to_t             *mpo_vnode_check_rename_to;
	mpo_vnode_check_revoke_t                *mpo_vnode_check_revoke;
	mpo_vnode_check_select_t                *mpo_vnode_check_select;
	mpo_vnode_check_setattrlist_t           *mpo_vnode_check_setattrlist;
	mpo_vnode_check_setextattr_t            *mpo_vnode_check_setextattr;
	mpo_vnode_check_setflags_t              *mpo_vnode_check_setflags;
	mpo_vnode_check_setmode_t               *mpo_vnode_check_setmode;
	mpo_vnode_check_setowner_t              *mpo_vnode_check_setowner;
	mpo_vnode_check_setutimes_t             *mpo_vnode_check_setutimes;
	mpo_vnode_check_stat_t                  *mpo_vnode_check_stat;
	mpo_vnode_check_truncate_t              *mpo_vnode_check_truncate;
	mpo_vnode_check_unlink_t                *mpo_vnode_check_unlink;
	mpo_vnode_check_write_t                 *mpo_vnode_check_write;
	mpo_vnode_label_associate_devfs_t       *mpo_vnode_label_associate_devfs;
	mpo_vnode_label_associate_extattr_t     *mpo_vnode_label_associate_extattr;
	mpo_vnode_label_associate_file_t        *mpo_vnode_label_associate_file;
	mpo_vnode_label_associate_pipe_t        *mpo_vnode_label_associate_pipe;
	mpo_vnode_label_associate_posixsem_t    *mpo_vnode_label_associate_posixsem;
	mpo_vnode_label_associate_posixshm_t    *mpo_vnode_label_associate_posixshm;
	mpo_vnode_label_associate_singlelabel_t *mpo_vnode_label_associate_singlelabel;
	mpo_vnode_label_associate_socket_t      *mpo_vnode_label_associate_socket;
	mpo_vnode_label_copy_t                  *mpo_vnode_label_copy;
	mpo_vnode_label_destroy_t               *mpo_vnode_label_destroy;
	mpo_vnode_label_externalize_audit_t     *mpo_vnode_label_externalize_audit;
	mpo_vnode_label_externalize_t           *mpo_vnode_label_externalize;
	mpo_vnode_label_init_t                  *mpo_vnode_label_init;
	mpo_vnode_label_internalize_t           *mpo_vnode_label_internalize;
	mpo_vnode_label_recycle_t               *mpo_vnode_label_recycle;
	mpo_vnode_label_store_t                 *mpo_vnode_label_store;
	mpo_vnode_label_update_extattr_t        *mpo_vnode_label_update_extattr;
	mpo_vnode_label_update_t                *mpo_vnode_label_update;
	mpo_vnode_notify_create_t               *mpo_vnode_notify_create;
	mpo_vnode_check_signature_t             *mpo_vnode_check_signature;
	mpo_vnode_check_uipc_bind_t             *mpo_vnode_check_uipc_bind;
	mpo_vnode_check_uipc_connect_t          *mpo_vnode_check_uipc_connect;

	mpo_proc_check_run_cs_invalid_t         *mpo_proc_check_run_cs_invalid;
	mpo_proc_check_suspend_resume_t         *mpo_proc_check_suspend_resume;

	mpo_thread_userret_t                    *mpo_thread_userret;

	mpo_iokit_check_set_properties_t        *mpo_iokit_check_set_properties;

	mpo_vnode_check_supplemental_signature_t *mpo_vnode_check_supplemental_signature;

	mpo_vnode_check_searchfs_t              *mpo_vnode_check_searchfs;

	mpo_priv_check_t                        *mpo_priv_check;
	mpo_priv_grant_t                        *mpo_priv_grant;

	mpo_proc_check_map_anon_t               *mpo_proc_check_map_anon;

	mpo_vnode_check_fsgetpath_t             *mpo_vnode_check_fsgetpath;

	mpo_iokit_check_open_t                  *mpo_iokit_check_open;

	mpo_proc_check_ledger_t                 *mpo_proc_check_ledger;

	mpo_vnode_notify_rename_t               *mpo_vnode_notify_rename;

	mpo_vnode_check_setacl_t                *mpo_vnode_check_setacl;

	mpo_vnode_notify_deleteextattr_t        *mpo_vnode_notify_deleteextattr;

	mpo_system_check_kas_info_t             *mpo_system_check_kas_info;

	mpo_vnode_check_lookup_preflight_t      *mpo_vnode_check_lookup_preflight;

	mpo_vnode_notify_open_t                 *mpo_vnode_notify_open;

	mpo_system_check_info_t                 *mpo_system_check_info;

	mpo_pty_notify_grant_t                  *mpo_pty_notify_grant;
	mpo_pty_notify_close_t                  *mpo_pty_notify_close;

	mpo_vnode_find_sigs_t                   *mpo_vnode_find_sigs;

	mpo_kext_check_load_t                   *mpo_kext_check_load;
	mpo_kext_check_unload_t                 *mpo_kext_check_unload;

	mpo_proc_check_proc_info_t              *mpo_proc_check_proc_info;
	mpo_vnode_notify_link_t                 *mpo_vnode_notify_link;
	mpo_iokit_check_filter_properties_t     *mpo_iokit_check_filter_properties;
	mpo_iokit_check_get_property_t          *mpo_iokit_check_get_property;
};
struct mac_policy_conf {
	const char              *mpc_name;              
	const char              *mpc_fullname;          
	char const * const *mpc_labelnames;     
	unsigned int             mpc_labelname_count;   
	const struct mac_policy_ops     *mpc_ops;               
	int                      mpc_loadtime_flags;    
	int                     *mpc_field_off;         
	int                      mpc_runtime_flags;     
	mpc_t                    mpc_list;              
	void                    *mpc_data;              
};
struct label {
	struct label **l_owner;
	long           l_perpolicy[MAC_MAX_SLOTS];
};
struct cred_backtrace {
	int                             depth;
	uint32_t                stack[MAX_STACK_DEPTH];
};
struct cred_debug_buffer {
	int                             next_slot;
	cred_backtrace  stack_buffer[1];
};
struct debug_ucred {
	uint32_t        credp;
	uint32_t        cr_ref;                         
	uid_t           cr_uid;                         
	uid_t           cr_ruid;                        
	uid_t           cr_svuid;                       
	u_short         cr_ngroups;                     
	gid_t           cr_groups[NGROUPS];     
	gid_t           cr_rgid;                        
	gid_t           cr_svgid;                       
	uid_t           cr_gmuid;                       
	struct auditinfo_addr cr_audit;                 
	uint32_t        cr_label;                       
	int                     cr_flags;                       
};
struct zone_view {
	void *zv_zone;
	void *zv_stats;
	const char *zv_name;
	void *zv_next;
};
struct kalloc_type_view {
	struct zone_view    kt_zv;
	const char         *kt_signature;
	kalloc_type_flags_t kt_flags;
	uint32_t            kt_size;
	struct zone        *kt_zearly;
	struct zone        *kt_zsig;
};
struct kalloc_type_var_view {
	kalloc_type_version_t   kt_version;
	uint16_t                kt_size_hdr;
	uint32_t                kt_size_type;
	struct zone_stats      *kt_stats;
	const char             *kt_name;
	struct zone_view       *kt_next;
	uint16_t                kt_heap_start;
	uint8_t                 kt_zones[KHEAP_NUM_ZONES];
	const char             *kt_sig_hdr;
	const char             *kt_sig_type;
	kalloc_type_flags_t     kt_flags;
};
struct macho_section {
	section_64 section;
	std::span<const T> contents;

	macho_section(const section_64 &sec, std::span<uint8_t> data)
		: section(sec),
		contents(reinterpret_cast<T *>(
			    data.subspan(sec.offset, sec.size / sizeof(T)).data()),
		    sec.size / sizeof(T))
	{
	}

	size_t
	elem_size() const
	{
		return sizeof(T);
	}

	size_t
	elem_count() const
	{
		return section.size / elem_size();
	}
};
struct file_list {
	struct  file_list *f_next;
	char    *f_fn;                  
	u_char  f_type;                 
	u_char  f_flags;                
	short   f_special;              
	char    *f_needs;
	char    *f_extra;               
};
struct device {
	int     d_type;                 
	const char      *d_name;        
	int     d_slave;                
	int     d_flags;                
	struct  device *d_next;         
	char    *d_init;                
};
struct opt {
	char    *op_name;
	char    *op_value;
	struct  opt *op_next;
};
struct symbol {
	char * name;
	unsigned int name_len;
	char * indirect;
	unsigned int indirect_len;
	unsigned int flags;
	struct symbol * list;
	unsigned int list_count;
};
struct bsearch_key {
	char * name;
	unsigned int name_len;
};
struct ksancov_od_module_entry {
	char     bundle[KMOD_MAX_NAME]; 
	uint32_t idx; 
};
struct ksancov_od_module_handle {
	uint32_t *start; 
	uint32_t *stop;
	uint64_t *gate; 
};
struct asan_global_source_location {
	const char *filename;
	int line_no;
	int column_no;
};
struct asan_global {
	uptr addr;
	uptr size;
	uptr size_with_redzone;
	const char *name;
	const char *module;
	uptr has_dynamic_init;
	struct asan_global_source_location *location;
};
struct kasan_alloc_header {
	union {
		struct {
			kasan_alloc_state_t state;
			uint16_t left_rz;
			uint32_t user_size;
		};
		struct {
			kasan_alloc_state_t state2;
			intptr_t next : 48;
		};
	};
	btref_t  alloc_btref;
	btref_t  free_btref;
} *kasan_alloc_header_t;
struct kasan_quarantine {
	kasan_alloc_header_t  head;
	kasan_alloc_header_t  tail;
	uint32_t              size;
	uint32_t              count;
} *kasan_quarantine_t;
struct kasan_quarantine_result {
	vm_address_t            addr;
	struct zone            *zone;
};
struct {
	unsigned int pml4   : 9;
	unsigned int pdpt   : 9;
	unsigned int pd     : 9;
	unsigned int pt     : 9;
	unsigned int offset : 12;
} split_addr_t;
struct san_type_desc {
	uint16_t type; 
	union {
		struct {
			uint16_t issigned : 1;
			uint16_t width    : 15;
		}; 
		struct {
			uint16_t float_desc;
		}; 
	};
	const char name[];
};
struct san_src_loc {
	const char *filename;
	uint32_t line;
	uint32_t col;
};
struct ubsan_overflow_desc {
	struct san_src_loc loc;
	struct san_type_desc *ty;
};
struct ubsan_unreachable_desc {
	struct san_src_loc loc;
};
struct ubsan_shift_desc {
	struct san_src_loc loc;
	struct san_type_desc *lhs_t;
	struct san_type_desc *rhs_t;
};
struct ubsan_align_desc {
	struct san_src_loc loc;
	struct san_type_desc *ty;
	uint8_t align;
	uint8_t kind;
};
struct ubsan_ptroverflow_desc {
	struct san_src_loc loc;
};
struct ubsan_oob_desc {
	struct san_src_loc loc;
	struct san_type_desc *array_ty;
	struct san_type_desc *index_ty;
};
struct ubsan_load_invalid_desc {
	struct san_src_loc loc;
	struct san_type_desc *type;
};
struct ubsan_nullability_arg_desc {
	struct san_src_loc loc;
	struct san_src_loc attr_loc;
	int arg_index;
};
struct ubsan_nullability_ret_desc {
	struct san_src_loc loc;
};
struct ubsan_missing_ret_desc {
	struct san_src_loc loc;
};
struct ubsan_float_desc {
	struct san_src_loc loc;
	struct san_type_desc *type_from;
	struct san_type_desc *type_to;
};
struct ubsan_implicit_conv_desc {
	struct san_src_loc loc;
	struct san_type_desc *type_from;
	struct san_type_desc *type_to;
	unsigned char kind;
};
struct ubsan_func_type_mismatch_desc {
	struct san_src_loc loc;
	struct san_type_desc *type;
};
struct ubsan_vla_bound_desc {
	struct san_src_loc loc;
	struct san_type_desc *type;
};
struct ubsan_invalid_builtin {
	struct san_src_loc loc;
	unsigned char kind;
};
struct ubsan_violation {
	ubsan_violation_type_t ubsan_type;
	uint64_t lhs;
	uint64_t rhs;
	union {
		struct ubsan_overflow_desc *overflow;
		struct ubsan_unreachable_desc *unreachable;
		struct ubsan_shift_desc *shift;
		struct ubsan_align_desc *align;
		struct ubsan_ptroverflow_desc *ptroverflow;
		struct ubsan_oob_desc *oob;
		struct ubsan_load_invalid_desc *invalid;
		struct ubsan_nullability_arg_desc *nonnull_arg;
		struct ubsan_nullability_ret_desc *nonnull_ret;
		struct ubsan_missing_ret_desc *missing_ret;
		struct ubsan_float_desc *flt;
		struct ubsan_implicit_conv_desc *implicit;
		struct ubsan_func_type_mismatch_desc *func_mismatch;
		struct ubsan_vla_bound_desc *vla_bound;
		struct ubsan_invalid_builtin *invalid_builtin;
		const char *func;
	};
	struct san_src_loc *loc;
} ubsan_violation_t;
struct ubsan_buf {
	char    *ub_buf;
	size_t  ub_buf_size;
	size_t  ub_written;
	bool    ub_err;
} ubsan_buf_t;
struct ubsan_minimal_trap_desc {
	uint16_t        id;
	uint32_t        flags;
	char            str[16];
};
struct ksancov_state {
	ksancov_mode_t       ks_mode;
	ksancov_edgemap_t    *ks_edgemap;
	union {
		ksancov_header_t       *ks_header;
		ksancov_trace_t        *ks_trace;
		ksancov_counters_t     *ks_counters;
	};
} ksancov_state_t;
struct ksancov_buf_desc {
	uintptr_t ptr;  
	size_t sz;      
};
struct ksancov_header {
	uint32_t         kh_magic;
	_Atomic uint32_t kh_enabled;
} ksancov_header_t;
struct ksancov_trace {
	ksancov_header_t kt_hdr;         
	uint32_t         kt_maxent;      
	_Atomic uint32_t kt_head;        
	uint64_t         kt_entries[];   
} ksancov_trace_t;
struct ksancov_trace_stksize_entry {
	uintptr_t pc;                      
	uint32_t  stksize;                 
} ksancov_trace_stksize_ent_t;
struct ksancov_counters {
	ksancov_header_t kc_hdr;
	uint32_t         kc_nedges;       
	uint8_t          kc_hits[];       
} ksancov_counters_t;
struct ksancov_edgemap {
	uint32_t  ke_magic;
	uint32_t  ke_nedges;
	uintptr_t ke_addrs[];             
} ksancov_edgemap_t;
struct ksancov_on_demand_msg {
	char bundle[ 64];
	ksancov_on_demand_operation_t operation;
	union {
		uint64_t gate;
		struct {
			uint32_t start;
			uint32_t stop;
		} range;
	};
};
struct pe_serial_functions {
	void (*init) (void);

	unsigned int (*transmit_ready) (void);

	void (*transmit_data) (uint8_t c);

	unsigned int (*receive_ready) (void);

	uint8_t (*receive_data) (void);

	void (*enable_irq) (void);

	bool (*disable_irq) (void);

	bool (*acknowledge_irq) (void);

	bool has_irq;

	serial_device_t device;

	struct pe_serial_functions *next;
};
struct {
	const char *const compatible;
	void(*const setup)(const DeviceTreeNode * const devicetree_node);
} driver_setup_functions[] = {
};
struct i24 {
	int32_t i24 : 24;
	int32_t _pad : 8;
};
struct i386_interrupt_handler {
	IOInterruptHandler      handler;
	void                    *nub;
	void                    *target;
	void                    *refCon;
};
struct pe_serial_functions {
	void            (*uart_init) (void);
	void            (*uart_set_baud_rate) (int unit, uint32_t baud_rate);
	int             (*tr0) (void);
	void            (*td0) (int c);
	int             (*rr0) (void);
	int             (*rd0) (void);
};
struct DeviceTreeNodeProperty {
	char                name[kPropNameLength];
	uint32_t            length;     

} DeviceTreeNodeProperty;
struct OpaqueDTEntry {
	uint32_t            nProperties;
	uint32_t            nChildren;  


} DeviceTreeNode;
struct DTSavedScope {
	struct DTSavedScope * nextScope;
	RealDTEntry scope;
	RealDTEntry entry;
	unsigned long index;
} *DTSavedScopePtr;
struct OpaqueDTEntryIterator {
	RealDTEntry outerScope;
	RealDTEntry currentScope;
	RealDTEntry currentEntry;
	DTSavedScopePtr savedScope;
	unsigned long currentIndex;
} OpaqueDTEntryIterator, *DTEntryIterator;
struct OpaqueDTPropertyIterator {
	RealDTEntry entry;
	DeviceTreeNodeProperty const *currentProperty;
	unsigned long currentIndex;
} OpaqueDTPropertyIterator, *DTPropertyIterator;
struct DTMemoryMapRange {
	vm_offset_t paddr;
	size_t length;
} DTMemoryMapRange;
struct clock_frequency_info_t {
	unsigned long bus_clock_rate_hz;
	unsigned long cpu_clock_rate_hz;
	unsigned long dec_clock_rate_hz;
	unsigned long bus_clock_rate_num;
	unsigned long bus_clock_rate_den;
	unsigned long bus_to_cpu_rate_num;
	unsigned long bus_to_cpu_rate_den;
	unsigned long bus_to_dec_rate_num;
	unsigned long bus_to_dec_rate_den;
	unsigned long timebase_frequency_hz;
	unsigned long timebase_frequency_num;
	unsigned long timebase_frequency_den;
	unsigned long long bus_frequency_hz;
	unsigned long long bus_frequency_min_hz;
	unsigned long long bus_frequency_max_hz;
	unsigned long long cpu_frequency_hz;
	unsigned long long cpu_frequency_min_hz;
	unsigned long long cpu_frequency_max_hz;
	unsigned long long prf_frequency_hz;
	unsigned long long prf_frequency_min_hz;
	unsigned long long prf_frequency_max_hz;
	unsigned long long mem_frequency_hz;
	unsigned long long mem_frequency_min_hz;
	unsigned long long mem_frequency_max_hz;
	unsigned long long fix_frequency_hz;
};
struct timebase_freq_t {
	unsigned long timebase_num;
	unsigned long timebase_den;
};
struct PE_Video {
	unsigned long   v_baseAddr;     
	unsigned long   v_rowBytes;     
	unsigned long   v_width;        
	unsigned long   v_height;       
	unsigned long   v_depth;        
	unsigned long   v_display;      
	char            v_pixelFormat[64];
	unsigned long   v_offset;       
	unsigned long   v_length;       
	unsigned char   v_rotate;       
	unsigned char   v_scale;        
	char            reserved1[2];
	long            reserved2;
};
struct PE_state {
	boolean_t       initialized;
	PE_Video        video;
	void            *deviceTreeHead;
	void            *bootArgs;
	vm_size_t       deviceTreeSize;
} PE_state_t;
struct PE_panic_save_context {
	void *psc_buffer;
	uint32_t psc_offset;
	uint32_t psc_length;
} PE_panic_save_context_t;
struct boot_progress_element {
	unsigned int        width;
	unsigned int        height;
	int                 yOffset;
	unsigned int        res[5];
	unsigned char       data[0];
};
struct {
	ulcon_t ulcon;
	ucon_t ucon;
	ufcon_t ufcon;
	uint32_t umcon;
	utrstat_t utrstat;
	uint32_t uerstat;
	ufstat_t ufstat;
	uint32_t umstat;
	utxh_t utxh;
	urxh_t urxh;
	ubrdiv_t ubrdiv;
	uint32_t uabrcnt;
	uint8_t rsvd0[4];
	uint32_t utxoffset;
	uint32_t urxoffset;
	uint32_t uver;
} apple_uart_registers_t;
struct Boot_Video {
	unsigned long   v_baseAddr;     
	unsigned long   v_display;      
	unsigned long   v_rowBytes;     
	unsigned long   v_width;        
	unsigned long   v_height;       
	unsigned long   v_depth;        
};
struct boot_args {
	uint16_t                Revision;                       
	uint16_t                Version;                        
	uint32_t                virtBase;                       
	uint32_t                physBase;                       
	uint32_t                memSize;                        
	uint32_t                topOfKernelData;        
	Boot_Video              Video;                          
	uint32_t                machineType;            
	void                    *deviceTreeP;           
	uint32_t                deviceTreeLength;       
	char                    CommandLine[BOOT_LINE_LENGTH];  
	uint32_t                bootFlags;              
	uint32_t                memSizeActual;          
} boot_args;
struct {
	uint64_t record_id;             
	uint32_t num_records;           
	uint32_t record_size_bytes;     
} dbg_top_level_header_t;
struct {
	uint64_t record_id; 
	uint64_t length;    
	uint64_t physaddr;  
} dbg_record_header_t;
struct {
	uint64_t timestamp;
	uint32_t cp_state;          
	uint32_t cp_state_arg;      
} dbg_cpr_state_entry_t;
struct {
	uint32_t rdptr;
	uint32_t wrptr;
	uint32_t num_cp_state_entries;
	uint32_t checksum;
	dbg_cpr_state_entry_t cp_state_entries[CPR_MAX_STATE_ENTRIES];
} dbg_cpr_t;
struct {
	dbg_top_level_header_t  top_level_header;
	dbg_record_header_t     records[DEBUG_REGISTRY_MAX_RECORDS];

	dbg_cpr_t               ap_cpr_region;
} dbg_registry_t;
struct {
	uartdr_t uartdr;
	uartrsr_uartecr_t uartrsr_uartecr;
	uint8_t _reserved0[0x10];
	uartfr_t uartfr;
	uint8_t _reserved1[0x4];
	uartilpr_t uartilpr;
	uartibrd_t uartibrd;
	uartfbrd_t uartfbrd;
	uartlcr_h_t uartlcr_h;
	uartcr_t uartcr;
	uartifls_t uartifls;
	uartimsc_t uartimsc;
	uartris_t uartris;
	uartmis_t uartmis;
	uarticr_t uarticr;
	uartdmacr_t uartdmacr;
	uint8_t _reserved2[0x34];
	uint8_t _reserved3[0x10];
	uint8_t _reserved4[0xf40];
	uint8_t _reserved5[0x10];
	uart_periph_id0_t uart_periph_id0;
	uart_periph_id1_t uart_periph_id1;
	uart_periph_id2_t uart_periph_id2;
	uart_periph_id3_t uart_periph_id3;
	uart_pcell_id0_t uart_pcell_id0;
	uart_pcell_id1_t uart_pcell_id1;
	uart_pcell_id2_t uart_pcell_id2;
	uart_pcell_id3_t uart_pcell_id3;
} pl011_registers_t;
struct Boot_Video {
	unsigned long   v_baseAddr;     
	unsigned long   v_display;      
	unsigned long   v_rowBytes;     
	unsigned long   v_width;        
	unsigned long   v_height;       
	unsigned long   v_depth;        
};
struct boot_args {
	uint16_t                Revision;                       
	uint16_t                Version;                        
	uint64_t                virtBase;                       
	uint64_t                physBase;                       
	uint64_t                memSize;                        
	uint64_t                topOfKernelData;        
	Boot_Video              Video;                          
	uint32_t                machineType;            
	void                    *deviceTreeP;           
	uint32_t                deviceTreeLength;       
	char                    CommandLine[BOOT_LINE_LENGTH];  
	uint64_t                bootFlags;              
	uint64_t                memSizeActual;          
} boot_args;
struct EfiMemoryRange {
	uint32_t Type;
	uint32_t Pad;
	uint64_t PhysicalStart;
	uint64_t VirtualStart;
	uint64_t NumberOfPages;
	uint64_t Attribute;
} EfiMemoryRange;
struct Boot_VideoV1 {
	uint32_t        v_baseAddr;     
	uint32_t        v_display;      
	uint32_t        v_rowBytes;     
	uint32_t        v_width;        
	uint32_t        v_height;       
	uint32_t        v_depth;        
};
struct Boot_Video {
	uint32_t        v_display;      
	uint32_t        v_rowBytes;     
	uint32_t        v_width;        
	uint32_t        v_height;       
	uint32_t        v_depth;        
	uint8_t         v_rotate;       
	uint8_t         v_resv_byte[3]; 
	uint32_t        v_resv[6];      
	uint64_t        v_baseAddr;     
};
struct boot_icon_element {
	unsigned int    width;
	unsigned int    height;
	int             y_offset_from_center;
	unsigned int    data_size;
	unsigned int    __reserved1[4];
	unsigned char   data[0];
};
struct boot_args {
	uint16_t    Revision;   
	uint16_t    Version;    

	uint8_t     efiMode;
	uint8_t     debugMode;
	uint16_t    flags;

	char        CommandLine[BOOT_LINE_LENGTH];

	uint32_t    MemoryMap;
	uint32_t    MemoryMapSize;
	uint32_t    MemoryMapDescriptorSize;
	uint32_t    MemoryMapDescriptorVersion;

	Boot_VideoV1 VideoV1;   

	uint32_t    deviceTreeP;  
	uint32_t    deviceTreeLength;

	uint32_t    kaddr;        
	uint32_t    ksize;        

	uint32_t    efiRuntimeServicesPageStart;
	uint32_t    efiRuntimeServicesPageCount;
	uint64_t    efiRuntimeServicesVirtualPageStart;

	uint32_t    efiSystemTable;
	uint32_t    kslide;

	uint32_t    performanceDataStart;
	uint32_t    performanceDataSize;

	uint32_t    keyStoreDataStart;
	uint32_t    keyStoreDataSize;
	uint64_t    bootMemStart;
	uint64_t    bootMemSize;
	uint64_t    PhysicalMemorySize;
	uint64_t    FSBFrequency;
	uint64_t    pciConfigSpaceBaseAddress;
	uint32_t    pciConfigSpaceStartBusNumber;
	uint32_t    pciConfigSpaceEndBusNumber;
	uint32_t    csrActiveConfig;
	uint32_t    csrCapabilities;
	uint32_t    boot_SMC_plimit;
	uint16_t    bootProgressMeterStart;
	uint16_t    bootProgressMeterEnd;
	Boot_Video  Video;      

	uint32_t    apfsDataStart;
	uint32_t    apfsDataSize;

	uint64_t    KC_hdrs_vaddr;

	uint64_t    arvRootHashStart; 
	uint64_t    arvRootHashSize;

	uint64_t    arvManifestStart; 
	uint64_t    arvManifestSize;

	uint64_t    bsARVRootHashStart;
	uint64_t    bsARVRootHashSize;

	uint64_t    bsARVManifestStart;
	uint64_t    bsARVManifestSize;

	uint32_t    __reserved4[692];
} boot_args;
struct {
	EFI_UINT32  Data1;
	EFI_UINT16  Data2;
	EFI_UINT16  Data3;
	EFI_UINT8   Data4[8];
} EFI_GUID;
struct {
	EFI_UINT16  Year;
	EFI_UINT8   Month;
	EFI_UINT8   Day;
	EFI_UINT8   Hour;
	EFI_UINT8   Minute;
	EFI_UINT8   Second;
	EFI_UINT8   Pad1;
	EFI_UINT32  Nanosecond;
	EFI_INT16   TimeZone;
	EFI_UINT8   Daylight;
	EFI_UINT8   Pad2;
} EFI_TIME;
struct {
	EFI_UINT64  Signature;
	EFI_UINT32  Revision;
	EFI_UINT32  HeaderSize;
	EFI_UINT32  CRC32;
	EFI_UINT32  Reserved;
} __attribute__((aligned(8))) EFI_TABLE_HEADER;
struct {
	EFI_UINT32            Type;
	EFI_UINT32            Pad;
	EFI_PHYSICAL_ADDRESS  PhysicalStart;
	EFI_VIRTUAL_ADDRESS   VirtualStart;
	EFI_UINT64            NumberOfPages;
	EFI_UINT64            Attribute;
} __attribute__((aligned(8))) EFI_MEMORY_DESCRIPTOR;
struct {
	EFI_UINT32  Resolution;
	EFI_UINT32  Accuracy;
	EFI_BOOLEAN SetsToZero;
} __attribute__((aligned(4))) EFI_TIME_CAPABILITIES;
struct {
	EFI_TABLE_HEADER              Hdr;

	EFI_PTR32                     GetTime;
	EFI_PTR32                     SetTime;
	EFI_PTR32                     GetWakeupTime;
	EFI_PTR32                     SetWakeupTime;

	EFI_PTR32                     SetVirtualAddressMap;
	EFI_PTR32                     ConvertPointer;

	EFI_PTR32                     GetVariable;
	EFI_PTR32                     GetNextVariableName;
	EFI_PTR32                     SetVariable;

	EFI_PTR32                     GetNextHighMonotonicCount;
	EFI_PTR32                     ResetSystem;

} __attribute__((aligned(8))) EFI_RUNTIME_SERVICES_32;
struct {
	EFI_TABLE_HEADER              Hdr;

	EFI_PTR64                     GetTime;
	EFI_PTR64                     SetTime;
	EFI_PTR64                     GetWakeupTime;
	EFI_PTR64                     SetWakeupTime;

	EFI_PTR64                     SetVirtualAddressMap;
	EFI_PTR64                     ConvertPointer;

	EFI_PTR64                     GetVariable;
	EFI_PTR64                     GetNextVariableName;
	EFI_PTR64                     SetVariable;

	EFI_PTR64                     GetNextHighMonotonicCount;
	EFI_PTR64                     ResetSystem;

} __attribute__((aligned(8))) EFI_RUNTIME_SERVICES_64;
struct {
	EFI_GUID  VendorGuid;
	EFI_PTR32 VendorTable;
} EFI_CONFIGURATION_TABLE_32;
struct {
	EFI_GUID  VendorGuid;
	EFI_PTR64 VendorTable;
} __attribute__((aligned(8))) EFI_CONFIGURATION_TABLE_64;
struct EFI_SYSTEM_TABLE_32 {
	EFI_TABLE_HEADER              Hdr;

	EFI_PTR32                     FirmwareVendor;
	EFI_UINT32                    FirmwareRevision;

	EFI_HANDLE32                  ConsoleInHandle;
	EFI_PTR32                     ConIn;

	EFI_HANDLE32                  ConsoleOutHandle;
	EFI_PTR32                     ConOut;

	EFI_HANDLE32                  StandardErrorHandle;
	EFI_PTR32                     StdErr;

	EFI_PTR32                     RuntimeServices;
	EFI_PTR32                     BootServices;

	EFI_UINT32                    NumberOfTableEntries;
	EFI_PTR32                     ConfigurationTable;
} __attribute__((aligned(8))) EFI_SYSTEM_TABLE_32;
struct EFI_SYSTEM_TABLE_64 {
	EFI_TABLE_HEADER              Hdr;

	EFI_PTR64                     FirmwareVendor;
	EFI_UINT32                    FirmwareRevision;

	EFI_UINT32                    __pad;

	EFI_HANDLE64                  ConsoleInHandle;
	EFI_PTR64                     ConIn;

	EFI_HANDLE64                  ConsoleOutHandle;
	EFI_PTR64                     ConOut;

	EFI_HANDLE64                  StandardErrorHandle;
	EFI_PTR64                     StdErr;

	EFI_PTR64                     RuntimeServices;
	EFI_PTR64                     BootServices;

	EFI_UINT64                    NumberOfTableEntries;
	EFI_PTR64                     ConfigurationTable;
} __attribute__((aligned(8))) EFI_SYSTEM_TABLE_64;
struct {
	uint32_t
	    Ctype1:3, 
	    Ctype2:3, 
	    Ctype3:3, 
	    Ctypes:15, 
	    LoC:3, 
	    LoU:3, 
	    RAZ:2; 
} arm_cache_clidr_t;
struct {
	uint32_t
	    LineSize:3, 
	    Assoc:10, 
	    NumSets:15, 
	    c_type:4; 
} arm_cache_ccsidr_t;
struct {
	uint32_t arm_rev : 4,  
	    arm_part         : 12,
	    arm_arch         : 4,
	    arm_variant      : 4,
	    arm_implementor  : 8;
} arm_cpuid_bits_t;
struct {
	boolean_t    c_valid;            
	boolean_t    c_unified;          
	uint32_t     c_isize;            
	boolean_t    c_i_ppage;          
	uint32_t     c_dsize;            
	boolean_t    c_d_ppage;          
	cache_type_t c_type;             
	uint32_t     c_linesz;           
	uint32_t     c_assoc;            
	uint32_t     c_l2size;           
	uint32_t     c_bulksize_op;      
	uint32_t     c_inner_cache_size; 

} cache_info_t;
struct {
	uint32_t
	    RB:4, 
	    SP:4, 
	    DP:4, 
	    TE:4, 
	    D:4, 
	    SR:4, 
	    SV:4, 
	    RM:4; 
} arm_mvfr0_t;
struct {
	uint32_t
	    FZ:4, 
	    DN:4, 
	    LS:4, 
	    I:4, 
	    SP:4, 
	    HPFP:4, 
	    RSVP:8; 
} arm_mvfr1_t;
struct {
	uint32_t neon;
	uint32_t neon_hpfp;
	uint32_t neon_fp16;
} arm_mvfp_info_t;
struct {
	volatile uint64_t       TimeBase;
	volatile uint32_t       TimeStamp_sec;
	volatile uint32_t       TimeStamp_usec;
	volatile uint32_t       TimeBaseTicks_per_sec;
	volatile uint32_t       TimeBaseTicks_per_usec;
	volatile uint64_t       TimeBase_magic;
	volatile uint32_t       TimeBase_add;
	volatile uint32_t       TimeBase_shift;
} commpage_timeofday_data_t;
struct cpu_broadcast_xcall_simple_data {
	broadcastFunc func;
	void* parm;
	uint32_t sync;
};
struct reset_handler_data {
	vm_offset_t     assist_reset_handler;           
	vm_offset_t     cpu_data_entries;                       
} reset_handler_data_t;
struct cpu_data_entry {
	void                           *cpu_data_paddr;         
	struct  cpu_data               *cpu_data_vaddr;         
} cpu_data_entry_t;
struct rtclock_timer {
	mpqueue_head_t                  queue;
	uint64_t                        deadline;
	uint32_t                        is_set:1,
	    has_expired:1,
	:0;
} rtclock_timer_t;
struct {
	uint64_t irq_ex_cnt;
	uint64_t irq_ex_cnt_wake;
	uint64_t ipi_cnt;
	uint64_t ipi_cnt_wake;
	uint64_t timer_cnt;
	uint64_t undef_ex_cnt;
	uint64_t unaligned_cnt;
	uint64_t vfp_cnt;
	uint64_t data_ex_cnt;
	uint64_t instr_ex_cnt;
} cpu_stat_t;
struct cpu_data {
	unsigned short                  cpu_number;
	_Atomic cpu_flags_t             cpu_flags;
	int                             cpu_type;
	int                             cpu_subtype;
	int                             cpu_threadtype;

	void *                          XNU_PTRAUTH_SIGNED_PTR("cpu_data.istackptr") istackptr;
	vm_offset_t                     intstack_top;
	void *                          XNU_PTRAUTH_SIGNED_PTR("cpu_data.excepstackptr") excepstackptr;
	vm_offset_t                     excepstack_top;
	thread_t                        cpu_active_thread;
	vm_offset_t                     cpu_active_stack;
	cpu_id_t                        cpu_id;
	volatile cpu_signal_t           cpu_signal;
	ast_t                           cpu_pending_ast;
	cache_dispatch_t                cpu_cache_dispatch;

	uint64_t                        cpu_base_timebase;
	uint64_t                        cpu_timebase;
	bool                            cpu_hibernate; 
	bool                            cpu_running;
	bool                            cluster_master;
	bool                            in_state_transition;

	uint32_t                        cpu_decrementer;
	get_decrementer_t               cpu_get_decrementer_func;
	set_decrementer_t               cpu_set_decrementer_func;
	fiq_handler_t                   cpu_get_fiq_handler;

	void                            *cpu_tbd_hardware_addr;
	void                            *cpu_tbd_hardware_val;

	processor_idle_t                cpu_idle_notify;
	uint64_t                        cpu_idle_latency;
	uint64_t                        cpu_idle_pop;

	vm_offset_t                     cpu_reset_handler;
	uintptr_t                       cpu_reset_assist;
	uint32_t                        cpu_reset_type;

	unsigned int                    interrupt_source;
	void                            *cpu_int_state;
	IOInterruptHandler              interrupt_handler;
	void                            *interrupt_nub;
	void                            *interrupt_target;
	void                            *interrupt_refCon;

	idle_timer_t                    idle_timer_notify;
	void                            *idle_timer_refcon;
	uint64_t                        idle_timer_deadline;

	uint64_t                        rtcPop;
	rtclock_timer_t                 rtclock_timer;
	struct _rtclock_data_           *rtclock_datap;

	arm_debug_state_t               *cpu_user_debug; 
	vm_offset_t                     cpu_debug_interface_map;

	volatile int                    debugger_active;
	volatile int                    PAB_active; 

	void                            *cpu_xcall_p0;
	void                            *cpu_xcall_p1;
	void                            *cpu_imm_xcall_p0;
	void                            *cpu_imm_xcall_p1;


	vm_offset_t                     coresight_base[CORESIGHT_REGIONS];


	uint64_t                        cpu_regmap_paddr;

	uint32_t                        cpu_phys_id;
	platform_error_handler_t        platform_error_handler;

	int                             cpu_mcount_off;

	volatile unsigned int           cpu_sleep_token;
	unsigned int                    cpu_sleep_token_last;

	cluster_type_t                  cpu_cluster_type;
	uint32_t                        cpu_cluster_id;
	uint32_t                        cpu_l2_id;
	uint32_t                        cpu_l2_size;
	uint32_t                        cpu_l3_id;
	uint32_t                        cpu_l3_size;

	enum {
		CPU_NOT_HALTED = 0,
		CPU_HALTED,
		CPU_HALTED_WITH_STATE
	}                               halt_status;


	uint64_t                        *cpu_kpc_buf[2];
	uint64_t                        *cpu_kpc_shadow;
	uint64_t                        *cpu_kpc_reload;


	cpu_stat_t                      cpu_stat;
	dbgwrap_thread_state_t          halt_state;
	uint64_t ipi_pc;
	uint64_t ipi_lr;
	uint64_t ipi_fp;

	uint64_t                        cpu_tpidr_el0;


} cpu_data_t;
struct sysreg_restore {
	uint64_t                tcr_el1;
} sysreg_restore_t;
struct ml_topology_cpu {
	unsigned int                    cpu_id;
	uint32_t                        phys_id;
	unsigned int                    cluster_id;
	unsigned int                    die_id;
	cluster_type_t                  cluster_type;
	uint32_t                        l2_access_penalty; 
	uint32_t                        l2_cache_size;
	uint32_t                        l2_cache_id;
	uint32_t                        l3_cache_size;
	uint32_t                        l3_cache_id;
	vm_offset_t                     cpu_IMPL_regs;
	uint64_t                        cpu_IMPL_pa;
	uint64_t                        cpu_IMPL_len;
	vm_offset_t                     cpu_UTTDBG_regs;
	uint64_t                        cpu_UTTDBG_pa;
	uint64_t                        cpu_UTTDBG_len;
	vm_offset_t                     coresight_regs;
	uint64_t                        coresight_pa;
	uint64_t                        coresight_len;
	unsigned int                    die_cluster_id;
	unsigned int                    cluster_core_id;
} ml_topology_cpu_t;
struct ml_topology_cluster {
	unsigned int                    cluster_id;
	cluster_type_t                  cluster_type;
	unsigned int                    num_cpus;
	unsigned int                    first_cpu_id;
	uint64_t                        cpu_mask;
	unsigned int                    die_id;
	unsigned int                    die_cluster_id;
	vm_offset_t                     acc_IMPL_regs;
	uint64_t                        acc_IMPL_pa;
	uint64_t                        acc_IMPL_len;
	vm_offset_t                     cpm_IMPL_regs;
	uint64_t                        cpm_IMPL_pa;
	uint64_t                        cpm_IMPL_len;
} ml_topology_cluster_t;
struct ml_topology_info {
	unsigned int                    version;
	unsigned int                    num_cpus;
	unsigned int                    max_cpu_id;
	unsigned int                    num_clusters;
	unsigned int                    max_cluster_id;
	unsigned int                    max_die_id;
	ml_topology_cpu_t               *cpus;
	ml_topology_cluster_t           *clusters;
	ml_topology_cpu_t               *boot_cpu;
	ml_topology_cluster_t           *boot_cluster;
	unsigned int                    chip_revision;
	unsigned int                    cluster_types;
	unsigned int                    cluster_type_num_cpus[MAX_CPU_TYPES];
	unsigned int                    cluster_type_num_clusters[MAX_CPU_TYPES];
	unsigned int                    cluster_power_down;
} ml_topology_info_t;
struct {
 uint8_t signature[16];
 uint64_t cpu_capabilities64;
 uint8_t _unused[6];
 uint16_t version;
 uint32_t cpu_capabilities;
 uint8_t _unused0[2];
 uint16_t cache_linesize;
 volatile uint32_t sched_gen;
 volatile uint32_t memory_pressure;
 volatile uint32_t spin_count;
 volatile uint8_t active_cpus;
 uint8_t physical_cpus;
 uint8_t logical_cpus;
 uint8_t cpu_clusters;
 uint64_t memory_size;
 uint32_t cpufamily;
 volatile uint32_t kdebug_enable;
 volatile uint32_t atm_diagnostic_config;
 uint8_t cp_dtrace_dof_enabled;
 uint8_t cp_kernel_page_shift; 
 uint8_t cp_user_page_shift; 
 uint8_t _unused2;
	volatile struct {
 uint64_t nt_tsc_base;
 uint32_t nt_scale;
 uint32_t nt_shift;
 uint64_t nt_ns_base;
 uint32_t nt_generation;
 uint32_t gtod_generation;
 uint64_t gtod_ns_base;
 uint64_t gtod_sec_base;
	} time_data;
	volatile union {
		struct {
 uint64_t time;
 uint64_t time_supported;
		} _;
		uint8_t _fill[64];
	} approx;
 volatile uint64_t cont_timebase;
 volatile uint64_t boottime_usec;
	new_commpage_timeofday_data_t new_time_data;








 uint64_t unused;
 uint64_t dyld_system_flags;
 uint8_t cpu_to_cluster[256];

 uint8_t unused2[3536];
 uint64_t arm_cpu_capabilities;
 uint8_t cp_aprr_shadow_supported;
 uint8_t user_timebase_type;
 uint8_t unused3[6];
 uint64_t cp_aprr_shadow_jit_rw;
 uint64_t cp_aprr_shadow_jit_rx;
 uint32_t unused4;
 uint32_t arm_cpufamily;
 uint64_t cp_aprr_shadow_tpro_rw;
 uint64_t cp_aprr_shadow_tpro_ro;
 uint64_t cp_asb_target_value;
 uint64_t cp_asb_target_address;
 uint64_t cp_asb_target_kern_value;
 uint64_t cp_asb_target_kern_address;
} x86_64_commpage_t;
struct {
	machdep_call_routine_t      routine;
	int                         nargs;
} machdep_call_t;
struct {
	uint32_t        arm_32bit_isa   : 4,
	    arm_thumb_ver   : 4,
	    arm_jazelle             : 4,
	    arm_thumb2              : 4,
	    reserved                : 16;
} arm_feature_bits_t;
struct{
	uint32_t endianness_support     : 4;
	uint32_t exception_1_support    : 4;
	uint32_t exception_2_support    : 4;
	uint32_t sign_zero_ext_support  : 4;
	uint32_t if_then_support        : 4;
	uint32_t immediate_support      : 4;
	uint32_t interworking_support   : 4;
	uint32_t jazelle_support        : 4;
}
syscp_ID_instructions_feat_1_reg;
struct {
	boolean_t               memory_mapped_core_debug;
	boolean_t               coprocessor_core_debug;
	uint32_t                num_watchpoint_pairs;
	uint32_t                num_breakpoint_pairs;
} arm_debug_info_t;
struct{
	vm_offset_t far;
}
ex_cb_state_t;
struct ml_cpu_info {
	unsigned long           vector_unit;
	unsigned long           cache_line_size;
	unsigned long           l1_icache_size;
	unsigned long           l1_dcache_size;
	unsigned long           l2_settings;
	unsigned long           l2_cache_size;
	unsigned long           l3_settings;
	unsigned long           l3_cache_size;
};
struct ml_processor_info {
	cpu_id_t                        cpu_id;
	vm_offset_t                     start_paddr;
	boolean_t                       supports_nap;
	void                            *platform_cache_dispatch;
	time_base_enable_t              time_base_enable;
	processor_idle_t                processor_idle;
	idle_tickle_t                   *idle_tickle;
	idle_timer_t                    idle_timer;
	void                            *idle_timer_refcon;
	vm_offset_t                     powergate_stub_addr;
	uint32_t                        powergate_stub_length;
	uint32_t                        powergate_latency;
	platform_error_handler_t        platform_error_handler;
	uint64_t                        regmap_paddr;
	uint32_t                        phys_id;
	uint32_t                        log_id;
	uint32_t                        l2_access_penalty; 
	uint32_t                        cluster_id;
	cluster_type_t                  cluster_type;
	uint32_t                        l2_cache_id;
	uint32_t                        l2_cache_size;
	uint32_t                        l3_cache_id;
	uint32_t                        l3_cache_size;
};
struct  tbd_ops {
	fiq_handler_t     tbd_fiq_handler;
	get_decrementer_t tbd_get_decrementer;
	set_decrementer_t tbd_set_decrementer;
};
struct going_on_core {
	uint64_t        thread_id;
	uint16_t        qos_class;
	uint16_t        urgency;        
	uint32_t        is_32_bit : 1; 
	uint32_t        is_kernel_thread : 1;
	uint64_t        thread_group_id;
	void            *thread_group_data;
	uint64_t        scheduling_latency;     
	uint64_t        start_time;
	uint64_t        scheduling_latency_at_same_basepri;
	uint32_t        energy_estimate_nj;     
};
struct going_off_core {
	uint64_t        thread_id;
	uint32_t        energy_estimate_nj;     
	uint32_t        reserved;
	uint64_t        end_time;
	uint64_t        thread_group_id;
	void            *thread_group_data;
};
struct thread_group_data {
	uint64_t        thread_group_id;
	void            *thread_group_data;
	uint32_t        thread_group_size;
	uint32_t        thread_group_flags;
};
struct perfcontrol_max_runnable_latency {
	uint64_t        max_scheduling_latencies[4 ];
};
struct perfcontrol_work_interval {
	uint64_t        thread_id;
	uint16_t        qos_class;
	uint16_t        urgency;
	uint32_t        flags; 
	uint64_t        work_interval_id;
	uint64_t        start;
	uint64_t        finish;
	uint64_t        deadline;
	uint64_t        next_start;
	uint64_t        thread_group_id;
	void            *thread_group_data;
	uint32_t        create_flags;
};
struct perfcontrol_work_interval_instance {
	work_interval_ctl_t     ctl;
	uint32_t                create_flags;
	uint64_t                complexity;
	uint64_t                thread_id;
	uint64_t                work_interval_id;
	uint64_t                instance_id; 
	uint64_t                start;
	uint64_t                finish;
	uint64_t                deadline;
	uint64_t                thread_group_id;
	void                    *thread_group_data;
};
struct perfcontrol_cpu_counters {
	uint64_t        instructions;
	uint64_t        cycles;
};
struct perfcontrol_thread_data {
	uint32_t            energy_estimate_nj;
	perfcontrol_class_t perfctl_class;
	uint64_t            thread_id;
	uint64_t            thread_group_id;
	uint64_t            scheduling_latency_at_same_basepri;
	void                *thread_group_data;
	void                *perfctl_state;
	perfcontrol_thread_flags_mask_t thread_flags_mask;
	perfcontrol_thread_flags_mask_t thread_flags;
};
struct sched_perfcontrol_callbacks {
	unsigned long version; 
	sched_perfcontrol_offcore_t                   offcore;
	sched_perfcontrol_context_switch_t            context_switch;
	sched_perfcontrol_oncore_t                    oncore;
	sched_perfcontrol_max_runnable_latency_t      max_runnable_latency;
	sched_perfcontrol_work_interval_notify_t      work_interval_notify;
	sched_perfcontrol_thread_group_init_t         thread_group_init;
	sched_perfcontrol_thread_group_deinit_t       thread_group_deinit;
	sched_perfcontrol_deadline_passed_t           deadline_passed;
	sched_perfcontrol_csw_t                       csw;
	sched_perfcontrol_state_update_t              state_update;
	sched_perfcontrol_thread_group_flags_update_t thread_group_flags_update;
	sched_perfcontrol_work_interval_ctl_t         work_interval_ctl;
	sched_perfcontrol_thread_group_blocked_t      thread_group_blocked;
	sched_perfcontrol_thread_group_unblocked_t    thread_group_unblocked;
};
struct arm_matrix_cpu_state {
};
struct _preemption_disable_pcpu {
	struct _preemption_disable_snap {
		
		uint64_t pds_mach_time;
		
		uint64_t pds_int_mach_time;
	}
	pdp_start;

	_Atomic uint64_t pdp_max_mach_duration;
	bool pdp_abandon;
};
struct _rtclock_data_ {
	uint32_t                                                rtc_sec_divisor;
	uint32_t                                                rtc_usec_divisor;
	mach_timebase_info_data_t               rtc_timebase_const;
	union {
		uint64_t                abstime;
		struct {
			uint32_t        low;
			uint32_t        high;
		} abstime_val;
	}                                                               rtc_base;
	union {
		uint64_t                abstime;
		struct {
			uint32_t        low;
			uint32_t        high;
		} abstime_val;
	}                                                               rtc_adj;
	tbd_ops_data_t                                  rtc_timebase_func;

	vm_offset_t                                             rtc_timebase_addr;
	vm_offset_t                                             rtc_timebase_val;
} rtclock_data_t;
struct jmp_buf {
	int   jmp_buf[28];
} jmp_buf_t;
struct perfcontrol_state {
	uint64_t opaque[8] __attribute__((aligned(8)));
};
struct machine_thread {

	uint32_t                  arm_machine_flags;       
	arm_context_t *           contextData;             
	arm_saved_state_t *       XNU_PTRAUTH_SIGNED_PTR("machine_thread.upcb") upcb;   
	arm_neon_saved_state_t *  XNU_PTRAUTH_SIGNED_PTR("machine_thread.uNeon") uNeon; 
	arm_saved_state_t *       kpcb;                    


	long                      reserved4;
	uint64_t                  recover_far;

	arm_debug_state_t        *DebugData;
	vm_address_t              cthread_self;               

	uint64_t                  recover_esr;

	void *                    XNU_PTRAUTH_SIGNED_PTR("machine_thread.kstackptr") kstackptr; 
	struct perfcontrol_state  perfctrl_state;
	uint64_t                  reserved5;



	uint64_t                  reserved6;
	union {
		long              pcpu_data_base_and_cpu_number;
		const uint16_t    cpu_number;
	};
	struct cpu_data *         CpuDatap;               
	unsigned int              preemption_count;       
	uint16_t                  exception_trace_code;
	bool                      reserved7;
	bool                      reserved8;

	uint64_t                  reserved11;

};
struct {
	pmap_paddr_t pa;
	vm_map_address_t va;
	vm_size_t len;
} ptov_table_entry;
struct cpc_event {
	const char *cev_name;
	uint16_t cev_selector;
};
struct cpc_event_list {
	unsigned int cel_event_count;
	struct cpc_event cel_events[];
};
struct {
	hibernate_page_list_t *bitmap;
	uint32_t nextFree;
	uint64_t page_table_base;
} map_ctx;
struct lowglo {
	unsigned char lgVerCode[8];            
	uint64_t      lgZero;                  
	uint64_t      lgStext;                 
	uint64_t      lgVersion;               
	uint64_t      lgOSVersion;             
	uint64_t      lgKmodptr;               
	uint64_t      lgTransOff;              
	uint64_t      lgRebootFlag;            
	uint64_t      lgManualPktAddr;         
	uint64_t      lgAltDebugger;           
	uint64_t      lgPmapMemQ;              
	uint64_t      lgPmapMemPageOffset;     
	uint64_t      lgPmapMemChainOffset;    
	uint64_t      lgStaticAddr;            
	uint64_t      lgStaticSize;            
	uint64_t      lgLayoutMajorVersion;    
	uint64_t      lgLayoutMagic;           
	uint64_t      lgPmapMemStartAddr;      
	uint64_t      lgPmapMemEndAddr;        
	uint64_t      lgPmapMemPagesize;       
	uint64_t      lgPmapMemFromArrayMask;  
	uint64_t      lgPmapMemFirstppnum;     
	uint64_t      lgPmapMemPackedShift;    
	uint64_t      lgPmapMemPackedBaseAddr; 
	uint64_t      lgLayoutMinorVersion;    
	uint64_t      lgPageShift;             
	uint64_t      lgVmFirstPhys;           
	uint64_t      lgVmLastPhys;            
	uint64_t      lgPhysMapBase;           
	uint64_t      lgPhysMapEnd;            
	uint64_t      lgPmapIoRangePtr;        
	uint64_t      lgNumPmapIoRanges;       
	uint64_t      lgCompressorBufferAddr;  
	uint64_t      lgCompressorSizeAddr;    
} lowglo;
struct {
	uint64_t        el0_not_implemented             : 1,
	    el0_aarch64_only                : 1,
	    el0_aarch32_and_64              : 1,
	    el1_not_implemented             : 1,
	    el1_aarch64_only                : 1,
	    el1_aarch32_and_64              : 1,
	    el2_not_implemented             : 1,
	    el2_aarch64_only                : 1,
	    el2_aarch32_and_64              : 1,
	    el3_not_implemented             : 1,
	    el3_aarch64_only                : 1,
	    el3_aarch32_and_64              : 1,
	    reserved                                : 52;
} arm_feature_bits_t;
struct {
	uint32_t        num_watchpoint_pairs;
	uint32_t        num_breakpoint_pairs;
} arm_debug_info_t;
struct pal_hib_ctx {
};
struct {
	uint64_t dockChannelRegPhysBase;
	uint64_t dockChannelRegVirtBase;
	uint32_t dockChannelWstatMask;
	uint64_t hibUartRegPhysBase;
	uint64_t hibUartRegVirtBase;
	uint64_t hmacRegBase;
	uint64_t kernelSlide;
} pal_hib_globals_t;
struct{
	uint64_t ttbr0;
	uint64_t ttbr1;
	uint64_t memSlide;
} pal_hib_tramp_result_t;
struct copyio_recovery_entry {
	ptrdiff_t cre_start;
	ptrdiff_t cre_end;
	ptrdiff_t cre_recovery;
};
struct arm_vfpv2_state {
	__uint32_t __r[32];
	__uint32_t __fpscr;
};
struct bank_element {
	unsigned int  be_type:31,                
	    be_voucher_ref:1;                    
	os_ref_atomic_t be_refs;                 
	unsigned int  be_made;                   
};
struct bank_task {
	struct bank_element       bt_elem;                 
	struct proc_persona_info  bt_proc_persona;         
	ledger_t                  bt_ledger;               
	queue_head_t              bt_accounts_to_pay;      
	queue_head_t              bt_accounts_to_charge;   
	decl_lck_mtx_data(, bt_acc_to_pay_lock);           
	decl_lck_mtx_data(, bt_acc_to_charge_lock);        
	uint32_t                  bt_persona_uid;          
	uint32_t                  bt_hasentitlement:1;     
};
struct bank_persona {
	uint32_t persona_id;
	uint32_t persona_uid;
};
struct bank_account {
	struct bank_element ba_elem;                 
	ledger_t            ba_bill;                 
	bank_task_t         ba_merchant;             
	bank_task_t         ba_holder;               
	bank_task_t         ba_secureoriginator;     
	bank_task_t         ba_proximateprocess;     
	queue_chain_t       ba_next_acc_to_pay;      
	queue_chain_t       ba_next_acc_to_charge;   
	struct bank_persona ba_so_persona;           
};
struct _bank_ledger_indices {
	int cpu_time;
	int energy;
};
struct proc_persona_info {
	uint64_t unique_pid;
	int32_t  pid;
	uint32_t flags;
	uint32_t pidversion;
	uint32_t persona_id;
	uint32_t uid;
	uint32_t gid;
	uint8_t  macho_uuid[16];
};
struct persona_token {
	struct proc_persona_info originator;
	struct proc_persona_info proximate;
};
struct persona_modify_info {
	uint32_t persona_id;
	uint64_t unique_pid;
};
struct {
	char *buffer;

	int len;

	int used;

	int nreserved;

	char *write_ptr;

	char *read_ptr;

	lck_mtx_t flush_lock;

	lck_ticket_t write_lock;
} console_ring;
struct console_ops {
	void (*putc)(char, bool);
	int (*getc)(bool);
};
struct console_printbuf_state {
	int pos;
	int total;
	int flags;
	char str[SERIAL_CONS_BUF_SIZE];
};
struct {
	void (*initialize)(struct vc_info * info);
	void (*enable)(boolean_t enable);
	void (*paint_char)(unsigned int xx, unsigned int yy, unsigned char ch,
	    int attrs, unsigned char ch_previous,
	    int attrs_previous);
	void (*clear_screen)(unsigned int xx, unsigned int yy, unsigned int top,
	    unsigned int bottom, int which);
	void (*scroll_down)(int num, unsigned int top, unsigned int bottom);
	void (*scroll_up)(int num, unsigned int top, unsigned int bottom);
	void (*hide_cursor)(unsigned int xx, unsigned int yy);
	void (*show_cursor)(unsigned int xx, unsigned int yy);
	void (*update_color)(int color, boolean_t fore);
} gc_ops;
struct lzss_image_state {
	uint32_t col;
	uint32_t row;
	uint32_t width;
	uint32_t height;
	uint32_t bytes_per_row;
	volatile uint32_t * row_start;
	const uint8_t* clut;
};
struct vc_progress_user_options {
	uint32_t options;
	uint32_t x_pos;
	uint32_t y_pos;
	uint32_t resv[8];
};
struct vc_info {
	unsigned int    v_height;       
	unsigned int    v_width;        
	unsigned int    v_depth;
	unsigned int    v_rowbytes;
	unsigned long   v_baseaddr;
	unsigned int    v_type;
	char            v_name[32];
	uint64_t        v_physaddr;
	unsigned int    v_rows;         
	unsigned int    v_columns;      
	unsigned int    v_rowscanbytes; 
	unsigned int    v_scale;
	unsigned int    v_rotate;
	unsigned int    v_reserved[3];
};
struct vc_progress_element {
	unsigned int        version;
	unsigned int        flags;
	unsigned int        time;
	unsigned char       count;
	unsigned char       res[3];
	int                 width;
	int                 height;
	int                 dx;
	int                 dy;
	int                 transparent;
	unsigned int        res2[3];
};
struct ccdrbg_nistctr_state {
	uint8_t Key[DRBG_CTR_MAX_KEYLEN];
	uint8_t V[DRBG_CTR_MAX_BLOCKLEN];
	uint64_t reseed_counter; 
	struct ccdrbg_nistctr_custom custom;
};
struct ccdrbg_nisthmac_state {
	const struct ccdrbg_nisthmac_custom *custom;
	uint8_t key[DRBG_HMAC_MAX_OUTPUT_SIZE];
	uint8_t V[DRBG_HMAC_MAX_OUTPUT_SIZE];
	uint64_t reseed_counter;
};
struct _ccmode_gcm_key {
	unsigned char H[16];   
	unsigned char X[16];   
	unsigned char Y[16];   
	unsigned char Y_0[16]; 
	unsigned char buf[16];  

	uint16_t state;    
	uint16_t flags;    
	uint32_t buf_nbytes; 

	uint64_t aad_nbytes; 
	uint64_t text_nbytes; 

	const struct ccmode_ecb *ecb;          
	void *ecb_key;                         
	int encdec; 

	CC_ALIGNED(16) unsigned char u[]; 
};
struct _ccmode_cbc_key {
	const struct ccmode_ecb *ecb;
	cc_unit u[];
};
struct _ccmode_cfb_key {
	const struct ccmode_ecb *ecb;
	size_t pad_len;
	cc_unit u[];
};
struct _ccmode_cfb8_key {
	const struct ccmode_ecb *ecb;
	cc_unit u[];
};
struct _ccmode_ctr_key {
	const struct ccmode_ecb *ecb;
	size_t pad_offset;
	cc_unit u[];
};
struct _ccmode_ofb_key {
	const struct ccmode_ecb *ecb;
	size_t pad_len;
	cc_unit u[];
};
struct _ccmode_xts_key {
	const struct ccmode_ecb *ecb;
	const struct ccmode_ecb *ecb_encrypt;
	cc_unit u[];
};
struct _ccmode_xts_tweak {
	size_t  blocks_processed;
	cc_unit u[];
};
struct _ccmode_ccm_key {
	const struct ccmode_ecb *ecb;
	cc_unit u[];
};
struct _ccmode_omac_key {
	const struct ccmode_ecb *ecb;
	size_t tweak_len;
	cc_unit u[];
};
struct ccn_rjsf_state {
	uint8_t u[2];
	const cc_unit *s;
	const cc_unit *t;
};
struct cc_ws {
	void *ctx;
	cc_size nunits;
	cc_size offset;
	cc_unit *(*CC_SPTR(cc_ws, alloc))(cc_ws_t ws, cc_size n);
	void(*CC_SPTR(cc_ws, free))(cc_ws_t ws);
};
struct mach_call_args {
	syscall_arg_t arg1;
	syscall_arg_t arg2;
	syscall_arg_t arg3;
	syscall_arg_t arg4;
	syscall_arg_t arg5;
	syscall_arg_t arg6;
	syscall_arg_t arg7;
	syscall_arg_t arg8;
	syscall_arg_t arg9;
};
struct cpuid_cache_descriptor {
	uint8_t         value;          
	uint8_t         type;           
	uint8_t         level;          
	uint8_t         ways;           
	uint16_t        size;           
	uint16_t        entries;        
} cpuid_cache_descriptor_t;
struct table {
	uint64_t        mask;
	const char      *name;
} feature_map[] = {
	{CPUID_FEATURE_FPU, "FPU"},
	{CPUID_FEATURE_VME, "VME"},
	{CPUID_FEATURE_DE, "DE"},
	{CPUID_FEATURE_PSE, "PSE"},
	{CPUID_FEATURE_TSC, "TSC"},
	{CPUID_FEATURE_MSR, "MSR"},
	{CPUID_FEATURE_PAE, "PAE"},
	{CPUID_FEATURE_MCE, "MCE"},
	{CPUID_FEATURE_CX8, "CX8"},
	{CPUID_FEATURE_APIC, "APIC"},
	{CPUID_FEATURE_SEP, "SEP"},
	{CPUID_FEATURE_MTRR, "MTRR"},
	{CPUID_FEATURE_PGE, "PGE"},
	{CPUID_FEATURE_MCA, "MCA"},
	{CPUID_FEATURE_CMOV, "CMOV"},
	{CPUID_FEATURE_PAT, "PAT"},
	{CPUID_FEATURE_PSE36, "PSE36"},
	{CPUID_FEATURE_PSN, "PSN"},
	{CPUID_FEATURE_CLFSH, "CLFSH"},
	{CPUID_FEATURE_DS, "DS"},
	{CPUID_FEATURE_ACPI, "ACPI"},
	{CPUID_FEATURE_MMX, "MMX"},
	{CPUID_FEATURE_FXSR, "FXSR"},
	{CPUID_FEATURE_SSE, "SSE"},
	{CPUID_FEATURE_SSE2, "SSE2"},
	{CPUID_FEATURE_SS, "SS"},
	{CPUID_FEATURE_HTT, "HTT"},
	{CPUID_FEATURE_TM, "TM"},
	{CPUID_FEATURE_PBE, "PBE"},
	{CPUID_FEATURE_SSE3, "SSE3"},
	{CPUID_FEATURE_PCLMULQDQ, "PCLMULQDQ"},
	{CPUID_FEATURE_DTES64, "DTES64"},
	{CPUID_FEATURE_MONITOR, "MON"},
	{CPUID_FEATURE_DSCPL, "DSCPL"},
	{CPUID_FEATURE_VMX, "VMX"},
	{CPUID_FEATURE_SMX, "SMX"},
	{CPUID_FEATURE_EST, "EST"},
	{CPUID_FEATURE_TM2, "TM2"},
	{CPUID_FEATURE_SSSE3, "SSSE3"},
	{CPUID_FEATURE_CID, "CID"},
	{CPUID_FEATURE_FMA, "FMA"},
	{CPUID_FEATURE_CX16, "CX16"},
	{CPUID_FEATURE_xTPR, "TPR"},
	{CPUID_FEATURE_PDCM, "PDCM"},
	{CPUID_FEATURE_SSE4_1, "SSE4.1"},
	{CPUID_FEATURE_SSE4_2, "SSE4.2"},
	{CPUID_FEATURE_x2APIC, "x2APIC"},
	{CPUID_FEATURE_MOVBE, "MOVBE"},
	{CPUID_FEATURE_POPCNT, "POPCNT"},
	{CPUID_FEATURE_AES, "AES"},
	{CPUID_FEATURE_VMM, "VMM"},
	{CPUID_FEATURE_PCID, "PCID"},
	{CPUID_FEATURE_XSAVE, "XSAVE"},
	{CPUID_FEATURE_OSXSAVE, "OSXSAVE"},
	{CPUID_FEATURE_SEGLIM64, "SEGLIM64"},
	{CPUID_FEATURE_TSCTMR, "TSCTMR"},
	{CPUID_FEATURE_AVX1_0, "AVX1.0"},
	{CPUID_FEATURE_RDRAND, "RDRAND"},
	{CPUID_FEATURE_F16C, "F16C"},
	{0, 0}
},
    extfeature_map[] = {
	{CPUID_EXTFEATURE_SYSCALL, "SYSCALL"},
	{CPUID_EXTFEATURE_XD, "XD"},
	{CPUID_EXTFEATURE_1GBPAGE, "1GBPAGE"},
	{CPUID_EXTFEATURE_EM64T, "EM64T"},
	{CPUID_EXTFEATURE_LAHF, "LAHF"},
	{CPUID_EXTFEATURE_LZCNT, "LZCNT"},
	{CPUID_EXTFEATURE_PREFETCHW, "PREFETCHW"},
	{CPUID_EXTFEATURE_RDTSCP, "RDTSCP"},
	{CPUID_EXTFEATURE_TSCI, "TSCI"},
	{0, 0}
},
    leaf7_feature_map[] = {
	{CPUID_LEAF7_FEATURE_RDWRFSGS, "RDWRFSGS"},
	{CPUID_LEAF7_FEATURE_TSCOFF, "TSC_THREAD_OFFSET"},
	{CPUID_LEAF7_FEATURE_SGX, "SGX"},
	{CPUID_LEAF7_FEATURE_BMI1, "BMI1"},
	{CPUID_LEAF7_FEATURE_HLE, "HLE"},
	{CPUID_LEAF7_FEATURE_AVX2, "AVX2"},
	{CPUID_LEAF7_FEATURE_FDPEO, "FDPEO"},
	{CPUID_LEAF7_FEATURE_SMEP, "SMEP"},
	{CPUID_LEAF7_FEATURE_BMI2, "BMI2"},
	{CPUID_LEAF7_FEATURE_ERMS, "ERMS"},
	{CPUID_LEAF7_FEATURE_INVPCID, "INVPCID"},
	{CPUID_LEAF7_FEATURE_RTM, "RTM"},
	{CPUID_LEAF7_FEATURE_PQM, "PQM"},
	{CPUID_LEAF7_FEATURE_FPU_CSDS, "FPU_CSDS"},
	{CPUID_LEAF7_FEATURE_MPX, "MPX"},
	{CPUID_LEAF7_FEATURE_PQE, "PQE"},
	{CPUID_LEAF7_FEATURE_AVX512F, "AVX512F"},
	{CPUID_LEAF7_FEATURE_AVX512DQ, "AVX512DQ"},
	{CPUID_LEAF7_FEATURE_RDSEED, "RDSEED"},
	{CPUID_LEAF7_FEATURE_ADX, "ADX"},
	{CPUID_LEAF7_FEATURE_SMAP, "SMAP"},
	{CPUID_LEAF7_FEATURE_AVX512IFMA, "AVX512IFMA"},
	{CPUID_LEAF7_FEATURE_CLFSOPT, "CLFSOPT"},
	{CPUID_LEAF7_FEATURE_CLWB, "CLWB"},
	{CPUID_LEAF7_FEATURE_IPT, "IPT"},
	{CPUID_LEAF7_FEATURE_AVX512CD, "AVX512CD"},
	{CPUID_LEAF7_FEATURE_SHA, "SHA"},
	{CPUID_LEAF7_FEATURE_AVX512BW, "AVX512BW"},
	{CPUID_LEAF7_FEATURE_AVX512VL, "AVX512VL"},
	{CPUID_LEAF7_FEATURE_PREFETCHWT1, "PREFETCHWT1"},
	{CPUID_LEAF7_FEATURE_AVX512VBMI, "AVX512VBMI"},
	{CPUID_LEAF7_FEATURE_UMIP, "UMIP"},
	{CPUID_LEAF7_FEATURE_PKU, "PKU"},
	{CPUID_LEAF7_FEATURE_OSPKE, "OSPKE"},
	{CPUID_LEAF7_FEATURE_WAITPKG, "WAITPKG"},
	{CPUID_LEAF7_FEATURE_GFNI, "GFNI"},
	{CPUID_LEAF7_FEATURE_VAES, "VAES"},
	{CPUID_LEAF7_FEATURE_VPCLMULQDQ, "VPCLMULQDQ"},
	{CPUID_LEAF7_FEATURE_AVX512VNNI, "AVX512VNNI"},
	{CPUID_LEAF7_FEATURE_AVX512BITALG, "AVX512BITALG"},
	{CPUID_LEAF7_FEATURE_AVX512VPCDQ, "AVX512VPOPCNTDQ"},
	{CPUID_LEAF7_FEATURE_RDPID, "RDPID"},
	{CPUID_LEAF7_FEATURE_CLDEMOTE, "CLDEMOTE"},
	{CPUID_LEAF7_FEATURE_MOVDIRI, "MOVDIRI"},
	{CPUID_LEAF7_FEATURE_MOVDIRI64B, "MOVDIRI64B"},
	{CPUID_LEAF7_FEATURE_SGXLC, "SGXLC"},
	{0, 0}
},
    leaf7_extfeature_map[] = {
	{ CPUID_LEAF7_EXTFEATURE_AVX5124VNNIW, "AVX5124VNNIW" },
	{ CPUID_LEAF7_EXTFEATURE_AVX5124FMAPS, "AVX5124FMAPS" },
	{ CPUID_LEAF7_EXTFEATURE_FSREPMOV, "FSREPMOV" },
	{ CPUID_LEAF7_EXTFEATURE_MDCLEAR, "MDCLEAR" },
	{ CPUID_LEAF7_EXTFEATURE_TSXFA, "TSXFA" },
	{ CPUID_LEAF7_EXTFEATURE_IBRS, "IBRS" },
	{ CPUID_LEAF7_EXTFEATURE_STIBP, "STIBP" },
	{ CPUID_LEAF7_EXTFEATURE_L1DF, "L1DF" },
	{ CPUID_LEAF7_EXTFEATURE_ACAPMSR, "ACAPMSR" },
	{ CPUID_LEAF7_EXTFEATURE_CCAPMSR, "CCAPMSR" },
	{ CPUID_LEAF7_EXTFEATURE_SSBD, "SSBD" },
	{0, 0}
};
struct {
	unsigned char   value;          
	cache_type_t    type;           
	unsigned int    size;           
	unsigned int    linesize;       
	const char      *description;   
} cpuid_cache_desc_t;
struct {
	uint32_t        linesize_min;
	uint32_t        linesize_max;
	uint32_t        extensions;
	uint32_t        sub_Cstates;
} cpuid_mwait_leaf_t;
struct {
	boolean_t       sensor;
	boolean_t       dynamic_acceleration;
	boolean_t       invariant_APIC_timer;
	boolean_t       core_power_limits;
	boolean_t       fine_grain_clock_mod;
	boolean_t       package_thermal_intr;
	uint32_t        thresholds;
	boolean_t       ACNT_MCNT;
	boolean_t       hardware_feedback;
	boolean_t       energy_policy;
} cpuid_thermal_leaf_t;
struct {
	uint32_t        extended_state[4];      
} cpuid_xsave_leaf_t;
struct {
	uint8_t         version;
	uint8_t         number;
	uint8_t         width;
	uint8_t         events_number;
	uint32_t        events;
	uint8_t         fixed_number;
	uint8_t         fixed_width;
} cpuid_arch_perf_leaf_t;
struct {
	uint32_t        numerator;
	uint32_t        denominator;
} cpuid_tsc_leaf_t;
struct i386_cpu_info {
	char            cpuid_vendor[16];
	char            cpuid_brand_string[48];
	const char      *cpuid_model_string;

	cpu_type_t      cpuid_type;     
	uint8_t         cpuid_family;
	uint8_t         cpuid_model;
	uint8_t         cpuid_extmodel;
	uint8_t         cpuid_extfamily;
	uint8_t         cpuid_stepping;
	uint64_t        cpuid_features;
	uint64_t        cpuid_extfeatures;
	uint32_t        cpuid_signature;
	uint8_t         cpuid_brand;
	uint8_t         cpuid_processor_flag;

	uint32_t        cache_size[LCACHE_MAX];
	uint32_t        cache_linesize;

	uint8_t         cache_info[64];    

	uint32_t        cpuid_cores_per_package;
	uint32_t        cpuid_logical_per_package;
	uint32_t        cache_sharing[LCACHE_MAX];
	uint32_t        cache_partitions[LCACHE_MAX];

	cpu_type_t      cpuid_cpu_type;                 
	cpu_subtype_t   cpuid_cpu_subtype;              

	cpuid_mwait_leaf_t      cpuid_mwait_leaf;
	cpuid_thermal_leaf_t    cpuid_thermal_leaf;
	cpuid_arch_perf_leaf_t  cpuid_arch_perf_leaf;
	uint32_t        unused[4];                      

	uint32_t        cpuid_cache_linesize;
	uint32_t        cpuid_cache_L2_associativity;
	uint32_t        cpuid_cache_size;

	uint32_t        cpuid_address_bits_physical;
	uint32_t        cpuid_address_bits_virtual;

	uint32_t        cpuid_microcode_version;

	uint32_t        cpuid_tlb[2][2][2];
	uint32_t        cpuid_stlb;

	uint32_t        core_count;
	uint32_t        thread_count;

	uint32_t        cpuid_max_basic;
	uint32_t        cpuid_max_ext;

	uint32_t                cpuid_cpufamily;
	cpuid_mwait_leaf_t      *cpuid_mwait_leafp;
	cpuid_thermal_leaf_t    *cpuid_thermal_leafp;
	cpuid_arch_perf_leaf_t  *cpuid_arch_perf_leafp;
	cpuid_xsave_leaf_t      *cpuid_xsave_leafp;
	uint64_t                cpuid_leaf7_features;
	uint64_t                cpuid_leaf7_extfeatures;
	cpuid_tsc_leaf_t        cpuid_tsc_leaf;
	cpuid_xsave_leaf_t      cpuid_xsave_leaf[8];
} i386_cpu_info_t;
struct x86_affinity_set {
	struct x86_affinity_set     *next;
	struct x86_cpu_cache        *cache;
	processor_set_t             pset;
	uint32_t                    num;
} x86_affinity_set_t;
struct rtclock_timer {
	mpqueue_head_t          queue;
	uint64_t                deadline;
	uint64_t                when_set;
	boolean_t               has_expired;
} rtclock_timer_t;
struct {
	struct x86_64_tss       *cdi_ktssu;
	struct x86_64_tss       *cdi_ktssb;
	x86_64_desc_register_t  cdi_gdtu;
	x86_64_desc_register_t  cdi_gdtb;
	x86_64_desc_register_t  cdi_idtu;
	x86_64_desc_register_t  cdi_idtb;
	struct real_descriptor  *cdi_ldtu;
	struct real_descriptor  *cdi_ldtb;
	vm_offset_t             cdi_sstku;
	vm_offset_t             cdi_sstkb;
} cpu_desc_index_t;
struct {
	addr64_t        cu_isf;         
	uint64_t        cu_tmp;         
	addr64_t        cu_user_gs_base;
} cpu_uber_t;
struct {
	boolean_t pltype;
	int plevel;
	uint64_t plbt[MAX_TRACE_BTFRAMES];
} plrecord_t;
struct {
	pcid_t                  cpu_pcid_free_hint;
	pcid_ref_t              cpu_pcid_refcounts[PMAP_PCID_MAX_PCID];
	pmap_t                  cpu_pcid_last_pmap_dispatched[PMAP_PCID_MAX_PCID];
} pcid_cdata_t;
struct cpu_data {
	struct pal_cpu_data     cpu_pal_data;           
	struct cpu_data         *cpu_this;              
	vm_offset_t             cpu_pcpu_base;
	thread_t                cpu_active_thread;
	thread_t                cpu_nthread;
	int                     cpu_number;             
	void                    *cpu_int_state;         
	vm_offset_t             cpu_active_stack;       
	vm_offset_t             cpu_kernel_stack;       
	vm_offset_t             cpu_int_stack_top;
	volatile int            cpu_signals;            
	volatile int            cpu_prior_signals;      
	ast_t                   cpu_pending_ast;
	int                     cpu_interrupt_level;
	volatile int            cpu_preemption_level;
	volatile int            cpu_running;
	rtclock_timer_t         rtclock_timer;
	volatile addr64_t       cpu_active_cr3 __attribute((aligned(64)));
	union {
		volatile uint32_t cpu_tlb_invalid;
		struct {
			volatile uint16_t cpu_tlb_invalid_local;
			volatile uint16_t cpu_tlb_invalid_global;
		};
	};
	uint64_t                cpu_ip_desc[2];
	volatile task_map_t     cpu_task_map;
	volatile addr64_t       cpu_task_cr3;
	addr64_t                cpu_kernel_cr3;
	volatile addr64_t       cpu_ucr3;
	volatile addr64_t       cpu_shadowtask_cr3;
	boolean_t               cpu_pagezero_mapped;
	cpu_uber_t              cpu_uber;

	uintptr_t               cd_estack;
	int                     cpu_xstate;
	int                     cpu_curtask_has_ldt;
	int                     cpu_curthread_do_segchk;

	void                    *cd_shadow;
	union {
		volatile uint32_t cpu_tlb_invalid_count;
		struct {
			volatile uint16_t cpu_tlb_invalid_local_count;
			volatile uint16_t cpu_tlb_invalid_global_count;
		};
	};

	uint16_t                cpu_tlb_gen_counts_local[MAX_CPUS];
	uint16_t                cpu_tlb_gen_counts_global[MAX_CPUS];

	struct processor        *cpu_processor;
	struct real_descriptor  *cpu_ldtp;
	struct cpu_desc_table   *cpu_desc_tablep;
	cpu_desc_index_t        cpu_desc_index;
	int                     cpu_ldt;

	uint32_t                cpu_hwIntCnt[HWINTCNT_SIZE];    
	uint64_t                cpu_hwIntpexits[HWINTCNT_SIZE];
	uint64_t                cpu_dr7; 
	uint64_t                cpu_int_event_time;     
	pal_rtc_nanotime_t      *cpu_nanotime;          
	uint32_t                cpu_pmap_pcid_enabled;
	pcid_t                  cpu_active_pcid;
	pcid_t                  cpu_last_pcid;
	pcid_t                  cpu_kernel_pcid;
	volatile pcid_ref_t     *cpu_pmap_pcid_coherentp;
	volatile pcid_ref_t     *cpu_pmap_pcid_coherentp_kernel;
	pcid_cdata_t            *cpu_pcid_data;
	uint64_t                cpu_aperf;
	uint64_t                cpu_mperf;
	uint64_t                cpu_c3res;
	uint64_t                cpu_c6res;
	uint64_t                cpu_c7res;
	uint64_t                cpu_itime_total;
	uint64_t                cpu_rtime_total;
	uint64_t                cpu_ixtime;
	uint64_t                cpu_idle_exits;
	uint64_t                cpu_rtimes[CPU_RTIME_BINS];
	uint64_t                cpu_itimes[CPU_ITIME_BINS];
	uint64_t                cpu_gpmcs[4];
	uint64_t                cpu_max_observed_int_latency;
	int                     cpu_max_observed_int_latency_vector;
	volatile boolean_t      cpu_NMI_acknowledged;
	uint64_t                debugger_entry_time;
	uint64_t                debugger_ipi_time;
	uint32_t                cpu_nested_istack;
	uint32_t                cpu_nested_istack_events;
	x86_saved_state64_t     *cpu_fatal_trap_state;
	x86_saved_state64_t     *cpu_post_fatal_trap_state;
	int                     cpu_type;
	int                     cpu_subtype;
	int                     cpu_threadtype;
	boolean_t               cpu_iflag;
	boolean_t               cpu_boot_complete;
	int                     cpu_hibernate;
	struct x86_lcpu         lcpu;
	int                     cpu_phys_number;        
	cpu_id_t                cpu_id;                 
	boolean_t               cpu_rendezvous_in_progress;
	uint32_t                cpu_soft_apic_lvt_timer;
} cpu_data_t;
struct cpu_cache {
	int     level; int     type;
} cpu_caches[LCACHE_MAX] = {
	[L1D] = {       1, CPU_CACHE_TYPE_DATA },
	[L1I] = {       1, CPU_CACHE_TYPE_INST },
	[L2U] = { 2, CPU_CACHE_TYPE_UNIF },
	[L3U] = { 3, CPU_CACHE_TYPE_UNIF },
};
struct x86_cpu_cache {
	struct x86_cpu_cache *next;     
	struct x86_die      *die;       
	uint8_t             maxcpus;    
	uint8_t             nlcpus;     
	uint8_t             type;       
	uint8_t             level;      
	uint16_t            ways;       
	uint16_t            partitions; 
	uint16_t            line_size;  
	uint32_t            cache_size; 
	struct x86_lcpu     *cpus[0];   
} x86_cpu_cache_t;
struct x86_lcpu {
	struct x86_lcpu     *next_in_core;
	struct x86_lcpu     *next_in_die;
	struct x86_lcpu     *next_in_pkg;
	struct x86_lcpu     *lcpu;      
	struct x86_core     *core;      
	struct x86_die      *die;       
	struct x86_pkg      *package;   
	struct cpu_data     *cpu;       
	uint32_t            flags;
	uint32_t            cpu_num;    
	uint32_t            lnum;       
	uint32_t            pnum;       
	boolean_t           master;     
	boolean_t           primary;    
	volatile lcpu_state_t       state;
	volatile boolean_t  stopped;    
	uint64_t            rtcPop;     
	uint64_t            rtcDeadline;
	x86_cpu_cache_t     *caches[MAX_CACHE_DEPTH];
	void                *pmStats;   
	void                *pmState;   
} x86_lcpu_t;
struct x86_core {
	struct x86_core     *next_in_die;
	struct x86_core     *next_in_pkg;
	struct x86_die      *die;       
	struct x86_pkg      *package;   
	struct x86_lcpu     *lcpus;     
	uint32_t            flags;
	uint32_t            lcore_num;  
	uint32_t            pcore_num;  
	uint32_t            num_lcpus;  
	uint32_t            active_lcpus;
	void                *pmStats;   
	void                *pmState;   
} x86_core_t;
struct x86_die {
	struct x86_die      *next_in_pkg;
	struct x86_lcpu     *lcpus;     
	struct x86_core     *cores;     
	struct x86_pkg      *package;   
	uint32_t            flags;
	uint32_t            ldie_num;   
	uint32_t            pdie_num;   
	uint32_t            num_cores;  
	x86_cpu_cache_t     *LLC;       
	void                *pmStats;   
	void                *pmState;   
} x86_die_t;
struct x86_pkg {
	struct x86_pkg      *next;      
	struct x86_lcpu     *lcpus;     
	struct x86_core     *cores;     
	struct x86_die      *dies;      
	uint32_t            flags;
	uint32_t            lpkg_num;   
	uint32_t            ppkg_num;   
	uint32_t            num_dies;   
	void                *pmStats;   
	void                *pmState;   
	struct mca_state    *mca_state; 
	uint64_t            package_idle_exits;
	uint32_t            num_idle;
} x86_pkg_t;
struct x86_topology_parameters {
	uint32_t            LLCDepth;
	uint32_t            nCoresSharingLLC;
	uint32_t            nLCPUsSharingLLC;
	uint32_t            maxSharingLLC;
	uint32_t            nLThreadsPerCore;
	uint32_t            nPThreadsPerCore;
	uint32_t            nLCoresPerDie;
	uint32_t            nPCoresPerDie;
	uint32_t            nLDiesPerPackage;
	uint32_t            nPDiesPerPackage;
	uint32_t            nLThreadsPerDie;
	uint32_t            nPThreadsPerDie;
	uint32_t            nLThreadsPerPackage;
	uint32_t            nPThreadsPerPackage;
	uint32_t            nLCoresPerPackage;
	uint32_t            nPCoresPerPackage;
	uint32_t            nPackages;
	boolean_t           stable;
} x86_topology_parameters_t;
struct {
	uint64_t caperf;
	uint64_t cmperf;
	uint64_t ccres[6];
	uint64_t crtimes[CPU_RTIME_BINS];
	uint64_t citimes[CPU_ITIME_BINS];
	uint64_t crtime_total;
	uint64_t citime_total;
	uint64_t cpu_idle_exits;
	uint64_t cpu_insns;
	uint64_t cpu_ucc;
	uint64_t cpu_urc;
} core_energy_stat_t;
struct {
	uint64_t pkes_version;
	uint64_t pkg_cres[2][7];
	uint64_t pkg_power_unit;
	uint64_t pkg_energy;
	uint64_t pp0_energy;
	uint64_t pp1_energy;
	uint64_t ddr_energy;
	uint64_t llc_flushed_cycles;
	uint64_t ring_ratio_instantaneous;
	uint64_t IA_frequency_clipping_cause;
	uint64_t GT_frequency_clipping_cause;
	uint64_t pkg_idle_exits;
	uint64_t pkg_rtimes[CPU_RTIME_BINS];
	uint64_t pkg_itimes[CPU_ITIME_BINS];
	uint64_t mbus_delay_time;
	uint64_t mint_delay_time;
	uint32_t ncpus;
	core_energy_stat_t cest[];
} pkg_energy_statistics_t;
struct diagWork {                       
	unsigned int dgLock;                    
	unsigned int dgFlags;                   

	unsigned int dgMisc0;
	unsigned int dgMisc1;
	unsigned int dgMisc2;
	unsigned int dgMisc3;
	unsigned int dgMisc4;
	unsigned int dgMisc5;
} diagWork;
struct exec {
	unsigned long a_text;   
	unsigned long a_data;   
	unsigned long a_bss;    
	unsigned long a_syms;   
	unsigned long a_entry;  
	unsigned long a_trsize; 
	unsigned long a_drsize; 
};
struct fp_avx512 {
	uint64_t *x_Opmask;
	reg256_t *x_ZMM_Hi256;
	reg512_t *x_Hi16_ZMM;
};
struct hpetReg {
	uint64_t        GCAP_ID;                
	uint64_t        rsv1;
	uint64_t        GEN_CONF;               
	uint64_t        rsv2;
	uint64_t        GINTR_STA;              
	uint64_t        rsv3[25];
	uint64_t        MAIN_CNT;               
	uint64_t        rsv4;
	uint64_t        TIM0_CONF;              
	uint64_t        TIM0_COMP;              
	uint64_t        rsv5[2];
	uint64_t        TIM1_CONF;              
	uint64_t        TIM1_COMP;              
	uint64_t        rsv6[2];
	uint64_t        TIM2_CONF;              
	uint64_t        TIM2_COMP;              
	uint64_t        rsv7[2];
} hpetReg;
struct hpetTimer {
	uint64_t        Config;         
	uint64_t        Compare;        
} hpetTimer_t;
struct hpetInfo {
	uint64_t        hpetCvtt2n;
	uint64_t        hpetCvtn2t;
	uint64_t        tsc2hpet;
	uint64_t        hpet2tsc;
	uint64_t        bus2hpet;
	uint64_t        hpet2bus;
	uint32_t        rcbaArea;
	uint32_t        rcbaAreap;
};
struct hpetRequest {
	uint32_t        flags;
	uint32_t        hpetOffset;
	uint32_t        hpetVector;
};
struct iopb_tss {
	struct i386_tss tss;            
	isa_iopb        bitmap;         
	unsigned int    barrier;        
	queue_head_t    io_port_list;   
	int             iopb_desc[2];   
};
struct {
	void            (*init)(void);
	uint32_t        (*read)(lapic_register_t);
	void            (*write)(lapic_register_t, uint32_t);
	uint64_t        (*read_icr)(void);
	void            (*write_icr)(uint32_t, uint32_t);
} lapic_ops_table_t;
struct lbr_data {
	uint64_t *from;
	uint64_t *to;
};
struct {
	volatile uintptr_t      interlock __kernel_data_semantics;
} lck_spin_t;
struct {
	machdep_call_routine_t      routine;
	int                         nargs;
	int                         bsd_style;
} machdep_call_t;
struct {
	ia32_mci_ctl_t          mca_mci_ctl;
	ia32_mci_status_t       mca_mci_status;
	ia32_mci_misc_t         mca_mci_misc;
	ia32_mci_addr_t         mca_mci_addr;
} mca_mci_bank_t;
struct mca_state {
	boolean_t               mca_is_saved;
	boolean_t               mca_is_valid;   
	ia32_mcg_ctl_t          mca_mcg_ctl;
	ia32_mcg_status_t       mca_mcg_status;
	mca_mci_bank_t          mca_error_bank[0];
} mca_state_t;
struct ml_processor_info {
	cpu_id_t                        cpu_id;
	boolean_t                       boot_cpu;
	vm_offset_t                     start_paddr;
	boolean_t                       supports_nap;
	unsigned long           l2cr_value;
	time_base_enable_t      time_base_enable;
};
struct ml_cpu_info {
	uint32_t        vector_unit;
	uint32_t        cache_line_size;
	uint32_t        l1_icache_size;
	uint32_t        l1_dcache_size;
	uint32_t        l2_settings;
	uint32_t        l2_cache_size;
	uint32_t        l3_settings;
	uint32_t        l3_cache_size;
};
struct cpu_warm_data {
	timer_call_t    cwd_call;
	uint64_t        cwd_deadline;
	int             cwd_result;
} *cpu_warm_data_t;
struct {
	int                     target_cpu;
	int                     target_lapic;
	int                     starter_cpu;
} processor_start_info_t;
struct {
	queue_chain_t   link;                   
	void            (*func)(void *, void *); 
	void            *arg0;                  
	void            *arg1;                  
	cpumask_t       *maskp;                 
} mp_call_t;
struct {
	queue_head_t            queue;
	decl_simple_lock_data(, lock);
} mp_call_queue_t;
struct {
	struct real_descriptor pcldts[LDTSZ];
} cldt_t;
struct cpu_desc_table64 {
	struct fake_descriptor  gdt[GDTSZ]       __attribute__ ((aligned(16)));
	struct x86_64_tss       ktss             __attribute__ ((aligned(16)));
	struct sysenter_stack   sstk             __attribute__ ((aligned(16)));
	uint8_t                 *fstkp;
} cpu_desc_table64_t;
struct {
	uint8_t                 fstk[FSTK_SZ]  __attribute__ ((aligned(16)));
} cpu_fault_stack_t;
struct mtrr_var_range {
	uint64_t  base;         
	uint64_t  mask;         
	uint32_t  refcnt;       
};
struct mtrr_fix_range {
	uint64_t  types;        
};
struct {
	uint64_t            MTRRcap;
	uint64_t            MTRRdefType;
	mtrr_var_range_t *  var_range;
	unsigned int        var_count;
	mtrr_fix_range_t    fix_range[11];
} mtrr_state;
struct pal_hib_ctx {
	char reserved;
};
struct pal_rtc_nanotime {
	volatile uint64_t       tsc_base;       
	volatile uint64_t       ns_base;        
	uint32_t                scale;          
	uint32_t                shift;          
	                                        
	volatile uint32_t       generation;     
	uint32_t                spare1;
};
struct pal_cpu_data {
};
struct pal_pcb {
};
struct pal_apic_table {
};
struct pal_efi_registers {
	uint64_t rcx;
	uint64_t rdx;
	uint64_t r8;
	uint64_t r9;
	uint64_t rax;
};
struct panic_hook {
	uint32_t                        magic1;
	queue_chain_t           chain;
	thread_t                        thread;
	panic_hook_fn_t         hook_fn;
	uint32_t                        magic2;
};
struct {
	uint64_t        opaque[6];
} panic_hook_t;
struct panic_phys_range {
	uint32_t type;
	uint64_t phys_start;
	uint64_t len;
} panic_phys_range_t;
struct x86_act_context32 {
	x86_saved_state32_t ss;
	x86_float_state32_t fs;
	x86_debug_state32_t ds;
};
struct x86_act_context64 {
	x86_saved_state64_t ss;
	x86_float_state64_t fs;
	x86_debug_state64_t ds;
};
struct lbr_group {
	uint32_t        msr_from;
	uint32_t        msr_to;
	uint32_t        msr_info;
};
struct cpu_lbrs {
	uint32_t                lbr_count;
	struct lbr_group        msr_lbrs[X86_MAX_LBRS];
};
struct pmap {
	lck_rw_t        pmap_rwl __attribute((aligned(64)));
	pmap_paddr_t    pm_cr3 __attribute((aligned(64))); 
	pmap_paddr_t    pm_ucr3;        
	pml4_entry_t    *pm_pml4;       
	pml4_entry_t    *pm_upml4;      
	pmap_paddr_t    pm_eptp;        

	task_map_t      pm_task_map;
	boolean_t       pagezero_accessible;
	boolean_t       pm_vm_map_cs_enforced; 
	pcid_t          pmap_pcid_cpus[PMAP_PCID_MAX_CPUS];
	volatile uint8_t pmap_pcid_coherency_vector[PMAP_PCID_MAX_CPUS];
	boolean_t       pm_shared;
	os_refcnt_t     ref_count;
	pdpt_entry_t    *pm_pdpt;       
	vm_object_t     pm_obj;         
	vm_object_t     pm_obj_pdpt;    
	vm_object_t     pm_obj_pml4;    
	ledger_t        ledger;         
	uint64_t        corrected_compressed_ptes_count;
};
struct pmap_memory_regions {
	ppnum_t base;            
	ppnum_t alloc_up;        
	ppnum_t alloc_down;      
	ppnum_t alloc_frag_up;   
	ppnum_t alloc_frag_down; 
	ppnum_t end;             
	uint32_t type;
	uint64_t attribute;
} pmap_memory_region_t;
struct pv_rooted_entry {
	queue_head_t            qlink;
	vm_map_offset_t         va_and_flags;   
	pmap_t                  pmap;   
} *pv_rooted_entry_t;
struct pv_hashed_entry {
	queue_head_t            qlink;
	vm_map_offset_t         va_and_flags;
	pmap_t                  pmap;
	ppnum_t                 ppn;
	struct pv_hashed_entry  *nexth;
} *pv_hashed_entry_t;
struct {
	pmap_pv_assertion_t incident;
	pmap_pagetable_corruption_t reason;
	pmap_pagetable_corruption_action_t action;
	pmap_t  pmap;
	vm_map_offset_t vaddr;
	pt_entry_t pte;
	ppnum_t ppn;
	pmap_t pvpmap;
	vm_map_offset_t pvva;
	uint64_t abstime;
	int adj_ptes_count;
	uint64_t adj_ptes[PMPTCR_MAX_ADJ_PTES];
} pmap_pagetable_corruption_record_t;
struct{
	kern_return_t       (*pmCPUStateInit)(void);
	void                (*cstateInit)(void);
	uint64_t            (*MachineIdle)(uint64_t maxIdleDuration);
	uint64_t            (*GetDeadline)(x86_lcpu_t *lcpu);
	uint64_t            (*SetDeadline)(x86_lcpu_t *lcpu, uint64_t);
	void                (*Deadline)(x86_lcpu_t *lcpu);
	boolean_t           (*exitIdle)(x86_lcpu_t *lcpu);
	void                (*markCPURunning)(x86_lcpu_t *lcpu);
	int                 (*pmCPUControl)(uint32_t cmd, void *datap);
	void                (*pmCPUHalt)(void);
	uint64_t            (*getMaxSnoop)(void);
	void                (*setMaxBusDelay)(uint64_t time);
	uint64_t            (*getMaxBusDelay)(void);
	void                (*setMaxIntDelay)(uint64_t time);
	uint64_t            (*getMaxIntDelay)(void);
	void                (*pmCPUSafeMode)(x86_lcpu_t *lcpu, uint32_t flags);
	void                (*pmTimerStateSave)(void);
	void                (*pmTimerStateRestore)(void);
	kern_return_t       (*exitHalt)(x86_lcpu_t *lcpu);
	kern_return_t       (*exitHaltToOff)(x86_lcpu_t *lcpu);
	void                (*markAllCPUsOff)(void);
	void                (*pmSetRunCount)(uint32_t count);
	boolean_t           (*pmIsCPUUnAvailable)(x86_lcpu_t *lcpu);
	int                 (*pmChooseCPU)(int startCPU, int endCPU, int preferredCPU);
	int                 (*pmIPIHandler)(void *state);
	void                (*pmThreadTellUrgency)(int urgency, uint64_t rt_period, uint64_t rt_deadline);
	void                (*pmActiveRTThreads)(boolean_t active);
	boolean_t           (*pmInterruptPrewakeApplicable)(void);
	void                (*pmThreadGoingOffCore)(thread_t old_thread, boolean_t transfer_load,
	    uint64_t last_dispatch, boolean_t thread_runnable);
} pmDispatch_t;
struct pm_rtc_nanotime {
	uint64_t        tsc_base;               
	uint64_t        ns_base;                
	uint32_t        scale;                  
	uint32_t        shift;                  
	uint32_t        generation;             
} pm_rtc_nanotime_t;
struct {
	uint64_t            (*setRTCPop)(uint64_t time);
	void                (*resyncDeadlines)(int cpu);
	void                (*initComplete)(void);
	x86_lcpu_t          *(*GetLCPU)(int cpu);
	x86_core_t          *(*GetCore)(int cpu);
	x86_die_t           *(*GetDie)(int cpu);
	x86_pkg_t           *(*GetPackage)(int cpu);
	x86_lcpu_t          *(*GetMyLCPU)(void);
	x86_core_t          *(*GetMyCore)(void);
	x86_die_t           *(*GetMyDie)(void);
	x86_pkg_t           *(*GetMyPackage)(void);
	x86_pkg_t           *(*GetPkgRoot)(void);
	void                (*LockCPUTopology)(int lock);
	boolean_t           (*GetHibernate)(int cpu);
	processor_t         (*LCPUtoProcessor)(int lcpu);
	processor_t         (*ThreadBind)(processor_t proc);
	uint32_t            (*GetSavedRunCount)(void);
	void                (*pmSendIPI)(int cpu);
	void                (*GetNanotimeInfo)(pm_rtc_nanotime_t *);
	int                 (*ThreadGetUrgency)(uint64_t *rt_period, uint64_t *rt_deadline);
	uint32_t            (*timerQueueMigrate)(int cpu);
	void                (*RTCClockAdjust)(uint64_t adjustment);
	x86_topology_parameters_t   *topoParms;
	boolean_t           (*InterruptPending)(void);
	boolean_t           (*IsInterrupting)(uint8_t vector);
	void                (*InterruptStats)(uint64_t intrs[256]);
	void                (*DisableApicTimer)(void);
} pmCallBacks_t;
struct x86_lbr_record {
	uint64_t        from_rip;
	uint64_t        to_rip;
	uint64_t        info;
};
struct x86_lbrs {
	uint64_t                lbr_tos;
	struct x86_lbr_record   lbrs[X86_MAX_LBRS];
} x86_lbrs_t;
struct {
	void     (*rtc_config)(void);
	uint64_t (*rtc_set)(uint64_t, uint64_t);
} rtc_timer_t;
struct real_descriptor {
	uint32_t        limit_low:16,   
	    base_low:16,                
	    base_med:8,                 
	    access:8,                   
	    limit_high:4,               
	    granularity:4,              
	    base_high:8;                
};
struct real_descriptor64 {
	uint32_t        limit_low16:16, 
	    base_low16:16,              
	    base_med8:8,                
	    access8:8,                  
	    limit_high4:4,              
	    granularity4:4,             
	    base_high8:8,               
	    base_top32:32,              
	    reserved32:32;              
};
struct real_gate {
	uint32_t        offset_low:16,  
	    selector:16,
	    word_count:8,
	    access:8,
	    offset_high:16;             
};
struct real_gate64 {
	uint32_t        offset_low16:16,        
	    selector16:16,
	    IST:3,
	    zeroes5:5,
	    access8:8,
	    offset_high16:16,                   
	    offset_top32:32,                    
	    reserved32:32;                      
};
struct fake_descriptor {
	uint32_t        offset:32;              
	uint32_t        lim_or_seg:20;          
	                                        
	uint32_t        size_or_wdct:4;         
	                                        
	uint32_t        access:8;               
};
struct fake_descriptor64 {
	uint64_t        offset64;               
	uint32_t        lim_or_seg:20;          
	                                        
	uint32_t        size_or_IST:4;          
	                                        
	uint32_t        access:8;               
	uint32_t        reserved:32;            
};
struct jmp_buf {
	int     jmp_buf[6];     
} jmp_buf_t;
struct uslock_debug {
	void                    *lock_pc;       
	void                    *lock_thread;   
	void                    *unlock_thread; 
	void                    *unlock_pc;     
	unsigned long   duration[2];
	unsigned short  state;
	unsigned char   lock_cpu;
	unsigned char   unlock_cpu;
} uslock_debug;
struct slock {
	hw_lock_data_t  interlock;      
} usimple_lock_data_t, *usimple_lock_t;
struct x86_kernel_state {
	uint64_t        k_rbx;  
	uint64_t        k_rsp;
	uint64_t        k_rbp;
	uint64_t        k_r12;
	uint64_t        k_r13;
	uint64_t        k_r14;
	uint64_t        k_r15;
	uint64_t        k_rip;
};
struct machine_thread {
	x86_saved_state_t       *iss;
	void                    *ifps;
	void                    *ids;
	decl_simple_lock_data(, lock);           
	xstate_t                xstate;


	struct pal_pcb          pal_pcb;
	uint32_t                specFlags;
	uint64_t                thread_gpu_ns;
	uint32_t                last_xcpm_ttd;
	uint8_t                 last_xcpm_index;
	int                     mthr_do_segchk;
	int                     insn_state_copyin_failure_errorcode;    
	x86_instruction_state_t *insn_state;
	x86_lbrs_t              lbrs;
	bool                    insn_copy_optout;
};
struct recovery {
	uintptr_t       fault_addr;
	uintptr_t       recover_addr;
};
struct tscInfo {
	uint64_t        busFCvtt2n;
	uint64_t        busFCvtn2t;
	uint64_t        tscFreq;
	uint64_t        tscFCvtt2n;
	uint64_t        tscFCvtn2t;
	uint64_t        tscGranularity;
	uint64_t        bus2tsc;
	uint64_t        busFreq;
	uint32_t        flex_ratio;
	uint32_t        flex_ratio_min;
	uint32_t        flex_ratio_max;
};
struct i386_tss {
	uint32_t        back_link;      
	uint32_t        esp0;           
	uint32_t        ss0;            
	uint32_t        esp1;           
	uint32_t        ss1;            
	uint32_t        esp2;           
	uint32_t        ss2;            
	uint32_t        cr3;            
	uint32_t        eip;
	uint32_t        eflags;
	uint32_t        eax;
	uint32_t        ecx;
	uint32_t        edx;
	uint32_t        ebx;
	uint32_t        esp;            
	uint32_t        ebp;
	uint32_t        esi;
	uint32_t        edi;
	uint32_t        es;
	uint32_t        cs;
	uint32_t        ss;             
	uint32_t        ds;
	uint32_t        fs;
	uint32_t        gs;
	uint32_t        ldt;            
	uint16_t        trace_trap;     
	uint16_t        io_bit_map_offset;
};
struct sysenter_stack {
	uint64_t        sysestack[64];  
	uint64_t        top;            
};
struct x86_64_tss {
	uint32_t        reserved1;
	uint64_t        rsp0;           
	uint64_t        rsp1;           
	uint64_t        rsp2;           
	uint32_t        reserved2;
	uint32_t        reserved3;
	uint64_t        ist1;           
	uint64_t        ist2;           
	uint64_t        ist3;           
	uint64_t        ist4;           
	uint64_t        ist5;           
	uint64_t        ist6;           
	uint64_t        ist7;           
	uint32_t        reserved4;
	uint32_t        reserved5;
	uint16_t        reserved6;
	uint16_t        io_bit_map_offset;
};
struct intel_ucupdate {
	uint32_t header_version;
	uint32_t update_revision;
	uint32_t date;
	uint32_t processor_signature;
	uint32_t checksum;
	uint32_t loader_revision;
	uint32_t processor_flags;
	uint32_t data_size;
	uint32_t total_size;

	uint32_t reserved0;
	uint32_t reserved1;
	uint32_t reserved2;

	uint32_t data;
};
struct hvg_hcall_output_regs {
	uint64_t   rax;
	uint64_t   rdi;
	uint64_t   rsi;
	uint64_t   rdx;
	uint64_t   rcx;
	uint64_t   r8;
	uint64_t   r9;
} hvg_hcall_output_regs_t;
struct ipc_entry {
	union {
		struct ipc_object *XNU_PTRAUTH_SIGNED_PTR("ipc_entry.ie_object") ie_object;
		struct ipc_port   *XNU_PTRAUTH_SIGNED_PTR("ipc_entry.ie_object") ie_port;
		struct ipc_pset   *XNU_PTRAUTH_SIGNED_PTR("ipc_entry.ie_object") ie_pset;
		struct ipc_object *XNU_PTRAUTH_SIGNED_PTR("ipc_entry.ie_object") volatile ie_volatile_object;
		struct ipc_entry_table *XNU_PTRAUTH_SIGNED_PTR("ipc_entry.ie_self") ie_self;
	};
	union {
		struct {
			ipc_entry_bits_t    ie_bits;
			union {
				mach_port_index_t ie_next;         
				ipc_table_index_t ie_request;      
			};

			
			uint32_t            ie_dist;
			mach_port_index_t   ie_index;
		};
		struct smr_node             ie_smr_node;
	};
};
struct ipc_eventlink {
	ipc_port_t                  el_port;             
	thread_t                    el_thread;           
	struct ipc_eventlink_base   *el_base;            
	uint64_t                    el_sync_counter;     
	uint64_t                    el_wait_counter;     
};
struct ipc_eventlink_base {
	struct ipc_eventlink          elb_eventlink[2];  
	struct waitq                  elb_waitq;         
	os_refcnt_t                   elb_ref_count;     
	uint8_t                       elb_type;
};
struct ipc_importance_elem {
	os_ref_atomic_t                         iie_bits;       
	mach_voucher_attr_value_reference_t     iie_made;       
	queue_head_t                            iie_kmsgs;      
	uint32_t                                iie_externcnt;  
	uint32_t                                iie_externdrop; 
	uint32_t iie_refs_added;                        
	uint32_t iie_refs_dropped;                      
	uint32_t iie_kmsg_refs_added;                   
	uint32_t iie_kmsg_refs_inherited;               
	uint32_t iie_kmsg_refs_coalesced;               
	uint32_t iie_kmsg_refs_dropped;                 
	uint32_t iie_task_refs_added;                   
	uint32_t iie_task_refs_added_inherit_from;      
	uint32_t iie_task_refs_added_transition;        
	uint32_t iie_task_refs_self_added;              
	uint32_t iie_task_refs_inherited;               
	uint32_t iie_task_refs_coalesced;               
	uint32_t iie_task_refs_dropped;                 
};
struct ipc_importance_task {
	struct ipc_importance_elem iit_elem;    
	task_t                  iit_task;       
	queue_head_t            iit_inherits;   
	queue_t                 iit_updateq;    
	queue_chain_t           iit_updates;    
	queue_chain_t           iit_props;      
	uint64_t                iit_updatetime; 
	uint64_t                iit_transitions;
	uint32_t                iit_assertcnt;  
	uint32_t                iit_legacy_externcnt;  
	uint32_t                iit_legacy_externdrop; 
	uint32_t                iit_receiver:1, 
	    iit_denap:1,                        
	    iit_donor:1,                        
	    iit_live_donor:1,                          
	    iit_updatepolicy:1,                        
	    iit_reserved:3,                            
	    iit_filelocks:24;                          
};
struct ipc_importance_inherit {
	struct ipc_importance_elem      iii_elem;         
	boolean_t                       iii_donating;     
	uint32_t                        iii_depth;        
	ipc_importance_task_t           iii_to_task;      
	ipc_importance_elem_t           iii_from_elem;    
	queue_chain_t                   iii_inheritance;  
};
struct {
	mach_msg_header_t      *msg;

	mach_port_name_t        dest_name;
	mach_msg_type_name_t    dest_type;
	ipc_port_t              dest_port;
	ipc_copyin_cleanup_t    dest_cleanup;

	mach_port_name_t        reply_name;
	mach_msg_type_name_t    reply_type;
	ipc_port_t              reply_port;
	ipc_copyin_cleanup_t    reply_cleanup;

	mach_port_name_t        voucher_name;
	mach_msg_type_name_t    voucher_type;
	ipc_port_t              voucher_port;
	ipc_copyin_cleanup_t    voucher_cleanup;

	ipc_table_index_t       dest_request;
	ipc_policy_violation_id_t reply_port_semantics_violation;
} ikm_copyinhdr_state_t;
struct {
	char                   *dctx_uhdr;
	char                   *dctx_udata;
	mach_msg_max_trailer_t *dctx_trailer;
	mach_msg_aux_header_t  *dctx_aux_hdr;
	mach_msg_size_t         dctx_uhdr_size;
	mach_msg_size_t         dctx_udata_size;
	mach_msg_size_t         dctx_trailer_size;
	mach_msg_size_t         dctx_aux_size;
	bool                    dctx_isU64;
} ikm_deflate_context_t;
struct ipc_kmsg {
	queue_chain_t              ikm_link;
	ipc_port_t                 XNU_PTRAUTH_SIGNED_PTR("kmsg.ikm_voucher_port") ikm_voucher_port;   
	struct ipc_importance_elem *ikm_importance;  
	queue_chain_t              ikm_inheritance;  
	uint16_t                   ikm_aux_size;     
	ipc_kmsg_keep_alive_t      ikm_keep_alive;   
	uint8_t                    __ikm_padding;
	uint32_t                   ikm_ppriority;    
	uint32_t                   ikm_signature;    
	ipc_object_copyin_flags_t  ikm_flags;
	mach_msg_qos_t             ikm_qos_override; 

	mach_msg_type_name_t       ikm_voucher_type: 6; 
	ipc_kmsg_type_t            ikm_type: 2;

	union {
		
		uint32_t           ikm_big_data[IKM_BIG_MSG_SIZE / 4];
		struct {
			uint32_t   ikm_small_data[IKM_SMALL_MSG_SIZE / 4];
			void *XNU_PTRAUTH_SIGNED_PTR("kmsg.ikm_kdata") ikm_kdata;
			void *XNU_PTRAUTH_SIGNED_PTR("kmsg.ikm_udata") ikm_udata;
			mach_msg_size_t ikm_kdata_size;
			mach_msg_size_t ikm_udata_size;
		} __attribute__((packed, aligned(4)));
	};
};
struct ipc_object_waitq {
	struct ipc_object       iowq_object;
	struct waitq            iowq_waitq;
};
struct ipc_mqueue {
	circle_queue_head_t     imq_messages;
	mach_port_seqno_t       imq_seqno;
	mach_port_name_t        imq_receiver_name;
	uint16_t                imq_msgcount;
	uint16_t                imq_qlimit;
	uint32_t                imq_context;
	union {
		
		struct klist            imq_klist;
		struct knote            *XNU_PTRAUTH_SIGNED_PTR("ipc_mqueue.knote") imq_inheritor_knote;
		struct turnstile        *XNU_PTRAUTH_SIGNED_PTR("ipc_mqueue.turnstile") imq_inheritor_turnstile;
		thread_t                XNU_PTRAUTH_SIGNED_PTR("ipc_mqueue.thread_ref") imq_inheritor_thread_ref;
		thread_t                XNU_PTRAUTH_SIGNED_PTR("ipc_mqueue.srp_owner_thread") imq_srp_owner_thread;
	};
} *ipc_mqueue_t;
struct ipc_notify_nsenders {
	ipc_port_t              ns_notify;
	mach_port_mscount_t     ns_mscount;
	boolean_t               ns_is_kobject;
} ipc_notify_nsenders_t;
struct ipc_object {
	ipc_object_bits_t _Atomic io_bits;
	ipc_object_refs_t _Atomic io_references;
} __attribute__((aligned(8)));
struct ipc_policy_violations_rb_entry {
	char proc_name[CA_PROCNAME_LEN];
	char service_name[CA_MACH_SERVICE_PORT_NAME_LEN];
	char team_id[CA_TEAMID_MAX_LEN];
	char signing_id[CA_SIGNINGID_MAX_LEN];
	ipc_policy_violation_id_t violation_id;
	int  sw_platform;
	int  msgh_id;
	int  sdk;
};
struct ipc_port_request {
	union {
		struct ipc_port                *ipr_soright;
		struct host_notify_entry *XNU_PTRAUTH_SIGNED_PTR("ipc_port_request.ipr_hnotify") ipr_hnotify;
		struct ipc_port_request *XNU_PTRAUTH_SIGNED_PTR("ipc_port_request.ipr_hn_slot") ipr_hn_slot;
	};

	union {
		mach_port_name_t                ipr_name;
		ipc_port_request_index_t        ipr_next;
	};
};
struct ipc_port {
	struct ipc_object               ip_object;
	union {
		
		WAITQ_FLAGS(ip_waitq
		    , ip_fullwaiters:1            
		    , ip_sprequests:1             
		    , ip_spimportant:1            
		    , ip_impdonation:1            
		    , ip_tempowner:1              
		    , ip_guarded:1                
		    , ip_strict_guard:1           
		    , ip_specialreply:1           
		    , ip_sync_link_state:3        
		    , ip_sync_bootstrap_checkin:1 
		    , ip_immovable_receive:1      
		    , ip_immovable_send:1         
		    , ip_no_grant:1               
		    , ip_tg_block_tracking:1      
		    , ip_pinned:1                 
		    , ip_service_port:1           
		    , ip_has_watchport:1          
		    , ip_kernel_iotier_override:2 
		    , ip_kernel_qos_override:3    
		    , ip_reply_port_semantics:3   
		    );
		struct waitq            ip_waitq;
	};

	struct ipc_mqueue               ip_messages;

	union {
		struct ipc_space       *XNU_PTRAUTH_SIGNED_PTR("ipc_port.ip_receiver") ip_receiver;
		struct ipc_port        *XNU_PTRAUTH_SIGNED_PTR("ipc_port.ip_destination") ip_destination;
		ipc_port_timestamp_t    ip_timestamp;
	};

	union {
		uintptr_t               ip_kobject; 
		ipc_importance_task_t   ip_imp_task; 
		struct ipc_port        *ip_sync_inheritor_port;
		struct knote           *ip_sync_inheritor_knote;
		struct turnstile       *ip_sync_inheritor_ts;
	};

	union {
		int                     ip_pid;
		struct task_watchport_elem *XNU_PTRAUTH_SIGNED_PTR("ipc_port.ip_twe") ip_twe;
		struct ipc_port *XNU_PTRAUTH_SIGNED_PTR("ipc_port.ip_pdrequest") ip_pdrequest;
	};

	struct ipc_port                *ip_nsrequest;
	ipc_port_request_table_t XNU_PTRAUTH_SIGNED_PTR("ipc_port.ip_request") ip_requests;
	struct turnstile               *ip_send_turnstile;
	mach_vm_address_t               ip_context;

	mach_port_mscount_t             ip_mscount;
	mach_port_rights_t              ip_srights;
	mach_port_rights_t              ip_sorights;

	union {
		ipc_kobject_label_t XNU_PTRAUTH_SIGNED_PTR("ipc_port.kolabel") ip_kolabel;
		
		void * XNU_PTRAUTH_SIGNED_PTR("ipc_port.ip_splabel") ip_splabel;
	};

};
struct thread_attr_for_ipc_propagation {
	union {
		struct {
			uint64_t tafip_iotier:2,
			    tafip_qos:3;
		};
		uint64_t tafip_value;
	};
	uint64_t tafip_reserved;
};
struct ipc_pset {
	struct ipc_object       ips_object;
	struct waitq_set        ips_wqset;
	struct klist            ips_klist;
};
struct {
	ipc_port_t              icc_release_port;
	ipc_port_t              icc_deleted_port;
} ipc_copyin_cleanup_t;
struct {
	waitq_link_list_t       icrc_free_list;
	mach_msg_guarded_port_descriptor_t *icrc_guarded_desc;
} ipc_copyin_rcleanup_t;
struct ipc_service_port_label {
	void * XNU_PTRAUTH_SIGNED_PTR("ipc_service_port_label.ispl_sblabel") ispl_sblabel; 
	mach_port_context_t               ispl_launchd_context;     
	mach_port_name_t                  ispl_launchd_name;        
	ipc_service_port_label_flags_t    ispl_flags;
};
struct ipc_space {
	lck_ticket_t    is_lock;
	os_ref_atomic_t is_bits;        
	ipc_entry_num_t is_table_hashed;
	ipc_entry_num_t is_table_free;  
	SMR_POINTER(ipc_entry_table_t XNU_PTRAUTH_SIGNED_PTR("ipc_space.is_table")) is_table; 
	task_t XNU_PTRAUTH_SIGNED_PTR("ipc_space.is_task") is_task; 
	thread_t        is_grower;      
	ipc_label_t     is_label;       
	ipc_entry_num_t is_low_mod;     
	ipc_entry_num_t is_high_mod;    
	struct bool_gen bool_gen;       
	unsigned int    is_entropy[IS_ENTROPY_CNT]; 
	int             is_node_id;     
};
struct ipc_voucher {
	os_ref_atomic_t         iv_refs;        
	iv_index_t              iv_table[MACH_VOUCHER_ATTR_KEY_NUM];
	ipc_port_t              iv_port;        
	struct smrq_slink       iv_hash_link;   
};
struct ivac_entry_s {
	iv_value_handle_t       ivace_value;
	iv_value_refs_t         ivace_layered:1,     
	    ivace_releasing:1,                       
	    ivace_free:1,                            
	    ivace_persist:1,                         
	    ivace_refs:28;                           
	union {
		iv_value_refs_t ivaceu_made;         
		iv_index_t      ivaceu_layer;        
	} ivace_u;
	iv_index_t              ivace_next;          
	iv_index_t              ivace_index;         
};
struct ipc_voucher_attr_control {
	boolean_t               ivac_is_growing;        
	ivac_entry_t            ivac_table;             
	iv_index_t              ivac_table_size;        
	iv_index_t              ivac_init_table_size;   
	iv_index_t              ivac_freelist;          
	lck_spin_t              ivac_lock_data;
	iv_index_t              ivac_key_index;
};
struct ipc_voucher_attr_recipe_data {
	mach_voucher_attr_key_t                 key;
	mach_voucher_attr_recipe_command_t      command;
	ipc_voucher_t                           previous_voucher;
	mach_voucher_attr_content_size_t        content_size;
	uint8_t                                 content[];
} ipc_voucher_attr_recipe_data_t;
struct ipc_voucher_attr_manager {
	ipc_voucher_attr_manager_release_value_t        ivam_release_value;
	ipc_voucher_attr_manager_get_value_t            ivam_get_value;
	ipc_voucher_attr_manager_extract_content_t      ivam_extract_content;
	ipc_voucher_attr_manager_command_t              ivam_command;
	ipc_voucher_attr_manager_flags                  ivam_flags;
};
struct main_bin_spec_note {
	uint32_t version;       
	uint32_t type;          
	uint64_t address;       
	uuid_t   uuid;          
	uint32_t log2_pagesize; 
	uint32_t unused;        
} __attribute__((packed)) main_bin_spec_note_t;
struct load_binary_spec_note {
	uint32_t version;    
	uuid_t   uuid;       
	uint64_t address;    
	uint64_t slide;      
	                     
	                     
	char     name_cstring[LOAD_BINARY_NAME_BUF_SIZE];
} __attribute__((packed)) load_binary_spec_note_t;
struct addrable_bits_note {
	uint32_t version;            
	uint32_t addressing_bits;    
	uint64_t unused;             
} __attribute__((packed)) addrable_bits_note_t;
struct panic_context_note {
	uuid_string_t kernel_uuid_string;
} __attribute__((packed)) panic_context_note_t;
struct{
	mach_vm_address_t       address;
	uint32_t        bytesused;
	uint8_t         oldbytes[MAX_BREAKINSN_BYTES];
} kdp_breakpoint_record_t;
struct kdp_fault_result {
	kdp_fault_result_flags_t flags;
	uint64_t time_spent_faulting;
};
struct  corehdr {
	short   th_opcode;              
	union {
		unsigned int    tu_block;       
		unsigned int    tu_code;        
		char    tu_rpl[1];      
	} th_u;
	char    th_data[0];             
}__attribute__((packed));
struct user32_dyld_image_info {
	user32_addr_t   imageLoadAddress;       
	user32_addr_t   imageFilePath;          
	user32_ulong_t  imageFileModDate;       
};
struct user64_dyld_image_info {
	user64_addr_t   imageLoadAddress;       
	user64_addr_t   imageFilePath;          
	user64_ulong_t  imageFileModDate;       
};
struct user32_dyld_all_image_infos {
	uint32_t                                        version;
	uint32_t                                        infoArrayCount;
	user32_addr_t                           infoArray;
	user32_addr_t                           notification;
	dyld_bool                                       processDetachedFromSharedRegion;
	dyld_bool                                       libSystemInitialized;
	user32_addr_t                           dyldImageLoadAddress;
	user32_addr_t                           jitInfo;
	user32_addr_t                           dyldVersion;
	user32_addr_t                           errorMessage;
	user32_addr_t                           terminationFlags;
	user32_addr_t                           coreSymbolicationShmPage;
	user32_addr_t                           systemOrderFlag;
	user32_size_t uuidArrayCount; 
	user32_addr_t uuidArray;
	user32_addr_t dyldAllImageInfosAddress;

	user32_addr_t initialImageCount;
	user32_addr_t errorKind;
	user32_addr_t errorClientOfDylibPath;
	user32_addr_t errorTargetDylibPath;
	user32_addr_t errorSymbol;
	user32_addr_t sharedCacheSlide;
	uint8_t sharedCacheUUID[16];
	user32_addr_t   sharedCacheBaseAddress;
	uint64_t        timestamp;
	user32_addr_t   dyldpath;
	mach_port_name_t notifyMachPorts[DYLD_MAX_PROCESS_INFO_NOTIFY_COUNT];
	user32_addr_t   reserved[5];
	user32_addr_t compact_dyld_image_info_addr;
	user32_size_t compact_dyld_image_info_size;
};
struct user64_dyld_all_image_infos {
	uint32_t                                        version;
	uint32_t                                        infoArrayCount;
	user64_addr_t                           infoArray;
	user64_addr_t                           notification;
	dyld_bool                                       processDetachedFromSharedRegion;
	dyld_bool                                       libSystemInitialized;
	user64_addr_t                           dyldImageLoadAddress;
	user64_addr_t                           jitInfo;
	user64_addr_t                           dyldVersion;
	user64_addr_t                           errorMessage;
	user64_addr_t                           terminationFlags;
	user64_addr_t                           coreSymbolicationShmPage;
	user64_addr_t                           systemOrderFlag;
	user64_size_t uuidArrayCount; 
	user64_addr_t uuidArray;
	user64_addr_t dyldAllImageInfosAddress;

	user64_addr_t initialImageCount;
	user64_addr_t errorKind;
	user64_addr_t errorClientOfDylibPath;
	user64_addr_t errorTargetDylibPath;
	user64_addr_t errorSymbol;
	user64_addr_t sharedCacheSlide;
	uint8_t sharedCacheUUID[16];
	user64_addr_t   sharedCacheBaseAddress;
	uint64_t        timestamp;
	user64_addr_t   dyldPath;
	mach_port_name_t notifyMachPorts[DYLD_MAX_PROCESS_INFO_NOTIFY_COUNT];
	user64_addr_t   reserved[9];
	user64_addr_t compact_dyld_image_info_addr;
	user64_size_t compact_dyld_image_info_size;
	uint32_t        platform;
	uint32_t                                aotInfoArrayCount;
	user64_addr_t                           aotInfoArray;
	uint64_t                                aotTimestamp;
};
struct {
	void                        *saved_state;
	thread_t                    kdp_thread;
	int                         kdp_cpu;
	uint32_t                    session_key;
	unsigned int                conn_seq;
	unsigned short              reply_port;
	unsigned short              exception_port;
	boolean_t                   is_conn;
	boolean_t                   is_halted;
	unsigned char               exception_seq;
	boolean_t                   exception_ack_needed;
} kdp_glob_t;
struct kdp_core_out_state {
	STAILQ_HEAD(, kdp_output_stage) kcos_out_stage;
	struct kdp_output_stage *       kcos_encryption_stage;
	bool                            kcos_enforce_encryption;
	uint64_t                        kcos_totalbytes;
	uint64_t                        kcos_bytes_written;
	uint64_t                        kcos_lastpercent;
	kern_return_t                   kcos_error;
};
struct kdp_output_stage_funcs {
	void (*kosf_reset)(struct kdp_output_stage *stage);
	kern_return_t (*kosf_outproc)(struct kdp_output_stage *stage, unsigned int request,
	    char *corename, uint64_t length, void *panic_data);
	void (*kosf_free)(struct kdp_output_stage *stage);
};
struct kdp_output_stage {
	STAILQ_ENTRY(kdp_output_stage) kos_next;
	bool                           kos_initialized;
	struct kdp_core_out_state *    kos_outstate;
	struct kdp_output_stage_funcs  kos_funcs;
	uint64_t                       kos_bytes_written; 
	bool                           kos_bypass;
	void *                         kos_data;
	size_t                         kos_data_size;
};
struct {
	kdp_req_t       request:7;      
	unsigned        is_reply:1;     
	unsigned        seq:8;          
	unsigned        len:16;         
	unsigned        key;            
} KDP_PACKED kdp_hdr_t;
struct {                        
	kdp_hdr_t       hdr;
	uint16_t        req_reply_port; 
	uint16_t        exc_note_port;  
	char            greeting[0];    
} KDP_PACKED kdp_connect_req_t;
struct {                        
	kdp_hdr_t       hdr;
	kdp_error_t     error;
} KDP_PACKED kdp_connect_reply_t;
struct {                        
	kdp_hdr_t       hdr;
} KDP_PACKED kdp_disconnect_req_t;
struct {                        
	kdp_hdr_t       hdr;
} KDP_PACKED kdp_disconnect_reply_t;
struct {
	kdp_hdr_t hdr;
	uint16_t req_reply_port; 
} KDP_PACKED kdp_reattach_req_t;
struct {                        
	kdp_hdr_t       hdr;
} KDP_PACKED kdp_hostinfo_req_t;
struct {
	uint32_t                cpus_mask;      
	uint32_t                cpu_type;
	uint32_t                cpu_subtype;
} KDP_PACKED kdp_hostinfo_t;
struct {                        
	kdp_hdr_t       hdr;
	kdp_hostinfo_t  hostinfo;
} KDP_PACKED kdp_hostinfo_reply_t;
struct {                        
	kdp_hdr_t       hdr;
} KDP_PACKED kdp_version_req_t;
struct {                        
	kdp_hdr_t       hdr;
	uint32_t        version;
	uint32_t        feature;
	uint32_t        pad0;
	uint32_t        pad1;
} KDP_PACKED kdp_version_reply_t;
struct {                        
	kdp_hdr_t       hdr;
} KDP_PACKED kdp_regions_req_t;
struct {
	uint32_t        address;
	uint32_t        nbytes;
	uint32_t        protection;     
} KDP_PACKED kdp_region_t;
struct {                        
	kdp_hdr_t       hdr;
	uint32_t        nregions;
	kdp_region_t    regions[0];
} KDP_PACKED kdp_regions_reply_t;
struct {                        
	kdp_hdr_t       hdr;
} KDP_PACKED kdp_maxbytes_req_t;
struct {                        
	kdp_hdr_t       hdr;
	uint32_t        max_bytes;
} KDP_PACKED kdp_maxbytes_reply_t;
struct {                        
	kdp_hdr_t       hdr;
	uint32_t        address;
	uint32_t        nbytes;
} KDP_PACKED kdp_readmem_req_t;
struct {                        
	kdp_hdr_t       hdr;
	kdp_error_t     error;
	char            data[0];
} KDP_PACKED kdp_readmem_reply_t;
struct {                        
	kdp_hdr_t       hdr;
	uint64_t        address;
	uint32_t        nbytes;
} KDP_PACKED kdp_readmem64_req_t;
struct {                        
	kdp_hdr_t       hdr;
	kdp_error_t     error;
	char            data[0];
} KDP_PACKED kdp_readmem64_reply_t;
struct {                        
	kdp_hdr_t       hdr;
	uint64_t        address;
	uint32_t        nbytes;
	uint16_t        lcpu;
} KDP_PACKED kdp_readphysmem64_req_t;
struct {                        
	kdp_hdr_t       hdr;
	kdp_error_t     error;
	char            data[0];
} KDP_PACKED kdp_readphysmem64_reply_t;
struct {                        
	kdp_hdr_t       hdr;
	uint32_t        address;
	uint32_t        nbytes;
	char            data[0];
} KDP_PACKED kdp_writemem_req_t;
struct {                        
	kdp_hdr_t       hdr;
	kdp_error_t     error;
} KDP_PACKED kdp_writemem_reply_t;
struct {                        
	kdp_hdr_t       hdr;
	uint64_t        address;
	uint32_t        nbytes;
	char            data[0];
} KDP_PACKED kdp_writemem64_req_t;
struct {                        
	kdp_hdr_t       hdr;
	kdp_error_t     error;
} KDP_PACKED kdp_writemem64_reply_t;
struct {                        
	kdp_hdr_t       hdr;
	uint64_t        address;
	uint32_t        nbytes;
	uint16_t        lcpu;
	char            data[0];
} KDP_PACKED kdp_writephysmem64_req_t;
struct {                        
	kdp_hdr_t       hdr;
	kdp_error_t     error;
} KDP_PACKED kdp_writephysmem64_reply_t;
struct {                        
	kdp_hdr_t       hdr;
	uint16_t        lcpu;
	uint16_t        address;
	uint16_t        nbytes;
	char            data[0];
} KDP_PACKED kdp_writeioport_req_t;
struct {                        
	kdp_hdr_t       hdr;
	kdp_error_t     error;
} KDP_PACKED kdp_writeioport_reply_t;
struct {                        
	kdp_hdr_t       hdr;
	uint16_t        lcpu;
	uint16_t        address;
	uint16_t        nbytes;
} KDP_PACKED kdp_readioport_req_t;
struct {                        
	kdp_hdr_t       hdr;
	kdp_error_t     error;
	char            data[0];
} KDP_PACKED kdp_readioport_reply_t;
struct {                        
	kdp_hdr_t       hdr;
	uint32_t        address;
	uint16_t        lcpu;
	char            data[0];
} KDP_PACKED kdp_writemsr64_req_t;
struct {                        
	kdp_hdr_t       hdr;
	kdp_error_t     error;
} KDP_PACKED kdp_writemsr64_reply_t;
struct {                        
	kdp_hdr_t       hdr;
	uint32_t        address;
	uint16_t        lcpu;
} KDP_PACKED kdp_readmsr64_req_t;
struct {                        
	kdp_hdr_t       hdr;
	kdp_error_t     error;
	char            data[0];
} KDP_PACKED kdp_readmsr64_reply_t;
struct {                        
	kdp_hdr_t       hdr;
	uint32_t        cpu;
	uint32_t        flavor;
} KDP_PACKED kdp_readregs_req_t;
struct {                        
	kdp_hdr_t       hdr;
	kdp_error_t     error;          
	char            data[0];
} KDP_PACKED kdp_readregs_reply_t;
struct {                        
	kdp_hdr_t       hdr;
	uint32_t        cpu;
	uint32_t        flavor;
	char            data[0];
} KDP_PACKED kdp_writeregs_req_t;
struct {                        
	kdp_hdr_t       hdr;
	kdp_error_t     error;
} KDP_PACKED kdp_writeregs_reply_t;
struct {                        
	kdp_hdr_t       hdr;
	char            file_args[0];
} KDP_PACKED kdp_load_req_t;
struct {                        
	kdp_hdr_t       hdr;
	kdp_error_t     error;
} KDP_PACKED kdp_load_reply_t;
struct {                        
	kdp_hdr_t       hdr;
} KDP_PACKED kdp_imagepath_req_t;
struct {                        
	kdp_hdr_t       hdr;
	char            path[0];
} KDP_PACKED kdp_imagepath_reply_t;
struct {                        
	kdp_hdr_t       hdr;
} KDP_PACKED kdp_suspend_req_t;
struct {                        
	kdp_hdr_t       hdr;
} KDP_PACKED kdp_suspend_reply_t;
struct {                        
	kdp_hdr_t       hdr;
	uint32_t        cpu_mask;
} KDP_PACKED kdp_resumecpus_req_t;
struct {                        
	kdp_hdr_t       hdr;
} KDP_PACKED kdp_resumecpus_reply_t;
struct {
	kdp_hdr_t hdr;
	uint32_t      address;
} KDP_PACKED kdp_breakpoint_req_t;
struct {
	kdp_hdr_t hdr;
	kdp_error_t error;
} KDP_PACKED kdp_breakpoint_reply_t;
struct {
	kdp_hdr_t hdr;
	uint64_t        address;
} KDP_PACKED kdp_breakpoint64_req_t;
struct {
	kdp_hdr_t hdr;
	kdp_error_t error;
} KDP_PACKED kdp_breakpoint64_reply_t;
struct {                        
	uint32_t        cpu;
	uint32_t        exception;
	uint32_t        code;
	uint32_t        subcode;
} KDP_PACKED kdp_exc_info_t;
struct {                        
	kdp_hdr_t       hdr;
	uint32_t        n_exc_info;
	kdp_exc_info_t  exc_info[0];
} KDP_PACKED kdp_exception_t;
struct {                        
	kdp_hdr_t       hdr;
} KDP_PACKED kdp_exception_ack_t;
struct {                        
	kdp_hdr_t       hdr;
} KDP_PACKED kdp_kernelversion_req_t;
struct {                        
	kdp_hdr_t       hdr;
	char            version[0];
} KDP_PACKED kdp_kernelversion_reply_t;
struct {                        
	kdp_hdr_t               hdr;
	uint32_t                term_code;      
	uint32_t                exit_code;
} KDP_PACKED kdp_termination_t;
struct {
	kdp_hdr_t       hdr;
} KDP_PACKED kdp_termination_ack_t;
struct {                        
	kdp_hdr_t       hdr;
	char            name[50];
	char            destip[16];
	char            routerip[16];
	uint32_t        port;
	kdp_dumpinfo_t  type;
} KDP_PACKED kdp_dumpinfo_req_t;
struct {                        
	kdp_hdr_t       hdr;
	char            name[50];
	char            destip[16];
	char            routerip[16];
	uint32_t        port;
	kdp_dumpinfo_t  type;
} KDP_PACKED kdp_dumpinfo_reply_t;
struct kdp_manual_pkt {
	unsigned char       data[KDP_MANUAL_PACKET_SIZE];
	unsigned int        len;
	boolean_t           input;
} KDP_PACKED;
struct kdp_in_addr {
	uint32_t s_addr;
};
struct kdp_ether_addr {
	u_char ether_addr_octet[ETHER_ADDR_LEN];
};
struct  kdp_ether_header {
	u_char  ether_dhost[ETHER_ADDR_LEN];
	u_char  ether_shost[ETHER_ADDR_LEN];
	u_short ether_type;
};
struct {
	kern_return_t (*kcc_coredump_init)(void *refcon, void *context); 
	kern_return_t (*kcc_coredump_get_summary)(void *refcon, core_save_summary_cb callback, void *context);
	kern_return_t (*kcc_coredump_save_segment_descriptions)(void *refcon, core_save_segment_descriptions_cb callback, void *context);
	kern_return_t (*kcc_coredump_save_thread_state)(void *refcon, void *buf, core_save_thread_state_cb callback, void *context);
	kern_return_t (*kcc_coredump_save_sw_vers)(void *refcon, core_save_sw_vers_cb callback, void *context) __deprecated_msg("please switch to kcc_coredump_save_sw_vers_detail");
	kern_return_t (*kcc_coredump_save_segment_data)(void *refcon, core_save_segment_data_cb callback, void *context);
	kern_return_t (*kcc_coredump_save_misc_data)(void *refcon, core_save_misc_data_cb callback, void *context) __deprecated_msg("please switch to kcc_coredump_save_note_*");
	kern_return_t (*kcc_coredump_save_note_summary)(void *refcon, core_save_note_summary_cb callback, void *context);
	kern_return_t (*kcc_coredump_save_note_descriptions)(void *refcon, core_save_note_descriptions_cb callback, void *context);
	kern_return_t (*kcc_coredump_save_note_data)(void *refcon, core_save_note_data_cb callback, void *context);
	kern_return_t (*kcc_coredump_save_sw_vers_detail)(void *refcon, core_save_sw_vers_detail_cb callback, void *context);
} kern_coredump_callback_config;
struct kern_userspace_coredump_context {
	task_t task;
};
struct user_dump_preflight_context {
	struct kern_userspace_coredump_context * uccontext;
	uint32_t region_count;
	uint64_t dumpable_bytes;
};
struct user_dump_send_seg_desc_context {
	core_save_segment_descriptions_cb callback;
	void *context;
};
struct user_dump_send_segdata_context {
	core_save_segment_data_cb callback;
	void *context;
};
struct affinity_space {
	lck_mtx_t               aspc_lock;
	uint32_t                aspc_task_count;
	queue_head_t    aspc_affinities;
};
struct affinity_set {
	struct affinity_space *aset_space;      
	queue_chain_t   aset_affinities;        
	queue_head_t    aset_threads;           
	uint32_t        aset_thread_count;      
	uint32_t        aset_tag;               
	uint32_t        aset_num;               
	processor_set_t aset_pset;              
};
struct arcade_register {
	ipc_port_t ar_port;
};
struct mach_assert_hdr {
	mach_assert_type_t      type;
	unsigned                lineno : 24;
	const char             *filename;
} __attribute__((packed, aligned(4)));
struct mach_assert_default {
	struct mach_assert_hdr  hdr;
	const char             *expr;
} __attribute__((packed, aligned(4)));
struct mach_assert_3x {
	struct mach_assert_hdr  hdr;
	const char             *a;
	const char             *op;
	const char             *b;
} __attribute__((packed, aligned(4)));
struct backtrace_control {
	backtrace_flags_t btc_flags;
	uintptr_t btc_frame_addr;
	void *btc_user_thread;
	backtrace_user_copy_fn btc_user_copy;
	void *btc_user_copy_context;
	int64_t btc_addr_offset;
};
struct backtrace_user_info {
	backtrace_info_t btui_info;
	errno_t btui_error;
	unsigned int btui_async_start_index;
	uintptr_t btui_async_frame_addr;
	uintptr_t btui_next_frame_addr;
};
struct bt_hash {
	btref_smr_t             bth_array[BTL_HASH_COUNT];
} *bt_hash_t;
struct bt_library {
	lck_ticket_t            btl_lock;
	SMR_POINTER(uint32_t)   btl_param;

	bt_hash_t              *btl_hash[2];
	thread_call_t           btl_call;
	thread_t                btl_grower;

	btref_t                *btl_free_tail;
	btref_t                 btl_free_head;

	btref_t                 btl_deferred_head;

	bool                    btl_waiters;
	bool                    btl_in_callout;
	bool                    btl_rehashing;
	uint8_t                 btl_slab_cur;
	uint32_t                btl_alloc_pos;
	uint32_t                btl_faulted_pos;
	uint32_t                btl_max_pos;
	vm_address_t            btl_slabs[BTL_SLABS];
} *bt_library_t;
struct btlog {
	btlog_type_t            btl_type;
	uint32_t                btl_disabled : 1;
	uint32_t                btl_sample_max : 23;
	uint32_t                btl_count;
	lck_ticket_t            btl_lock;
	uint32_t     *__zpercpu btl_sample;
};
struct bt_log_entry {
	vm_address_t            btle_addr;
	btref_t                 btle_where;
} __attribute__((packed, aligned(4)));
struct btlog_log {
	struct btlog            btll_hdr;
	uint32_t                btll_pos;
	struct bt_log_entry     btll_entries[__counted_by(btll_count)];
};
struct bt_hash_entry {
	vm_address_t            bthe_addr;
	uint32_t                bthe_next;
	btref_t                 bthe_where;
};
struct bt_hash_head {
	uint32_t                bthh_first;
	uint32_t                bthh_last;
};
struct btlog_hash {
	struct btlog            btlh_hdr;
	uint32_t                btlh_pos;
	struct bt_hash_head     btlh_free;
	struct bt_hash_entry    btlh_entries[__counted_by(btlh_count)];
};
struct btlog_size_pair {
	vm_size_t btsp_size;
	uint32_t  btsp_count;
}
__btlog_size(btlog_type_t type, uint32_t count)
{
	struct btlog_size_pair pair = {0};
struct circle_queue_head {
	queue_entry_t head;
} circle_queue_head_t, *circle_queue_t;
struct bintime {
	time_t  sec;
	uint64_t frac;
};
struct clock_calend {
	uint64_t                s_scale_ns; 
	int64_t                 s_adj_nsx; 
	uint64_t                tick_scale_x; 
	uint64_t                offset_count; 
	struct bintime          offset; 
	struct bintime          bintime; 
	struct bintime          boottime; 
} clock_calend;
struct unlocked_clock_calend {
	struct clock_calend     calend;         
	uint32_t                gen;            
} flipflop[2];
struct  clock_ops {
	int             (*c_config)(void);              

	int             (*c_init)(void);                

	kern_return_t   (*c_gettime)(   
		mach_timespec_t                 *cur_time);

	kern_return_t   (*c_getattr)(   
		clock_flavor_t                  flavor,
		clock_attr_t                    attr,
		mach_msg_type_number_t  *count);
};
struct  clock {
	clock_ops_t             cl_ops;         
	struct ipc_port         *cl_service;    
};
struct  alarm {
	struct  alarm   *al_next;               
	struct  alarm   *al_prev;               
	int                             al_status;              
	mach_timespec_t al_time;                
	struct {                                
		int                             type;           
		ipc_port_t              port;           
		mach_msg_type_name_t
		    port_type;                                  
		struct  clock   *clock;         
		void                    *data;          
	} al_alrm;
	long                    al_seqno;               
};
struct coalition_type {
	int type;
	int has_default;
	kern_return_t (*init)(coalition_t coal, boolean_t privileged, boolean_t efficient);

	void          (*dealloc)(coalition_t coal);

	kern_return_t (*adopt_task)(coalition_t coal, task_t task);

	kern_return_t (*remove_task)(coalition_t coal, task_t task);

	kern_return_t (*set_taskrole)(coalition_t coal, task_t task, int role);

	int (*get_taskrole)(coalition_t coal, task_t task);

	task_t (*iterate_tasks)(coalition_t coal, coalition_for_each_task_block_t);
};
struct i_resource_coalition {
	ledger_t ledger;
	uint64_t bytesread;
	uint64_t byteswritten;
	uint64_t energy;
	uint64_t gpu_time;
	uint64_t logical_immediate_writes;
	uint64_t logical_deferred_writes;
	uint64_t logical_invalidated_writes;
	uint64_t logical_metadata_writes;
	uint64_t logical_immediate_writes_to_external;
	uint64_t logical_deferred_writes_to_external;
	uint64_t logical_invalidated_writes_to_external;
	uint64_t logical_metadata_writes_to_external;
	uint64_t cpu_time_eqos[COALITION_NUM_THREAD_QOS_TYPES];      
	uint64_t cpu_time_rqos[COALITION_NUM_THREAD_QOS_TYPES];      
	uint64_t cpu_instructions;
	uint64_t cpu_cycles;
	uint64_t ane_mach_time;
	uint64_t ane_energy_nj;

	_Atomic uint64_t gpu_energy_nj;
	_Atomic uint64_t gpu_energy_nj_billed_to_me;
	_Atomic uint64_t gpu_energy_nj_billed_to_others;

	struct recount_coalition co_recount;

	uint64_t task_count;      
	uint64_t dead_task_count; 
	uint64_t last_became_nonempty_time;
	uint64_t time_nonempty;

	queue_head_t tasks;         
	ledger_t resource_monitor_ledger;
};
struct i_jetsam_coalition {
	task_t       leader;
	queue_head_t extensions;
	queue_head_t services;
	queue_head_t other;
	struct thread_group *thread_group;
	bool swap_enabled;

	struct coalition_requested_policy {
		uint64_t        crp_darwinbg        :1, 
		    crp_reserved        :63;
	} c_requested_policy;
	struct coalition_effective_policy {
		uint64_t        cep_darwinbg        :1, 
		    cep_reserved        :63;
	} c_effective_policy;
};
struct coalition {
	uint64_t id;                
	uint32_t type;
	uint32_t role;              
	os_ref_atomic_t ref_count;  
	uint32_t active_count;      
	uint32_t focal_task_count;   
	uint32_t nonfocal_task_count; 
	uint32_t game_task_count;    
	uint32_t carplay_task_count;    

	uint32_t privileged : 1;    
	uint32_t termrequested : 1; 
	uint32_t terminated : 1;    
	uint32_t reaped : 1;        
	uint32_t notified : 1;      
	uint32_t efficient : 1;     

	struct smrq_slink link;     

	union {
		lck_mtx_t lock;     
		struct smr_node smr_node;
	};

	union {
		struct i_resource_coalition  r;
		struct i_jetsam_coalition    j;
	};
};
struct coal_sort_s {
	int pid;
	int usr_order;
	uint64_t bytes;
};
struct coalition_ledger_indices {
	int logical_writes;
};
struct compact_id_table {
	void                  **cidt_array[COMPACT_ID_SLAB_COUNT];
	bitmap_t               *cidt_bitmap[COMPACT_ID_SLAB_COUNT];
	lck_mtx_t               cidt_lock;
	struct thread          *cidt_allocator;
	bool                    cidt_waiters;
	uint32_t                cidt_count;
	compact_id_t            cidt_first_free;
};
struct {
	core_analytics_family_service_t *ts_core_analytics_service;
} telemetry_state = {0};
struct __CodeDirectory {
	uint32_t magic;                                 
	uint32_t length;                                
	uint32_t version;                               
	uint32_t flags;                                 
	uint32_t hashOffset;                    
	uint32_t identOffset;                   
	uint32_t nSpecialSlots;                 
	uint32_t nCodeSlots;                    
	uint32_t codeLimit;                             
	uint8_t hashSize;                               
	uint8_t hashType;                               
	uint8_t platform;                               
	uint8_t pageSize;                               
	uint32_t spare2;                                

	char end_earliest[0];

	uint32_t scatterOffset;                 
	char end_withScatter[0];

	uint32_t teamOffset;                    
	char end_withTeam[0];

	uint32_t spare3;                                
	uint64_t codeLimit64;                   
	char end_withCodeLimit64[0];

	uint64_t execSegBase;                   
	uint64_t execSegLimit;                  
	uint64_t execSegFlags;                  
	char end_withExecSeg[0];

	uint32_t runtime;
	uint32_t preEncryptOffset;
	char end_withPreEncryptOffset[0];

	uint8_t linkageHashType;
	uint8_t linkageApplicationType;
	uint16_t linkageApplicationSubType;
	uint32_t linkageOffset;
	uint32_t linkageSize;
	char end_withLinkage[0];

} CS_CodeDirectory
__attribute__ ((aligned(1)));
struct __BlobIndex {
	uint32_t type;                                  
	uint32_t offset;                                
} CS_BlobIndex
__attribute__ ((aligned(1)));
struct __SC_SuperBlob {
	uint32_t magic;                                 
	uint32_t length;                                
	uint32_t count;                                 
	CS_BlobIndex index[];                   
} CS_SuperBlob
__attribute__ ((aligned(1)));
struct __SC_GenericBlob {
	uint32_t magic;                                 
	uint32_t length;                                
	char data[];
} CS_GenericBlob
__attribute__ ((aligned(1)));
struct __SC_Scatter {
	uint32_t count;                                 
	uint32_t base;                                  
	uint64_t targetOffset;                  
	uint64_t spare;                                 
} SC_Scatter
__attribute__ ((aligned(1)));
struct launch_constraint_data {
	cs_launch_type_t launch_type;
};
struct debugger_state {
	uint64_t        db_panic_options;
	debugger_op     db_current_op;
	boolean_t       db_proceed_on_sync_failure;
	const char     *db_message;
	const char     *db_panic_str;
	va_list        *db_panic_args;
	void           *db_panic_data_ptr;
	unsigned long   db_panic_caller;
	const char     *db_panic_initiator;
	uint32_t        db_entry_count;
	kern_return_t   db_op_return;
};
struct kdp_callout {
	struct kdp_callout * callout_next;
	kdp_callout_fn_t callout_fn;
	boolean_t callout_in_progress;
	void * callout_arg;
} * kdp_callout_list = NULL;
struct additional_panic_data_buffer {
	const char *producer_name;
	void *buf;
	int len;
};
struct kernel_panic_reason {
	char            buf[1024];
} *kernel_panic_reason_t;
struct kdp_core_encryption_key_descriptor {
	uint64_t kcekd_format;
	uint16_t kcekd_size;
	void *   kcekd_key;
};
struct ecc_event {
	uint8_t         id;     
	uint8_t         count;  
	uint64_t        data[ECC_EVENT_INFO_DATA_ENTRIES] __attribute__((aligned(8))); 
};
struct {
	ecc_version_t version;
	ecc_flags_t flags;
	uint64_t physaddr;
	uint32_t ce_count;
	uint32_t vendor;
	uint32_t reserved[4];
} ecc_event_t;
struct {
	mcc_ecc_version_t version;
	mcc_flags_t flags;
	uint32_t status;
	uint32_t amcc;
	uint32_t plane;
	uint32_t bank;
	uint32_t way;
	uint32_t index;
	uint32_t bit_off_cl;
	uint32_t bit_off_within_hcl;
} mcc_ecc_event_t;
struct {
	uint32_t gpu_id;
	uint32_t gpu_max_domains;
} gpu_descriptor;
struct {
	uint64_t          es_id;            
	struct turnstile *es_turnstile;     
	esync_policy_t    es_policy;        
	lck_spin_t        es_lock;          
	os_refcnt_t       es_refcnt;        
	queue_chain_t     es_link;          
} esync_t;
struct {
	queue_head_t  htb_head;
	lck_spin_t    htb_lock;
} ht_bucket_t;
struct ht {
	const uint32_t  ht_size;
	ht_bucket_t    *ht_bucket;
} ht_t;
struct exception_action {
	struct ipc_port         * XNU_PTRAUTH_SIGNED_PTR("exception_action.port") port; 
	thread_state_flavor_t   flavor;         
	exception_behavior_t    behavior;       
	boolean_t               privileged;     
	boolean_t               hardened;       
	struct label            *label;         
};
struct hardened_exception_action {
	struct exception_action ea;
	uint32_t                signed_pc_key;
	exception_mask_t        exception;
};
struct ext_paniclog_handle {
	LIST_ENTRY(ext_paniclog_handle) handles;
	uuid_t uuid;
	char data_id[MAX_DATA_ID_SIZE];
	void * XNU_PTRAUTH_SIGNED_PTR("ext_paniclog_handle.buf_addr") buf_addr;
	uint32_t max_len;
	uint32_t used_len;
	ext_paniclog_create_options_t options;
	ext_paniclog_flags_t flags;
	uint8_t active;
} ext_paniclog_handle_t;
struct ext_paniclog_header {
	uint32_t len;
	uuid_t uuid;
	ext_paniclog_flags_t flags;
} ext_paniclog_header_t;
struct host_stats_cache {
	uint64_t last_access;
	uint64_t current_requests;
	uint64_t max_requests;
	uintptr_t data;
	mach_msg_type_number_t count; 
};
struct  host {
	decl_lck_mtx_data(, lock);               
	ipc_port_t XNU_PTRAUTH_SIGNED_PTR("host.special") special[HOST_MAX_SPECIAL_PORT + 1];
	struct exception_action exc_actions[EXC_TYPES_COUNT];
};
struct {
	uint64_t total_user_time;
	uint64_t total_system_time;
	uint64_t task_interrupt_wakeups;
	uint64_t task_platform_idle_wakeups;
	uint64_t task_timer_wakeups_bin_1;
	uint64_t task_timer_wakeups_bin_2;
	uint64_t total_ptime;
	uint64_t total_pset_switches;
	uint64_t task_gpu_ns;
	uint64_t task_energy;
} expired_task_statistics_t;
struct host_notify_entry {
	queue_chain_t                   entries;
	ipc_port_t                      port;
	ipc_port_request_index_t        index;
};
struct hvg_hcall_args {
	uint64_t args[6];
} hvg_hcall_args_t;
struct hvg_hcall_output {
	uint64_t regs[7];
} hvg_hcall_output_t;
struct hvg_hcall_vmcore_file {
	char tag[57];   
} hvg_hcall_vmcore_file_t;
struct hv_ion_entry {
	LIST_ENTRY(hv_ion_entry) list;

	uint64_t           addr;
	size_t             size;
	uint64_t           value;
	uint32_t           flags;

	mach_port_t        port;
	mach_port_name_t   port_name;
} hv_ion_entry_t;
struct hv_ion_grp {
	struct io_notifier_list list;
	lck_rw_t lock;
};
struct {
	mach_msg_header_t header;
	uint64_t addr;
	uint64_t size;
	uint64_t value;
} hv_ion_message_t;
struct {
	uint64_t addr;
	uint64_t size;
	uint64_t value;
	uint32_t port_name;
	uint32_t flags;
} hv_ion_t;
struct  {
	const hv_trap_t *traps;
	unsigned trap_count;
} hv_trap_table_t;
struct {
	void (*dispatch)(void *vcpu);
	void (*preempt)(void *vcpu);
	void (*suspend)(void);
	void (*thread_destroy)(void *vcpu);
	void (*task_destroy)(void *vm);
	void (*volatile_state)(void *vcpu, int state);
	void (*resume)(void);
	void (*memory_pressure)(void);
} hv_callbacks_t;
struct {
	mach_msg_id_t num;
	int kobjidx;
	mig_kern_routine_t kroutine;    
	unsigned int kreply_size;       
	unsigned int kreply_desc_cnt;   
} mig_hash_t;
struct ipc_kobject_ops {
	ipc_kobject_type_t iko_op_type;
	unsigned long
	    iko_op_stable        : 1,
	    iko_op_permanent     : 1;
	const char        *iko_op_name;
	void (*iko_op_no_senders)(ipc_port_t port, mach_port_mscount_t mscount);
	void (*iko_op_destroy)(ipc_port_t port);
} *ipc_kobject_ops_t;
struct ipc_kobject_label {
	ipc_label_t   ikol_label;       
	ipc_port_t XNU_PTRAUTH_SIGNED_PTR("ipc_kobject_label.ikol_alt_port") ikol_alt_port;
};
struct thread_init_exc_actions {
	struct exception_action array[EXC_TYPES_COUNT];
};
struct nzones_with_idx {
	uint16_t nzones;
	uint16_t idx;
};
struct kalloc_heap {
	zone_stats_t        kh_stats;
	const char         *__unsafe_indexable kh_name;
	zone_kheap_id_t     kh_heap_id;
	vm_tag_t            kh_tag;
	uint16_t            kh_type_hash;
	zone_id_t           kh_zstart;
	struct kalloc_heap *kh_views;
} *kalloc_heap_t;
struct kalloc_type_view {
	struct zone_view        kt_zv;
	const char             *kt_signature __unsafe_indexable;
	kalloc_type_flags_t     kt_flags;
	uint32_t                kt_size;
	zone_t                  kt_zearly;
	zone_t                  kt_zsig;
};
struct kalloc_type_var_view {
	kalloc_type_version_t   kt_version;
	uint16_t                kt_size_hdr;
	uint32_t                kt_size_type;
	zone_stats_t            kt_stats;
	const char             *__unsafe_indexable kt_name;
	zone_view_t             kt_next;
	zone_id_t               kt_heap_start;
	uint8_t                 kt_zones[KHEAP_NUM_ZONES];
	const char             * __unsafe_indexable kt_sig_hdr;
	const char             * __unsafe_indexable kt_sig_type;
	kalloc_type_flags_t     kt_flags;
};
struct kcdata_item {
	uint32_t type;
	uint32_t size; 
	               
	uint64_t flags;
	char data[]; 
};
struct kcdata_subtype_descriptor {
	uint8_t kcs_flags;

	uint8_t kcs_elem_type;                              
	uint16_t kcs_elem_offset;                           
	uint32_t kcs_elem_size;                             
	char                 kcs_name[KCDATA_DESC_MAXLEN];  
};
struct kcdata_type_definition {
	uint32_t kct_type_identifier;
	uint32_t kct_num_elements;
	char kct_name[KCDATA_DESC_MAXLEN];
	struct kcdata_subtype_descriptor kct_elements[];
};
struct stack_snapshot_frame32 {
	uint32_t lr;
	uint32_t sp;
};
struct stack_snapshot_frame64 {
	uint64_t lr;
	uint64_t sp;
};
struct dyld_uuid_info_32 {
	uint32_t imageLoadAddress; 
	uuid_t   imageUUID;
};
struct dyld_uuid_info_64 {
	uint64_t imageLoadAddress; 
	uuid_t   imageUUID;
};
struct dyld_uuid_info_64_v2 {
	uint64_t imageLoadAddress; 
	uuid_t   imageUUID;
	uint64_t imageSlidBaseAddress; 
};
struct dyld_shared_cache_loadinfo_v2 {
	uint64_t sharedCacheSlide;      
	uuid_t   sharedCacheUUID;
	uint64_t sharedCacheUnreliableSlidBaseAddress;  
	uint64_t sharedCacheSlidFirstMapping; 
	uint32_t sharedCacheID; 
	uint32_t sharedCacheFlags;
};
struct dyld_shared_cache_loadinfo {
	uint64_t sharedCacheSlide;      
	uuid_t   sharedCacheUUID;
	uint64_t sharedCacheUnreliableSlidBaseAddress;  
	uint64_t sharedCacheSlidFirstMapping; 
};
struct dyld_aot_cache_uuid_info {
	uint64_t x86SlidBaseAddress; 
	uuid_t x86UUID; 
	uint64_t aotSlidBaseAddress; 
	uuid_t aotUUID; 
};
struct user32_dyld_uuid_info {
	uint32_t        imageLoadAddress;       
	uuid_t                  imageUUID;                      
};
struct user64_dyld_uuid_info {
	uint64_t        imageLoadAddress;       
	uuid_t                  imageUUID;                      
};
struct user64_dyld_aot_info {
	uint64_t x86LoadAddress;
	uint64_t aotLoadAddress;
	uint64_t aotImageSize;
	uint8_t  aotImageKey[DYLD_AOT_IMAGE_KEY_SIZE];
};
struct mem_and_io_snapshot {
	uint32_t        snapshot_magic;
	uint32_t        free_pages;
	uint32_t        active_pages;
	uint32_t        inactive_pages;
	uint32_t        purgeable_pages;
	uint32_t        wired_pages;
	uint32_t        speculative_pages;
	uint32_t        throttled_pages;
	uint32_t        filebacked_pages;
	uint32_t        compressions;
	uint32_t        decompressions;
	uint32_t        compressor_size;
	int32_t         busy_buffer_count;
	uint32_t        pages_wanted;
	uint32_t        pages_reclaimed;
	uint8_t         pages_wanted_reclaimed_valid; 
} __attribute__((packed));
struct thread_snapshot_v2 {
	uint64_t  ths_thread_id;
	uint64_t  ths_wait_event;
	uint64_t  ths_continuation;
	uint64_t  ths_total_syscalls;
	uint64_t  ths_voucher_identifier;
	uint64_t  ths_dqserialnum;
	uint64_t  ths_user_time;
	uint64_t  ths_sys_time;
	uint64_t  ths_ss_flags;
	uint64_t  ths_last_run_time;
	uint64_t  ths_last_made_runnable_time;
	uint32_t  ths_state;
	uint32_t  ths_sched_flags;
	int16_t   ths_base_priority;
	int16_t   ths_sched_priority;
	uint8_t   ths_eqos;
	uint8_t ths_rqos;
	uint8_t ths_rqos_override;
	uint8_t ths_io_tier;
} __attribute__((packed));
struct thread_snapshot_v3 {
	uint64_t ths_thread_id;
	uint64_t ths_wait_event;
	uint64_t ths_continuation;
	uint64_t ths_total_syscalls;
	uint64_t ths_voucher_identifier;
	uint64_t ths_dqserialnum;
	uint64_t ths_user_time;
	uint64_t ths_sys_time;
	uint64_t ths_ss_flags;
	uint64_t ths_last_run_time;
	uint64_t ths_last_made_runnable_time;
	uint32_t ths_state;
	uint32_t ths_sched_flags;
	int16_t ths_base_priority;
	int16_t ths_sched_priority;
	uint8_t ths_eqos;
	uint8_t ths_rqos;
	uint8_t ths_rqos_override;
	uint8_t ths_io_tier;
	uint64_t ths_thread_t;
} __attribute__((packed));
struct thread_snapshot_v4 {
	uint64_t ths_thread_id;
	uint64_t ths_wait_event;
	uint64_t ths_continuation;
	uint64_t ths_total_syscalls;
	uint64_t ths_voucher_identifier;
	uint64_t ths_dqserialnum;
	uint64_t ths_user_time;
	uint64_t ths_sys_time;
	uint64_t ths_ss_flags;
	uint64_t ths_last_run_time;
	uint64_t ths_last_made_runnable_time;
	uint32_t ths_state;
	uint32_t ths_sched_flags;
	int16_t ths_base_priority;
	int16_t ths_sched_priority;
	uint8_t ths_eqos;
	uint8_t ths_rqos;
	uint8_t ths_rqos_override;
	uint8_t ths_io_tier;
	uint64_t ths_thread_t;
	uint64_t ths_requested_policy;
	uint64_t ths_effective_policy;
} __attribute__((packed));
struct thread_group_snapshot {
	uint64_t tgs_id;
	char tgs_name[16];
} __attribute__((packed));
struct thread_group_snapshot_v2 {
	uint64_t tgs_id;
	char tgs_name[16];
	uint64_t tgs_flags;
} __attribute__((packed));
struct thread_group_snapshot_v3 {
	uint64_t tgs_id;
	char tgs_name[16];
	uint64_t tgs_flags;
	char tgs_name_cont[16];
} __attribute__((packed));
struct jetsam_coalition_snapshot {
	uint64_t jcs_id;
	uint64_t jcs_flags;
	uint64_t jcs_thread_group;
	uint64_t jcs_leader_task_uniqueid;
} __attribute__((packed));
struct instrs_cycles_snapshot {
	uint64_t ics_instructions;
	uint64_t ics_cycles;
} __attribute__((packed));
struct instrs_cycles_snapshot_v2 {
	uint64_t ics_instructions;
	uint64_t ics_cycles;
	uint64_t ics_p_instructions;
	uint64_t ics_p_cycles;
} __attribute__((packed));
struct thread_delta_snapshot_v2 {
	uint64_t  tds_thread_id;
	uint64_t  tds_voucher_identifier;
	uint64_t  tds_ss_flags;
	uint64_t  tds_last_made_runnable_time;
	uint32_t  tds_state;
	uint32_t  tds_sched_flags;
	int16_t   tds_base_priority;
	int16_t   tds_sched_priority;
	uint8_t   tds_eqos;
	uint8_t   tds_rqos;
	uint8_t   tds_rqos_override;
	uint8_t   tds_io_tier;
} __attribute__ ((packed));
struct thread_delta_snapshot_v3 {
	uint64_t  tds_thread_id;
	uint64_t  tds_voucher_identifier;
	uint64_t  tds_ss_flags;
	uint64_t  tds_last_made_runnable_time;
	uint32_t  tds_state;
	uint32_t  tds_sched_flags;
	int16_t   tds_base_priority;
	int16_t   tds_sched_priority;
	uint8_t   tds_eqos;
	uint8_t   tds_rqos;
	uint8_t   tds_rqos_override;
	uint8_t   tds_io_tier;
	uint64_t  tds_requested_policy;
	uint64_t  tds_effective_policy;
} __attribute__ ((packed));
struct io_stats_snapshot {
	uint64_t         ss_disk_reads_count;
	uint64_t         ss_disk_reads_size;
	uint64_t         ss_disk_writes_count;
	uint64_t         ss_disk_writes_size;
	uint64_t         ss_io_priority_count[STACKSHOT_IO_NUM_PRIORITIES];
	uint64_t         ss_io_priority_size[STACKSHOT_IO_NUM_PRIORITIES];
	uint64_t         ss_paging_count;
	uint64_t         ss_paging_size;
	uint64_t         ss_non_paging_count;
	uint64_t         ss_non_paging_size;
	uint64_t         ss_data_count;
	uint64_t         ss_data_size;
	uint64_t         ss_metadata_count;
	uint64_t         ss_metadata_size;
} __attribute__ ((packed));
struct task_snapshot_v2 {
	uint64_t  ts_unique_pid;
	uint64_t  ts_ss_flags;
	uint64_t  ts_user_time_in_terminated_threads;
	uint64_t  ts_system_time_in_terminated_threads;
	uint64_t  ts_p_start_sec;
	uint64_t  ts_task_size;
	uint64_t  ts_max_resident_size;
	uint32_t  ts_suspend_count;
	uint32_t  ts_faults;
	uint32_t  ts_pageins;
	uint32_t  ts_cow_faults;
	uint32_t  ts_was_throttled;
	uint32_t  ts_did_throttle;
	uint32_t  ts_latency_qos;
	int32_t   ts_pid;
	char      ts_p_comm[32];
} __attribute__ ((packed));
struct transitioning_task_snapshot {
	uint64_t  tts_unique_pid;
	uint64_t  tts_ss_flags;
	uint64_t  tts_transition_type;
	int32_t   tts_pid;
	char      tts_p_comm[32];
} __attribute__ ((packed));
struct task_delta_snapshot_v2 {
	uint64_t  tds_unique_pid;
	uint64_t  tds_ss_flags;
	uint64_t  tds_user_time_in_terminated_threads;
	uint64_t  tds_system_time_in_terminated_threads;
	uint64_t  tds_task_size;
	uint64_t  tds_max_resident_size;
	uint32_t  tds_suspend_count;
	uint32_t  tds_faults;
	uint32_t  tds_pageins;
	uint32_t  tds_cow_faults;
	uint32_t  tds_was_throttled;
	uint32_t  tds_did_throttle;
	uint32_t  tds_latency_qos;
} __attribute__ ((packed));
struct stackshot_task_codesigning_info {
	uint64_t csflags;
	uint32_t cs_trust_level;
} __attribute__ ((packed));
struct stackshot_cpu_times {
	uint64_t user_usec;
	uint64_t system_usec;
} __attribute__((packed));
struct stackshot_cpu_times_v2 {
	uint64_t user_usec;
	uint64_t system_usec;
	uint64_t runnable_usec;
} __attribute__((packed));
struct stackshot_duration {
	uint64_t stackshot_duration;
	uint64_t stackshot_duration_outer;
} __attribute__((packed));
struct stackshot_duration_v2 {
	uint64_t stackshot_duration;
	uint64_t stackshot_duration_outer;
	uint64_t stackshot_duration_prior;
} __attribute__((packed));
struct stackshot_fault_stats {
	uint32_t sfs_pages_faulted_in;      
	uint64_t sfs_time_spent_faulting;   
	uint64_t sfs_system_max_fault_time; 
	uint8_t  sfs_stopped_faulting;      
} __attribute__((packed));
struct stackshot_thread_waitinfo {
	uint64_t owner;         
	uint64_t waiter;        
	uint64_t context;       
	uint8_t wait_type;      
} __attribute__((packed)) thread_waitinfo_t;
struct stackshot_thread_waitinfo_v2 {
	uint64_t owner;         
	uint64_t waiter;        
	uint64_t context;       
	uint8_t wait_type;      
	int16_t portlabel_id;   
	uint32_t wait_flags;    
} __attribute__((packed)) thread_waitinfo_v2_t;
struct stackshot_thread_turnstileinfo {
	uint64_t waiter;        
	uint64_t turnstile_context; 
	uint8_t turnstile_priority;
	uint8_t number_of_hops;
	uint64_t turnstile_flags;               
} __attribute__((packed)) thread_turnstileinfo_t;
struct stackshot_thread_turnstileinfo_v2 {
	uint64_t waiter;        
	uint64_t turnstile_context; 
	uint8_t turnstile_priority;
	uint8_t number_of_hops;
	uint64_t turnstile_flags; 
	int16_t portlabel_id;   
} __attribute__((packed)) thread_turnstileinfo_v2_t;
struct portlabel_info {
	int16_t portlabel_id;         
	uint16_t portlabel_flags;           
	uint8_t portlabel_domain;           
} __attribute__((packed));
struct stackshot_cpu_architecture {
	int32_t cputype;
	int32_t cpusubtype;
} __attribute__((packed));
struct stack_snapshot_stacktop {
	uint64_t sp;
	uint8_t stack_contents[8];
};
struct stackshot_latency_collection {
	uint64_t latency_version;
	uint64_t setup_latency;
	uint64_t total_task_iteration_latency;
	uint64_t total_terminated_task_iteration_latency;
} __attribute__((packed));
struct stackshot_latency_collection_v2 {
	uint64_t latency_version;
	uint64_t setup_latency_mt;
	uint64_t total_task_iteration_latency_mt;
	uint64_t total_terminated_task_iteration_latency_mt;
	uint64_t task_queue_building_latency_mt;
	uint64_t terminated_task_queue_building_latency_mt;
	uint64_t cpu_wait_latency_mt;
	int32_t  main_cpu_number;
	int32_t  calling_cpu_number;
	uint64_t buffer_size;
	uint64_t buffer_used;
	uint64_t buffer_overhead;
	uint64_t buffer_count;
} __attribute__((packed));
struct stackshot_latency_cpu {
	int32_t  cpu_number;
	int32_t  cluster_type;
	uint64_t init_latency_mt;
	uint64_t workqueue_latency_mt;
	uint64_t total_latency_mt;
	uint64_t total_cycles;
	uint64_t total_instrs;
	uint64_t tasks_processed;
	uint64_t threads_processed;
	uint64_t faulting_time_mt;
	uint64_t total_buf;
	uint64_t intercluster_buf_used;
} __attribute__((packed));
struct stackshot_latency_task {
	uint64_t task_uniqueid;
	uint64_t setup_latency;
	uint64_t task_thread_count_loop_latency;
	uint64_t task_thread_data_loop_latency;
	uint64_t cur_tsnap_latency;
	uint64_t pmap_latency;
	uint64_t bsd_proc_ids_latency;
	uint64_t misc_latency;
	uint64_t misc2_latency;
	uint64_t end_latency;
} __attribute__((packed));
struct stackshot_latency_thread {
	uint64_t thread_id;
	uint64_t cur_thsnap1_latency;
	uint64_t dispatch_serial_latency;
	uint64_t dispatch_label_latency;
	uint64_t cur_thsnap2_latency;
	uint64_t thread_name_latency;
	uint64_t sur_times_latency;
	uint64_t user_stack_latency;
	uint64_t kernel_stack_latency;
	uint64_t misc_latency;
} __attribute__((packed));
struct stackshot_suspension_info {
	uint64_t tss_last_start; 
	uint64_t tss_last_end;   
	uint64_t tss_count;      
	uint64_t tss_duration;   
} __attribute__((packed));
struct stackshot_suspension_source {
	uint64_t tss_time;     
	uint64_t tss_tid;      
	int tss_pid;           
	char tss_procname[65]; 
} __attribute__((packed));
struct thread_exclaves_info {
	uint64_t tei_scid;              
	uint32_t tei_thread_offset;     
	uint32_t tei_flags;             
} __attribute__((packed));
struct thread_crash_exclaves_info {
	uint64_t tcei_scid;              
	uint64_t tcei_thread_id;         
	uint32_t tcei_flags;             
} __attribute__((packed));
struct exclave_scresult_info {
	uint64_t esc_id;
	uint64_t esc_flags;             
} __attribute__((packed));
struct exclave_ipcstackentry_info {
	uint64_t eise_asid;                     
	uint64_t eise_tnid;                     
	uint64_t eise_invocationid;             
	uint64_t eise_flags;                    
} __attribute__((packed));
struct exclave_addressspace_info {
	uint64_t eas_id;                        
	uint64_t eas_flags;                     
	uint64_t eas_layoutid;                  
	uint64_t eas_slide;                     
	uint64_t eas_asroot;                    
} __attribute__((packed));
struct exclave_textlayout_info_v1 {
	uint64_t layout_id;
	uint64_t etl_flags;                     
} __attribute__((packed));
struct exclave_textlayout_info {
	uint64_t layout_id;
	uint64_t etl_flags;                     
	uint32_t sharedcache_index;             
} __attribute__((packed));
struct exclave_textlayout_segment {
	uuid_t layoutSegment_uuid;
	uint64_t layoutSegment_loadAddress;     
} __attribute__((packed));
struct exclave_textlayout_segment_v2 {
	uuid_t layoutSegment_uuid;
	uint64_t layoutSegment_loadAddress;     
	uint64_t layoutSegment_rawLoadAddress;  
} __attribute__((packed));
struct crashinfo_proc_uniqidentifierinfo {
	uint8_t                 p_uuid[16];             
	uint64_t                p_uniqueid;             
	uint64_t                p_puniqueid;            
	uint64_t                p_reserve2;             
	uint64_t                p_reserve3;             
	uint64_t                p_reserve4;             
} __attribute__((packed));
struct kernel_triage_info_v1 {
	char triage_string1[MAX_TRIAGE_STRING_LEN];
	char triage_string2[MAX_TRIAGE_STRING_LEN];
	char triage_string3[MAX_TRIAGE_STRING_LEN];
	char triage_string4[MAX_TRIAGE_STRING_LEN];
	char triage_string5[MAX_TRIAGE_STRING_LEN];
} __attribute__((packed));
struct crashinfo_jit_address_range {
	uint64_t start_address;
	uint64_t end_address;
} __attribute__((packed));
struct crashinfo_mb {
	uint64_t start_address;
	uint64_t data[64];
} __attribute__((packed));
struct btinfo_thread_state_data_t {
	uint32_t flavor;
	uint32_t count;
	int tstate[];
};
struct btinfo_sc_load_info64 {
	uint64_t sharedCacheSlide;
	uuid_t   sharedCacheUUID;
	uint64_t sharedCacheBaseAddress;
};
struct btinfo_sc_load_info {
	uint32_t sharedCacheSlide;
	uuid_t   sharedCacheUUID;
	uint32_t sharedCacheBaseAddress;
};
struct exit_reason_snapshot {
	uint32_t ers_namespace;
	uint64_t ers_code;
	uint64_t ers_flags;
} __attribute__((packed));
struct codesigning_exit_reason_info {
	uint64_t  ceri_virt_addr;
	uint64_t  ceri_file_offset;
	char      ceri_pathname[EXIT_REASON_CODESIG_PATH_MAX];
	char      ceri_filename[EXIT_REASON_CODESIG_PATH_MAX];
	uint64_t  ceri_codesig_modtime_secs;
	uint64_t  ceri_codesig_modtime_nsecs;
	uint64_t  ceri_page_modtime_secs;
	uint64_t  ceri_page_modtime_nsecs;
	uint8_t   ceri_path_truncated;
	uint8_t   ceri_object_codesigned;
	uint8_t   ceri_page_codesig_validated;
	uint8_t   ceri_page_codesig_tainted;
	uint8_t   ceri_page_codesig_nx;
	uint8_t   ceri_page_wpmapped;
	uint8_t   ceri_page_slid;
	uint8_t   ceri_page_dirty;
	uint32_t  ceri_page_shadow_depth;
} __attribute__((packed));
struct kern_apfs_reflock {
	union {
		cond_swi_var64_s kern_apfs_rl_data;
		struct {
			uint64_t kern_apfs_rl_owner: SWI_COND_OWNER_BITS,
			    kern_apfs_rl_waiters: KERN_APFS_REFLOCK_WAITERS_BIT,
			    kern_apfs_rl_delayed_free: 1,
			    kern_apfs_rl_wake: 1,
			    kern_apfs_rl_allocated: 1,
			    kern_apfs_rl_allow_force: 1,
			    kern_apfs_rl_count: KERN_APFS_REFLOCK_REFCOUNT_BIT;
		};
	};
} *kern_apfs_reflock_t;
struct _uint64_with_description_data {
	char desc[KCDATA_DESC_MAXLEN];
	uint64_t data;
};
struct _uint32_with_description_data {
	char     desc[KCDATA_DESC_MAXLEN];
	uint32_t data;
};
struct kcdata_compress_descriptor {
	z_stream kcd_cd_zs;
	void *kcd_cd_base;
	uint64_t kcd_cd_offset;
	size_t kcd_cd_maxoffset;
	uint64_t kcd_cd_mark_begin;
	kcd_cd_flag_t kcd_cd_flags;
	kcd_compression_type_t kcd_cd_compression_type;
	void (*kcd_cd_memcpy_f)(void *, const void *, size_t);
	mach_vm_address_t kcd_cd_totalout_addr;
	mach_vm_address_t kcd_cd_totalin_addr;
};
struct kcdata_descriptor {
	uint32_t            kcd_length;
	uint16_t kcd_flags;
	uint16_t kcd_user_flags; 
	mach_vm_address_t kcd_addr_begin;
	mach_vm_address_t kcd_addr_end;
	struct kcdata_compress_descriptor kcd_comp_d;
	uint32_t            kcd_endalloced;
	struct kcdata_descriptor * (*kcd_alloc_callback) (struct kcdata_descriptor*, size_t);
};
struct kcdata_object {
	kcdata_descriptor_t ko_data;
	kcdata_obj_flags_t  ko_flags;
	ipc_port_t          ko_port;
	uint32_t            ko_alloc_size;
	os_refcnt_t         ko_refs;
};
struct linked_kcdata_descriptor {
	struct kcdata_descriptor          kcdata;
	struct linked_kcdata_descriptor  *next;
} * linked_kcdata_descriptor_t;
struct stackshot_workitem {
	task_t                        sswi_task;
	linked_kcdata_descriptor_t    sswi_data; 
	int                           sswi_idx;  
};
struct stackshot_workqueue {
	uint32_t _Atomic              sswq_num_items; 
	uint32_t _Atomic              sswq_cur_item; 
	size_t                        sswq_capacity; 
	bool _Atomic                  sswq_populated; 
	struct stackshot_workitem    *__counted_by(capacity) sswq_items;
};
struct freelist_entry {
	struct freelist_entry        *fl_next; 
	size_t                        fl_size; 
};
struct stackshot_buffer {
	void                         *ssb_ptr; 
	size_t                        ssb_size;
	size_t _Atomic                ssb_used;
	struct freelist_entry        *ssb_freelist; 
	int _Atomic                   ssb_freelist_lock;
	size_t _Atomic                ssb_overhead; 
};
struct kdp_snapshot_args {
	int                           pid;
	void                         *buffer;
	struct kcdata_descriptor     *descriptor;
	uint32_t                      buffer_size;
	uint64_t                      flags;
	uint64_t                      since_timestamp;
	uint32_t                      pagetable_mask;
};
struct _stackshot_validation_state {
	vm_offset_t last_valid_page_kva;
	size_t last_valid_size;
};
struct _stackshot_plh_gen_state {
	uint8_t                *pgs_gen;       
	int16_t                 pgs_curgen_min; 
	int16_t                 pgs_curgen_max; 
	uint8_t                 pgs_curgen;     
};
struct port_label_hash {
	int _Atomic             plh_lock;       
	uint16_t                plh_size;       
	uint16_t                plh_count;      
	struct ipc_service_port_label **plh_array; 
	int16_t                *plh_chains;    
	int16_t                *plh_hash;      
};
struct stackshot_cpu_context {
	bool                               scc_can_work; 
	bool                               scc_did_work; 
	linked_kcdata_descriptor_t         scc_kcdata_head; 
	linked_kcdata_descriptor_t         scc_kcdata_tail; 
	uintptr_t                         *scc_stack_buffer; 
	struct stackshot_fault_stats       scc_fault_stats;
	struct _stackshot_validation_state scc_validation_state;
	struct _stackshot_plh_gen_state    scc_plh_gen;
};
struct stackshot_context {
	struct kdp_snapshot_args      sc_args;
	int                           sc_calling_cpuid;
	int                           sc_main_cpuid;
	bool                          sc_enable_faulting;
	uint64_t                      sc_microsecs; 
	bool                          sc_panic_stackshot;
	size_t                        sc_min_kcdata_size;
	bool                          sc_is_singlethreaded;

	stackshot_state_t _Atomic     sc_state; 
	kern_return_t                 sc_retval; 
	uint32_t _Atomic              sc_cpus_working;

	linked_kcdata_descriptor_t    sc_pretask_kcdata;
	linked_kcdata_descriptor_t    sc_posttask_kcdata;
	kcdata_descriptor_t           sc_finalized_kcdata;

	struct stackshot_buffer       __counted_by(num_buffers) sc_buffers[STACKSHOT_NUM_BUFFERS];
	size_t                        sc_num_buffers;
	struct stackshot_workqueue    __counted_by(STACKSHOT_NUM_WORKQUEUES) sc_workqueues[STACKSHOT_NUM_WORKQUEUES];
	struct port_label_hash        sc_plh;

	struct stackshot_duration_v2  sc_duration;
	uint32_t                      sc_bytes_traced;
	uint32_t                      sc_bytes_uncompressed;
};
struct stackshot_trace_entry {
	int               sste_line_no;
	uint64_t          sste_timestamp;
	mach_vm_address_t sste_data;
};
struct stackshot_trace_buffer {
	uint64_t                     sstb_last_trace_timestamp;
	size_t                       sstb_tail_idx;
	size_t                       sstb_size;
	struct stackshot_trace_entry __counted_by(STACKSHOT_DEBUG_TRACEBUF_SIZE) sstb_entries[STACKSHOT_DEBUG_TRACEBUF_SIZE];
};
struct {
	uint64_t last_abs_start;      
	uint64_t last_abs_end;        
	uint64_t stackshots_taken;    
	uint64_t stackshots_duration; 
} stackshot_stats = { 0 };
struct _stackshot_backtrace_context {
	vm_map_t sbc_map;
	vm_offset_t sbc_prev_page;
	vm_offset_t sbc_prev_kva;
	uint32_t sbc_flags;
	bool sbc_allow_faulting;
};
struct saved_uniqueids {
	uint64_t ids[UNIQUEIDSPERFLUSH];
	unsigned count;
};
struct kpc_config_remote {
	uint32_t classes;
	kpc_config_t *configv;
	uint64_t pmc_mask;
	bool secure;
};
struct kpc_running_remote {
	uint32_t        classes;                
	uint64_t        cfg_target_mask;        
	uint64_t        cfg_state_mask;         
};
struct kpc_get_counters_remote {
	uint32_t classes;
	uint32_t nb_counters;
	uint32_t buf_stride;
	uint64_t *buf;
};
struct ledger_callback {
	ledger_callback_t       lc_func;
	const void              *lc_param0;
	const void              *lc_param1;
};
struct entry_template {
	char                    et_key[LEDGER_NAME_MAX];
	char                    et_group[LEDGER_NAME_MAX];
	char                    et_units[LEDGER_NAME_MAX];
	uint32_t                et_flags;
	uint16_t                et_size;
	uint16_t                et_offset;
	struct ledger_callback  *et_callback;
};
struct ledger_template {
	const char              *lt_name;
	int                     lt_refs;
	volatile uint32_t       lt_inuse;
	lck_mtx_t               lt_lock;
	zone_t                  lt_zone;
	bool                    lt_initialized;
	uint16_t                lt_next_offset;
	uint16_t                lt_cnt;
	uint16_t                lt_table_size;
	struct entry_template   *lt_entries;
	uint16_t                *lt_entries_lut;
};
struct ledger_info {
	char    li_name[LEDGER_NAME_MAX];
	int64_t li_id;
	int64_t li_entries;
};
struct ledger_template_info {
	char            lti_name[LEDGER_NAME_MAX];
	char            lti_group[LEDGER_NAME_MAX];
	char            lti_units[LEDGER_NAME_MAX];
};
struct ledger_entry {
	volatile uint32_t le_flags;

	uint16_t                 le_warn_percent;
	int16_t                  le_diag_threshold_scaled;  
	ledger_amount_t          le_limit;
	volatile ledger_amount_t le_credit __attribute__((aligned(8)));
	volatile ledger_amount_t le_debit  __attribute__((aligned(8)));
	union {
		struct {
			
			uint64_t le_refill_period;
			uint64_t le_last_refill;
		} le_refill;
		struct {
			ledger_amount_t le_lifetime_max; 
		} _le_max;
	} _le;
} __attribute__((aligned(8)));
struct ledger_entry_small {
	volatile uint32_t les_flags;
	volatile ledger_amount_t les_credit __attribute__((aligned(8)));
} __attribute__((aligned(8)));
struct ledger {
	uint64_t                  l_id;
	os_refcnt_t               l_refs;
	int32_t                   l_size;
	struct ledger_template *  l_template;
	struct ledger_entry_small l_entries[] __attribute__((aligned(8)));
};
struct ledger_entry_info {
	int64_t         lei_balance;
	int64_t         lei_credit;
	int64_t         lei_debit;
	uint64_t        lei_limit;
	uint64_t        lei_refill_period;      
	uint64_t        lei_last_refill;        
};
struct ledger_limit_args {
	char            lla_name[LEDGER_NAME_MAX];
	uint64_t        lla_limit;
	uint64_t        lla_refill_period;
};
struct cond_swi_var32 {
	union {
		uint32_t cond32_data;
		struct {
			uint32_t cond32_owner: SWI_COND_OWNER_BITS,
			    cond32_caller_bits: SWI_COND_CALLER_BITS;
		};
	};
} cond_swi_var32_s;
struct cond_swi_var64 {
	union {
		uint64_t cond64_data;
		struct {
			uint32_t cond64_owner: SWI_COND_OWNER_BITS,
			    cond64_caller_bits: SWI_COND_CALLER_BITS;
			uint32_t cond64_caller_extra;
		};
	};
} cond_swi_var64_s;
struct gate {
	uintptr_t         gt_data;                
	struct turnstile *gt_turnstile;           
	union {
		struct {
			uint32_t  gt_refs:16,             
			    gt_alloc:1,                   
			    gt_type:2,                    
			    gt_flags_pad:13;              
		};
		uint32_t  gt_flags;
	};
} gate_t;
struct lck_spinlock_to_info {
	void                   *lock;
	uintptr_t               owner_thread_cur;
	int                     owner_cpu;
	uint32_t                extra;
} *lck_spinlock_to_info_t;
struct lck_tktlock_pv_info {
	void                   *ltpi_lck;
	uint8_t                 ltpi_wt;
} *lck_tktlock_pv_info_t;
struct lck_attr_startup_spec {
	lck_attr_t              *lck_attr;
	uint32_t                lck_attr_set_flags;
	uint32_t                lck_attr_clear_flags;
};
struct lck_spin_startup_spec {
	lck_spin_t              *lck;
	lck_grp_t               *lck_grp;
	lck_attr_t              *lck_attr;
};
struct lck_ticket_startup_spec {
	lck_ticket_t            *lck;
	lck_grp_t               *lck_grp;
};
struct lck_mtx_mcs {
	struct lck_mtx_s       *lmm_ilk_current;

	struct lck_mtx_mcs     *lmm_ilk_next;
	unsigned long           lmm_ilk_ready;

	struct lck_mtx_mcs     *lmm_as_next;
	unsigned long long      lmm_as_prev;
} __attribute__((aligned(64))) * lck_mtx_mcs_t;
struct lck_spin_mcs {
	struct lck_spin_mcs    *lsm_next;
	const void             *lsm_lock;
	unsigned long           lsm_ready;
} *lck_spin_mcs_t;
struct lck_mcs {
	struct lck_mtx_mcs      mcs_mtx;
	volatile unsigned long  mcs_spin_rsv;
	struct lck_spin_mcs     mcs_spin[2];
} __attribute__((aligned(128))) * lck_mcs_t;
struct {
	lck_mcs_t               txn_mcs;
	lck_spin_mcs_t          txn_slot;
	lck_mcs_id_t            txn_mcs_id;
} lck_spin_txn_t;
struct _lck_attr_ {
	unsigned int    lck_attr_val;
} lck_attr_t;
struct lck_debug_state {
	uint32_t                lds_value;
	long                    lds_counts[LCK_DEBUG_MAX];
} lck_debug_state;
struct _lck_grp_stat_ {
	uint64_t lgs_count;
	uint32_t lgs_enablings;
	uint32_t lgs_probeid;
	uint64_t lgs_limit;
} lck_grp_stat_t;
struct _lck_grp_stats_ {
	lck_grp_stat_t          lgss_spin_held;
	lck_grp_stat_t          lgss_spin_miss;
	lck_grp_stat_t          lgss_spin_spin;

	lck_grp_stat_t          lgss_ticket_held;
	lck_grp_stat_t          lgss_ticket_miss;
	lck_grp_stat_t          lgss_ticket_spin;

	lck_grp_stat_t          lgss_mtx_held;
	lck_grp_stat_t          lgss_mtx_direct_wait;
	lck_grp_stat_t          lgss_mtx_miss;
	lck_grp_stat_t          lgss_mtx_wait;
} lck_grp_stats_t;
struct _lck_grp_ {
	os_ref_atomic_t         lck_grp_refcnt;
	uint32_t                lck_grp_attr_id;
	uint32_t                lck_grp_spincnt;
	uint32_t                lck_grp_ticketcnt;
	uint32_t                lck_grp_mtxcnt;
	uint32_t                lck_grp_rwcnt;
	char                    lck_grp_name[LCK_GRP_MAX_NAME];
	lck_grp_stats_t         lck_grp_stats;
};
struct _lck_grp_attr_ {
	lck_grp_options_t       grp_attr_val;
};
struct lck_grp_spec {
	lck_grp_t              *grp;
	char                    grp_name[LCK_GRP_MAX_NAME];
	lck_grp_options_t       grp_flags;
};
struct lck_mtx_startup_spec {
	lck_mtx_t               *lck;
	lck_grp_t               *lck_grp;
	lck_attr_t              *lck_attr;
};
struct lck_rw_s {
	uint32_t        lck_rw_unused : 24; 
	uint32_t        lck_rw_type   :  8; 
	uint32_t        lck_rw_padding;
	lck_rw_word_t   lck_rw;
	uint32_t        lck_rw_owner;       
} lck_rw_t;
struct lck_rw_startup_spec {
	lck_rw_t                *lck;
	lck_grp_t               *lck_grp;
	lck_attr_t              *lck_attr;
};
struct hw_lck_ticket_reserve_arg {
	uint8_t mt;
	bool    validate;
};
struct hslock {
	uintptr_t       lock_data __kernel_data_semantics;
};
struct {
	uint64_t                hwst_timeout;
} hw_spin_timeout_t;
struct {
	uint64_t                hwss_start;
	uint64_t                hwss_now;
	uint64_t                hwss_deadline;
} hw_spin_state_t;
struct hw_spin_policy {
	const char             *hwsp_name;
	union {
		const uint64_t *hwsp_timeout;
		const _Atomic uint64_t *hwsp_timeout_atomic;
	};
	uint16_t                hwsp_timeout_shift;
	uint16_t                hwsp_lock_offset;

	hw_spin_timeout_fn_t   *hwsp_op_timeout;
};
struct cpu_callback_chain_elem {
	cpu_callback_t                  fn;
	void                            *param;
	struct cpu_callback_chain_elem  *next;
};
struct mach_msg_filter_callbacks {
	unsigned int version;
	const mach_msg_fetch_filter_policy_cbfunc_t fetch_filter_policy;

	const mach_msg_filter_alloc_service_port_sblabel_cbfunc_t alloc_service_port_sblabel;
	const mach_msg_filter_dealloc_service_port_sblabel_cbfunc_t dealloc_service_port_sblabel;
	const mach_msg_filter_derive_sblabel_from_service_port_cbfunc_t derive_sblabel_from_service_port;
	const mach_msg_filter_get_connection_port_filter_policy_cbfunc_t get_connection_port_filter_policy;
	const mach_msg_filter_retain_sblabel_cbfunc_t retain_sblabel;
};
struct mach_node_server_msg {
	mach_msg_header_t   header;
	uint32_t    identifier; 
	uint32_t    options;    
	uint32_t    node_id;    
} *mach_node_server_msg_t;
struct mach_node_server_register_msg {
	struct mach_node_server_msg node_header;
	uint8_t     datamodel;  
	uint8_t     byteorder;  
} *mach_node_server_register_msg_t;
struct mnl_node_info {
	mach_node_id_t  node_id;    
	uint8_t         datamodel;  
	uint8_t         byteorder;  
	uint32_t        proto_vers_min;
	uint32_t        proto_vers_max;
} __attribute__ ((aligned(8))) * mnl_node_info_t;
struct mnl_msg {
	uint8_t     sub;    
	uint8_t     cmd;    
	uint8_t     qos;    
	uint8_t     flags;  
	uint32_t    node_id;
	mnl_name_t  object; 
	uint32_t    options;
	uint32_t    size;   
}  __attribute__((__packed__)) * mnl_msg_t;
struct mk_timer {
	decl_simple_lock_data(, lock);
	thread_call_data_t      mkt_thread_call;
	bool                    is_dead;
	bool                    is_armed;
	int                     active;
	ipc_port_t XNU_PTRAUTH_SIGNED_PTR("mk_timer.port") port;
	ipc_kmsg_t XNU_PTRAUTH_SIGNED_PTR("mk_timer.prealloc") prealloc;
};
struct mpqueue_head {
	struct queue_entry      head;           
	struct priority_queue_deadline_min mpq_pqhead;
	uint64_t                earliest_soft_deadline;
	uint64_t                count;
	lck_ticket_t            lock_data;
};
struct mpsc_queue_chain {
} *mpsc_queue_chain_t;
struct mpsc_queue_head {
	struct mpsc_queue_chain mpqh_head;
} *mpsc_queue_head_t;
struct mpsc_daemon_queue {
	mpsc_daemon_queue_kind_t    mpd_kind;
	mpsc_daemon_queue_options_t mpd_options;
	mpsc_daemon_queue_state_t _Atomic mpd_state;
	mpsc_daemon_invoke_fn_t     mpd_invoke;
	union {
		mpsc_daemon_queue_t     mpd_target;
		struct thread          *mpd_thread;
		struct thread_call     *mpd_call;
	};
	struct mpsc_queue_head      mpd_queue;
	struct mpsc_queue_chain     mpd_chain;
};
struct mpsc_ring {
	char *mr_buffer;
	uint32_t *mr_writer_holds;

	union mpsc_ring_head_tail {
		struct {
			uint32_t mrht_head;
			uint32_t mrht_tail;
		};
		uint64_t mrht_head_tail;
	} mr_head_tail;

	uint32_t mr_capacity;
	uint8_t mr_writer_count;
};
struct {
	uint32_t mrc_commit_pos;
	uint32_t mrc_pos;
	uint32_t mrc_limit;
} mpsc_ring_cursor_t;
struct pager_crypt_info {
	int     (*page_decrypt)(const void *src_vaddr, void *dst_vaddr,
	    unsigned long long src_offset, void *crypt_ops);
	void    (*crypt_end)(void *crypt_ops);
	void    *crypt_ops;
	volatile int    crypt_refcnt;
};
struct crypt_file_data {
	char          *filename;
	cpu_type_t     cputype;
	cpu_subtype_t  cpusubtype;
	crypt_origin_t origin;
};
struct percpu_base {
	vm_address_t start;
	vm_address_t end;
	vm_offset_t  size;
} percpu_base;
struct pmsStat {
	uint64_t        stTime[2];                      
	uint32_t        stCnt[2];                       
} pmsStat;
struct pmsDef {
	uint64_t        pmsLimit;                       
	uint32_t        pmsStepID;                      
	uint32_t        pmsSetCmd;                      



	union sf {
		pmsSetFunc_t    pmsSetFunc;     
		uint32_t        pmsSetFuncInd;  
	} sf;

	uint32_t        pmsDown;                        
	uint32_t        pmsNext;                        
	uint32_t        pmsTDelay;                      
} pmsDef;
struct pmsCtl {
	pmsStat(*pmsStats)[pmsMaxStates];               
	pmsDef          *pmsDefs[pmsMaxStates]; 
} pmsCtl;
struct pmsd {
	uint32_t        pmsState;                       
	uint32_t        pmsCSetCmd;                     
	uint64_t        pmsPop;                         
	uint64_t        pmsStamp;                       
	uint64_t        pmsTime;                        
} pmsd;
struct {
	uint32_t        request;                        
	uint32_t        reqsize;                        
	void            *reqaddr;                       
} pmsctl_t;
struct {
	int16_t         qos_pri[THREAD_QOS_LAST];
	int16_t         qos_iotier[THREAD_QOS_LAST];
	uint32_t        qos_through_qos[THREAD_QOS_LAST];
	uint32_t        qos_latency_qos[THREAD_QOS_LAST];
} qos_policy_params_t;
struct priority_queue_entry {
	struct priority_queue_entry        *next;
	struct priority_queue_entry        *prev;
	long                                __key: PRIORITY_QUEUE_ENTRY_KEY_BITS;
	long                                child: PRIORITY_QUEUE_ENTRY_CHILD_BITS;
} *priority_queue_entry_t;
struct priority_queue_entry_deadline {
	struct priority_queue_entry_deadline *next;
	struct priority_queue_entry_deadline *prev;
	long                                  __key: PRIORITY_QUEUE_ENTRY_KEY_BITS;
	long                                  child: PRIORITY_QUEUE_ENTRY_CHILD_BITS;
	uint64_t                              deadline;
} *priority_queue_entry_deadline_t;
struct priority_queue_entry_sched {
	struct priority_queue_entry_sched  *next;
	struct priority_queue_entry_sched  *prev;
	long                                key: PRIORITY_QUEUE_ENTRY_KEY_BITS;
	long                                child: PRIORITY_QUEUE_ENTRY_CHILD_BITS;
} *priority_queue_entry_sched_t;
struct priority_queue_entry_stable {
	struct priority_queue_entry_stable *next;
	struct priority_queue_entry_stable *prev;
	long                                key: PRIORITY_QUEUE_ENTRY_KEY_BITS;
	long                                child: PRIORITY_QUEUE_ENTRY_CHILD_BITS;
	uint64_t                            stamp;
} *priority_queue_entry_stable_t;
struct priority_queue_min {
	struct priority_queue_entry *pq_root;
	priority_queue_compare_fn_t  pq_cmp_fn;
};
struct priority_queue_max {
	struct priority_queue_entry *pq_root;
	priority_queue_compare_fn_t  pq_cmp_fn;
};
struct priority_queue_deadline_min {
	struct priority_queue_entry_deadline *pq_root;
};
struct priority_queue_deadline_max {
	struct priority_queue_entry_deadline *pq_root;
};
struct priority_queue_sched_min {
	struct priority_queue_entry_sched *pq_root;
};
struct priority_queue_sched_max {
	struct priority_queue_entry_sched *pq_root;
};
struct priority_queue_sched_stable_min {
	struct priority_queue_entry_stable *pq_root;
};
struct priority_queue_sched_stable_max {
	struct priority_queue_entry_stable *pq_root;
};
struct processor_set {
	int                     pset_id;
	int                     online_processor_count;
	int                     cpu_set_low, cpu_set_hi;
	int                     cpu_set_count;
	int                     last_chosen;

	uint64_t                pset_load_last_update;
	cpumap_t                cpu_bitmask;
	cpumap_t                recommended_bitmask;
	cpumap_t                cpu_state_map[PROCESSOR_STATE_LEN];
	cpumap_t                realtime_map;
	cpumap_t                cpu_available_map;


	struct run_queue        pset_runq;      
	struct rt_queue         rt_runq;        
	uint64_t                stealable_rt_threads_earliest_deadline; 

	cpumap_t                pending_AST_URGENT_cpu_mask;
	cpumap_t                pending_AST_PREEMPT_cpu_mask;
	cpumap_t                pending_spill_cpu_mask;
	cpumap_t                rt_pending_spill_cpu_mask;

	struct ipc_port *       pset_self;              
	struct ipc_port *       pset_name_self; 

	processor_set_t         pset_list;              
	pset_node_t             node;
	uint32_t                pset_cluster_id;

	pset_cluster_type_t     pset_cluster_type;
	cluster_type_t          pset_type;

	cpumap_t                perfcontrol_cpu_preferred_bitmask;
	cpumap_t                perfcontrol_cpu_migration_bitmask;
	int                     cpu_preferred_last_chosen;
};
struct pset_node {
	processor_set_t         psets;                  

	pset_node_t             nodes;                  
	pset_node_t             node_list;              

	pset_cluster_type_t     pset_cluster_type;      

	pset_map_t              pset_map;               
	_Atomic pset_map_t      pset_idle_map;          
	_Atomic pset_map_t      pset_non_rt_map;        
	_Atomic pset_map_t      pset_recommended_map;   
};
struct processor {
	processor_state_t       state;                  
	bool                    is_recommended;
	bool                    current_is_bound;       
	bool                    current_is_eagerpreempt;
	bool                    pending_nonurgent_preemption; 
	struct thread          *active_thread;          
	struct thread          *idle_thread;            
	struct thread          *startup_thread;

	processor_set_t         processor_set;  

	int                     current_pri;            
	sfi_class_id_t          current_sfi_class;      
	perfcontrol_class_t     current_perfctl_class;  
	pset_cluster_type_t     current_recommended_pset_type;
	thread_urgency_t        current_urgency;        

	int                     starting_pri;           
	int                     cpu_id;                 

	uint64_t                quantum_end;            
	uint64_t                last_dispatch;          


	uint64_t                deadline;               
	bool                    first_timeslice;        

	bool                    must_idle;              
	bool                    next_idle_short;        


	struct run_queue        runq;                   


	struct ipc_port        *processor_self;         

	processor_t             processor_list;         

	uint64_t                timer_call_ttd;         
	processor_reason_t      last_startup_reason;
	processor_reason_t      last_shutdown_reason;
	processor_reason_t      last_recommend_reason;
	processor_reason_t      last_derecommend_reason;

	bool                    processor_instartup;     

	bool                    processor_booted;       

	bool                    shutdown_temporary;     
	bool                    processor_online;       

	bool                    processor_inshutdown;   
	processor_offline_state_t processor_offline_state;
};
struct queue_entry {
	struct queue_entry      *next;          
	struct queue_entry      *prev;          
};
struct recount_plan {
	const char *rpl_name;
	recount_topo_t rpl_topo;
} *recount_plan_t;
struct recount_track {
	uint32_t rt_pad;
	uint32_t rt_sync;

	struct recount_usage {
		struct recount_metrics {
			
			uint64_t rm_time_mach;
		} ru_metrics[RCT_LVL_COUNT];

	} rt_usage;
};
struct recount_times_mach {
	uint64_t rtm_user;
	uint64_t rtm_system;
};
struct recount_thread {
	struct recount_track *rth_lifetime;
	uint64_t rth_interrupt_duration_mach;
	recount_level_t rth_current_level;
};
struct recount_work_interval {
	struct recount_track *rwi_current_instance;
};
struct recount_task {
	struct recount_track *rtk_lifetime;
	struct recount_usage *rtk_terminated;
};
struct recount_coalition {
	struct recount_usage *rco_exited;
};
struct recount_snap {
	uint64_t rsn_time_mach;
};
struct recount_processor {
	struct recount_snap rpr_snap;
	struct recount_track rpr_active;
	uint64_t rpr_interrupt_duration_mach;
	uint64_t rpr_last_interrupt_enter_time_mach;
	uint64_t rpr_last_interrupt_leave_time_mach;
	uint64_t rpr_idle_time_mach;
	_Atomic uint64_t rpr_state_last_abs_time;
};
struct bt_params {
	double rate;
	uint64_t base_local_ts;
	uint64_t base_remote_ts;
};
struct restartable_ranges {
	queue_chain_t            rr_link;
	os_refcnt_t              rr_ref;
	uint32_t                 rr_count;
	uint32_t                 rr_hash;
	task_restartable_range_t rr_ranges[RR_RANGES_MAX];
};
struct {
	mach_vm_address_t location;
	unsigned short    length;
	unsigned short    recovery_offs;
	unsigned int      flags;
} task_restartable_range_t;
struct runq_stats {
	uint64_t                count_sum;
	uint64_t                last_change_timestamp;
};
struct {
	queue_head_t            pri_queue;                      
	uint64_t                pri_earliest_deadline;          
	int                     pri_count;                      
	uint32_t                pri_constraint;                 
} rt_queue_pri_t;
struct rt_queue {
	_Atomic uint64_t        earliest_deadline;              
	_Atomic int             count;                          
	_Atomic uint32_t        constraint;                     
	_Atomic int             ed_index;                       

	bitmap_t                bitmap[BITMAP_LEN(NRTQS)];

	rt_queue_pri_t          rt_queue_pri[NRTQS];

	struct runq_stats       runq_stats;
};
struct shift_data {
	int     shift1;
	int     shift2;
};
struct sched_average {
	sched_avg_comp_t        comp;
	void                    *param;
	int                     period; 
	uint64_t                deadline;
} sched_average[] = {
	{ compute_averunnable, &sched_nrun, 5, 0 },
	{ compute_stack_target, NULL, 5, 1 },
	{ compute_pageout_gc_throttle, NULL, 1, 0 },
	{ compute_pmap_gc_throttle, NULL, 60, 0 },
	{ compute_zone_working_set_size, NULL, ZONE_WSS_UPDATE_PERIOD, 0 },
	{ NULL, NULL, 0, 0 }
};
struct global_powered_cores_state {
	bool    pcs_init_completed;

	cpumap_t pcs_managed_cores;         

	cpumap_t pcs_requested_online_user; 
	cpumap_t pcs_requested_online_clpc_user;
	cpumap_t pcs_requested_online_clpc_system;
	cpumap_t pcs_required_online_pmgr;  
	cpumap_t pcs_required_online_system;  

	int32_t  pcs_powerdown_suspend_count;

	bool     pcs_user_online_core_control;
	bool     pcs_wants_kernel_sleep;
	bool     pcs_in_kernel_sleep;

	struct powered_cores_state {
		
		cpumap_t pcs_powerdown_recommended_cores;

		
		cpumap_t pcs_online_cores;

		
		cpumap_t pcs_tempdown_cores;
	} pcs_effective;

	struct powered_cores_state pcs_requested;


	cpumap_t        pcs_requested_recommended_clpc;
	cpumap_t        pcs_requested_recommended_clpc_system;
	cpumap_t        pcs_requested_recommended_clpc_user;
	bool            pcs_recommended_clpc_failsafe_active;
	bool            pcs_sleep_override_recommended;

	cpumap_t pcs_recommended_cores;

	volatile processor_reason_t pcs_in_flight_reason;
	volatile processor_reason_t pcs_previous_reason;
} pcs = {
	.pcs_powerdown_suspend_count = 1,
	.pcs_requested_online_user = ALL_CORES_POWERED,
	.pcs_requested_online_clpc_user = ALL_CORES_POWERED,
	.pcs_requested_online_clpc_system = ALL_CORES_POWERED,
	.pcs_in_flight_reason = REASON_NONE,
	.pcs_previous_reason = REASON_NONE,
	.pcs_requested.pcs_powerdown_recommended_cores = ALL_CORES_POWERED,
	.pcs_requested_recommended_clpc = ALL_CORES_RECOMMENDED,
	.pcs_requested_recommended_clpc_system = ALL_CORES_RECOMMENDED,
	.pcs_requested_recommended_clpc_user = ALL_CORES_RECOMMENDED,
};
struct sched_update_scan_context {
	uint64_t        earliest_bg_make_runnable_time;
	uint64_t        earliest_normal_make_runnable_time;
	uint64_t        earliest_rt_make_runnable_time;
	uint64_t        sched_tick_last_abstime;
};
struct sched_statistics {
	uint32_t        csw_count;
	uint32_t        preempt_count;
	uint32_t        preempted_rt_count;
	uint32_t        preempted_by_rt_count;
	uint32_t        rt_sched_count;
	uint32_t        interrupt_count;
	uint32_t        ipi_count;
	uint32_t        timer_pop_count;
	uint32_t        idle_transitions;
	uint32_t        quantum_timer_expirations;
};
struct sched_dispatch_table {
	const char *sched_name;
	void    (*init)(void);                          
	void    (*timebase_init)(void);         
	void    (*processor_init)(processor_t processor);       
	void    (*pset_init)(processor_set_t pset);     

	void    (*maintenance_continuation)(void);      

	thread_t        (*choose_thread)(
		processor_t           processor,
		int                           priority,
		thread_t              prev_thread,
		ast_t reason);

	bool    (*steal_thread_enabled)(processor_set_t pset);

	thread_t        (*steal_thread)(
		processor_set_t         pset);

	int (*compute_timeshare_priority)(thread_t thread);

	pset_node_t (*choose_node)(
		thread_t                      thread);

	processor_t     (*choose_processor)(
		processor_set_t                pset,
		processor_t                    processor,
		thread_t                       thread);
	boolean_t (*processor_enqueue)(
		processor_t                    processor,
		thread_t                       thread,
		sched_options_t                options);

	void (*processor_queue_shutdown)(
		processor_t                    processor);

	boolean_t       (*processor_queue_remove)(
		processor_t             processor,
		thread_t                thread);

	boolean_t       (*processor_queue_empty)(processor_t            processor);

	boolean_t       (*priority_is_urgent)(int priority);

	ast_t           (*processor_csw_check)(processor_t processor);

	boolean_t       (*processor_queue_has_priority)(processor_t             processor,
	    int                             priority,
	    boolean_t               gte);

	uint32_t        (*initial_quantum_size)(thread_t thread);

	sched_mode_t    (*initial_thread_sched_mode)(task_t parent_task);

	boolean_t       (*can_update_priority)(thread_t thread);

	void            (*update_priority)(thread_t thread);

	void            (*lightweight_update_priority)(thread_t thread);

	void            (*quantum_expire)(thread_t thread);

	int                     (*processor_runq_count)(processor_t     processor);

	uint64_t    (*processor_runq_stats_count_sum)(processor_t   processor);

	boolean_t       (*processor_bound_count)(processor_t processor);

	void            (*thread_update_scan)(sched_update_scan_context_t scan_context);

	boolean_t   multiple_psets_enabled;

	boolean_t   avoid_processor_enabled;

	bool    (*thread_avoid_processor)(processor_t processor, thread_t thread, ast_t reason);

	bool    (*processor_balance)(processor_t processor, processor_set_t pset);
	rt_queue_t      (*rt_runq)(processor_set_t pset);
	void    (*rt_init)(processor_set_t pset);
	void    (*rt_queue_shutdown)(processor_t processor);
	void    (*rt_runq_scan)(sched_update_scan_context_t scan_context);
	int64_t (*rt_runq_count_sum)(void);
	thread_t (*rt_steal_thread)(processor_set_t pset, uint64_t earliest_deadline);

	uint32_t (*qos_max_parallelism)(int qos, uint64_t options);
	void    (*check_spill)(processor_set_t pset, thread_t thread);
	sched_ipi_type_t (*ipi_policy)(processor_t dst, thread_t thread, boolean_t dst_idle, sched_ipi_event_t event);
	bool    (*thread_should_yield)(processor_t processor, thread_t thread);

	uint32_t (*run_count_incr)(thread_t thread);
	uint32_t (*run_count_decr)(thread_t thread);

	void (*update_thread_bucket)(thread_t thread);

	void (*pset_made_schedulable)(processor_t processor, processor_set_t pset, boolean_t drop_lock);
	void (*cpu_init_completed)(void);
	bool (*thread_eligible_for_pset)(thread_t thread, processor_set_t pset);
};
struct usimple_lock_startup_spec {
	usimple_lock_t  lck;
	unsigned short  lck_init_arg;
};
struct smr_worker {
	struct thread          *thread;
	struct processor       *processor;

	struct waitq            waitq;
	smr_cpu_reason_t        detach_reason;


	struct smrq_list_head   sect_queue;
	struct thread          *sect_waiter;

	struct smr_pcpu        *whead;
	struct smr_pcpu       **wold_tail;
	struct smr_pcpu       **wage_tail;
	struct smr_pcpu       **wcur_tail;
	uint64_t                drain_ctime;

	struct mpsc_queue_head  barrier_queue;
} __attribute__((aligned(64)));
struct smr_pcpu {

	smr_seq_t               c_rd_seq; 

	smr_node_t              qhead;

	smr_seq_t               qold_seq;
	smr_node_t             *qold_tail;

	smr_seq_t               qage_seq;
	smr_node_t             *qage_tail;

	uint32_t                qcur_size;
	uint32_t                qcur_cnt;
	smr_node_t             *qcur_tail;

	uint8_t                 __cacheline_sep[0];

	struct smr             *drain_smr;
	struct smr_pcpu        *drain_next;
	uint16_t                __check_cpu;
	uint8_t                 __check_reason;
	uint8_t                 __check_list;

	hw_lck_ticket_t         stall_lock;
	smr_seq_t               stall_rd_seq;
	smr_seq_t               stall_waiter_goal;
	struct smrq_tailq_head  stall_queue;
	struct turnstile       *stall_ts;
} __attribute__((aligned(128))) * smr_pcpu_t;
struct smr_barrier_ctx {
	struct smr             *smrb_domain;
	struct thread          *smrb_waiter;
	uint32_t                smrb_pending;
	uint32_t                smrb_count;
};
struct smr_barrier_job {
	struct smr_barrier_ctx *smrj_context;
	union {
		struct smr_node smrj_node;
		struct mpsc_queue_chain smrj_link;
	};
};
struct {
	smr_seq_t               s_rd_seq;
	smr_seq_t               s_wr_seq;
} smr_clock_t;
struct smr {
	smr_clock_t             smr_clock;
	struct smr_pcpu        *smr_pcpu;
	unsigned long           smr_flags;
	unsigned long           smr_early;
	char                    smr_name[SMR_NAME_MAX];
} __attribute__((aligned(64)));
struct smr_tracker {
	smr_t                   smrt_domain;
	smr_seq_t               smrt_seq;
	struct smrq_link        smrt_link;
	struct smrq_slink       smrt_stack;
	uint32_t                smrt_ctid;
	int                     smrt_cpu;
} *smr_tracker_t;
struct {
	union {
		const char     *smrk_string;
		const void     *smrk_opaque;
		uint64_t        smrk_u64;
	};
	size_t                  smrk_len;
} smrh_key_t;
struct smrh_traits {
	unsigned long           link_offset;
	smr_t                   domain;
	uint32_t              (*key_hash)(smrh_key_t, uint32_t);
	bool                  (*key_equ)(smrh_key_t, smrh_key_t);
	uint32_t              (*obj_hash)(const struct smrq_slink *, uint32_t);
	bool                  (*obj_equ)(const struct smrq_slink *, smrh_key_t);
	bool                  (*obj_try_get)(void *);
};
struct smr_hash {
	uintptr_t               smrh_array;
	uint32_t                smrh_count;
	bool                    smrh_resizing;
	uint8_t                 smrh_unused1;
	uint16_t                smrh_unused2;
};
struct smr_hash_array {
	struct smrq_slist_head *smrh_array;
	uint16_t                smrh_order;
};
struct smr_hash_iterator {
	struct smr_hash        *smrh;
	struct smrq_slist_head *hd_next;
	struct smrq_slist_head *hd_last;
	__smrq_slink_t         *prev;
	struct smrq_slink      *link;
};
struct {
	uint8_t                 curidx;
	uint8_t                 curshift;
	uint8_t                 newidx;
	uint8_t                 newshift;
} smrsh_state_t;
struct smr_shash {
	hw_lck_ptr_t *_Atomic   smrsh_array[2];
	uint32_t _Atomic        smrsh_seed[2];
	smrsh_state_t _Atomic   smrsh_state;
	smrsh_rehash_t _Atomic  smrsh_rehashing;
	smrsh_policy_t          smrsh_policy;
	uint16_t                smrsh_min_shift : 5;
	uint16_t                __unused_bits : 11;
	scalable_counter_t      smrsh_count;
	struct thread_call     *smrsh_callout;
};
struct {
	hw_lck_ptr_t           *head;
	__smrq_slink_t         *prev;
} smr_shash_mut_cursor_t;
struct smr_node {
	struct smr_node        *smrn_next;
	smr_cb_t XNU_PTRAUTH_SIGNED_FUNCTION_PTR("ssmr_cb_t") smrn_cb;
};
struct smrq_slink {
	__smrq_slink_t          next;
};
struct smrq_link {
	__smrq_link_t           next;
	__smrq_link_t          *prev;
};
struct smrq_slist_head {
	__smrq_slink_t          first;
};
struct smrq_list_head {
	__smrq_link_t           first;
};
struct smrq_stailq_head {
	__smrq_slink_t          first;
	__smrq_slink_t         *last;
};
struct smrq_tailq_head {
	__smrq_link_t           first;
	__smrq_link_t          *last;
};
struct {
	uint64_t boot_time_ns;
	vm_offset_t trace_buff_offset;
	uint32_t trace_buff_len;
} socd_client_cfg_t;
struct {
	_Atomic uint32_t trace_idx;
} socd_client_state = {0};
struct {
	uint32_t version;
	uint64_t boot_time;
	uuid_t kernel_uuid;
	uuid_t primary_kernelcache_uuid;
} __attribute__((packed)) socd_client_hdr_t;
struct {
	uint64_t timestamp;
	uint32_t debugid;
	socd_client_trace_arg_t arg1;
	socd_client_trace_arg_t arg2;
	socd_client_trace_arg_t arg3;
	socd_client_trace_arg_t arg4;
} __attribute ((packed)) socd_client_trace_entry_t;
struct stack_cache {
	vm_offset_t     free;
	unsigned int    count;
};
struct machine_timeout_spec {
	void *ptr;
	uint64_t default_value;
	uint64_t unit_scale;
	char name[MACHINE_TIMEOUT_MAX_NAME_LEN + 1];
	bool (*skip_predicate)(struct machine_timeout_spec const *);
};
struct startup_entry {
	startup_subsystem_id_t subsystem;
	startup_rank_t         rank;
	void                 (*func)(const void *);
	const void            *arg;
};
struct startup_tunable_spec {
	const char *name;
	void       *var_addr;
	int         var_len;
	bool        var_is_bool;
	bool        var_is_str;
};
struct startup_tunable_dt_spec {
	const char *dt_base;
	const char *dt_name;
	bool        dt_chosen_override;
	const char *boot_arg_name;
	void       *var_addr;
	int         var_len;
	bool        var_is_bool;
};
struct startup_tunable_dt_source_spec {
	const char       *dt_base;
	const char       *dt_name;
	bool              dt_chosen_override;
	const char       *boot_arg_name;
	void             *var_addr;
	int               var_len;
	bool              var_is_bool;
	startup_source_t *source_addr;
};
struct event_hdr {
	struct event_hdr *next;
};
struct semaphore {
	queue_chain_t     task_link;  
	struct waitq      waitq;      
	task_t            owner;      
	ipc_port_t        port;       
	os_ref_atomic_t   ref_count;  
	int               count;      
} Semaphore;
struct {
	unsigned char           mach_trap_arg_count; 
	unsigned char           mach_trap_u32_words; 
	unsigned char           mach_trap_returns_port;
	unsigned char           __mach_trap_padding;
	kern_return_t         (*mach_trap_function)(void *);
} mach_trap_t;
struct zinfo_usage_store_t {
	uint64_t        alloc __attribute__((aligned(8)));              
	uint64_t        free __attribute__((aligned(8)));               
} zinfo_usage_store_t;
struct task_exc_guard_named_default {
	char *name;
	uint32_t behavior;
};
struct _cpu_time_qos_stats {
	uint64_t cpu_time_qos_default;
	uint64_t cpu_time_qos_maintenance;
	uint64_t cpu_time_qos_background;
	uint64_t cpu_time_qos_utility;
	uint64_t cpu_time_qos_legacy;
	uint64_t cpu_time_qos_user_initiated;
	uint64_t cpu_time_qos_user_interactive;
};
struct task_writes_counters {
	uint64_t task_immediate_writes;
	uint64_t task_deferred_writes;
	uint64_t task_invalidated_writes;
	uint64_t task_metadata_writes;
};
struct task_pend_token {
	union {
		struct {
			uint32_t        tpt_update_sockets      :1,
			    tpt_update_timers       :1,
			    tpt_update_watchers     :1,
			    tpt_update_live_donor   :1,
			    tpt_update_coal_sfi     :1,
			    tpt_update_throttle     :1,
			    tpt_update_thread_sfi   :1,
			    tpt_force_recompute_pri :1,
			    tpt_update_tg_ui_flag   :1,
			    tpt_update_turnstile    :1,
			    tpt_update_tg_app_flag  :1,
			    tpt_update_game_mode    :1,
			    tpt_update_carplay_mode :1;
		};
		uint32_t tpt_value;
	};
};
struct task {
	decl_lck_mtx_data(, lock);      
	os_refcnt_t     ref_count;      


	bool            active;         
	bool            ipc_active;     
	bool            halting;        
	bool            message_app_suspended;  

	uint32_t        vtimers;
	uint32_t loadTag; 

	uint64_t        task_uniqueid;

	vm_map_t        XNU_PTRAUTH_SIGNED_PTR("task.map") map; 
	queue_chain_t   tasks;  
	struct task_watchports *watchports; 
	turnstile_inheritor_t returnwait_inheritor; 

	queue_head_t            threads;
	struct restartable_ranges *t_rr_ranges;

	processor_set_t         pset_hint;
	struct affinity_space   *affinity_space;

	int                     thread_count;
	uint32_t                active_thread_count;
	int                     suspend_count;  

	integer_t               user_stop_count;        
	integer_t               legacy_stop_count;      

	int16_t                 priority;               
	int16_t                 max_priority;           

	integer_t               importance;             


	uint64_t                total_runnable_time;

	struct recount_task     tk_recount;

	decl_lck_mtx_data(, itk_lock_data);
	struct ipc_port * XNU_PTRAUTH_SIGNED_PTR("task.itk_task_ports") itk_task_ports[TASK_SELF_PORT_COUNT];
	struct ipc_port * XNU_PTRAUTH_SIGNED_PTR("task.itk_self") itk_self;                     
	struct exception_action exc_actions[EXC_TYPES_COUNT];
	struct hardened_exception_action hardened_exception_action;
	struct ipc_port * XNU_PTRAUTH_SIGNED_PTR("task.itk_host") itk_host;                     
	struct ipc_port * XNU_PTRAUTH_SIGNED_PTR("task.itk_bootstrap") itk_bootstrap;           
	struct ipc_port * XNU_PTRAUTH_SIGNED_PTR("task.itk_debug_control") itk_debug_control;   
	struct ipc_port * XNU_PTRAUTH_SIGNED_PTR("task.itk_task_access") itk_task_access;       
	struct ipc_port * XNU_PTRAUTH_SIGNED_PTR("task.itk_resume") itk_resume;                 
	struct ipc_port * XNU_PTRAUTH_SIGNED_PTR("task.itk_registered") itk_registered[TASK_PORT_REGISTER_MAX];
	ipc_port_t * XNU_PTRAUTH_SIGNED_PTR("task.itk_dyld_notify") itk_dyld_notify; 
	struct ipc_space * XNU_PTRAUTH_SIGNED_PTR("task.itk_space") itk_space;

	ledger_t        ledger;
	queue_head_t    semaphore_list;         
	int             semaphores_owned;       

	unsigned int    priv_flags;                     

	MACHINE_TASK

	counter_t faults;             
	counter_t pageins;            
	counter_t cow_faults;         
	counter_t messages_sent;      
	counter_t messages_received;  
	counter_t pages_grabbed;      
	counter_t pages_grabbed_kern; 
	counter_t pages_grabbed_iopl; 
	counter_t pages_grabbed_upl;  
	uint32_t decompressions;      
	uint32_t syscalls_mach;       
	uint32_t syscalls_unix;       
	uint32_t c_switch;            
	uint32_t p_switch;            
	uint32_t ps_switch;           

	kcdata_descriptor_t             corpse_info;
	uint64_t                        crashed_thread_id;
	queue_chain_t                   corpse_tasks;
	struct label *                  crash_label;
	volatile uint32_t t_flags;                                      























	uint32_t t_procflags;                                            



	mach_vm_address_t       all_image_info_addr; 
	mach_vm_size_t          all_image_info_size; 


	bool pidsuspended; 
	bool frozen;       
	bool changing_freeze_state;        
	bool     is_large_corpse;
	uint16_t policy_ru_cpu          :4,
	    policy_ru_cpu_ext      :4,
	    applied_ru_cpu         :4,
	    applied_ru_cpu_ext     :4;
	uint8_t  rusage_cpu_flags;
	uint8_t  rusage_cpu_percentage;         
	uint8_t  rusage_cpu_perthr_percentage;  
	uint8_t                  t_returnwaitflags;


	struct vm_shared_region         *shared_region;

	uint64_t rusage_cpu_interval;           
	uint64_t rusage_cpu_perthr_interval;    
	uint64_t rusage_cpu_deadline;
	thread_call_t rusage_cpu_callt;

	struct bank_task *bank_context;  


	vm_extmod_statistics_data_t     extmod_statistics;

	struct task_requested_policy requested_policy;
	struct task_effective_policy effective_policy;

	struct task_pend_token pended_coalition_changes;

	uint32_t        low_mem_notified_warn           :1,     
	    low_mem_notified_critical       :1,                 
	    purged_memory_warn              :1,                 
	    purged_memory_critical          :1,                 
	    low_mem_privileged_listener     :1,                 
	    mem_notify_reserved             :27;                

	uint32_t memlimit_is_active                 :1, 
	    memlimit_is_fatal                   :1,     
	    memlimit_active_exc_resource        :1,     
	    memlimit_inactive_exc_resource      :1,     
	    memlimit_attrs_reserved             :28;     

	io_stat_info_t          task_io_stats;

	struct task_writes_counters task_writes_counters_internal;
	struct task_writes_counters task_writes_counters_external;

	struct _cpu_time_qos_stats      cpu_time_eqos_stats;
	struct _cpu_time_qos_stats      cpu_time_rqos_stats;

	uint32_t        task_timer_wakeups_bin_1;
	uint32_t        task_timer_wakeups_bin_2;
	uint64_t        task_gpu_ns;

	uint8_t         task_can_transfer_memory_ownership;
	uint8_t         task_objects_disowning;
	uint8_t         task_objects_disowned;
	int             task_volatile_objects;
	int             task_nonvolatile_objects;
	int             task_owned_objects;
	queue_head_t    task_objq;
	decl_lck_mtx_data(, task_objq_lock); 

	unsigned int    task_thread_limit:16;
	unsigned int    task_legacy_footprint:1;
	unsigned int    task_extra_footprint_limit:1;
	unsigned int    task_ios13extended_footprint_limit:1;
	unsigned int    task_region_footprint:1;
	unsigned int    task_region_info_flags:1;
	unsigned int    task_has_crossed_thread_limit:1;
	unsigned int    task_rr_in_flight:1; 
	coalition_t     coalition[COALITION_NUM_TYPES];
	queue_chain_t   task_coalition[COALITION_NUM_TYPES];
	uint64_t        dispatchqueue_offset;




	task_exc_guard_behavior_t task_exc_guard;
	mach_vm_address_t mach_header_vm_address;

	queue_head_t    io_user_clients;

	queue_head_t   task_frozen_cseg_q;  
	boolean_t       donates_own_pages; 
	uint32_t task_shared_region_slide;   
	uuid_t   task_shared_region_uuid;
	uint64_t        memstat_dirty_start; 
	vmobject_list_output_t corpse_vmobject_list;
	uint64_t corpse_vmobject_list_size;


	uint64_t task_cs_auxiliary_info;

};
struct task_watchport_elem {
	task_t                          twe_task;
	ipc_port_t                      twe_port;     
	ipc_port_t XNU_PTRAUTH_SIGNED_PTR("twe_pdrequest") twe_pdrequest;
};
struct task_watchports {
	os_refcnt_t                     tw_refcount;           
	task_t                          tw_task;               
	thread_t                        tw_thread;             
	uint32_t                        tw_elem_array_count;   
	struct task_watchport_elem      tw_elem[];             
};
struct task_power_info_extra {
	uint64_t cycles;
	uint64_t instructions;
	uint64_t pcycles;
	uint64_t pinstructions;
	uint64_t user_ptime;
	uint64_t system_ptime;
	uint64_t runnable_time;
	uint64_t energy;
	uint64_t penergy;
	uint64_t secure_time;
	uint64_t secure_ptime;
};
struct _task_ledger_indices {
	int cpu_time;
	int tkm_private;
	int tkm_shared;
	int phys_mem;
	int wired_mem;
	int conclave_mem;
	int internal;
	int iokit_mapped;
	int external;
	int reusable;
	int alternate_accounting;
	int alternate_accounting_compressed;
	int page_table;
	int phys_footprint;
	int internal_compressed;
	int purgeable_volatile;
	int purgeable_nonvolatile;
	int purgeable_volatile_compressed;
	int purgeable_nonvolatile_compressed;
	int tagged_nofootprint;
	int tagged_footprint;
	int tagged_nofootprint_compressed;
	int tagged_footprint_compressed;
	int network_volatile;
	int network_nonvolatile;
	int network_volatile_compressed;
	int network_nonvolatile_compressed;
	int media_nofootprint;
	int media_footprint;
	int media_nofootprint_compressed;
	int media_footprint_compressed;
	int graphics_nofootprint;
	int graphics_footprint;
	int graphics_nofootprint_compressed;
	int graphics_footprint_compressed;
	int neural_nofootprint;
	int neural_footprint;
	int neural_nofootprint_compressed;
	int neural_footprint_compressed;
	int neural_nofootprint_total;
	int platform_idle_wakeups;
	int interrupt_wakeups;
	int cpu_time_billed_to_me;
	int cpu_time_billed_to_others;
	int physical_writes;
	int logical_writes;
	int logical_writes_to_external;
	int energy_billed_to_me;
	int energy_billed_to_others;
	int memorystatus_dirty_time;
	int pages_grabbed;
	int pages_grabbed_kern;
	int pages_grabbed_iopl;
	int pages_grabbed_upl;
	int frozen_to_swap;
	int swapins;
};
struct proc_ident {
	uint64_t        p_uniqueid;
	pid_t           p_pid;
	int             p_idversion;
};
struct task_id_token {
	struct proc_ident ident;
	ipc_port_t        port;
	uint64_t          task_uniqueid; 
	os_refcnt_t       tidt_refs;
};
struct micro_snapshot_buffer {
	vm_offset_t             buffer;
	uint32_t                size;
	uint32_t                current_position;
	uint32_t                end_point;
};
struct telemetry_target {
	thread_t                         thread;
	uintptr_t                       *frames;
	size_t                           frames_count;
	bool                             user64_regs;
	uint16_t                         async_start_index;
	enum micro_snapshot_flags        microsnapshot_flags;
	bool                             include_metadata;
	struct micro_snapshot_buffer    *buffer;
	lck_mtx_t                       *buffer_mtx;
};
struct telemetry_metadata {
	uint32_t tm_generation;
	uint64_t tm_samples_recorded;
	uint64_t tm_samples_skipped;
	enum telemetry_source {
		TMSRC_NONE = 0,
		TMSRC_UNKNOWN,
		TMSRC_TIME,
		TMSRC_INSTRUCTIONS,
		TMSRC_CYCLES,
	} tm_source;
	uint64_t tm_period;
};
struct _telemetry_uuids {
	errno_t error;
	void *uuid_info;
	uint32_t uuid_info_count;
	uint32_t uuid_info_size;
};
struct thread_exception_elt {
	struct mpsc_queue_chain link;
	exception_type_t        exception_type;
	task_t                  exception_task;
	thread_t                exception_thread;
};
struct thread_backtrace_elt {
	struct mpsc_queue_chain link;
	exception_type_t        exception_type;
	kcdata_object_t         obj;
	exception_port_t        exc_ports[BT_EXC_PORTS_COUNT]; 
};
struct thread_ro {
	struct thread              *tro_owner;
	struct task                *tro_task;

	struct ipc_port            *tro_self_port;
	struct ipc_port            *tro_ports[THREAD_SELF_PORT_COUNT];  

	struct exception_action    *tro_exc_actions;
};
struct thread {

	union {
		queue_chain_t                   runq_links;             
		queue_chain_t                   wait_links;             
		struct mpsc_queue_chain         mpsc_links;             
		struct priority_queue_entry_sched wait_prioq_links;       
	};

	event64_t               wait_event;     
	struct { processor_t    runq; } __runq; 
	waitq_t                 waitq;          
	struct turnstile       *turnstile;      
	void                   *inheritor;      
	struct priority_queue_sched_max sched_inheritor_queue; 
	struct priority_queue_sched_max base_inheritor_queue; 



	decl_simple_lock_data(, sched_lock);     
	decl_simple_lock_data(, wake_lock);      
	uint16_t                options;        

	bool                    wake_active;    
	bool                    at_safe_point;  
	uint8_t                 sched_saved_run_weight;


	ast_t                   reason;         
	uint32_t                quantum_remaining;
	wait_result_t           wait_result;    
	thread_rr_state_t       t_rr_state;     
	thread_continue_t       continuation;   
	void                   *parameter;      

	vm_offset_t             kernel_stack;   
	vm_offset_t             reserved_stack; 

	struct machine_thread   machine;


	int                     state;


	sched_mode_t            sched_mode;     
	sched_mode_t            saved_mode;     

	sched_bucket_t          th_sched_bucket;

	sfi_class_id_t          sfi_class;      
	sfi_class_id_t          sfi_wait_class; 

	uint32_t                sched_flags;            














	int16_t                 sched_pri;              
	int16_t                 base_pri;               
	int16_t                 req_base_pri;           
	int16_t                 max_priority;           
	int16_t                 task_priority;          
	uint16_t                priority_floor_count;   
	int16_t                 suspend_count;          

	int                     iotier_override;        
	os_ref_atomic_t         ref_count;              

	uint32_t                rwlock_count;           
	struct smrq_slist_head  smr_stack;

	integer_t               importance;             

	integer_t               depress_timer_active;
	timer_call_t            depress_timer;

	struct {                                        
		uint32_t            period;
		uint32_t            computation;
		uint32_t            constraint;
		bool                preemptible;
		uint8_t             priority_offset;   
		uint64_t            deadline;
	}                       realtime;

	uint64_t                last_run_time;          
	uint64_t                last_made_runnable_time;        
	uint64_t                last_basepri_change_time;       
	uint64_t                same_pri_latency;
	uint64_t                workq_quantum_deadline;




	processor_t             bound_processor;        
	processor_t             last_processor;         
	processor_t             chosen_processor;       

	uint64_t                computation_metered;
	uint64_t                computation_epoch;
	uint64_t                computation_interrupt_epoch;
	uint64_t                safe_release;           

	void                  (*sched_call)(int type, thread_t thread);


	uint32_t                c_switch;               
	uint32_t                p_switch;               
	uint32_t                ps_switch;              

	uint64_t                sched_time_save;        
	uint64_t                vtimer_user_save;       
	uint64_t                vtimer_prof_save;
	uint64_t                vtimer_rlim_save;
	uint64_t                vtimer_qos_save;

	timer_data_t            runnable_timer;         

	struct recount_thread   th_recount;             


	queue_chain_t           affinity_threads;
	affinity_set_t          affinity_set;


	union {
		struct {
			
			mach_msg_recv_bufs_t    recv_bufs;      
			mach_msg_option64_t     option;         
			ipc_object_t            object;         

			
			mach_msg_return_t       state;          
			mach_port_seqno_t       seqno;          
			mach_msg_size_t         msize;          
			mach_msg_size_t         asize;          
			mach_port_name_t        receiver_name;  
			union {
				struct ipc_kmsg   *XNU_PTRAUTH_SIGNED_PTR("thread.ith_kmsg")  kmsg;  
			};
		} receive;
		struct {
			struct semaphore        *waitsemaphore;         
			struct semaphore        *signalsemaphore;       
			int                     options;                
			kern_return_t           result;                 
			mach_msg_continue_t continuation;
		} sema;
		struct {
			void                    *tls[THREAD_SAVE_IOKIT_TLS_COUNT];
		} iokit;
	} saved;

	union {
		
		struct thread_call_thread_state *thc_state;

		
		struct {
			int                             os_reason;
			exception_type_t                exception_type;
			mach_exception_code_t           code;
			mach_exception_subcode_t        subcode;
		} mach_exc_info;
	};

	int32_t                 user_stop_count;

	circle_queue_head_t     ith_messages;           
	mach_port_t             ith_kernel_reply_port;  

	bool                    th_vm_faults_disabled;

	bool                    recover;                


	queue_chain_t           threads;                

	queue_chain_t           task_threads;

	struct thread_ro       *t_tro;
	vm_map_t                map;
	thread_t                handoff_thread;

	timer_call_t            wait_timer;
	uint16_t                wait_timer_active; 
	bool                    wait_timer_armed; 

	uint32_t
	    active:1,           
	    ipc_active:1,       
	    started:1,          
	    static_param:1,     
	    inspection:1,       
	    policy_reset:1,     
	    suspend_parked:1,   
	    corpse_dup:1,       
	:0;

	os_atomic(ast_t)        ast;

	decl_lck_mtx_data(, mutex);

	struct ipc_port         *ith_special_reply_port;   

	uint16_t                t_dtrace_flags;         
	uint16_t                t_dtrace_inprobe;       
	uint32_t                t_dtrace_predcache;     
	int64_t                 t_dtrace_tracing;       
	int64_t                 t_dtrace_vtime;

	clock_sec_t             t_page_creation_time;
	uint32_t                t_page_creation_count;
	uint32_t                t_page_creation_throttled;
	int                     t_pagein_error;         

	mach_port_name_t        ith_voucher_name;
	ipc_voucher_t           ith_voucher;








	uint32_t                syscalls_unix;
	uint32_t                syscalls_mach;
	ledger_t                t_ledger;
	ledger_t                t_threadledger; 
	ledger_t                t_bankledger;                
	uint64_t                t_deduct_bank_ledger_time;   
	uint64_t                t_deduct_bank_ledger_energy; 

	uint64_t                thread_id;             
	uint32_t                ctid;                  
	uint32_t                ctsid;                 

	struct thread_requested_policy  requested_policy;
	struct thread_effective_policy  effective_policy;

	struct thread_qos_override {
		struct thread_qos_override      *override_next;
		uint32_t        override_contended_resource_count;
		int16_t         override_qos;
		int16_t         override_resource_type;
		user_addr_t     override_resource;
	} *overrides;

	uint32_t                kevent_overrides;
	uint8_t                 user_promotion_basepri;
	uint8_t                 kern_promotion_schedpri;
	_Atomic uint16_t        kevent_ast_bits;

	io_stat_info_t          thread_io_stats; 

	uint32_t                thread_callout_interrupt_wakeups;
	uint32_t                thread_callout_platform_idle_wakeups;
	uint32_t                thread_timer_wakeups_bin_1;
	uint32_t                thread_timer_wakeups_bin_2;
	thread_tag_t            thread_tag;

	uint16_t
	    callout_woken_from_icontext:1,
	    callout_woken_from_platform_idle:1,
	    callout_woke_thread:1,
	    mach_exc_fatal:1,
	    mach_exc_ktriage:1,
	    thread_bitfield_unused:11;

	uint32_t                 th_bound_cluster_id;


	struct work_interval            *th_work_interval;
	thread_work_interval_flags_t    th_work_interval_flags;

	turnstile_update_flags_t inheritor_flags; 
	block_hint_t            pending_block_hint;
	block_hint_t            block_hint;      
	uint32_t                decompressions;  
	int                     thread_region_page_shift; 
	                                                  
	                                                  

	struct knote            *ith_knote;         


};
struct _thread_ledger_indices {
	int cpu_time;
};
struct thread_pri_floor {
	thread_t thread;
} thread_pri_floor_t;
struct thread_call_group {
	__attribute__((aligned(128))) lck_ticket_t tcg_lock;

	const char *            tcg_name;

	queue_head_t            pending_queue;
	uint32_t                pending_count;

	queue_head_t            delayed_queues[TCF_COUNT];
	struct priority_queue_deadline_min delayed_pqueues[TCF_COUNT];
	timer_call_data_t       delayed_timers[TCF_COUNT];

	timer_call_data_t       dealloc_timer;

	struct waitq            idle_waitq;
	uint64_t                idle_timestamp;
	uint32_t                idle_count, active_count, blocked_count;

	uint32_t                tcg_thread_pri;
	uint32_t                target_thread_count;

	thread_call_group_flags_t tcg_flags;

	struct waitq            waiters_waitq;
} thread_call_groups[THREAD_CALL_INDEX_MAX] = {
	[THREAD_CALL_INDEX_INVALID] = {
		.tcg_name               = "invalid",
	},
	[THREAD_CALL_INDEX_HIGH] = {
		.tcg_name               = "high",
		.tcg_thread_pri         = BASEPRI_PREEMPT_HIGH,
		.target_thread_count    = 4,
		.tcg_flags              = TCG_NONE,
	},
	[THREAD_CALL_INDEX_KERNEL] = {
		.tcg_name               = "kernel",
		.tcg_thread_pri         = BASEPRI_KERNEL,
		.target_thread_count    = 1,
		.tcg_flags              = TCG_PARALLEL,
	},
	[THREAD_CALL_INDEX_USER] = {
		.tcg_name               = "user",
		.tcg_thread_pri         = BASEPRI_DEFAULT,
		.target_thread_count    = 1,
		.tcg_flags              = TCG_PARALLEL,
	},
	[THREAD_CALL_INDEX_LOW] = {
		.tcg_name               = "low",
		.tcg_thread_pri         = MAXPRI_THROTTLE,
		.target_thread_count    = 1,
		.tcg_flags              = TCG_PARALLEL,
	},
	[THREAD_CALL_INDEX_KERNEL_HIGH] = {
		.tcg_name               = "kernel-high",
		.tcg_thread_pri         = BASEPRI_PREEMPT,
		.target_thread_count    = 2,
		.tcg_flags              = TCG_NONE,
	},
	[THREAD_CALL_INDEX_QOS_UI] = {
		.tcg_name               = "qos-ui",
		.tcg_thread_pri         = BASEPRI_FOREGROUND,
		.target_thread_count    = 1,
		.tcg_flags              = TCG_NONE,
	},
	[THREAD_CALL_INDEX_QOS_IN] = {
		.tcg_name               = "qos-in",
		.tcg_thread_pri         = BASEPRI_USER_INITIATED,
		.target_thread_count    = 1,
		.tcg_flags              = TCG_NONE,
	},
	[THREAD_CALL_INDEX_QOS_UT] = {
		.tcg_name               = "qos-ut",
		.tcg_thread_pri         = BASEPRI_UTILITY,
		.target_thread_count    = 1,
		.tcg_flags              = TCG_NONE,
	},
};
struct thread_call_thread_state {
	struct thread_call_group * thc_group;
	struct thread_call *       thc_call;    
	uint64_t thc_call_start;
	uint64_t thc_call_soft_deadline;
	uint64_t thc_call_hard_deadline;
	uint64_t thc_call_pending_timestamp;
	uint64_t thc_IOTES_invocation_timestamp;
	thread_call_func_t  thc_func;
	thread_call_param_t thc_param0;
	thread_call_param_t thc_param1;
};
struct thread_call {
	uint64_t                                tc_soft_deadline;
	struct priority_queue_entry_deadline    tc_pqlink;
	queue_head_t                            *tc_queue;
	queue_chain_t                           tc_qlink;
	thread_call_index_t                     tc_index;
	thread_call_flags_t                     tc_flags;
	int32_t                                 tc_refs;
	uint64_t                                tc_ttd;
	uint64_t                                tc_pending_timestamp;
	thread_call_func_t                      tc_func;
	thread_call_param_t                     tc_param0;
	thread_call_param_t                     tc_param1;
	uint64_t                                tc_submit_count;
	uint64_t                                tc_finish_count;
};
struct thread_kernel_state {
	machine_thread_kernel_state  machine;       
	kern_allocation_name_t       allocation_name;
} __attribute__((aligned(16)));
struct lck_ticket_s {
	uint32_t                __lck_ticket_unused : 24;
	uint32_t                lck_ticket_type     :  8;
	uint32_t                lck_ticket_padding;
	hw_lck_ticket_t         tu;
	uint32_t                lck_ticket_owner;
} lck_ticket_t;
struct timer {
	uint64_t tstamp;
	uint64_t all_bits;
} TIMER_ALIGNMENT;
struct {
	uint64_t        interval;       
	uint64_t        margin;         
	uint64_t        deadline;       
	uint64_t        preempted;      
	timer_call_t    call;           
	uint64_t        deadline_set;   
	timer_call_data_t timer;        
	                                
	uint64_t        scans;          
	uint64_t        preempts;       
	uint64_t        latency;        
	uint64_t        latency_min;    
	uint64_t        latency_max;    
} threshold_t;
struct {
	mpqueue_head_t  queue;          
	uint64_t        enqueues;       
	uint64_t        dequeues;       
	uint64_t        escalates;      
	uint64_t        scan_time;      
	threshold_t     threshold;      
	uint64_t        scan_limit;     
	uint64_t        scan_interval;  
	uint64_t        scan_pauses;    
} timer_longterm_t;
struct timer_call {
	uint64_t                                tc_soft_deadline;
	decl_simple_lock_data(, tc_lock);          
	struct priority_queue_entry_deadline    tc_pqlink;
	queue_head_t                            *tc_queue;
	queue_chain_t                           tc_qlink;
	timer_call_func_t                       tc_func;
	timer_call_param_t                      tc_param0;
	timer_call_param_t                      tc_param1;
	uint64_t                                tc_ttd; 
	uint64_t                                tc_entry_time;
	uint32_t                                tc_flags;
	bool                                    tc_async_dequeue;
} timer_call_data_t, *timer_call_t;
struct {
	uint32_t powergate_latency_abstime;

	uint32_t idle_entry_timer_processing_hdeadline_threshold_abstime;
	uint32_t interrupt_timer_coalescing_ilat_threshold_abstime;
	uint32_t timer_resort_threshold_abstime;

	int32_t timer_coalesce_rt_shift;
	int32_t timer_coalesce_bg_shift;
	int32_t timer_coalesce_kt_shift;
	int32_t timer_coalesce_fp_shift;
	int32_t timer_coalesce_ts_shift;

	uint64_t timer_coalesce_rt_abstime_max;
	uint64_t timer_coalesce_bg_abstime_max;
	uint64_t timer_coalesce_kt_abstime_max;
	uint64_t timer_coalesce_fp_abstime_max;
	uint64_t timer_coalesce_ts_abstime_max;

	uint32_t latency_qos_scale[NUM_LATENCY_QOS_TIERS];
	uint64_t latency_qos_abstime_max[NUM_LATENCY_QOS_TIERS];
	boolean_t latency_tier_rate_limited[NUM_LATENCY_QOS_TIERS];
} timer_coalescing_priority_params_t;
struct {
	uint32_t idle_entry_timer_processing_hdeadline_threshold_ns;
	uint32_t interrupt_timer_coalescing_ilat_threshold_ns;
	uint32_t timer_resort_threshold_ns;

	int32_t timer_coalesce_rt_shift;
	int32_t timer_coalesce_bg_shift;
	int32_t timer_coalesce_kt_shift;
	int32_t timer_coalesce_fp_shift;
	int32_t timer_coalesce_ts_shift;

	uint64_t timer_coalesce_rt_ns_max;
	uint64_t timer_coalesce_bg_ns_max;
	uint64_t timer_coalesce_kt_ns_max;
	uint64_t timer_coalesce_fp_ns_max;
	uint64_t timer_coalesce_ts_ns_max;

	uint32_t latency_qos_scale[NUM_LATENCY_QOS_TIERS];
	uint64_t latency_qos_ns_max[NUM_LATENCY_QOS_TIERS];
	boolean_t latency_tier_rate_limited[NUM_LATENCY_QOS_TIERS];
} timer_coalescing_priority_params_ns_t;
struct match_record {
	uintptr_t fault_pc;

	trap_telemetry_type_t trap_type;

	uint64_t trap_code;
} match_record_s;
struct rsb_entry {
	match_record_s record;
	trap_telemetry_options_s options;
	size_t bt_frames_count;
	uintptr_t bt_frames[TRAP_TELEMETRY_BT_FRAMES];
} rsb_entry_s;
struct trap_telemetry_tree_entry {
	SPLAY_ENTRY(trap_telemetry_tree_entry) link;
	match_record_s record;
} trap_telemetry_tree_entry_s;
struct trap_debounce_buffer {
	match_record_s records[DEBOUNCE_RECORD_COUNT];

	size_t tail;
} trap_debounce_buffer_s;
struct {
	uint8_t
	    telemetry_ca_event:2,

	    report_once_per_site:1;
} trap_telemetry_options_s;
struct {
	uint8_t
	    recoverable : 1,
	    enable_trap_telemetry : 1;
	trap_telemetry_options_s telemetry_options;
} brk_telemetry_options_s;
struct kernel_brk_descriptor {
	trap_telemetry_type_t    type;
	uint16_t                 base;
	uint16_t                 max;
	brk_telemetry_options_s  options;

	const char *(*handle_breakpoint)(void *states, uint16_t comment);
} *kernel_brk_descriptor_t;
struct trust_cache_entry1 {
	uint8_t cdhash[CS_CDHASH_LEN];
	uint8_t hash_type;
	uint8_t flags;
} __attribute__((__packed__));
struct trust_cache_module1 {
	uint32_t version;
	uuid_t uuid;
	uint32_t num_entries;
	struct trust_cache_entry1 entries[];
} __attribute__((__packed__));
struct turnstile_htable_bucket {
	lck_spin_t                    ts_ht_bucket_lock;
	struct turnstile_hashlist     ts_ht_bucket_list;
};
struct turnstile_stats {
	uint64_t ts_priority_propagation;
	uint64_t ts_no_inheritor;
	uint64_t ts_thread_runnable;
	uint64_t ts_no_priority_change_required;
	uint64_t ts_above_ui_pri_change;
	uint64_t ts_no_turnstile;
};
struct turnstile {
	union {
		
		WAITQ_FLAGS(ts_waitq
		    , __ts_unused_bits: 7
		    , ts_compact_id: CTSID_BITS);
		struct waitq          ts_waitq;              
	};
	union {
		struct turnstile_list ts_free_turnstiles;    
		SLIST_ENTRY(turnstile) ts_free_elm;          
	};
	struct priority_queue_sched_max ts_inheritor_queue;  
	struct priority_queue_entry_sched ts_inheritor_links;    
	SLIST_ENTRY(turnstile)        ts_htable_link;        
	uintptr_t                     ts_proprietor;         
	os_ref_atomic_t               ts_refcount;           
	_Atomic uint32_t              ts_type_gencount;      
	uint32_t                      ts_prim_count;         
	turnstile_update_flags_t      ts_inheritor_flags;    
	uint8_t                       ts_priority;           

};
struct waitq_link_hdr {
	uintptr_t       wql_wqs;
};
struct waitq_sellink {
	uintptr_t       wql_wqs;
	struct waitq_link_list_entry wql_next;
	uint64_t        wql_setid;
};
struct waitq_link {
	uintptr_t       wql_wqs;       
	queue_chain_t   wql_qlink;     
	queue_chain_t   wql_slink;     
	struct waitq   *wql_wq;        
};
struct waitq_select_args {
	event64_t               event;
	wait_result_t           result;
	waitq_wakeup_flags_t    flags;
	uint32_t                max_threads;
	bool                    is_identified;

	uint32_t                nthreads;
	circle_queue_head_t     threadq;
};
struct waitq_link_list_entry {
	struct waitq_link_list_entry *next;
} waitq_link_list_t;
struct waitq {
	WAITQ_HDR(waitq, waitq_eventmask:_EVENT_MASK_BITS);
} __attribute__((aligned(WQ_OPAQUE_ALIGN)));
struct waitq_set {
	WAITQ_HDR(wqset, wqset_index:_EVENT_MASK_BITS);
	circle_queue_head_t wqset_preposts;
};
struct select_set {
	WAITQ_HDR(selset, selset_conflict:1);
	uint64_t selset_id;
};
struct workload_phase_entry {
	LIST_ENTRY(workload_phase_entry)   wpe_link;
	char                               wpe_phase[WORKLOAD_CONFIG_PHASE_NAME_MAX];
	workload_config_t                  wpe_config;
} workload_phase_entry_t;
struct workload_config_entry {
	LIST_ENTRY(workload_config_entry)  wce_link;
	char                               wce_id[WORKLOAD_CONFIG_ID_NAME_MAX];
	const workload_phase_entry_t      *wce_default;
	LIST_HEAD(, workload_phase_entry)  wce_phases;
} workload_config_entry_t;
struct workload_config_ctx {
	workload_config_flags_t            wlcc_flags;
	int32_t                            wlcc_count;
	u_long                             wlcc_hash_mask;
	lck_mtx_t                          wlcc_mtx;
	LIST_HEAD(workload_config_hashhead, workload_config_entry) * wlcc_hashtbl;
};
struct workload_config {
	uint32_t   wc_thread_group_flags;
	uint32_t   wc_flags;
	uint32_t   wc_create_flags;
	uint8_t    wc_class_offset;
	wi_class_t wc_class;
} workload_config_t;
struct work_interval {
	uint64_t wi_id;
	struct os_refcnt wi_ref_count;
	uint32_t wi_create_flags;

	ipc_port_t wi_port;

	uint64_t wi_creator_uniqueid;
	uint32_t wi_creator_pid;
	int wi_creator_pidversion;

	uint32_t wi_wlid_flags;



	wi_class_t wi_class;
	uint8_t wi_class_offset;

	struct recount_work_interval wi_recount;
};
struct {
	int          priority;
	sched_mode_t sched_mode;
} work_interval_class_data[WI_CLASS_COUNT] = {
	[WI_CLASS_BEST_EFFORT] = {
		BASEPRI_DEFAULT,        
		TH_MODE_TIMESHARE,
	},

	[WI_CLASS_APP_SUPPORT] = {
		BASEPRI_USER_INITIATED, 
		TH_MODE_TIMESHARE,
	},

	[WI_CLASS_SYSTEM] = {
		BASEPRI_FOREGROUND + 1, 
		TH_MODE_FIXED,
	},

	[WI_CLASS_SYSTEM_CRITICAL] = {
		MAXPRI_USER + 1,        
		TH_MODE_FIXED,
	},

	[WI_CLASS_REALTIME_CRITICAL] = {
		BASEPRI_RTQUEUES + 1,   
		TH_MODE_REALTIME,
	},
};
struct kern_work_interval_args {
	uint64_t work_interval_id;
	uint64_t start;
	uint64_t finish;
	uint64_t deadline;
	uint64_t next_start;
	uint32_t notify_flags;
	uint32_t create_flags;
	uint16_t urgency;
};
struct kern_work_interval_create_args {
	uint64_t        wica_id;          
	mach_port_name_t wica_port;        
	uint32_t        wica_create_flags;
};
struct kern_work_interval_workload_id_args {
	uint32_t        wlida_flags;            
	uint32_t        wlida_wicreate_flags;   
	char *          wlida_name;             
	uint64_t        wlida_syscall_mask[2];  
};
struct zone_bits_chain {
	uint32_t zbc_next;
	uint32_t zbc_prev;
} __attribute__((aligned(ZBA_GRANULE)));
struct zone_bits_head {
	uint32_t zbh_next;
	uint32_t zbh_unused;
} __attribute__((aligned(ZBA_GRANULE)));
struct zone_bits_allocator_meta {
	uint32_t  zbam_left;
	uint32_t  zbam_right;
	struct zone_bits_head zbam_lists[ZBA_HEADS_COUNT];
	struct zone_bits_head zbam_lists_with_extra[ZBA_HEADS_COUNT];
};
struct zone_bits_allocator_header {
	uint64_t zbah_bits[ZBA_SLOTS / (8 * sizeof(uint64_t))];
};
struct kalloc_result {
	void         *addr __sized_by(size);
	vm_size_t     size;
};
struct zone_view {
	zone_t          zv_zone;
	zone_stats_t    zv_stats;
	const char     *zv_name __unsafe_indexable;
	zone_view_t     zv_next;
};
struct zone_basic_stats {
	uint64_t        zbs_avail;
	uint64_t        zbs_alloc;
	uint64_t        zbs_free;
	uint64_t        zbs_cached;
	uint64_t        zbs_alloc_fail;
};
struct zstack {
	vm_offset_t     z_head;
	uint32_t        z_count;
} zstack_t;
struct zone_cache_ops {
	void         *(*zc_op_alloc)(zone_id_t, zalloc_flags_t);
	void         *(*zc_op_mark_valid)(zone_id_t, void *);
	void         *(*zc_op_mark_invalid)(zone_id_t, void *);
	void          (*zc_op_free)(zone_id_t, void *);
} *zone_cache_ops_t;
struct zone_create_startup_spec {
	zone_t                 *z_var;
	const char             *z_name __unsafe_indexable;
	vm_size_t               z_size;
	zone_create_flags_t     z_flags;
	zone_id_t               z_zid;
	void                  (^z_setup)(zone_t);
};
struct zone_view_startup_spec {
	zone_view_t         zv_view;
	union {
		zone_kheap_id_t zv_heapid;
		zone_t         *zv_zone;
	};
	vm_size_t           zv_size;
};
struct zone_packed_virtual_address {
	uint32_t packed_address;
} zone_pva_t;
struct zone_stats {
	uint64_t            zs_mem_allocated;
	uint64_t            zs_mem_freed;
	uint64_t            zs_alloc_fail;
	uint32_t            zs_alloc_rr;     
	uint32_t _Atomic    zs_alloc_not_early;
};
struct zone_depot {
	uint32_t            zd_full;
	uint32_t            zd_empty;
	zone_magazine_t     zd_head;
	zone_magazine_t    *zd_tail;
};
struct zone_size_params {
	uint32_t            z_align_magic;  
	uint32_t            z_elem_size;    
};
struct zone_expand {
	struct zone_expand *ze_next;
	thread_t            ze_thread;
	bool                ze_pg_wait;
	bool                ze_vm_priv;
	bool                ze_clear_priv;
};
struct zone {

	struct zone        *z_self;
	zone_stats_t        z_stats;
	const char         *z_name;
	struct zone_view   *z_views;
	struct zone_expand *z_expander;

	uint64_t            z_quo_magic;
	uint32_t            z_align_magic;
	uint16_t            z_elem_size;
	uint16_t            z_elem_offs;
	uint16_t            z_chunk_pages;
	uint16_t            z_chunk_elems;

	uint32_t 
	    z_destroyed        :1,  
	    z_async_refilling  :1,  
	    z_depot_cleanup    :1,  
	    z_expanding_wait   :1,  
	    z_exhausted_wait   :1,  
	    z_exhausts         :1,  

	    z_percpu           :1,  
	    z_smr              :1,  
	    z_permanent        :1,  
	    z_nocaching        :1,  
	    collectable        :1,  
	    no_callout         :1,
	    z_destructible     :1,  

	    _reserved          :6,

	    z_pgz_tracked      :1,  
	    z_pgz_use_guards   :1,  
	    z_kasan_fakestacks :1,
	    z_kasan_quarantine :1,  
	    z_tags_sizeclass   :6,  
	    z_uses_tags        :1,
	    z_log_on           :1,  
	    z_tbi_tag          :1;  

	uint8_t             z_cacheline1[0] __attribute__((aligned(64)));

	struct zone_cache  *__zpercpu OS_PTRAUTH_SIGNED_PTR("zone.z_pcpu_cache") z_pcpu_cache;
	struct zone_depot   z_recirc;

	hw_lck_ticket_t     z_recirc_lock;
	uint32_t            z_recirc_full_min;
	uint32_t            z_recirc_full_wma;
	union {
		uint32_t    z_recirc_empty_min;
		uint32_t    z_elems_free_min;
	};
	union {
		uint32_t    z_recirc_empty_wma;
		uint32_t    z_elems_free_wma;
	};
	uint32_t            z_recirc_cont_cur;
	uint32_t            z_recirc_cont_wma;

	uint16_t            z_depot_size;
	uint16_t            z_depot_limit;

	uint8_t             z_cacheline2[0] __attribute__((aligned(64)));


	hw_lck_ticket_t     z_lock;

	uint32_t            z_wired_max;    
	uint32_t            z_wired_hwm;    
	uint32_t            z_wired_cur;    
	uint32_t            z_wired_empty;  
	uint32_t            z_va_cur;       

	zone_pva_t          z_pageq_empty;  
	zone_pva_t          z_pageq_partial;
	zone_pva_t          z_pageq_full;   
	zone_pva_t          z_pageq_va;     

	uint32_t            z_elems_free;   
	uint32_t            z_elems_avail;  
	uint32_t            z_elems_rsv;
	uint32_t            z_array_size_class;

	struct zone        *z_kt_next;

	uint8_t             z_cacheline3[0] __attribute__((aligned(64)));


} __attribute__((aligned((64))));
struct zone_security_flags {
	uint32_t
	    z_submap_idx       :8,  
	    z_kheap_id         :3,  
	    z_kalloc_type      :1,  
	    z_lifo             :1,  
	    z_pgz_use_guards   :1,  
	    z_submap_from_end  :1,  
	    z_noencrypt        :1,  
	    z_tag              :1,  
	    z_unused           :15;
	zone_id_t           z_sig_eq;
} zone_security_flags_t;
struct kheap_info {
	zone_id_t               kh_zstart;
	kalloc_heap_t           kh_views;
	kalloc_type_var_view_t  kt_views;
};
struct action {
	uint32_t sample;
	uint32_t ucallstack_depth;
	uint32_t kcallstack_depth;
	uint32_t userdata;
	int pid_filter;
};
struct kp_ucallstack {
	uint32_t kpuc_flags;
	uint32_t kpuc_nframes;
	uint32_t kpuc_async_index;
	uint32_t kpuc_async_nframes;
	uintptr_t kpuc_frames[MAX_UCALLSTACK_FRAMES];
};
struct kp_kcallstack {
	uint32_t kpkc_flags;
	uint32_t kpkc_nframes;
	union {
		uintptr_t kpkc_word_frames[MAX_KCALLSTACK_FRAMES];
		uint64_t kpkc_frames[MAX_KCALLSTACK_FRAMES] __kernel_ptr_semantics;
	};
	uint32_t kpkc_exclaves_offset;
};
struct kperf_context {
	int cur_pid;
	thread_t cur_thread;
	task_t cur_task;
	uintptr_t *starting_fp;

	unsigned int trigger_type;
	unsigned int trigger_id;
};
struct kperf_kdebug_filter {
	uint64_t types[2];
	uint32_t debugids[KPERF_KDEBUG_DEBUGIDS_MAX];
	uint8_t n_debugids;
} __attribute__((packed)) *kperf_kdebug_filter = NULL;
struct kptimer {
	uint32_t kt_actionid;
	uint64_t kt_period_abs;
	lck_spin_t kt_lock;
	uint64_t kt_cur_deadline;

};
struct {
	struct kptimer *g_timers;
	uint64_t *g_cpu_deadlines;
	unsigned int g_ntimers;
	unsigned int g_pet_timerid;

	bool g_setup:1;
	bool g_pet_active:1;
	bool g_started:1;

	struct timer_call g_pet_timer;
} kptimer = {
	.g_pet_timerid = KPTIMER_PET_INACTIVE,
};
struct meminfo {
	uint64_t phys_footprint;
	uint64_t purgeable_volatile;
	uint64_t purgeable_volatile_compressed;
};
struct {
	unsigned int g_actionid;
	uint32_t g_idle_rate;
	bool g_setup:1;
	bool g_lightweight:1;
	uint64_t g_period;
	struct kperf_sample *g_sample;

	thread_t g_sample_thread;

	thread_t *g_threads;
	unsigned int g_nthreads;
	size_t g_threads_count;

	task_t *g_tasks;
	unsigned int g_ntasks;
	size_t g_tasks_count;
} kppet = {
	.g_actionid = 0,
	.g_idle_rate = KPERF_PET_DEFAULT_IDLE_RATE,
};
struct kperf_usample_min {
	struct kperf_thread_dispatch th_dispatch;
};
struct kperf_usample {
	struct kperf_usample_min *usample_min;
	struct kp_ucallstack ucallstack;
	struct kperf_thread_info th_info;
};
struct kperf_sample {
	struct kperf_thread_info       th_info;
	struct kperf_thread_scheduling th_scheduling;
	struct kperf_thread_snapshot   th_snapshot;

	struct kperf_task_snapshot tk_snapshot;

	struct kp_kcallstack kcallstack;
	struct meminfo     meminfo;

	struct kperf_usample usample;


};
struct kperf_task_snapshot {
	uint64_t kptksn_flags;
	uint64_t kptksn_user_time_in_terminated_threads;
	uint64_t kptksn_system_time_in_terminated_threads;
	int kptksn_suspend_count;
	int kptksn_pageins;
};
struct kperf_thread_info {
	uint64_t kpthi_pid;
	uint64_t kpthi_tid;
	uint64_t kpthi_dq_addr;
	uint64_t kpthi_runmode;
};
struct kperf_thread_scheduling {
	uint64_t kpthsc_user_time;
	uint64_t kpthsc_system_time;
	uint64_t kpthsc_runnable_time;
	unsigned int kpthsc_state;
	uint16_t kpthsc_base_priority;
	uint16_t kpthsc_sched_priority;
	unsigned int kpthsc_effective_qos :3,
	    kpthsc_requested_qos :3,
	    kpthsc_requested_qos_override :3,
	    kpthsc_requested_qos_promote :3,
	    kpthsc_requested_qos_kevent_override :3,
	    kpthsc_requested_qos_sync_ipc_override :3,             
	    kpthsc_effective_latency_qos :3;
};
struct kperf_thread_snapshot {
	uint64_t kpthsn_last_made_runnable_time;
	int16_t kpthsn_suspend_count;
	uint8_t kpthsn_io_tier;
	uint8_t kpthsn_flags;
};
struct kperf_thread_dispatch {
	uint64_t kpthdi_dq_serialno;
	char kpthdi_dq_label[64];
};
struct _quad_ {
	unsigned int    val[2];         
} quad;
struct mach_timespec {
	unsigned int    tv_sec;                 
	clock_res_t     tv_nsec;                
};
struct coalition_resource_usage {
	uint64_t tasks_started;
	uint64_t tasks_exited;
	uint64_t time_nonempty;
	uint64_t cpu_time; 
	uint64_t interrupt_wakeups;
	uint64_t platform_idle_wakeups;
	uint64_t bytesread;
	uint64_t byteswritten;
	uint64_t gpu_time; 
	uint64_t cpu_time_billed_to_me; 
	uint64_t cpu_time_billed_to_others; 
	uint64_t energy; 
	uint64_t logical_immediate_writes;
	uint64_t logical_deferred_writes;
	uint64_t logical_invalidated_writes;
	uint64_t logical_metadata_writes;
	uint64_t logical_immediate_writes_to_external;
	uint64_t logical_deferred_writes_to_external;
	uint64_t logical_invalidated_writes_to_external;
	uint64_t logical_metadata_writes_to_external;
	uint64_t energy_billed_to_me; 
	uint64_t energy_billed_to_others; 
	uint64_t cpu_ptime; 
	uint64_t cpu_time_eqos_len;     
	uint64_t cpu_time_eqos[COALITION_NUM_THREAD_QOS_TYPES];
	uint64_t cpu_instructions;
	uint64_t cpu_cycles;
	uint64_t fs_metadata_writes;
	uint64_t pm_writes;
	uint64_t cpu_pinstructions;
	uint64_t cpu_pcycles;
	uint64_t conclave_mem;
	uint64_t ane_mach_time; 
	uint64_t ane_energy_nj; 
	uint64_t phys_footprint;        
	uint64_t gpu_energy_nj; 
	uint64_t gpu_energy_nj_billed_to_me; 
	uint64_t gpu_energy_nj_billed_to_others; 
};
struct coalinfo_debuginfo {
	uint64_t thread_group_id;
	uint32_t thread_group_recommendation;
	uint32_t thread_group_flags;
	uint32_t focal_task_count;
	uint32_t nonfocal_task_count;
	uint32_t game_task_count;
	uint32_t carplay_task_count;
};
struct procinfo_coalinfo {
	uint64_t coalition_id;
	uint32_t coalition_type;
	uint32_t coalition_tasks;
};
struct coalition_pend_token {
	uint32_t        cpt_update_timers      :1,
	    cpt_update_j_coal_tasks :1;
} *coalition_pend_token_t;
struct list_xattrs_result {
	uint64_t finderInfoOffset; 
	uint64_t resourceForkOffset; 
	uint64_t resourceForkLength; 
	uint64_t numOfXattrs;

	uint64_t dataLength;
	uint64_t namesLength;
	uint64_t rangesLength;
	uint8_t  data[LISTXATTR_RESULT_MAX_SIZE];
} listxattrs_result_t;
struct dyld_kernel_image_info {
	uuid_t uuid;
	fsobj_id_t fsobjid;
	fsid_t fsid;
	uint64_t load_addr;
};
struct dyld_kernel_process_info {
	struct dyld_kernel_image_info cache_image_info;
	uint64_t timestamp;         
	uint32_t imageCount;        
	uint32_t initialImageCount; 
	uint8_t dyldState;          
	boolean_t no_cache;         
	boolean_t private_cache;    
};
struct mwl_region {
	int                  mwlr_fd;      
	vm_prot_t            mwlr_protections;
	uint64_t             mwlr_file_offset;
	mach_vm_address_t    mwlr_address __kernel_data_semantics; 
	mach_vm_size_t       mwlr_size;    
};
struct mwl_info_hdr {
	uint32_t        mwli_version;            
	uint16_t        mwli_page_size;          
	uint16_t        mwli_pointer_format;     
	uint32_t        mwli_binds_offset;       
	uint32_t        mwli_binds_count;        
	uint32_t        mwli_chains_offset;      
	uint32_t        mwli_chains_size;        
	uint64_t        mwli_slide;              
	uint64_t        mwli_image_address;      
};
struct events_info {
	integer_t       faults;         
	integer_t       zero_fills;     
	integer_t       reactivations;  
	integer_t       pageins;        
	integer_t       cow_faults;     
	integer_t       messages_sent;  
	integer_t       messages_received; 
};
struct {
	void *ipcb;
	unsigned long scid;
	uint64_t usecnt;
} exclaves_ctx_t;
struct exclaves_resource_user {
	char                  r_name[MAXCONCLAVENAME];
	uint64_t              r_type;
	exclaves_id_t         r_id;
	mach_port_name_t      r_port;
} exclaves_resouce_user_t;
struct __Exclaves_L4_Packed {
	Exclaves_L4_Word_t mr[Exclaves_L4_IpcBuffer_Mrs];
	Exclaves_L4_Word_t scr[Exclaves_L4_IpcBuffer_Crs];
	Exclaves_L4_Word_t dcr[Exclaves_L4_IpcBuffer_Crs];
} Exclaves_L4_IpcBuffer_t;
struct host_basic_info_old {
	integer_t       max_cpus;       
	uint32_t        avail_cpus;     
	natural_t       memory_size;    
	cpu_type_t      cpu_type;       
	cpu_subtype_t   cpu_subtype;    
};
struct host_can_has_debugger_info {
	boolean_t       can_has_debugger;
};
struct host_basic_info {
	integer_t               max_cpus;               
	integer_t               avail_cpus;             
	natural_t               memory_size;            
	cpu_type_t              cpu_type;               
	cpu_subtype_t           cpu_subtype;            
	cpu_threadtype_t        cpu_threadtype;         
	integer_t               physical_cpu;           
	integer_t               physical_cpu_max;       
	integer_t               logical_cpu;            
	integer_t               logical_cpu_max;        
	uint64_t                max_mem;                
};
struct host_sched_info {
	integer_t       min_timeout;    
	integer_t       min_quantum;    
};
struct kernel_resource_sizes {
	natural_t       task;
	natural_t       thread;
	natural_t       port;
	natural_t       memory_region;
	natural_t       memory_object;
};
struct host_priority_info {
	integer_t       kernel_priority;
	integer_t       system_priority;
	integer_t       server_priority;
	integer_t       user_priority;
	integer_t       depress_priority;
	integer_t       idle_priority;
	integer_t       minimum_priority;
	integer_t       maximum_priority;
};
struct vm_compressor_q_lens {
	uint32_t qcc_segments_available;
	uint32_t qcc_segment_count;
	uint32_t qcc_age_count;
	uint32_t qcc_early_swappedin_count, qcc_regular_swappedin_count, qcc_late_swappedin_count;
	uint32_t qcc_early_swapout_count, qcc_regular_swapout_count, qcc_late_swapout_count;
	uint32_t qcc_swapio_count;
	uint32_t qcc_swappedout_count;
	uint32_t qcc_swappedout_sparse_count;
	uint32_t qcc_major_count;
	uint32_t qcc_filling_count;
	uint32_t qcc_empty_count;
	uint32_t qcc_bad_count;
	uint32_t qcc_minor_count;
};
struct host_load_info {
	integer_t       avenrun[3];     
	integer_t       mach_factor[3]; 
};
struct host_cpu_load_info {             
	natural_t       cpu_ticks[CPU_STATE_MAX]; 
};
struct host_preferred_user_arch {
	cpu_type_t      cpu_type;       
	cpu_subtype_t   cpu_subtype;    
};
struct _processor_statistics_np  {
	int32_t                 ps_cpuid;

	uint32_t                ps_csw_count;
	uint32_t                ps_preempt_count;
	uint32_t                ps_preempted_rt_count;
	uint32_t                ps_preempted_by_rt_count;

	uint32_t                ps_rt_sched_count;

	uint32_t                ps_interrupt_count;
	uint32_t                ps_ipi_count;
	uint32_t                ps_timer_pop_count;

	uint64_t                ps_runq_count_sum __attribute((aligned(8)));

	uint32_t                ps_idle_transitions;
	uint32_t                ps_quantum_timer_expirations;
};
struct host_debug_info_internal {
	uint64_t config_bank:1,   
	    config_atm:1,
	    config_csr:1,
	    config_coalitions:1,
	    config_unused:60;
};
struct kmod_reference {
	struct kmod_reference * next;
	struct kmod_info      * info;
} kmod_reference_t;
struct kmod_info {
	struct kmod_info  * next;
	int32_t             info_version;       
	uint32_t            id;
	char                name[KMOD_MAX_NAME];
	char                version[KMOD_MAX_NAME];
	int32_t             reference_count;    
	kmod_reference_t  * reference_list;     
	vm_address_t        address;            
	vm_size_t           size;               
	vm_size_t           hdr_size;           
	kmod_start_func_t * start;
	kmod_stop_func_t  * stop;
} kmod_info_t;
struct kmod_info_32_v1 {
	uint32_t            next_addr;
	int32_t             info_version;
	uint32_t            id;
	uint8_t             name[KMOD_MAX_NAME];
	uint8_t             version[KMOD_MAX_NAME];
	int32_t             reference_count;
	uint32_t            reference_list_addr;
	uint32_t            address;
	uint32_t            size;
	uint32_t            hdr_size;
	uint32_t            start_addr;
	uint32_t            stop_addr;
} kmod_info_32_v1_t;
struct kmod_info_64_v1 {
	uint64_t            next_addr;
	int32_t             info_version;
	uint32_t            id;
	uint8_t             name[KMOD_MAX_NAME];
	uint8_t             version[KMOD_MAX_NAME];
	int32_t             reference_count;
	uint64_t            reference_list_addr;
	uint64_t            address;
	uint64_t            size;
	uint64_t            hdr_size;
	uint64_t            start_addr;
	uint64_t            stop_addr;
} kmod_info_64_v1_t;
struct machine_info {
	integer_t       major_version;          
	integer_t       minor_version;          
	integer_t       max_cpus;                       
	uint32_t        memory_size;            
	uint64_t        max_mem;                        
	uint32_t        physical_cpu;           
	integer_t       physical_cpu_max;       
	uint32_t        logical_cpu;            
	integer_t       logical_cpu_max;        
};
struct mach_timebase_info {
	uint32_t        numer;
	uint32_t        denom;
};
struct mach_voucher_attr_recipe_data {
	mach_voucher_attr_key_t                 key;
	mach_voucher_attr_recipe_command_t      command;
	mach_voucher_name_t                     previous_voucher;
	mach_voucher_attr_content_size_t        content_size;
	uint8_t                                 content[];
} mach_voucher_attr_recipe_data_t;
struct memory_object {
	mo_ipc_object_bits_t                    mo_ikot; 
	os_ref_atomic_t                         mo_ref;
	const struct memory_object_pager_ops    *mo_pager_ops;
	memory_object_control_t                 mo_control;
} *memory_object_t;
struct memory_object_pager_ops {
	void (*memory_object_reference)(
		memory_object_t mem_obj);
	void (*memory_object_deallocate)(
		memory_object_t mem_obj);
	kern_return_t (*memory_object_init)(
		memory_object_t mem_obj,
		memory_object_control_t mem_control,
		memory_object_cluster_size_t size);
	kern_return_t (*memory_object_terminate)(
		memory_object_t mem_obj);
	kern_return_t (*memory_object_data_request)(
		memory_object_t mem_obj,
		memory_object_offset_t offset,
		memory_object_cluster_size_t length,
		vm_prot_t desired_access,
		memory_object_fault_info_t fault_info);
	kern_return_t (*memory_object_data_return)(
		memory_object_t mem_obj,
		memory_object_offset_t offset,
		memory_object_cluster_size_t size,
		memory_object_offset_t *resid_offset,
		int *io_error,
		boolean_t dirty,
		boolean_t kernel_copy,
		int upl_flags);
	kern_return_t (*memory_object_data_initialize)(
		memory_object_t mem_obj,
		memory_object_offset_t offset,
		memory_object_cluster_size_t size);
	void *__obsolete_memory_object_data_unlock;
	void *__obsolete_memory_object_synchronize;
	kern_return_t (*memory_object_map)(
		memory_object_t mem_obj,
		vm_prot_t prot);
	kern_return_t (*memory_object_last_unmap)(
		memory_object_t mem_obj);
	void *__obsolete_memory_object_data_reclaim;
	boolean_t (*memory_object_backing_object)(
		memory_object_t mem_obj,
		memory_object_offset_t mem_obj_offset,
		vm_object_t *backing_object,
		vm_object_offset_t *backing_offset);
	const char *memory_object_pager_name;
} * memory_object_pager_ops_t;
struct old_memory_object_behave_info {
	memory_object_copy_strategy_t   copy_strategy;
	boolean_t                       temporary;
	boolean_t                       invalidate;
};
struct old_memory_object_attr_info {                    
	boolean_t                       object_ready;
	boolean_t                       may_cache;
	memory_object_copy_strategy_t   copy_strategy;
};
struct memory_object_perf_info {
	memory_object_cluster_size_t    cluster_size;
	boolean_t                       may_cache;
};
struct memory_object_attr_info {
	memory_object_copy_strategy_t   copy_strategy;
	memory_object_cluster_size_t    cluster_size;
	boolean_t                       may_cache_object;
	boolean_t                       temporary;
};
struct memory_object_behave_info {
	memory_object_copy_strategy_t   copy_strategy;
	boolean_t                       temporary;
	boolean_t                       invalidate;
	boolean_t                       silent_overwrite;
	boolean_t                       advisory_pageout;
};
struct upl_page_info {
	ppnum_t         phys_addr;      
	unsigned int
	    free_when_done:1,    
	    absent:1,           
	    dirty:1,            
	    precious:1,         
	    device:1,           
	    speculative:1,      
	cs_validated:VMP_CS_BITS,     
	    cs_tainted:VMP_CS_BITS,   
	    cs_nx:VMP_CS_BITS,        

	    needed:1,           
	    mark:1,             
	reserved: 12,
	:0;                     
};
struct {
	natural_t                     pad1;
	mach_msg_size_t               pad2;
	unsigned int                  pad3 : 24;
	mach_msg_descriptor_type_t    type : 8;
} mach_msg_type_descriptor_t;
struct {
	union {
		mach_port_t __ipc_desc_sign("port") name;
		mach_port_t           kext_name;
		mach_port_t           u_name;
	};
	unsigned int                  pad2 : 16;
	mach_msg_type_name_t          disposition : 8;
	mach_msg_descriptor_type_t    type : 8;
	uint32_t                      pad_end;
} mach_msg_port_descriptor_t;
struct {
	mach_port_name_t              name;
	mach_msg_size_t               pad1;
	uint32_t                      pad2 : 16;
	mach_msg_type_name_t          disposition : 8;
	mach_msg_descriptor_type_t    type : 8;
} mach_msg_user_port_descriptor_t;
struct {
	uint32_t                      address;
	mach_msg_size_t               size;
	boolean_t                     deallocate: 8;
	mach_msg_copy_options_t       copy: 8;
	unsigned int                  pad1: 8;
	mach_msg_descriptor_type_t    type: 8;
} mach_msg_ool_descriptor32_t;
struct {
	uint64_t                      address;
	boolean_t                     deallocate: 8;
	mach_msg_copy_options_t       copy: 8;
	unsigned int                  pad1: 8;
	mach_msg_descriptor_type_t    type: 8;
	mach_msg_size_t               size;
} mach_msg_ool_descriptor64_t;
struct {
	union {
		void *__ipc_desc_sign("address") address;
		void                 *kext_address;
		user_addr_t           u_address;
	};
	boolean_t                     deallocate: 8;
	mach_msg_copy_options_t       copy: 8;
	unsigned int                  pad1: 8;
	mach_msg_descriptor_type_t    type: 8;
	mach_msg_size_t               size;
} mach_msg_ool_descriptor_t;
struct {
	uint32_t                      address;
	mach_msg_size_t               count;
	boolean_t                     deallocate: 8;
	mach_msg_copy_options_t       copy: 8;
	mach_msg_type_name_t          disposition : 8;
	mach_msg_descriptor_type_t    type : 8;
} mach_msg_ool_ports_descriptor32_t;
struct {
	uint64_t                      address;
	boolean_t                     deallocate: 8;
	mach_msg_copy_options_t       copy: 8;
	mach_msg_type_name_t          disposition : 8;
	mach_msg_descriptor_type_t    type : 8;
	mach_msg_size_t               count;
} mach_msg_ool_ports_descriptor64_t;
struct {
	union {
		void *__ipc_desc_sign("port_array") address;
		void                 *kext_address;
		user_addr_t           u_address;
	};
	boolean_t                     deallocate: 8;
	mach_msg_copy_options_t       copy: 8;
	mach_msg_type_name_t          disposition : 8;
	mach_msg_descriptor_type_t    type : 8;
	mach_msg_size_t               count;
} mach_msg_ool_ports_descriptor_t;
struct {
	uint32_t                      context;
	mach_port_name_t              name;
	mach_msg_guard_flags_t        flags : 16;
	mach_msg_type_name_t          disposition : 8;
	mach_msg_descriptor_type_t    type : 8;
} mach_msg_guarded_port_descriptor32_t;
struct {
	uint64_t                      context;
	mach_msg_guard_flags_t        flags : 16;
	mach_msg_type_name_t          disposition : 8;
	mach_msg_descriptor_type_t    type : 8;
	mach_port_name_t              name;
} mach_msg_guarded_port_descriptor64_t;
struct {
	union {
		mach_port_t __ipc_desc_sign("guarded_port") name;
		mach_port_t           kext_name;
		mach_port_context_t   u_context;
	};
	mach_msg_guard_flags_t        flags : 16;
	mach_msg_type_name_t          disposition : 8;
	mach_msg_descriptor_type_t    type : 8;
	union {
		uint32_t              pad_end;
		mach_port_name_t      u_name;
	};
} mach_msg_guarded_port_descriptor_t;
struct {
	mach_msg_size_t msgh_descriptor_count;
} mach_msg_body_t;
struct {
	mach_msg_bits_t               msgh_bits;
	mach_msg_size_t               msgh_size;
	mach_port_t                   msgh_remote_port;
	mach_port_t                   msgh_local_port;
	mach_port_name_t              msgh_voucher_port;
	mach_msg_id_t                 msgh_id;
} mach_msg_header_t;
struct {
	mach_vm_address_t               msgv_data;
	mach_vm_address_t               msgv_rcv_addr;
	mach_msg_size_t                 msgv_send_size;
	mach_msg_size_t                 msgv_rcv_size;
} mach_msg_vector_t;
struct {
	mach_msg_size_t                 msgdh_size;
	uint32_t                        msgdh_reserved; 
} mach_msg_aux_header_t;
struct {
	mach_msg_header_t             header;
	mach_msg_body_t               body;
} mach_msg_base_t;
struct {
	mach_msg_bits_t               msgh_bits;
	mach_msg_size_t               msgh_size;
	mach_port_name_t              msgh_remote_port;
	mach_port_name_t              msgh_local_port;
	mach_port_name_t              msgh_voucher_port;
	mach_msg_id_t                 msgh_id;
} mach_msg_user_header_t;
struct {
	mach_msg_user_header_t        header;
	mach_msg_body_t               body;
} mach_msg_user_base_t;
struct {
	mach_msg_header_t             msgb_header;
	mach_msg_size_t               msgb_dsc_count;
	mach_msg_kdescriptor_t        msgb_dsc_array[];
} mach_msg_kbase_t;
struct {
	mach_msg_trailer_type_t       msgh_trailer_type;
	mach_msg_trailer_size_t       msgh_trailer_size;
} mach_msg_trailer_t;
struct {
	mach_msg_trailer_type_t       msgh_trailer_type;
	mach_msg_trailer_size_t       msgh_trailer_size;
	mach_port_seqno_t             msgh_seqno;
} mach_msg_seqno_trailer_t;
struct {
	unsigned int                  val[2];
} security_token_t;
struct {
	mach_msg_trailer_type_t       msgh_trailer_type;
	mach_msg_trailer_size_t       msgh_trailer_size;
	mach_port_seqno_t             msgh_seqno;
	security_token_t              msgh_sender;
} mach_msg_security_trailer_t;
struct {
	unsigned int                  val[8];
} audit_token_t;
struct {
	mach_msg_trailer_type_t       msgh_trailer_type;
	mach_msg_trailer_size_t       msgh_trailer_size;
	mach_port_seqno_t             msgh_seqno;
	security_token_t              msgh_sender;
	audit_token_t                 msgh_audit;
} mach_msg_audit_trailer_t;
struct {
	mach_msg_trailer_type_t       msgh_trailer_type;
	mach_msg_trailer_size_t       msgh_trailer_size;
	mach_port_seqno_t             msgh_seqno;
	security_token_t              msgh_sender;
	audit_token_t                 msgh_audit;
	mach_port_context_t           msgh_context;
} mach_msg_context_trailer_t;
struct {
	mach_msg_trailer_type_t       msgh_trailer_type;
	mach_msg_trailer_size_t       msgh_trailer_size;
	mach_port_seqno_t             msgh_seqno;
	security_token_t              msgh_sender;
	audit_token_t                 msgh_audit;
	mach_port_context32_t         msgh_context;
} mach_msg_context_trailer32_t;
struct {
	mach_msg_trailer_type_t       msgh_trailer_type;
	mach_msg_trailer_size_t       msgh_trailer_size;
	mach_port_seqno_t             msgh_seqno;
	security_token_t              msgh_sender;
	audit_token_t                 msgh_audit;
	mach_port_context64_t         msgh_context;
} mach_msg_context_trailer64_t;
struct {
	mach_port_name_t sender;
} msg_labels_t;
struct {
	mach_msg_trailer_type_t       msgh_trailer_type;
	mach_msg_trailer_size_t       msgh_trailer_size;
	mach_port_seqno_t             msgh_seqno;
	security_token_t              msgh_sender;
	audit_token_t                 msgh_audit;
	mach_port_context_t           msgh_context;
	mach_msg_filter_id            msgh_ad;
	msg_labels_t                  msgh_labels;
} mach_msg_mac_trailer_t;
struct {
	mach_msg_trailer_type_t       msgh_trailer_type;
	mach_msg_trailer_size_t       msgh_trailer_size;
	mach_port_seqno_t             msgh_seqno;
	security_token_t              msgh_sender;
	audit_token_t                 msgh_audit;
	mach_port_context32_t         msgh_context;
	mach_msg_filter_id            msgh_ad;
	msg_labels_t                  msgh_labels;
} mach_msg_mac_trailer32_t;
struct {
	mach_msg_trailer_type_t       msgh_trailer_type;
	mach_msg_trailer_size_t       msgh_trailer_size;
	mach_port_seqno_t             msgh_seqno;
	security_token_t              msgh_sender;
	audit_token_t                 msgh_audit;
	mach_port_context64_t         msgh_context;
	mach_msg_filter_id            msgh_ad;
	msg_labels_t                  msgh_labels;
} mach_msg_mac_trailer64_t;
struct {
	mach_msg_header_t     header;
} mach_msg_empty_send_t;
struct {
	mach_msg_header_t     header;
	mach_msg_trailer_t    trailer;
} mach_msg_empty_rcv_t;
struct routine_descriptor {
	mig_impl_routine_t      impl_routine;   
	mig_stub_routine_t      stub_routine;   
	unsigned int            argc;                   
	unsigned int            descr_count;    
	routine_arg_descriptor_t
	    arg_descr;                                                  
	unsigned int            max_reply_msg;  
};
struct mig_subsystem {
	mig_server_routine_t server;            
	mach_msg_id_t            start;                 
	mach_msg_id_t            end;                   
	mach_msg_size_t          maxsize;               
	vm_address_t             reserved;              
	mig_routine_descriptor
	    routine[1];                                         
} *mig_subsystem_t;
struct kern_routine_descriptor {
	mig_impl_routine_t      impl_routine;      
	mig_stub_kern_routine_t kstub_routine;     
	unsigned int            argc;              
	unsigned int            descr_count;       
	unsigned int            reply_descr_count; 
	unsigned int            max_reply_msg;     
};
struct mig_kern_subsystem {
	mig_kern_server_routine_t     kserver;     
	mach_msg_id_t            start;            
	mach_msg_id_t            end;              
	mach_msg_size_t          maxsize;          
	vm_address_t             reserved;         
	mig_kern_routine_descriptor
	    kroutine[1];                           
} *mig_kern_subsystem_t;
struct mig_symtab {
	char                            *ms_routine_name;
	int                                     ms_routine_number;
	void                            (*ms_routine)(void);    
} mig_symtab_t;
struct {
	mach_msg_header_t       Head;
	NDR_record_t            NDR;
	kern_return_t           RetCode;
} mig_reply_error_t;
struct mk_timer_expire_msg {
	mach_msg_header_t       header;
	uint64_t                unused[3];
} mk_timer_expire_msg_t;
struct {
	unsigned char       mig_vers;
	unsigned char       if_vers;
	unsigned char       reserved1;
	unsigned char       mig_encoding;
	unsigned char       int_rep;
	unsigned char       char_rep;
	unsigned char       float_rep;
	unsigned char       reserved2;
} NDR_record_t;
struct {
	mach_msg_header_t   not_header;
	NDR_record_t        NDR;
	mach_port_name_t not_port;
	mach_msg_format_0_trailer_t trailer;
} mach_port_deleted_notification_t;
struct {
	mach_msg_header_t   not_header;
	NDR_record_t        NDR;
	mach_port_name_t not_port;
	mach_msg_format_0_trailer_t trailer;
} mach_send_possible_notification_t;
struct {
	mach_msg_header_t   not_header;
	mach_msg_body_t     not_body;
	mach_msg_port_descriptor_t not_port;
	mach_msg_format_0_trailer_t trailer;
} mach_port_destroyed_notification_t;
struct {
	mach_msg_header_t   not_header;
	NDR_record_t        NDR;
	mach_msg_type_number_t not_count;
	mach_msg_format_0_trailer_t trailer;
} mach_no_senders_notification_t;
struct {
	mach_msg_header_t   not_header;
	mach_msg_format_0_trailer_t trailer;
} mach_send_once_notification_t;
struct {
	mach_msg_header_t   not_header;
	NDR_record_t        NDR;
	mach_port_name_t not_port;
	mach_msg_format_0_trailer_t trailer;
} mach_dead_name_notification_t;
struct policy_timeshare_base {
	integer_t               base_priority;
};
struct policy_timeshare_limit {
	integer_t               max_priority;
};
struct policy_timeshare_info {
	integer_t               max_priority;
	integer_t               base_priority;
	integer_t               cur_priority;
	boolean_t               depressed;
	integer_t               depress_priority;
};
struct policy_rr_base {
	integer_t               base_priority;
	integer_t               quantum;
};
struct policy_rr_limit {
	integer_t               max_priority;
};
struct policy_rr_info {
	integer_t               max_priority;
	integer_t               base_priority;
	integer_t               quantum;
	boolean_t               depressed;
	integer_t               depress_priority;
};
struct policy_fifo_base {
	integer_t               base_priority;
};
struct policy_fifo_limit {
	integer_t               max_priority;
};
struct policy_fifo_info {
	integer_t               max_priority;
	integer_t               base_priority;
	boolean_t               depressed;
	integer_t               depress_priority;
};
struct policy_bases {
	policy_timeshare_base_data_t    ts;
	policy_rr_base_data_t           rr;
	policy_fifo_base_data_t         fifo;
};
struct policy_limits {
	policy_timeshare_limit_data_t   ts;
	policy_rr_limit_data_t          rr;
	policy_fifo_limit_data_t        fifo;
};
struct policy_infos {
	policy_timeshare_info_data_t    ts;
	policy_rr_info_data_t           rr;
	policy_fifo_info_data_t         fifo;
};
struct {
	mach_port_t __mach_port_array_auth port;
} mach_port_ool_t;
struct mach_port_status {
	mach_port_rights_t      mps_pset;       
	mach_port_seqno_t       mps_seqno;      
	mach_port_mscount_t     mps_mscount;    
	mach_port_msgcount_t    mps_qlimit;     
	mach_port_msgcount_t    mps_msgcount;   
	mach_port_rights_t      mps_sorights;   
	boolean_t               mps_srights;    
	boolean_t               mps_pdrequest;  
	boolean_t               mps_nsrequest;  
	natural_t               mps_flags;              
} mach_port_status_t;
struct mach_port_limits {
	mach_port_msgcount_t    mpl_qlimit;     
} mach_port_limits_t;
struct mach_port_info_ext {
	mach_port_status_t      mpie_status;
	mach_port_msgcount_t    mpie_boost_cnt;
	uint32_t                reserved[6];
} mach_port_info_ext_t;
struct mach_port_guard_info {
	uint64_t    mpgi_guard;     
} mach_port_guard_info_t;
struct mach_port_qos {
	unsigned int            name:1;         
	unsigned int            prealloc:1;     
	boolean_t               pad1:30;
	natural_t               len;
} mach_port_qos_t;
struct mach_service_port_info {
	char                    mspi_string_name[MACH_SERVICE_PORT_INFO_STRING_NAME_MAX_BUF_LEN]; 
	uint8_t                 mspi_domain_type;          
} mach_service_port_info_data_t;
struct mach_port_options {
	uint32_t                flags;          
	mach_port_limits_t      mpl;            
	union {
		uint64_t                   reserved[2];           
		mach_port_name_t           work_interval_port;    
		uint32_t                   service_port_info32;   
		uint64_t                   service_port_info64;   
		mach_port_name_t           service_port_name;     
	};
}mach_port_options_t;
struct processor_basic_info {
	cpu_type_t      cpu_type;       
	cpu_subtype_t   cpu_subtype;    
	boolean_t       running;        
	int             slot_num;       
	union {
		boolean_t       is_master;  
		boolean_t       is_main;    
	};
};
struct processor_cpu_load_info {             
	unsigned int    cpu_ticks[CPU_STATE_MAX]; 
};
struct processor_set_basic_info {
	int             processor_count;        
	int             default_policy;         
};
struct processor_set_load_info {
	int             task_count;             
	int             thread_count;           
	integer_t       load_average;           
	integer_t       mach_factor;            
};
struct rpc_routine_arg_descriptor {
	routine_arg_type        type;      
	routine_arg_size        size;      
	routine_arg_size        count;     
	routine_arg_offset      offset;    
};
struct rpc_routine_descriptor {
	mig_impl_routine_t      impl_routine;   
	mig_stub_routine_t      stub_routine;   
	unsigned int            argc;           
	unsigned int            descr_count;    
	                                        
	rpc_routine_arg_descriptor_t
	    arg_descr;                          
	                                        
	unsigned int            max_reply_msg;  
};
struct rpc_signature {
	struct rpc_routine_descriptor rd;
	struct rpc_routine_arg_descriptor rad[1];
};
struct rpc_subsystem {
	void            *reserved;      

	mach_msg_id_t   start;          
	mach_msg_id_t   end;            
	unsigned int    maxsize;        
	vm_address_t    base_addr;      

	struct rpc_routine_descriptor   
	    routine[1                   
	];

	struct rpc_routine_arg_descriptor
	    arg_descriptor[1               
	];                                 
};
struct shared_region_range_np {
	mach_vm_address_t       srr_address;
	mach_vm_size_t          srr_size;
};
struct shared_file_mapping_np {
	mach_vm_address_t       sfm_address;
	mach_vm_size_t          sfm_size;
	mach_vm_offset_t        sfm_file_offset;
	vm_prot_t               sfm_max_prot;
	vm_prot_t               sfm_init_prot;
};
struct shared_file_mapping_slide_np {
	mach_vm_address_t       sms_address __kernel_data_semantics;
	mach_vm_size_t          sms_size;
	mach_vm_offset_t        sms_file_offset __kernel_data_semantics;
	user_addr_t             sms_slide_size;
	user_addr_t             sms_slide_start;
	vm_prot_t               sms_max_prot;
	vm_prot_t               sms_init_prot;
} shared_file_mapping_slide_np_t;
struct {
	mach_vm_address_ut       sms_address_u;
	mach_vm_size_ut          sms_size_u;
	mach_vm_offset_ut        sms_file_offset_u;
	user_addr_ut             sms_slide_size_u;
	user_addr_ut             sms_slide_start_u;
	vm_prot_ut               sms_max_prot_u;
	vm_prot_ut               sms_init_prot_u;
});
struct shared_file_np {
	int                     sf_fd;             
	uint32_t                sf_mappings_count; 
	uint32_t                sf_slide;          
};
struct task_basic_info_32 {
	integer_t       suspend_count;  
	natural_t       virtual_size;   
	natural_t       resident_size;  
	time_value_t    user_time;      
	time_value_t    system_time;    
	policy_t        policy;         
};
struct task_basic_info_64 {
	integer_t       suspend_count;  
	natural_t       virtual_size;   
	natural_t       resident_size;  
	time_value_t    user_time;      
	time_value_t    system_time;    
	policy_t        policy;         
};
struct task_basic_info {
	integer_t       suspend_count;  
	vm_size_t       virtual_size;   
	vm_size_t       resident_size;  
	time_value_t    user_time;      
	time_value_t    system_time;    
	policy_t        policy;         
};
struct task_events_info {
	integer_t       faults;         
	integer_t       pageins;        
	integer_t       cow_faults;     
	integer_t       messages_sent;  
	integer_t       messages_received; 
	integer_t       syscalls_mach;  
	integer_t       syscalls_unix;  
	integer_t       csw;            
};
struct task_thread_times_info {
	time_value_t    user_time;      
	time_value_t    system_time;    
};
struct task_absolutetime_info {
	uint64_t                total_user;
	uint64_t                total_system;
	uint64_t                threads_user;   
	uint64_t                threads_system;
};
struct task_kernelmemory_info {
	uint64_t                total_palloc;   
	uint64_t                total_pfree;    
	uint64_t                total_salloc;   
	uint64_t                total_sfree;    
};
struct task_affinity_tag_info {
	integer_t               set_count;
	integer_t               min;
	integer_t               max;
	integer_t               task_count;
};
struct task_dyld_info {
	mach_vm_address_t       all_image_info_addr;
	mach_vm_size_t          all_image_info_size;
	integer_t               all_image_info_format;
};
struct task_basic_info_64_2 {
	integer_t       suspend_count;  
	mach_vm_size_t  virtual_size;   
	mach_vm_size_t  resident_size;  
	time_value_t    user_time;      
	time_value_t    system_time;    
	policy_t        policy;         
};
struct task_extmod_info {
	unsigned char   task_uuid[16];
	vm_extmod_statistics_data_t             extmod_statistics;
};
struct mach_task_basic_info {
	mach_vm_size_t  virtual_size;       
	mach_vm_size_t  resident_size;      
	mach_vm_size_t  resident_size_max;  
	time_value_t    user_time;          
	time_value_t    system_time;        
	policy_t        policy;             
	integer_t       suspend_count;      
};
struct task_power_info {
	uint64_t                total_user;
	uint64_t                total_system;
	uint64_t                task_interrupt_wakeups;
	uint64_t                task_platform_idle_wakeups;
	uint64_t                task_timer_wakeups_bin_1;
	uint64_t                task_timer_wakeups_bin_2;
};
struct task_vm_info {
	mach_vm_size_t  virtual_size;       
	integer_t       region_count;       
	integer_t       page_size;
	mach_vm_size_t  resident_size;      
	mach_vm_size_t  resident_size_peak; 

	mach_vm_size_t  device;
	mach_vm_size_t  device_peak;
	mach_vm_size_t  internal;
	mach_vm_size_t  internal_peak;
	mach_vm_size_t  external;
	mach_vm_size_t  external_peak;
	mach_vm_size_t  reusable;
	mach_vm_size_t  reusable_peak;
	mach_vm_size_t  purgeable_volatile_pmap;
	mach_vm_size_t  purgeable_volatile_resident;
	mach_vm_size_t  purgeable_volatile_virtual;
	mach_vm_size_t  compressed;
	mach_vm_size_t  compressed_peak;
	mach_vm_size_t  compressed_lifetime;

	mach_vm_size_t  phys_footprint;

	mach_vm_address_t       min_address;
	mach_vm_address_t       max_address;

	int64_t ledger_phys_footprint_peak;
	int64_t ledger_purgeable_nonvolatile;
	int64_t ledger_purgeable_novolatile_compressed;
	int64_t ledger_purgeable_volatile;
	int64_t ledger_purgeable_volatile_compressed;
	int64_t ledger_tag_network_nonvolatile;
	int64_t ledger_tag_network_nonvolatile_compressed;
	int64_t ledger_tag_network_volatile;
	int64_t ledger_tag_network_volatile_compressed;
	int64_t ledger_tag_media_footprint;
	int64_t ledger_tag_media_footprint_compressed;
	int64_t ledger_tag_media_nofootprint;
	int64_t ledger_tag_media_nofootprint_compressed;
	int64_t ledger_tag_graphics_footprint;
	int64_t ledger_tag_graphics_footprint_compressed;
	int64_t ledger_tag_graphics_nofootprint;
	int64_t ledger_tag_graphics_nofootprint_compressed;
	int64_t ledger_tag_neural_footprint;
	int64_t ledger_tag_neural_footprint_compressed;
	int64_t ledger_tag_neural_nofootprint;
	int64_t ledger_tag_neural_nofootprint_compressed;

	uint64_t limit_bytes_remaining;

	integer_t decompressions;

	int64_t ledger_swapins;

	int64_t ledger_tag_neural_nofootprint_total;
	int64_t ledger_tag_neural_nofootprint_peak;
};
struct task_trace_memory_info {
	uint64_t  user_memory_address;  
	uint64_t  buffer_size;                  
	uint64_t  mailbox_array_size;   
};
struct task_wait_state_info {
	uint64_t  total_wait_state_time;        
	uint64_t  total_wait_sfi_state_time;    
	uint32_t  _reserved[4];
};
struct {
	uint64_t                task_gpu_utilisation;
	uint64_t                task_gpu_stat_reserved0;
	uint64_t                task_gpu_stat_reserved1;
	uint64_t                task_gpu_stat_reserved2;
} gpu_energy_data;
struct task_power_info_v2 {
	task_power_info_data_t  cpu_energy;
	gpu_energy_data gpu_energy;
	uint64_t                task_energy;
	uint64_t                task_ptime;
	uint64_t                task_pset_switches;
};
struct pvm_account_info {
	uint64_t pvm_volatile_count; 
	uint64_t pvm_volatile_compressed_count; 
	uint64_t pvm_nonvolatile_count; 
	uint64_t pvm_nonvolatile_compressed_count; 
};
struct task_flags_info {
	uint32_t        flags;                          
};
struct task_debug_info_internal {
	integer_t suspend_count;
	uint64_t ipc_space_size;
};
struct task_suspend_stats_s {
	uint64_t tss_last_start; 
	uint64_t tss_last_end; 
	uint64_t tss_count; 
	uint64_t tss_duration; 
} *task_suspend_stats_t;
struct task_suspend_source_s {
	uint64_t tss_time; 
	uint64_t tss_tid; 
	int tss_pid; 
	char tss_procname[65]; 
	uint8_t tss_padding[3]; 
} *task_suspend_source_t;
struct task_inspect_basic_counts {
	uint64_t instructions;
	uint64_t cycles;
};
struct task_category_policy {
	task_role_t             role;
};
struct task_qos_policy {
	task_latency_qos_t task_latency_qos_tier;
	task_throughput_qos_t task_throughput_qos_tier;
};
struct task_requested_policy {
	uint64_t        trp_int_darwinbg        :1, 
	    trp_ext_darwinbg        :1,
	    trp_int_iotier          :2,             
	    trp_ext_iotier          :2,
	    trp_int_iopassive       :1,             
	    trp_ext_iopassive       :1,
	    trp_bg_iotier           :2,             
	    trp_terminated          :1,             
	    trp_base_latency_qos    :3,             
	    trp_base_through_qos    :3,             

	    trp_apptype             :3,             
	    trp_boosted             :1,             
	    trp_role                :5,             
	    trp_over_latency_qos    :3,             
	    trp_over_through_qos    :3,             
	    trp_sfi_managed         :1,             
	    trp_qos_clamp           :3,             

	    trp_sup_active          :1,             
	    trp_sup_lowpri_cpu      :1,             
	    trp_sup_timer           :3,             
	    trp_sup_disk            :1,             
	    trp_sup_throughput      :3,             
	    trp_sup_cpu             :1,             
	    trp_sup_bg_sockets      :1,             

	    trp_reserved            :17;
};
struct task_effective_policy {
	uint64_t        tep_darwinbg            :1, 
	    tep_lowpri_cpu          :1,             
	    tep_io_tier             :2,             
	    tep_io_passive          :1,             
	    tep_all_sockets_bg      :1,             
	    tep_new_sockets_bg      :1,             
	    tep_bg_iotier           :2,             
	    tep_terminated          :1,             
	    tep_qos_ui_is_urgent    :1,             
	    tep_latency_qos         :3,             
	    tep_through_qos         :3,             

	    tep_tal_engaged         :1,             
	    tep_watchers_bg         :1,             
	    tep_sup_active          :1,             
	    tep_role                :4,             
	    tep_suppressed_cpu      :1,             
	    tep_sfi_managed         :1,             
	    tep_live_donor          :1,             
	    tep_qos_clamp           :3,             
	    tep_qos_ceiling         :3,             
	    tep_adaptive_bg         :1,             
	    tep_coalition_bg        :1,             

	    tep_reserved            :29;
};
struct task_suppression_policy {
	integer_t active;
	integer_t lowpri_cpu; 
	integer_t timer_throttle;
	integer_t disk_throttle;
	integer_t cpu_limit;
	integer_t suspend;
	integer_t throughput_qos;
	integer_t suppressed_cpu; 
	integer_t background_sockets;
	integer_t reserved[7];
};
struct task_policy_state {
	uint64_t requested;
	uint64_t effective;
	uint64_t pending;
	uint32_t imp_assertcnt;
	uint32_t imp_externcnt;
	uint64_t flags;
	uint64_t imp_transitions;
	uint64_t tps_requested_policy;
	uint64_t tps_effective_policy;
};
struct thread_basic_info {
	time_value_t    user_time;      
	time_value_t    system_time;    
	integer_t       cpu_usage;      
	policy_t        policy;         
	integer_t       run_state;      
	integer_t       flags;          
	integer_t       suspend_count;  
	integer_t       sleep_time;     
};
struct thread_identifier_info {
	uint64_t        thread_id;      
	uint64_t        thread_handle;  
	uint64_t        dispatch_qaddr; 
};
struct thread_extended_info {           
	uint64_t                pth_user_time;          
	uint64_t                pth_system_time;        
	int32_t                 pth_cpu_usage;          
	int32_t                 pth_policy;                     
	int32_t                 pth_run_state;          
	int32_t                 pth_flags;              
	int32_t                 pth_sleep_time;         
	int32_t                 pth_curpri;                     
	int32_t                 pth_priority;           
	int32_t                 pth_maxpriority;        
	char                    pth_name[MAXTHREADNAMESIZE];    
};
struct thread_debug_info_internal {
	uint64_t page_creation_count;
};
struct io_stat_entry {
	uint64_t        count;
	uint64_t        size;
};
struct io_stat_info {
	struct io_stat_entry    disk_reads;
	struct io_stat_entry    io_priority[IO_NUM_PRIORITIES];
	struct io_stat_entry    paging;
	struct io_stat_entry    metadata;
	struct io_stat_entry    total_io;
};
struct thread_standard_policy {
	natural_t               no_data;
};
struct thread_extended_policy {
	boolean_t               timeshare;
};
struct thread_time_constraint_policy {
	uint32_t                period;
	uint32_t                computation;
	uint32_t                constraint;
	boolean_t               preemptible;
};
struct thread_precedence_policy {
	integer_t               importance;
};
struct thread_affinity_policy {
	integer_t       affinity_tag;
};
struct thread_background_policy {
	integer_t       priority;
};
struct thread_latency_qos_policy {
	thread_latency_qos_t thread_latency_qos_tier;
};
struct thread_throughput_qos_policy {
	thread_throughput_qos_t thread_throughput_qos_tier;
};
struct thread_policy_state {
	integer_t requested;
	integer_t effective;
	integer_t pending;
	integer_t flags;
	uint64_t thps_requested_policy;
	uint64_t thps_effective_policy;
	uint32_t thps_user_promotions;
	uint32_t thps_user_promotion_basepri;
	uint32_t thps_ipc_overrides;
	uint32_t reserved32;
	uint64_t reserved[2];
};
struct thread_qos_policy {
	integer_t qos_tier;
	integer_t tier_importance;
};
struct thread_time_constraint_with_priority_policy {
	uint32_t                period;
	uint32_t                computation;
	uint32_t                constraint;
	boolean_t               preemptible;
	uint32_t                priority;
};
struct thread_requested_qos_policy {
	integer_t  thrq_base_qos;
	integer_t  thrq_qos_relprio;
	integer_t  thrq_qos_override;
	integer_t  thrq_qos_promote;
	integer_t  thrq_qos_kevent_override;
	integer_t  thrq_qos_workq_override;
	integer_t  thrq_qos_wlsvc_override;
};
struct thread_requested_policy {
	uint64_t        thrp_int_darwinbg       :1,     
	    thrp_ext_darwinbg       :1,
	    thrp_int_iotier         :2,                 
	    thrp_ext_iotier         :2,
	    thrp_int_iopassive      :1,                 
	    thrp_ext_iopassive      :1,
	    thrp_latency_qos        :3,                 
	    thrp_through_qos        :3,                 

	    thrp_pidbind_bg         :1,                 
	    thrp_qos                :3,                 
	    thrp_qos_relprio        :4,                 
	    thrp_qos_override       :3,                 
	    thrp_qos_promote        :3,                 
	    thrp_qos_kevent_override:3,                 
	    thrp_terminated         :1,                 
	    thrp_qos_workq_override :3,                 
	    thrp_qos_wlsvc_override :3,                 
	    thrp_iotier_kevent_override :2,             
	    thrp_wi_driven          :1,                 

	    thrp_reserved           :23;
};
struct thread_effective_policy {
	uint64_t        thep_darwinbg           :1,     
	    thep_io_tier            :2,                 
	    thep_io_passive         :1,                 
	    thep_all_sockets_bg     :1,                 
	    thep_new_sockets_bg     :1,                 
	    thep_terminated         :1,                 
	    thep_qos_ui_is_urgent   :1,                 
	    thep_latency_qos        :3,                 
	    thep_through_qos        :3,                 

	    thep_qos                :3,                 
	    thep_qos_relprio        :4,                 
	    thep_qos_promote        :3,                 
	    thep_promote_above_task :1,                 
	    thep_wi_driven          :1,                 

	    thep_reserved           :38;
};
struct time_value {
	integer_t seconds;
	integer_t microseconds;
};
struct vm_packing_params {
	vm_offset_t vmpp_base;
	uint8_t     vmpp_bits;
	uint8_t     vmpp_shift;
	bool        vmpp_base_relative;
} vm_packing_params_t;
struct mach_vm_reclaim_indices_s {
	_Atomic mach_vm_reclaim_id_t head;
	_Atomic mach_vm_reclaim_id_t tail;
	_Atomic mach_vm_reclaim_id_t busy;
} *mach_vm_reclaim_indices_t;
struct mach_vm_reclaim_entry_s {
	mach_vm_address_t address;
	uint32_t size;
	mach_vm_reclaim_action_t behavior;
	uint8_t _unused[3];
} *mach_vm_reclaim_entry_t;
struct mach_vm_reclaim_ring_s {
	mach_vm_size_t va_in_buffer;
	mach_vm_size_t last_accounting_given_to_kernel;
	mach_vm_reclaim_count_t len;
	mach_vm_reclaim_count_t max_len;
	struct mach_vm_reclaim_indices_s indices;
	struct mach_vm_reclaim_entry_s entries[] __counted_by(len);
};
struct vm_region_basic_info_64 {
	vm_prot_t               protection;
	vm_prot_t               max_protection;
	vm_inherit_t            inheritance;
	boolean_t               shared;
	boolean_t               reserved;
	memory_object_offset_t  offset;
	vm_behavior_t           behavior;
	unsigned short          user_wired_count;
};
struct vm_region_basic_info {
	vm_prot_t               protection;
	vm_prot_t               max_protection;
	vm_inherit_t            inheritance;
	boolean_t               shared;
	boolean_t               reserved;
	uint32_t                offset; 
	vm_behavior_t           behavior;
	unsigned short          user_wired_count;
};
struct vm_region_extended_info__legacy {
	vm_prot_t               protection;
	unsigned int            user_tag;
	unsigned int            pages_resident;
	unsigned int            pages_shared_now_private;
	unsigned int            pages_swapped_out;
	unsigned int            pages_dirtied;
	unsigned int            ref_count;
	unsigned short          shadow_depth;
	unsigned char           external_pager;
	unsigned char           share_mode;
};
struct vm_region_extended_info {
	vm_prot_t               protection;
	unsigned int            user_tag;
	unsigned int            pages_resident;
	unsigned int            pages_shared_now_private;
	unsigned int            pages_swapped_out;
	unsigned int            pages_dirtied;
	unsigned int            ref_count;
	unsigned short          shadow_depth;
	unsigned char           external_pager;
	unsigned char           share_mode;
	unsigned int            pages_reusable;
};
struct vm_region_top_info {
	unsigned int            obj_id;
	unsigned int            ref_count;
	unsigned int            private_pages_resident;
	unsigned int            shared_pages_resident;
	unsigned char           share_mode;
};
struct vm_region_submap_info {
	vm_prot_t               protection;     
	vm_prot_t               max_protection; 
	vm_inherit_t            inheritance;
	uint32_t                offset;         
	unsigned int            user_tag;       
	unsigned int            pages_resident; 
	unsigned int            pages_shared_now_private; 
	unsigned int            pages_swapped_out; 
	unsigned int            pages_dirtied;   
	unsigned int            ref_count;       
	unsigned short          shadow_depth;   
	unsigned char           external_pager;  
	unsigned char           share_mode;     
	boolean_t               is_submap;      
	vm_behavior_t           behavior;       
	vm32_object_id_t        object_id;      
	unsigned short          user_wired_count;
};
struct vm_region_submap_info_64 {
	vm_prot_t               protection;     
	vm_prot_t               max_protection; 
	vm_inherit_t            inheritance;
	memory_object_offset_t  offset;         
	unsigned int            user_tag;       
	unsigned int            pages_resident; 
	unsigned int            pages_shared_now_private; 
	unsigned int            pages_swapped_out; 
	unsigned int            pages_dirtied;   
	unsigned int            ref_count;       
	unsigned short          shadow_depth;   
	unsigned char           external_pager;  
	unsigned char           share_mode;     
	boolean_t               is_submap;      
	vm_behavior_t           behavior;       
	vm32_object_id_t        object_id;      
	unsigned short          user_wired_count;
	unsigned int            pages_reusable;
	vm_object_id_t          object_id_full;
};
struct vm_region_submap_short_info_64 {
	vm_prot_t               protection;     
	vm_prot_t               max_protection; 
	vm_inherit_t            inheritance;
	memory_object_offset_t  offset;         
	unsigned int            user_tag;       
	unsigned int            ref_count;       
	unsigned short          shadow_depth;   
	unsigned char           external_pager;  
	unsigned char           share_mode;     
	boolean_t               is_submap;      
	vm_behavior_t           behavior;       
	vm32_object_id_t        object_id;      
	unsigned short          user_wired_count;
};
struct mach_vm_read_entry {
	mach_vm_address_t address;
	mach_vm_size_t size;
};
struct vm_read_entry {
	vm_address_t    address;
	vm_size_t       size;
};
struct vm_page_info_basic {
	int                     disposition;
	int                     ref_count;
	vm_object_id_t          object_id;
	memory_object_offset_t  offset;
	int                     depth;
	int                     __pad; 
};
struct vm_statistics {
	natural_t       free_count;             
	natural_t       active_count;           
	natural_t       inactive_count;         
	natural_t       wire_count;             
	natural_t       zero_fill_count;        
	natural_t       reactivations;          
	natural_t       pageins;                
	natural_t       pageouts;               
	natural_t       faults;                 
	natural_t       cow_faults;             
	natural_t       lookups;                
	natural_t       hits;                   

	natural_t       purgeable_count;        
	natural_t       purges;                 

	natural_t       speculative_count;      
};
struct vm_statistics64 {
	natural_t       free_count;             
	natural_t       active_count;           
	natural_t       inactive_count;         
	natural_t       wire_count;             
	uint64_t        zero_fill_count;        
	uint64_t        reactivations;          
	uint64_t        pageins;                
	uint64_t        pageouts;               
	uint64_t        faults;                 
	uint64_t        cow_faults;             
	uint64_t        lookups;                
	uint64_t        hits;                   
	uint64_t        purges;                 
	natural_t       purgeable_count;        
	natural_t       speculative_count;      

	uint64_t        decompressions;         
	uint64_t        compressions;           
	uint64_t        swapins;                
	uint64_t        swapouts;               
	natural_t       compressor_page_count;  
	natural_t       throttled_count;        
	natural_t       external_page_count;    
	natural_t       internal_page_count;    
	uint64_t        total_uncompressed_pages_in_compressor; 
} __attribute__((aligned(8)));
struct vm_extmod_statistics {
	int64_t task_for_pid_count;                     
	int64_t task_for_pid_caller_count;      
	int64_t thread_creation_count;          
	int64_t thread_creation_caller_count;   
	int64_t thread_set_state_count;         
	int64_t thread_set_state_caller_count;  
} __attribute__((aligned(8)));
struct vm_purgeable_stat {
	uint64_t        count;
	uint64_t        size;
}vm_purgeable_stat_t;
struct vm_purgeable_info {
	vm_purgeable_stat_t fifo_data[8];
	vm_purgeable_stat_t obsolete_data;
	vm_purgeable_stat_t lifo_data[8];
};
struct {
	unsigned int
	    vmnekf_ledger_tag:3,
	    vmnekf_ledger_no_footprint:1,
	__vmnekf_unused:28;
} vm_named_entry_kernel_flags_t;
struct mach_vm_range {
	mach_vm_offset_t        min_address;
	mach_vm_offset_t        max_address;
} *mach_vm_range_t;
struct {
	mach_vm_range_flags_t   flags: 48;
	mach_vm_range_tag_t     range_tag  : 8;
	uint8_t                 vm_tag : 8;
	struct mach_vm_range    range;
} mach_vm_range_recipe_v1_t;
struct {
	uint64_t rtfabstime; 
	uint64_t rtfduration; 
	uint64_t rtfaddr; 
	uint64_t rtfpc; 
	uint64_t rtftid; 
	uint64_t rtfupid; 
	uint64_t rtftype; 
} vm_rtfault_record_t;
struct vm_allocation_total {
	vm_tag_t tag;
	uint64_t total;
};
struct vm_allocation_zone_total {
	vm_size_t vazt_total;
	vm_size_t vazt_peak;
};
struct vm_allocation_site {
	uint64_t  total;
	uint64_t  mapped;
	int16_t   refcount;
	vm_tag_t  tag;
	uint16_t  flags;
	uint16_t  subtotalscount;
	struct vm_allocation_total subtotals[0];
};
struct {
	mach_vm_offset_ut min_address_u;
	mach_vm_offset_ut max_address_u;
});
struct {
	mach_vm_range_flags_t flags: 48;
	mach_vm_range_tag_t   range_tag: 8;
	uint8_t               vm_tag: 8;
	mach_vm_range_ut      range_u;
});
struct static_if_key {
	short                   sik_enable_count;
	short                   sik_init_value;
	unsigned                sik_entries_count;
	static_if_entry_t       sik_entries_head;
} *static_if_key_t;
struct static_if_key_true {
	struct static_if_key    key;
};
struct static_if_key_false {
	struct static_if_key    key;
};
struct hash_info_bucket {
	natural_t       hib_count;      
} hash_info_bucket_t;
struct ipc_info_space {
	natural_t iis_genno_mask;       
	natural_t iis_table_size;       
	natural_t iis_table_next;       
	natural_t iis_tree_size;        
	natural_t iis_tree_small;       
	natural_t iis_tree_hash;        
} ipc_info_space_t;
struct ipc_info_space_basic {
	natural_t iisb_genno_mask;      
	natural_t iisb_table_size;      
	natural_t iisb_table_next;      
	natural_t iisb_table_inuse;     
	natural_t iisb_reserved[2];     
} ipc_info_space_basic_t;
struct ipc_info_name {
	mach_port_name_t iin_name;              
 integer_t iin_collision;   
	mach_port_type_t iin_type;      
	mach_port_urefs_t iin_urefs;    
	natural_t iin_object;           
	natural_t iin_next;             
	natural_t iin_hash;             
} ipc_info_name_t;
struct ipc_info_tree_name {
	ipc_info_name_t iitn_name;
	mach_port_name_t iitn_lchild;   
	mach_port_name_t iitn_rchild;   
} ipc_info_tree_name_t;
struct ipc_info_port {
	natural_t iip_port_object;      
	natural_t iip_receiver_object;  
} ipc_info_port_t;
struct lockgroup_info {
	char            lockgroup_name[LOCKGROUP_MAX_NAME];
	uint64_t        lockgroup_attr;
	uint64_t        lock_spin_cnt;
	uint64_t        lock_spin_util_cnt;
	uint64_t        lock_spin_held_cnt;
	uint64_t        lock_spin_miss_cnt;
	uint64_t        lock_spin_held_max;
	uint64_t        lock_spin_held_cum;
	uint64_t        lock_mtx_cnt;
	uint64_t        lock_mtx_util_cnt;
	uint64_t        lock_mtx_held_cnt;
	uint64_t        lock_mtx_miss_cnt;
	uint64_t        lock_mtx_wait_cnt;
	uint64_t        lock_mtx_held_max;
	uint64_t        lock_mtx_held_cum;
	uint64_t        lock_mtx_wait_max;
	uint64_t        lock_mtx_wait_cum;
	uint64_t        lock_rw_cnt;
	uint64_t        lock_rw_util_cnt;
	uint64_t        lock_rw_held_cnt;
	uint64_t        lock_rw_miss_cnt;
	uint64_t        lock_rw_wait_cnt;
	uint64_t        lock_rw_held_max;
	uint64_t        lock_rw_held_cum;
	uint64_t        lock_rw_wait_max;
	uint64_t        lock_rw_wait_cum;
} lockgroup_info_t;
struct mach_core_details {
	uint64_t gzip_offset;
	uint64_t gzip_length;
	char core_name[MACH_CORE_FILEHEADER_NAMELEN];
};
struct mach_core_fileheader {
	uint64_t signature; 
	uint64_t log_offset;
	uint64_t log_length;
	uint64_t num_files;
	struct mach_core_details files[MACH_CORE_FILEHEADER_MAXFILES];
};
struct mach_core_details_v2 {
	uint64_t flags;  
	uint64_t offset;
	uint64_t length;
	char core_name[MACH_CORE_FILEHEADER_NAMELEN];
};
struct mach_core_fileheader_base {
	uint64_t signature; 
	uint32_t version;
};
struct mach_core_fileheader_v2 {
	uint64_t signature;       
	uint32_t version;         
	uint64_t flags;           
	uint64_t pub_key_offset;  
	uint16_t pub_key_length;  
	uint64_t log_offset;
	uint64_t log_length;
	uint64_t num_files;
	struct mach_core_details_v2 files[];
};
struct mach_vm_info_region {
	mach_vm_offset_t vir_start;     
	mach_vm_offset_t vir_end;       
	mach_vm_offset_t vir_object;    
	memory_object_offset_t vir_offset;      
	boolean_t vir_needs_copy;       
	vm_prot_t vir_protection;       
	vm_prot_t vir_max_protection;   
	vm_inherit_t vir_inheritance;   
	natural_t vir_wired_count;      
	natural_t vir_user_wired_count; 
} mach_vm_info_region_t;
struct vm_info_region_64 {
	natural_t vir_start;            
	natural_t vir_end;              
	natural_t vir_object;           
	memory_object_offset_t vir_offset;      
	boolean_t vir_needs_copy;       
	vm_prot_t vir_protection;       
	vm_prot_t vir_max_protection;   
	vm_inherit_t vir_inheritance;   
	natural_t vir_wired_count;      
	natural_t vir_user_wired_count; 
} vm_info_region_64_t;
struct vm_info_region {
	natural_t vir_start;            
	natural_t vir_end;              
	natural_t vir_object;           
	natural_t vir_offset;           
	boolean_t vir_needs_copy;       
	vm_prot_t vir_protection;       
	vm_prot_t vir_max_protection;   
	vm_inherit_t vir_inheritance;   
	natural_t vir_wired_count;      
	natural_t vir_user_wired_count; 
} vm_info_region_t;
struct vm_info_object {
	natural_t vio_object;           
	natural_t vio_size;             
	unsigned int vio_ref_count;     
	unsigned int vio_resident_page_count; 
	unsigned int vio_absent_count;  
	natural_t vio_copy;             
	natural_t vio_shadow;           
	natural_t vio_shadow_offset;    
	natural_t vio_paging_offset;    
	memory_object_copy_strategy_t vio_copy_strategy;
	vm_offset_t vio_last_alloc;     
	unsigned int vio_paging_in_progress;
	boolean_t vio_pager_created;
	boolean_t vio_pager_initialized;
	boolean_t vio_pager_ready;
	boolean_t vio_can_persist;
	boolean_t vio_internal;
	boolean_t vio_temporary;
	boolean_t vio_alive;
	boolean_t vio_purgable;
	boolean_t vio_purgable_volatile;
} vm_info_object_t;
struct zone_name {
	char            zn_name[ZONE_NAME_MAX_LEN];
} zone_name_t;
struct zone_info {
	integer_t       zi_count;       
	vm_size_t       zi_cur_size;    
	vm_size_t       zi_max_size;    
	vm_size_t       zi_elem_size;   
	vm_size_t       zi_alloc_size;  
	integer_t       zi_pageable;    
	integer_t       zi_sleepable;   
	integer_t       zi_exhaustible; 
	integer_t       zi_collectable; 
} zone_info_t;
struct mach_zone_name {
	char            mzn_name[ZONE_NAME_MAX_LEN];
} mach_zone_name_t;
struct mach_zone_info_data {
	uint64_t        mzi_count;      
	uint64_t        mzi_cur_size;   
	uint64_t        mzi_max_size;   
	uint64_t        mzi_elem_size;  
	uint64_t        mzi_alloc_size; 
	uint64_t        mzi_sum_size;   
	uint64_t        mzi_exhaustible;        
	uint64_t        mzi_collectable;        
} mach_zone_info_t;
struct task_zone_info_data {
	uint64_t        tzi_count;      
	uint64_t        tzi_cur_size;   
	uint64_t        tzi_max_size;   
	uint64_t        tzi_elem_size;  
	uint64_t        tzi_alloc_size; 
	uint64_t        tzi_sum_size;   
	uint64_t        tzi_exhaustible;        
	uint64_t        tzi_collectable;        
	uint64_t        tzi_caller_acct;        
	uint64_t        tzi_task_alloc; 
	uint64_t        tzi_task_free;  
} task_zone_info_t;
struct mach_memory_info {
	uint64_t flags;
	uint64_t site;
	uint64_t size;
	uint64_t free;
	uint64_t largest;
	uint64_t collectable_bytes;
	uint64_t mapped;
	uint64_t peak;
	uint16_t tag;
	uint16_t zone;
	uint16_t _resvA[2];
	uint64_t _resv[3];
	char     name[MACH_MEMORY_INFO_NAME_MAX_LEN];
} mach_memory_info_t;
struct zone_btrecord {
	uint32_t    ref_count;                                  
	uint32_t        operation_type;                         
	uint64_t        bt[MAX_ZTRACE_DEPTH];           
} zone_btrecord_t;
struct entropy_cpu_data {
	entropy_sample_t samples[ENTROPY_MAX_SAMPLE_COUNT];

	uint32_t _Atomic sample_count;
} entropy_cpu_data_t;
struct entropy_health_test {
	entropy_sample_t init_observation;

	uint64_t observation_count;

	entropy_health_stats_t *stats;
} entropy_health_test_t;
struct entropy_data {
	SHA512_CTX sha512_ctx;

	bitmap_t filter[ENTROPY_MAX_FILTER_COUNT];

	uint64_t total_sample_count;

	uint64_t startup_sample_count;

	uint64_t read_sample_count;

	lck_grp_t lock_group;

	lck_mtx_t mutex;

	entropy_health_test_t repetition_count_test;

	entropy_health_test_t adaptive_proportion_test;
} entropy_data_t;
struct entropy_health_stats {
	uint32_t reset_count;

	uint32_t failure_count;

	uint32_t max_observation_count;
} entropy_health_stats_t;
struct dsp {
	size_t info_size;
	size_t dst_size;
	void *info;
	void *dst;
} derived_seed_param;
struct {
	uint8_t drbg_state[EARLY_RANDOM_STATE_STATIC_SIZE];
	struct ccdrbg_info drbg_info;
	const struct ccdrbg_nisthmac_custom drbg_custom;
} erandom = {.drbg_custom = {
		     .di         = &ccsha256_ltc_di,
		     .strictFIPS = 0,
	     }};
struct bool_gen {
	unsigned int seed[RANDOM_BOOL_GEN_SEED_COUNT];
	unsigned int state;
	decl_simple_lock_data(, lock);
};
struct vnode_pager {
	struct memory_object vn_pgr_hdr;

	struct vnode            *vnode_handle;  
} *vnode_pager_t;
struct device_pager {
	struct memory_object dev_pgr_hdr;

	lck_mtx_t       lock;
	device_port_t   device_handle;  
	vm_size_t       size;
	int             flags;
	boolean_t       is_mapped;
} *device_pager_t;
struct { uint32_t offset; uint32_t word; } lz4_hash_entry_t;
struct {
	union {
		
		struct {
			upl_page_info_array_t upl_info;
			unsigned int upl_size;
		} upl;
		
		vm_page_t page_slist;
		
		void *pageq; 
	};
	unified_page_list_type_t type;
} unified_page_list_t;
struct {
	const unified_page_list_t *list;
	union {
		
		unsigned int upl_index;
		
		vm_page_t pageq_pos;
	};
} unified_page_list_iterator_t;
struct pfc {
	long    pfc_cpus;
	long    pfc_invalid_global;
};
struct apple_protect_pager {
	struct memory_object    ap_pgr_hdr;

	queue_chain_t           pager_queue;    
	bool                    is_ready;       
	bool                    is_mapped;      
	bool                    is_cached;      
	vm_object_t             backing_object; 
	vm_object_offset_t      backing_offset;
	vm_object_offset_t      crypto_backing_offset; 
	vm_object_offset_t      crypto_start;
	vm_object_offset_t      crypto_end;
	struct pager_crypt_info *crypt_info;
} *apple_protect_pager_t;
struct c_sv_hash_entry {
	union {
		struct  {
			uint32_t        c_sv_he_ref;
			uint32_t        c_sv_he_data;
		} c_sv_he;
		uint64_t        c_sv_he_record;
	} c_sv_he_un;
};
struct {
	uint64_t asked_permission;
	uint64_t compactions;
	uint64_t moved_slots;
	uint64_t moved_bytes;
	uint64_t wasted_space_in_swapouts;
	uint64_t count_of_swapouts;
	uint64_t count_of_freed_segs;
	uint64_t bailed_compactions;
	uint64_t bytes_freed_rate_us;
} c_seg_major_compact_stats[C_SEG_MAJOR_COMPACT_STATS_MAX];
struct {
	uint16_t lz4_selection_run;
	uint16_t lz4_run_length;
	uint16_t lz4_preselects;
	uint32_t lz4_total_preselects;
	uint16_t lz4_failure_skips;
	uint32_t lz4_total_failure_skips;
	uint16_t lz4_failure_run_length;
	uint16_t lz4_total_unprofitables;
	uint32_t lz4_total_negatives;
	uint32_t lz4_total_failures;
} compressor_state_t;
struct {
	uint64_t lz4_compressions;
	uint64_t lz4_compression_failures;
	uint64_t lz4_compressed_bytes;
	uint64_t lz4_wk_compression_delta;
	uint64_t lz4_wk_compression_negative_delta;
	uint64_t lz4_post_wk_compressions;

	uint64_t wk_compressions;
	uint64_t wk_cabstime;
	uint64_t wk_sv_compressions;
	uint64_t wk_mzv_compressions;
	uint64_t wk_compression_failures;
	uint64_t wk_compressed_bytes_total;
	uint64_t wk_compressions_exclusive;
	uint64_t wk_compressed_bytes_exclusive;

	uint64_t wkh_compressions;
	uint64_t wkh_cabstime;
	uint64_t wks_compressions;
	uint64_t wks_cabstime;
	uint64_t wks_compressed_bytes;
	uint64_t wks_compression_failures;
	uint64_t wks_sv_compressions;

	uint64_t lz4_decompressions;
	uint64_t lz4_decompressed_bytes;
	uint64_t uc_decompressions;

	uint64_t wk_decompressions;
	uint64_t wk_dabstime;

	uint64_t wkh_decompressions;
	uint64_t wkh_dabstime;

	uint64_t wks_decompressions;
	uint64_t wks_dabstime;

	uint64_t wk_decompressed_bytes;
	uint64_t wk_sv_decompressions;
} compressor_stats_t;
struct {
	uint32_t lz4_selection_max;
	int32_t wkdm_reeval_threshold;
	int32_t lz4_threshold;
	uint32_t lz4_max_failure_skips;
	uint32_t lz4_max_failure_run_length;
	uint32_t lz4_max_preselects;
	uint32_t lz4_run_preselection_threshold;
	uint32_t lz4_run_continue_bytes;
	uint32_t lz4_profitable_bytes;
} compressor_tuneables_t;
struct swapfile {
	queue_head_t            swp_queue;      
	char                    *swp_path;      
	struct vnode            *swp_vp;        
	uint64_t                swp_size;       
	uint8_t                 *swp_bitmap;    
	unsigned int            swp_pathlen;    
	unsigned int            swp_nsegs;      
	unsigned int            swp_nseginuse;  
	unsigned int            swp_index;      
	unsigned int            swp_flags;      
	unsigned int            swp_free_hint;  
	unsigned int            swp_io_count;   
	c_segment_t             *swp_csegs;     

	struct trim_list        *swp_delayed_trim_list_head;
	unsigned int            swp_delayed_trim_count;
};
struct swapout_io_completion {
	int          swp_io_busy;
	int          swp_io_done;
	int          swp_io_error;

	uint32_t     swp_c_size;
	c_segment_t  swp_c_seg;

	struct swapfile *swp_swf;
	uint64_t        swp_f_offset;

	struct upl_io_completion swp_upl_ctx;
};
struct c_slot_info {
	uint16_t       csi_size;
	uint16_t       csi_unused;
} __attribute__((packed));
struct c_segment_info {
	uint32_t       csi_mysegno;
	uint32_t       csi_creation_ts;
	uint32_t       csi_swappedin_ts;
	int32_t        csi_bytes_unused;
	int32_t        csi_bytes_used;
	uint32_t       csi_populated_offset;

	uint32_t       csi_state: 4,
	    csi_swappedin: 1,
	    csi_on_minor_compact_q: 1,
	    csi_has_donated_pages: 1,
	    csi_reserved: 25;
	int            csi_slot_var_array_len;
	uint32_t       csi_decompressions_since_swapin;
	uint16_t       csi_slots_used;
	uint16_t       csi_slots_len;  
	struct c_slot_info  csi_slots[0];
} __attribute__((packed));
struct vm_map_info_hdr {
	int vmi_nentries;
} __attribute__((packed));
struct vm_map_entry_info {
	vm_map_offset_t         vmei_start;          
	vm_map_offset_t         vmei_end;            
	unsigned long long
	 vmei_alias:12,   
	 vmei_offset:(64 - 12); 
	uint32_t vmei_is_sub_map: 1,
	    vmei_is_compressor_pager: 1,
	    vmei_protection: 3;
	uint32_t vmei_slot_mapping_count;
	int slot_mappings[0];
} __attribute__((packed));
struct {
	uint64_t        data_returns;
	uint64_t        data_requests;
	uint64_t        put;
	uint64_t        get;
	uint64_t        state_clr;
	uint64_t        state_get;
	uint64_t        transfer;
} compressor_pager_stats;
struct compressor_pager {
	struct memory_object cpgr_hdr;

	lck_mtx_t                       cpgr_lock;
	unsigned int                    cpgr_num_slots;
	unsigned int                    cpgr_num_slots_occupied;
	union {
		compressor_slot_t       cpgr_eslots[2]; 
		compressor_slot_t       *cpgr_dslots;   
		compressor_slot_t       **cpgr_islots;  
	} cpgr_slots;
} *compressor_pager_t;
struct c_slot {
	uint64_t        c_offset:C_SEG_OFFSET_BITS __kernel_ptr_semantics;
	uint64_t        c_size:C_SLOT_C_SIZE_BITS;
	uint64_t        c_packed_ptr:C_SLOT_PACKED_PTR_BITS __kernel_ptr_semantics; 

	unsigned int    c_hash_data;
	unsigned int    c_hash_compressed_data;
} __attribute__((packed, aligned(4)));
struct c_segment {
	lck_mtx_t       c_lock;
	queue_chain_t   c_age_list;  
	queue_chain_t   c_list;      

	queue_chain_t   c_task_list_next_cseg;
	task_t          c_task_owner;

	uint32_t        c_mysegno;  

	uint32_t        c_creation_ts;  
	uint64_t        c_generation_id;  

	int32_t         c_bytes_used;
	int32_t         c_bytes_unused;
	uint32_t        c_slots_used;

	uint16_t        c_firstemptyslot;  
	uint16_t        c_nextslot;        
	uint32_t        c_nextoffset;      
	uint32_t        c_populated_offset; 

	union {
		int32_t *c_buffer;
		uint64_t c_swap_handle;  
	} c_store;

	uint32_t        c_was_minor_compacted;
	uint32_t        c_was_major_compacted;
	uint32_t        c_was_major_donor;
	unsigned int    cseg_hash;
	unsigned int    cseg_swap_size;

	thread_t        c_busy_for_thread;
	uint32_t        c_agedin_ts;  
	uint32_t        c_swappedin_ts;
	bool            c_swappedin;
	uint32_t        c_decompressions_since_swapin;
	uint32_t        c_busy:1,
	    c_busy_swapping:1,
	    c_wanted:1,
	    c_on_minorcompact_q:1,              

	    c_state:4,                          
	    c_overage_swap:1,
	    c_has_donated_pages:1,
	    c_has_freezer_pages:1,
	    c_reserved:21;

	int             c_slot_var_array_len;  
	struct  c_slot  *c_slot_var_array;     
	struct  c_slot  c_slot_fixed_array[0];
};
struct  c_slot_mapping {
};
struct vm_compressor_kdp_state {
	char           *kc_scratch_bufs;
	char           *kc_decompressed_pages;
	addr64_t       *kc_decompressed_pages_paddr;
	ppnum_t        *kc_decompressed_pages_ppnum;
	char           *kc_panic_scratch_buf;
	char           *kc_panic_decompressed_page;
	addr64_t        kc_panic_decompressed_page_paddr;
	ppnum_t         kc_panic_decompressed_page_ppnum;
};
struct dyld_pager {
	struct memory_object    dyld_header;          

	queue_chain_t           dyld_pager_queue;    
	bool                    dyld_is_mapped;      
	bool                    dyld_is_ready;       
	vm_object_t             dyld_backing_object; 
	void                    *dyld_link_info;
	uint32_t                dyld_link_info_size;
	uint32_t                dyld_num_range;
	memory_object_offset_t  dyld_file_offset[MWL_MAX_REGION_COUNT];
	mach_vm_address_t       dyld_address[MWL_MAX_REGION_COUNT];
	mach_vm_size_t          dyld_size[MWL_MAX_REGION_COUNT];
};
struct vmrtfr {
	int vmrtfr_maxi;
	int vmrtfr_curi;
	int64_t vmrtf_total;
	vm_rtfault_record_t *vm_rtf_records;
} vmrtfrs;
struct kmem_page_meta {
	union {
		
		uint32_t km_bitmap;
		
		uint32_t km_free_chunks;
	};
	uint8_t  km_page_marker;
	uint8_t  km_sizeclass;
	union {
		
		uint16_t km_chunk_len;
		
		uint16_t km_page_idx;
	};
	LIST_ENTRY(kmem_page_meta) km_link;
} kmem_page_meta_t;
struct kmem_sizeclass {
	vm_map_size_t                   ks_size;
	uint32_t                        ks_num_chunk;
	uint32_t                        ks_num_elem;
	crypto_random_ctx_t __zpercpu   ks_rng_ctx;
	kmem_list_head_t                ks_allfree_head[KMEM_FRONTS];
	kmem_list_head_t                ks_partial_head[KMEM_FRONTS];
	kmem_list_head_t                ks_full_head[KMEM_FRONTS];
};
struct {
	kern_return_t           kmr_return;
	union {
		vm_address_t    kmr_address;
		vm_size_t       kmr_size;
		void           *kmr_ptr;
		vm_map_t        kmr_submap;
	};
} kmem_return_t;
struct {
	uint16_t                kmg_tag;
	uint16_t                kmg_type_hash;
	uint32_t                kmg_atomic : 1;
	uint32_t                kmg_submap : 1;
	uint32_t                kmg_context : 30;
} kmem_guard_t;
struct kmem_range_startup_spec {
	const char             *kc_name;
	struct mach_vm_range   *kc_range;
	vm_map_size_t           kc_size;
	vm_map_size_t           (^kc_calculate_sz)(void);
	kmem_claims_flags_t     kc_flags;
};
struct vm_map_zap {
	vm_map_entry_t          vmz_head;
	vm_map_entry_t         *vmz_tail;
} *vm_map_zap_t;
struct submap_map {
	vm_map_t        parent_map;
	vm_map_offset_t base_start;
	vm_map_offset_t base_end;
	vm_map_size_t   base_len;
	struct submap_map *next;
} submap_map_t;
struct vm_map_corpse_footprint_header {
	vm_size_t       cf_size;        
	uint32_t        cf_last_region; 
	union {
		uint32_t cfu_last_zeroes; 
		uint32_t cfu_hint_region; 
	} cfu;
};
struct vm_map_corpse_footprint_region {
	vm_map_offset_t cfr_vaddr;      
	uint32_t        cfr_num_pages;  
	cf_disp_t   cfr_disposition[0]; 
} __attribute__((packed));
struct vm_map_store {
	RB_ENTRY(vm_map_store) entry;
};
struct vm_map_links {
	struct vm_map_entry     *prev;          
	struct vm_map_entry     *next;          
	vm_map_offset_t         start;          
	vm_map_offset_t         end;            
};
struct vm_map_header {
	struct vm_map_links     links;          
	int                     nentries;       
	uint16_t                page_shift;     
	uint16_t                entries_pageable : 1;   
	uint16_t                __padding : 15;
	struct rb_head          rb_head_store;
};
struct vm_named_entry {
	decl_lck_mtx_data(, Lock);              
	union {
		vm_map_t        map;            
		vm_map_copy_t   copy;           
	} backing;
	vm_object_offset_t      offset;         
	vm_object_size_t        size;           
	vm_object_offset_t      data_offset;    
	unsigned int                            
	 access:8,               
	 protection:4,           
	 is_object:1,            
	 internal:1,             
	 is_sub_map:1,           
	 is_copy:1,              
	 is_fully_owned:1;       
};
struct vm_map_entry {
	struct vm_map_links     links;                      

	struct vm_map_store     store;

	union {
		vm_offset_t     vme_object_value;
		struct {
			vm_offset_t vme_atomic:1;           
			vm_offset_t is_sub_map:1;           
			vm_offset_t vme_submap:VME_SUBMAP_BITS;
		};
		struct {
			uint32_t    vme_ctx_atomic : 1;
			uint32_t    vme_ctx_is_sub_map : 1;
			uint32_t    vme_context : 30;

			
			union {
				vm_page_object_t vme_object_or_delta;
				btref_t vme_tag_btref;
			};
		};
	};

	unsigned long long
	 vme_alias:VME_ALIAS_BITS,   
	 vme_offset:VME_OFFSET_BITS, 

	 is_shared:1,                
	__unused1:1,
	in_transition:1,             
	 needs_wakeup:1,             
	 behavior:2,                 
	 needs_copy:1,               


	 max_protection:4,           
	 inheritance:2,              

	 use_pmap:1,
	 no_cache:1,                 
	 vme_permanent:1,            
	 superpage_size:1,           
	 map_aligned:1,              
	 zero_wired_pages:1,
	 used_for_jit:1,
	 csm_associated:1,       

	 iokit_acct:1,
	 vme_resilient_codesign:1,
	 vme_resilient_media:1,
	 vme_xnu_user_debug:1,
	 vme_no_copy_on_read:1,
	 translated_allow_execute:1, 
	 vme_kernel_object:1;        

	unsigned short          wired_count;                
	unsigned short          user_wired_count;           

};
struct vm_map_user_range {
	vm_map_address_t        vmur_min_address __kernel_data_semantics;

	vm_map_address_t        vmur_max_address : 56 __kernel_data_semantics;
	vm_map_range_id_t       vmur_range_id : 8;
} *vm_map_user_range_t;
struct _vm_map {
	lck_rw_t                lock;           
	struct vm_map_header    hdr;            
	pmap_t                  XNU_PTRAUTH_SIGNED_PTR("_vm_map.pmap") pmap;           
	vm_map_size_t           size;           
	uint64_t                size_limit;     
	uint64_t                data_limit;     
	vm_map_size_t           user_wire_limit;
	vm_map_size_t           user_wire_size; 

	os_ref_atomic_t         map_refcnt;       


	union {
		
		vm_map_offset_t         vmu1_highest_entry_end;
		
		vm_map_offset_t         vmu1_lowest_unnestable_start;
	} vmu1;
	vm_map_entry_t          hint;           
	union {
		struct vm_map_links* vmmap_hole_hint;   
		struct vm_map_corpse_footprint_header *vmmap_corpse_footprint;
	} vmmap_u_1;
	union {
		vm_map_entry_t          _first_free;    
		struct vm_map_links*    _holes;         
	} f_s;                                      


	unsigned int
	 wait_for_space:1,         
	 wiring_required:1,        
	 no_zero_fill:1,           
	 mapped_in_other_pmaps:1,  
	 switch_protect:1,         
	 disable_vmentry_reuse:1,  
	 map_disallow_data_exec:1, 
	 holelistenabled:1,
	 is_nested_map:1,
	 map_disallow_new_exec:1,  
	 jit_entry_exists:1,
	 has_corpse_footprint:1,
	 terminated:1,
	 is_alien:1,               
	 cs_enforcement:1,         
	 cs_debugged:1,            
	 reserved_regions:1,       
	 single_jit:1,             
	 never_faults:1,           
	 uses_user_ranges:1,       
	 tpro_enforcement:1,       
	 corpse_source:1,          
	 res0:1,
	pad:9;
	unsigned int            timestamp;          
	task_t owning_task;
};
struct vm_map_version {
	unsigned int    main_timestamp;
} vm_map_version_t;
struct vm_map_copy {
	uint16_t                type;
	bool                    is_kernel_range;
	bool                    is_user_range;
	vm_map_range_id_t       orig_range;
	vm_object_offset_t      offset;
	vm_map_size_t           size;
	union {
		struct vm_map_header                  hdr;    
		void *XNU_PTRAUTH_SIGNED_PTR("vm_map_copy.kdata") kdata;  
	} c_u;
};
struct vm_reserved_region {
	const char             *vmrr_name;
	vm_map_offset_t         vmrr_addr;
	vm_map_size_t           vmrr_size;
};
struct {
	vm_map_t map;
	task_t task;
} vm_map_switch_context_t;
struct vm_object_fault_info {
	int             interruptible;
	uint32_t        user_tag;
	vm_size_t       cluster_size;
	vm_behavior_t   behavior;
	vm_object_offset_t lo_offset;
	vm_object_offset_t hi_offset;
	unsigned int
	 no_cache:1,
	 stealth:1,
	 io_sync:1,
	 cs_bypass:1,
	 csm_associated:1,
	 mark_zf_absent:1,
	 batch_pmap_op:1,
	 resilient_media:1,
	 no_copy_on_read:1,
	 fi_xnu_user_debug:1,
	 fi_used_for_tpro:1,
	 fi_change_wiring:1,
	 fi_no_sleep:1,
	__vm_object_fault_info_unused_bits:19;
	int             pmap_options;
};
struct vm_object {
	vm_page_queue_head_t    memq;           
	lck_rw_t                Lock;           

	union {
		vm_object_size_t  vou_size;     
		int               vou_cache_pages_to_scan;      
	} vo_un1;

	struct vm_page          *memq_hint;
	os_ref_atomic_t         ref_count;        
	unsigned int            resident_page_count;
	unsigned int            wired_page_count; 
	unsigned int            reusable_page_count;

	struct vm_object        *vo_copy;       
	uint32_t                vo_copy_version;
	uint32_t                vo_inherit_copy_none:1,
	    __vo_unused_padding:31;
	struct vm_object        *shadow;        
	memory_object_t         pager;          

	union {
		vm_object_offset_t vou_shadow_offset;   
		clock_sec_t     vou_cache_ts;   
		task_t          vou_owner;      
	} vo_un2;

	vm_object_offset_t      paging_offset;  
	memory_object_control_t pager_control;  

	memory_object_copy_strategy_t
	    copy_strategy;                      

	uint16_t                paging_in_progress;
	uint16_t                vo_size_delta;
	uint32_t                activity_in_progress;


	unsigned int
	 all_wanted:7,     
	 pager_created:1,        
	 pager_initialized:1,    
	 pager_ready:1,          

	 pager_trusted:1,        
	 can_persist:1,          
	 internal:1,             
	 private:1,              
	 pageout:1,              
	 alive:1,                

	 purgable:2,             
	 purgeable_only_by_kernel:1,
	 purgeable_when_ripe:1,         
	 shadowed:1,             
	 true_share:1,
	 terminating:1,
	 named:1,                
	 shadow_severed:1,
	 phys_contiguous:1,
	 nophyscache:1,
	 for_realtime:1,
	 no_pager_reason:3,

	queue_chain_t           cached_list;    
	vm_object_offset_t      last_alloc;     
	vm_offset_t             cow_hint;       
	                                        
	int                     sequential;     

	uint32_t                pages_created;
	uint32_t                pages_used;
	unsigned        int
	    wimg_bits:8,                
	    code_signed:1,              
	    transposed:1,               
	    mapping_in_progress:1,      
	    phantom_isssd:1,
	    volatile_empty:1,
	    volatile_fault:1,
	    all_reusable:1,
	    blocked_access:1,
	    set_cache_attr:1,
	    object_is_shared_cache:1,
	    purgeable_queue_type:2,
	    purgeable_queue_group:3,
	    io_tracking:1,
	    no_tag_update:1,            
	vo_ledger_tag:3,
	    vo_no_footprint:1;


	uint8_t                 scan_collisions;
	uint8_t                 __object4_unused_bits[1];
	vm_tag_t                wire_tag;



	queue_chain_t           objq;      
	queue_chain_t           task_objq; 


};
struct vm_page_packed_queue_entry {
	vm_page_packed_t        next;          
	vm_page_packed_t        prev;          
};
struct vm_page {
	union {
		vm_page_queue_chain_t vmp_q_pageq;           
		struct vm_page        *vmp_q_snext;
	} vmp_q_un;

	vm_page_queue_chain_t         vmp_listq;           

	vm_page_queue_chain_t         vmp_specialq;     
	vm_object_offset_t            vmp_offset;          

	vm_page_object_t              vmp_object;          

	unsigned int vmp_wire_count:16,      
	    vmp_q_state:4,                   
	    vmp_on_specialq:2,
	    vmp_canonical:1,                 
	    vmp_gobbled:1,                   
	    vmp_laundry:1,                   
	    vmp_no_cache:1,                  
	                                     
	    vmp_reference:1,                 
	    vmp_lopage:1,
	    vmp_realtime:1,                  

	vm_page_packed_t vmp_next_m;            

	unsigned int    vmp_busy:1,           
	    vmp_wanted:1,                     
	    vmp_tabled:1,                     
	    vmp_hashed:1,                     
	__vmp_unused : 1,
	vmp_clustered:1,                      
	    vmp_pmapped:1,                    
	                                      
	    vmp_xpmapped:1,                   
	                                      
	    vmp_wpmapped:1,                   
	    vmp_free_when_done:1,             
	    vmp_absent:1,                     
	    vmp_error:1,                      
	    vmp_dirty:1,                      
	    vmp_cleaning:1,                   
	    vmp_precious:1,                   
	    vmp_overwriting:1,                
	                                      
	    vmp_restart:1,                    
	                                      
	    vmp_unusual:1,                    
	    vmp_cs_validated:VMP_CS_BITS,     
	    vmp_cs_tainted:VMP_CS_BITS,       
	    vmp_cs_nx:VMP_CS_BITS,            
	    vmp_reusable:1,
	    vmp_written_by_kernel:1;          

};
struct vm_speculative_age_q {
	vm_page_queue_head_t    age_q;
	mach_timespec_t age_ts;
} VM_PAGE_PACKED_ALIGNED;
struct vm_locks_array {
	char    pad  __attribute__ ((aligned(64)));
	lck_mtx_t       vm_page_queue_lock2 __attribute__ ((aligned(64)));
	lck_mtx_t       vm_page_queue_free_lock2 __attribute__ ((aligned(64)));
	char    pad2  __attribute__ ((aligned(64)));
} vm_locks_array_t;
struct vpl {
	vm_page_queue_head_t    vpl_queue;
	unsigned int    vpl_count;
	unsigned int    vpl_internal_count;
	unsigned int    vpl_external_count;
	lck_spin_t      vpl_lock;
};
struct freezer_context {

	task_t  freezer_ctx_task; 

	void    *freezer_ctx_chead; 
	                            

	uint64_t        freezer_ctx_swapped_bytes; 

	int     freezer_ctx_uncompressed_pages; 

	char    *freezer_ctx_compressor_scratch_buf; 
};
struct vm_page_stats_reusable {
	SInt32          reusable_count;
	uint64_t        reusable;
	uint64_t        reused;
	uint64_t        reused_wire;
	uint64_t        reused_remove;
	uint64_t        all_reusable_calls;
	uint64_t        partial_reusable_calls;
	uint64_t        all_reuse_calls;
	uint64_t        partial_reuse_calls;
	uint64_t        reusable_pages_success;
	uint64_t        reusable_pages_failure;
	uint64_t        reusable_pages_shared;
	uint64_t        reuse_pages_success;
	uint64_t        reuse_pages_failure;
	uint64_t        can_reuse_success;
	uint64_t        can_reuse_failure;
	uint64_t        reusable_reclaimed;
	uint64_t        reusable_nonwritable;
	uint64_t        reusable_shared;
	uint64_t        free_shared;
};
struct  vm_config {
	boolean_t       compressor_is_present;          
	boolean_t       compressor_is_active;           
	boolean_t       swap_is_present;                
	boolean_t       swap_is_active;                 
	boolean_t       freezer_swap_is_active;         
};
struct vm_pageout_queue {
	vm_page_queue_head_t pgo_pending;  
	unsigned int    pgo_laundry;       
	unsigned int    pgo_maxlaundry;

	uint32_t
	    pgo_busy:1,        
	    pgo_throttled:1,   
	    pgo_lowpriority:1, 
	    pgo_draining:1,
	    pgo_inited:1,
	    pgo_unused_bits:26;
};
struct _vector_upl_iostates {
	upl_offset_t offset;
	upl_size_t   size;
};
struct _vector_upl {
	upl_size_t              size;
	uint32_t                num_upls;
	uint32_t                invalid_upls;
	uint32_t                max_upls;
	vm_map_t                submap;
	vm_offset_t             submap_dst_addr;
	vm_object_offset_t      offset;
	upl_page_info_array_t   pagelist;
	struct {
		upl_t                   elem;
		vector_upl_iostates_t   iostate;
	} upls[];
};
struct upl_io_completion {
	void     *io_context;
	void     (*io_done)(void *, int);

	int      io_error;
};
struct upl {
	decl_lck_mtx_data(, Lock);      
	int             ref_count;
	int             ext_ref_count;
	int             flags;
	ctid_t          map_addr_owner; 
	vm_object_offset_t u_offset;
	upl_size_t      u_size;       
	upl_size_t      u_mapped_size;       
	vm_offset_t     kaddr;      
	vm_object_t     map_object;
	vector_upl_t    vector_upl;
	upl_t           associated_upl;
	struct upl_io_completion *upl_iodone;
	ppnum_t         highest_page;

	bitmap_t       *lite_list;
	struct upl_page_info page_list[];
};
struct vm_pageout_state {
	boolean_t vm_pressure_thread_running;
	boolean_t vm_pressure_changed;
	boolean_t vm_restricted_to_single_processor;
	int vm_compressor_thread_count;

	unsigned int vm_page_speculative_q_age_ms;
	unsigned int vm_page_speculative_percentage;
	unsigned int vm_page_speculative_target;

	unsigned int vm_pageout_swap_wait;
	unsigned int vm_pageout_idle_wait;      
	unsigned int vm_pageout_empty_wait;     
	unsigned int vm_pageout_burst_wait;     
	unsigned int vm_pageout_deadlock_wait;  
	unsigned int vm_pageout_deadlock_relief;
	unsigned int vm_pageout_burst_inactive_throttle;

	unsigned int vm_pageout_inactive;
	unsigned int vm_pageout_inactive_used;  
	unsigned int vm_pageout_inactive_clean; 

	uint32_t vm_page_filecache_min;
	uint32_t vm_page_filecache_min_divisor;
	uint32_t vm_page_xpmapped_min;
	uint32_t vm_page_xpmapped_min_divisor;
	uint64_t vm_pageout_considered_page_last;

	int vm_page_free_count_init;

	unsigned int vm_memory_pressure;

	int memorystatus_purge_on_critical;
	int memorystatus_purge_on_warning;
	int memorystatus_purge_on_urgent;

	thread_t vm_pageout_early_swapout_iothread;
};
struct vm_pageout_vminfo {
	unsigned long vm_pageout_considered_page;
	unsigned long vm_pageout_considered_bq_internal;
	unsigned long vm_pageout_considered_bq_external;
	unsigned long vm_pageout_skipped_external;
	unsigned long vm_pageout_skipped_internal;

	unsigned long vm_pageout_pages_evicted;
	unsigned long vm_pageout_pages_purged;
	unsigned long vm_pageout_freed_cleaned;
	unsigned long vm_pageout_freed_speculative;
	unsigned long vm_pageout_freed_external;
	unsigned long vm_pageout_freed_internal;
	unsigned long vm_pageout_inactive_dirty_internal;
	unsigned long vm_pageout_inactive_dirty_external;
	unsigned long vm_pageout_inactive_referenced;
	unsigned long vm_pageout_reactivation_limit_exceeded;
	unsigned long vm_pageout_inactive_force_reclaim;
	unsigned long vm_pageout_inactive_nolock;
	unsigned long vm_pageout_filecache_min_reactivated;
	unsigned long vm_pageout_scan_inactive_throttled_internal;
	unsigned long vm_pageout_scan_inactive_throttled_external;

	uint64_t      vm_pageout_compressions;
	uint64_t      vm_compressor_pages_grabbed;
	unsigned long vm_compressor_failed;

	unsigned long vm_page_pages_freed;

	unsigned long vm_phantom_cache_found_ghost;
	unsigned long vm_phantom_cache_added_ghost;

	unsigned long vm_pageout_protected_sharedcache;
	unsigned long vm_pageout_forcereclaimed_sharedcache;
	unsigned long vm_pageout_protected_realtime;
	unsigned long vm_pageout_forcereclaimed_realtime;

};
struct pgo_iothread_state {
	struct vm_pageout_queue *q;
	void                    *current_early_swapout_chead;
	void                    *current_regular_swapout_chead;
	void                    *current_late_swapout_chead;
	char                    *scratch_buf;
	int                     id;
	thread_t                pgo_iothread; 
	sched_cond_atomic_t     pgo_wakeup;
};
struct vm_compressor_swapper_stats {
	uint64_t unripe_under_30s;
	uint64_t unripe_under_60s;
	uint64_t unripe_under_300s;
	uint64_t reclaim_swapins;
	uint64_t defrag_swapins;
	uint64_t compressor_swap_threshold_exceeded;
	uint64_t external_q_throttled;
	uint64_t free_count_below_reserve;
	uint64_t thrashing_detected;
	uint64_t fragmentation_detected;
};
struct vm_page_queue_free_head {
	vm_page_queue_head_t    qhead;
} VM_PAGE_PACKED_ALIGNED;
struct {
	uint8_t vmpr_regular;
	uint8_t vmpr_lopage;
} vmp_free_list_result_t;
struct page_worker_token {
	thread_pri_floor_t pwt_floor_token;
	bool pwt_did_register_inheritor;
} page_worker_token_t;
struct vm_page_delayed_work {
	vm_page_t       dw_m;
	int             dw_mask;
};
struct vm_page_delayed_work_ctx {
	struct vm_page_delayed_work dwp[DEFAULT_DELAYED_WORK_LIMIT];
	thread_t                    delayed_owner;
};
struct phantom_cache_stats {
	uint32_t        pcs_wrapped;
	uint32_t        pcs_added_page_to_entry;
	uint32_t        pcs_added_new_entry;
	uint32_t        pcs_replaced_entry;

	uint32_t        pcs_lookup_found_page_in_cache;
	uint32_t        pcs_lookup_entry_not_in_cache;
	uint32_t        pcs_lookup_page_not_in_entry;

	uint32_t        pcs_updated_phantom_state;
} phantom_cache_stats;
struct {
	uint32_t        added;
	uint32_t        found;
	uint32_t        added_ssd;
	uint32_t        found_ssd;
	uint32_t        elapsed_ms;
	boolean_t       pressure_detected;
} sample_period_ghost_counts[256];
struct  vm_ghost {
	uint64_t        g_next_index:VM_GHOST_INDEX_BITS,
	    g_pages_held:VM_GHOST_PAGES_PER_ENTRY,
	    g_obj_offset:VM_GHOST_OFFSET_BITS;
	uint32_t        g_obj_id;
} __attribute__((packed));
struct trim_list {
	uint64_t        tl_offset;
	uint64_t        tl_length;
	struct trim_list *tl_next;
};
struct vm_counters {
	unsigned int    do_collapse_compressor;
	unsigned int    do_collapse_compressor_pages;
	unsigned int    do_collapse_terminate;
	unsigned int    do_collapse_terminate_failure;
	unsigned int    should_cow_but_wired;
	unsigned int    create_upl_extra_cow;
	unsigned int    create_upl_extra_cow_pages;
	unsigned int    create_upl_lookup_failure_write;
	unsigned int    create_upl_lookup_failure_copy;
};
struct token {
	token_cnt_t     count;
	token_idx_t     prev;
	token_idx_t     next;
};
struct purgeable_q {
	token_idx_t token_q_head;    
	token_idx_t token_q_tail;    
	token_idx_t token_q_unripe;  
	int32_t new_pages;
	queue_head_t objq[NUM_VOLATILE_GROUPS];
	enum purgeable_q_type type;
};
struct vm_deferred_reclamation_metadata_s {
	TAILQ_ENTRY(vm_deferred_reclamation_metadata_s) vdrm_list;
	decl_lck_mtx_data(, vdrm_lock);
	decl_lck_mtx_gate_data(, vdrm_gate);
	task_t vdrm_task;
	pid_t vdrm_pid;
	vm_map_t vdrm_map;
	os_refcnt_t vdrm_refcnt;
	user_addr_t vdrm_buffer_addr;
	mach_vm_size_t vdrm_buffer_size;
	mach_vm_reclaim_count_t vdrm_buffer_len;
	uint64_t vdrm_reclaimed_at;
	uint32_t vdrm_waiters;
	size_t vdrm_cumulative_uncancelled_bytes;
	size_t vdrm_cumulative_reclaimed_bytes;

	uint8_t vdrm_is_registered : 1,
	    __unused1 : 7;
};
struct {
	vm_page_packed_t page_list;
} vm_page_bucket_t;
struct {
	kern_return_t compat_kr;
	bool should_rewrite;
	bool should_telemeter;
} vm_sanitize_compat_rewrite_t;
struct vm_sanitize_caller {
	vm_sanitize_caller_id_t              vmsc_caller_id;
	const char                          *vmsc_caller_name;
	vm_sanitize_method_t                 vmsc_telemetry_id;
	enum vm_sanitize_subsys_error_codes  vmsc_ktriage_id;

	vm_sanitize_err_compat_addr_size_fn    err_compat_addr_size;
	vm_sanitize_err_compat_cur_and_max_prots_fn err_compat_prot_cur_max;
} *vm_sanitize_caller_t;
struct _sr_file_mappings {
	int                     fd;
	uint32_t                mappings_count;
	struct shared_file_mapping_slide_np *mappings;
	uint32_t                slide;
	struct fileproc         *fp;
	struct vnode            *vp;
	memory_object_size_t    file_size;
	memory_object_control_t file_control;
};
struct shared_region_pager {
	struct memory_object    srp_header;          

	queue_chain_t           srp_queue;          
	bool                    srp_is_mapped;      
	bool                    srp_is_ready;       
	vm_object_t             srp_backing_object; 
	vm_object_offset_t      srp_backing_offset;
	vm_shared_region_slide_info_t srp_slide_info;
} *shared_region_pager_t;
struct vm_shared_region_slide_info_entry_v1 {
	uint32_t        version;
	uint32_t        toc_offset;     
	uint32_t        toc_count;      
	uint32_t        entry_offset;
	uint32_t        entry_count;
	uint32_t        entries_size;
};
struct slide_info_entry_toc {
	uint8_t entry[NUM_SLIDING_BITMAPS_PER_PAGE];
};
struct vm_shared_region_slide_info_entry_v2 {
	uint32_t        version;
	uint32_t        page_size;
	uint32_t        page_starts_offset;
	uint32_t        page_starts_count;
	uint32_t        page_extras_offset;
	uint32_t        page_extras_count;
	uint64_t        delta_mask;             
	uint64_t        value_add;
};
struct vm_shared_region_slide_info_entry_v3 {
	uint32_t        version;                        
	uint32_t        page_size;                      
	uint32_t        page_starts_count;
	uint64_t        value_add;
	uint16_t        page_starts[] ;
};
struct vm_shared_region_slide_info_entry_v4 {
	uint32_t    version;        
	uint32_t    page_size;      
	uint32_t    page_starts_offset;
	uint32_t    page_starts_count;
	uint32_t    page_extras_offset;
	uint32_t    page_extras_count;
	uint64_t    delta_mask;    
	uint64_t    value_add;     
};
struct vm_shared_region_slide_info_entry_v5 {
	uint32_t    version;        
	uint32_t    page_size;      
	uint32_t    page_starts_count;
	uint64_t    value_add;
	uint16_t    page_starts[] ;
};
struct vm_shared_region_slide_info {
	uint32_t                si_slide;           
	bool                    si_slid;
	mach_vm_address_t       si_slid_address __kernel_data_semantics;
	mach_vm_offset_t        si_start __kernel_data_semantics; 
	mach_vm_offset_t        si_end __kernel_data_semantics;
	vm_object_t             si_slide_object;    
	mach_vm_size_t          si_slide_info_size; 
	vm_shared_region_slide_info_entry_t si_slide_info_entry; 
} *vm_shared_region_slide_info_t;
struct vm_shared_region {
	uint32_t                sr_ref_count;
	uint32_t                sr_slide;
	queue_chain_t           sr_q;
	void                    *sr_root_dir;
	cpu_type_t              sr_cpu_type;
	cpu_subtype_t           sr_cpu_subtype;
	ipc_port_t              sr_mem_entry;
	mach_vm_offset_t        sr_first_mapping;
	mach_vm_offset_t        sr_base_address;
	mach_vm_size_t          sr_size;
	mach_vm_offset_t        sr_pmap_nesting_start;
	mach_vm_size_t          sr_pmap_nesting_size;
	thread_call_t           sr_timer_call;
	uuid_t                  sr_uuid;

	thread_t                sr_mapping_in_progress; 
	thread_t                sr_slide_in_progress;
	bool                    sr_64bit;
	bool                    sr_persists;
	bool                    sr_uuid_copied;
	bool                    sr_stale;              
	bool                    sr_driverkit;


	uint32_t                sr_rsr_version;

	uint64_t                sr_install_time; 
	uint32_t                sr_id; 
	uint32_t                sr_images_count;
	struct dyld_uuid_info_64 *sr_images;
};
struct swapfile_pager {
	struct memory_object    swp_pgr_hdr;

	queue_chain_t           pager_queue;    
	bool                    is_ready;       
	bool                    is_mapped;      
	struct vnode            *swapfile_vnode;
} *swapfile_pager_t;
struct lowglo {
	unsigned char   lgVerCode[8];           
	uint64_t        lgZero;                 
	uint64_t        lgStext;                
	uint64_t        lgLayoutMajorVersion;   
	uint64_t        lgLayoutMinorVersion;   
	uint64_t        lgRsv028;               
	uint64_t        lgVersion;              
	uint64_t        lgCompressorBufferAddr; 
	uint64_t        lgCompressorSizeAddr;   
	uint64_t        lgRsv038[278];          
	uint64_t        lgKmodptr;              
	uint64_t        lgTransOff;             
	uint64_t        lgReadIO;               
	uint64_t        lgDevSlot1;             
	uint64_t        lgDevSlot2;             
	uint64_t        lgOSVersion;            
	uint64_t        lgRebootFlag;           
	uint64_t        lgManualPktAddr;        
	uint64_t        lgKdpJtagCoredumpAddr;  

	uint64_t        lgRsv940[216];          
} lowglo;
struct processor_cpu_stat {
	uint32_t irq_ex_cnt;
	uint32_t ipi_cnt;
	uint32_t timer_cnt;
	uint32_t undef_ex_cnt;
	uint32_t unaligned_cnt;
	uint32_t vfp_cnt;
	uint32_t vfp_shortv_cnt;
	uint32_t data_ex_cnt;
	uint32_t instr_ex_cnt;
};
struct processor_cpu_stat64 {
	uint64_t irq_ex_cnt;
	uint64_t ipi_cnt;
	uint64_t timer_cnt;
	uint64_t undef_ex_cnt;
	uint64_t unaligned_cnt;
	uint64_t vfp_cnt;
	uint64_t vfp_shortv_cnt;
	uint64_t data_ex_cnt;
	uint64_t instr_ex_cnt;
	uint64_t pmi_cnt;
} __attribute__((packed, aligned(4)));
struct arm_state_hdr {
	uint32_t flavor;
	uint32_t count;
};
struct arm_unified_thread_state {
	arm_state_hdr_t ash;
	union {
		arm_thread_state32_t ts_32;
		arm_thread_state64_t ts_64;
	} uts;
};
struct arm_saved_state32 {
	uint32_t r[13];     
	uint32_t sp;        
	uint32_t lr;        
	uint32_t pc;        
	uint32_t cpsr;      
	uint32_t far;       
	uint32_t esr;       
	uint32_t exception; 
};
struct arm_saved_state32_tagged {
	uint32_t                 tag;
	struct arm_saved_state32 state;
};
struct arm_saved_state64 {
	uint64_t x[29];     
	uint64_t fp;        
	uint64_t lr;        
	uint64_t sp;        
	uint64_t pc;        
	uint32_t cpsr;      
	uint32_t reserved;  
	uint64_t far;       
	uint64_t esr;       
};
struct arm_saved_state64_tagged {
	uint32_t                 tag;
	struct arm_saved_state64 state;
};
struct arm_saved_state {
	arm_state_hdr_t ash;
	union {
		struct arm_saved_state32 ss_32;
		struct arm_saved_state64 ss_64;
	} uss;
} __attribute__((aligned(16)));
struct arm_kernel_saved_state {
	uint64_t x[10];     
	uint64_t fp;        
	uint64_t lr;        
	uint64_t sp;        
	uint8_t pc_was_in_userspace;
	uint8_t ssbs;
	uint8_t dit;
	uint8_t uao;
} __attribute__((aligned(16)));
struct arm_debug_aggregate_state {
	arm_state_hdr_t dsh;
	union {
		arm_debug_state32_t ds32;
		arm_debug_state64_t ds64;
	} uds;
	os_refcnt_t     ref;
} __attribute__((aligned(16)));
struct arm_neon_saved_state32 {
	union {
		uint128_t q[16];
		uint64_t  d[32];
		uint32_t  s[32];
	} v;
	uint32_t fpsr;
	uint32_t fpcr;
};
struct arm_neon_saved_state64 {
	union {
		uint128_t  q[32];
		uint64x2_t d[32];
		uint32x4_t s[32];
	} v;
	uint32_t fpsr;
	uint32_t fpcr;
};
struct arm_neon_saved_state {
	arm_state_hdr_t nsh;
	union {
		struct arm_neon_saved_state32 ns_32;
		struct arm_neon_saved_state64 ns_64;
	} uns;
};
struct arm_kernel_neon_saved_state {
	uint64_t d[8];
	uint32_t fpcr;
};
struct arm_context {
	struct arm_saved_state ss;
	struct arm_neon_saved_state ns;
};
struct arm_kernel_context {
	struct arm_kernel_saved_state ss;
	struct arm_kernel_neon_saved_state ns;
};
struct { int __val[2]; } bit64_t;
struct { unsigned int __val[2]; } u_bit64_t;
struct { int __val[2]; } bit64_t;
struct { unsigned int __val[2]; } u_bit64_t;
struct timespec {
	unsigned long tv_sec;
	long tv_nsec;
};
struct _kdp_jtag_coredump_t {
	uint64_t signature;
	uint64_t version;
	uint64_t kernel_map_start;
	uint64_t kernel_map_end;
	uint64_t kernel_pmap_pml4;
	uint64_t pmap_memory_regions;
	uint64_t pmap_memory_region_count;
	uint64_t pmap_memory_region_t_size;
	uint64_t physmap_base;
} kdp_jtag_coredump_t;
struct _cframe_t {
	struct _cframe_t    *prev;
	unsigned            caller;
	unsigned            args[0];
} cframe_t;
struct _cframe_t {
	struct _cframe_t    *prev;
	uintptr_t           caller;
	unsigned            args[0];
} cframe_t;
struct panic_lbr_header_s {
	uint32_t id;
	uint8_t ncpus;
	uint8_t lbr_count;
	uint64_t pcarveout_va;
};
struct vmx_specs {
	boolean_t       initialized;    
	boolean_t       vmx_present;    
	boolean_t       vmx_on;                 
	uint32_t        vmcs_id;                
	uint32_t        cr0_fixed_0;    
	uint32_t        cr0_fixed_1;    

	uint32_t        cr4_fixed_0;    
	uint32_t        cr4_fixed_1;    
} vmx_specs_t;
struct vmx_cpu {
	vmx_specs_t     specs;          
	void            *vmxon_region;  
} vmx_cpu_t;
struct {
	pmap_paddr_t pa;
	vm_map_address_t va;
	vm_size_t len;
} ptov_table_entry;
struct arm_physrange {
	uint64_t        start_phys;     
	uint64_t        end_phys;       
} arm_physrange_t;
struct pmap_tlb_flush_range {
	pmap_t ptfr_pmap;

	vm_map_address_t ptfr_start;

	vm_map_address_t ptfr_end;

	pt_entry_t *current_ptep;

	vm_map_address_t pending_region_start;

	unsigned int pending_region_entries;

	bool region_entry_added;

	sptm_update_disjoint_multipage_op_t *current_header;

	unsigned int current_header_first_mapping_index;

	unsigned int pending_disjoint_entries;

	unsigned int processed_entries;

	bool ptfr_flush_needed;
} pmap_tlb_flush_range_t;
struct tt_free_entry {
	struct tt_free_entry    *next;
} tt_free_entry_t;
struct pv_entry {
	struct pv_entry *pve_next;

	pt_entry_t *pve_ptep[PTE_PER_PVE];
} pv_entry_t;
struct {
	pv_entry_t *list;
	uint32_t count;
} pv_free_list_t;
struct pmap_cpu_data {
	unsigned int cpu_number;
	bool copywindow_strong_sync[CPUWINDOWS_MAX];
	bool inflight_disconnect;
	pv_free_list_t pv_free;
	pv_entry_t *pv_free_spill_marker;
};
struct {
	uintptr_t pvh;
	thread_pri_floor_t pri_token;
	unsigned int pai;
} locked_pvh_t;
struct pmap {
	tt_entry_t *tte;

	pmap_paddr_t ttep;


	vm_map_address_t min;

	vm_map_address_t max;


	ledger_t ledger;

	decl_lck_rw_data(, rwlock);

	queue_chain_t pmaps;

	struct pmap      *nested_pmap;
	vm_map_address_t nested_region_addr;
	vm_map_offset_t  nested_region_size;
	vm_map_offset_t  nested_region_true_start;
	vm_map_offset_t  nested_region_true_end;
	bitmap_t         *nested_region_unnested_table_bitmap;

	os_ref_atomic_t ref_count;

	uint32_t nested_no_bounds_refcnt;

	union {
		
		uint16_t asid;

		
		uint16_t vmid;
	};


	bool reserved0;

	bool pmap_vm_map_cs_enforced;

	bool reserved1;
	unsigned int reserved2;
	unsigned int reserved3;



	bool nx_enabled;

	bool is_64bit;

	bool nested_has_no_bounds_ref;

	bool nested_bounds_set;


	bool reserved6;

	uint8_t type;

	uint32_t reserved7[4];
	void *reserved8;
	uint8_t reserved9;
};
struct pmap_cpu_data_array_entry {
	pmap_cpu_data_t cpu_data;
} __attribute__((aligned(MAX_L2_CLINE_BYTES)));
struct page_free_entry {
	struct page_free_entry *next;
} page_free_entry_t;
struct {
	unsigned short wiredcnt;
} ptd_info_t;
struct pt_desc {
	union {
		struct pmap *pmap;
	};


	vm_offset_t va;

	ptd_info_t *ptd_info;
} pt_desc_t;
struct {
	uint64_t local_seq;

	uint64_t next_seq;

	uint64_t remote_seq[MAX_CPUS];



	uint8_t flags;
} pmap_retype_epoch_t;
struct {
	sptm_pte_t *sptm_prev_ptes;

	void *sptm_iommu_scratch;

	sptm_disjoint_op_t sptm_ops[SPTM_MAPPING_LIMIT];

	union {
		
		sptm_pte_t sptm_templates[SPTM_MAPPING_LIMIT];

		
		sptm_paddr_t sptm_paddrs[SPTM_MAPPING_LIMIT];
	};

	pmap_paddr_t sptm_ops_pa;

	pmap_paddr_t sptm_templates_pa;

	pmap_paddr_t sptm_paddrs_pa;

	pt_desc_t *sptm_ptds[SPTM_MAPPING_LIMIT];

	ptd_info_t *sptm_ptd_info[SPTM_MAPPING_LIMIT];

	uint8_t sptm_acct_flags[SPTM_MAPPING_LIMIT];

	pmap_retype_epoch_t retype_epoch;

	sptm_guest_dispatch_t sptm_guest_dispatch;

	pmap_paddr_t sptm_guest_dispatch_paddr;

	uint16_t sptm_cpu_id;

	uint64_t sptm_trace_buffer_read_index;

	uint64_t sptm_trace_prev_state;
} __attribute__((aligned(PMAP_SPTM_PCPU_ALIGN))) pmap_sptm_percpu_data_t;
struct pmap_io_range {
	uint64_t addr;

	uint64_t len;





	uint32_t wimg;

	uint32_t signature;
} pmap_io_range_t;
struct pmap_io_filter_entry {
	uint32_t signature;

	uint16_t offset;

	uint16_t length;
} pmap_io_filter_entry_t;
struct page_table_level_info {
	const uint64_t size;
	const uint64_t offmask;
	const uint64_t shift;
	const uint64_t index_mask;
	const uint64_t valid_mask;
	const uint64_t type_mask;
	const uint64_t type_block;
};
struct page_table_ops {
	bool (*alloc_id)(pmap_t pmap);
	void (*free_id)(pmap_t pmap);
	void (*flush_tlb_region_async)(vm_offset_t va, size_t length, pmap_t pmap, bool last_level_only);
	void (*flush_tlb_async)(pmap_t pmap);
	pt_entry_t (*wimg_to_pte)(unsigned int wimg, pmap_paddr_t pa);
};
struct page_table_attr {
	const struct page_table_level_info * const pta_level_info;

	const struct page_table_ops * const pta_ops;

	const uintptr_t ap_ro;
	const uintptr_t ap_rw;
	const uintptr_t ap_rona;
	const uintptr_t ap_rwna;
	const uintptr_t ap_xn;
	const uintptr_t ap_x;

	const unsigned int pta_root_level;

	const unsigned int pta_commpage_level;

	const unsigned int pta_max_level;


	const uint64_t pta_tcr_value;

	const uint64_t pta_page_size;

	const uint64_t pta_page_shift;

	const uint8_t geometry_id;
};
struct pmap_tlb_flush_range {
	pmap_t ptfr_pmap;
	vm_map_address_t ptfr_start;
	vm_map_address_t ptfr_end;
	bool ptfr_flush_needed;
} pmap_tlb_flush_range_t;
struct tt_free_entry {
	struct tt_free_entry    *next;
} tt_free_entry_t;
struct {
	uint64_t page_index : 32,           
	    state : 8,                      
	    tlb_flush_pass_needed : 1,      
	    rt_cache_flush_pass_needed : 1, 
	:0;
} batch_set_cache_attr_state_t;
struct pv_entry {
	struct pv_entry *pve_next;

	pt_entry_t *pve_ptep[PTE_PER_PVE];
} pv_entry_t;
struct {
	pv_entry_t *list;
	uint32_t count;
} pv_free_list_t;
struct pmap_cpu_data {
	pmap_t cpu_nested_pmap;
	const struct page_table_attr *cpu_nested_pmap_attr;
	vm_map_address_t cpu_nested_region_addr;
	vm_map_offset_t cpu_nested_region_size;
	unsigned int cpu_number;
	bool copywindow_strong_sync[CPUWINDOWS_MAX];
	bool inflight_disconnect;
	pv_free_list_t pv_free;
	pv_entry_t *pv_free_spill_marker;

};
struct pmap {
	tt_entry_t *tte;

	pmap_paddr_t ttep;


	vm_map_address_t min;

	vm_map_address_t max;


	ledger_t ledger;

	decl_lck_rw_data(, rwlock);

	queue_chain_t pmaps;

	tt_entry_t *tt_entry_free;

	struct pmap      *nested_pmap;
	vm_map_address_t nested_region_addr;
	vm_map_offset_t  nested_region_size;
	vm_map_offset_t  nested_region_true_start;
	vm_map_offset_t  nested_region_true_end;
	unsigned int     *nested_region_unnested_table_bitmap;
	unsigned int     nested_region_unnested_table_bitmap_size;


	void *          reserved0;
	void *          reserved1;
	uint8_t         reserved12;
	uint64_t        reserved2;
	uint64_t        reserved3;

	_Atomic int32_t ref_count;


	uint32_t nested_no_bounds_refcnt;

	uint16_t hw_asid;

	uint8_t sw_asid;


	bool reserved4;

	bool pmap_vm_map_cs_enforced;

	bool reserved5;
	unsigned int reserved6;
	unsigned int reserved7;

	bool reserved8;
	bool reserved9;



	bool nx_enabled;

	bool is_64bit;

	enum : uint8_t {
		
		NESTED_NO_BOUNDS_REF_NONE = 0,
		
		NESTED_NO_BOUNDS_REF_SUBORD,
		
		NESTED_NO_BOUNDS_REF_AFTER,
		
		NESTED_NO_BOUNDS_REF_BEFORE_AND_AFTER,
	} nested_no_bounds_ref_state;

	bool nested_bounds_set;


	bool reserved13;

	uint8_t type;
};
struct pmap_cpu_data_array_entry {
	pmap_cpu_data_t cpu_data;
} __attribute__((aligned(MAX_L2_CLINE_BYTES)));
struct page_free_entry {
	struct page_free_entry *next;
} page_free_entry_t;
struct {

	unsigned short refcnt;

	unsigned short wiredcnt;
} ptd_info_t;
struct pt_desc {
	queue_chain_t pt_page;

	union {
		struct pmap *pmap;
	};


	vm_offset_t va[PT_INDEX_MAX];

	ptd_info_t *ptd_info;
} pt_desc_t;
struct pmap_io_range {
	uint64_t addr;

	uint64_t len;





	uint32_t wimg;

	uint32_t signature;
} pmap_io_range_t;
struct pmap_io_filter_entry {
	uint32_t signature;

	uint16_t offset;

	uint16_t length;
} pmap_io_filter_entry_t;
struct page_table_level_info {
	const uint64_t size;
	const uint64_t offmask;
	const uint64_t shift;
	const uint64_t index_mask;
	const uint64_t valid_mask;
	const uint64_t type_mask;
	const uint64_t type_block;
};
struct page_table_ops {
	bool (*alloc_id)(pmap_t pmap);
	void (*free_id)(pmap_t pmap);
	void (*flush_tlb_region_async)(vm_offset_t va, size_t length, pmap_t pmap, bool last_level_only, bool strong);
	void (*flush_tlb_async)(pmap_t pmap);
	pt_entry_t (*wimg_to_pte)(unsigned int wimg, pmap_paddr_t pa);
};
struct page_table_attr {
	const struct page_table_level_info * const pta_level_info;

	const struct page_table_ops * const pta_ops;

	const uintptr_t ap_ro;
	const uintptr_t ap_rw;
	const uintptr_t ap_rona;
	const uintptr_t ap_rwna;
	const uintptr_t ap_xn;
	const uintptr_t ap_x;

	const unsigned int pta_root_level;

	const unsigned int pta_commpage_level;

	const unsigned int pta_max_level;


	const uint64_t pta_tcr_value;

	const uint64_t pta_page_size;

	const uint64_t pta_pagezero_size;

	const uint64_t pta_page_shift;
};
struct error_sparse_map {
	unsigned                start;
	unsigned                end;
};
struct error_subsystem {
	const char                      *subsys_name;
	int                             max_code;
	const char * const              *codes;
	const struct error_sparse_map   *map_table;
	int                             map_count;
};
struct error_system {
	int                             max_sub;
	const char                      *bad_sub;
	const struct error_subsystem    *subsystem;
	const struct error_sparse_map   *map_table;
	int                             map_count;
};
struct _os_alloc_once_s {
	long once;
	void *ptr;
};
struct work_interval {
	uint64_t thread_id;
	uint64_t work_interval_id;
	uint32_t create_flags;
	mach_port_t wi_port;
};
struct _libkernel_functions {
	unsigned long version;
	void* (*LIBKERNEL_FUNCTION_PTRAUTH(dlsym))(void*, const char*);
	void* (*LIBKERNEL_FUNCTION_PTRAUTH(malloc))(size_t);
	void(*LIBKERNEL_FUNCTION_PTRAUTH(free))(void*);
	void* (*LIBKERNEL_FUNCTION_PTRAUTH(realloc))(void*, size_t);
	void(*LIBKERNEL_FUNCTION_PTRAUTH(_pthread_exit_if_canceled))(int);

	void *reserved1;
	void *reserved2;
	void *reserved3;
	void *reserved4;
	void *reserved5;

	void(*LIBKERNEL_FUNCTION_PTRAUTH(pthread_clear_qos_tsd))(mach_port_t);

	int(*LIBKERNEL_FUNCTION_PTRAUTH(pthread_current_stack_contains_np))(const void *, size_t);

	void* (*LIBKERNEL_FUNCTION_PTRAUTH(malloc_type_malloc))(size_t, malloc_type_id_t);
	void(*LIBKERNEL_FUNCTION_PTRAUTH(malloc_type_free))(void *, malloc_type_id_t);
	void* (*LIBKERNEL_FUNCTION_PTRAUTH(malloc_type_realloc))(void *, size_t, malloc_type_id_t);

} *_libkernel_functions_t;
struct _libkernel_string_functions {
	unsigned long version;
	void (*bzero)(void *s, size_t n);
	void * (*memchr)(const void *s, int c, size_t n);
	int (*memcmp)(const void *s1, const void *s2, size_t n);
	void * (*memmove)(void *dst, const void *src, size_t n);
	void * (*memccpy)(void *__restrict dst, const void *__restrict src, int c, size_t n);
	void * (*memset)(void *b, int c, size_t len);
	char * (*strchr)(const char *s, int c);
	int (*strcmp)(const char *s1, const char *s2);
	char * (*strcpy)(char * restrict dst, const char * restrict src);
	size_t (*strlcat)(char * restrict dst, const char * restrict src, size_t maxlen);
	size_t (*strlcpy)(char * restrict dst, const char * restrict src, size_t maxlen);
	size_t (*strlen)(const char *str);
	int (*strncmp)(const char *s1, const char *s2, size_t n);
	char * (*strncpy)(char * restrict dst, const char * restrict src, size_t maxlen);
	size_t (*strnlen)(const char *s, size_t maxlen);
	char * (*strstr)(const char *s, const char *find);
} *_libkernel_string_functions_t;
struct _libkernel_voucher_functions {
	unsigned long version;
	boolean_t (*voucher_mach_msg_set)(mach_msg_header_t*);
	void (*voucher_mach_msg_clear)(mach_msg_header_t*);
	voucher_mach_msg_state_t (*voucher_mach_msg_adopt)(mach_msg_header_t*);
	void (*voucher_mach_msg_revert)(voucher_mach_msg_state_t);


	mach_msg_size_t (*voucher_mach_msg_fill_aux)(mach_msg_aux_header_t*, mach_msg_size_t);

} *_libkernel_voucher_functions_t;
struct _libkernel_late_init_config {
	unsigned long version;

	bool enable_system_version_compat;

	bool enable_ios_version_compat;

	bool enable_posix_spawn_filtering;
} *_libkernel_late_init_config_t;
struct _libkernel_init_after_boot_tasks_config {
	unsigned long version;

	bool enable_posix_spawn_filtering;
} *_libkernel_init_after_boot_tasks_config_t;
struct {
	int                             *pids;
	int                             pids_count;
	size_t                          pids_size;

	uint64_t                        *threads;
	int                             thr_count;
	size_t                          thr_size;

	struct proc_fdinfo              *fds;
	int                             fds_count;
	size_t                          fds_size;

	struct stat                     match_stat;

	uint32_t                        flags;
} fdOpenInfo, *fdOpenInfoRef;
struct traffic_rule_type {
	uint8_t tr_type;
	uint32_t tr_size;
	uint32_t tr_count;
	void (*tr_iterate)(void *, uint32_t,
	    nexus_traffic_rule_iterator_t, void *);
};
struct error_subsystem {
	const char              *subsys_name;
	int                     max_code;
	const char * const      *codes;
};
struct error_system {
	int                             max_sub;
	const char                      *bad_sub;
	const struct error_subsystem    *subsystem;
};
struct _mach_right_recv {
	mach_port_t mrr_name;
} mach_right_recv_t;
struct _mach_right_send {
	mach_port_t mrs_name;
} mach_right_send_t;
struct _mach_right_send_once {
	mach_port_t mrso_name;
} mach_right_send_once_t;
struct port_obj_tentry {
	void *pos_value;
	int pos_type;
};
struct  {
	long    code;
	long    thread;
	long    a1;
	long    a2;
	long    a3;
	long    a4;
	long    a5;
	long    a6;
} log_rec_t;
struct {
	int     datagram_pkts_sent;
	int     datagram_pkts_rcvd;
	int     srr_requests_sent;
	int     srr_bcasts_sent;
	int     srr_requests_rcvd;
	int     srr_bcasts_rcvd;
	int     srr_replies_sent;
	int     srr_replies_rcvd;
	int     srr_retries_sent;
	int     srr_retries_rcvd;
	int     srr_cfailures_sent;
	int     srr_cfailures_rcvd;
	int     deltat_dpkts_sent;
	int     deltat_acks_rcvd;
	int     deltat_dpkts_rcvd;
	int     deltat_acks_sent;
	int     deltat_oldpkts_rcvd;
	int     deltat_oospkts_rcvd;
	int     deltat_retries_sent;
	int     deltat_retries_rcvd;
	int     deltat_cfailures_sent;
	int     deltat_cfailures_rcvd;
	int     deltat_aborts_sent;
	int     deltat_aborts_rcvd;
	int     vmtp_requests_sent;
	int     vmtp_requests_rcvd;
	int     vmtp_replies_sent;
	int     vmtp_replies_rcvd;
	int     ipc_in_messages;
	int     ipc_out_messages;
	int     ipc_unblocks_sent;
	int     ipc_unblocks_rcvd;
	int     pc_requests_sent;
	int     pc_requests_rcvd;
	int     pc_replies_rcvd;
	int     pc_startups_rcvd;
	int     nn_requests_sent;
	int     nn_requests_rcvd;
	int     nn_replies_rcvd;
	int     po_ro_hints_sent;
	int     po_ro_hints_rcvd;
	int     po_token_requests_sent;
	int     po_token_requests_rcvd;
	int     po_token_replies_rcvd;
	int     po_xfer_requests_sent;
	int     po_xfer_requests_rcvd;
	int     po_xfer_replies_rcvd;
	int     po_deaths_sent;
	int     po_deaths_rcvd;
	int     ps_requests_sent;
	int     ps_requests_rcvd;
	int     ps_replies_rcvd;
	int     ps_auth_requests_sent;
	int     ps_auth_requests_rcvd;
	int     ps_auth_replies_rcvd;
	int     mallocs_or_vm_allocates;
	int     mem_allocs;
	int     mem_deallocs;
	int     mem_allocobjs;
	int     mem_deallocobjs;
	int     pkts_encrypted;
	int     pkts_decrypted;
	int     vmtp_segs_encrypted;
	int     vmtp_segs_decrypted;
	int     tcp_requests_sent;
	int     tcp_replies_sent;
	int     tcp_requests_rcvd;
	int     tcp_replies_rcvd;
	int     tcp_send;
	int     tcp_recv;
	int     tcp_connect;
	int     tcp_accept;
	int     tcp_close;
} stat_t;
struct {
	int     print_level;
	int     ipc_in;
	int     ipc_out;
	int     tracing;
	int     vmtp;
	int     netname;
	int     deltat;
	int     tcp;
	int     mem;
} debug_t;
struct {
	int     srr_max_tries;
	int     srr_retry_sec;
	int     srr_retry_usec;
	int     deltat_max_tries;
	int     deltat_retry_sec;
	int     deltat_retry_usec;
	int     deltat_msg_life;
	int     pc_checkup_interval;
	int     crypt_algorithm;
	int     transport_default;
	int     conf_network;
	int     conf_netport;
	int     timer_quantum;
	int     tcp_conn_steady;
	int     tcp_conn_opening;
	int     tcp_conn_max;
	int     compat;
	int     syslog;
	int     old_nmmonitor;
} param_t;
struct {
	u_int   port_id;
	u_int   alive;
	u_int   nport_id_high;
	u_int   nport_id_low;
	u_int   nport_receiver;
	u_int   nport_owner;
	u_int   messages_sent;
	u_int   messages_rcvd;
	u_int   send_rights_sent;
	u_int   send_rights_rcvd_sender;
	u_int   send_rights_rcvd_recown;
	u_int   rcv_rights_xferd;
	u_int   own_rights_xferd;
	u_int   all_rights_xferd;
	u_int   tokens_sent;
	u_int   tokens_requested;
	u_int   xfer_hints_sent;
	u_int   xfer_hints_rcvd;
} port_stat_t, *port_stat_ptr_t;
struct osLogDataHeader {
	uint32_t version;
	uint32_t sect_count;
	struct {
		uint32_t sect_offset;
		uint32_t sect_size;
	} sections[0];
} osLogDataHeaderRef;
struct MkextEntryRef {
	mkext_basic_header * mkext; 
	void               * fileinfo;
} MkextEntryRef;
struct _BooterKextFileInfo {
	uint32_t  infoDictPhysAddr;
	uint32_t  infoDictLength;
	uint32_t  executablePhysAddr;
	uint32_t  executableLength;
	uint32_t  bundlePathPhysAddr;
	uint32_t  bundlePathLength;
} _BooterKextFileInfo;
struct _DeviceTreeBuffer {
	uint32_t paddr;
	uint32_t length;
} _DeviceTreeBuffer;
struct kaslrPackedOffsets {
		uint32_t    count;          
		uint32_t    offsetsArray[];        
	};
struct StalledData {
	const char   * kextIdentifier;
	OSReturn       result;
	unsigned int   capacity;
	unsigned int   count;
	OSMetaClass ** classes;
} * sStalled;
struct ExpansionData {
	OSOrderedSet    * instances;
	OSKext          * kext;
	uint32_t          retain;
};
struct _Element {
	OSTaggedPtr<const OSMetaClassBase> obj;
};
struct object {
	struct object   *next;
	struct object   *prev;
	void            *object;
	int             size;           
	union {
		void    *key;           
		long long offset;       
	} u;
} object_t;
struct pqueue_entry_traits {
	static inline int
	compare(queue_t que, entry_t a, entry_t b);
};
struct pqueue {
	using entry_traits = pqueue_entry_traits<queue_t, entry_t>;

	static inline void
	pack_child(entry_t e, const entry_t child)
	{
		e->child = (long)child;
	}

	static inline entry_t
	unpack_child(entry_t e)
	{
		return (entry_t)e->child;
	}

private:
	static inline bool
	merge_parent_is_subtree_b(queue_t que, entry_t subtree_a, entry_t subtree_b)
	{
		if (priority_queue_is_max_heap((queue_t)nullptr)) {
			return entry_traits::compare(que, subtree_a, subtree_b) > 0;
		}
		return entry_traits::compare(que, subtree_a, subtree_b) < 0;
	}

	static inline entry_t
	merge_pair_inline(queue_t que, entry_t subtree_a, entry_t subtree_b)
	{
		entry_t merge_result = NULL;
		if (subtree_a == NULL) {
			merge_result = subtree_b;
		} else if (subtree_b == NULL || (subtree_a == subtree_b)) {
			merge_result = subtree_a;
		} else {
			entry_t parent = subtree_a;
			entry_t child = subtree_b;
			if (merge_parent_is_subtree_b(que, subtree_a, subtree_b)) {
				parent = subtree_b;
				child = subtree_a;
			}
			
			child->next = unpack_child(parent);
			child->prev = parent;
			if (unpack_child(parent) != NULL) {
				unpack_child(parent)->prev = child;
			}
			
			pack_child(parent, child);
			parent->next = NULL;
			parent->prev = NULL;
			merge_result = parent;
		}
		return merge_result;
	}

	OS_NOINLINE
	static entry_t
	merge_pair(queue_t que, entry_t subtree_a, entry_t subtree_b)
	{
		return merge_pair_inline(que, subtree_a, subtree_b);
	}

	OS_NOINLINE
	static entry_t
	meld_pair(queue_t que, entry_t elt)
	{
		entry_t pq_meld_result = NULL;
		entry_t pair_list = NULL;

		assert(elt); 

		
		
		

		do {
			
			entry_t pair_item_a = elt;
			entry_t pair_item_b = elt->next;
			if (pair_item_b == NULL) {
				
				
				pair_item_a->prev = pair_list;
				pair_list = pair_item_a;
				break;
			}
			
			elt = pair_item_b->next;
			entry_t pair = merge_pair_inline(que, pair_item_a, pair_item_b);
			
			pair->prev = pair_list;
			pair_list = pair;
		} while (elt != NULL);

		
		do {
			elt = pair_list->prev;
			pq_meld_result = merge_pair_inline(que, pq_meld_result, pair_list);
			pair_list = elt;
		} while (pair_list != NULL);

		return pq_meld_result;
	}

	static inline void
	list_clear(entry_t e)
	{
		e->next = e->prev = NULL;
	}

	static inline void
	list_remove(entry_t elt)
	{
		assert(elt->prev != NULL);
		
		
		
		if (unpack_child(elt->prev) == elt) {
			pack_child(elt->prev, elt->next);
		} else {
			elt->prev->next = elt->next;
		}
		
		if (elt->next != NULL) {
			elt->next->prev = elt->prev;
		}
		list_clear(elt);
	}

	static inline bool
	sift_down(queue_t que, entry_t elt)
	{
		bool was_root = (que->pq_root == elt);

		if (!was_root) {
			remove_non_root(que, elt);
			insert(que, elt, false);
		} else if (unpack_child(elt)) {
			remove_root(que, elt);
			insert(que, elt, false);
		} else {
			
		}
		return was_root;
	}

	static inline bool
	sift_up(queue_t que, entry_t elt)
	{
		if (elt == que->pq_root) {
			return true;
		}

		
		list_remove(elt);
		
		return insert(que, elt, false);
	}

	static inline entry_t
	remove_non_root(queue_t que, entry_t elt)
	{
		entry_t child, new_root;

		
		
		
		
		
		list_remove(elt);

		child = unpack_child(elt);
		if (child) {
			child = meld_pair(que, child);
			new_root = merge_pair(que, que->pq_root, child);
			que->pq_root = new_root;
			pack_child(elt, nullptr);
		}

		return elt;
	}

public:


	OS_NOINLINE
	static void
	destroy(queue_t que, uintptr_t offset, void (^callback)(void *e))
	{
		assert(callback != NULL);
		entry_t head = que->pq_root;
		entry_t tail = head;

		while (head != NULL) {
			entry_t child_list = unpack_child(head);
			if (child_list) {
				tail->next = child_list;
				while (tail->next) {
					tail = tail->next;
				}
			}

			entry_t elt = head;
			head = head->next;
			callback((void *)((char *)elt - offset));
		}

		
		que->pq_root = (entry_t)(~0ul);
	}

	static inline bool
	insert(queue_t que, entry_t elt, bool clear = true)
	{
		if (clear) {
			list_clear(elt);
			pack_child(elt, nullptr);
		}
		return (que->pq_root = merge_pair(que, que->pq_root, elt)) == elt;
	}

	static inline entry_t
	remove_root(queue_t que, entry_t old_root)
	{
		entry_t new_root = unpack_child(old_root);

		if (new_root) {
			que->pq_root = meld_pair(que, new_root);
			pack_child(old_root, nullptr);
		} else {
			que->pq_root = NULL;
		}
		return old_root;
	}

	static inline bool
	remove(queue_t que, entry_t elt)
	{
		if (elt == que->pq_root) {
			remove_root(que, elt);
			return true;
		} else {
			remove_non_root(que, elt);
			return false;
		}
	}

	static inline bool
	entry_increased(queue_t que, entry_t elt)
	{
		if (priority_queue_is_max_heap(que)) {
			return sift_up(que, elt);
		} else {
			return sift_down(que, elt);
		}
	}

	static inline bool
	entry_decreased(queue_t que, entry_t elt)
	{
		if (priority_queue_is_min_heap(que)) {
			return sift_up(que, elt);
		} else {
			return sift_down(que, elt);
		}
	}
};
struct core_analytics_serialized_event_s {
	OSSharedPtr<OSString> case_event_name;
	OSSharedPtr<OSDictionary> case_event;
} core_analytics_serialized_event_t;
struct firehose_chunk_s {
	union {
		uint8_t fc_start[FIREHOSE_CHUNK_SIZE];
		struct {
			firehose_chunk_pos_u fc_pos;
			uint64_t fc_timestamp;
			uint8_t  fc_data[FIREHOSE_CHUNK_SIZE - 8 - 8];
		};
	};
} *firehose_chunk_t;
struct firehose_chunk_range_s {
	uint16_t fcr_offset; 
	uint16_t fcr_length;
} *firehose_chunk_range_t;
struct firehose_push_reply_s {
	uint64_t fpr_mem_flushed_pos;
	uint64_t fpr_io_flushed_pos;
} firehose_push_reply_t;
struct firehose_buffer_map_info_s {
	mach_vm_address_t fbmi_addr;
	mach_vm_size_t fbmi_size;
} firehose_buffer_map_info_t;
struct firehose_trace_uuid_info_s {
	uuid_t ftui_uuid;      
	uint64_t ftui_address; 
	uint64_t ftui_size;    
	char ftui_path[];      
} *firehose_trace_uuid_info_t;
struct firehose_tracepoint_s {
	firehose_tracepoint_id_u ft_id;
	uint64_t ft_thread;
	union {
		struct {
			uint64_t ft_timestamp_delta : 48;
			uint64_t ft_length : 16;
		};
		uint64_t ft_stamp_and_length;
		os_atomic(uint64_t) ft_atomic_stamp_and_length;
	};
	uint8_t ft_data[];
} *firehose_tracepoint_t;
struct firehose_loss_payload_s {
	uint64_t start_stamp; 
	uint64_t end_stamp;
	uint32_t count;
} firehose_loss_payload_s, *firehose_loss_payload_t;
struct kxld_context {
	KXLDKext *kext;
	KXLDArray *section_order;
	KXLDArray objects;
	KXLDArray dependencies;
	KXLDDict defined_symbols_by_name;
	KXLDDict defined_cxx_symbols_by_value;
	KXLDDict obsolete_symbols_by_name;
	KXLDDict vtables_by_name;
	KXLDFlags flags;
	KXLDAllocateCallback allocate_callback;
	cpu_type_t cputype;
	cpu_subtype_t cpusubtype;
};
struct kxld_array {
	struct kxld_array_head pools;
	size_t itemsize;        
	size_t pool_capacity;   
	u_int pool_maxitems;    
	u_int nitems;           
	u_int maxitems;         
	u_int npools;           
};
struct kxld_array_pool {
	STAILQ_ENTRY(kxld_array_pool) entries;
	u_char *buffer;         
	u_int nitems;           
};
struct dict_entry {
	const void *key;
	void *value;
	DictEntryState state;
};
struct kxld_dict {
	KXLDArray buckets;      
	KXLDArray resize_buckets; 
	kxld_dict_hash hash;    
	kxld_dict_cmp cmp;      
	u_int num_entries;      
	u_int resize_threshold; 
};
struct kxld_dict_iterator {
	u_int idx;
	const KXLDDict *dict;
};
struct kxld_kext {
	KXLDObject *kext;
	KXLDObject *interface;
	KXLDArray vtables;
	KXLDDict vtable_index;
	boolean_t vtables_created;
	boolean_t vtable_index_created;
};
struct kxld_object {
	u_char *file;   
	u_long size;    
	const char *name;
	uint32_t filetype;
	cpu_type_t cputype;
	cpu_subtype_t cpusubtype;
	KXLDArray segs;
	KXLDArray sects;
	KXLDArray extrelocs;
	KXLDArray locrelocs;
	KXLDRelocator relocator;
	KXLDuuid uuid;
	KXLDversionmin versionmin;
	KXLDsrcversion srcversion;
	KXLDSymtab *symtab;
	struct dysymtab_command *dysymtab_hdr;
	KXLDsplitinfolc splitinfolc;
	splitKextLinkInfo split_info;
	kxld_addr_t link_addr;
	u_long    output_buffer_size;
	boolean_t is_kernel;
	boolean_t is_final_image;
	boolean_t is_linked;
	boolean_t got_is_created;
};
struct kxld_relocator {
	RelocHasPair reloc_has_pair;
	RelocGetPairType reloc_get_pair_type;
	RelocHasGot reloc_has_got;
	ProcessReloc process_reloc;
	const struct kxld_symtab *symtab;
	const struct kxld_array *sectarray;
	const struct kxld_dict *vtables;
	const struct kxld_vtable *current_vtable;
	u_char *file;
	u_int function_align; 
	boolean_t is_32_bit;
	boolean_t swap;
	boolean_t may_scatter;
};
struct kxld_reloc {
	u_int address;
	u_int pair_address;
	u_int target;
	u_int pair_target;
	u_int target_type:3;
	u_int pair_target_type:3;
	u_int reloc_type:4;
	u_int length:2;
	u_int pcrel:1;
};
struct kxld_sect {
	char sectname[16];          
	char segname[16];           
	u_char *data;               
	KXLDArray relocs;           
	kxld_addr_t base_addr;      
	kxld_addr_t link_addr;      
	kxld_size_t size;           
	u_int sectnum;              
	u_int flags;                
	u_int align;                
	u_int reserved1;            
	u_int reserved2;            
	boolean_t allocated;        
};
struct kxld_seg {
	char segname[16];
	kxld_addr_t base_addr;
	kxld_addr_t link_addr;
	kxld_size_t vmsize;
	kxld_size_t fileoff;
	KXLDArray sects;
	u_int flags;
	vm_prot_t maxprot;
	vm_prot_t initprot;
};
struct kxld_splitinfolc {
	uint32_t    cmdsize;
	uint32_t    dataoff;
	uint32_t    datasize;
	boolean_t   has_splitinfolc;
};
struct kxld_srcversion {
	uint64_t    version;
	boolean_t   has_srcversion;
};
struct kxld_sym {
	char *name;                   
	char *alias;                  
	kxld_addr_t base_addr;        
	kxld_addr_t link_addr;        
	kxld_addr_t got_addr;         
	uint16_t desc;
	uint8_t type;
	uint8_t sectnum;              
	uint8_t relocated_sectnum;
	u_int is_absolute:1,          
	    is_section:1,             
	    is_undefined:1,           
	    is_indirect:1,            
	    is_common:1,              
	    is_external:1,            
	    is_stab:1,                
	    is_weak:1,                
	    is_resolved:1,            
	                              
	    is_obsolete:1,            
	    is_replaced:1,            
	    is_got:1,                 
	    is_cxx:1,                 
	    is_pure_virtual:1,        
	    is_class_vtable:1,        
	    is_meta_vtable:1,         
	    is_padslot:1,             
	    is_metaclass:1,           
	    is_super_metaclass_pointer:1, 
	    is_thumb:1;               
};
struct kxld_symtab {
	KXLDArray syms;
	KXLDDict cxx_index;
	KXLDDict name_index;
	char *strings;
	u_int strsize;
	boolean_t cxx_index_initialized;
	boolean_t name_index_initialized;
};
struct kxld_symtab_iterator {
	const KXLDSymtab *symtab;
	u_int idx;
	KXLDSymPredicateTest test;
	boolean_t negate;
};
struct kxld_section_name {
	char segname[16];
	char sectname[16];
};
struct kxld_uuid {
	u_char uuid[16];
	boolean_t has_uuid;
};
struct kxld_versionmin {
	enum kxld_versionmin_platforms platform;
	uint32_t version;
	boolean_t has_versionmin;
};
struct kxld_vtable {
	u_char *vtable;
	const char *name;
	KXLDArray entries;
	boolean_t is_patched;
};
struct kxld_vtable_patched_entry {
	char *name;
	kxld_addr_t addr;
};
struct kxld_vtable_unpatched_entry {
	const struct kxld_sym *sym;
	struct kxld_reloc *reloc;
};
struct {
	int quot;
	int rem;
} div_t;
struct {
	long quot;
	long rem;
} ldiv_t;
struct {
	long long quot;
	long long rem;
} lldiv_t;
struct Block_descriptor_1 {
	uintptr_t reserved;
	uintptr_t size;
};
struct Block_descriptor_2 {
	BlockCopyFunction copy;
	BlockDisposeFunction dispose;
};
struct Block_descriptor_3 {
	const char *signature;
	const char *layout; 
};
struct Block_descriptor_small {
	uint32_t size;

	int32_t signature;
	int32_t layout;

	int32_t copy;
	int32_t dispose;
};
struct Block_layout {
	void *isa;
	volatile int32_t flags; 
	int32_t reserved;
	BlockInvokeFunction invoke;
	struct Block_descriptor_1 *descriptor;
};
struct Block_byref {
	void *isa;
	struct Block_byref *forwarding;
	volatile int32_t flags; 
	uint32_t size;
};
struct Block_byref_2 {
	BlockByrefKeepFunction byref_keep;
	BlockByrefDestroyFunction byref_destroy;
};
struct Block_byref_3 {
	const char *layout;
};
struct subs_entry_t {
	const char * substring;
	char         substitute;
} subs_entry_t;
struct splitKextLinkInfo {
	u_char *        kextExecutable; 
	size_t          kextSize;       
	u_char *        linkedKext;     
	size_t          linkedKextSize; 
	uint64_t        vmaddr_TEXT;    
	uint64_t        vmaddr_TEXT_EXEC;
	uint64_t        vmaddr_DATA;    
	uint64_t        vmaddr_DATA_CONST;
	uint64_t        vmaddr_LINKEDIT;
	uint64_t        vmaddr_LLVM_COV;
	uint32_t        kaslr_offsets_count;
	uint32_t *      kaslr_offsets;  
} splitKextLinkInfo;
struct kxld_dependency {
	u_char      * kext;
	u_long        kext_size;
	char        * kext_name;
	u_char      * interface;
	u_long        interface_size;
	char        * interface_name;
	boolean_t     is_direct_dependency;
} KXLDDependency;
struct mkext_basic_header {
	MKEXT_HEADER_CORE
} mkext_basic_header;
struct mkext2_file_entry {
	uint32_t  compressed_size;
	uint32_t  full_size;    
	uint8_t   data[0];      
} mkext2_file_entry;
struct mkext2_header {
	MKEXT_HEADER_CORE
	uint32_t plist_offset;
	uint32_t plist_compressed_size;
	uint32_t plist_full_size;
} mkext2_header;
struct mkext_file {
	uint32_t offset;     
	uint32_t compsize;   
	uint32_t realsize;   
	uint32_t modifiedsecs; 
} mkext_file;
struct mkext_kext {
	mkext_file plist;    
	mkext_file module;   
} mkext_kext;
struct mkext_header {
	MKEXT_HEADER_CORE
	mkext_kext kext[1]; 
} mkext_header;
struct _loaded_kext_summary {
	char        name[KMOD_MAX_NAME];
	uuid_t      uuid;
	uint64_t    address;
	uint64_t    size;
	uint64_t    version;
	uint32_t    loadTag;
	uint32_t    flags;
	uint64_t    reference_list;
	uint64_t    text_exec_address;
	size_t      text_exec_size;
} OSKextLoadedKextSummary;
struct _loaded_kext_summary_header {
	uint32_t version;
	uint32_t entry_size;
	uint32_t numSummaries;
	uint32_t reserved; 
	OSKextLoadedKextSummary summaries[0];
} OSKextLoadedKextSummaryHeader;
struct z_stream_s {
	Bytef    *next_in;
	uInt     avail_in;
	uLong    total_in;

	Bytef    *next_out;
	uInt     avail_out;
	uLong    total_out;

	char     *msg;  
	struct internal_state FAR *state; 

	alloc_func zalloc; 
	free_func  zfree;
	voidpf     opaque;

	int     data_type;
	uLong   adler;  
	uLong   reserved;
} z_stream;
struct gz_header_s {
	int     text;   
	uLong   time;   
	int     xflags; 
	int     os;     
	Bytef   *extra; 
	uInt    extra_len;
	uInt    extra_max;
	Bytef   *name;  
	uInt    name_max;
	Bytef   *comment;
	uInt    comm_max;
	int     hcrc;   
	int     done;   
} gz_header;
struct { unsigned long __opaque_zero; } os_atomic_dependency_t;
struct os_log_subsystem_s {
	uint16_t ols_id;
	union {
		struct {
			uint8_t ols_sub_size;
			uint8_t ols_cat_size;
		};
		uint16_t ols_sizes;
	};
	char ols_name[2 * OS_LOG_SUBSYSTEM_NAME_MAX_LEN];
};
struct os_log_s {
	struct os_log_subsystem_s   ol_subsystem;
	struct smrq_slink           ol_hash_link;
};
struct {
	uint8_t *tp_buf;
	size_t  tp_size;
} tracepoint_buf_t;
struct os_log_fmt_hdr_s {
	os_log_fmt_hdr_flags_t hdr_flags;
	uint8_t hdr_cmd_cnt;
	uint8_t hdr_data[];
} *os_log_fmt_hdr_t;
struct os_log_fmt_cmd_s {
	os_log_fmt_cmd_flags_t cmd_flags : 4;
	os_log_fmt_cmd_type_t cmd_type : 4;
	uint8_t cmd_size;
	uint8_t cmd_data[];
} *os_log_fmt_cmd_t;
struct os_log_fmt_range_s {
	uint16_t offset;
	uint16_t length : 15;
	uint16_t truncated : 1;
} *os_log_fmt_range_t;
struct os_log_context_s {
	logmem_t                    *ctx_logmem;
	uint8_t                     *ctx_buffer;
	size_t                      ctx_buffer_sz;
	os_log_fmt_hdr_t            ctx_hdr;
	char                        *ctx_pubdata[OS_LOG_MAX_PUB_ARGS];
	uint16_t                    ctx_content_off; 
	uint16_t                    ctx_content_sz; 
	uint16_t                    ctx_pubdata_sz;
	uint16_t                    ctx_pubdata_cnt;
	uint8_t                     ctx_truncated : 1;
	uint8_t                     ctx_allocated : 1;
} *os_log_context_t;
struct {
	firehose_tracepoint_id_u    lp_ftid;
	uint64_t                    lp_timestamp;
	uint16_t                    lp_pub_data_size;
	uint16_t                    lp_data_size;
	firehose_stream_t           lp_stream;
} log_payload_s, *log_payload_t;
struct logmem_s {
	lck_spin_t  lm_lock;
	uint8_t     *lm_mem;
	uint8_t     *lm_mem_map;
	size_t      lm_mem_size;
	size_t      lm_cap_order;
	size_t      lm_min_order;
	size_t      lm_max_order;
	uint32_t    lm_cnt_allocations;
	uint32_t    lm_cnt_failed_size;
	uint32_t    lm_cnt_failed_full;
	uint32_t    lm_cnt_failed_lmoff;
	uint32_t    lm_cnt_free;
} logmem_t;
struct log_queue_entry {
	STAILQ_ENTRY(log_queue_entry)   lqe_link;
	uint16_t                        lqe_size;
	uint16_t                        lqe_lm_id;
	_Atomic log_queue_entry_state_t lqe_state;
	log_payload_s                   lqe_payload;
} log_queue_entry_s, *log_queue_entry_t;
struct {
	log_queue_list_s        lq_log_list;
	log_queue_list_s        lq_dispatch_list;
	logmem_t                lq_mem[LQ_MAX_LM_SLOTS];
	size_t                  lq_mem_set;
	size_t                  lq_mem_size;
	size_t                  lq_mem_size_order;
	lq_mem_state_t          lq_mem_state;
	thread_call_t           lq_mem_handler;
	size_t                  lq_cnt_mem_active;
	size_t                  lq_cnt_mem_avail;
	size_t                  lq_cnt_mem_meta_avail;
	_Atomic lq_req_state_t  lq_req_state;
	void                    *lq_req_mem;
	uint32_t                lq_ready : 1;
	uint32_t                lq_suspend : 1;
} log_queue_s, *log_queue_t;
struct os_refcnt {
	os_ref_atomic_t ref_count;
};
struct config_s {
   ush good_length; 
   ush max_lazy;    
   ush nice_length; 
   ush max_chain;
   compress_func func;
} config;
struct static_tree_desc_s {int dummy;};
struct ct_data_s {
    union {
        ush  freq;       
        ush  code;       
    } fc;
    union {
        ush  dad;        
        ush  len;        
    } dl;
} FAR ct_data;
struct tree_desc_s {
    ct_data *dyn_tree;           
    int     max_code;            
    static_tree_desc *stat_desc; 
} FAR tree_desc;
struct internal_state {
    z_streamp strm;      
    z_input_func zinput;
    z_output_func zoutput;
    int   status;        
    Bytef *pending_buf;  
    ulg   pending_buf_size; 
    Bytef *pending_out;  
    uInt   pending;      
    int   wrap;          
    gz_headerp  gzhead;  
    uInt   gzindex;      
    Byte  method;        
    int   last_flush;    

                

    uInt  w_size;        
    uInt  w_bits;        
    uInt  w_mask;        

    Bytef *window;
    

    ulg window_size;
    

    Posf *prev;
    

    Posf *head; 

    uInt  ins_h;          
    uInt  hash_size;      
    uInt  hash_bits;      
    uInt  hash_mask;      

    uInt  hash_shift;
    

    long block_start;
    

    uInt match_length;           
    IPos prev_match;             
    int match_available;         
    uInt strstart;               
    uInt match_start;            
    uInt lookahead;              

    uInt prev_length;
    

    uInt max_chain_length;
    

    uInt max_lazy_match;
    
#   define max_insert_length  max_lazy_match
    

    int level;    
    int strategy; 

    uInt good_match;
    

    int nice_match; 

                
    
    struct ct_data_s dyn_ltree[HEAP_SIZE];   
    struct ct_data_s dyn_dtree[2*D_CODES+1]; 
    struct ct_data_s bl_tree[2*BL_CODES+1];  

    struct tree_desc_s l_desc;               
    struct tree_desc_s d_desc;               
    struct tree_desc_s bl_desc;              

    ush bl_count[MAX_BITS+1];
    

    int heap[2*L_CODES+1];      
    int heap_len;               
    int heap_max;               
    

    uch depth[2*L_CODES+1];
    

    uchf *l_buf;          

    uInt  lit_bufsize;
    

    uInt last_lit;      

    ushf *d_buf;
    

    ulg opt_len;        
    ulg static_len;     
    uInt matches;       
    int last_eob_len;   


    ush bi_buf;
    
    int bi_valid;
    

} FAR deflate_state;
struct inflate_state {
    inflate_mode mode;          
    int last;                   
    int wrap;                   
    int havedict;               
    int flags;                  
    unsigned dmax;              
    unsigned long check;        
    unsigned long total;        
    gz_headerp head;            
        
    unsigned wbits;             
    unsigned wsize;             
    unsigned whave;             
    unsigned write;             
    unsigned char FAR *window;  
        
    unsigned long hold;         
    unsigned bits;              
        
    unsigned length;            
    unsigned offset;            
        
    unsigned extra;             
        
    code const FAR *lencode;    
    code const FAR *distcode;   
    unsigned lenbits;           
    unsigned distbits;          
        
    unsigned ncode;             
    unsigned nlen;              
    unsigned ndist;             
    unsigned have;              
    code FAR *next;             
    unsigned short lens[320];   
    unsigned short work[288];   
    code codes[ENOUGH];         
};
struct {
    unsigned char op;           
    unsigned char bits;         
    unsigned short val;         
} code;
struct static_tree_desc_s {
    const ct_data *static_tree;  
    const intf *extra_bits;      
    int     extra_base;          
    int     elems;               
    int     max_length;          
};
struct internal_state      {int dummy;};
struct _OSEntitlementsInterface {
	uint32_t version;
	OSEntitlements_adjustContextWithMonitor adjustContextWithMonitor;
	OSEntitlements_adjustContextWithoutMonitor adjustContextWithoutMonitor;
	OSEntitlements_queryEntitlementBoolean queryEntitlementBoolean;
	OSEntitlements_queryEntitlementBooleanWithProc queryEntitlementBooleanWithProc;
	OSEntitlements_queryEntitlementString queryEntitlementString;
	OSEntitlements_queryEntitlementStringWithProc queryEntitlementStringWithProc;
	OSEntitlements_copyEntitlementAsOSObject copyEntitlementAsOSObject;
	OSEntitlements_copyEntitlementAsOSObjectWithProc copyEntitlementAsOSObjectWithProc;
} OSEntitlementsInterface_t;
struct _TrustCacheInterface {
	uint32_t version;
	loadModule_t loadModule;
	load_t load;
	query_t query;
	getCapabilities_t getCapabilities;
	queryGetTCType_t queryGetTCType;
	queryGetCapabilities_t queryGetCapabilities;
	queryGetHashType_t queryGetHashType;
	queryGetFlags_t queryGetFlags;
	queryGetConstraintCategory_t queryGetConstraintCategory;

	constructInvalid_t constructInvalid;
	checkRuntimeForUUID_t checkRuntimeForUUID;
	extractModule_t extractModule;
	getModule_t getModule;
	getUUID_t getUUID;
} TrustCacheInterface_t;
struct _amfi {
	amfi_OSEntitlements_invalidate OSEntitlements_invalidate;
	amfi_OSEntitlements_asDict OSEntitlements_asdict;
	amfi_OSEntitlements_query OSEntitlements_query;
	amfi_OSEntitlements_get_transmuted_blob OSEntitlements_get_transmuted;
	amfi_OSEntitlements_get_xml_blob OSEntitlements_get_xml;
	coreentitlements_t CoreEntitlements;
	amfi_get_legacy_profile_exemptions get_legacy_profile_exemptions;
	amfi_get_udid get_udid;
	amfi_query_context_to_object query_context_to_object;

	TrustCacheInterface_t TrustCache;

	OSEntitlementsInterface_t OSEntitlements;

} amfi_t;
struct _apple_encrypted_archive {
	apple_encrypted_archive_get_state_size   aea_get_state_size;
	apple_encrypted_archive_initialize_state aea_initialize_state;
	apple_encrypted_archive_open             aea_open;
	apple_encrypted_archive_write            aea_write;
	apple_encrypted_archive_close            aea_close;
} apple_encrypted_archive_t;
struct _OSUnalignedU16 {
	volatile uint16_t __val;
} __attribute__((__packed__));
struct _OSUnalignedU32 {
	volatile uint32_t __val;
} __attribute__((__packed__));
struct _OSUnalignedU64 {
	volatile uint64_t __val;
} __attribute__((__packed__));
struct list_head {
	struct list_head *prev;
	struct list_head *next;
};
struct OSKextGrabPgoStruct {
	bool metadata;
	uint64_t *pSize;
	char *pBuffer;
	uint64_t bufferSize;
	int err;
	struct list_head list_head;
};
struct OSKextAccount {
	vm_allocation_site_t site;

	uint32_t             loadTag;
	OSKext             * kext;
};
struct OSKextActiveAccount {
	uintptr_t       address;
	uintptr_t       address_end;
	OSKextAccount * account;
};
struct intrusive_osobject_retainer {
	static void
	retain(OSMetaClassBase const& obj)
	{
		obj.retain();
	}
	static void
	release(OSMetaClassBase const& obj)
	{
		obj.release();
	}
};
struct intrusive_tagged_osobject_retainer {
	static void
	retain(OSMetaClassBase const& obj)
	{
		obj.taggedRetain(OSTypeID(Tag));
	}
	static void
	release(OSMetaClassBase const& obj)
	{
		obj.taggedRelease(OSTypeID(Tag));
	}
};
struct object {
	struct object   *next;
	struct object   *free;
	struct object   *elements;
	OSObject        *object;
	OSSymbol        *key;                   
	int             size;
	void            *data;                  
	char            *string;                
	int             string_alloc_length;
	long long       number;                 
	int             idref;
} object_t;
struct parser_state {
	const char      *parseBuffer;           
	int             parseBufferIndex;       
	int             lineNumber;             
	object_t        *objects;               
	object_t        *freeObjects;           
	OSDictionary    *tags;                  
	OSString        **errorString;          
	OSObject        *parsedObject;          
	int             parsedObjectCount;
	int             retrievedObjectCount;
} parser_state_t;
struct{
	uint8_t*       dst_ptr;
	size_t         dst_size;
	const uint8_t* src_ptr;
	size_t         src_size;

	void*          state;
} compression_stream_t;
struct{
	compression_stream_init_proc                compression_stream_init;
	compression_stream_reinit_proc              compression_stream_reinit;
	compression_stream_destroy_proc             compression_stream_destroy;
	compression_stream_process_proc             compression_stream_process;
	compression_stream_identify_algorithm_proc  compression_stream_identify_algorithm;

	compression_encode_scratch_buffer_size_proc compression_encode_scratch_buffer_size;
	compression_encode_buffer_proc              compression_encode_buffer;
	compression_decode_scratch_buffer_size_proc compression_decode_scratch_buffer_size;
	compression_decode_buffer_proc              compression_decode_buffer;
} compression_ki_t;
struct _ca_event {
	struct mpsc_queue_chain link;
	const char *format_str;
	void *data;
};
struct _coretrust {
	coretrust_CTEvaluateAMFICodeSignatureCMS_t CTEvaluateAMFICodeSignatureCMS;
	coretrust_CTEvaluateAMFICodeSignatureCMSPubKey_t CTEvaluateAMFICodeSignatureCMSPubKey;
	coretrust_CTEvaluateProvisioningProfile_t CTEvaluateProvisioningProfile;
	coretrust_CTParseKey_t CTParseKey;
	coretrust_CTParseAmfiCMS_t CTParseAmfiCMS;
	coretrust_CTVerifyAmfiCMS_t CTVerifyAmfiCMS;
	coretrust_CTVerifyAmfiCertificateChain_t CTVerifyAmfiCertificateChain;
} coretrust_t;
struct{
	cccbc_ctx_decl(AES_CBC_CTX_MAX_SIZE, ctx);
} aes_decrypt_ctx;
struct{
	cccbc_ctx_decl(AES_CBC_CTX_MAX_SIZE, ctx);
} aes_encrypt_ctx;
struct{
	aes_decrypt_ctx decrypt;
	aes_encrypt_ctx encrypt;
} aes_ctx;
struct {
	ccxts_ctx_decl(AES_XTS_CTX_MAX_SIZE, enc);
	ccxts_ctx_decl(AES_XTS_CTX_MAX_SIZE, dec);
} symmetric_xts;
struct{
	ccecb_ctx_decl(DES_ECB_CTX_MAX_SIZE, enc);
	ccecb_ctx_decl(DES_ECB_CTX_MAX_SIZE, dec);
} des_ecb_key_schedule;
struct{
	ccecb_ctx_decl(DES3_ECB_CTX_MAX_SIZE, enc);
	ccecb_ctx_decl(DES3_ECB_CTX_MAX_SIZE, dec);
} des3_ecb_key_schedule;
struct {
	u_int32_t state[4];     
	u_int32_t count[2];     
	unsigned char buffer[64];       
} MD5_CTX;
struct ccchacha20poly1305_fns {
	const struct ccchacha20poly1305_info *(*info)(void);
	int (*init)(const struct ccchacha20poly1305_info *info, ccchacha20poly1305_ctx *ctx, const uint8_t *key);
	int (*reset)(const struct ccchacha20poly1305_info *info, ccchacha20poly1305_ctx *ctx);
	int (*setnonce)(const struct ccchacha20poly1305_info *info, ccchacha20poly1305_ctx *ctx, const uint8_t *nonce);
	int (*incnonce)(const struct ccchacha20poly1305_info *info, ccchacha20poly1305_ctx *ctx, uint8_t *nonce);
	int (*aad)(const struct ccchacha20poly1305_info *info, ccchacha20poly1305_ctx *ctx, size_t nbytes, const void *aad);
	int (*encrypt)(const struct ccchacha20poly1305_info *info, ccchacha20poly1305_ctx *ctx, size_t nbytes, const void *ptext, void *ctext);
	int (*finalize)(const struct ccchacha20poly1305_info *info, ccchacha20poly1305_ctx *ctx, uint8_t *tag);
	int (*decrypt)(const struct ccchacha20poly1305_info *info, ccchacha20poly1305_ctx *ctx, size_t nbytes, const void *ctext, void *ptext);
	int (*verify)(const struct ccchacha20poly1305_info *info, ccchacha20poly1305_ctx *ctx, const uint8_t *tag);
} *ccchacha20poly1305_fns_t;
struct crypto_functions {
	ccdigest_init_fn_t ccdigest_init_fn;
	ccdigest_update_fn_t ccdigest_update_fn;
	ccdigest_final_fn_t ccdigest_final_fn;
	ccdigest_fn_t ccdigest_fn;
	const struct ccdigest_info * ccmd5_di;
	const struct ccdigest_info * ccsha1_di;
	const struct ccdigest_info * ccsha256_di;
	const struct ccdigest_info * ccsha384_di;
	const struct ccdigest_info * ccsha512_di;

	cchmac_init_fn_t cchmac_init_fn;
	cchmac_update_fn_t cchmac_update_fn;
	cchmac_final_fn_t cchmac_final_fn;
	cchmac_fn_t cchmac_fn;

	const struct ccmode_ecb *ccaes_ecb_encrypt;
	const struct ccmode_ecb *ccaes_ecb_decrypt;
	const struct ccmode_cbc *ccaes_cbc_encrypt;
	const struct ccmode_cbc *ccaes_cbc_decrypt;
	const struct ccmode_ctr *ccaes_ctr_crypt;
	const struct ccmode_xts *ccaes_xts_encrypt;
	const struct ccmode_xts *ccaes_xts_decrypt;
	const struct ccmode_gcm *ccaes_gcm_encrypt;
	const struct ccmode_gcm *ccaes_gcm_decrypt;

	ccgcm_init_with_iv_fn_t ccgcm_init_with_iv_fn;
	ccgcm_inc_iv_fn_t ccgcm_inc_iv_fn;

	ccchacha20poly1305_fns_t ccchacha20poly1305_fns;

	const struct ccmode_ecb *ccdes_ecb_encrypt;
	const struct ccmode_ecb *ccdes_ecb_decrypt;
	const struct ccmode_cbc *ccdes_cbc_encrypt;
	const struct ccmode_cbc *ccdes_cbc_decrypt;
	const struct ccmode_ecb *cctdes_ecb_encrypt;
	const struct ccmode_ecb *cctdes_ecb_decrypt;
	const struct ccmode_cbc *cctdes_cbc_encrypt;
	const struct ccmode_cbc *cctdes_cbc_decrypt;
	ccdes_key_is_weak_fn_t ccdes_key_is_weak_fn;
	ccdes_key_set_odd_parity_fn_t ccdes_key_set_odd_parity_fn;
	ccpad_cts3_crypt_fn_t ccpad_cts3_encrypt_fn;
	ccpad_cts3_crypt_fn_t ccpad_cts3_decrypt_fn;

	ccrng_fn_t ccrng_fn;

	ccrsa_make_pub_fn_t        ccrsa_make_pub_fn;
	ccrsa_verify_pkcs1v15_fn_t ccrsa_verify_pkcs1v15_fn;

	crypto_random_generate_fn_t random_generate_fn;
	crypto_random_uniform_fn_t random_uniform_fn;
	crypto_random_kmem_ctx_size_fn_t random_kmem_ctx_size_fn;
	crypto_random_kmem_init_fn_t random_kmem_init_fn;

	crypto_digest_ctx_size_fn_t digest_ctx_size_fn;
	crypto_digest_init_fn_t digest_init_fn;
	crypto_digest_update_fn_t digest_update_fn;
	crypto_digest_final_fn_t digest_final_fn;
	crypto_digest_fn_t digest_fn;

	crypto_hmac_ctx_size_fn_t hmac_ctx_size_fn;
	crypto_hmac_init_fn_t hmac_init_fn;
	crypto_hmac_update_fn_t hmac_update_fn;
	crypto_hmac_final_generate_fn_t hmac_final_generate_fn;
	crypto_hmac_final_verify_fn_t hmac_final_verify_fn;
	crypto_hmac_generate_fn_t hmac_generate_fn;
	crypto_hmac_verify_fn_t hmac_verify_fn;
} *crypto_functions_t;
struct{
	ccrsa_pub_ctx_decl(ccn_sizeof(RSA_MAX_KEY_BITSIZE), key);
} rsa_pub_ctx;
struct sha1_ctxt {
	union {
		u_int8_t        b8[20];
		u_int32_t       b32[5]; 
	} h;
	union {
		u_int8_t        b8[8];
		u_int32_t       b32[2];
		u_int64_t       b64[1]; 
	} c;
	union {
		u_int8_t        b8[64];
		u_int32_t       b32[16]; 
	} m;
	u_int8_t        count;          
} SHA1_CTX;
struct {
	ccdigest_ctx_decl(CCSHA256_STATE_SIZE, CCSHA256_BLOCK_SIZE, ctx);
} SHA256_CTX;
struct SHA512_CTX {
	ccdigest_ctx_decl(CCSHA512_STATE_SIZE, CCSHA512_BLOCK_SIZE, ctx);
} SHA512_CTX;
struct _image4_dlxk_interface {
	image4_struct_version_t dlxk_version;
	image4_xnu_dlxk_fld_decl(coprocessor_host);
	image4_xnu_dlxk_fld_decl(coprocessor_ap);
	image4_xnu_dlxk_fld_decl(coprocessor_ap_local);
	image4_xnu_dlxk_fld_decl(coprocessor_cryptex1);
	image4_xnu_dlxk_fld_decl(coprocessor_sep);
	image4_xnu_dlxk_fld_decl(coprocessor_x86);
	image4_xnu_dlxk_fld_decl(environment_init);
	image4_xnu_dlxk_fld_decl(environment_new);
	image4_xnu_dlxk_fld_decl(environment_set_secure_boot);
	image4_xnu_dlxk_fld_decl(environment_set_callbacks);
	image4_xnu_dlxk_fld_decl(environment_copy_nonce_digest);
	image4_xnu_dlxk_fld_decl(environment_roll_nonce);
	image4_xnu_dlxk_fld_decl(environment_generate_nonce_proposal);
	image4_xnu_dlxk_fld_decl(environment_commit_nonce_proposal);
	image4_xnu_dlxk_fld_decl(environment_get_nonce_handle);
	image4_xnu_dlxk_fld_decl(environment_destroy);
	image4_xnu_dlxk_fld_decl(trust_init);
	image4_xnu_dlxk_fld_decl(trust_new);
	image4_xnu_dlxk_fld_decl(trust_set_payload);
	image4_xnu_dlxk_fld_decl(trust_set_booter);
	image4_xnu_dlxk_fld_decl(trust_record_property_bool);
	image4_xnu_dlxk_fld_decl(trust_record_property_integer);
	image4_xnu_dlxk_fld_decl(trust_record_property_data);
	image4_xnu_dlxk_fld_decl(trust_evaluate);
	image4_xnu_dlxk_fld_decl(trust_destroy);
	image4_xnu_dlxk_fld_decl(trust_evaluation_exec);
	image4_xnu_dlxk_fld_decl(trust_evaluation_preflight);
	image4_xnu_dlxk_fld_decl(trust_evaluation_sign);
	image4_xnu_dlxk_fld_decl(trust_evaluation_boot);
	image4_xnu_dlxk_fld_decl(cs_trap_resolve_handler);
	image4_xnu_dlxk_fld_decl(cs_trap_vector_size);
	image4_xnu_dlxk_fld_decl(trust_evaluation_normalize);
	image4_xnu_dlxk_fld_decl(environment_identify);
	image4_xnu_dlxk_fld_decl(environment_get_digest_info);
	image4_xnu_dlxk_fld_decl(environment_flash);
	image4_xnu_dlxk_fld_decl(coprocessor_resolve_from_manifest);
	image4_xnu_dlxk_fld_decl(coprocessor_bootpc);
	image4_xnu_dlxk_fld_decl(coprocessor_vma2);
	image4_xnu_dlxk_fld_decl(coprocessor_vma3);
} image4_dlxk_interface_t;
struct _img4_interface {
	const uint32_t i4if_version;
	img4_retired_t i4if_init;
	img4_retired_t i4if_set_nonce;
	img4_retired_t i4if_get_trusted_payload;
	img4_retired_t i4if_get_trusted_external_payload;
	img4_retired_t i4if_destroy;
	img4_retired_t i4if_payload_init;
	img4_retired_t i4if_payload_destroy;
	img4_retired_t i4if_environment_platform;
	img4_retired_t i4if_environment_reserved;
	img4_retired_t i4if_environment_trust_cache;
	struct {
		img4_retired_t set_nonce_domain;
		img4_nonce_domain_copy_nonce_t nonce_domain_copy_nonce;
		img4_nonce_domain_roll_nonce_t nonce_domain_roll_nonce;
		const img4_nonce_domain_t *nonce_domain_trust_cache;
	} i4if_v1;
	struct {
		img4_retired_t payload_init_with_vnode_4xnu;
	} i4if_v2;
	struct {
		const img4_nonce_domain_t *nonce_domain_pdi;
		const img4_nonce_domain_t *nonce_domain_cryptex;
	} i4if_v3;
	struct {
		img4_retired_t environment_init_identity;
	} i4if_v4;
	struct {
		img4_retired_t environment_t2;
		img4_retired_t environment_init_from_identity;
		img4_retired_t identity_init_from_environment;
	} i4if_v5;
	struct {
		img4_retired_t environment_x86;
	} i4if_v6;
	struct {
		const img4_chip_t *chip_ap_sha1;
		const img4_chip_t *chip_ap_sha2_384;
		const img4_chip_t *chip_ap_hybrid;
		const img4_chip_t *chip_ap_reduced;
		const img4_chip_t *chip_ap_software_ff00;
		const img4_chip_t *chip_ap_software_ff01;
		const img4_chip_t *chip_x86;
		const img4_chip_t *chip_x86_software_8012;
		img4_chip_init_from_buff_t chip_init_from_buff;
		img4_chip_select_personalized_ap_t chip_select_personalized_ap;
		img4_chip_select_effective_ap_t chip_select_effective_ap;
		img4_chip_instantiate_t chip_instantiate;
		img4_chip_custom_t chip_custom;
		img4_firmware_new_t firmware_new;
		img4_firmware_new_from_vnode_4xnu_t firmware_new_from_vnode_4xnu;
		img4_firmware_init_from_buff_t firmware_init_from_buff;
		img4_firmware_init_t firmware_init;
		img4_firmware_attach_manifest_t firmware_attach_manifest;
		img4_firmware_execute_t firmware_execute;
		img4_firmware_destroy_t firmware_destroy;
		img4_image_get_bytes_t image_get_bytes;
		img4_image_get_property_bool_t image_get_property_bool;
		img4_image_get_property_uint32_t image_get_property_uint32;
		img4_image_get_property_uint64_t image_get_property_uint64;
		img4_image_get_property_data_t image_get_property_data;
		const img4_object_spec_t *firmware_spec;
		const img4_object_spec_t *chip_spec;
		const img4_runtime_t *runtime_default;
		const img4_runtime_t *runtime_pmap_cs;
		img4_buff_dealloc_t buff_dealloc;
	} i4if_v7;
	struct {
		const img4_chip_t *chip_ap_permissive;
		const img4_chip_t *chip_ap_hybrid_medium;
		const img4_chip_t *chip_ap_hybrid_relaxed;
	} i4if_v8;
	struct {
		img4_firmware_evaluate_t firmware_evaluate;
	} i4if_v9;
	struct {
		img4_firmware_select_chip_t firmware_select_chip;
	} i4if_v10;
	struct {
		
		
		
		
		
		
		
		const img4_chip_t *chip_ap_datacenter_development;
		const img4_chip_t *chip_ap_intransigent;
		const img4_chip_t *chip_ap_category;
		const img4_chip_t *chip_ap_ddi;
		const img4_chip_t *chip_ap_developer_disk_image;
		const img4_chip_t *chip_ap_software_ff06;
		const img4_chip_t *chip_ap_supplemental;
		const img4_runtime_object_spec_t *runtime_object_spec_supplemental_root;
		img4_runtime_find_object_spec_t runtime_find_object_spec;
		img4_runtime_execute_object_t runtime_execute_object;
		img4_runtime_copy_object_t runtime_copy_object;
	} i4if_v11;
	struct {
		const img4_nonce_domain_t *nonce_domain_ddi;
		const img4_nonce_domain_t *nonce_domain_ephemeral_cryptex;
		const img4_chip_t *chip_ap_category_ff02;
		const img4_chip_t *chip_ap_category_ff03;
		const img4_chip_t *chip_ap_category_ff04_f0;
		const img4_chip_t *chip_ap_category_ff04_f1;
		const img4_chip_t *chip_ap_category_ff04_f2;
		const img4_chip_t *chip_ap_category_ff04_f3;
		img4_chip_select_personalized_ap_t chip_select_categorized_ap;
	} i4if_v12;
	struct {
		const img4_chip_t *chip_ap_vma2;
		const img4_chip_t *chip_ap_vma2_clone;
		const img4_object_spec_t *pmap_data_spec;
	} i4if_v13;
	struct {
		img4_nonce_domain_preroll_nonce_t nonce_domain_preroll_nonce;
	} i4if_v14;
	struct {
		img4_get_manifest_t get_manifest;
		img4_get_payload_t get_payload;
	} i4if_v15;
	struct {
		img4_chip_select_personalized_ap_t chip_select_personalized_sep;
		const img4_nonce_domain_t *nonce_domain_cryptex1_boot;
		const img4_nonce_domain_t *nonce_domain_cryptex1_asset;
	} i4if_v16;
	struct {
		img4_chip_select_personalized_ap_t chip_select_cryptex1_boot;
		img4_chip_select_personalized_ap_t chip_select_cryptex1_preboot;
		const img4_chip_t *chip_cryptex1_boot;
		const img4_chip_t *chip_cryptex1_boot_reduced;
		const img4_chip_t *chip_cryptex1_boot_x86;
		const img4_chip_t *chip_cryptex1_boot_vma2;
		const img4_chip_t *chip_cryptex1_preboot;
		const img4_chip_t *chip_cryptex1_preboot_reduced;
		const img4_chip_t *chip_cryptex1_preboot_x86;
		const img4_chip_t *chip_cryptex1_preboot_vma2;
		const img4_chip_t *chip_cryptex1_asset;
	} i4if_v17;
	struct {
		const img4_nonce_domain_t *nonce_domain_cryptex1_snuf_stub;
		const img4_chip_t *chip_cryptex1_asset_x86;
		const img4_chip_t *chip_cryptex1_boot_proposal;
		const img4_chip_t *chip_cryptex1_boot_reduced_proposal;
		const img4_chip_t *chip_cryptex1_boot_vma2_proposal;
		const img4_chip_t *chip_cryptex1_boot_vma2_clone_proposal;
		img4_chip_get_cryptex1_boot_t chip_get_cryptex1_boot;
		img4_chip_get_cryptex1_boot_t chip_get_cryptex1_boot_proposal;
		img4_image_get_property_bool_t image_get_entitlement_bool;
		img4_image_get_property_uint32_t image_get_entitlement_uint32;
		img4_image_get_property_uint64_t image_get_entitlement_uint64;
		img4_image_get_property_data_t image_get_entitlement_data;
		const img4_runtime_object_spec_t *runtime_object_spec_local_policy;
		const img4_chip_t *chip_ap_local_blessed;
	} i4if_v18;
	struct {
		img4_nonce_domain_peek_nonce_t nonce_domain_peek_nonce;
		const img4_chip_t *chip_cryptex1_boot_relaxed_x86;
		const img4_chip_t *chip_cryptex1_preboot_relaxed_x86;
		const img4_chip_t *chip_cryptex1_boot_static_x86;
		const img4_chip_t *chip_cryptex1_preboot_static_x86;
	} i4if_v19;
	struct {
		img4_nonce_domain_get_from_handle_t nonce_domain_get_from_handle;
		const img4_chip_t *chip_cryptex1_generic;
		const img4_chip_t *chip_cryptex1_generic_supplemental;
		const img4_chip_t *chip_cryptex1_generic_x86;
	} i4if_v20;
} img4_interface_t;
struct {
	uint32_t    base_bucket_width;
	uint32_t    scale_flag;       
	uint32_t    segment_idx;      
	uint32_t    segment_bucket_count;
} __attribute((packed)) IOHistogramSegmentConfig;
struct {
	uint64_t    samples;
	uint64_t    mean;
	uint64_t    variance;
	uint64_t    reserved;
} __attribute((packed)) IONormDistReportValues;
struct {
	int64_t    simple_value;
	uint64_t    reserved1;
	uint64_t    reserved2;
	uint64_t    reserved3;
} __attribute((packed)) IOSimpleReportValues;
struct {
	int64_t    simple_values[IOR_VALUES_PER_ELEMENT];
} __attribute((packed)) IOSimpleArrayReportValues;
struct {
	uint64_t    state_id;       
	uint64_t    intransitions;  
	uint64_t    upticks;        
	uint64_t    last_intransition;
} __attribute((packed)) IOStateReportValues;
struct {
	uint64_t    bucket_hits;
	int64_t     bucket_min;
	int64_t     bucket_max;
	int64_t     bucket_sum;
} __attribute((packed)) IOHistogramReportValues;
struct {
	uint8_t     report_format;  
	uint8_t     reserved;       
	uint16_t    categories;     
	uint16_t    nelements;      

	int16_t     element_idx;    
	                            
} __attribute((packed)) IOReportChannelType;
struct {
	uint64_t                channel_id;
	IOReportChannelType     channel_type;
} IOReportChannel;
struct {
	uint32_t                nchannels;
	IOReportChannel         channels[];
} IOReportChannelList;
struct {
	uint64_t                provider_id;
	IOReportChannel         channel;
} IOReportInterest;
struct {
	uint32_t                ninterests;
	IOReportInterest        interests[];
} IOReportInterestList;
struct {
	uint64_t                v[IOR_VALUES_PER_ELEMENT];
} __attribute((packed)) IOReportElementValues;
struct {
	uint64_t                provider_id;
	uint64_t                channel_id;
	IOReportChannelType     channel_type;
	uint64_t                timestamp;
	IOReportElementValues   values;
} __attribute((packed)) IOReportElement;
struct IORPCMessageMach {
	mach_msg_header_t          msgh;
	mach_msg_body_t            msgh_body;
	mach_msg_port_descriptor_t objects[0];
};
struct IORPCMessage {
	uint64_t         msgid;
	uint64_t         flags;
	uint64_t         objectRefs;
	OSObjectRef      objects[0];
};
struct IORPCMessageErrorReturnContent {
	IORPCMessage  hdr;
	kern_return_t result;
	uint32_t      pad;
};
struct IORPCMessageErrorReturn {
	IORPCMessageMach mach;
	IORPCMessageErrorReturnContent content;
};
struct IORPC {
	IORPCMessageMach * message;
	IORPCMessageMach * reply;
	uint32_t           sendSize;
	uint32_t           replySize;
	IORPCMessage     * kernelContent;
};
struct OSClassDescription {
	uint32_t    descriptionSize;

	char        name[96];
	char        superName[96];

	uint32_t    methodOptionsSize;
	uint32_t    methodOptionsOffset;
	uint32_t    metaMethodOptionsSize;
	uint32_t    metaMethodOptionsOffset;
	uint32_t    queueNamesSize;
	uint32_t    queueNamesOffset;
	uint32_t    methodNamesSize;
	uint32_t    methodNamesOffset;
	uint32_t    metaMethodNamesSize;
	uint32_t    metaMethodNamesOffset;

	uint64_t    flags;

	uint64_t    resv1[8];

	uint64_t    methodOptions[0];
	uint64_t    metaMethodOptions[0];

	char        dispatchNames[0];
	char        methodNames[0];
	char        metaMethodNames[0];
};
struct{
	IOPhysicalAddress   address;
	IOByteCount         length;
} IOPhysicalRange;
struct{
	IOVirtualAddress    address;
	IOByteCount         length;
} IOVirtualRange;
struct {
	int value;
	const char *name;
} IONamedValue;
struct queue_entry {
	struct queue_entry      *next;          
	struct queue_entry      *prev;          
};
struct aks_raw_key_t {
	uint32_t  keybytecount;
	uint8_t   keybytes[AKS_MAX_KEY_SIZE];
};
struct aks_volume_key_t {
	uint32_t      algorithm;
	aks_raw_key_t key;
};
struct _notifyMsg {
	mach_msg_header_t h;
};
struct _IODataQueueEntry {
	UInt32  size;
	UInt8   data[4];
} IODataQueueEntry;
struct _IODataQueueMemory {
	UInt32            queueSize;
	volatile UInt32   head;
	volatile UInt32   tail;
	IODataQueueEntry  queue[1];
} IODataQueueMemory;
struct _IODataQueueAppendix {
	UInt32            version;
	mach_msg_header_t msgh;
} IODataQueueAppendix;
struct IONVRAMDescriptor {
	unsigned int format:4;
	unsigned int marker:1;
	unsigned int bridgeCount:3;
	unsigned int busNum:2;
	unsigned int bridgeDevices:6 * 5;
	unsigned int functionNum:3;
	unsigned int deviceNum:5;
} __attribute__((aligned(2), packed));
struct IOHibernateHibSegment {
	uint32_t    iBootMemoryRegion;
	uint32_t    physPage;
	uint32_t    pageCount;
	uint32_t    protection;
};
struct IOHibernateHibSegInfo {
	struct IOHibernateHibSegment    segments[NUM_HIBSEGINFO_SEGMENTS];
	uint8_t                         hmac[HIBERNATE_HMAC_SIZE];
};
struct IOPolledFileExtent {
	uint64_t    start;
	uint64_t    length;
};
struct {
	IOHibernateHibSegment hib_segments[NUM_HIBSEGINFO_SEGMENTS];

	uint64_t dram_base;
	uint64_t dram_size;

	uint64_t dt_start_paddr;

	uint64_t dt_size;

	uint64_t sptm_entry_phys;

	uint32_t sptm_phys_page;
	uint32_t sptm_page_count;

	uint64_t sptm_ro_start_phys;
	uint64_t xnu_ro_start_phys;
	uint64_t txm_ro_start_phys;
	uint64_t sptm_ro_start_virt;
	uint64_t xnu_ro_start_virt;
	uint64_t txm_ro_start_virt;

	uint64_t sptm_rm_start_phys;
	uint64_t sptm_rm_end_phys;
	uint64_t sptm_le_end_phys;

	uint64_t consistent_debug_page_phys;

	uint64_t early_debug_consistent_debug_page;
	uint64_t global_debug_consistent_debug_page;

	uint64_t sptm_slide;

	uint64_t ctrr_a_begin;
	uint64_t ctrr_a_end;
	uint64_t ctrr_c_begin;
	uint64_t ctrr_c_end;
	uint64_t ctrr_d_begin;
	uint64_t ctrr_d_end;

	uint64_t hibtext_stack_top;

} hib_protected_metadata_t;
struct hib_exclave_iv {
	uint8_t iv[CCGCM_IV_NBYTES];
	uint8_t tag[CCGCM_BLOCK_NBYTES];
};
struct IOHibernateImageHeader {
	uint64_t    imageSize;
	uint64_t    image1Size;

	uint32_t    restore1CodePhysPage;
	uint32_t    reserved1;
	uint64_t    restore1CodeVirt;
	uint32_t    restore1PageCount;
	uint32_t    restore1CodeOffset;
	uint32_t    restore1StackOffset;

	uint32_t    pageCount;
	uint32_t    bitmapSize;

	uint32_t    restore1Sum;
	uint32_t    image1Sum;
	uint32_t    image2Sum;

	uint32_t    actualRestore1Sum;
	uint32_t    actualImage1Sum;
	uint32_t    actualImage2Sum;

	uint32_t    actualUncompressedPages;
	uint32_t    conflictCount;
	uint32_t    nextFree;

	uint32_t    signature;
	uint32_t    processorFlags;

	uint32_t    runtimePages;
	uint32_t    runtimePageCount;
	uint64_t    runtimeVirtualPages __attribute__ ((packed));

	uint32_t    performanceDataStart;
	uint32_t    performanceDataSize;

	uint64_t    encryptStart __attribute__ ((packed));
	uint64_t    machineSignature __attribute__ ((packed));

	uint32_t    previewSize;
	uint32_t    previewPageListSize;

	uint32_t    diag[4];

	uint32_t    handoffPages;
	uint32_t    handoffPageCount;

	uint32_t    systemTableOffset;

	uint32_t    debugFlags;
	uint32_t    options;
	uint64_t    sleepTime __attribute__ ((packed));
	uint32_t    compression;

	uint8_t     bridgeBootSessionUUID[16];

	uint64_t    lastHibAbsTime __attribute__ ((packed));
	union {
		uint64_t    lastHibContTime;
		uint64_t    hwClockOffset;
	} __attribute__ ((packed));
	uint64_t    kernVirtSlide __attribute__ ((packed));

	uint32_t    reserved[45];

	uint64_t    kernelSlide __attribute__ ((packed));      

	uint32_t    booterTime0;
	uint32_t    booterTime1;
	uint32_t    booterTime2;

	uint32_t    booterStart;
	uint32_t    smcStart;
	uint32_t    connectDisplayTime;
	uint32_t    splashTime;
	uint32_t    booterTime;
	uint32_t    trampolineTime;

	uint64_t    encryptEnd __attribute__ ((packed));
	uint64_t    deviceBase __attribute__ ((packed));
	uint32_t    deviceBlockSize;


	uint32_t    segmentsFileOffset;

	uint32_t    imageHeaderHMACSize;
	uint8_t     imageHeaderHMAC[HIBERNATE_HMAC_SIZE];

	uint8_t     handoffHMAC[HIBERNATE_HMAC_SIZE];

	uint8_t     image1PagesHMAC[HIBERNATE_HMAC_SIZE];
	uint8_t     image2PagesHMAC[HIBERNATE_HMAC_SIZE];

	IOHibernateHibSegInfo hibSegInfo;

	uint8_t     rorgnHMAC[HIBERNATE_HMAC_SIZE];
	uint8_t     rorgnSHA256[HIBERNATE_SHA256_SIZE];

	hib_protected_metadata_t protected_metadata;

	uint8_t     protected_metadata_hmac[HIBERNATE_HMAC_SIZE];

	uint8_t     sptm_rorgn_hmac[HIBERNATE_HMAC_SIZE];

	uint8_t     xnu_rorgn_hmac[HIBERNATE_HMAC_SIZE];

	uint8_t     hib_segs_hmac[HIBERNATE_HMAC_SIZE];

	struct hib_exclave_iv exclave_iv;

	uint32_t            fileExtentMapSize;
	IOPolledFileExtent  fileExtentMap[2];
};
struct hibernate_bitmap_t {
	uint32_t    first_page;
	uint32_t    last_page;
	uint32_t    bitmapwords;
	uint32_t    bitmap[0];
};
struct hibernate_page_list_t {
	uint32_t              list_size;
	uint32_t              page_count;
	uint32_t              bank_count;
	hibernate_bitmap_t    bank_bitmap[0];
};
struct IOHibernateHandoff {
	uint32_t type;
	uint32_t bytecount;
	uint8_t  data[];
};
struct hibernate_graphics_t {
	uint64_t physicalAddress; 
	int32_t  gfxStatus;     
	uint32_t rowBytes;              
	uint32_t width;                 
	uint32_t height;                
	uint32_t depth;                 

	uint8_t progressSaveUnder[kIOHibernateProgressCount][kIOHibernateProgressSaveUnderSize];
};
struct hibernate_preview_t {
	uint32_t  imageCount;   
	uint32_t  width;        
	uint32_t  height;       
	uint32_t  depth;        
	uint64_t  lockTime;     
	uint32_t  reservedG[7]; 
	uint32_t  reservedK[8]; 
};
struct hibernate_statistics_t {
	uint64_t image1Size;
	uint64_t imageSize;
	uint32_t image1Pages;
	uint32_t imagePages;
	uint32_t booterStart;
	uint32_t smcStart;
	uint32_t booterDuration;
	uint32_t booterConnectDisplayDuration;
	uint32_t booterSplashDuration;
	uint32_t booterDuration0;
	uint32_t booterDuration1;
	uint32_t booterDuration2;
	uint32_t trampolineDuration;
	uint32_t kernelImageReadDuration;

	uint32_t graphicsReadyTime;
	uint32_t wakeNotificationTime;
	uint32_t lockScreenReadyTime;
	uint32_t hidReadyTime;

	uint32_t wakeCapability;
	uint32_t hibCount;
	uint32_t resvA[14];
};
struct hibernate_scratch {
	uint8_t  *curPage;
	size_t    curPagePos;
	uint64_t  curPos;
	uint64_t  totalLength;
	ppnum_t  headPage;
	hibernate_page_list_t *map;
	uint32_t *nextFree;
};
struct IOInterruptAccountingData {
	OSObject * owner; 
	queue_chain_t chain;
	int interruptIndex;

	bool enablePrimaryTimestamp;
	volatile uint64_t primaryTimestamp __attribute__((aligned(8)));

	volatile uint64_t interruptStatistics[IA_NUM_INTERRUPT_ACCOUNTING_STATISTICS] __attribute__((aligned(8)));
};
struct IOInterruptVector {
	volatile char               interruptActive;
	volatile char               interruptDisabledSoft;
	volatile char               interruptDisabledHard;
	volatile char               interruptRegistered;
	IOLock *                    interruptLock;
	IOService *                 nub;
	int                         source;
	void *                      target;
	IOInterruptHandler          handler;
	void *                      refCon;
	IOSharedInterruptController *sharedController;
};
struct {
	uint32_t    base_bucket_width;
	uint32_t    scale_flag;       
	uint32_t    segment_idx;      
	uint32_t    segment_bucket_count;
} __attribute((packed)) IOHistogramSegmentConfig;
struct {
	uint64_t    samples;
	uint64_t    mean;
	uint64_t    variance;
	uint64_t    reserved;
} __attribute((packed)) IONormDistReportValues;
struct IOKitDiagnosticsParameters {
	size_t    size;
	uint64_t  value;
	uint32_t  options;
	uint32_t  tag;
	uint32_t  zsize;
	uint32_t  reserved[8];
};
struct IOTrackingCallSiteInfo {
	uint32_t          count;
	pid_t             addressPID;
	mach_vm_address_t address;
	mach_vm_size_t    size[2];
	pid_t             btPID;
	mach_vm_address_t bt[2][kIOTrackingCallSiteBTs];
};
struct _IOUCProcessToken {
	void *  token;
	UInt32  pid;
} IOUCProcessToken;
struct IODMAMapSpecification {
	uint64_t    alignment;
	IOService * device;
	uint32_t    options;
	uint8_t     numAddressBits;
	uint8_t     resvA[3];
	uint32_t    resvB[4];
};
struct IODMAMapPageList {
	uint32_t                pageOffset;
	uint32_t                pageListCount;
	const upl_page_info_t * pageList;
};
struct IOMDDMACharacteristics {
	UInt64 fLength;
	UInt32 fSGCount;
	UInt32 fPages;
	UInt32 fPageAlign;
	ppnum_t fHighestPage;
	IODirection fDirection;
	UInt8 fIsPrepared;
};
struct IOMDDMAMapArgs {
	IOMapper            * fMapper;
	IODMACommand        * fCommand;
	IODMAMapSpecification fMapSpec;
	uint64_t              fOffset;
	uint64_t              fLength;
	uint64_t              fAlloc;
	uint64_t              fAllocLength;
};
struct IOMDDMAWalkSegmentArgs {
	UInt64 fOffset;                 
	UInt64 fIOVMAddr, fLength;
	UInt8 fMapped;                  
	UInt64 fMappedBase;             
};
struct IOPolledFileIOVars {
	IOPolledFilePollers              *  pollers;
	struct kern_direct_file_io_ref_t *  fileRef;
	OSData *                            fileExtents;
	uint64_t                            block0;
	uint32_t                         blockSize;
	uint64_t                            maxiobytes;
	uint32_t                         bufferLimit;
	uint8_t *                           buffer;
	uint32_t                         bufferSize;
	uint32_t                         bufferOffset;
	uint32_t                         bufferHalf;
	uint64_t                         extentRemaining;
	uint32_t                         lastRead;
	uint64_t                         readEnd;
	uint32_t                            flags;
	uint64_t                            fileSizeMin;
	uint64_t                            fileSizeMax;
	uint64_t                            fileSize;
	uint64_t                            position;
	uint64_t                            extentPosition;
	uint64_t                            encryptStart;
	uint64_t                            encryptEnd;
	uint64_t                            cryptBytes;
	AbsoluteTime                        cryptTime;
	IOPolledFileExtent *                extentMap;
	IOPolledFileExtent *                currentExtent;
	bool                                allocated;
};
struct IOPolledFileCryptVars {
	uint8_t aes_iv[AES_BLOCK_SIZE];
	aes_ctx ctx;
};
struct {
	uint16_t        curr_state;
	uint64_t        update_ts;
	IOReportElement elem[]; 
} IOStateReportInfo;
struct {
	int             bucketWidth;
	IOReportElement elem[]; 
} IOHistReportInfo;
struct {
	int64_t    simple_value;
	uint64_t    reserved1;
	uint64_t    reserved2;
	uint64_t    reserved3;
} __attribute((packed)) IOSimpleReportValues;
struct {
	int64_t    simple_values[IOR_VALUES_PER_ELEMENT];
} __attribute((packed)) IOSimpleArrayReportValues;
struct {
	uint64_t    state_id;       
	uint64_t    intransitions;  
	uint64_t    upticks;        
	uint64_t    last_intransition;
} __attribute((packed)) IOStateReportValues;
struct {
	uint64_t    bucket_hits;
	int64_t     bucket_min;
	int64_t     bucket_max;
	int64_t     bucket_sum;
} __attribute((packed)) IOHistogramReportValues;
struct {
	uint8_t     report_format;  
	uint8_t     reserved;       
	uint16_t    categories;     
	uint16_t    nelements;      

	int16_t     element_idx;    
	                            
} __attribute((packed)) IOReportChannelType;
struct {
	uint64_t                channel_id;
	IOReportChannelType     channel_type;
} IOReportChannel;
struct {
	uint32_t                nchannels;
	IOReportChannel         channels[];
} IOReportChannelList;
struct {
	uint64_t                provider_id;
	IOReportChannel         channel;
} IOReportInterest;
struct {
	uint32_t                ninterests;
	IOReportInterest        interests[];
} IOReportInterestList;
struct {
	uint64_t                v[IOR_VALUES_PER_ELEMENT];
} __attribute((packed)) IOReportElementValues;
struct {
	uint64_t                provider_id;
	uint64_t                channel_id;
	IOReportChannelType     channel_type;
	uint64_t                timestamp;
	IOReportElementValues   values;
} __attribute((packed)) IOReportElement;
struct IORPCMessageMach {
	mach_msg_header_t          msgh;
	mach_msg_body_t            msgh_body;
	mach_msg_port_descriptor_t objects[0];
};
struct IORPCMessage {
	uint64_t         msgid;
	uint64_t         flags;
	uint64_t         objectRefs;
	OSObjectRef      objects[0];
};
struct IORPCMessageErrorReturnContent {
	IORPCMessage  hdr;
	kern_return_t result;
	uint32_t      pad;
};
struct IORPCMessageErrorReturn {
	IORPCMessageMach mach;
	IORPCMessageErrorReturnContent content;
};
struct IORPC {
	IORPCMessageMach * message;
	IORPCMessageMach * reply;
	uint32_t           sendSize;
	uint32_t           replySize;
	IORPCMessage     * kernelContent;
};
struct OSClassDescription {
	uint32_t    descriptionSize;

	char        name[96];
	char        superName[96];

	uint32_t    methodOptionsSize;
	uint32_t    methodOptionsOffset;
	uint32_t    metaMethodOptionsSize;
	uint32_t    metaMethodOptionsOffset;
	uint32_t    queueNamesSize;
	uint32_t    queueNamesOffset;
	uint32_t    methodNamesSize;
	uint32_t    methodNamesOffset;
	uint32_t    metaMethodNamesSize;
	uint32_t    metaMethodNamesOffset;

	uint64_t    flags;

	uint64_t    resv1[8];

	uint64_t    methodOptions[0];
	uint64_t    metaMethodOptions[0];

	char        dispatchNames[0];
	char        methodNames[0];
	char        metaMethodNames[0];
};
struct IOPMDriverCallEntry {
	queue_chain_t   link;
	thread_t        thread;
	IOService *     target;
	const void  *callMethod;
};
struct IOStatisticsInterruptEventSources {
	uint32_t created;
	uint32_t produced;
	uint32_t checksForWork;
} IOStatisticsInterruptEventSources;
struct IOStatisticsTimerEventSources {
	uint32_t created;
	uint32_t openGateCalls;
	uint32_t closeGateCalls;
	uint64_t timeOnGate;
	uint32_t timeouts;
	uint32_t checksForWork;
} IOStatisticsTimerEventSources;
struct IOStatisticsDerivedEventSources {
	uint32_t created;
	uint32_t openGateCalls;
	uint32_t closeGateCalls;
	uint64_t timeOnGate;
} IOStatisticsDerivedEventSources;
struct IOStatisticsCommandGates {
	uint32_t created;
	uint32_t openGateCalls;
	uint32_t closeGateCalls;
	uint64_t timeOnGate;
	uint32_t actionCalls;
} IOStatisticsCommandGates;
struct IOStatisticsCommandQueues {
	uint32_t created;
	uint32_t actionCalls;
} IOStatisticsCommandQueues;
struct IOStatisticsUserClients {
	uint32_t created;
	uint32_t clientCalls;
} IOStatisticsUserClients;
struct IOStatisticsHeader {
	uint32_t sig; 
	uint32_t ver; 

	uint32_t seq; 

	uint32_t globalStatsOffset;
	uint32_t kextStatsOffset;
	uint32_t memoryStatsOffset;
	uint32_t classStatsOffset;
	uint32_t counterStatsOffset;
	uint32_t kextIdentifiersOffset;
	uint32_t classNamesOffset;

} IOStatisticsHeader;
struct IOStatisticsGlobal {
	uint32_t kextCount;
	uint32_t classCount;
	uint32_t workloops;
} IOStatisticsGlobal;
struct IOStatisticsKext {
	uint32_t loadTag;
	uint32_t loadSize;
	uint32_t wiredSize;
	uint32_t classes; 
	uint32_t classIndexes[]; 
} IOStatisticsKext;
struct IOStatisticsMemory {
	uint32_t allocatedSize;
	uint32_t freedSize;
	uint32_t allocatedAlignedSize;
	uint32_t freedAlignedSize;
	uint32_t allocatedContiguousSize;
	uint32_t freedContiguousSize;
	uint32_t allocatedPageableSize;
	uint32_t freedPageableSize;
} IOStatisticsMemory;
struct IOStatisticsClass {
	uint32_t classID;
	uint32_t superClassID;
	uint32_t classSize;
} IOStatisticsClass;
struct IOStatisticsCounter {
	uint32_t classID;
	uint32_t classInstanceCount;
	struct IOStatisticsUserClients userClientStatistics;
	struct IOStatisticsInterruptEventSources interruptEventSourceStatistics;
	struct IOStatisticsInterruptEventSources filterInterruptEventSourceStatistics;
	struct IOStatisticsTimerEventSources timerEventSourceStatistics;
	struct IOStatisticsCommandGates commandGateStatistics;
	struct IOStatisticsCommandQueues commandQueueStatistics;
	struct IOStatisticsDerivedEventSources derivedEventSourceStatistics;
} IOStatisticsCounter;
struct IOStatisticsKextIdentifier {
	char identifier[kIOStatisticsDriverNameLength];
} IOStatisticsKextIdentifier;
struct IOStatisticsClassName {
	char name[kIOStatisticsClassNameLength];
} IOStatisticsClassName;
struct IOStatisticsWorkLoop {
	uint32_t attachedEventSources;
	uint64_t timeOnGate;
	uint32_t kextLoadTag;
	uint32_t dependentKexts;
	uint32_t dependentKextLoadTags[];
} IOStatisticsWorkLoop;
struct IOStatisticsWorkLoopHeader {
	uint32_t sig; 
	uint32_t ver; 
	uint32_t seq; 
	uint32_t workloopCount;
	struct IOStatisticsWorkLoop workLoopStats;
} IOStatisticsWorkLoopHeader;
struct IOStatisticsUserClientCall {
	char processName[kIOStatisticsProcessNameLength];
	int32_t pid;
	uint32_t calls;
} IOStatisticsUserClientCall;
struct IOStatisticsUserClientHeader {
	uint32_t sig; 
	uint32_t ver; 
	uint32_t seq; 
	uint32_t processes;
	struct IOStatisticsUserClientCall userClientCalls[];
} IOStatisticsUserClientHeader;
struct{
	IOPhysicalAddress   address;
	IOByteCount         length;
} IOPhysicalRange;
struct{
	IOVirtualAddress    address;
	IOByteCount         length;
} IOVirtualRange;
struct {
	int value;
	const char *name;
} IONamedValue;
struct IOExternalMethod {
	IOService *         object;
	IOMethod            func;
	IOOptionBits        flags;
	IOByteCount         count0;
	IOByteCount         count1;
};
struct IOExternalAsyncMethod {
	IOService *         object;
	IOAsyncMethod       func;
	IOOptionBits        flags;
	IOByteCount         count0;
	IOByteCount         count1;
};
struct IOExternalTrap {
	IOService *         object;
	IOTrap              func;
};
struct IOExternalMethodArguments {
	uint32_t            version;

	uint32_t            selector;

	mach_port_t           asyncWakePort;
	io_user_reference_t * asyncReference;
	uint32_t              asyncReferenceCount;

	const uint64_t *    scalarInput;
	uint32_t            scalarInputCount;

	const void *        structureInput;
	uint32_t            structureInputSize;

	IOMemoryDescriptor * structureInputDescriptor;

	uint64_t *          scalarOutput;
	uint32_t            scalarOutputCount;

	void *              structureOutput;
	uint32_t            structureOutputSize;

	IOMemoryDescriptor * structureOutputDescriptor;
	uint32_t             structureOutputDescriptorSize;

	uint32_t            __reservedA;

	OSObject **         structureVariableOutputData;

	uint32_t            __reserved[30];
};
struct IOExternalMethodDispatch {
	IOExternalMethodAction function;
	uint32_t               checkScalarInputCount;
	uint32_t               checkStructureInputSize;
	uint32_t               checkScalarOutputCount;
	uint32_t               checkStructureOutputSize;
};
struct IOExternalMethodDispatch2022 {
	IOExternalMethodAction function;
	uint32_t               checkScalarInputCount;
	uint32_t               checkStructureInputSize;
	uint32_t               checkScalarOutputCount;
	uint32_t               checkStructureOutputSize;
	uint8_t                allowAsync;
	const char*            checkEntitlement;
};
struct io_filter_callbacks {
	const io_filter_resolver_t      io_filter_resolver;
	const io_filter_applier_t       io_filter_applier;
	const io_filter_release_t       io_filter_release;
};
struct OSObjectUserVars {
	IOUserServer     * userServer;
	OSBoundedArrayRef<IODispatchQueue *> queueArray;
	OSUserMetaClass  * userMeta;
	OSArray          * openProviders;
	IOService        * controllingDriver;
	unsigned long      willPowerState;
	bool               willTerminate;
	bool               didTerminate;
	bool               serverDied;
	bool               started;
	bool               stopped;
	bool               userServerPM;
	bool               willPower;
	bool               powerState;
	bool               resetPowerOnWake;
	bool               deferredRegisterService;
	uint32_t           powerOverride;
	IOLock           * uvarsLock;
};
struct OSNotificationHeader64 {
	mach_msg_size_t     size;       
	natural_t           type;
	OSAsyncReference64  reference;

};
struct IOServiceInterestContent64 {
	natural_t           messageType;
	io_user_reference_t messageArgument[1];
};
struct IOAsyncCompletionContent {
	IOReturn result;
};
struct IODataQueueInternal {
	mach_msg_header_t msg;
	UInt32            queueSize;
};
struct IODTPersistent {
	IODTCompareAddressCellFunc  compareFunc;
};
struct IODTResolvers {
	unsigned int     alloc;
	unsigned int     count;
	IOLock         * lock;
	IODTPersistent * resolvers;
};
struct IODMACommandTransferContext {
	void *   buffer;
	UInt64   bufferOffset;
	UInt64   remaining;
	UInt32   op;
};
struct IOMemoryDescriptorMapAllocRef {
	vm_map_t          map;
	mach_vm_address_t mapped;
	mach_vm_size_t    size;
	vm_prot_t         prot;
	vm_tag_t          tag;
	IOOptionBits      options;
};
struct IODMACommandMapSegment {
	uint64_t fDMAOffset;       
	uint64_t fMapOffset;       
	uint64_t fPageOffset;      
};
struct IODMACommandInternal {
	IOMDDMAWalkSegmentState      fState;
	IOMDDMACharacteristics       fMDSummary;

	UInt64 fPreparedOffset;
	UInt64 fPreparedLength;

	UInt32 fSourceAlignMask;

	UInt8  fCursor;
	UInt8  fCheckAddressing;
	UInt8  fIterateOnly;
	UInt8  fMisaligned;
	UInt8  fPrepared;
	UInt8  fDoubleBuffer;
	UInt8  fNewMD;
	UInt8  fLocalMapperAllocValid;
	UInt8  fIOVMAddrValid;
	UInt8  fForceDoubleBuffer;
	UInt8  fSetActiveNoMapper;

	vm_page_t fCopyPageAlloc;
	vm_page_t fCopyNext;
	vm_page_t fNextRemapPage;

	ppnum_t  fCopyPageCount;

	uint64_t  fLocalMapperAlloc;
	uint64_t  fLocalMapperAllocLength;

	OSPtr<IOBufferMemoryDescriptor> fCopyMD;

	IOService * fDevice;
	IOLock * fDextLock;

	IOReturn fStatus;
	UInt64   fActualByteCount;
	AbsoluteTime    fTimeStamp;

	IODMACommandMapSegment * fMapSegments;
	uint32_t                 fMapSegmentsCount;
	uint64_t fLocalMapperAllocBase;
	uint64_t fOffset2Index;
	uint64_t fNextOffset;
	uint64_t fIndex;
};
struct IOMemoryDescriptorDevicePager {
	void *                       devicePager;
	unsigned int             pagerContig:1;
	unsigned int             unused:31;
	IOMemoryDescriptor * memory;
};
struct IOMemoryDescriptorReserved {
	IOMemoryDescriptorDevicePager dp;
	uint64_t                      descriptorID;
	uint64_t                      preparationID;
	uint64_t                      kernReserved[4];
	vm_tag_t                      kernelTag;
	vm_tag_t                      userTag;
	task_t                        creator;
	OSObject                    * contextObject;
};
struct IOMDPersistentInitData {
	const IOGeneralMemoryDescriptor * fMD;
	IOMemoryReference               * fMemRef;
};
struct ioPLBlock {
	upl_t fIOPL;
	vm_address_t fPageInfo; 
	uint64_t fIOMDOffset;       
	ppnum_t fMappedPage;        
	unsigned int fPageOffset;   
	unsigned int fFlags;        
};
struct ioGMDData {
	IOMapper *  fMapper;
	uint64_t    fDMAMapAlignment;
	uint64_t    fMappedBase;
	uint64_t    fMappedLength;
	uint64_t    fPreparationID;
	unsigned int      fPageCnt;
	uint8_t           fDMAMapNumAddressBits;
	unsigned char     fCompletionError:1;
	unsigned char     fMappedBaseValid:1;
	unsigned char     _resv:4;
	unsigned char     fDMAAccess:2;

	upl_page_info_t fPageList[1]
	__attribute__((aligned(sizeof(upl_t))))
	;
};
struct {
	unsigned int wimg;
	unsigned int object_type;
} iokit_memtype_entry;
struct IOMemoryEntry {
	ipc_port_t entry;
	int64_t    offset;
	uint64_t   size;
	uint64_t   start;
};
struct IOMemoryReference {
	volatile SInt32             refCount;
	vm_prot_t                   prot;
	uint32_t                    capacity;
	uint32_t                    count;
	struct IOMemoryReference  * mapRef;
	IOMemoryEntry               entries[0];
};
struct {
	const char *name;
	IONVRAMVariableType type;
} VariableTypeEntry;
struct {
	const char *name;
	VariablePermission p;
} VariablePermissionEntry;
struct {
	const uint8_t checkOp;
	const uuid_t  *varGuid;
	const char    *varName;
	const char    *varEntitlement;
} VariableEntitlementEntry;
struct chrp_nvram_header { 
	uint8_t  sig;
	uint8_t  cksum; 
	uint16_t len;   
	char     name[12];
	uint8_t  data[0];
} chrp_nvram_header_t;
struct apple_nvram_header {  
	struct   chrp_nvram_header chrp;
	uint32_t adler;
	uint32_t generation;
	uint8_t  padding[8];
} apple_nvram_header_t;
struct {
	NVRAMPartitionType type;
	uint32_t           offset;
	uint32_t           size;
} NVRAMRegionInfo;
struct v3_store_header {
	uint32_t     name;
	uint32_t     size;
	uint32_t     generation;
	uint8_t      state;
	uint8_t      flags;
	uint8_t      version;
	uint8_t      reserved1;
	uint32_t     system_size;
	uint32_t     common_size;
};
struct v3_var_header {
	uint16_t     startId;
	uint8_t      state;
	uint8_t      reserved;
	uint32_t     attributes;
	uint32_t     nameSize;
	uint32_t     dataSize;
	uuid_t       guid;
	uint32_t     crc;
	uint8_t      name_data_buf[];
};
struct nvram_v3_var_entry {
	uint8_t                new_state;
	size_t                 existing_offset;
	struct v3_var_header   header;
};
struct {
	const char            *name;
	OSSharedPtr<OSObject> value;
} ephDMAllowListEntry;
struct iocpu_platform_action_entry {
	queue_chain_t                     link;
	iocpu_platform_action_t           action;
	int32_t                           priority;
	const char *                      name;
	void *                            refcon0;
	void *                            refcon1;
	boolean_t                         callout_in_progress;
	struct iocpu_platform_action_entry * alloc_list;
};
struct AggressivesRecord {
	uint32_t    flags;
	uint32_t    type;
	uint32_t    value;
};
struct AggressivesRequest {
	queue_chain_t           chain;
	uint32_t                options;
	uint32_t                dataType;
	union {
		OSSharedPtr<IOService> service;
		AggressivesRecord      record;
	} data;
};
struct PMSettingCallEntry {
	queue_chain_t   link;
	thread_t        thread;
};
struct PMAssertStruct {
	IOPMDriverAssertionID       id;
	IOPMDriverAssertionType     assertionBits;
	uint64_t                    createdTime;
	uint64_t                    modifiedTime;
	const OSSymbol              *ownerString;
	IOService                   *ownerService;
	uint64_t                    registryEntryID;
	IOPMDriverAssertionLevel    level;
	uint64_t                    assertCPUStartTime;
	uint64_t                    assertCPUDuration;
};
struct pmioctlVaribleInfo {
	uint32_t            varID;      
	uint8_t             varName[PMVARNAMELEN + 1];
	pmioctlVarType_t    varType;    
	uint64_t            varInitValue;
	uint64_t            varCurValue;
} pmioctlVariableInfo_t;
struct _OpenFileContext {
	OSData * extents;
	uint64_t size;
};
struct IORangeAllocatorElement {
	IORangeScalar       start;
	IORangeScalar       end;
};
struct IOInterruptAccountingReporter {
	IOSimpleReporter * reporter; 
	IOInterruptAccountingData * statistics; 
};
struct ArbitrationLockQueueElement {
	queue_chain_t link;
	IOThread      thread;
	IOService *   service;
	unsigned      count;
	bool          required;
	bool          aborted;
};
struct CpuDelayEntry {
	IOService * fService;
	UInt32      fMaxDelay;
	UInt32      fDelayType;
};
struct MessageClientsContext {
	IOService * service;
	UInt32      type;
	void *      argument;
	vm_size_t   argSize;
	IOReturn    ret;
};
struct ServiceOpenMessageContext {
	IOService *  service;
	UInt32       type;
	IOService *  excludeClient;
	IOOptionBits options;
};
struct FindRootMediaContext {
	OSArray   * services;
	IOService * parent;
};
struct IOServiceMatchContext {
	OSDictionary * table;
	OSObject *     result;
	uint32_t       options;
	uint32_t       state;
	uint32_t       count;
	uint32_t       done;
};
struct _IOServiceMatchingNotificationHandlerRef {
	IOServiceNotificationHandler handler;
	void * ref;
};
struct IOUserServerCancellationHandlerArgs {
	IOService ** ref;
	bool canceled;
};
struct IOPMRequestDomainPowerContext {
	IOService *     child;          
	IOPMPowerFlags  requestPowerFlags;
};
struct IOPMActions {
	void *                          target;
	IOPMActionPowerChangeStart      actionPowerChangeStart;
	IOPMActionPowerChangeDone       actionPowerChangeDone;
	IOPMActionPowerChangeOverride   actionPowerChangeOverride;
	IOPMActionActivityTickle        actionActivityTickle;
	IOPMActionUpdatePowerClient     actionUpdatePowerClient;
	uint32_t                        darkWakePowerState;
	uint16_t                        flags;
	uint16_t                        state;
};
struct IOPMPSEntry {
	IOPMPowerFlags      capabilityFlags;
	IOPMPowerFlags      outputPowerFlags;
	IOPMPowerFlags      inputPowerFlags;
	unsigned long       staticPower;
	uint32_t            settleUpTime;
	uint32_t            settleDownTime;
	IOPMPowerStateIndex stateOrder;
	IOPMPowerStateIndex stateOrderToIndex;
};
struct DriverCallParam {
	OSObject *  Target;
	IOReturn    Result;
};
struct IOPMInterestContext {
	OSArray *               responseArray;
	OSArray *               notifyClients;
	uint16_t                serialNumber;
	uint8_t                 isPreChange;
	uint8_t                 enableTracing;
	uint32_t                maxTimeRequested;
	uint32_t                messageType;
	uint32_t                notifyType;
	uint32_t                skippedInDark;
	uint32_t                notSkippedInDark;
	IOService *             us;
	IOPMPowerStateIndex     stateNumber;
	IOPMPowerFlags          stateFlags;
	IOPMPowerChangeFlags    changeFlags;
	IOPMMessageFilter       messageFilter;
};
struct _IOServiceNotifierInvocation {
	IOThread            thread;
	queue_chain_t       link;
};
struct IOUserClientOwner {
	task_t         task;
	queue_chain_t  taskLink;
	IOUserClient * uc;
	queue_chain_t  ucLink;
};
struct IOUCFilterPolicy {
	task_t             task;
	io_filter_policy_t filterPolicy;
	IOUCFilterPolicy * next;
};
struct IODispatchQueue_IVars {
	IOUserServer * userServer;
	IODispatchQueue   * queue;
	queue_chain_t  link;
	uint64_t       tid;

	mach_port_t    serverPort;
};
struct OSAction_IVars {
	OSObject             * target;
	uint64_t               targetmsgid;
	uint64_t               msgid;
	IOUserServer         * userServer;
	OSActionAbortedHandler abortedHandler;
	OSString             * typeName;
	void                 * reference;
	size_t                 referenceSize;
	bool                   aborted;
};
struct IOWorkGroup_IVars {
	IOUserServer * userServer;
	OSString * name;
	IOUserUserClient * userClient;
};
struct IOEventLink_IVars {
	IOUserServer * userServer;
	OSString * name;
	IOUserUserClient * userClient;
};
struct IODispatchSource_IVars {
	queue_chain_t           link;
	IODispatchSource      * source;
	IOUserServer          * server;
	IODispatchQueue_IVars * queue;
	bool                    enabled;
};
struct IOInterruptDispatchSource_IVars {
	IOService    * provider;
	uint32_t       intIndex;
	uint32_t       flags;
	int            interruptType;
	IOSimpleLock * lock;
	thread_t       waiter;
	uint64_t       count;
	uint64_t       time;
	OSAction     * action;
	bool           enable;
	bool           canceled;
};
struct IOServiceNotificationDispatchSource_IVars {
	OSObject     * serverName;
	OSAction     * action;
	IOLock       * lock;
	IONotifier   * notifier;
	OSDictionary * interestNotifiers;
	OSBoundedArray<OSArray *, kIOServiceNotificationTypeCount> pending;
	bool           enable;
};
struct IOPStrings {
	uint32_t     dataSize;
	uint32_t     count;
	const char   strings[0];
};
struct UEXTTrapReply {
	uint64_t replySize;
	IORPCMessage replyMessage;
};
struct IOUserServerRecordExitReasonContext {
	task_t task;
	os_reason_t reason;
};
struct IOUserUserClientActionRef {
	OSAsyncReference64 asyncRef;
};
struct IOServiceStateNotificationDispatchSource_IVars {
	IOLock                       * fLock;
	IOService                    * fStateNotification;
	IOStateNotificationListenerRef fListener;
	OSAction                     * fAction;
	bool                           fEnable;
	bool                           fArmed;
};
struct IOServiceStateChangeVars {
	IOLock       * fLock;
	OSDictionary * fItems;
};
struct WorkloadClassData {
	const char *name;
	UInt32 workIntervalFlags;
	UInt32 threadGroupFlags;
} wlClassData[] = {
	[WI_CLASS_NONE] =
	{
		.name = "NONE",
		.workIntervalFlags = WORK_INTERVAL_WORKLOAD_ID_HAS_ID,
		.threadGroupFlags = THREAD_GROUP_FLAGS_ABSENT,
	},
	[WI_CLASS_DISCRETIONARY] =
	{
		.name = "DISCRETIONARY",
		.workIntervalFlags = WORK_INTERVAL_WORKLOAD_ID_HAS_ID,
		.threadGroupFlags = THREAD_GROUP_FLAGS_EFFICIENT,
	},
	[WI_CLASS_BEST_EFFORT] =
	{
		.name = "BEST_EFFORT",
		.workIntervalFlags = WORK_INTERVAL_WORKLOAD_ID_HAS_ID,
		.threadGroupFlags = THREAD_GROUP_FLAGS_BEST_EFFORT,
	},
	[WI_CLASS_APP_SUPPORT] =
	{
		.name = "APPLICATION_SUPPORT",
		.workIntervalFlags = WORK_INTERVAL_WORKLOAD_ID_HAS_ID,
		.threadGroupFlags = 0,
	},
	[WI_CLASS_APPLICATION] =
	{
		.name = "APPLICATION",
		.workIntervalFlags = WORK_INTERVAL_WORKLOAD_ID_HAS_ID,
		.threadGroupFlags = THREAD_GROUP_FLAGS_APPLICATION,
	},
	[WI_CLASS_SYSTEM] =
	{
		.name = "SYSTEM",
		.workIntervalFlags = WORK_INTERVAL_WORKLOAD_ID_HAS_ID,
		.threadGroupFlags = 0,
	},
	[WI_CLASS_SYSTEM_CRITICAL] =
	{
		.name = "SYSTEM_CRITICAL",
		.workIntervalFlags = WORK_INTERVAL_WORKLOAD_ID_HAS_ID,
		.threadGroupFlags = THREAD_GROUP_FLAGS_CRITICAL,
	},
	[WI_CLASS_REALTIME] =
	{
		.name = "REALTIME",
		.workIntervalFlags = WORK_INTERVAL_WORKLOAD_ID_HAS_ID |
		                     WORK_INTERVAL_WORKLOAD_ID_RT_ALLOWED,
		.threadGroupFlags = 0,
	},
	[WI_CLASS_REALTIME_CRITICAL] =
	{
		.name = "REALTIME_CRITICAL",
		.workIntervalFlags = WORK_INTERVAL_WORKLOAD_ID_HAS_ID |
		                     WORK_INTERVAL_WORKLOAD_ID_RT_ALLOWED |
		                     WORK_INTERVAL_WORKLOAD_ID_RT_CRITICAL,
		.threadGroupFlags = THREAD_GROUP_FLAGS_CRITICAL,
	},
};
struct FlagMap {
	const char *str;
	UInt32 flags;
};
struct _IODataQueueEntry {
	uint32_t  size;
	uint8_t   data[0];
} IODataQueueEntry;
struct _IODataQueueMemory {
	volatile uint32_t   head;
	volatile uint32_t   tail;
	volatile uint8_t    needServicedCallback;
	volatile uint8_t    _resv[119];
	IODataQueueEntry  queue[0];
} IODataQueueMemory;
struct IODataQueueDispatchSource_IVars {
	IODataQueueMemory         * dataQueue;
	IODataQueueDispatchSource * source;

	IOMemoryDescriptor        * memory;
	OSAction                  * dataAvailableAction;
	OSAction                  * dataServicedAction;
	uint64_t                    options;
	uint32_t                    queueByteCount;

};
struct object {
	struct object   *next;
	struct object   *free;
	struct object   *elements;
	OSObject        *object;
	OSSymbol        *key;                   
	int             size;
	void            *data;                  
	char            *string;                
	int             string_alloc_length;
	long long       number;                 
	int             idref;
} object_t;
struct parser_state {
	const char      *parseBuffer;           
	int             parseBufferIndex;       
	int             lineNumber;             
	object_t        *objects;               
	object_t        *freeObjects;           
	OSDictionary    *tags;                  
	OSString        **errorString;          
	OSObject        *parsedObject;          
	int             parsedObjectCount;
	int             retrievedObjectCount;
} parser_state_t;
struct IOPMCalendarStruct {
	UInt32      year;
	UInt8       month;
	UInt8       day;
	UInt8       hour;
	UInt8       minute;
	UInt8       second;
	UInt8       selector;
};
struct IOPowerStateChangeNotification {
	void *        powerRef;
	unsigned long    returnValue;
	unsigned long    stateNumber;
	IOPMPowerFlags    stateFlags;
};
struct IOPMSystemCapabilityChangeParameters {
	uint32_t    notifyRef;
	uint32_t    maxWaitForReply;
	uint32_t    changeFlags;
	uint32_t    __reserved1;
	uint32_t    fromCapabilities;
	uint32_t    toCapabilities;
	uint32_t    __reserved2[4];
};
struct IOPMPowerState {
	unsigned long       version;
	IOPMPowerFlags      capabilityFlags;
	IOPMPowerFlags      outputPowerCharacter;
	IOPMPowerFlags      inputPowerRequirement;
	unsigned long       staticPower;
	unsigned long       stateOrder;
	unsigned long       powerToAttain;
	unsigned long       timeToAttain;
	unsigned long       settleUpTime;
	unsigned long       timeToLower;
	unsigned long       settleDownTime;
	unsigned long       powerDomainBudget;
};
struct PMStatsBounds{
    uint64_t start;
    uint64_t stop;
};
struct {

    struct PMStatsBounds    hibWrite;
    struct PMStatsBounds    hibRead;






} PMStatsStruct;
struct {
   uint32_t signature;
   uint32_t alloc_size;
   uint32_t          crc;             
   uint32_t          spindump_offset; 
   uint32_t          spindump_size;
   uint8_t           is_osx_watchdog;

   
   char             UUID[44];
   char             spindump_status[24];   
   char             PMStatusCode[32];
   char             reason[32];
} swd_hdr;
struct {
	boolean_t user_writable;        
	boolean_t kernel_writable;      
	boolean_t iodir_in;             
	boolean_t iodir_out;            
	boolean_t purgeable;            
	boolean_t inhibitCache;         
	boolean_t physcontig;           
	boolean_t puredata;             
	boolean_t threadSafe;           
	boolean_t memtag;               
} IOSKMemoryBufferSpec;
struct {
	boolean_t noRedirect;
} IOSKRegionSpec;
struct{
	cccbc_ctx_decl(AES_CBC_CTX_MAX_SIZE, ctx);
} aes_decrypt_ctx;
struct{
	cccbc_ctx_decl(AES_CBC_CTX_MAX_SIZE, ctx);
} aes_encrypt_ctx;
struct{
	aes_decrypt_ctx decrypt;
	aes_encrypt_ctx encrypt;
} aes_ctx;
struct {
	u_int32_t state[4];     
	u_int32_t count[2];     
	unsigned char buffer[64];       
} MD5_CTX;
struct sha1_ctxt {
	union {
		u_int8_t        b8[20];
		u_int32_t       b32[5]; 
	} h;
	union {
		u_int8_t        b8[8];
		u_int32_t       b32[2];
		u_int64_t       b64[1]; 
	} c;
	union {
		u_int8_t        b8[64];
		u_int32_t       b32[16]; 
	} m;
	u_int8_t        count;          
} SHA1_CTX;
struct {
	ccdigest_ctx_decl(CCSHA256_STATE_SIZE, CCSHA256_BLOCK_SIZE, ctx);
} SHA256_CTX;
struct SHA512_CTX {
	ccdigest_ctx_decl(CCSHA512_STATE_SIZE, CCSHA512_BLOCK_SIZE, ctx);
} SHA512_CTX;
struct acpi_table_header {
	ACPI_TABLE_HEADER_DEF
} ACPI_TABLE_HEADER;
struct acpi_generic_address {
	UINT8                   AddressSpaceId;     
	UINT8                   RegisterBitWidth;   
	UINT8                   RegisterBitOffset;  
	UINT8                   AccessWidth;        
	UINT64                  Address;            
} ACPI_GENERIC_ADDRESS;
struct rsdp_descriptor {
	char                    Signature[8];       
	UINT8                   Checksum;           
	char                    OemId[6];           
	UINT8                   Revision;           
	UINT32                  RsdtPhysicalAddress;
	UINT32                  Length;             
	UINT64                  XsdtPhysicalAddress;
	UINT8                   ExtendedChecksum;   
	UINT8                   Reserved[3];        
} RSDP_DESCRIPTOR;
struct rsdt_descriptor {
	ACPI_TABLE_HEADER_DEF
	UINT32                  TableOffsetEntry[1];
} RSDT_DESCRIPTOR;
struct xsdt_descriptor {
	ACPI_TABLE_HEADER_DEF
	UINT64                  TableOffsetEntry[1];
} XSDT_DESCRIPTOR;
struct facs_descriptor {
	char                    Signature[4];       
	UINT32                  Length;             
	UINT32                  HardwareSignature;  
	UINT32                  FirmwareWakingVector;
	UINT32                  GlobalLock;         


	UINT8                   S4Bios_f        : 1;
	UINT8                                   : 7;
	UINT8                   Reserved1[3];       

	UINT64                  XFirmwareWakingVector;
	UINT8                   Version;            
	UINT8                   Reserved[31];       
} FACS_DESCRIPTOR;
struct acpi_common_facs {
	UINT32                  *GlobalLock;
	UINT64                  *FirmwareWakingVector;
	UINT8                   VectorWidth;
} ACPI_COMMON_FACS;
struct fadt_descriptor {
	ACPI_FADT_COMMON


	UINT8                   WbInvd      : 1;
	UINT8                   WbInvdFlush : 1;
	UINT8                   ProcC1      : 1;
	UINT8                   Plvl2Up     : 1;
	UINT8                   PwrButton   : 1;
	UINT8                   SleepButton : 1;
	UINT8                   FixedRTC    : 1;
	UINT8                   Rtcs4       : 1;
	UINT8                   TmrValExt   : 1;
	UINT8                   DockCap     : 1;
	UINT8                   ResetRegSup : 1;
	UINT8                   SealedCase  : 1;
	UINT8                   Headless    : 1;
	UINT8                   CpuSwSleep  : 1;

	UINT8                   PciExpWak                           : 1;
	UINT8                   UsePlatformClock                    : 1;
	UINT8                   S4RtcStsValid                       : 1;
	UINT8                   RemotePowerOnCapable                : 1;
	UINT8                   ForceApicClusterModel               : 1;
	UINT8                   ForceApicPhysicalDestinationMode    : 1;
	UINT8                                                       : 4;
	UINT8                   Reserved3;                           

	ACPI_GENERIC_ADDRESS    ResetRegister;  
	UINT8                   ResetValue;     
	UINT8                   Reserved4[3];   
	UINT64                  XFirmwareCtrl;  
	UINT64                  XDsdt;          
	ACPI_GENERIC_ADDRESS    XPm1aEvtBlk;    
	ACPI_GENERIC_ADDRESS    XPm1bEvtBlk;    
	ACPI_GENERIC_ADDRESS    XPm1aCntBlk;    
	ACPI_GENERIC_ADDRESS    XPm1bCntBlk;    
	ACPI_GENERIC_ADDRESS    XPm2CntBlk;     
	ACPI_GENERIC_ADDRESS    XPmTmrBlk;      
	ACPI_GENERIC_ADDRESS    XGpe0Blk;       
	ACPI_GENERIC_ADDRESS    XGpe1Blk;       
} FADT_DESCRIPTOR;
struct fadt_descriptor_rev2_minus {
	ACPI_FADT_COMMON
	UINT32                  Flags;
	ACPI_GENERIC_ADDRESS    ResetRegister;  
	UINT8                   ResetValue;     
	UINT8                   Reserved7[3];   
} FADT_DESCRIPTOR_REV2_MINUS;
struct fadt_descriptor_rev1 {
	ACPI_FADT_COMMON
	UINT32                  Flags;
} FADT_DESCRIPTOR_REV1;
struct acpi_table_support {
	char                    *Name;
	char                    *Signature;
	void                    **GlobalPtr;
	UINT8                   SigLength;
	UINT8                   Flags;
} ACPI_TABLE_SUPPORT;
struct acpi_table_asf {
	ACPI_TABLE_HEADER_DEF
} ACPI_TABLE_ASF;
struct acpi_asf_header {
	ACPI_ASF_HEADER_DEF
} ACPI_ASF_HEADER;
struct acpi_asf_info {
	ACPI_ASF_HEADER_DEF
	UINT8                   MinResetValue;
	UINT8                   MinPollInterval;
	UINT16                  SystemId;
	UINT32                  MfgId;
	UINT8                   Flags;
	UINT8                   Reserved2[3];
} ACPI_ASF_INFO;
struct acpi_asf_alert {
	ACPI_ASF_HEADER_DEF
	UINT8                   AssertMask;
	UINT8                   DeassertMask;
	UINT8                   Alerts;
	UINT8                   DataLength;
	UINT8                   Array[1];
} ACPI_ASF_ALERT;
struct acpi_asf_remote {
	ACPI_ASF_HEADER_DEF
	UINT8                   Controls;
	UINT8                   DataLength;
	UINT16                  Reserved2;
	UINT8                   Array[1];
} ACPI_ASF_REMOTE;
struct acpi_asf_rmcp {
	ACPI_ASF_HEADER_DEF
	UINT8                   Capabilities[7];
	UINT8                   CompletionCode;
	UINT32                  EnterpriseId;
	UINT8                   Command;
	UINT16                  Parameter;
	UINT16                  BootOptions;
	UINT16                  OemParameters;
} ACPI_ASF_RMCP;
struct acpi_asf_address {
	ACPI_ASF_HEADER_DEF
	UINT8                   EpromAddress;
	UINT8                   Devices;
	UINT8                   SmbusAddresses[1];
} ACPI_ASF_ADDRESS;
struct acpi_table_boot {
	ACPI_TABLE_HEADER_DEF
	UINT8                   CmosIndex;      
	UINT8                   Reserved[3];
} ACPI_TABLE_BOOT;
struct acpi_table_cpep {
	ACPI_TABLE_HEADER_DEF
	UINT64                  Reserved;
} ACPI_TABLE_CPEP;
struct acpi_cpep_polling {
	UINT8                   Type;
	UINT8                   Length;
	UINT8                   ProcessorId;    
	UINT8                   ProcessorEid;   
	UINT32                  PollingInterval;
} ACPI_CPEP_POLLING;
struct acpi_table_dbgp {
	ACPI_TABLE_HEADER_DEF
	UINT8                   InterfaceType;  
	UINT8                   Reserved[3];
	ACPI_GENERIC_ADDRESS    DebugPort;
} ACPI_TABLE_DBGP;
struct ec_boot_resources {
	ACPI_TABLE_HEADER_DEF
	ACPI_GENERIC_ADDRESS    EcControl;      
	ACPI_GENERIC_ADDRESS    EcData;         
	UINT32                  Uid;            
	UINT8                   GpeBit;         
	UINT8                   EcId[1];        
} EC_BOOT_RESOURCES;
struct acpi_hpet_table {
	ACPI_TABLE_HEADER_DEF
	UINT32                  HardwareId;     
	ACPI_GENERIC_ADDRESS    BaseAddress;    
	UINT8                   HpetNumber;     
	UINT16                  ClockTick;      
	UINT8                   Attributes;
} HPET_TABLE;
struct multiple_apic_table {
	ACPI_TABLE_HEADER_DEF
	UINT32                  LocalApicAddress;


	UINT8                   PCATCompat      : 1;
	UINT8                                   : 7;
	UINT8                   Reserved1[3];       
} MULTIPLE_APIC_TABLE;
struct apic_header {
	APIC_HEADER_DEF
} APIC_HEADER;
struct madt_processor_apic {
	APIC_HEADER_DEF
	UINT8                   ProcessorId;    
	UINT8                   LocalApicId;    
	ACPI_MADT_LFLAGS
} MADT_PROCESSOR_APIC;
struct madt_io_apic {
	APIC_HEADER_DEF
	UINT8                   IoApicId;       
	UINT8                   Reserved;       
	UINT32                  Address;        
	UINT32                  Interrupt;      
} MADT_IO_APIC;
struct madt_interrupt_override {
	APIC_HEADER_DEF
	UINT8                   Bus;            
	UINT8                   Source;         
	UINT32                  Interrupt;      
	ACPI_MADT_IFLAGS
} MADT_INTERRUPT_OVERRIDE;
struct madt_nmi_source {
	APIC_HEADER_DEF
	ACPI_MADT_IFLAGS
	UINT32                  Interrupt;      
} MADT_NMI_SOURCE;
struct madt_local_apic_nmi {
	APIC_HEADER_DEF
	UINT8                   ProcessorId;    
	ACPI_MADT_IFLAGS
	UINT8                   Lint;               
} MADT_LOCAL_APIC_NMI;
struct madt_address_override {
	APIC_HEADER_DEF
	UINT16                  Reserved;       
	UINT64                  Address;        
} MADT_ADDRESS_OVERRIDE;
struct madt_io_sapic {
	APIC_HEADER_DEF
	UINT8                   IoSapicId;      
	UINT8                   Reserved;       
	UINT32                  InterruptBase;  
	UINT64                  Address;        
} MADT_IO_SAPIC;
struct madt_local_sapic {
	APIC_HEADER_DEF
	UINT8                   ProcessorId;    
	UINT8                   LocalSapicId;   
	UINT8                   LocalSapicEid;  
	UINT8                   Reserved[3];    
	ACPI_MADT_LFLAGS
	UINT32                  ProcessorUID;           
	char                    ProcessorUIDString[1];
} MADT_LOCAL_SAPIC;
struct madt_interrupt_source {
	APIC_HEADER_DEF
	ACPI_MADT_IFLAGS
	UINT8                   InterruptType;  
	UINT8                   ProcessorId;    
	UINT8                   ProcessorEid;   
	UINT8                   IoSapicVector;  
	UINT32                  Interrupt;      
	UINT32                  Flags;          
} MADT_INTERRUPT_SOURCE;
struct acpi_table_mcfg {
	ACPI_TABLE_HEADER_DEF
	UINT8                   Reserved[8];
} ACPI_TABLE_MCFG;
struct acpi_mcfg_allocation {
	UINT64                  BaseAddress;    
	UINT16                  PciSegment;     
	UINT8                   StartBusNumber; 
	UINT8                   EndBusNumber;   
	UINT32                  Reserved;
} ACPI_MCFG_ALLOCATION;
struct smart_battery_table {
	ACPI_TABLE_HEADER_DEF
	UINT32                  WarningLevel;
	UINT32                  LowLevel;
	UINT32                  CriticalLevel;
} SMART_BATTERY_TABLE;
struct system_locality_info {
	ACPI_TABLE_HEADER_DEF
	UINT64                  LocalityCount;
	UINT8                   Entry[1][1];
} SYSTEM_LOCALITY_INFO;
struct acpi_table_spcr {
	ACPI_TABLE_HEADER_DEF
	UINT8                   InterfaceType;  
	UINT8                   Reserved[3];
	ACPI_GENERIC_ADDRESS    SerialPort;
	UINT8                   InterruptType;
	UINT8                   PcInterrupt;
	UINT32                  Interrupt;
	UINT8                   BaudRate;
	UINT8                   Parity;
	UINT8                   StopBits;
	UINT8                   FlowControl;
	UINT8                   TerminalType;
	UINT8                   Reserved2;
	UINT16                  PciDeviceId;
	UINT16                  PciVendorId;
	UINT8                   PciBus;
	UINT8                   PciDevice;
	UINT8                   PciFunction;
	UINT32                  PciFlags;
	UINT8                   PciSegment;
	UINT32                  Reserved3;
} ACPI_TABLE_SPCR;
struct acpi_table_spmi {
	ACPI_TABLE_HEADER_DEF
	UINT8                   Reserved;
	UINT8                   InterfaceType;
	UINT16                  SpecRevision;   
	UINT8                   InterruptType;
	UINT8                   GpeNumber;      
	UINT8                   Reserved2;
	UINT8                   PciDeviceFlag;
	UINT32                  Interrupt;
	ACPI_GENERIC_ADDRESS    IpmiRegister;
	UINT8                   PciSegment;
	UINT8                   PciBus;
	UINT8                   PciDevice;
	UINT8                   PciFunction;
} ACPI_TABLE_SPMI;
struct system_resource_affinity {
	ACPI_TABLE_HEADER_DEF
	UINT32                  Reserved1;      
	UINT64                  Reserved2;      
} SYSTEM_RESOURCE_AFFINITY;
struct static_resource_alloc {
	SRAT_SUBTABLE_HEADER
	UINT8                   ProximityDomainLo;
	UINT8                   ApicId;


	UINT8                   Enabled         :1;
	UINT8                                   :7;
	UINT8                   Reserved3[3];   

	UINT8                   LocalSapicEid;
	UINT8                   ProximityDomainHi[3];
	UINT32                  Reserved4;      
} STATIC_RESOURCE_ALLOC;
struct memory_affinity {
	SRAT_SUBTABLE_HEADER
	UINT32                  ProximityDomain;
	UINT16                  Reserved3;
	UINT64                  BaseAddress;
	UINT64                  AddressLength;
	UINT32                  Reserved4;


	UINT8                   Enabled         :1;
	UINT8                   HotPluggable    :1;
	UINT8                   NonVolatile     :1;
	UINT8                                   :5;
	UINT8                   Reserved5[3];   

	UINT64                  Reserved6;      
} MEMORY_AFFINITY;
struct acpi_table_tcpa {
	ACPI_TABLE_HEADER_DEF
	UINT16                  Reserved;
	UINT32                  MaxLogLength;   
	UINT64                  LogAddress;     
} ACPI_TABLE_TCPA;
struct acpi_table_wdrt {
	ACPI_TABLE_HEADER_DEF
	UINT32                  HeaderLength;   
	UINT8                   PciSegment;     
	UINT8                   PciBus;         
	UINT8                   PciDevice;      
	UINT8                   PciFunction;    
	UINT32                  TimerPeriod;    
	UINT32                  MaxCount;       
	UINT32                  MinCount;       
	UINT8                   Flags;
	UINT8                   Reserved[3];
	UINT32                  Entries;        
} ACPI_TABLE_WDRT;
struct cc_iovec {
    const void *base;
    size_t nbytes;
} cc_iovec_t;
struct {
	uint32_t state[16];
	uint8_t	buffer[CCCHACHA20_BLOCK_NBYTES];
	size_t leftover;
} ccchacha20_ctx;
struct {
	uint32_t r0, r1, r2, r3, r4;
	uint32_t s1, s2, s3, s4;
	uint32_t h0, h1, h2, h3, h4;
	uint8_t	buf[16];
	size_t buf_used;
	uint8_t	key[16];
} ccpoly1305_ctx;
struct {
	ccchacha20_ctx chacha20_ctx;
	ccpoly1305_ctx poly1305_ctx;
	uint64_t aad_nbytes;
	uint64_t text_nbytes;
    uint8_t state;
} ccchacha20poly1305_ctx;
struct ccchacha20poly1305_info {

};
struct cccmac_ctx {
    uint8_t k1[CMAC_BLOCKSIZE];
    uint8_t k2[CMAC_BLOCKSIZE];
    uint8_t block[CMAC_BLOCKSIZE];
    size_t  block_nbytes; 
    size_t  cumulated_nbytes;  
    const struct ccmode_cbc *cbc;
    uint8_t ctx[1];
} CC_ALIGNED(8);
struct ccder_blob {
    uint8_t *cc_ended_by(der_end) der;
    uint8_t *der_end;
} ccder_blob;
struct ccder_read_blob {
    const uint8_t *cc_ended_by(der_end) der;
    const uint8_t *der_end;
} ccder_read_blob;
struct ccdigest_ctx {
    uint8_t state[1];
} CC_ALIGNED(8);
struct ccdigest_state {
    uint8_t state[1];
} CC_ALIGNED(8);
struct ccdigest_info {
    size_t output_size;
    size_t state_size;
    size_t block_size;
    size_t oid_size;
    const unsigned char *oid;
    const void *initial_state;
    void(* CC_SPTR(ccdigest_info, compress))(ccdigest_state_t state, size_t nblocks,
                    const void *data);
    void(* CC_SPTR(ccdigest_info, final))(const struct ccdigest_info *di, ccdigest_ctx_t ctx,
                 unsigned char *digest);
    cc_impl_t impl;
};
struct ccdrbg_nistctr_custom {
    const struct ccmode_ctr *ctr_info;
    size_t keylen;
    int strictFIPS;
    const ccdrbg_df_ctx_t *df_ctx;
};
struct ccdrbg_nisthmac_custom {
    const struct ccdigest_info *di;
    int strictFIPS;
};
struct ccdrbg_df_ctx {
    int (*derive_keys)(const ccdrbg_df_ctx_t *ctx,
                       size_t inputs_count,
                       const cc_iovec_t *inputs,
                       size_t keys_nbytes,
                       void *keys);
};
struct ccdrbg_df_bc_ctx {
    ccdrbg_df_ctx_t df_ctx;
    const struct ccmode_cbc *cbc_info;
    size_t key_nbytes;

    
    cc_ctx_decl_field(cccbc_ctx, CCCBC_MAX_CTX_SIZE, cbc_ctx);
};
struct ccdrbg_info {
    
    size_t size;

    
    int (*CC_SPTR(ccdrbg_info, init))(const struct ccdrbg_info *info, struct ccdrbg_state *drbg,
                size_t entropyLength, const void* entropy,
                size_t nonceLength, const void* nonce,
                size_t psLength, const void* ps);

    
    int (*CC_SPTR(ccdrbg_info, reseed))(struct ccdrbg_state *drbg,
                  size_t entropylen, const void *entropy,
                  size_t inlen, const void *in);

    
    int (*CC_SPTR(ccdrbg_info, generate))(struct ccdrbg_state *drbg,
                    size_t outlen, void *out,
                    size_t inlen, const void *in);

    
    void (*CC_SPTR(ccdrbg_info, done))(struct ccdrbg_state *drbg);

    
    const void *custom;

    
    bool (*CC_SPTR(ccdrbg_info, must_reseed))(const struct ccdrbg_state *drbg);
};
struct ccentropy_info {
    
    
    
    
    
    ccentropy_get_seed_fn_t get_seed;

    
    
    
    
    
    ccentropy_add_entropy_fn_t add_entropy;
} ccentropy_info_t;
struct ccentropy_ctx {
    
    const ccentropy_info_t *info;
};
struct ccentropy_rng_ctx {
    ccentropy_ctx_t entropy_ctx;
    struct ccrng_state *rng_ctx;
    size_t seed_max_nbytes;
} ccentropy_rng_ctx_t;
struct ccentropy_digest_ctx {
    ccentropy_ctx_t entropy_ctx;
    const struct ccdigest_info *digest_info;
    ccdigest_ctx_decl(MAX_DIGEST_STATE_SIZE,
                      MAX_DIGEST_BLOCK_SIZE,
                      digest_ctx);
    uint32_t entropy_mbits_per_sample;
    uint32_t entropy_mbits;
} ccentropy_digest_ctx_t;
struct cchmac_ctx {
    uint8_t b[1];
} CC_ALIGNED(8);
struct cckprng_ctx {
    
    ccrng_schedule_atomic_flag_ctx_t schedule_ctx;

    ccentropy_rng_ctx_t entropy_ctx;

    cc_lock_ctx_t lock_ctx;

    struct ccdrbg_info drbg_info;
    uint8_t drbg_state[CCKPRNG_DRBG_STATE_MAX_SIZE];

    ccdrbg_df_bc_ctx_t drbg_df_ctx;

    uint8_t cache[CCKPRNG_CACHED_BUF_SIZE];

    ccrng_crypto_ctx_t rng_ctx;

    struct ccrng_fortuna_ctx fortuna_ctx;
};
struct cckprng_funcs {
    void (*CC_SPTR(cckprng_funcs, init))(struct cckprng_ctx *ctx,
                                         size_t seed_nbytes,
                                         const void *seed,
                                         size_t nonce_nbytes,
                                         const void *nonce,
                                         cckprng_getentropy getentropy,
                                         void *getentropy_arg);
    void (*CC_SPTR(cckprng_funcs, initgen))(struct cckprng_ctx *ctx, unsigned gen_idx);
    void (*CC_SPTR(cckprng_funcs, reseed))(struct cckprng_ctx *ctx, size_t nbytes, const void *seed);
    void (*CC_SPTR(cckprng_funcs, refresh))(struct cckprng_ctx *ctx);
    void (*CC_SPTR(cckprng_funcs, generate))(struct cckprng_ctx *ctx, unsigned gen_idx, size_t nbytes, void *out);
    void (*CC_SPTR(cckprng_funcs, init_with_getentropy))(struct cckprng_ctx *ctx,
                                                         unsigned max_ngens,
                                                         size_t seed_nbytes,
                                                         const void *seed,
                                                         size_t nonce_nbytes,
                                                         const void *nonce,
                                                         cckprng_getentropy getentropy,
                                                         void *getentropy_arg);
};
struct ccmode_ecb {
    size_t size; 
    size_t block_size;
    int (*CC_SPTR(ccmode_ecb, init))(const struct ccmode_ecb *ecb, ccecb_ctx *ctx, size_t key_nbytes, const void *key);
    int (*CC_SPTR(ccmode_ecb, ecb))(const ccecb_ctx *ctx, size_t nblocks, const void *in, void *out);
    void (*CC_SPTR(ccmode_ecb, roundkey))(const ccecb_ctx *ctx, unsigned r, void *key);
    cc_impl_t impl;
};
struct ccmode_cbc {
    size_t size; 
    size_t block_size;
    int (*CC_SPTR(ccmode_cbc, init))(const struct ccmode_cbc *cbc, cccbc_ctx *ctx, size_t key_len, const void *key);
    
    int (*CC_SPTR(ccmode_cbc, cbc))(const cccbc_ctx *ctx, cccbc_iv *iv, size_t nblocks, const void *in, void *out);
    const void *custom;
};
struct ccmode_cfb {
    size_t size; 
    size_t block_size;
    int (*CC_SPTR(ccmode_cfb,
                  init))(const struct ccmode_cfb *cfb, cccfb_ctx *ctx, size_t key_len, const void *key, const void *iv);
    int (*CC_SPTR(ccmode_cfb, cfb))(cccfb_ctx *ctx, size_t nbytes, const void *in, void *out);
    const void *custom;
};
struct ccmode_cfb8 {
    size_t size; 
    size_t block_size;
    int (*CC_SPTR(ccmode_cfb8,
                  init))(const struct ccmode_cfb8 *cfb8, cccfb8_ctx *ctx, size_t key_len, const void *key, const void *iv);
    int (*CC_SPTR(ccmode_cfb8, cfb8))(cccfb8_ctx *ctx, size_t nbytes, const void *in, void *out);
    const void *custom;
};
struct ccmode_ctr {
    size_t size;           
    size_t block_size;     
    size_t ecb_block_size; 
    int (*CC_SPTR(ccmode_ctr,
                  init))(const struct ccmode_ctr *mode, ccctr_ctx *ctx, size_t key_len, const void *key, const void *iv);
    int (*CC_SPTR(ccmode_ctr, setctr))(const struct ccmode_ctr *mode, ccctr_ctx *ctx, const void *ctr);
    int (*CC_SPTR(ccmode_ctr, ctr))(ccctr_ctx *ctx, size_t nbytes, const void *in, void *out);
    const void *custom;
};
struct ccmode_ofb {
    size_t size; 
    size_t block_size;
    int (*CC_SPTR(ccmode_ofb,
                  init))(const struct ccmode_ofb *ofb, ccofb_ctx *ctx, size_t key_len, const void *key, const void *iv);
    int (*CC_SPTR(ccmode_ofb, ofb))(ccofb_ctx *ctx, size_t nbytes, const void *in, void *out);
    const void *custom;
};
struct ccmode_xts {
    size_t size;       
    size_t tweak_size; 
    size_t block_size;

    
    int (*CC_SPTR(ccmode_xts, init))(const struct ccmode_xts *xts,
                                     ccxts_ctx *ctx,
                                     size_t key_nbytes,
                                     const void *data_key,
                                     const void *tweak_key);

    void (*CC_SPTR(ccmode_xts, key_sched))(const struct ccmode_xts *xts,
                                           ccxts_ctx *ctx,
                                           size_t key_nbytes,
                                           const void *data_key,
                                           const void *tweak_key);

    
    int (*CC_SPTR(ccmode_xts, set_tweak))(const ccxts_ctx *ctx, ccxts_tweak *tweak, const void *iv);

    
    void *(*CC_SPTR(ccmode_xts, xts))(const ccxts_ctx *ctx, ccxts_tweak *tweak, size_t nblocks, const void *in, void *out);

    const void *custom;
    const void *custom1;
    cc_impl_t impl;
};
struct ccmode_gcm {
    size_t size; 
    int encdec;  
    size_t block_size;
    int (*CC_SPTR(ccmode_gcm, init))(const struct ccmode_gcm *gcm, ccgcm_ctx *ctx, size_t key_nbytes, const void *key);
    int (*CC_SPTR(ccmode_gcm, set_iv))(ccgcm_ctx *ctx, size_t iv_nbytes, const void *iv);
    int (*CC_SPTR(ccmode_gcm, gmac))(ccgcm_ctx *ctx, size_t nbytes, const void *in); 
    int (*CC_SPTR(ccmode_gcm, gcm))(ccgcm_ctx *ctx, size_t nbytes, const void *in, void *out);
    int (*CC_SPTR(ccmode_gcm, finalize))(ccgcm_ctx *key, size_t tag_nbytes, void *tag);
    int (*CC_SPTR(ccmode_gcm, reset))(ccgcm_ctx *ctx);
    const void *custom;
};
struct ccmode_ccm {
    size_t size;       
    size_t nonce_size; 
    size_t block_size;
    int (*CC_SPTR(ccmode_ccm, init))(const struct ccmode_ccm *ccm, ccccm_ctx *ctx, size_t key_len, const void *key);
    int (*CC_SPTR(ccmode_ccm, set_iv))(ccccm_ctx *ctx,
                                       ccccm_nonce *nonce_ctx,
                                       size_t nonce_len,
                                       const void *nonce,
                                       size_t mac_size,
                                       size_t auth_len,
                                       size_t data_len);
    int (*CC_SPTR(ccmode_ccm, cbcmac))(ccccm_ctx *ctx,
                                       ccccm_nonce *nonce_ctx,
                                       size_t nbytes,
                                       const void *in); 
    int (*CC_SPTR(ccmode_ccm, ccm))(ccccm_ctx *ctx, ccccm_nonce *nonce_ctx, size_t nbytes, const void *in, void *out);
    int (*CC_SPTR(ccmode_ccm, finalize))(ccccm_ctx *key, ccccm_nonce *nonce_ctx, void *mac);
    int (*CC_SPTR(ccmode_ccm, reset))(ccccm_ctx *key, ccccm_nonce *nonce_ctx);
    const void *custom;
    bool enc_mode;
};
struct _ccmode_ccm_nonce {
    unsigned char A_i[16]; 
    unsigned char B_i[16]; 
    unsigned char MAC[16]; 
    unsigned char buf[16]; 

    uint32_t mode;    
    uint32_t buflen;  
    uint32_t b_i_len; 

    size_t nonce_size;
    size_t mac_size;
};
struct ccmode_omac {
    size_t size; 
    size_t block_size;
    int (*CC_SPTR(ccmode_omac,
                  init))(const struct ccmode_omac *omac, ccomac_ctx *ctx, size_t tweak_len, size_t key_len, const void *key);
    int (*CC_SPTR(ccmode_omac, omac))(ccomac_ctx *ctx, size_t nblocks, const void *tweak, const void *in, void *out);
    const void *custom;
};
struct ccmode_siv {
    size_t size;        
    size_t block_size;
    int (*CC_SPTR(ccmode_siv, init))(const struct ccmode_siv *siv, ccsiv_ctx *ctx,
                 size_t key_len, const uint8_t *key);
    int (*CC_SPTR(ccmode_siv, set_nonce))(ccsiv_ctx *ctx,  size_t nbytes, const uint8_t *in);  
    int (*CC_SPTR(ccmode_siv, auth))(ccsiv_ctx *ctx,  size_t nbytes, const uint8_t *in);  
    int (*CC_SPTR(ccmode_siv, crypt))(ccsiv_ctx *ctx, size_t nbytes, const uint8_t *in, uint8_t *out);
    int (*CC_SPTR(ccmode_siv, reset))(ccsiv_ctx *ctx);
    const struct ccmode_cbc *cbc;
    const struct ccmode_ctr *ctr;
};
struct ccmode_siv_hmac {
    size_t size; 
    size_t block_size;
    
    int (*CC_SPTR(ccmode_siv_hmac, init))(const struct ccmode_siv_hmac *sivhmac,
                ccsiv_hmac_ctx *ctx,
                size_t key_len,
                const uint8_t *key,
                const size_t tag_size);
    int (*CC_SPTR(ccmode_siv_hmac, set_nonce))(ccsiv_hmac_ctx *ctx, size_t nbytes, const uint8_t *in);
    int (*CC_SPTR(ccmode_siv_hmac, auth))(ccsiv_hmac_ctx *ctx, size_t nbytes, const uint8_t *in);
    int (*CC_SPTR(ccmode_siv_hmac, crypt))(ccsiv_hmac_ctx *ctx, size_t nbytes, const uint8_t *in, uint8_t *out);
    int (*CC_SPTR(ccmode_siv_hmac, reset))(ccsiv_hmac_ctx *ctx);
    const struct ccdigest_info *hmac_digest; 
    const struct ccmode_ctr *ctr;
};
struct ccrng_state {
    CCRNG_STATE_COMMON
};
struct ccrng_crypto_ctx {
    CCRNG_STATE_COMMON

    ccentropy_ctx_t *entropy_ctx;
    ccrng_schedule_ctx_t *schedule_ctx;
    cc_lock_ctx_t *lock_ctx;

    const struct ccdrbg_info *drbg_info;
    struct ccdrbg_state *drbg_ctx;

    size_t generate_chunk_nbytes;
    size_t seed_nbytes;

    size_t cache_nbytes;
    uint8_t *cache;
    size_t cache_pos;
} ccrng_crypto_ctx_t;
struct ccrng_fortuna_pool_ctx {
    uint8_t data[CCRNG_FORTUNA_POOL_NBYTES];

    
    uint64_t nsamples;

    
    uint64_t ndrains;

    
    uint64_t nsamples_max;
};
struct ccrng_fortuna_sched_ctx {
    
    uint64_t reseed_sched;

    
    unsigned pool_idx;
};
struct ccrng_fortuna_ctx {
    CCRNG_STATE_COMMON

    
    uint8_t key[CCRNG_FORTUNA_KEY_NBYTES];

    
    uint8_t ctr[16];

    
    struct ccrng_fortuna_sched_ctx sched;

    
    cc_lock_ctx_t lock;

    
    struct ccrng_fortuna_pool_ctx pools[CCRNG_FORTUNA_NPOOLS];

    
    CC_SPTR(ccrng_fortuna_ctx, ccrng_fortuna_getentropy) getentropy;

    
    void *getentropy_arg;

    
    
    
    
    
    
    bool seeded;

    
    uint64_t nreseeds;

    
    uint64_t schedreseed_nsamples_max;

    
    uint64_t addentropy_nsamples_max;
};
struct ccrng_schedule_info {
    ccrng_schedule_action_t (*read)(ccrng_schedule_ctx_t *ctx);
    void (*notify_reseed)(ccrng_schedule_ctx_t *ctx);
} ccrng_schedule_info_t;
struct ccrng_schedule_ctx {
    const ccrng_schedule_info_t *info;
    bool must_reseed;
};
struct ccrng_schedule_atomic_flag_ctx {
    ccrng_schedule_ctx_t schedule_ctx;
    _Atomic ccrng_schedule_action_t flag;
} ccrng_schedule_atomic_flag_ctx_t;
struct ccrng_schedule_constant_ctx {
    ccrng_schedule_ctx_t schedule_ctx;
    ccrng_schedule_action_t action;
} ccrng_schedule_constant_ctx_t;
struct ccrng_schedule_timer_ctx {
    ccrng_schedule_ctx_t schedule_ctx;
    uint64_t (*get_time)(void);
    uint64_t reseed_interval;
    uint64_t last_reseed_time;
} ccrng_schedule_timer_ctx_t;
struct ccrng_schedule_tree_ctx {
    ccrng_schedule_ctx_t schedule_ctx;
    ccrng_schedule_ctx_t *left;
    ccrng_schedule_ctx_t *right;
} ccrng_schedule_tree_ctx_t;
struct ccrng_schedule_drbg_ctx {
    ccrng_schedule_ctx_t schedule_ctx;
    const struct ccdrbg_info *drbg_info;
    struct ccdrbg_state *drbg_ctx;
} ccrng_schedule_drbg_ctx_t;
struct ccrsa_full_ctx {
    __CCZP_ELEMENTS_DEFINITIONS(pb_)
} CC_ALIGNED(CCN_UNIT_SIZE);
struct ccrsa_pub_ctx {
    __CCZP_ELEMENTS_DEFINITIONS(pb_)
} CC_ALIGNED(CCN_UNIT_SIZE);
struct cczp {
    __CCZP_ELEMENTS_DEFINITIONS()
} CC_ALIGNED(CCN_UNIT_SIZE);
struct {
    uint64_t version;
    typeof(&CEAcquireUnmanagedContext) AcquireUnmanagedContext;
    typeof(&CEValidate) Validate;
    typeof(&CEContextQuery) ContextQuery;
    typeof(&CEConjureContextFromDER) ConjureContextFromDER;
    
    typeof(&der_vm_context_create) der_vm_context_create;
    typeof(&der_vm_execute) der_vm_execute;
    typeof(&der_vm_iterate) der_vm_iterate;
    typeof(&der_vm_context_is_valid) der_vm_context_is_valid;
    typeof(&der_vm_CEType_from_context) der_vm_CEType_from_context;
    typeof(&der_vm_integer_from_context) der_vm_integer_from_context;
    typeof(&der_vm_string_from_context) der_vm_string_from_context;
    typeof(&der_vm_bool_from_context) der_vm_bool_from_context;
    
    typeof(kCENoError) kNoError;
    typeof(kCEAPIMisuse) kAPIMisuse;
    typeof(kCEInvalidArgument) kInvalidArgument;
    typeof(kCEAllocationFailed) kAllocationFailed;
    typeof(kCEMalformedEntitlements) kMalformedEntitlements;
    typeof(kCEQueryCannotBeSatisfied) kQueryCannotBeSatisfied;

    typeof(&CEGetErrorString) GetErrorString;
    
    typeof(&der_vm_buffer_from_context) der_vm_buffer_from_context;
    typeof(&CEContextIsSubset) CEContextIsSubset;
    
} coreentitlements_t;
struct der_vm_context {
    CERuntime_t runtime;
    ccder_tag dictionary_tag;
    bool sorted;
    bool valid;
    union {
        
        ccder_read_blob ccstate;
        
        
        struct {
            const uint8_t *__ended_by(der_end) der_start;
            const uint8_t *der_end;
        } state;
    };
} der_vm_context_t;
struct {
    der_vm_context_t original;
    der_vm_context_t active;
    CEType_t parent_type;
    CEType_t active_type;
    void* user_data;
} der_vm_iteration_context;
struct {
    CEVersion_t version;
    const uint8_t *__ended_by(blob_end) blob;
    const uint8_t * blob_end;
} CEValidationResult;
struct {
    bool allow_data_elements;
} CEValidationOptions;
struct CEQueryOperation {
    CEQueryOpOpcode_t opcode;
    union {
        CEBuffer dynamicParameter;
        CEStaticBuffer stringParameter;
        int64_t numericParameter;
    } parameters;
} CEQueryOperation_t;
struct CEPrepareOptions {
    
    bool materialize;
    
    bool failOnOversizedParameters;
} CEPrepareOptions_t;
struct CEQueryContext {
    der_vm_context_t der_context;
    bool managed;
};
struct CEAccelerationElement {
    uint32_t key_offset;
    uint32_t key_length;
} CEAccelerationElement_t;
struct CEAccelerationContext {
    CEAccelerationElement_t * __counted_by(index_count) index;
    size_t index_count;
};
struct {
    const uint8_t *__counted_by(length) data;
    size_t length;
} CEBuffer;
struct {
    uint8_t data[CE_MAX_KEY_SIZE];
    size_t length;
} CEStaticBuffer;
struct CERuntime {
    const uint64_t                  version;
    const CERuntimeMalloc           alloc;
    const CERuntimeFree             free;
    const CERuntimeLog              log;
    const CERuntimeAbort            abort;
    const CERuntimeInternalStatus   internalStatus;
    const CERuntimeAllocIndex       allocIndex;
    const CERuntimeFreeIndex        freeIndex;
} ;
struct CESerializedElement {
    CESerializedElementType_t type;
    union {
        int64_t value;
    } data;
    size_t length;
    bool pair;
} CESerializedElement_t;
struct x509_octet_string {
    const CT_uint8_t * __counted_by(length) data;
    CT_size_t length;
} CTAsn1Item;
struct baa_identity {
    CT_uint32_t chipId;
    CT_uint64_t ecid;
    CT_bool productionStatus;
    CT_bool securityMode;
    CT_uint8_t securityDomain;
    CTAsn1Item img4;
} CTBAAIdentity;
struct _image4_environment_callbacks {
	image4_struct_version_t nvcb_version;
	image4_environment_query_boot_nonce_t _Nullable nvcb_query_boot_nonce;
	image4_environment_query_nonce_digest_t _Nullable nvcb_query_nonce_digest;
	image4_environment_identifier_bool_t _Nullable nvcb_identifier_bool;
	image4_environment_identifier_integer_t _Nullable nvcb_identifier_integer;
	image4_environment_identifier_data_t _Nullable nvcb_identifier_data;
} image4_environment_callbacks_t;
struct _image4_environment_storage {
	uint8_t __opaque[256];
};
struct _image4_trust_storage {
	uint8_t __opaque[2048];
} image4_trust_storage_t;
struct _img4_chip_instance {
	img4_struct_version_t chid_version;
	const img4_chip_t *chid_chip_family;
	img4_chip_instance_omit_t chid_omit;
	uint32_t chid_cepo;
	uint32_t chid_bord;
	uint32_t chid_chip;
	uint32_t chid_sdom;
	uint64_t chid_ecid;
	bool chid_cpro;
	bool chid_csec;
	bool chid_epro;
	bool chid_esec;
	bool chid_iuou;
	bool chid_rsch;
	bool chid_euou;
	uint32_t chid_esdm;
	bool chid_fpgt;
	img4_dgst_t chid_udid;
	uint32_t chid_fchp;
	uint32_t chid_type;
	uint32_t chid_styp;
	uint32_t chid_clas;
} img4_chip_instance_t;
struct _img4_dgst {
	img4_struct_version_t i4d_version;
	size_t i4d_len;
	uint8_t i4d_bytes[IMG4_DGST_MAX_LEN];
} img4_dgst_t;
struct _img4_cstr {
	size_t i4cs_len;
	char i4cs_cstr[64];
} img4_cstr_t;
struct _img4_firmware_execution_context {
	img4_struct_version_t i4fex_version;
	img4_firmware_authenticated_execute_t i4fex_execute;
	void *i4fex_context;
} img4_firmware_execution_context_t;
struct _img4_nonce {
	img4_struct_version_t i4n_version;
	uint8_t i4n_nonce[IMG4_NONCE_MAX_LENGTH];
	uint32_t i4n_length;
} img4_nonce_t;
struct _img4_buff {
	img4_struct_version_t i4b_version;
	uint8_t *__counted_by(i4b_len) i4b_bytes;
	size_t i4b_len;
	img4_runtime_dealloc_t _Nullable i4b_dealloc;
} IMG4_API_AVAILABLE_20200508;
struct _img4_runtime {
	img4_struct_version_t i4rt_version;
	const char *i4rt_name;
	img4_runtime_init_t _Nullable i4rt_init;
	img4_runtime_alloc_t i4rt_alloc;
	img4_runtime_dealloc_t i4rt_dealloc;
	img4_runtime_log_t i4rt_log;
	img4_runtime_log_handle_t i4rt_log_handle;
	img4_runtime_get_identifier_bool_t i4rt_get_identifier_bool;
	img4_runtime_get_identifier_uint32_t i4rt_get_identifier_uint32;
	img4_runtime_get_identifier_uint64_t i4rt_get_identifier_uint64;
	img4_runtime_get_identifier_digest_t i4rt_get_identifier_digest;
	void *_Nullable i4rt_context;
	img4_runtime_get_identifier_cstr_t i4rt_get_identifier_cstr;
	img4_runtime_execute_object_t i4rt_execute_object;
	img4_runtime_copy_object_t i4rt_copy_object;
	img4_runtime_alloc_type_t i4rt_alloc_type;
	img4_runtime_dealloc_type_t i4rt_dealloc_type;
	img4_runtime_set_nonce_t i4rt_set_nonce;
	img4_runtime_roll_nonce_t i4rt_roll_nonce;
	img4_runtime_copy_nonce_t i4rt_copy_nonce;
} IMG4_API_AVAILABLE_20200508;
struct fat_header {
	uint32_t	magic;		
	uint32_t	nfat_arch;	
};
struct fat_arch {
	cpu_type_t	cputype;	
	cpu_subtype_t	cpusubtype;	
	uint32_t	offset;		
	uint32_t	size;		
	uint32_t	align;		
};
struct mach_header {
	uint32_t	magic;		
	cpu_type_t	cputype;	
	cpu_subtype_t	cpusubtype;	
	uint32_t	filetype;	
	uint32_t	ncmds;		
	uint32_t	sizeofcmds;	
	uint32_t	flags;		
};
struct mach_header_64 {
	uint32_t	magic;		
	cpu_type_t	cputype;	
	cpu_subtype_t	cpusubtype;	
	uint32_t	filetype;	
	uint32_t	ncmds;		
	uint32_t	sizeofcmds;	
	uint32_t	flags;		
	uint32_t	reserved;	
};
struct load_command {
	uint32_t cmd;		
	uint32_t cmdsize;	
};
struct segment_command { 
	uint32_t	cmd;		
	uint32_t	cmdsize;	
	char		segname[16];	
	uint32_t	vmaddr;		
	uint32_t	vmsize;		
	uint32_t	fileoff;	
	uint32_t	filesize;	
	vm_prot_t	maxprot;	
	vm_prot_t	initprot;	
	uint32_t	nsects;		
	uint32_t	flags;		
};
struct segment_command_64 { 
	uint32_t	cmd;		
	uint32_t	cmdsize;	
	char		segname[16];	
	uint64_t	vmaddr;		
	uint64_t	vmsize;		
	uint64_t	fileoff;	
	uint64_t	filesize;	
	vm_prot_t	maxprot;	
	vm_prot_t	initprot;	
	uint32_t	nsects;		
	uint32_t	flags;		
};
struct section { 
	char		sectname[16];	
	char		segname[16];	
	uint32_t	addr;		
	uint32_t	size;		
	uint32_t	offset;		
	uint32_t	align;		
	uint32_t	reloff;		
	uint32_t	nreloc;		
	uint32_t	flags;		
	uint32_t	reserved1;	
	uint32_t	reserved2;	
};
struct section_64 { 
	char		sectname[16];	
	char		segname[16];	
	uint64_t	addr;		
	uint64_t	size;		
	uint32_t	offset;		
	uint32_t	align;		
	uint32_t	reloff;		
	uint32_t	nreloc;		
	uint32_t	flags;		
	uint32_t	reserved1;	
	uint32_t	reserved2;	
	uint32_t	reserved3;	
};
struct fvmlib {
	union lc_str	name;		
	uint32_t	minor_version;	
	uint32_t	header_addr;	
};
struct fvmlib_command {
	uint32_t	cmd;		
	uint32_t	cmdsize;	
	struct fvmlib	fvmlib;		
};
struct dylib {
    union lc_str  name;			
    uint32_t timestamp;			
    uint32_t current_version;		
    uint32_t compatibility_version;	
};
struct dylib_command {
	uint32_t	cmd;		
	uint32_t	cmdsize;	
	struct dylib	dylib;		
};
struct sub_framework_command {
	uint32_t	cmd;		
	uint32_t	cmdsize;	
	union lc_str 	umbrella;	
};
struct sub_client_command {
	uint32_t	cmd;		
	uint32_t	cmdsize;	
	union lc_str 	client;		
};
struct sub_umbrella_command {
	uint32_t	cmd;		
	uint32_t	cmdsize;	
	union lc_str 	sub_umbrella;	
};
struct sub_library_command {
	uint32_t	cmd;		
	uint32_t	cmdsize;	
	union lc_str 	sub_library;	
};
struct prebound_dylib_command {
	uint32_t	cmd;		
	uint32_t	cmdsize;	
	union lc_str	name;		
	uint32_t	nmodules;	
	union lc_str	linked_modules;	
};
struct dylinker_command {
	uint32_t	cmd;		
	uint32_t	cmdsize;	
	union lc_str    name;		
};
struct thread_command {
	uint32_t	cmd;		
	uint32_t	cmdsize;	
};
struct routines_command { 
	uint32_t	cmd;		
	uint32_t	cmdsize;	
	uint32_t	init_address;	
	uint32_t	init_module;	
				        
	uint32_t	reserved1;
	uint32_t	reserved2;
	uint32_t	reserved3;
	uint32_t	reserved4;
	uint32_t	reserved5;
	uint32_t	reserved6;
};
struct routines_command_64 { 
	uint32_t	cmd;		
	uint32_t	cmdsize;	
	uint64_t	init_address;	
	uint64_t	init_module;	
					
	uint64_t	reserved1;
	uint64_t	reserved2;
	uint64_t	reserved3;
	uint64_t	reserved4;
	uint64_t	reserved5;
	uint64_t	reserved6;
};
struct symtab_command {
	uint32_t	cmd;		
	uint32_t	cmdsize;	
	uint32_t	symoff;		
	uint32_t	nsyms;		
	uint32_t	stroff;		
	uint32_t	strsize;	
};
struct dysymtab_command {
    uint32_t cmd;	
    uint32_t cmdsize;	

    
    uint32_t ilocalsym;	
    uint32_t nlocalsym;	

    uint32_t iextdefsym;
    uint32_t nextdefsym;

    uint32_t iundefsym;	
    uint32_t nundefsym;	

    
    uint32_t tocoff;	
    uint32_t ntoc;	

    
    uint32_t modtaboff;	
    uint32_t nmodtab;	

    
    uint32_t extrefsymoff;	
    uint32_t nextrefsyms;	

    
    uint32_t indirectsymoff; 
    uint32_t nindirectsyms;  

    
    uint32_t extreloff;	
    uint32_t nextrel;	

    
    uint32_t locreloff;	
    uint32_t nlocrel;	

};
struct dylib_table_of_contents {
    uint32_t symbol_index;	
    uint32_t module_index;	
};
struct dylib_module {
    uint32_t module_name;	

    uint32_t iextdefsym;	
    uint32_t nextdefsym;	
    uint32_t irefsym;		
    uint32_t nrefsym;		
    uint32_t ilocalsym;		
    uint32_t nlocalsym;		

    uint32_t iextrel;		
    uint32_t nextrel;		

    uint32_t iinit_iterm;	
    uint32_t ninit_nterm;	

    uint32_t			
	objc_module_info_addr;  
    uint32_t			
	objc_module_info_size;	
};
struct dylib_module_64 {
    uint32_t module_name;	

    uint32_t iextdefsym;	
    uint32_t nextdefsym;	
    uint32_t irefsym;		
    uint32_t nrefsym;		
    uint32_t ilocalsym;		
    uint32_t nlocalsym;		

    uint32_t iextrel;		
    uint32_t nextrel;		

    uint32_t iinit_iterm;	
    uint32_t ninit_nterm;      

    uint32_t			
        objc_module_info_size;	
    uint64_t			
        objc_module_info_addr;	
};
struct dylib_reference {
    uint32_t isym:24,		
    		  flags:8;	
};
struct twolevel_hints_command {
    uint32_t cmd;	
    uint32_t cmdsize;	
    uint32_t offset;	
    uint32_t nhints;	
};
struct twolevel_hint {
    uint32_t 
	isub_image:8,	
	itoc:24;	
};
struct prebind_cksum_command {
    uint32_t cmd;	
    uint32_t cmdsize;	
    uint32_t cksum;	
};
struct uuid_command {
    uint32_t	cmd;		
    uint32_t	cmdsize;	
    uint8_t	uuid[16];	
};
struct rpath_command {
    uint32_t	 cmd;		
    uint32_t	 cmdsize;	
    union lc_str path;		
};
struct linkedit_data_command {
    uint32_t	cmd;		
    uint32_t	cmdsize;	
    uint32_t	dataoff;	
    uint32_t	datasize;	
};
struct fileset_entry_command {
    uint32_t        cmd;        
    uint32_t        cmdsize;    
    uint64_t        vmaddr;     
    uint64_t        fileoff;    
    union lc_str    entry_id;   
    uint32_t        reserved;   
};
struct encryption_info_command {
   uint32_t	cmd;		
   uint32_t	cmdsize;	
   uint32_t	cryptoff;	
   uint32_t	cryptsize;	
   uint32_t	cryptid;	
};
struct encryption_info_command_64 {
   uint32_t	cmd;		
   uint32_t	cmdsize;	
   uint32_t	cryptoff;	
   uint32_t	cryptsize;	
   uint32_t	cryptid;	
   uint32_t	pad;		
};
struct version_min_command {
    uint32_t	cmd;		
    uint32_t	cmdsize;	
    uint32_t	version;	
    uint32_t	sdk;		
};
struct build_version_command {
    uint32_t	cmd;		
    uint32_t	cmdsize;	
                                
    uint32_t	platform;	
    uint32_t	minos;		
    uint32_t	sdk;		
    uint32_t	ntools;		
};
struct build_tool_version {
    uint32_t	tool;		
    uint32_t	version;	
};
struct dyld_info_command {
   uint32_t   cmd;		
   uint32_t   cmdsize;		

    
    uint32_t   rebase_off;	
    uint32_t   rebase_size;	
    
    
    uint32_t   bind_off;	
    uint32_t   bind_size;	
        
    
    uint32_t   weak_bind_off;	
    uint32_t   weak_bind_size;  
    
    
    uint32_t   lazy_bind_off;	
    uint32_t   lazy_bind_size;  
    
    
    uint32_t   export_off;	
    uint32_t   export_size;	
};
struct linker_option_command {
    uint32_t  cmd;	
    uint32_t  cmdsize;
    uint32_t  count;	
    
};
struct symseg_command {
	uint32_t	cmd;		
	uint32_t	cmdsize;	
	uint32_t	offset;		
	uint32_t	size;		
};
struct ident_command {
	uint32_t cmd;		
	uint32_t cmdsize;	
};
struct fvmfile_command {
	uint32_t cmd;			
	uint32_t cmdsize;		
	union lc_str	name;		
	uint32_t	header_addr;	
};
struct entry_point_command {
    uint32_t  cmd;	
    uint32_t  cmdsize;	
    uint64_t  entryoff;	
    uint64_t  stacksize;
};
struct source_version_command {
    uint32_t  cmd;	
    uint32_t  cmdsize;	
    uint64_t  version;	
};
struct data_in_code_entry {
    uint32_t	offset;  
    uint16_t	length;  
    uint16_t	kind;    
};
struct note_command {
    uint32_t	cmd;		
    uint32_t	cmdsize;	
    char	data_owner[16];	
    uint64_t	offset;		
    uint64_t	size;		
};
struct nlist {
	union {
		uint32_t n_strx;	
	} n_un;
	uint8_t n_type;		
	uint8_t n_sect;		
	int16_t n_desc;		
	uint32_t n_value;	
};
struct nlist_64 {
    union {
        uint32_t  n_strx; 
    } n_un;
    uint8_t n_type;        
    uint8_t n_sect;        
    uint16_t n_desc;       
    uint64_t n_value;      
};
struct relocation_info {
   int32_t	r_address;	
   uint32_t     r_symbolnum:24,	
		r_pcrel:1, 	
		r_length:2,	
		r_extern:1,	
		r_type:4;	
};
struct scattered_relocation_info {
};
struct __darwin_pthread_handler_rec {
	void (*__routine)(void *);	
	void *__arg;			
	struct __darwin_pthread_handler_rec *__next;
};
struct _opaque_pthread_attr_t {
	long __sig;
	char __opaque[__PTHREAD_ATTR_SIZE__];
};
struct _opaque_pthread_cond_t {
	long __sig;
	char __opaque[__PTHREAD_COND_SIZE__];
};
struct _opaque_pthread_condattr_t {
	long __sig;
	char __opaque[__PTHREAD_CONDATTR_SIZE__];
};
struct _opaque_pthread_mutex_t {
	long __sig;
	char __opaque[__PTHREAD_MUTEX_SIZE__];
};
struct _opaque_pthread_mutexattr_t {
	long __sig;
	char __opaque[__PTHREAD_MUTEXATTR_SIZE__];
};
struct _opaque_pthread_once_t {
	long __sig;
	char __opaque[__PTHREAD_ONCE_SIZE__];
};
struct _opaque_pthread_rwlock_t {
	long __sig;
	char __opaque[__PTHREAD_RWLOCK_SIZE__];
};
struct _opaque_pthread_rwlockattr_t {
	long __sig;
	char __opaque[__PTHREAD_RWLOCKATTR_SIZE__];
};
struct _opaque_pthread_t {
	long __sig;
	struct __darwin_pthread_handler_rec  *__cleanup_stack;
	char __opaque[__PTHREAD_SIZE__];
};
struct _cr0 {
    unsigned int	pe	:1,
    			mp	:1,
			em	:1,
			ts	:1,
				:1,
			ne	:1,
				:10,
			wp	:1,
				:1,
			am	:1,
				:10,
			nw	:1,
			cd	:1,
			pg	:1;
} cr0_t;
struct code_desc {
    unsigned short	limit00;
    unsigned short	base00;
    unsigned char	base16;
    unsigned char	type	:5,
			dpl	:2,
			present	:1;
    unsigned char	limit16	:4,
				:1,
                        Lflag   :1,
			opsz	:1,
			granular:1;
    unsigned char	base24;
} code_desc_t;
struct data_desc {
    unsigned short	limit00;
    unsigned short	base00;
    unsigned char	base16;
    unsigned char	type	:5,
			dpl	:2,
			present	:1;
    unsigned char	limit16	:4,
				:2,
			stksz	:1,
			granular:1;
    unsigned char	base24;
} data_desc_t;
struct ldt_desc {
    unsigned short	limit00;
    unsigned short	base00;
    unsigned char	base16;
    unsigned char	type	:5,
				:2,
			present	:1;
    unsigned char	limit16	:4,
				:3,
			granular:1;
    unsigned char	base24;
} ldt_desc_t;
struct call_gate {
    unsigned short	offset00;
    sel_t		seg;
    unsigned int	argcnt	:5,
    				:3,
			type	:5,
			dpl	:2,
			present	:1,
			offset16:16;
} call_gate_t;
struct trap_gate {
    unsigned short	offset00;
    sel_t		seg;
    unsigned int		:8,
    			type	:5,
			dpl	:2,
			present	:1,
			offset16:16;
} trap_gate_t;
struct intr_gate {
    unsigned short	offset00;
    sel_t		seg;
    unsigned int		:8,
    			type	:5,
			dpl	:2,
			present	:1,
			offset16:16;
} intr_gate_t;
struct sel {
    unsigned short	rpl	:2,
			ti	:1,
			index	:13;
} sel_t;
struct tss {
    sel_t		oldtss;
    unsigned int		:0;
    unsigned int	esp0;
    sel_t		ss0;
    unsigned int		:0;
    unsigned int	esp1;
    sel_t		ss1;
    unsigned int		:0;
    unsigned int	esp2;
    sel_t		ss2;
    unsigned int		:0;
    unsigned int	cr3;
    unsigned int	eip;
    unsigned int	eflags;
    unsigned int	eax;
    unsigned int	ecx;
    unsigned int	edx;
    unsigned int	ebx;
    unsigned int	esp;
    unsigned int	ebp;
    unsigned int	esi;
    unsigned int	edi;
    sel_t		es;
    unsigned int		:0;
    sel_t		cs;
    unsigned int		:0;
    sel_t		ss;
    unsigned int		:0;
    sel_t		ds;
    unsigned int		:0;
    sel_t		fs;
    unsigned int		:0;
    sel_t		gs;
    unsigned int		:0;
    sel_t		ldt;
    unsigned int		:0;
    unsigned int	t	:1,
    				:15,
			io_bmap	:16;
} tss_t;
struct tss_desc {
    unsigned short	limit00;
    unsigned short	base00;
    unsigned char	base16;
    unsigned char	type	:5,
			dpl	:2,
			present	:1;
    unsigned char	limit16	:4,
				:3,
			granular:1;
    unsigned char	base24;
} tss_desc_t;
struct task_gate {
    unsigned short		:16;
    sel_t		tss;
    unsigned int		:8,
    			type	:5,
			dpl	:2,
			present	:1,
				:0;
} task_gate_t;
struct fasttrap_machtp {
	fasttrap_instr_t        ftmt_instr;     

	uint8_t                 ftmt_fntype;    
	uint8_t                 ftmt_thumb;

	uint8_t                 ftmt_type;
	uint8_t                 ftmt_installed:1;
	uint8_t                 ftmt_retired:1;
} fasttrap_machtp_t;
struct au_tid {
	dev_t           port;
	u_int32_t       machine;
};
struct au_tid_addr {
	dev_t           at_port;
	u_int32_t       at_type;
	u_int32_t       at_addr[4];
};
struct au_mask {
	unsigned int    am_success;     
	unsigned int    am_failure;     
};
struct auditinfo {
	au_id_t         ai_auid;        
	au_mask_t       ai_mask;        
	au_tid_t        ai_termid;      
	au_asid_t       ai_asid;        
};
struct auditinfo_addr {
	au_id_t         ai_auid;        
	au_mask_t       ai_mask;        
	au_tid_addr_t   ai_termid;      
	au_asid_t       ai_asid;        
	au_asflgs_t     ai_flags;       
};
struct auditpinfo {
	pid_t           ap_pid;         
	au_id_t         ap_auid;        
	au_mask_t       ap_mask;        
	au_tid_t        ap_termid;      
	au_asid_t       ap_asid;        
};
struct auditpinfo_addr {
	pid_t           ap_pid;         
	au_id_t         ap_auid;        
	au_mask_t       ap_mask;        
	au_tid_addr_t   ap_termid;      
	au_asid_t       ap_asid;        
	au_asflgs_t     ap_flags;       
};
struct au_session {
	auditinfo_addr_t        *as_aia_p;      
	au_mask_t                as_mask;       
};
struct au_expire_after {
	time_t age;             
	size_t size;    
	unsigned char op_type; 
};
struct au_qctrl {
	int     aq_hiwater;     
	                        

	int     aq_lowater;     
	                        

	int     aq_bufsz;       
	int     aq_delay;       
	int     aq_minfree;     
};
struct audit_stat {
	unsigned int    as_version;
	unsigned int    as_numevent;
	int             as_generated;
	int             as_nonattrib;
	int             as_kernel;
	int             as_audit;
	int             as_auditctl;
	int             as_enqueue;
	int             as_written;
	int             as_wblocked;
	int             as_rblocked;
	int             as_dropped;
	int             as_totalsize;
	unsigned int    as_memused;
};
struct audit_fstat {
	u_int64_t       af_filesz;
	u_int64_t       af_currsz;
};
struct au_evclass_map {
	au_event_t      ec_number;
	au_class_t      ec_class;
};
struct au_token {
	u_char                  *t_data;
	size_t                   len;
	TAILQ_ENTRY(au_token)    tokens;
};
struct au_record {
	char                     used;          
	int                      desc;          
	TAILQ_HEAD(, au_token)   token_q;       
	u_char                  *data;
	size_t                   len;
	LIST_ENTRY(au_record)    au_rec_q;
};
struct km_drawrect {
	unsigned short x;       
	unsigned short y;
	unsigned short width;   
	unsigned short height;
	union {
		void *bits;     
		int   fill;     
	} data;
};
struct mdev {
	uint64_t        mdBase;         
	uint32_t        mdSize;         
	int                     mdFlags;        
	int                     mdSecsize;      
	int                     mdBDev;         
	int                     mdCDev;         
	void *          mdbdevb;
	void *          mdcdevb;
} mdev[NB_MAX_MDEVICES];
struct d86opnd {
	char            d86_opnd[OPLEN];        
	char            d86_prefix[PFIXLEN];    
	uint_t          d86_mode;               
	uint_t          d86_value_size;         
	uint64_t        d86_value;              
} d86opnd_t;
struct dis86 {
	uint_t          d86_mode;
	uint_t          d86_error;
	uint_t          d86_len;                
	int             d86_rmindex;            
	uint_t          d86_memsize;            
	char            d86_bytes[16];          
	char            d86_mnem[OPLEN];
	uint_t          d86_numopnds;
	uint_t          d86_rex_prefix;         
	char            *d86_seg_prefix;        
	uint_t          d86_opnd_size;
	uint_t          d86_addr_size;
	uint_t          d86_got_modrm;
	uint_t          d86_vsib;               
	struct d86opnd  d86_opnd[4];            
	int             (*d86_check_func)(void *);
	int             (*d86_get_byte)(void *);
	void            *d86_data;
} dis86_t;
struct devsw_lock {
	TAILQ_ENTRY(devsw_lock) dl_list;
	thread_t                dl_thread;
	dev_t                   dl_dev;
	int                     dl_mode;
	int                     dl_waiters;
} *devsw_lock_t;
struct chunklist_hdr {
	uint32_t cl_magic;
	uint32_t cl_header_size;
	uint8_t  cl_file_ver;
	uint8_t  cl_chunk_method;
	uint8_t  cl_sig_method;
	uint8_t  __unused1;
	uint64_t cl_chunk_count;
	uint64_t cl_chunk_offset;
	uint64_t cl_sig_offset;
} __attribute__((packed));
struct chunklist_chunk {
	uint32_t chunk_size;
	uint8_t  chunk_sha256[SHA256_DIGEST_LENGTH];
} __attribute__((packed));
struct chunklist_pubkey {
	const boolean_t is_production;
	const uint8_t key[CHUNKLIST_PUBKEY_LEN];
};
struct kd_coproc {
	char                  full_name[32];
	kdebug_coproc_flags_t flags;
	kd_callback_t         callback;
	uint32_t              cpu_id;
	struct kd_coproc     *next;
	struct mpsc_queue_chain chain;
};
struct kd_resolver {
	kd_threadmap *krs_map;
	vm_size_t krs_count;
	vm_size_t krs_maxcount;
};
struct event_chunk_header {
	uint32_t tag;
	uint32_t sub_tag;
	uint64_t length;
	uint64_t future_events_timestamp;
};
struct aio_workq_entry {
	TAILQ_ENTRY(aio_workq_entry)    aio_workq_link;

	TAILQ_ENTRY(aio_workq_entry)    aio_proc_link;  
	user_ssize_t                    returnval;      
	errno_t                         errorval;       
	os_refcnt_t                     aio_refcount;
	aio_entry_flags_t               flags;

	int                             lio_pending;    
	struct aio_workq_entry         *lio_leader;     

	struct proc                    *procp;          
	user_addr_t                     uaiocbp;        
	struct user_aiocb               aiocb;          
	struct vfs_context              context;        

	vm_map_t                        aio_map;        
};
struct aio_workq   {
	TAILQ_HEAD(, aio_workq_entry)   aioq_entries;
	lck_spin_t                      aioq_lock;
	struct waitq                    aioq_waitq;
} *aio_workq_t;
struct aio_anchor_cb {
	os_atomic(int)          aio_total_count;        

	int                     aio_num_workqs;
	struct aio_workq        aio_async_workqs[AIO_NUM_WORK_QUEUES];
};
struct kauth_listener {
	TAILQ_ENTRY(kauth_listener)     kl_link;
	const char *                            kl_identifier;
	kauth_scope_callback_t          kl_callback;
	void *                                          kl_idata;
};
struct kauth_local_listener {
	kauth_listener_t                        kll_listenerp;
	kauth_scope_callback_t          kll_callback;
	void *                                          kll_idata;
};
struct kauth_scope {
	TAILQ_ENTRY(kauth_scope)        ks_link;
	volatile struct kauth_local_listener  ks_listeners[KAUTH_SCOPE_MAX_LISTENERS];
	const char *                            ks_identifier;
	kauth_scope_callback_t          ks_callback;
	void *                                          ks_idata;
	u_int                                           ks_flags;
};
struct kctl {
	TAILQ_ENTRY(kctl)       next;           
	kern_ctl_ref            kctlref;

	char                    name[MAX_KCTL_NAME];    
	u_int32_t               id;
	u_int32_t               reg_unit;

	u_int32_t               flags;          
	u_int32_t               recvbufsize;    
	u_int32_t               sendbufsize;    

	ctl_setup_func          setup;          
	ctl_bind_func           bind;           
	ctl_connect_func        connect;        
	ctl_disconnect_func     disconnect;     
	ctl_send_func           send;           
	ctl_send_list_func      send_list;      
	ctl_setopt_func         setopt;         
	ctl_getopt_func         getopt;         
	ctl_rcvd_func           rcvd;           

	TAILQ_HEAD(, ctl_cb)    kcb_head;
	u_int32_t               lastunit;
};
struct ctl_cb {
	TAILQ_ENTRY(ctl_cb)     next;           
	lck_mtx_t               mtx;
	struct socket           *so;            
	struct kctl             *kctl;          
	void                    *userdata;
	struct sockaddr_ctl     sac;
	uint32_t                usecount;
	uint32_t                kcb_usecount;
	uint32_t                require_clearing_count;
};
struct ucred_rw {
	os_ref_atomic_t         crw_weak_ref;
	struct ucred           *crw_cred;
	struct smrq_slink       crw_link;
	struct smr_node         crw_node;
};
struct filt_timer_params {
	uint64_t deadline; 
	uint64_t leeway;   
	uint64_t interval; 
};
struct exception_port_action_t {
	ipc_port_t port;
	_ps_port_action_t *port_action;
};
struct exec_port_actions {
	uint32_t exception_port_count;
	uint32_t portwatch_count;
	uint32_t registered_count;
	struct exception_port_action_t *excport_array;
	ipc_port_t *portwatch_array;
	ipc_port_t registered_array[TASK_PORT_REGISTER_MAX];
};
struct execsw {
	int(*const ex_imgact)(struct image_params *);
	const char *ex_name;
}const execsw[] = {
	{ exec_mach_imgact, "Mach-o Binary" },
	{ exec_fat_imgact, "Fat Binary" },
	{ exec_shell_imgact, "Interpreter Script" },
	{ NULL, NULL}
};
struct gfp_crarg {
	guardid_t gca_guard;
	uint16_t  gca_attrs;
};
struct memstat_reaper_stats {
	uint32_t sweep_count;
	uint32_t kill_count;
	uint64_t memory_freed_bytes;
} memstat_reaper_stats_t;
struct memstat_sort_info {
	coalition_t     msi_coal;
	uint64_t        msi_page_count;
	pid_t           msi_pid;
	int             msi_ntasks;
} memstat_sort_info_t;
struct jetsam_state_s {
	bool                            inited; 
	bool                            limit_to_low_bands; 
	int                             index; 
	thread_t                        thread; 
	int                             jld_idle_kills; 
	uint32_t                        errors; 
	bool                            sort_flag; 
	bool                            corpse_list_purged; 
	bool                            post_snapshot; 
	uint64_t                        memory_reclaimed; 
	uint32_t                        hwm_kills; 
	sched_cond_atomic_t             jt_wakeup_cond; 
} *jetsam_state_t;
struct memorystatus_system_health {
	bool msh_compressor_exhausted;
	bool msh_swap_exhausted;
	bool msh_swap_low_on_space;
	bool msh_zone_map_is_exhausted;
} memorystatus_system_health_t;
struct memorystatus_freezer_candidate_list {
	memorystatus_properties_freeze_entry_v1 *mfcl_list;
	size_t mfcl_length;
};
struct memorystatus_freeze_list_iterator {
	bool refreeze_only;
	proc_t last_p;
	size_t global_freeze_list_index;
};
struct {
	uint32_t ephemeral_storage:1;
	uint32_t use_recovery_securityd:1;
} property_existence = {0, 0};
struct sysctl_oid_iterator {
	struct sysctl_oid *a;
	struct sysctl_oid *b;
};
struct uidinfo {
	LIST_ENTRY(uidinfo) ui_hash;
	uid_t   ui_uid;
	size_t    ui_proccnt;
};
struct fixjob_iterargs {
	struct pgrp * pg;
	struct session * mysession;
	int entering;
};
struct pidlist_entry {
	SLIST_ENTRY(pidlist_entry) pe_link;
	u_int pe_nused;
	pid_t pe_pid[PIDS_PER_ENTRY];
} pidlist_entry_t;
struct {
	SLIST_HEAD(, pidlist_entry) pl_head;
	struct pidlist_entry *pl_active;
	u_int pl_nalloc;
} pidlist_t;
struct no_paging_space {
	uint64_t        pcs_max_size;
	uint64_t        pcs_uniqueid;
	int             pcs_pid;
	int             pcs_proc_count;
	uint64_t        pcs_total_size;

	uint64_t        npcs_max_size;
	uint64_t        npcs_uniqueid;
	int             npcs_pid;
	int             npcs_proc_count;
	uint64_t        npcs_total_size;

	int             apcs_proc_count;
	uint64_t        apcs_total_size;
};
struct puser_nice_args {
	proc_t curp;
	int     prio;
	id_t    who;
	int *   foundp;
	int *   errorp;
};
struct ppgrp_nice_args {
	proc_t curp;
	int     prio;
	int *   foundp;
	int *   errorp;
};
struct sd_filterargs {
	int delayterm;
	int shutdownstate;
	int only_non_dext;
};
struct sd_iterargs {
	int signo;              
	int setsdstate;         
	int countproc;          
	int activecount;        
};
struct killpg1_filtargs {
	bool posix;
	proc_t curproc;
};
struct killpg1_iterargs {
	proc_t curproc;
	kauth_cred_t uc;
	int signum;
	int nfound;
};
struct kern_direct_file_io_ref_t {
	vfs_context_t      ctx;
	struct vnode      * vp;
	char              * name;
	size_t              namesize;
	dev_t               device;
	uint32_t            blksize;
	off_t               filelength;
	char                cf;
	char                pinned;
	char                frozen;
	char                wbcranged;
};
struct sysdoproc_args {
	size_t buflen;
	void *kprocp;
	boolean_t is_64_bit;
	user_addr_t dp;
	size_t needed;
	unsigned int sizeof_kproc;
	int *errorp;
	int uidcheck;
	int ruidcheck;
	int ttycheck;
	int uidval;
};
struct socket_filter_entry {
	struct socket_filter_entry      *sfe_next_onsocket;
	struct socket_filter_entry      *sfe_next_onfilter;
	struct socket_filter_entry      *sfe_next_oncleanup;

	struct socket_filter            *sfe_filter;
	struct socket                   *sfe_socket;
	void                            *sfe_cookie;

	uint32_t                        sfe_flags;
	struct os_refcnt                sfe_refcount;
};
struct socket_filter {
	TAILQ_ENTRY(socket_filter)      sf_protosw_next;
	TAILQ_ENTRY(socket_filter)      sf_global_next;
	struct socket_filter_entry      *sf_entry_head;

	struct protosw                  *sf_proto;
	struct sflt_filter              sf_filter;
	struct os_refcnt                sf_refcount;
	uint32_t                        sf_flags;
};
struct solist {
	struct solist *next;
	struct socket *so;
};
struct macho_data {
	struct nameidata        __nid;
	union macho_vnode_header {
		struct mach_header      mach_header;
		struct fat_header       fat_header;
		char    __pad[512];
	} __header;
};
struct _load_result {
	user_addr_t             mach_header;
	user_addr_t             entry_point;

	user_addr_t             user_stack;
	mach_vm_size_t          user_stack_size;

	user_addr_t             user_stack_alloc;
	mach_vm_size_t          user_stack_alloc_size;

	mach_vm_address_t       all_image_info_addr;
	mach_vm_size_t          all_image_info_size;

	int                     thread_count;
	unsigned int
	    unixproc                : 1,
	    needs_dynlinker         : 1,
	    dynlinker               : 1,
	    validentry              : 1,
	    has_pagezero            : 1,
	    using_lcmain            : 1,
	    legacy_footprint        : 1,
	is_64bit_addr           : 1,
	    is_64bit_data           : 1,
	    custom_stack            : 1,
	    is_rosetta              : 1;
	unsigned int            csflags;
	unsigned char           uuid[16];
	mach_vm_address_t       min_vm_addr;
	mach_vm_address_t       max_vm_addr;
	mach_vm_address_t       ro_vm_start;
	mach_vm_address_t       ro_vm_end;
	unsigned int            platform_binary;

	HR_flags_t              hardened_runtime_binary;
	off_t                   cs_end_offset;
	void                    *threadstate;
	size_t                  threadstate_sz;
	uint32_t                ip_platform;
	uint32_t                lr_min_sdk;
	uint32_t                lr_sdk;
	user_addr_t             dynlinker_mach_header;
	user_addr_t             dynlinker_max_vm_addr;
	mach_vm_address_t       dynlinker_ro_vm_start;
	mach_vm_address_t       dynlinker_ro_vm_end;
	int                     dynlinker_fd;
	struct fileproc*        dynlinker_fp;
} load_result_t;
struct netboot_info {
	struct in_addr      client_ip;
	struct in_addr      server_ip;
	char *              server_name;
	size_t              server_name_length;
	char *              mount_point;
	size_t              mount_point_length;
	char *              image_path;
	size_t              image_path_length;
	NetBootImageType    image_type;
	char *              second_image_path;
	size_t              second_image_path_length;
};
struct pseminfo {
	unsigned int    psem_flags;
	unsigned int    psem_usecount;
	mode_t          psem_mode;
	uid_t           psem_uid;
	gid_t           psem_gid;
	char            psem_name[PSEMNAMLEN + 1];      
	semaphore_t     psem_semobject;
	struct label *  psem_label;
	pid_t           psem_creator_pid;
	uint64_t        psem_creator_uniqueid;
};
struct  psemcache {
	LIST_ENTRY(psemcache) psem_hash;        
	struct  pseminfo *pseminfo;             
	size_t  psem_nlen;              
	char    psem_name[PSEMNAMLEN + 1];      
};
struct  psemstats {
	long    goodhits;               
	long    neghits;                
	long    badhits;                
	long    falsehits;              
	long    miss;           
	long    longnames;              
};
struct psemname {
	char    *psem_nameptr;  
	size_t  psem_namelen;   
	u_int32_t       psem_hash;      
};
struct psemnode {
	struct pseminfo *pinfo;
};
struct pshm_mobj {
	void                  *pshmo_memobject;
	memory_object_size_t  pshmo_size;
	SLIST_ENTRY(pshm_mobj) pshmo_next;
} pshm_mobj_t;
struct internal_pshminfo {
	struct pshminfo pshm_hdr;
	SLIST_HEAD(pshm_mobjhead, pshm_mobj) pshm_mobjs;
	RB_ENTRY(internal_pshminfo) pshm_links;        
} pshm_info_t;
struct pshmnode {
	off_t       mapp_addr;
	pshm_info_t *pinfo;
} pshmnode_t;
struct fileport_info_args {
	int             fia_flavor;
	user_addr_t     fia_buffer;
	uint32_t        fia_buffersize;
	int32_t         *fia_retval;
};
struct proc_uuid_policy_entry {
	LIST_ENTRY(proc_uuid_policy_entry) entries;
	uuid_t          uuid;   
	uint32_t        flags;  
};
struct soflow_hash_entry {
	LIST_ENTRY(soflow_hash_entry)       soflow_entry_link;
	TAILQ_ENTRY(soflow_hash_entry)      soflow_entry_list_link;
	os_refcnt_t                         soflow_ref_count;
	struct soflow_db                    *soflow_db;
	uint16_t                            soflow_outifindex;
	in_port_t                           soflow_fport;
	in_port_t                           soflow_lport;
	sa_family_t                         soflow_family;
	uint32_t                            soflow_flowhash;
	uint64_t                            soflow_lastused;
	uint32_t                            soflow_faddr6_ifscope;
	uint32_t                            soflow_laddr6_ifscope;
	union {
		
		struct in_addr_4in6             addr46;
		struct in6_addr                 addr6;
	} soflow_faddr;
	union {
		
		struct in_addr_4in6             addr46;
		struct in6_addr                 addr6;
	} soflow_laddr;
	uint8_t                             soflow_outgoing: 1;
	uint8_t                             soflow_laddr_updated: 1;
	uint8_t                             soflow_lport_updated: 1;
	uint8_t                             soflow_gc: 1;
	uint8_t                             soflow_feat_gc: 1;
	uint8_t                             soflow_debug: 1;
	uint8_t                             soflow_reserved:2;

	uint64_t                            soflow_rxpackets;
	uint64_t                            soflow_rxbytes;
	uint64_t                            soflow_txpackets;
	uint64_t                            soflow_txbytes;

	uint64_t                            soflow_feat_ctxt_id;
	void                                *soflow_feat_ctxt;
	uint32_t                            soflow_filter_control_unit;
	int32_t                             soflow_policies_gencount;

	struct timeval                      soflow_timestamp;
};
struct soflow_db {
	os_refcnt_t                         soflow_db_ref_count;
	struct socket                       *soflow_db_so;
	uint32_t                            soflow_db_count;
	struct soflow_hash_head             * __counted_by(SOFLOW_HASH_SIZE) soflow_db_hashbase;
	u_long                              soflow_db_hashmask;
	struct soflow_hash_entry            *soflow_db_only_entry;

	uint8_t                             soflow_db_debug:1;
	uint8_t                             soflow_db_reserved:7;
	uint64_t                            soflow_db_flags;
};
struct stackshot_entitlement_report {
	uint64_t ser_lastev;
	uint32_t ser_count;
	command_t ser_pcomm;
	proc_name_t ser_pname;
	bool ser_have_entitlement;
	char ser_progress; 
};
struct eventhandler_entry_generic {
	struct eventhandler_entry       ee;
	void                           *func;
};
struct logsoftc {
	int     sc_state;               
	struct  selinfo sc_selp;        
	int     sc_pgid;                
	struct msgbuf *sc_mbp;
} logsoftc;
struct oslogsoftc {
	int     sc_state;               
	struct  selinfo sc_selp;        
	int     sc_pgid;                
} oslogsoftc;
struct {
	lck_spin_t          lsi_lock;
	log_stream_siopts_t lsi_opts;
	struct selinfo      lsi_selinfo;
	void                *lsi_channel;
} log_stream_si_t;
struct {
	uint64_t                        lsm_ts;
	struct firehose_tracepoint_s    lsm_ft;
} __attribute__((packed)) log_stream_msg_t;
struct {
	bool                ls_enabled;
	bool                ls_snapshot;
	uint8_t             *ls_buf;
	uint8_t             *ls_blk;
	size_t              ls_blk_count;
	_Atomic(size_t)     ls_reserved;
	ls_atomic(size_t)   ls_commited;
	size_t              ls_commited_wraps;
} log_stream_t;
struct {
	log_stream_ticket_t lss_ticket;
	log_stream_t        *lss_stream;
	log_stream_t        lss_snapshot;
} log_stream_session_t;
struct {
	uint8_t         *lc_buf;
	uint8_t         *lc_blk;
	size_t          lc_blk_count;
	size_t          lc_blk_pos;
	log_stream_t    *lc_stream;
	size_t          lc_stream_pos;
} log_cache_t;
struct snprintf_arg {
	char *str;
	size_t remain;
};
struct putchar_args {
	int flags;
	struct tty *tty;
	bool last_char_was_cr;
};
struct pipepair {
	lck_mtx_t     pp_mtx;
	struct pipe   pp_rpipe;
	struct pipe   pp_wpipe;
	uint64_t      pp_pipe_id;       
};
struct {
	union {
		struct __attribute__((packed)) {
			user_addr_t     ulk_addr;
			
			task_t          ulk_task __kernel_data_semantics;
		};
		struct __attribute__((packed)) {
			uint64_t        ulk_object;
			uint64_t        ulk_offset;
		};
	};
	ulk_type        ulk_key_type;
} ulk_t;
struct ull {
	thread_t        ull_owner; 
	ulk_t           ull_key;
	ull_lock_t      ull_lock;
	uint            ull_bucket_index;
	int32_t         ull_nwaiters;
	int32_t         ull_refcount;
	uint8_t         ull_opcode;
	struct turnstile *ull_turnstile;
	queue_chain_t   ull_hash_link;
} ull_t;
struct ull_bucket {
	queue_head_t ulb_head;
} ull_bucket_t;
struct tracker_hash_entry {
	TRACKER_HASH_ENTRY_HEADER_FIELDS
	tracker_metadata_t                  metadata;
} tracker_hash_entry_t;
struct tracker_hash_entry_short {
	TRACKER_HASH_ENTRY_HEADER_FIELDS
	tracker_metadata_short_t            metadata;
} tracker_hash_entry_short_t;
struct tracker_db {
	struct trackerhashhead              * __indexable tracker_hashbase;
	u_long                              tracker_hashmask;
	uint32_t                            tracker_count;
	uint32_t                            tracker_count_short;
	uint32_t                            max_link_count;
};
struct ptmx_ioctl {
	struct tty      *pt_tty;        
	int             pt_flags;
	struct selinfo  pt_selr;
	struct selinfo  pt_selw;
	u_char          pt_send;
	u_char          pt_ucntl;
	void            *pt_devhandle;  
};
struct tty_dev_t {
	int primary;     
	int replica;     
	unsigned int    fix_7828447:1,
	    fix_7070978:1,
	    mac_notify:1,
	    open_reset:1,
	    _reserved:28;
	int _pad;

	struct tty_dev_t *next;

	struct ptmx_ioctl *(*open)(int minor, int flags);
	int (*free)(int minor, int flags);
	int (*name)(int minor, char *buffer, size_t size);
	void (*revoke)(int minor, struct tty *tp);
};
struct _ptmx_ioctl_state {
	struct ptmx_ioctl       **pis_ioctl_list;       
	int                     pis_total;              
	int                     pis_free;               
} _state;
struct cs_hash {
	uint8_t             cs_type;    
	size_t              cs_size;    
	size_t              cs_digest_size;
	cs_md_init          cs_init;
	cs_md_update        cs_update;
	cs_md_final         cs_final;
};
struct mcl_slab {
	struct mcl_slab *sl_next;       
	u_int8_t        sl_class;       
	int8_t          sl_refcnt;      
	int8_t          sl_chunks;      
	u_int16_t       sl_flags;       
	u_int16_t       sl_len;         
	void            *sl_base;       
	void            *sl_head;       
	TAILQ_ENTRY(mcl_slab) sl_link;  
} mcl_slab_t;
struct mcl_slabg {
	mcl_slab_t      *slg_slab;      
} mcl_slabg_t;
struct {
	mbuf_class_t    mtbl_class;     
	mb_class_stat_t *mtbl_stats;    
	u_int32_t       mtbl_maxsize;   
	int             mtbl_minlimit;  
	int             mtbl_maxlimit;  
	u_int32_t       mtbl_wantpurge; 
	uint32_t        mtbl_avgtotal;  
	u_int32_t       mtbl_expand;    
} mbuf_table_t;
struct {
	unsigned int cpu_mtypes[MT_MAX];
} mbuf_mtypes_t;
struct ncl_tbl {
	uint64_t nt_maxmem;     
	uint32_t nt_mbpool;     
} ncl_tbl_t;
struct mbuf_watchdog_defunct_args {
	struct proc *top_app;
	uint32_t top_app_space_used;
	bool non_blocking;
};
struct m_tag_type_entry {
	m_tag_kalloc_func_t mt_alloc_func;
	m_tag_kfree_func_t mt_free_func;
	uint16_t mt_type;
	uint16_t mt_len;
};
struct m_tag_type_stats {
	uint64_t mt_alloc_count;
	uint64_t mt_alloc_failed;
	uint64_t mt_free_count;
};
struct mdns_ipc_msg_hdr {
	uint32_t version;
	uint32_t datalen;
	uint32_t ipc_flags;
	uint32_t op;
	union {
		void *context;
		uint32_t u32[2];
	} __attribute__((packed));
	uint32_t reg_index;
} __attribute__((packed));
struct consdev {
	char    *cn_name;       
	int     (*cn_probe)(void);      
	int     (*cn_init)(void);       
	int     (*cn_getc)(void);       
	int     (*cn_putc)(void);       
	struct  tty *cn_tp;     
	dev_t   cn_dev;         
	short   cn_pri;         
};
struct exec_info {
	char    path[MAXPATHLEN];
	int     ac;
	int     ec;
	char    **av;
	char    **ev;
};
struct net_bloom_filter {
	uint32_t b_table_num_bits;
	uint32_t b_table[__counted_by(net_bloom_howmany(b_table_num_bits, kNetBloomFilterBitsPerTableElement))];
};
struct bpf_d {
	struct bpf_d    *bd_next;       
	caddr_t BPF_BIDI_INDEXABLE bd_sbuf; 
	caddr_t BPF_BIDI_INDEXABLE bd_hbuf; 
	caddr_t BPF_BIDI_INDEXABLE bd_fbuf; 
	uint32_t        bd_slen;        
	uint32_t        bd_hlen;        
	uint32_t        bd_scnt;        
	uint32_t        bd_hcnt;        

	uint32_t        bd_bufsize;     
	bool            bd_hbuf_read;   
	bool            bd_hbuf_write;  
	bool            bd_headdrop;    

	uint32_t        bd_write_size_max;      

	uint32_t        bd_rtout;       
	struct bpf_if   *bd_bif;        
	struct bpf_insn *__counted_by(bd_filter_len) bd_filter; 
	uint32_t        bd_filter_len;  
	uint64_t        bd_rcount;      
	uint64_t        bd_dcount;      
	uint64_t        bd_fcount;      

	uint64_t        bd_wcount;      
	uint64_t        bd_wdcount;     

	uint8_t         bd_promisc;     
	uint8_t         bd_state;       
	uint8_t         bd_immediate;   
	uint32_t        bd_dev_minor;   
	int             bd_async;       
	int             bd_sig;         
	pid_t           bd_sigio;

	struct selinfo  bd_sel;         

	int             bd_hdrcmplt;    
	u_int           bd_direction;   
	int             bd_oflags;      
	thread_call_t   bd_thread_call; 
	int             bd_traffic_class; 
	int             bd_flags;       
	int             bd_tstamp;      

	int             bd_refcnt;
	void            *bd_ref_lr[BPF_REF_HIST];
	void            *bd_unref_lr[BPF_REF_HIST];
	int             bd_next_ref_lr;
	int             bd_next_unref_lr;

	struct proc     *bd_opened_by;
	uuid_t          bd_uuid;
	pid_t           bd_pid;

	uint8_t         bd_prev_slen;
	caddr_t BPF_BIDI_INDEXABLE bd_prev_sbuf;
	caddr_t BPF_BIDI_INDEXABLE bd_prev_fbuf;

	struct bpf_comp_stats bd_bcs;
};
struct bpf_if {
	struct bpf_if *bif_next;        
	struct bpf_d *bif_dlist;        
	uint32_t bif_dlt;                  
	uint32_t bif_hdrlen;               
	uint32_t bif_exthdrlen;            
	uint32_t bif_comphdrlen;        
	struct ifnet *bif_ifp;          
	bpf_send_func   bif_send;
	bpf_tap_func    bif_tap;
};
struct bstp_cb_ops {
	bstp_state_cb_t bcb_state;
	bstp_rtage_cb_t bcb_rtage;
};
struct bstp_cbpdu {
	uint8_t         cbu_dsap;               
	uint8_t         cbu_ssap;               
	uint8_t         cbu_ctl;                
	uint16_t        cbu_protoid;            
	uint8_t         cbu_protover;           
	uint8_t         cbu_bpdutype;           
	uint8_t         cbu_flags;              

	uint16_t        cbu_rootpri;            
	uint8_t         cbu_rootaddr[6];        

	uint32_t        cbu_rootpathcost;       

	uint16_t        cbu_bridgepri;          
	uint8_t         cbu_bridgeaddr[6];      

	uint16_t        cbu_portid;             
	uint16_t        cbu_messageage;         
	uint16_t        cbu_maxage;             
	uint16_t        cbu_hellotime;          
	uint16_t        cbu_forwarddelay;       
	uint8_t         cbu_versionlen;         
} __attribute__((__packed__));
struct bstp_tbpdu {
	uint8_t         tbu_dsap;               
	uint8_t         tbu_ssap;               
	uint8_t         tbu_ctl;                
	uint16_t        tbu_protoid;            
	uint8_t         tbu_protover;           
	uint8_t         tbu_bpdutype;           
} __attribute__((__packed__));
struct bstp_task {
	TAILQ_ENTRY(bstp_task)  bt_next;
	int                                             bt_count;
	bstp_task_func_t                *bt_func;
	void                                    *bt_context;
};
struct bstp_timer {
	int             active;
	int             latched;
	int             value;
};
struct bstp_pri_vector {
	uint64_t                pv_root_id;
	uint32_t                pv_cost;
	uint64_t                pv_dbridge_id;
	uint16_t                pv_dport_id;
	uint16_t                pv_port_id;
};
struct bstp_config_unit {
	struct bstp_pri_vector  cu_pv;
	uint16_t        cu_message_age;
	uint16_t        cu_max_age;
	uint16_t        cu_forward_delay;
	uint16_t        cu_hello_time;
	uint8_t         cu_message_type;
	uint8_t         cu_topology_change_ack;
	uint8_t         cu_topology_change;
	uint8_t         cu_proposal;
	uint8_t         cu_agree;
	uint8_t         cu_learning;
	uint8_t         cu_forwarding;
	uint8_t         cu_role;
};
struct bstp_tcn_unit {
	uint8_t         tu_message_type;
};
struct bstp_port {
	LIST_ENTRY(bstp_port)   bp_next;
	struct ifnet            *bp_ifp;        
	struct bstp_state       *bp_bs;
	uint8_t                 bp_active;
	uint8_t                 bp_protover;
	uint32_t                bp_flags;
	uint32_t                bp_path_cost;
	uint16_t                bp_port_msg_age;
	uint16_t                bp_port_max_age;
	uint16_t                bp_port_fdelay;
	uint16_t                bp_port_htime;
	uint16_t                bp_desg_msg_age;
	uint16_t                bp_desg_max_age;
	uint16_t                bp_desg_fdelay;
	uint16_t                bp_desg_htime;
	struct bstp_timer       bp_edge_delay_timer;
	struct bstp_timer       bp_forward_delay_timer;
	struct bstp_timer       bp_hello_timer;
	struct bstp_timer       bp_message_age_timer;
	struct bstp_timer       bp_migrate_delay_timer;
	struct bstp_timer       bp_recent_backup_timer;
	struct bstp_timer       bp_recent_root_timer;
	struct bstp_timer       bp_tc_timer;
	struct bstp_config_unit bp_msg_cu;
	struct bstp_pri_vector  bp_desg_pv;
	struct bstp_pri_vector  bp_port_pv;
	uint16_t                bp_port_id;
	uint8_t                 bp_state;
	uint8_t                 bp_tcstate;
	uint8_t                 bp_role;
	uint8_t                 bp_infois;
	uint8_t                 bp_tc_ack;
	uint8_t                 bp_tc_prop;
	uint8_t                 bp_fdbflush;
	uint8_t                 bp_priority;
	uint8_t                 bp_ptp_link;
	uint8_t                 bp_agree;
	uint8_t                 bp_agreed;
	uint8_t                 bp_sync;
	uint8_t                 bp_synced;
	uint8_t                 bp_proposing;
	uint8_t                 bp_proposed;
	uint8_t                 bp_operedge;
	uint8_t                 bp_reroot;
	uint8_t                 bp_rcvdtc;
	uint8_t                 bp_rcvdtca;
	uint8_t                 bp_rcvdtcn;
	uint32_t                bp_forward_transitions;
	uint8_t                 bp_txcount;
	struct bstp_task        bp_statetask;
	struct bstp_task        bp_rtagetask;
	uint32_t                bp_if_link_state;       
};
struct bstp_state {
	LIST_ENTRY(bstp_state)  bs_list;
	uint8_t                 bs_running;
	lck_mtx_t               bs_mtx;
	struct bstp_pri_vector  bs_bridge_pv;
	struct bstp_pri_vector  bs_root_pv;
	struct bstp_port        *bs_root_port;
	uint8_t                 bs_protover;
	uint16_t                bs_migration_delay;
	uint16_t                bs_edge_delay;
	uint16_t                bs_bridge_max_age;
	uint16_t                bs_bridge_fdelay;
	uint16_t                bs_bridge_htime;
	uint16_t                bs_root_msg_age;
	uint16_t                bs_root_max_age;
	uint16_t                bs_root_fdelay;
	uint16_t                bs_root_htime;
	uint16_t                bs_hold_time;
	uint16_t                bs_bridge_priority;
	uint8_t                 bs_txholdcount;
	uint8_t                 bs_allsynced;
	struct bstp_timer       bs_link_timer;
	struct timeval          bs_last_tc_time;
	LIST_HEAD(, bstp_port)  bs_bplist;
	bstp_state_cb_t         bs_state_cb;
	bstp_rtage_cb_t         bs_rtage_cb;
};
struct content_filter {
	kern_ctl_ref            cf_kcref;
	u_int32_t               cf_kcunit;
	u_int32_t               cf_flags;

	uint32_t                cf_necp_control_unit;

	uint32_t                cf_sock_count;
	TAILQ_HEAD(, cfil_entry) cf_sock_entries;

	cfil_crypto_state_t cf_crypto_state;
};
struct cfil_queue {
	uint64_t                q_start; 
	uint64_t                q_end; 
	struct cfil_mqhead      q_mq;
};
struct cfil_entry {
	TAILQ_ENTRY(cfil_entry) cfe_link;
	SLIST_ENTRY(cfil_entry) cfe_order_link;
	struct content_filter   *cfe_filter;

	struct cfil_info        *cfe_cfil_info;
	uint32_t                cfe_flags;
	uint32_t                cfe_necp_control_unit;
	struct timeval          cfe_last_event; 
	struct timeval          cfe_last_action; 
	uint64_t                cfe_byte_inbound_count_reported; 
	uint64_t                cfe_byte_outbound_count_reported; 
	struct timeval          cfe_stats_report_ts; 
	uint32_t                cfe_stats_report_frequency; 
	boolean_t               cfe_laddr_sent;

	struct cfe_buf {
		
		struct cfil_queue       cfe_pending_q;
		
		struct cfil_queue       cfe_ctl_q;

		uint64_t                cfe_pass_offset;
		uint64_t                cfe_peek_offset;
		uint64_t                cfe_peeked;
	} cfe_snd, cfe_rcv;
};
struct cfil_info {
	TAILQ_ENTRY(cfil_info)  cfi_link;
	TAILQ_ENTRY(cfil_info)  cfi_link_stats;
	struct socket           *cfi_so;
	uint64_t                cfi_flags;
	uint64_t                cfi_sock_id;
	struct timeval64        cfi_first_event;
	uint32_t                cfi_op_list_ctr;
	uint32_t                cfi_op_time[CFI_MAX_TIME_LOG_ENTRY];    
	unsigned char           cfi_op_list[CFI_MAX_TIME_LOG_ENTRY];
	union sockaddr_in_4_6   cfi_so_attach_faddr;                    
	union sockaddr_in_4_6   cfi_so_attach_laddr;                    

	int                     cfi_dir;
	uint64_t                cfi_byte_inbound_count;
	uint64_t                cfi_byte_outbound_count;
	struct timeval          cfi_timestamp;

	boolean_t               cfi_isSignatureLatest;                  
	u_int32_t               cfi_filter_control_unit;
	u_int32_t               cfi_filter_policy_gencount;
	u_int32_t               cfi_debug;
	struct cfi_buf {
		
		uint64_t                cfi_pending_first;
		uint64_t                cfi_pending_last;
		uint32_t                cfi_pending_mbcnt;
		uint32_t                cfi_pending_mbnum;
		uint32_t                cfi_tail_drop_cnt;
		
		uint64_t                cfi_pass_offset;
		
		struct cfil_queue       cfi_inject_q;
	} cfi_snd, cfi_rcv;

	struct cfil_entry       cfi_entries[MAX_CONTENT_FILTER];
	struct soflow_hash_entry *cfi_hash_entry;
	SLIST_HEAD(, cfil_entry) cfi_ordered_entries;
	os_refcnt_t             cfi_ref_count;
} __attribute__((aligned(8)));
struct cfil_stats_report_buffer {
	struct cfil_msg_hdr        msghdr;
	uint32_t                   count;
	struct cfil_msg_sock_stats stats[CFIL_STATS_REPORT_MAX_COUNT];
};
struct cfil_tag {
	union sockaddr_in_4_6 cfil_faddr;
	uint32_t cfil_so_state_change_cnt;
	uint32_t cfil_so_options;
	int cfil_inp_flags;
};
struct cflil_tag_container {
	struct m_tag    cfil_m_tag;
	struct cfil_tag cfil_tag;
};
struct cfil_sign_parameters {
	cfil_crypto_state_t csp_state;
	struct cfil_crypto_data *csp_data;
	uint8_t * __indexable csp_signature;
	uint32_t *csp_signature_size;
};
struct cfil_udp_attached_context {
	bool need_wait;
	lck_mtx_t *mutex_held;
	int attached;
};
struct cfil_udp_data_pending_context {
	struct sockbuf *sb;
	uint64_t total_pending;
};
struct cfil_udp_notify_shutdown_context {
	int how;
	int drop_flag;
	int shut_flag;
	int done_count;
};
struct cfil_opt_sock_info {
	cfil_sock_id_t  cfs_sock_id;
	int                             cfs_sock_family;        
	int                             cfs_sock_type;          
	int                             cfs_sock_protocol;      
	union sockaddr_in_4_6   cfs_local;
	union sockaddr_in_4_6   cfs_remote;
	pid_t                   cfs_pid;
	pid_t                   cfs_e_pid;
	pid_t                   cfs_r_pid;
	uuid_t                  cfs_uuid;
	uuid_t                  cfs_e_uuid;
	uuid_t                  cfs_r_uuid;
};
struct cfil_crypto_state {
	const struct ccdigest_info *digest_info;
	cfil_crypto_key key;
} *cfil_crypto_state_t;
struct cfil_crypto_data {
	uuid_t flow_id;
	u_int64_t sock_id;
	u_int32_t direction;
	union sockaddr_in_4_6 remote;
	union sockaddr_in_4_6 local;
	u_int32_t socketProtocol;
	pid_t pid;
	pid_t effective_pid;
	pid_t responsible_pid;
	uuid_t uuid;
	uuid_t effective_uuid;
	uuid_t responsible_uuid;
	u_int64_t byte_count_in;
	u_int64_t byte_count_out;
} *cfil_crypto_data_t;
struct cfil_msg_hdr {
	uint32_t        cfm_len;        
	uint32_t        cfm_version;
	uint32_t        cfm_type;
	uint32_t        cfm_op;
	cfil_sock_id_t  cfm_sock_id;
};
struct cfil_msg_sock_attached {
	struct cfil_msg_hdr     cfs_msghdr;
	int                     cfs_sock_family;        
	int                     cfs_sock_type;          
	int                     cfs_sock_protocol;      
	int                     cfs_unused;             
	pid_t                   cfs_pid;
	pid_t                   cfs_e_pid;
	pid_t                   cfs_r_pid;
	uuid_t                  cfs_uuid;
	uuid_t                  cfs_e_uuid;
	uuid_t                  cfs_r_uuid;
	union sockaddr_in_4_6   cfs_src;
	union sockaddr_in_4_6   cfs_dst;
	int                     cfs_conn_dir;
	unsigned int            cfs_audit_token[8];             
	unsigned int            cfs_real_audit_token[8];        
	cfil_crypto_signature   cfs_signature;
	uint32_t                cfs_signature_length;
	char                    cfs_remote_domain_name[CFS_MAX_DOMAIN_NAME_LENGTH];
};
struct cfil_msg_data_event {
	struct cfil_msg_hdr     cfd_msghdr;
	union sockaddr_in_4_6   cfc_src;
	union sockaddr_in_4_6   cfc_dst;
	uint64_t                cfd_start_offset;
	uint64_t                cfd_end_offset;
	cfil_crypto_signature   cfd_signature;
	uint32_t                cfd_signature_length;
	uint32_t                cfd_flags;
	pid_t                   cfd_delegated_pid;
	unsigned int            cfd_delegated_audit_token[8];
};
struct cfil_msg_sock_closed {
	struct cfil_msg_hdr     cfc_msghdr;
	struct timeval64        cfc_first_event;
	uint32_t                cfc_op_list_ctr;
	uint32_t                cfc_op_time[CFI_MAX_TIME_LOG_ENTRY];    
	unsigned char           cfc_op_list[CFI_MAX_TIME_LOG_ENTRY];
	uint64_t                cfc_byte_inbound_count;
	uint64_t                cfc_byte_outbound_count;
	union sockaddr_in_4_6   cfc_laddr;
	cfil_crypto_signature   cfc_signature;
	uint32_t                cfc_signature_length;
} __attribute__((aligned(8)));
struct cfil_msg_sock_stats {
	cfil_sock_id_t          cfs_sock_id;
	uint64_t                cfs_byte_inbound_count;
	uint64_t                cfs_byte_outbound_count;
	union sockaddr_in_4_6   cfs_laddr;
} __attribute__((aligned(8)));
struct cfil_msg_stats_report {
	struct cfil_msg_hdr        cfr_msghdr;
	uint32_t                   cfr_count;
	struct cfil_msg_sock_stats cfr_stats[];
} __attribute__((aligned(8)));
struct cfil_msg_action {
	struct cfil_msg_hdr     cfa_msghdr;
	uint64_t                cfa_in_pass_offset;
	uint64_t                cfa_in_peek_offset;
	uint64_t                cfa_out_pass_offset;
	uint64_t                cfa_out_peek_offset;
	uint32_t                cfa_stats_frequency; 
};
struct cfil_msg_bless_client {
	struct cfil_msg_hdr     cfb_msghdr;
	uuid_t cfb_client_uuid;
};
struct cfil_msg_set_crypto_key {
	struct cfil_msg_hdr     cfb_msghdr;
	cfil_crypto_key         crypto_key;
};
struct cfil_filter_stat {
	uint32_t        cfs_len;
	uint32_t        cfs_filter_id;
	uint32_t        cfs_flags;
	uint32_t        cfs_sock_count;
	uint32_t        cfs_necp_control_unit;
};
struct cfil_entry_stat {
	uint32_t                ces_len;
	uint32_t                ces_filter_id;
	uint32_t                ces_flags;
	uint32_t                ces_necp_control_unit;
	struct timeval64        ces_last_event;
	struct timeval64        ces_last_action;
	struct cfe_buf_stat {
		uint64_t        cbs_pending_first;
		uint64_t        cbs_pending_last;
		uint64_t        cbs_ctl_first;
		uint64_t        cbs_ctl_last;
		uint64_t        cbs_pass_offset;
		uint64_t        cbs_peek_offset;
		uint64_t        cbs_peeked;
	} ces_snd, ces_rcv;
};
struct cfil_sock_stat {
	uint32_t        cfs_len;
	int             cfs_sock_family;
	int             cfs_sock_type;
	int             cfs_sock_protocol;
	cfil_sock_id_t  cfs_sock_id;
	uint64_t        cfs_flags;
	pid_t           cfs_pid;
	pid_t           cfs_e_pid;
	uuid_t          cfs_uuid;
	uuid_t          cfs_e_uuid;
	struct cfi_buf_stat {
		uint64_t        cbs_pending_first;
		uint64_t        cbs_pending_last;
		uint64_t        cbs_pass_offset;
		uint64_t        cbs_inject_q_len;
	} cfs_snd, cfs_rcv;
	struct cfil_entry_stat  ces_entries[CFIL_MAX_FILTER_COUNT];
};
struct cfil_stats {
	int32_t cfs_ctl_connect_ok;
	int32_t cfs_ctl_connect_fail;
	int32_t cfs_ctl_disconnect_ok;
	int32_t cfs_ctl_disconnect_fail;
	int32_t cfs_ctl_send_ok;
	int32_t cfs_ctl_send_bad;
	int32_t cfs_ctl_rcvd_ok;
	int32_t cfs_ctl_rcvd_bad;
	int32_t cfs_ctl_rcvd_flow_lift;
	int32_t cfs_ctl_action_data_update;
	int32_t cfs_ctl_action_drop;
	int32_t cfs_ctl_action_bad_op;
	int32_t cfs_ctl_action_bad_len;

	int32_t cfs_sock_id_not_found;

	int32_t cfs_cfi_alloc_ok;
	int32_t cfs_cfi_alloc_fail;

	int32_t cfs_sock_userspace_only;
	int32_t cfs_sock_attach_in_vain;
	int32_t cfs_sock_attach_already;
	int32_t cfs_sock_attach_no_mem;
	int32_t cfs_sock_attach_failed;
	int32_t cfs_sock_attached;
	int32_t cfs_sock_detached;

	int32_t cfs_attach_event_ok;
	int32_t cfs_attach_event_flow_control;
	int32_t cfs_attach_event_fail;

	int32_t cfs_closed_event_ok;
	int32_t cfs_closed_event_flow_control;
	int32_t cfs_closed_event_fail;

	int32_t cfs_data_event_ok;
	int32_t cfs_data_event_flow_control;
	int32_t cfs_data_event_fail;

	int32_t cfs_stats_event_ok;
	int32_t cfs_stats_event_flow_control;
	int32_t cfs_stats_event_fail;

	int32_t cfs_disconnect_in_event_ok;
	int32_t cfs_disconnect_out_event_ok;
	int32_t cfs_disconnect_event_flow_control;
	int32_t cfs_disconnect_event_fail;

	int32_t cfs_ctl_q_not_started;

	int32_t cfs_close_wait;
	int32_t cfs_close_wait_timeout;

	int32_t cfs_flush_in_drop;
	int32_t cfs_flush_out_drop;
	int32_t cfs_flush_in_close;
	int32_t cfs_flush_out_close;
	int32_t cfs_flush_in_free;
	int32_t cfs_flush_out_free;

	int32_t cfs_inject_q_nomem;
	int32_t cfs_inject_q_nobufs;
	int32_t cfs_inject_q_detached;
	int32_t cfs_inject_q_in_fail;
	int32_t cfs_inject_q_out_fail;

	int32_t cfs_inject_q_in_retry;
	int32_t cfs_inject_q_out_retry;

	int32_t cfs_data_in_control;
	int32_t cfs_data_in_oob;
	int32_t cfs_data_out_control;
	int32_t cfs_data_out_oob;

	int64_t cfs_ctl_q_in_enqueued __attribute__((aligned(8)));
	int64_t cfs_ctl_q_out_enqueued __attribute__((aligned(8)));
	int64_t cfs_ctl_q_in_peeked __attribute__((aligned(8)));
	int64_t cfs_ctl_q_out_peeked __attribute__((aligned(8)));

	int64_t cfs_pending_q_in_enqueued __attribute__((aligned(8)));
	int64_t cfs_pending_q_out_enqueued __attribute__((aligned(8)));

	int64_t cfs_inject_q_in_enqueued __attribute__((aligned(8)));
	int64_t cfs_inject_q_out_enqueued __attribute__((aligned(8)));
	int64_t cfs_inject_q_in_passed __attribute__((aligned(8)));
	int64_t cfs_inject_q_out_passed __attribute__((aligned(8)));
};
struct devtimer_s {
	void *                      dt_callout;
	devtimer_timeout_func       dt_timeout_func;
	devtimer_process_func       dt_process_func;
	void *                      dt_arg0;
	void *                      dt_arg1;
	void *                      dt_arg2;
	int                         dt_generation;
	struct os_refcnt            dt_retain_count;
};
struct ifnet_flowhash_key {
	char            ifk_name[IFNAMSIZ];
	uint32_t        ifk_unit;
	uint32_t        ifk_flags;
	uint32_t        ifk_eflags;
	uint32_t        ifk_capabilities;
	uint32_t        ifk_capenable;
	uint32_t        ifk_output_sched_model;
	uint32_t        ifk_rand1;
	uint32_t        ifk_rand2;
};
struct ifnet_fc_entry {
	RB_ENTRY(ifnet_fc_entry) ifce_entry;
	u_int32_t       ifce_flowhash;
	ifnet_ref_t     ifce_ifp;
};
struct rxpoll_time_tbl {
	u_int64_t       speed;          
	u_int32_t       plowat;         
	u_int32_t       phiwat;         
	u_int32_t       blowat;         
	u_int32_t       bhiwat;         
};
struct ifnet_ioctl_event {
	ifnet_ref_t ifp;
	u_long ioctl_code;
};
struct ifnet_ioctl_event_nwk_wq_entry {
	struct nwk_wq_entry nwk_wqe;
	struct ifnet_ioctl_event ifnet_ioctl_ev_arg;
};
struct dlil_threading_info {
	decl_lck_mtx_data(, dlth_lock);
	class_queue_t   dlth_pkts;      
	struct ifnet    *dlth_ifp;      
	struct ifnet_stat_increment_param dlth_stats; 
	uint32_t       dlth_flags;      
	uint32_t       dlth_wtot;       

	errno_t (*dlth_strategy)(struct dlil_threading_info *,
	    struct ifnet *, struct mbuf *, struct mbuf *,
	    const struct ifnet_stat_increment_param *, boolean_t,
	    struct thread *);

	boolean_t       dlth_affinity;          
	uint32_t        dlth_affinity_tag;      
	struct thread   *dlth_thread;           
	struct thread   *dlth_driver_thread;    
	struct thread   *dlth_poller_thread;    

	lck_grp_t       *dlth_lock_grp; 
	char            dlth_name_storage[DLIL_THREADNAME_LEN]; 
	const char * __null_terminated dlth_name;
	uint32_t        dlth_trim_cnt;          
	uint32_t        dlth_trim_pkts_dropped; 
};
struct dlil_main_threading_info {
	struct dlil_threading_info      inp;
	class_queue_t                   lo_rcvq_pkts; 
};
struct dl_if_lladdr_std {
	struct ifaddr   ifa;
	u_int8_t        addr_sdl_bytes[DLIL_SDLMAXLEN];
	u_int8_t        mask_sdl_bytes[DLIL_SDLMAXLEN];
};
struct dl_if_lladdr_xtra_space {
	struct ifaddr   ifa;
	u_int8_t        addr_sdl_bytes[SOCK_MAXADDRLEN];
	u_int8_t        mask_sdl_bytes[SOCK_MAXADDRLEN];
};
struct dlil_ifnet {
	struct ifnet    dl_if;                  
	decl_lck_mtx_data(, dl_if_lock);
	TAILQ_ENTRY(dlil_ifnet) dl_if_link;     
	u_int32_t dl_if_flags;                  
	u_int32_t dl_if_refcnt;                 
	void (*dl_if_trace)(struct dlil_ifnet *, int); 
	void    *dl_if_uniqueid __sized_by_or_null(dl_if_uniqueid_len);                
	size_t  dl_if_uniqueid_len;             
	char    dl_if_namestorage[IFNAMSIZ];    
	char    dl_if_xnamestorage[IFXNAMSIZ];  
	struct dl_if_lladdr_std dl_if_lladdr;   
	u_int8_t dl_if_descstorage[IF_DESCSIZE]; 
	u_int8_t dl_if_permanent_ether[ETHER_ADDR_LEN]; 
	u_int8_t dl_if_permanent_ether_is_set;
	u_int8_t dl_if_unused;
	struct dlil_threading_info dl_if_inpstorage; 
	ctrace_t        dl_if_attach;           
	ctrace_t        dl_if_detach;           
};
struct dlil_ifnet_dbg {
	struct dlil_ifnet       dldbg_dlif;             
	u_int16_t               dldbg_if_refhold_cnt;   
	u_int16_t               dldbg_if_refrele_cnt;   
	ctrace_t                dldbg_if_refhold[IF_REF_TRACE_HIST_SIZE];
	ctrace_t                dldbg_if_refrele[IF_REF_TRACE_HIST_SIZE];
};
struct ifnet_filter {
	TAILQ_ENTRY(ifnet_filter)       filt_next;
	u_int32_t                       filt_skip;
	u_int32_t                       filt_flags;
	ifnet_t                         filt_ifp;
	const char                      *filt_name;
	void                            *filt_cookie;
	protocol_family_t               filt_protocol;
	iff_input_func                  filt_input;
	iff_output_func                 filt_output;
	iff_event_func                  filt_event;
	iff_ioctl_func                  filt_ioctl;
	iff_detached_func               filt_detached;
};
struct droptap_softc {
	LIST_ENTRY(droptap_softc)         dtap_link;
	uint32_t                          dtap_unit;
	uint32_t                          dtap_dlt_pktap_count;
	struct ifnet                      *dtap_ifp;
};
struct droptap_header {
	struct pktap_header     dth_pktap_hdr;
	uint32_t                dth_dropreason;
	uint8_t                 dth_dropfunc_size;
	uint16_t                dth_dropline;
	char                    dth_dropfunc[DROPTAP_DROPFUNC_MAXLEN];
};
struct  ether_header {
	u_char  ether_dhost[ETHER_ADDR_LEN];
	u_char  ether_shost[ETHER_ADDR_LEN];
	u_short ether_type;
} ether_header_t;
struct  ether_addr {
	u_char octet[ETHER_ADDR_LEN];
} ether_addr_t;
struct en_desc {
	u_int16_t type;                 
	u_int32_t protocol_family;      
	u_int32_t data[2];              
};
struct ether_desc_blk_str {
	u_int32_t       n_max_used;
	u_int32_t       n_count;
	u_int32_t       n_used;
	struct en_desc  block_ptr[__counted_by(n_count)];
};
struct  firewire_header {
	u_char  firewire_dhost[FIREWIRE_EUI64_LEN];
	u_char  firewire_shost[FIREWIRE_EUI64_LEN];
	u_short firewire_type;          
};
struct  firewire_eui64 {
	u_char octet[FIREWIRE_EUI64_LEN];
};
struct firewire_address {
	u_char      eui64[FIREWIRE_EUI64_LEN];
	u_char      maxRec;
	u_char      spd;
	u_int16_t   unicastFifoHi;
	u_int32_t   unicastFifoLo;
};
struct flowadv {
	int32_t         code;           
};
struct flowadv_fcentry {
	STAILQ_ENTRY(flowadv_fcentry) fce_link;
	u_int32_t        fce_flowsrc_type;       
	u_int32_t        fce_flowid;
	u_int32_t        fce_ce_cnt;
	u_int32_t        fce_pkts_since_last_report;
	fce_event_type_t fce_event_type;
};
struct ifmultiaddr_dbg {
	struct ifmultiaddr      ifma;                   
	u_int16_t               ifma_refhold_cnt;       
	u_int16_t               ifma_refrele_cnt;       
	ctrace_t                ifma_refhold[IFMA_TRACE_HIST_SIZE];
	ctrace_t                ifma_refrele[IFMA_TRACE_HIST_SIZE];
	TAILQ_ENTRY(ifmultiaddr_dbg) ifma_trash_link;
};
struct intf_event {
	struct ifnet *ifp;
	union sockaddr_in_4_6 addr;
	uint32_t intf_event_code;
};
struct intf_event_nwk_wq_entry {
	struct nwk_wq_entry nwk_wqe;
	struct intf_event intf_ev_arg;
};
struct  arphdr {
	u_short ar_hrd;         
	u_short ar_pro;         
	u_char  ar_hln;         
	u_char  ar_pln;         
	u_short ar_op;          

};
struct arpreq {
	struct  sockaddr arp_pa;                
	struct  sockaddr arp_ha;                
	int     arp_flags;                      
};
struct arpstat {
	uint32_t txrequests;    
	uint32_t txreplies;     
	uint32_t txannounces;   
	uint32_t rxrequests;    
	uint32_t rxreplies;     
	uint32_t received;      

	uint32_t txconflicts;   
	uint32_t invalidreqs;   
	uint32_t reqnobufs;     
	uint32_t dropped;       
	uint32_t purged;        
	uint32_t timeouts;      
	                        
	uint32_t dupips;        

	uint32_t inuse;         
	uint32_t txurequests;   
	uint32_t held;          
};
struct LAG_info_s {
	lacp_system                 li_system;
	lacp_system_priority        li_system_priority;
	lacp_key                    li_key;
};
struct LAG_s {
	TAILQ_ENTRY(LAG_s)          lag_list;
	struct port_list            lag_port_list;
	short                       lag_port_count;
	short                       lag_selected_port_count;
	int                         lag_active_media;
	LAG_info                    lag_info;
};
struct partner_state_s {
	LAG_info                    ps_lag_info;
	lacp_port                   ps_port;
	lacp_port_priority          ps_port_priority;
	lacp_actor_partner_state    ps_state;
} partner_state, * partner_state_ref;
struct ifbond_s {
	TAILQ_ENTRY(ifbond_s)       ifb_bond_list;
	int                         ifb_flags;
	struct os_refcnt            ifb_retain_count;
	char                        ifb_name[IFNAMSIZ];
	struct ifnet *              ifb_ifp;
	int                         ifb_altmtu;
	struct port_list            ifb_port_list;
	short                       ifb_port_count;
	struct lag_list             ifb_lag_list;
	lacp_key                    ifb_key;
	short                       ifb_max_active;
	LAG_ref                     ifb_active_lag;
	struct ifmultiaddr *        ifb_ifma_slow_proto;
	bondport_ref *__counted_by(ifb_distributing_max) ifb_distributing_array;
	int                         ifb_distributing_count;
	int                         ifb_distributing_max;
	int                         ifb_last_link_event;
	int                         ifb_mode;
};
struct media_info {
	int         mi_active;
	int         mi_status;
};
struct bondport_s {
	TAILQ_ENTRY(bondport_s)     po_port_list;
	ifbond_ref                  po_bond;
	struct multicast_list       po_multicast;
	struct ifnet *              po_ifp;
	struct ether_addr           po_saved_addr;
	int                         po_enabled;
	char                        po_name[IFNAMSIZ];
	struct ifdevmtu             po_devmtu;
	uint32_t                    po_control_flags;

	TAILQ_ENTRY(bondport_s)     po_lag_port_list;
	devtimer_ref                po_current_while_timer;
	devtimer_ref                po_periodic_timer;
	devtimer_ref                po_wait_while_timer;
	devtimer_ref                po_transmit_timer;
	partner_state               po_partner_state;
	lacp_port_priority          po_priority;
	lacp_actor_partner_state    po_actor_state;
	u_char                      po_flags;
	u_char                      po_periodic_interval;
	u_char                      po_n_transmit;
	ReceiveState                po_receive_state;
	MuxState                    po_mux_state;
	SelectedState               po_selected;
	int32_t                     po_last_transmit_secs;
	struct media_info           po_media_info;
	uint64_t                    po_force_link_event_time;
	LAG_ref                     po_lag;
};
struct bond_globals_s {
	struct ifbond_list          ifbond_list;
	lacp_system                 system;
	lacp_system_priority        system_priority;
} * bond_globals_ref;
struct if_bond_partner_state {
	lacp_system                 ibps_system;
	lacp_system_priority        ibps_system_priority;
	lacp_key                    ibps_key;
	lacp_port                   ibps_port;
	lacp_port_priority          ibps_port_priority;
	lacp_actor_partner_state    ibps_state;
	u_char                      ibps_reserved1;
};
struct if_bond_status {
	char                        ibs_if_name[IFNAMSIZ];
	lacp_port_priority          ibs_port_priority;
	lacp_actor_partner_state    ibs_state;
	u_char                      ibs_selected_state;
	struct if_bond_partner_state ibs_partner_state;
	u_int32_t                   ibs_reserved[8];
};
struct if_bond_status_req {
	int         ibsr_version;
	int         ibsr_total; 
	int         ibsr_count; 
	union {                 
		void *          ibsru_buffer;
		u_int64_t       ibsru_buffer64;
	} ibsr_ibsru;
	lacp_key    ibsr_key;   
	u_int8_t    ibsr_mode;  
	u_int8_t    ibsr_reserved0;
	u_int32_t   ibsr_reserved[3];
};
struct if_bond_req {
	u_int32_t   ibr_op;                     
	union {
		char    ibru_if_name[IFNAMSIZ]; 
		struct if_bond_status_req ibru_status; 
		int     ibru_int_val;
	} ibr_ibru;
};
struct bridge_iflist {
	TAILQ_ENTRY(bridge_iflist) bif_next;
	struct ifnet            *bif_ifp;       
	struct bstp_port        bif_stp;        
	uint32_t                bif_ifflags;    
	int                     bif_savedcaps;  
	uint32_t                bif_addrmax;    
	uint32_t                bif_addrcnt;    
	uint32_t                bif_addrexceeded; 

	interface_filter_t      bif_iff_ref;
	struct bridge_softc     *bif_sc;
	uint32_t                bif_flags;

	struct in_addr          bif_hf_ipsrc;
	uint8_t                 bif_hf_hwsrc[ETHER_ADDR_LEN];

	struct ifbrmstats       bif_stats;
};
struct mac_nat_entry {
	LIST_ENTRY(mac_nat_entry) mne_list;     
	struct bridge_iflist    *mne_bif;       
	unsigned long           mne_expire;     
	union {
		struct in_addr  mneu_ip;        
		struct in6_addr mneu_ip6;       
	} mne_u;
	uint8_t                 mne_mac[ETHER_ADDR_LEN];
	uint8_t                 mne_flags;
	uint8_t                 mne_reserved;
};
struct mac_nat_record {
	uint16_t                mnr_ether_type;
	union {
		uint16_t        mnru_arp_offset;
		struct {
			uint16_t mnruip_dhcp_flags;
			uint16_t mnruip_udp_csum;
			uint8_t  mnruip_header_len;
		} mnru_ip;
		struct {
			uint16_t mnruip6_icmp6_len;
			uint16_t mnruip6_lladdr_offset;
			uint8_t mnruip6_icmp6_type;
			uint8_t mnruip6_header_len;
		} mnru_ip6;
	} mnr_u;
};
struct bridge_rtnode {
	LIST_ENTRY(bridge_rtnode) brt_hash;     
	LIST_ENTRY(bridge_rtnode) brt_list;     
	struct bridge_iflist    *brt_dst;       
	unsigned long           brt_expire;     
	uint8_t                 brt_flags;      
	uint8_t                 brt_addr[ETHER_ADDR_LEN];
	uint16_t                brt_vlan;       
};
struct bridge_delayed_call {
	struct bridge_softc     *bdc_sc;
	bridge_delayed_func_t   bdc_func; 
	struct timespec         bdc_ts; 
	u_int32_t               bdc_flags;
	thread_call_t           bdc_thread_call;
};
struct bridge_softc {
	struct ifnet            *sc_ifp;        
	uint32_t                sc_flags;
	LIST_ENTRY(bridge_softc) sc_list;
	decl_lck_mtx_data(, sc_mtx);
	struct _bridge_rtnode_list * __counted_by(sc_rthash_size) sc_rthash;  
	struct _bridge_rtnode_list sc_rtlist;   
	uint32_t                sc_rthash_key;  
	uint32_t                sc_rthash_size; 
	struct bridge_delayed_call sc_aging_timer;
	struct bridge_delayed_call sc_resize_call;
	TAILQ_HEAD(, bridge_iflist) sc_spanlist;        
	struct bstp_state       sc_stp;         
	void                    *sc_cv;
	uint32_t                sc_brtmax;      
	uint32_t                sc_brtcnt;      
	uint32_t                sc_brttimeout;  
	uint32_t                sc_iflist_ref;  
	uint32_t                sc_iflist_xcnt; 
	TAILQ_HEAD(, bridge_iflist) sc_iflist;  
	uint32_t                sc_brtexceeded; 
	uint32_t                sc_filter_flags; 
	struct ifnet            *sc_ifaddr;     
	u_char                  sc_defaddr[6];  
	char                    sc_if_xname[IFNAMSIZ];

	struct bridge_iflist    *sc_mac_nat_bif; 
	struct mac_nat_entry_list sc_mne_list;  
	struct mac_nat_entry_list sc_mne_list_v6;
	uint32_t                sc_mne_max;      
	uint32_t                sc_mne_count;    
	uint32_t                sc_mne_allocation_failures;
	void                    *lock_lr[BR_LCKDBG_MAX];
	int                     next_lock_lr;
	void                    *unlock_lr[BR_LCKDBG_MAX];
	int                     next_unlock_lr;
};
struct {
	u_int           ip_hlen;        
	u_int           ip_pay_len;     
	u_int           ip_m0_len;      
	u_int           ip_opt_len;     
	uint8_t         ip_proto;       
	bool            ip_is_ipv4;
	bool            ip_is_fragmented;
	uint8_t         *__sized_by(ip_m0_len) ip_hdr;   
	uint8_t         *__indexable ip_proto_hdr;   
} ip_packet_info, *ip_packet_info_t;
struct bridge_control {
	int             (*bc_func)(struct bridge_softc *, void *__sized_by(arg_len) args, size_t arg_len);
	unsigned int    bc_argsize;
	unsigned int    bc_flags;
};
struct gso_ip_tcp_state {
	void    (*update)
	(struct gso_ip_tcp_state*, struct mbuf*);
	void    (*internal)
	(struct gso_ip_tcp_state*, struct mbuf*);
	u_int ip_m0_len;
	uint8_t * __counted_by(ip_m0_len) hdr;
	struct tcphdr *tcp;
	int mac_hlen;
	int ip_hlen;
	int tcp_hlen;
	int hlen;
	int pay_len;
	int sw_csum;
	uint32_t tcp_seq;
	uint16_t ip_id;
	boolean_t is_tx;
};
struct ifbreq {
	char            ifbr_ifsname[IFNAMSIZ]; 
	uint32_t        ifbr_ifsflags;          
	uint32_t        ifbr_stpflags;          
	uint32_t        ifbr_path_cost;         
	uint8_t         ifbr_portno;            
	uint8_t         ifbr_priority;          
	uint8_t         ifbr_proto;             
	uint8_t         ifbr_role;              
	uint8_t         ifbr_state;             
	uint32_t        ifbr_addrcnt;           
	uint32_t        ifbr_addrmax;           
	uint32_t        ifbr_addrexceeded;      
	uint8_t         pad[32];
};
struct ifbrparam {
	union {
		uint32_t ifbrpu_int32;
		uint16_t ifbrpu_int16;
		uint8_t ifbrpu_int8;
	} ifbrp_ifbrpu;
};
struct ifbpstpreq {
	uint8_t         ifbp_portno;            
	uint32_t        ifbp_fwd_trans;         
	uint32_t        ifbp_design_cost;       
	uint32_t        ifbp_design_port;       
	uint64_t        ifbp_design_bridge;     
	uint64_t        ifbp_design_root;       
};
struct ifbrhostfilter {
	uint32_t        ifbrhf_flags;           
	char            ifbrhf_ifsname[IFNAMSIZ];       
	uint8_t         ifbrhf_hwsrca[ETHER_ADDR_LEN];
	uint32_t        ifbrhf_ipsrc;
};
struct bridge_hostfilter_stats {
	uint64_t        brhf_bad_ether_type;
	uint64_t        brhf_bad_ether_srchw_addr;

	uint64_t        brhf_ether_too_small;
	uint64_t        brhf_ether_pullup_failed;

	uint64_t        brhf_arp_ok;
	uint64_t        brhf_arp_too_small;
	uint64_t        brhf_arp_pullup_failed;
	uint64_t        brhf_arp_bad_hw_type;
	uint64_t        brhf_arp_bad_pro_type;
	uint64_t        brhf_arp_bad_hw_len;
	uint64_t        brhf_arp_bad_pro_len;
	uint64_t        brhf_arp_bad_op;
	uint64_t        brhf_arp_bad_sha;
	uint64_t        brhf_arp_bad_spa;

	uint64_t        brhf_ip_ok;
	uint64_t        brhf_ip_too_small;
	uint64_t        brhf_ip_pullup_failed;
	uint64_t        brhf_ip_bad_srcaddr;
	uint64_t        brhf_ip_bad_proto;

	uint64_t        brhf_dhcp_too_small;
	uint64_t        brhf_dhcp_bad_op;
	uint64_t        brhf_dhcp_bad_htype;
	uint64_t        brhf_dhcp_bad_hlen;
	uint64_t        brhf_dhcp_bad_chaddr;
	uint64_t        brhf_dhcp_bad_ciaddr;
};
struct ifbrmne {
	char            ifbmne_ifname[IFNAMSIZ]; 
	uint64_t        ifbmne_expire;           
	uint8_t         ifbmne_mac[ETHER_ADDR_LEN];
	uint8_t         ifbmne_reserved;
	uint8_t         ifbmne_af;              
	union ifbrip    ifbmne_ip;
};
struct bripstats {
	uint64_t        bips_ip;
	uint64_t        bips_ip6;
	uint64_t        bips_udp;
	uint64_t        bips_tcp;

	uint64_t        bips_bad_ip;
	uint64_t        bips_bad_ip6;
	uint64_t        bips_bad_udp;
	uint64_t        bips_bad_tcp;
};
struct brcsumstats {
	uint64_t        brcs_ip_checksum;
	uint64_t        brcs_udp_checksum;
	uint64_t        brcs_tcp_checksum;
};
struct ifbrmstats {
	struct bripstats        brms_in_ip;
	struct bripstats        brms_out_ip;

	struct brcsumstats      brms_in_computed_cksum;

	struct brcsumstats      brms_out_cksum_good;
	struct brcsumstats      brms_out_cksum_good_hw;

	struct brcsumstats      brms_out_cksum_bad;
	struct brcsumstats      brms_out_cksum_bad_hw;
};
struct sockaddr_dl {
	u_char  sdl_len;        
	u_char  sdl_family;     
	u_short sdl_index;      
	u_char  sdl_type;       
	u_char  sdl_nlen;       
	u_char  sdl_alen;       
	u_char  sdl_slen;       
	char    sdl_data[12];
};
struct if_fake {
	char                    iff_name[IFNAMSIZ]; 
	ifnet_t                 iff_ifp;
	iff_flags_t             iff_flags;
	uint32_t                iff_retain_count;
	ifnet_t                 iff_peer;       
	int                     iff_media_current;
	int                     iff_media_active;
	uint32_t                iff_media_count;
	int                     iff_media_list[IF_FAKE_MEDIA_LIST_MAX];
	boolean_t               iff_start_busy;
	unsigned int            iff_max_mtu;
	uint32_t                iff_fcs;
	uint32_t                iff_trailer_length;
};
struct if_fake_media {
	int32_t         iffm_current;
	uint32_t        iffm_count;
	uint32_t        iffm_reserved[3];
	int32_t         iffm_list[IF_FAKE_MEDIA_LIST_MAX];
};
struct if_fake_request {
	uint64_t        iffr_reserved[4];
	union {
		char    iffru_buf[128];         
		struct if_fake_media    iffru_media;
		char    iffru_peer_name[IFNAMSIZ]; 
		
		uint32_t        iffru_dequeue_stall;
	} iffr_u;
};
struct gif_softc {
	ifnet_t                 gif_if;    
	struct sockaddr *gif_psrc; 
	struct sockaddr *gif_pdst; 
	protocol_family_t gif_proto; 
	union {
		struct route  gifscr_ro;    
		struct route_in6 gifscr_ro6; 
	} gifsc_gifscr;
	int             gif_flags;
	int             gif_called;
	const struct encaptab *encap_cookie4;
	const struct encaptab *encap_cookie6;
	TAILQ_ENTRY(gif_softc) gif_link; 
	bpf_tap_mode    tap_mode;
	bpf_packet_func tap_callback;
	char    gif_ifname[IFNAMSIZ];
	decl_lck_mtx_data(, gif_lock);  
};
struct ipsec_pcb {
	TAILQ_ENTRY(ipsec_pcb)  ipsec_chain;
	kern_ctl_ref            ipsec_ctlref;
	ifnet_t                 ipsec_ifp;
	u_int32_t               ipsec_unit;
	u_int32_t               ipsec_unique_id;
	u_int32_t               ipsec_external_flags;
	u_int32_t               ipsec_internal_flags;
	u_int32_t               ipsec_input_frag_size;
	bool                    ipsec_frag_size_set;
	int                     ipsec_ext_ifdata_stats;
	mbuf_svc_class_t        ipsec_output_service_class;
	char                    ipsec_if_xname[IFXNAMSIZ];
	char                    ipsec_unique_name[IFXNAMSIZ];
	decl_lck_rw_data(, ipsec_pcb_lock);
	decl_lck_mtx_data(, ipsec_pcb_data_move_lock);
	u_int32_t               ipsec_pcb_data_move; 
	u_int32_t               ipsec_pcb_drainers; 
	u_int32_t               ipsec_pcb_data_path_state; 
	ipsec_dscp_mapping_t    ipsec_output_dscp_mapping;

};
struct ipsec_stats_param {
	u_int64_t       utsp_packets;
	u_int64_t       utsp_bytes;
	u_int64_t       utsp_errors;
};
struct llc {
	u_int8_t llc_dsap;
	u_int8_t llc_ssap;
	union {
		struct {
			u_int8_t control;
			u_int8_t format_id;
			u_int8_t class_id;
			u_int8_t window_x2;
		} type_u;
		struct {
			u_int8_t num_snd_x2;
			u_int8_t num_rcv_x2;
		} type_i;
		struct {
			u_int8_t control;
			u_int8_t num_rcv_x2;
		} type_s;
		struct {
			u_int8_t control;
			
			u_int8_t frmr_rej_pdu0;
			u_int8_t frmr_rej_pdu1;
			u_int8_t frmr_control;
			u_int8_t frmr_control_ext;
			u_int8_t frmr_cause;
		} type_frmr;
		struct {
			u_int8_t  control;
			u_int8_t  org_code[3];
			u_int16_t ether_type;
		} type_snap __attribute__((__packed__));
		struct {
			u_int8_t control;
			u_int8_t control_ext;
		} type_raw;
	} llc_un;
} __attribute__((__packed__));
struct frmrinfo {
	u_int8_t frmr_rej_pdu0;
	u_int8_t frmr_rej_pdu1;
	u_int8_t frmr_control;
	u_int8_t frmr_control_ext;
	u_int8_t frmr_cause;
} __attribute__((__packed__));
struct if_llreach_info {
	u_int32_t               lri_refcnt;     
	u_int32_t               lri_ifindex;    
	u_int64_t               lri_expire;     
	u_int32_t               lri_probes;     
	u_int16_t               lri_reserved;   
	u_int16_t               lri_proto;      
	u_int8_t                lri_addr[IF_LLREACHINFO_ADDRLEN]; 
	int32_t                 lri_rssi;       
	int32_t                 lri_lqm;        
	int32_t                 lri_npm;        
	u_int8_t                lri_reserved2[IF_LLREACHINFO_RESERVED2];
};
struct if_llreach {
	decl_lck_mtx_data(, lr_lock);
	RB_ENTRY(if_llreach)    lr_link;        
	struct ifnet            *lr_ifp;        
	u_int32_t               lr_refcnt;      
	u_int32_t               lr_reqcnt;      
	u_int32_t               lr_debug;       
	u_int32_t               lr_probes;      
	u_int64_t               lr_basecal;     
	u_int64_t               lr_baseup;      
	u_int64_t               lr_lastrcvd;    
	u_int32_t               lr_basereachable; 
	u_int32_t               lr_reachable;   
	struct lr_key_s {
		u_int16_t       proto;          
		u_int8_t        addr[IF_LLREACH_MAXLEN]; 
	} lr_key;
	int32_t                 lr_rssi;        
	int32_t                 lr_lqm;         
	int32_t                 lr_npm;         
};
struct if_low_power_ev_args {
	struct ifnet *ifp;
	if_low_power_ev_code_t event_code;
};
struct if_low_power_ev_nwk_wq_entry {
	struct nwk_wq_entry nwk_wqe;
	struct if_low_power_ev_args ev_args;
};
struct ifmedia_description {
	int     ifmt_word;              
	const char *ifmt_string;        
};
struct ifmibdata {
	char                    ifmd_name[IFNAMSIZ]; 
	unsigned int            ifmd_pcount;    
	unsigned int            ifmd_flags;     
	unsigned int            ifmd_snd_len;   
	unsigned int            ifmd_snd_maxlen; 
	unsigned int            ifmd_snd_drops; 
	unsigned int            ifmd_filler[4]; 
	struct if_data64        ifmd_data; 
};
struct ifs_iso_8802_3 {
	u_int32_t       dot3StatsAlignmentErrors;
	u_int32_t       dot3StatsFCSErrors;
	u_int32_t       dot3StatsSingleCollisionFrames;
	u_int32_t       dot3StatsMultipleCollisionFrames;
	u_int32_t       dot3StatsSQETestErrors;
	u_int32_t       dot3StatsDeferredTransmissions;
	u_int32_t       dot3StatsLateCollisions;
	u_int32_t       dot3StatsExcessiveCollisions;
	u_int32_t       dot3StatsInternalMacTransmitErrors;
	u_int32_t       dot3StatsCarrierSenseErrors;
	u_int32_t       dot3StatsFrameTooLongs;
	u_int32_t       dot3StatsInternalMacReceiveErrors;
	u_int32_t       dot3StatsEtherChipSet;
	u_int32_t       dot3StatsMissedFrames;

	u_int32_t       dot3StatsCollFrequencies[16]; 

	u_int32_t       dot3Compliance;
};
struct ifmibdata_supplemental {
	struct if_traffic_class ifmd_traffic_class;
	struct if_data_extended ifmd_data_extended;
	struct if_packet_stats  ifmd_packet_stats;
	struct if_rxpoll_stats  ifmd_rxpoll_stats;
	struct if_netif_stats   ifmd_netif_stats;
};
struct net_port_entry {
	SLIST_ENTRY(net_port_entry)     npe_list_next;
	TAILQ_ENTRY(net_port_entry)     npe_hash_next;
	struct net_port_info            npe_npi;
};
struct net_port_info_wake_pkt_event {
	uint32_t                npi_wp_code;
	uint32_t                npi_wp_flags;
	union {
		struct net_port_info_wake_event _npi_ev_wake_pkt_attributed;
		struct net_port_info_una_wake_event _npi_ev_wake_pkt_unattributed;
	} npi_ev_wake_pkt_;
};
struct xnpigen {
	uint32_t        xng_len; 
	uint32_t        xng_gen; 
	uint32_t        xng_npi_count; 
	uint32_t        xng_npi_size; 
	uuid_t          xng_wakeuuid; 
};
struct net_port_info {
	uint16_t                npi_if_index;
	uint16_t                npi_flags; 
	struct timeval32        npi_timestamp; 
	uuid_t                  npi_flow_uuid;
	in_port_t               npi_local_port; 
	in_port_t               npi_foreign_port; 
	union in_addr_4_6       npi_local_addr_;
	union in_addr_4_6       npi_foreign_addr_;
	pid_t                   npi_owner_pid;
	pid_t                   npi_effective_pid;
	char                    npi_owner_pname[MAXCOMLEN + 1];
	char                    npi_effective_pname[MAXCOMLEN + 1];
	uuid_t                  npi_owner_uuid;
	uuid_t                  npi_effective_uuid;
};
struct npi_if_info {
	uint32_t            npi_if_family; 
	uint32_t            npi_if_subfamily; 
	uint32_t            npi_if_functional_type; 
};
struct net_port_info_wake_event {
	uuid_t              wake_uuid;
	struct timeval32    wake_pkt_timestamp; 
	uint16_t            wake_pkt_if_index; 
	in_port_t           wake_pkt_port; 
	uint16_t            wake_pkt_flags; 
	pid_t               wake_pkt_owner_pid;
	pid_t               wake_pkt_effective_pid;
	char                wake_pkt_owner_pname[MAXCOMLEN + 1];
	char                wake_pkt_effective_pname[MAXCOMLEN + 1];
	uuid_t              wake_pkt_owner_uuid;
	uuid_t              wake_pkt_effective_uuid;
	in_port_t           wake_pkt_foreign_port; 
	union in_addr_4_6   wake_pkt_local_addr_;
	union in_addr_4_6   wake_pkt_foreign_addr_;
	char                wake_pkt_ifname[IFNAMSIZ]; 

	uint32_t            wake_pkt_total_len; 
	uint32_t            wake_pkt_data_len; 
	uint16_t            wake_pkt_control_flags; 

	struct npi_if_info  wake_pkt_if_info;  

	char                wake_pkt_phy_ifname[IFNAMSIZ]; 
	struct npi_if_info  wake_pkt_phy_if_info; 
};
struct net_port_info_una_wake_event {
	uuid_t              una_wake_uuid;
	struct timeval32    una_wake_pkt_timestamp; 
	uint16_t            una_wake_pkt_if_index; 
	uint16_t            una_wake_pkt_flags; 
	uint16_t            _una_wake_pkt_reserved; 
	uint16_t            una_wake_ptk_len; 
	uint8_t             una_wake_pkt[NPI_MAX_UNA_WAKE_PKT_LEN]; 
	in_port_t           una_wake_pkt_local_port; 
	in_port_t           una_wake_pkt_foreign_port; 
	union in_addr_4_6   una_wake_pkt_local_addr_;
	union in_addr_4_6   una_wake_pkt_foreign_addr_;
	char                una_wake_pkt_ifname[IFNAMSIZ]; 

	uint32_t            una_wake_pkt_total_len; 
	uint32_t            una_wake_pkt_data_len; 
	uint16_t            una_wake_pkt_control_flags; 
	uint16_t            una_wake_pkt_proto; 

	struct npi_if_info  una_wake_pkt_if_info; 

	char                una_wake_pkt_phy_ifname[IFNAMSIZ]; 
	struct npi_if_info  una_wake_pkt_phy_if_info; 
};
struct if_ports_used_stats {
	IF_PORTS_USED_STATS_LIST
};
struct npioctl {
	int         protocol;   
	enum NPmode mode;
};
struct ppp_option_data {
	u_char  *ptr;
	u_int   length;
	int     transmit;
};
struct ifpppstatsreq {
	char ifr_name[IFNAMSIZ];
	struct ppp_stats stats;
};
struct ifpppcstatsreq {
	char ifr_name[IFNAMSIZ];
	struct ppp_comp_stats stats;
};
struct {
	uuid_t                 rnx_provider;
	uuid_t                 rnx_instance;
} redirect_nx, *redirect_nx_t;
struct {
	char                   rd_name[IFNAMSIZ]; 
	lck_mtx_t              rd_lock;
	uint32_t               rd_ftype;
	ifnet_t                rd_ifp;
	ifnet_t                rd_delegate_ifp;

	boolean_t              rd_detaching;
	boolean_t              rd_connected;

	boolean_t              rd_self_ref;
	boolean_t              rd_delegate_parent_set;
	boolean_t              rd_delegate_ref;
	boolean_t              rd_fsw_rx_cb_set;
	boolean_t              rd_delegate_set;
	boolean_t              rd_mac_addr_set;
	boolean_t              rd_detach_notify_set;

	unsigned int           rd_max_mtu;
	uint32_t               rd_retain_count;
	kern_pbufpool_t        rd_pp;
	kern_channel_ring_t    rd_rx_ring[RD_MAX_RX_RINGS];
	kern_channel_ring_t    rd_tx_ring[RD_MAX_TX_RINGS];
	redirect_nx            rd_nx;
	struct netif_stats     *rd_nifs;
	void                   *rd_intf_adv_kern_ctx;
	thread_call_t          rd_doorbell_tcall;
	boolean_t              rd_doorbell_tcall_active;
	boolean_t              rd_waiting_for_tcall;
	bool                   rd_intf_adv_enabled;
	kern_nexus_capab_interface_advisory_notify_fn_t rd_intf_adv_notify;
} if_redirect, *if_redirect_t;
struct if_redirect_create_params {
	uint16_t ircp_type;
	uint16_t ircp_len;
	uint32_t ircp_ftype;
};
struct if_redirect_request {
	uint64_t ifrr_reserved[4];
	union {
		char ifrru_buf[128];                
		char ifrru_delegate_name[IFNAMSIZ]; 
	} ifrr_u;
};
struct stf_softc {
	ifnet_t                         sc_if;     
	u_int32_t                               sc_protocol_family; 
	union {
		struct route  __sc_ro4;
		struct route_in6 __sc_ro6; 
	} __sc_ro46;
	decl_lck_mtx_data(, sc_ro_mtx);
	const struct encaptab *encap_cookie;
	bpf_tap_mode            tap_mode;
	bpf_packet_func         tap_callback;
};
struct utun_pcb {
	TAILQ_ENTRY(utun_pcb)   utun_chain;
	kern_ctl_ref    utun_ctlref;
	ifnet_t                 utun_ifp;
	u_int32_t               utun_unit;
	u_int32_t               utun_unique_id;
	u_int32_t               utun_flags;
	int                     utun_ext_ifdata_stats;
	u_int32_t               utun_max_pending_packets;
	char                    utun_if_xname[IFXNAMSIZ];
	char                    utun_unique_name[IFXNAMSIZ];
	decl_lck_rw_data(, utun_pcb_lock);
	struct mbuf *   utun_input_chain;
	struct mbuf *   utun_input_chain_last;
	u_int32_t               utun_input_chain_count;
	lck_mtx_t               utun_input_chain_lock;

};
struct utun_stats_param {
	u_int64_t       utsp_packets;
	u_int64_t       utsp_bytes;
	u_int64_t       utsp_errors;
};
struct if_cellular_status_v1 {
	u_int32_t valid_bitmask;     

	u_int32_t link_quality_metric;
	u_int32_t ul_effective_bandwidth; 
	u_int32_t ul_max_bandwidth; 
	u_int32_t ul_min_latency; 
	u_int32_t ul_effective_latency; 
	u_int32_t ul_max_latency; 
	u_int32_t ul_retxt_level; 
	u_int32_t ul_bytes_lost; 
	u_int32_t ul_min_queue_size; 
	u_int32_t ul_avg_queue_size; 
	u_int32_t ul_max_queue_size; 
	u_int32_t dl_effective_bandwidth; 
	u_int32_t dl_max_bandwidth; 
	u_int32_t config_inactivity_time; 
	u_int32_t config_backoff_time; 
	u_int16_t mss_recommended;
	u_int16_t reserved_1;
	u_int32_t reserved_2;
	u_int64_t reserved_3;
	u_int64_t reserved_4;
	u_int64_t reserved_5;
	u_int64_t reserved_6;
} __attribute__((packed));
struct if_cellular_status {
	union {
		struct if_cellular_status_v1 if_status_v1;
	} if_cell_u;
};
struct if_wifi_status_v1 {
	u_int32_t valid_bitmask;
	u_int32_t link_quality_metric; 
	u_int32_t ul_effective_bandwidth; 
	u_int32_t ul_max_bandwidth; 
	u_int32_t ul_min_latency; 
	u_int32_t ul_effective_latency; 
	u_int32_t ul_max_latency; 
	u_int32_t ul_retxt_level; 
	u_int32_t ul_bytes_lost; 
	u_int32_t ul_error_rate; 
	u_int32_t dl_effective_bandwidth; 
	u_int32_t dl_max_bandwidth; 
	u_int32_t dl_min_latency; 
	u_int32_t dl_effective_latency; 
	u_int32_t dl_max_latency; 
	u_int32_t dl_error_rate; 
	u_int32_t config_frequency; 
	u_int32_t config_multicast_rate; 
	u_int32_t scan_count; 
	u_int32_t scan_duration; 
	u_int64_t reserved_1;
	u_int64_t reserved_2;
	u_int64_t reserved_3;
	u_int64_t reserved_4;
} __attribute__((packed));
struct if_wifi_status {
	union {
		struct if_wifi_status_v1 if_status_v1;
	} if_wifi_u;
};
struct if_link_status {
	u_int32_t       ifsr_version;   
	u_int32_t       ifsr_len;       
	union {
		struct if_cellular_status ifsr_cell;
		struct if_wifi_status ifsr_wifi;
	} ifsr_u;
};
struct ifnet_interface_advisory_header {
	enum ifnet_interface_advisory_version         version;
	enum ifnet_interface_advisory_direction       direction;
	enum ifnet_interface_advisory_interface_type  interface_type;
	ifnet_interface_advisory_notification_type_t  notification_type;
};
struct ifnet_interface_advisory_capacity {
	enum ifnet_interface_advisory_rate_trend  rate_trend_suggestion;
	uint64_t    timestamp;
	uint64_t    max_bandwidth;
	uint64_t    total_byte_count;
	uint64_t    average_throughput;
	uint32_t    flushable_queue_size;
	uint32_t    non_flushable_queue_size;
	uint32_t    average_delay;
};
struct ifnet_interface_advisory_wifi_context {
	enum ifnet_interface_advisory_wifi_freq_band  frequency_band;
	uint8_t     intermittent_state;
	uint16_t    estimated_intermittent_period;
	uint16_t    single_outage_period;
	uint8_t     bt_coex;
	uint8_t     quality_score_delay;
	uint8_t     quality_score_loss;
	uint8_t     quality_score_channel;
	uint8_t     radio_coex;
	uint16_t    wlan_duty_cycle;
	uint32_t    wifi_observed_tx_bitrate[IF_INTERFACE_ADVISORY_WIFI_TX_QUEUE_COUNT];
};
struct ifnet_interface_advisory_cell_context {
	uint8_t     radio_access_technology;
	int16_t     reference_signal_level;
	int16_t     signal_level;
	int8_t      signal_quality;
	uint8_t     uplink_bler;
	uint8_t     downlink_bler;
	uint8_t     bandwidth_limitation_indication;
	uint8_t     cdrx_state;
	uint16_t    cdrx_cycle;
	uint16_t    estimated_outage_period;
	uint8_t     outage_state;
	uint8_t     __pad;
};
struct ifnet_interface_advisory {
	union {
		struct { 
			
			uint8_t     version;
			
			uint8_t     direction;
			
			uint16_t    _reserved;
			
			int32_t     rate_trend_suggestion;
			
			uint64_t    timestamp;
			
			uint64_t    max_bandwidth;
			
			uint64_t    total_byte_count;
			
			uint64_t    average_throughput;
			
			uint32_t    flushable_queue_size;
			
			uint32_t    non_flushable_queue_size;
			
			uint32_t    average_delay;
			
			uint8_t    frequency_band;
			
			uint8_t     intermittent_state;
			
			uint16_t    estimated_intermittent_period;
			
			uint16_t    single_outage_period;

			
			uint8_t     bt_coex;
			
			uint8_t     quality_score_delay;
			
			uint8_t     quality_score_loss;
			
			uint8_t     quality_score_channel;
		};

		struct { 
			struct ifnet_interface_advisory_header    header;
			struct ifnet_interface_advisory_capacity  capacity;
			union {
				struct ifnet_interface_advisory_wifi_context    wifi_context;
				struct ifnet_interface_advisory_cell_context    cell_context;
			};
		};
	};
} __attribute__((aligned(sizeof(uint64_t))));
struct ifnet_traffic_descriptor_common {
	uint8_t     itd_type;
	uint8_t     _reserved;
	uint16_t    itd_len; 
	uint32_t    itd_flags;
};
struct ifnet_ip_addr {
	union {
		uint8_t  addr8[16];
		uint16_t addr16[8];
		uint32_t addr32[4];
	};
};
struct ifnet_traffic_descriptor_inet {
	struct ifnet_traffic_descriptor_common inet_common;
	uint8_t     inet_mask;
	uint8_t     inet_ipver; 
	uint8_t     inet_proto; 
	uint8_t     _reserved;
	struct ifnet_ip_addr inet_laddr;
	struct ifnet_ip_addr inet_raddr;
	uint16_t    inet_lport;
	uint16_t    inet_rport;
};
struct ifnet_traffic_rule_action {
	uint8_t     ra_type;
	uint8_t     _reserved;
	uint16_t    ra_len;
};
struct ifnet_traffic_rule_action_steer {
	struct ifnet_traffic_rule_action ras_common;
	uint64_t    ras_qset_id;
};
struct vlan_parent {
	vlan_parent_entry           vlp_parent_list;
	struct ifnet *              vlp_ifp;    
	struct ifvlan_list          vlp_vlan_list;
	u_int32_t                   vlp_flags;
	u_int32_t                   vlp_event_code;
	struct ifdevmtu             vlp_devmtu;
	int32_t                     vlp_retain_count;
	u_int32_t                   vlp_signature;
} vlan_parent, * __single vlan_parent_ref;
struct ifvlan {
	ifvlan_entry                ifv_vlan_list;
	char                        ifv_name[IFNAMSIZ];
	struct ifnet *              ifv_ifp;    
	vlan_parent_ref             ifv_vlp;    
	u_int16_t                   ifv_mtufudge;
	u_int16_t                   ifv_tag;     
	struct multicast_list       ifv_multicast;
	u_int32_t                   ifv_flags;
	int32_t                     ifv_retain_count;
	u_int32_t                   ifv_signature;
};
struct vlan_globals_s {
	struct vlan_parent_list     parent_list;
} * vlan_globals_ref;
struct ether_vlan_encap_header {
	u_int16_t evle_tag;
	u_int16_t evle_proto;
};
struct  ether_vlan_header {
	u_char  evl_dhost[ETHER_ADDR_LEN];
	u_char  evl_shost[ETHER_ADDR_LEN];
	u_int16_t evl_encap_proto;
	u_int16_t evl_tag;
	u_int16_t evl_proto;
};
struct  vlanreq {
	char    vlr_parent[IFNAMSIZ];
	u_short vlr_tag;
};
struct init_list_entry {
	struct init_list_entry  *next;
	net_init_func_ptr               func;
};
struct iptap_softc {
	LIST_ENTRY(iptap_softc)         iptap_link;
	uint32_t                                        iptap_unit;
	uint32_t                                        iptap_dlt_raw_count;
	uint32_t                                        iptap_dlt_pkttap_count;
	struct ifnet                            *iptap_ifp;
};
struct so_nke {
	unsigned int nke_handle;
	unsigned int nke_where;
	int nke_flags; 
	u_int32_t reserved[4];  
};
struct ifnet_addr_list {
	SLIST_ENTRY(ifnet_addr_list)    ifal_le;
	struct ifaddr                   *ifal_ifa;
};
struct ifnet_list {
	SLIST_ENTRY(ifnet_list) ifl_le;
	struct ifnet            *ifl_ifp;
};
struct ifnet_demux_desc {
	u_int32_t       type;
	void            *__sized_by(datalen) data;
	u_int32_t       datalen;
};
struct ifnet_stat_increment_param {
	u_int32_t                               packets_in;
	u_int32_t                               bytes_in;
	u_int32_t                               errors_in;

	u_int32_t                               packets_out;
	u_int32_t                               bytes_out;
	u_int32_t                               errors_out;

	u_int32_t                               collisions;
	u_int32_t                               dropped;
};
struct ifnet_init_params {
	const void *__sized_by(uniqueid_len) uniqueid;  
	u_int32_t               uniqueid_len;           

	const char              *name;                  
	u_int32_t               unit;                   
	ifnet_family_t          family;                 
	u_int32_t               type;                   
	ifnet_output_func       output;                 
	ifnet_demux_func        demux;                  
	ifnet_add_proto_func    add_proto;              
	ifnet_del_proto_func    del_proto;              
	ifnet_check_multi       check_multi;            
	ifnet_framer_func       framer;                 
	void                    *softc;                 
	ifnet_ioctl_func        ioctl;                  
	ifnet_set_bpf_tap       set_bpf_tap;            
	ifnet_detached_func     detach;                 
	ifnet_event_func        event;                  
	const void *__sized_by(broadcast_len) broadcast_addr; 
	u_int32_t               broadcast_len;          
};
struct ifnet_model_params {
	ifnet_model_t           model;
	u_int32_t               reserved[3];
};
struct ifnet_log_params {
	ifnet_log_level_t       level;
	ifnet_log_flags_t       flags;
	ifnet_log_category_t    category;
	ifnet_log_subcategory_t subcategory;
};
struct ifnet_notify_address_params {
	sa_family_t             address_family;
	u_int32_t               reserved[3];
};
struct ifnet_init_eparams {
	u_int32_t               ver;                    
	u_int32_t               len;                    
	u_int32_t               flags;                  

	const void *__sized_by(uniqueid_len) uniqueid;  
	u_int32_t               uniqueid_len;           

	const char              *name;                  
	u_int32_t               unit;                   
	ifnet_family_t          family;                 
	u_int32_t               type;                   
	u_int32_t               sndq_maxlen;            
	ifnet_output_func       output;                 
	ifnet_pre_enqueue_func  pre_enqueue;            
	ifnet_start_func        start;                  
	ifnet_ctl_func          output_ctl;             
	u_int32_t               output_sched_model;     
	u_int32_t               output_target_qdelay;   
	u_int64_t               output_bw;              
	u_int64_t               output_bw_max;          
	u_int64_t               output_lt;              
	u_int64_t               output_lt_max;          
	u_int16_t               start_delay_qlen;       
	u_int16_t               start_delay_timeout;    
	u_int32_t               _reserved[3];           
	ifnet_input_poll_func   input_poll;             
	ifnet_ctl_func          input_ctl;              
	u_int32_t               rcvq_maxlen;            
	u_int32_t               __reserved;             
	u_int64_t               input_bw;               
	u_int64_t               input_bw_max;           
	u_int64_t               input_lt;               
	u_int64_t               input_lt_max;           
	u_int64_t               ___reserved[2];         
	ifnet_demux_func        demux;                  
	ifnet_add_proto_func    add_proto;              
	ifnet_del_proto_func    del_proto;              
	ifnet_check_multi       check_multi;            
	ifnet_framer_func       framer;                 
	void                    *softc;                 
	ifnet_ioctl_func        ioctl;                  
	ifnet_set_bpf_tap       set_bpf_tap;            
	ifnet_detached_func     detach;                 
	ifnet_event_func        event;                  
	const void *__sized_by(broadcast_len) broadcast_addr; 
	u_int32_t               broadcast_len;          
	ifnet_framer_extended_func framer_extended;     
	ifnet_subfamily_t       subfamily;              
	u_int16_t               tx_headroom;            
	u_int16_t               tx_trailer;             
	u_int32_t               rx_mit_ival;            
};
struct ifnet_stats_param {
	u_int64_t       packets_in;
	u_int64_t       bytes_in;
	u_int64_t       multicasts_in;
	u_int64_t       errors_in;

	u_int64_t       packets_out;
	u_int64_t       bytes_out;
	u_int64_t       multicasts_out;
	u_int64_t       errors_out;

	u_int64_t       collisions;
	u_int64_t       dropped;
	u_int64_t       no_protocol;
};
struct ifnet_attach_proto_param {
	struct ifnet_demux_desc         *__counted_by(demux_count) demux_array; 
	u_int32_t                       demux_count;    

	proto_media_input               input;          
	proto_media_preout              pre_output;     
	proto_media_event               event;          
	proto_media_ioctl               ioctl;          
	proto_media_detached            detached;       
	proto_media_resolve_multi       resolve;        
	proto_media_send_arp            send_arp;       
};
struct ifnet_attach_proto_param_v2 {
	struct ifnet_demux_desc         *__counted_by(demux_count) demux_array;   
	u_int32_t                       demux_count;    

	proto_media_input_v2            input;          
	proto_media_preout              pre_output;     
	proto_media_event               event;          
	proto_media_ioctl               ioctl;          
	proto_media_detached            detached;       
	proto_media_resolve_multi       resolve;        
	proto_media_send_arp            send_arp;       
};
struct ifnet_poll_params {
	u_int32_t       flags;
	u_int32_t       packets_limit;
	u_int32_t       packets_lowat;
	u_int32_t       packets_hiwat;
	u_int32_t       bytes_lowat;
	u_int32_t       bytes_hiwat;
	u_int64_t       interval_time;
	u_int64_t       reserved[4];
};
struct ifnet_llreach_info {
	u_int32_t iflri_refcnt;
	u_int32_t iflri_probes;
	u_int64_t iflri_snd_expire;
	u_int64_t iflri_rcv_expire;
	u_int64_t iflri_curtime;
	u_int32_t iflri_netproto;
	u_int8_t  iflri_addr[IFNET_LLREACHINFO_ADDRLEN];
	int32_t   iflri_rssi;
	int32_t   iflri_lqm;
	int32_t   iflri_npm;
};
struct ifnet_clone_params {
	const char                      *ifc_name;
	ifnet_clone_create_func         ifc_create;
	ifnet_clone_destroy_func        ifc_destroy;
};
struct ifnet_keepalive_offload_frame {
	u_int8_t data[IFNET_KEEPALIVE_OFFLOAD_FRAME_DATA_SIZE]; 
	u_int8_t type;  
	u_int8_t length; 
	u_int16_t interval; 
	u_int8_t ether_type; 
	u_int8_t keep_cnt; 
	u_int16_t keep_retry; 
	u_int8_t reply_length; 
	u_int8_t addr_length; 
	u_int8_t flags;
	u_int8_t reserved[1];
	u_int8_t reply_data[IFNET_KEEPALIVE_OFFLOAD_FRAME_DATA_SIZE]; 
	u_int8_t local_addr[IFNET_KEEPALIVE_OFFLOAD_MAX_ADDR_SIZE]; 
	u_int8_t remote_addr[IFNET_KEEPALIVE_OFFLOAD_MAX_ADDR_SIZE]; 
	u_int16_t local_port; 
	u_int16_t remote_port; 
	u_int32_t local_seq; 
	u_int32_t remote_seq; 
};
struct {
	int32_t buf_interface; 
	int32_t buf_sndbuf; 
} ifnet_buffer_status_t;
struct iff_filter {
	void                    *iff_cookie;
	const char              *iff_name;
	protocol_family_t       iff_protocol;
	iff_input_func          iff_input;
	iff_output_func         iff_output;
	iff_event_func          iff_event;
	iff_ioctl_func          iff_ioctl;
	iff_detached_func       iff_detached;
};
struct proto_input_entry {
	struct proto_input_entry        *next;
	int                             detach;
	struct domain                   *domain;
	int                             hash;
	int                             chain;

	protocol_family_t               protocol;
	proto_input_handler             input;
	proto_input_detached_handler    detached;

	mbuf_t                          inject_first;
	mbuf_t                          inject_last;

	struct proto_input_entry        *input_next;
	mbuf_t                          input_first;
	mbuf_t                          input_last;
};
struct proto_family_str {
	TAILQ_ENTRY(proto_family_str)   proto_fam_next;
	protocol_family_t               proto_family;
	ifnet_family_t                  if_family;
	proto_plumb_handler             attach_proto;
	proto_unplumb_handler           detach_proto;
};
struct {
	u_char      system_id[6];
} lacp_system, *lacp_system_ref;
struct lacp_actor_partner_tlv_s {
	u_char      lap_tlv_type;       
	u_char      lap_length;         
	u_char      lap_system_priority[2];
	u_char      lap_system[6];
	u_char      lap_key[2];
	u_char      lap_port_priority[2];
	u_char      lap_port[2];
	u_char      lap_state;
	u_char      lap_reserved[3];
} lacp_actor_partner_tlv, *lacp_actor_partner_tlv_ref;
struct lacp_collector_tlv_s {
	u_char      lac_tlv_type;       
	u_char      lac_length;         
	u_char      lac_max_delay[2];
	u_char      lac_reserved[12];
} lacp_collector_tlv, *lacp_collector_tlv_ref;
struct lacpdu_s {
	u_char              la_subtype;
	u_char              la_version;
	u_char              la_actor_tlv[LACPDU_ACTOR_TLV_LENGTH];
	u_char              la_partner_tlv[LACPDU_PARTNER_TLV_LENGTH];
	u_char              la_collector_tlv[LACPDU_COLLECTOR_TLV_LENGTH];
	u_char              la_terminator_type;
	u_char              la_terminator_length;
	u_char              la_reserved[50];
} lacpdu, *lacpdu_ref;
struct la_marker_pdu_s {
	u_char              lm_subtype;         
	u_char              lm_version;         
	u_char              lm_marker_tlv_type; 
	u_char              lm_marker_tlv_length;
	u_char              lm_requestor_port[2];
	u_char              lm_requestor_system[6];
	u_char              lm_requestor_transaction_id[4];
	u_char              lm_pad[2];
	u_char              lm_terminator_type; 
	u_char              lm_terminator_length;
	u_char              lm_reserved[90];
} la_marker_pdu, *la_marker_pdu_ref,
la_marker_response_pdu, * la_marker_response_pdu_ref;
struct {
	mbuf_t          head;
	mbuf_t          tail;
	uint32_t        bytes;
	uint32_t        count;
} mblist, * mblist_t;
struct multicast_entry {
	SLIST_ENTRY(multicast_entry)    mc_entries;
	ifmultiaddr_t                   mc_ifma;
};
struct in6_clat46_event_nwk_wq_entry {
	struct nwk_wq_entry nwk_wqe;
	struct kev_netevent_clat46_data in6_clat46_ev_arg;
};
struct nat464_addr {
	union {
		struct in_addr          _v4addr;
		struct in6_addr         _v6addr;
		uint8_t         _addr8[16];
		uint16_t                _addr16[8];
		uint32_t                _addr32[4];
	} nat464a;                  
};
struct sockaddr_ndrv {
	unsigned char snd_len;
	unsigned char snd_family;
	unsigned char snd_name[IFNAMSIZ]; 
};
struct ndrv_demux_desc {
	u_int16_t   type;
	u_int16_t   length;
	union{
		u_int16_t       ether_type;
		u_int8_t        sap[3];
		u_int8_t        snap[5];
		u_int8_t        other[28];
	} data;
};
struct ndrv_protocol_desc_kernel {
	u_int32_t                           version;
	u_int32_t                           protocol_family;
	u_int32_t                           demux_count;
	struct ndrv_demux_desc              *__counted_by(demux_count) demux_list;
};
struct ndrv_protocol_desc64 {
	u_int32_t                           version;
	u_int32_t                           protocol_family;
	u_int32_t                           demux_count;
	user64_addr_t                       demux_list __attribute__((aligned(8)));
};
struct ndrv_protocol_desc32 {
	u_int32_t                           version;
	u_int32_t                           protocol_family;
	u_int32_t                           demux_count;
	user32_addr_t                       demux_list;
};
struct ndrv_multiaddr {
	struct ndrv_multiaddr      *next;
	ifmultiaddr_t               ifma;
	struct sockaddr            *addr;
};
struct ndrv_cb {
	TAILQ_ENTRY(ndrv_cb)    nd_next;
	struct socket *nd_socket;       
	u_int32_t nd_signature; 
	struct sockaddr_ndrv *nd_faddr;
	struct sockaddr_ndrv *nd_laddr;
	struct sockproto nd_proto;      
	int nd_descrcnt;                
	TAILQ_HEAD(dlist, dlil_demux_desc) nd_dlist; 
	u_int32_t nd_dlist_cnt; 
	struct ifnet *nd_if; 
	u_int32_t nd_proto_family;
	u_int32_t nd_family;
	struct ndrv_multiaddr* nd_multiaddrs;
	short nd_unit;
};
struct necp_service_registration {
	LIST_ENTRY(necp_service_registration)   session_chain;
	LIST_ENTRY(necp_service_registration)   kernel_chain;
	u_int32_t                                                               service_id;
};
struct necp_domain_filter {
	LIST_ENTRY(necp_domain_filter) owner_chain;
	LIST_ENTRY(necp_domain_filter) chain;
	u_int32_t       id;
	struct net_bloom_filter *filter;
	os_refcnt_t     refcount;
};
struct necp_domain_trie {
	LIST_ENTRY(necp_domain_trie) owner_chain;
	LIST_ENTRY(necp_domain_trie) chain;
	u_int32_t       id;
	struct necp_domain_trie_request *trie_request;
	size_t trie_request_size;
	struct net_trie trie;
	os_refcnt_t     refcount;
};
struct necp_session {
	u_int8_t                                        necp_fd_type;
	u_int32_t                                       control_unit;
	u_int32_t                                       session_priority; 
	u_int32_t                                       session_order;

	necp_policy_id                          last_policy_id;

	decl_lck_mtx_data(, lock);

	bool                                            proc_locked; 
	uuid_t                                          proc_uuid;
	int                                                     proc_pid;

	bool                                            dirty;
	LIST_HEAD(_policies, necp_session_policy) policies;

	LIST_HEAD(_services, necp_service_registration) services;
	struct necp_domain_filter_list domain_filters;
	struct necp_domain_trie_list domain_tries;

	TAILQ_ENTRY(necp_session) chain;
};
struct necp_socket_info {
	pid_t pid;
	int32_t pid_version;
	uid_t uid;
	uid_t real_uid;
	union necp_sockaddr_union local_addr;
	union necp_sockaddr_union remote_addr;
	u_int32_t bound_interface_index;
	u_int32_t bound_interface_flags;
	u_int32_t bound_interface_eflags;
	u_int32_t bound_interface_xflags;
	u_int32_t traffic_class;
	u_int16_t protocol;
	u_int16_t scheme_port;
	u_int32_t application_id;
	u_int32_t real_application_id;
	u_int32_t account_id;
	u_int32_t drop_order;
	u_int32_t client_flags;
	char *domain __null_terminated;
	char *url __null_terminated;
	struct soflow_hash_entry *soflow_entry;
	unsigned is_entitled : 1;
	unsigned has_client : 1;
	unsigned has_system_signed_result : 1;
	unsigned is_platform_binary : 1;
	unsigned used_responsible_pid : 1;
	unsigned is_loopback : 1;
	unsigned real_is_platform_binary : 1;
	unsigned is_delegated : 1;
	unsigned is_local : 1;
	unsigned __pad_bits : 7;
};
struct necp_uuid_id_mapping {
	LIST_ENTRY(necp_uuid_id_mapping) chain;
	uuid_t          uuid;
	u_int32_t       id;
	os_refcnt_t     refcount;
	u_int32_t       table_usecount; 
};
struct necp_string_id_mapping {
	LIST_ENTRY(necp_string_id_mapping) chain;
	char            *string __null_terminated;
	necp_app_id     id;
	os_refcnt_t     refcount;
};
struct necp_route_rule {
	LIST_ENTRY(necp_route_rule) chain;
	u_int32_t       id;
	u_int32_t       netagent_id;
	u_int32_t       control_unit;
	u_int32_t       match_netagent_id;
	u_int32_t       effective_type;
	u_int8_t        default_action;
	u_int8_t        cellular_action;
	u_int8_t        wifi_action;
	u_int8_t        wired_action;
	u_int8_t        expensive_action;
	u_int8_t        constrained_action;
	u_int8_t        companion_action;
	u_int8_t        vpn_action;
	u_int           exception_if_indices[MAX_ROUTE_RULE_INTERFACES];
	u_int8_t        exception_if_actions[MAX_ROUTE_RULE_INTERFACES];
	os_refcnt_t     refcount;
};
struct necp_aggregate_route_rule {
	LIST_ENTRY(necp_aggregate_route_rule) chain;
	u_int32_t       id;
	u_int32_t       rule_ids[MAX_AGGREGATE_ROUTE_RULES];
};
struct necp_resolver_key_state {
	const struct ccdigest_info *digest_info;
	uint8_t key[CCSHA256_OUTPUT_SIZE];
};
struct necp_application_id_key_state {
	const struct ccdigest_info *digest_info;
	uint8_t key[CCSHA256_OUTPUT_SIZE];
};
struct necp_policy_result_ip_tunnel {
	u_int32_t secondary_result;
	char interface_name[IFXNAMSIZ];
} __attribute__((__packed__));
struct necp_policy_result_service {
	uuid_t identifier;
	u_int32_t data;
} __attribute__((__packed__));
struct substring {
	size_t length;
	char * __sized_by(length) string;
};
struct necp_packet_header {
	u_int8_t            packet_type;
	u_int8_t                flags;
	u_int32_t           message_id;
};
struct {
	uid_t               uid;
	uuid_t              effective_uuid;
	uid_t               persona_id;
} necp_application_id_t;
struct necp_domain_trie_request {
	uint32_t id;
	uint32_t total_mem_size;
	uint32_t nodes_mem_size;
	uint32_t maps_mem_size;
	uint32_t bytes_mem_size;
	uint32_t nodes_count;
	uint32_t maps_count;
	uint32_t bytes_count;
	uint32_t partial_match_terminator;
	uint32_t flags;
	uint8_t  data[__counted_by(total_mem_size)];
} necp_domain_trie_request_t;
struct necp_policy_condition_tc_range {
	u_int32_t start_tc;
	u_int32_t end_tc;
} __attribute__((__packed__));
struct necp_policy_condition_addr {
	u_int8_t                prefix;
	union {
		struct sockaddr                 sa;
		struct sockaddr_in              sin;
		struct sockaddr_in6             sin6;
	} address __attribute__((__packed__));
} __attribute__((__packed__));
struct necp_policy_condition_addr_range {
	union {
		struct sockaddr                 sa;
		struct sockaddr_in              sin;
		struct sockaddr_in6             sin6;
	} start_address __attribute__((__packed__));
	union {
		struct sockaddr                 sa;
		struct sockaddr_in              sin;
		struct sockaddr_in6             sin6;
	} end_address __attribute__((__packed__));
} __attribute__((__packed__));
struct necp_policy_condition_agent_type {
	char agent_domain[32];
	char agent_type[32];
} __attribute__((__packed__));
struct necp_policy_condition_sdk_version {
	uint32_t platform; 
	uint32_t min_version; 
	uint32_t version; 
} __attribute__((__packed__));
struct necp_aggregate_result {
	necp_kernel_policy_result                       routing_result;
	necp_kernel_policy_routing_result_parameter     routing_result_parameter;
	necp_kernel_policy_filter                       filter_control_unit;
	u_int32_t                                       flow_divert_aggregate_unit;
	necp_kernel_policy_result                       service_action;
	uuid_t                                                          service_uuid;
	u_int32_t                                                       service_flags;
	u_int32_t                                                       service_data;
	u_int                                                           routed_interface_index;
	u_int32_t                                                       policy_id;
	u_int32_t                                                       skip_policy_id;
	uuid_t                                                          netagents[NECP_MAX_NETAGENTS];
	u_int32_t                                                       netagent_use_flags[NECP_MAX_NETAGENTS];
	struct ipv6_prefix                                              nat64_prefixes[NAT64_MAX_NUM_PREFIXES];
	u_int8_t                                                        mss_recommended;
};
struct necp_stat_counts {
	u_int64_t       necp_stat_rxpackets             __attribute__((aligned(8)));
	u_int64_t       necp_stat_rxbytes               __attribute__((aligned(8)));
	u_int64_t       necp_stat_txpackets             __attribute__((aligned(8)));
	u_int64_t       necp_stat_txbytes               __attribute__((aligned(8)));

	u_int32_t       necp_stat_rxduplicatebytes;
	u_int32_t       necp_stat_rxoutoforderbytes;
	u_int32_t       necp_stat_txretransmit;

	u_int32_t       necp_stat_connectattempts;
	u_int32_t       necp_stat_connectsuccesses;

	u_int32_t       necp_stat_min_rtt;
	u_int32_t       necp_stat_avg_rtt;
	u_int32_t       necp_stat_var_rtt;

	u_int32_t       necp_stat_route_flags;
};
struct necp_basic_metadata {
	u_int32_t       rcvbufsize;
	u_int32_t       rcvbufused;
};
struct necp_connection_probe_status {
	unsigned int    probe_activated : 1;
	unsigned int    write_probe_failed : 1;
	unsigned int    read_probe_failed : 1;
	unsigned int    conn_probe_failed : 1;
};
struct necp_extra_tcp_metadata {
	struct necp_connection_probe_status probestatus;

	u_int32_t       sndbufsize;
	u_int32_t       sndbufused;
	u_int32_t       txunacked;
	u_int32_t       txwindow;
	u_int32_t       txcwindow;
	u_int32_t       flags;                  
	u_int32_t       flags1;                 
	u_int32_t       traffic_mgt_flags;
	u_int32_t       cc_alg_index;
	u_int32_t       state;
};
struct necp_stats_hdr {
	u_int32_t                                       necp_stats_type __attribute__((aligned(8)));
	u_int32_t                                       necp_stats_ver;
	u_int64_t                                       __necp_stats_reserved; 
};
struct necp_tcp_stats {
	struct necp_stats_hdr                   necp_tcp_hdr;
	struct necp_stat_counts                 necp_tcp_counts;
	struct necp_basic_metadata              necp_tcp_basic;
	struct necp_extra_tcp_metadata  necp_tcp_extra;
};
struct necp_udp_stats {
	struct necp_stats_hdr           necp_udp_hdr;
	struct necp_stat_counts         necp_udp_counts;
	struct necp_basic_metadata      necp_udp_basic;
};
struct necp_extra_quic_metadata {
	u_int32_t       sndbufsize;
	u_int32_t       sndbufused;
	u_int32_t       txunacked;
	u_int32_t       txwindow;
	u_int32_t       txcwindow;
	u_int32_t       traffic_mgt_flags;
	u_int32_t       cc_alg_index;
	u_int32_t       state;
	u_int8_t        ssr_token[QUIC_STATELESS_RESET_TOKEN_SIZE];
	struct necp_connection_probe_status probestatus;
};
struct necp_quic_stats {
	struct necp_udp_stats           necp_quic_udp_stats;
	struct necp_extra_quic_metadata necp_quic_extra;
};
struct necp_all_stats {
	union {
		struct necp_tcp_stats   tcp_stats;
		struct necp_udp_stats   udp_stats;
		struct necp_quic_stats  quic_stats;
	} all_stats_u;
} necp_all_stats;
struct necp_stats_bufreq {
	u_int32_t                                       necp_stats_bufreq_id __attribute__((aligned(8)));
	u_int32_t                                       necp_stats_bufreq_type;         
	u_int32_t                                       necp_stats_bufreq_ver;          
	u_int32_t                                       necp_stats_bufreq_size;
	union {
		void                                    *necp_stats_bufreq_addr;
		mach_vm_address_t               necp_stats_bufreq_uaddr;
	};
};
struct necp_tcp_ecn_cache {
	u_int8_t                necp_tcp_ecn_heuristics_success:1;
	u_int8_t                necp_tcp_ecn_heuristics_loss:1;
	u_int8_t                necp_tcp_ecn_heuristics_drop_rst:1;
	u_int8_t                necp_tcp_ecn_heuristics_drop_rxmt:1;
	u_int8_t                necp_tcp_ecn_heuristics_aggressive:1;
	u_int8_t                necp_tcp_ecn_heuristics_syn_rst:1;
} necp_tcp_ecn_cache;
struct necp_tcp_tfo_cache {
	u_int8_t                necp_tcp_tfo_cookie[NECP_TFO_COOKIE_LEN_MAX];
	u_int8_t                necp_tcp_tfo_cookie_len;
	u_int8_t                necp_tcp_tfo_heuristics_success:1; 
	u_int8_t                necp_tcp_tfo_heuristics_loss:1; 
	u_int8_t                necp_tcp_tfo_heuristics_middlebox:1; 
	u_int8_t                necp_tcp_tfo_heuristics_success_req:1; 
	u_int8_t                necp_tcp_tfo_heuristics_loss_req:1; 
	u_int8_t                necp_tcp_tfo_heuristics_rst_data:1; 
	u_int8_t                necp_tcp_tfo_heuristics_rst_req:1; 
} necp_tcp_tfo_cache;
struct necp_cache_buffer {
	u_int8_t                necp_cache_buf_type;    
	u_int8_t                necp_cache_buf_ver;     
	u_int32_t               necp_cache_buf_size;
	mach_vm_address_t       necp_cache_buf_addr;
} necp_cache_buffer;
struct necp_interface_signature {
	u_int8_t signature[IFNET_SIGNATURELEN];
	u_int8_t signature_len;
};
struct necp_interface_details {
	char name[IFXNAMSIZ];
	u_int32_t index;
	u_int32_t generation;
	u_int32_t functional_type;
	u_int32_t delegate_index;
	u_int32_t flags; 
	u_int32_t mtu;
	struct necp_interface_signature ipv4_signature;
	struct necp_interface_signature ipv6_signature;
	u_int32_t ipv4_netmask;
	u_int32_t ipv4_broadcast;
	u_int32_t tso_max_segment_size_v4;
	u_int32_t tso_max_segment_size_v6;
	u_int32_t hwcsum_flags;
	u_int8_t  radio_type;
	u_int8_t  radio_channel;
};
struct necp_client_parameter_netagent_type {
	char netagent_domain[32];
	char netagent_type[32];
};
struct necp_client_result_netagent {
	u_int32_t generation;
	uuid_t netagent_uuid;
};
struct necp_client_result_interface {
	u_int32_t generation;
	u_int32_t index;
};
struct necp_client_result_estimated_throughput {
	u_int8_t up;
	u_int8_t down;
};
struct necp_client_result_agent_error {
	u_int32_t code;
	u_int8_t domain;
};
struct necp_client_interface_option {
	u_int32_t interface_index;
	u_int32_t interface_generation;
	uuid_t nexus_agent;
};
struct necp_client_endpoint {
	union {
		struct sockaddr sa;
		struct sockaddr_in sin;
		struct sockaddr_in6 sin6;
		struct {
			u_int8_t endpoint_length;
			u_int8_t endpoint_family; 
			u_int16_t endpoint_port;
			u_int32_t endpoint_type; 
			char endpoint_data[0]; 
		} endpoint;
	} u;
};
struct necp_client_group {
	u_int32_t group_type;
	uuid_t group_id;
};
struct necp_client_list {
	u_int32_t client_count;
	uuid_t clients[0];
};
struct kev_necp_policies_changed_data {
	u_int32_t               changed_count;  
};
struct necp_client_flow_stats {
	u_int32_t stats_type; 
	u_int32_t stats_version; 
	u_int32_t stats_size;
	mach_vm_address_t stats_addr;
};
struct necp_client_add_flow {
	uuid_t agent_uuid;
	uuid_t registration_id;
	u_int16_t flags; 
	u_int16_t stats_request_count;
	struct necp_client_flow_stats stats_requests[0];
} __attribute__((__packed__));
struct necp_agent_use_parameters {
	uuid_t agent_uuid;
	uint64_t out_use_count;
};
struct necp_client_group_action {
	uuid_t agent_uuid;
	u_int16_t group_member_count;
	struct necp_client_endpoint group_members[0];
} __attribute__((__packed__));
struct necp_client_flow_protoctl_event {
	uint32_t        protoctl_event_code;
	uint32_t        protoctl_event_val;
	uint32_t        protoctl_event_tcp_seq_num;
};
struct necp_client_observer_update {
	u_int32_t update_type;  
	u_int8_t tlv_buffer[0]; 
};
struct necp_client_signature {
	u_int8_t signed_tag[32];
} __attribute__((__packed__));
struct necp_client_signable {
	uuid_t client_id; 
	u_int32_t sign_type;
	u_int8_t signable_data[0];
} __attribute__((__packed__));
struct necp_client_resolver_answer {
	uuid_t client_id;
	u_int32_t sign_type;
	union sockaddr_in_4_6 address_answer; 
	u_int32_t hostname_length;
	char hostname[0];
} __attribute__((__packed__));
struct necp_client_host_resolver_answer {
	struct necp_client_signable header;
	u_int32_t metadata_hash; 
	union sockaddr_in_4_6 address_answer; 
	u_int32_t hostname_length;
	char hostname[0];
} __attribute__((__packed__));
struct necp_client_browse_result {
	struct necp_client_signable header;
	u_int32_t metadata_hash; 
	u_int16_t service_length;
	char service[0];
} __attribute__((__packed__));
struct necp_client_service_resolver_answer {
	struct necp_client_signable header;
	u_int32_t metadata_hash; 
	u_int16_t service_length;
	u_int16_t port;
	u_int16_t hostname_length;
	char service[0];
	char hostname[0];
} __attribute__((__packed__));
struct necp_client_validatable {
	struct necp_client_signature signature;
	struct necp_client_signable signable;
} __attribute__((__packed__));
struct necp_client_signed_client_id_uuid {
	uuid_t client_id;
	u_int32_t signature_length;
	u_int8_t signature_data[NECP_CLIENT_ACTION_SIGN_TAG_LENGTH];
} __attribute__((__packed__));
struct necp_drop_dest_entry {
	u_int32_t                           level;          
	u_int32_t                           order;          
	struct necp_policy_condition_addr   cond_addr;
};
struct necp_drop_dest_policy {
	u_int32_t entry_count;
	struct necp_drop_dest_entry entries[MAX_NECP_DROP_DEST_LEVEL_ADDRS];
};
struct necp_demux_pattern {
	uint16_t offset;
	uint16_t len;
	uint8_t mask[NECP_DEMUX_MAX_LEN];
	uint8_t value[NECP_DEMUX_MAX_LEN];
};
struct necp_all_kstats {
	struct necp_all_stats           necp_stats_comm;        
	struct necp_all_stats           *necp_stats_ustats;     
};
struct necp_tlv_header {
	u_int8_t type;
	u_int32_t length;
} __attribute__((__packed__));
struct {
	u_int32_t identifier;
	u_int32_t data;
} necp_kernel_policy_service;
struct necp_kernel_socket_policy {
	LIST_ENTRY(necp_kernel_socket_policy)   chain;
	necp_kernel_policy_id           id;
	necp_policy_order                       order;
	u_int32_t                                       session_order;
	int                                                     session_pid;

	u_int64_t                                       condition_mask;
	u_int64_t                                       condition_negated_mask;
	u_int32_t                                       cond_client_flags;
	necp_kernel_policy_id           cond_policy_id;
	u_int32_t                                       cond_app_id;                                    
	u_int32_t                                       cond_real_app_id;                               
	char                                            *cond_custom_entitlement __null_terminated;     
	u_int32_t                                       cond_account_id;                                
	char                                            *cond_domain __null_terminated;                 
	u_int8_t                                        cond_domain_dot_count;                  
	u_int32_t                                       cond_domain_filter;
	pid_t                                           cond_pid;
	uid_t                                           cond_uid;
	uid_t                                           cond_real_uid;
	ifnet_t                                         cond_bound_interface;                   
	struct necp_policy_condition_tc_range cond_traffic_class;       
	u_int16_t                                       cond_protocol;                                  
	union necp_sockaddr_union       cond_local_start;                               
	union necp_sockaddr_union       cond_local_end;                                 
	u_int8_t                                        cond_local_prefix;                              
	union necp_sockaddr_union       cond_remote_start;                              
	union necp_sockaddr_union       cond_remote_end;                                
	u_int8_t                                        cond_remote_prefix;                             
	struct necp_policy_condition_agent_type cond_agent_type;
	struct necp_policy_condition_sdk_version cond_sdk_version;
	char                                            *cond_signing_identifier __null_terminated;   
	char                                            *cond_url __null_terminated;
	u_int16_t                                       cond_packet_filter_tags;
	u_int16_t                                       cond_scheme_port;
	int32_t                                         cond_pid_version;
	u_int32_t                                       cond_bound_interface_flags;
	u_int32_t                                       cond_bound_interface_eflags;
	u_int32_t                                       cond_bound_interface_xflags;
	u_int8_t                                        cond_local_networks_flags;

	necp_kernel_policy_result       result;
	necp_kernel_policy_result_parameter     result_parameter;
};
struct necp_kernel_ip_output_policy {
	LIST_ENTRY(necp_kernel_ip_output_policy)        chain;
	necp_kernel_policy_id           id;
	necp_policy_order                       suborder;
	necp_policy_order                       order;
	u_int32_t                                       session_order;
	int                                                     session_pid;

	u_int64_t                                       condition_mask;
	u_int64_t                                       condition_negated_mask;
	necp_kernel_policy_id           cond_policy_id;
	ifnet_t                                         cond_bound_interface;                   
	u_int16_t                                       cond_protocol;                                  
	union necp_sockaddr_union       cond_local_start;                               
	union necp_sockaddr_union       cond_local_end;                                 
	u_int8_t                                        cond_local_prefix;                              
	union necp_sockaddr_union       cond_remote_start;                              
	union necp_sockaddr_union       cond_remote_end;                                
	u_int8_t                                        cond_remote_prefix;                             
	u_int32_t                                       cond_last_interface_index;
	u_int16_t                       cond_packet_filter_tags;
	u_int16_t                       cond_scheme_port;
	u_int32_t                                       cond_bound_interface_flags;
	u_int32_t                                       cond_bound_interface_eflags;
	u_int32_t                                       cond_bound_interface_xflags;
	u_int8_t                                        cond_local_networks_flags;

	necp_kernel_policy_result       result;
	necp_kernel_policy_result_parameter     result_parameter;
};
struct necp_session_policy {
	LIST_ENTRY(necp_session_policy) chain;
	bool                            applied;                        
	bool                            pending_deletion;       
	bool                            pending_update;         
	necp_policy_id          local_id;
	necp_policy_order       order;
	u_int32_t                       result_size;
	u_int8_t                        *result __sized_by(result_size);
	u_int32_t                       conditions_size;
	u_int8_t                        *conditions __sized_by(conditions_size); 
	u_int32_t                       route_rules_size;
	u_int8_t                        *route_rules __sized_by(route_rules_size); 

	uuid_t                          applied_app_uuid;
	uuid_t                          applied_real_app_uuid;
	u_int32_t                       applied_account_size;
	char                            *applied_account __sized_by(applied_account_size);

	uuid_t                          applied_result_uuid;

	u_int32_t                       applied_route_rules_id;

	necp_kernel_policy_id   kernel_socket_policies[MAX_KERNEL_SOCKET_POLICIES];
	necp_kernel_policy_id   kernel_ip_output_policies[MAX_KERNEL_IP_OUTPUT_POLICIES];
};
struct necp_aggregate_socket_result {
	necp_kernel_policy_result                       result;
	necp_kernel_policy_result_parameter     result_parameter;
	necp_kernel_policy_filter                       filter_control_unit;
	u_int32_t                                       flow_divert_aggregate_unit;
	u_int32_t                                                       route_rule_id;
	int32_t                                         qos_marking_gencount;
};
struct necp_inpcb_result {
	u_int32_t                                       app_id;
	necp_kernel_policy_id                           policy_id;
	necp_kernel_policy_id                           skip_policy_id;
	int32_t                                         policy_gencount;
	u_int32_t                                       flowhash;
	u_int32_t                                       network_denied_notifies;
	struct necp_aggregate_socket_result             results;
};
struct necp_client_nexus_parameters {
	pid_t pid;
	pid_t epid;
	uuid_t euuid;
	union necp_sockaddr_union local_addr;
	union necp_sockaddr_union remote_addr;
	u_int8_t ip_protocol;
	u_int8_t transport_protocol;
	u_int16_t ethertype;
	u_int32_t traffic_class;
	necp_policy_id policy_id;
	necp_policy_id skip_policy_id;
	unsigned is_listener:1;
	unsigned is_interpose:1;
	unsigned is_custom_ether:1;
	unsigned allow_qos_marking:1;
	unsigned override_address_selection:1;
	unsigned use_stable_address:1; 
	unsigned no_wake_from_sleep:1;
	unsigned is_demuxable_parent:1;
	unsigned reuse_port:1;

	uuid_t parent_flow_uuid;
	struct necp_demux_pattern demux_patterns[NECP_MAX_DEMUX_PATTERNS];
	uint8_t demux_pattern_count;
};
struct necp_client_group_members {
	size_t group_members_length;
	u_int8_t *group_members __sized_by(group_members_length);
};
struct necp_client_error_parameters {
	int32_t error;
	bool force_report;
};
struct necp_client_agent_parameters {
	union {
		struct necp_client_nexus_parameters nexus_request;
		u_int8_t close_token[QUIC_STATELESS_RESET_TOKEN_SIZE];
		struct necp_client_group_members group_members;
		struct necp_client_error_parameters error;
	} u;
};
struct necp_client_add_flow_default {
	uuid_t agent_uuid;
	uuid_t registration_id;
	u_int16_t flags; 
	u_int16_t stats_request_count;
	struct necp_client_flow_stats stats_requests[1];
} __attribute__((__packed__));
struct necp_client_parsed_parameters {
	u_int32_t valid_fields;
	u_int32_t flags;
	u_int64_t delegated_upid;
	union necp_sockaddr_union local_addr;
	union necp_sockaddr_union remote_addr;
	u_int32_t required_interface_index;
	char prohibited_interfaces[NECP_MAX_INTERFACE_PARAMETERS][IFXNAMSIZ];
	u_int8_t required_interface_type;
	u_int8_t local_address_preference;
	u_int8_t prohibited_interface_types[NECP_MAX_INTERFACE_PARAMETERS];
	struct necp_client_parameter_netagent_type required_netagent_types[NECP_MAX_AGENT_PARAMETERS];
	struct necp_client_parameter_netagent_type prohibited_netagent_types[NECP_MAX_AGENT_PARAMETERS];
	struct necp_client_parameter_netagent_type preferred_netagent_types[NECP_MAX_AGENT_PARAMETERS];
	struct necp_client_parameter_netagent_type avoided_netagent_types[NECP_MAX_AGENT_PARAMETERS];
	uuid_t required_netagents[NECP_MAX_AGENT_PARAMETERS];
	uuid_t prohibited_netagents[NECP_MAX_AGENT_PARAMETERS];
	uuid_t preferred_netagents[NECP_MAX_AGENT_PARAMETERS];
	uuid_t avoided_netagents[NECP_MAX_AGENT_PARAMETERS];
	u_int8_t ip_protocol;
	u_int8_t transport_protocol;
	u_int16_t ethertype;
	pid_t effective_pid;
	uuid_t effective_uuid;
	uuid_t parent_uuid;
	u_int32_t traffic_class;
	struct necp_demux_pattern demux_patterns[NECP_MAX_DEMUX_PATTERNS];
	u_int8_t demux_pattern_count;
	uid_t uid;
	uid_t persona_id;
};
struct necp_client_assertion {
	LIST_ENTRY(necp_client_assertion) assertion_chain;
	uuid_t asserted_netagent;
};
struct necp_client_flow_header {
	struct necp_tlv_header outer_header;
	struct necp_tlv_header flow_id_tlv_header;
	uuid_t flow_id;
	struct necp_tlv_header flags_tlv_header;
	u_int32_t flags_value;
	struct necp_tlv_header interface_tlv_header;
	struct necp_client_result_interface interface_value;
} __attribute__((__packed__));
struct necp_client_flow_protoctl_event_header {
	struct necp_tlv_header protoctl_tlv_header;
	struct necp_client_flow_protoctl_event protoctl_event;
} __attribute__((__packed__));
struct necp_client_nexus_flow_header {
	struct necp_client_flow_header flow_header;
	struct necp_tlv_header agent_tlv_header;
	struct necp_client_result_netagent agent_value;
	struct necp_tlv_header tfo_cookie_tlv_header;
	u_int8_t tfo_cookie_value[NECP_TFO_COOKIE_LEN_MAX];
} __attribute__((__packed__));
struct necp_client_flow {
	LIST_ENTRY(necp_client_flow) flow_chain;
	unsigned invalid : 1;
	unsigned nexus : 1; 
	unsigned socket : 1;
	unsigned viable : 1;
	unsigned assigned : 1;
	unsigned has_protoctl_event : 1;
	unsigned check_tcp_heuristics : 1;
	unsigned _reserved : 1;
	union {
		uuid_t nexus_agent;
		struct {
			void *socket_handle;
			necp_client_flow_cb cb;
		};
	} u;
	uint32_t interface_index;
	u_short  delegated_interface_index;
	uint32_t interface_flags;
	uint32_t necp_flow_flags;
	struct necp_client_flow_protoctl_event protoctl_event;
	union necp_sockaddr_union local_addr;
	union necp_sockaddr_union remote_addr;

	size_t assigned_results_length;
	u_int8_t *__counted_by(assigned_results_length) assigned_results;
};
struct necp_client_flow_registration {
	RB_ENTRY(necp_client_flow_registration) fd_link;
	RB_ENTRY(necp_client_flow_registration) global_link;
	RB_ENTRY(necp_client_flow_registration) client_link;
	LIST_ENTRY(necp_client_flow_registration) collect_stats_chain;
	uuid_t registration_id;
	u_int32_t flags;
	unsigned flow_result_read : 1;
	unsigned defunct : 1;
	void *interface_handle;
	necp_client_flow_cb interface_cb;
	struct necp_client *client;
	LIST_HEAD(_necp_registration_flow_list, necp_client_flow) flow_list;
	u_int64_t last_interface_details __attribute__((aligned(sizeof(u_int64_t))));
};
struct necp_client {
	RB_ENTRY(necp_client) link;
	RB_ENTRY(necp_client) global_link;

	decl_lck_mtx_data(, lock);
	decl_lck_mtx_data(, route_lock);
	os_refcnt_t reference_count;

	uuid_t client_id;
	unsigned result_read : 1;
	unsigned group_members_read : 1;
	unsigned allow_multiple_flows : 1;
	unsigned legacy_client_is_flow : 1;

	unsigned platform_binary : 1;
	unsigned validated_parent : 1;

	size_t result_length;
	u_int8_t result[NECP_BASE_CLIENT_RESULT_SIZE];

	necp_policy_id policy_id;
	necp_policy_id skip_policy_id;

	u_int8_t ip_protocol;
	int proc_pid;

	u_int64_t delegated_upid;

	struct _necp_client_flow_tree flow_registrations;
	LIST_HEAD(_necp_client_assertion_list, necp_client_assertion) assertion_list;

	size_t assigned_group_members_length;
	u_int8_t *__counted_by(assigned_group_members_length) assigned_group_members;

	struct rtentry *current_route;

	struct necp_client_interface_option interface_options[NECP_CLIENT_INTERFACE_OPTION_STATIC_COUNT];
	struct necp_client_interface_option * __indexable extra_interface_options;
	u_int8_t interface_option_count; 

	struct necp_client_result_netagent failed_trigger_agent;

	void *agent_handle;

	uuid_t override_euuid;


	size_t parameters_length;
	u_int8_t * __sized_by(parameters_length) parameters;
};
struct necp_flow_defunct {
	LIST_ENTRY(necp_flow_defunct) chain;

	uuid_t flow_id;
	uuid_t nexus_agent;
	void *agent_handle;
	int proc_pid;
	u_int32_t flags;
	struct necp_client_agent_parameters close_parameters;
	bool has_close_parameters;
};
struct necp_client_update {
	TAILQ_ENTRY(necp_client_update) chain;

	uuid_t client_id;

	size_t update_length;
	struct necp_client_observer_update *__sized_by(update_length) update;
};
struct necp_fd_reported_agents {
	uuid_t agent_uuid[NECP_FD_REPORTED_AGENT_COUNT];
};
struct necp_fd_data {
	u_int8_t necp_fd_type;
	LIST_ENTRY(necp_fd_data) chain;
	struct _necp_client_tree clients;
	struct _necp_fd_flow_tree flows;
	TAILQ_HEAD(_necp_client_update_list, necp_client_update) update_list;
	int update_count;
	int flags;

	unsigned background : 1;
	unsigned request_in_process_flow_divert : 1;

	int proc_pid;
	decl_lck_mtx_data(, fd_lock);
	struct selinfo si;

	struct necp_fd_reported_agents reported_agents;
};
struct necp_client_signable_default {
	uuid_t client_id;
	u_int32_t sign_type;
	u_int8_t signable_data[NECP_CLIENT_ACTION_SIGN_DEFAULT_DATA_LENGTH];
} __attribute__((__packed__));
struct necp_client_validatable_default {
	struct necp_client_signature signature;
	struct necp_client_signable_default signable;
} __attribute__((__packed__));
struct netsrc_req {
	unsigned int nrq_ver;
	unsigned int nrq_ifscope;
	union {
		union sockaddr_in_4_6 nrq_dst;
		union sockaddr_in_4_6 _usa;
	};
};
struct netsrc_repv1 {
	union {
		union sockaddr_in_4_6 nrp_src;
		union sockaddr_in_4_6 _usa;
	};
	uint16_t nrp_flags;
	uint16_t nrp_label;
	uint16_t nrp_precedence;
	uint16_t nrp_dstlabel;
	uint16_t nrp_dstprecedence;
	uint16_t nrp_unused;    
};
struct netsrc_repv2 {
	union {
		union sockaddr_in_4_6 nrp_src;
		union sockaddr_in_4_6 _usa;
	};
	uint32_t nrp_min_rtt;
	uint32_t nrp_connection_attempts;
	uint32_t nrp_connection_successes;
	uint32_t nrp_flags;
	uint16_t nrp_label;
	uint16_t nrp_precedence;
	uint16_t nrp_dstlabel;
	uint16_t nrp_dstprecedence;
	uint16_t nrp_ifindex;
	uint16_t nrp_unused; 
};
struct netagent_client {
	LIST_ENTRY(netagent_client) client_chain;
	uuid_t client_id;
	uuid_t client_proc_uuid;
	pid_t client_pid;
};
struct netagent_token {
	TAILQ_ENTRY(netagent_token) token_chain;
	u_int32_t token_length;
	u_int8_t *  __indexable token_bytes;
};
struct netagent_registration {
	LIST_ENTRY(netagent_registration) global_chain;
	TAILQ_ENTRY(netagent_registration) session_chain;
	lck_rw_t agent_lock;
	u_int32_t control_unit;
	netagent_event_f event_handler;
	void *event_context;
	u_int32_t generation;
	u_int64_t use_count;
	u_int64_t need_tokens_event_deadline;
	u_int32_t token_count;
	u_int32_t token_low_water;
	int32_t last_client_error;
	u_int32_t client_error_count;
	u_int8_t allow_multiple_registrations;
	u_int8_t __pad_bytes[2];
	struct netagent_token_list_s token_list;
	struct netagent_client_list_s pending_triggers_list;
	size_t netagent_alloc_size;
	struct netagent *netagent __sized_by(netagent_alloc_size);
};
struct netagent_session {
	u_int32_t control_unit; 
	lck_mtx_t session_lock;
	TAILQ_HEAD(_netagent_registration_list, netagent_registration) registrations;

	netagent_event_f event_handler;
	void *event_context;
	bool allow_multiple_registrations;
};
struct netagent_message_header {
	u_int8_t                message_type;
	u_int8_t                message_flags;
	u_int32_t               message_id;
	u_int32_t               message_error;
	u_int32_t               message_payload_length;
};
struct netagent_session_message_header {
	u_int8_t                message_type;
	u_int8_t                message_flags;
	u_int32_t               message_id;
	u_int32_t               message_error;
	uuid_t                  message_agent_id;
	u_int32_t               message_payload_length;
};
struct netagent_trigger_message {
	u_int32_t               trigger_flags;
	pid_t                   trigger_pid;
	uuid_t                  trigger_proc_uuid;
};
struct netagent_client_message {
	uuid_t                  client_id;
};
struct netagent_client_error_message {
	uuid_t                  client_id;
	int32_t                 error_code;
};
struct netagent_client_group_message {
	uuid_t                  client_id;
	u_int8_t                group_members[0];
};
struct netagent_assign_nexus_message {
	uuid_t                  assign_client_id;
	u_int8_t                assign_necp_results[0];
};
struct netagent_session_assign_nexus_message {
	uuid_t                  agent_id;
	uuid_t                  assign_client_id;
	u_int8_t                assign_necp_results[0];
};
struct netagent_nexus {
	u_int32_t       frame_type;
	u_int32_t       endpoint_assignment_type;
	u_int32_t       endpoint_request_types[NETAGENT_NEXUS_MAX_REQUEST_TYPES];
	u_int32_t       endpoint_resolution_type_pairs[NETAGENT_NEXUS_MAX_RESOLUTION_TYPE_PAIRS * 2];
	u_int32_t       nexus_max_buf_size;
	u_int32_t       reserved;
	u_int32_t       nexus_flags;
};
struct kev_netagent_data {
	uuid_t          netagent_uuid;
};
struct netagent {
	uuid_t          netagent_uuid;
	char            netagent_domain[NETAGENT_DOMAINSIZE];
	char            netagent_type[NETAGENT_TYPESIZE];
	char            netagent_desc[NETAGENT_DESCSIZE];
	u_int32_t       netagent_flags;
	u_int32_t       netagent_data_size;
	u_int8_t        netagent_data[0];
};
struct netagent_req {
	uuid_t          netagent_uuid;
	char            netagent_domain[NETAGENT_DOMAINSIZE];
	char            netagent_type[NETAGENT_TYPESIZE];
	char            netagent_desc[NETAGENT_DESCSIZE];
	u_int32_t       netagent_flags;
	u_int32_t       netagent_data_size;
	u_int8_t        *netagent_data;
};
struct netagentlist_req {
	u_int32_t       data_size;
	u_int8_t        *data;
};
struct netagent_req32 {
	uuid_t          netagent_uuid;
	char            netagent_domain[NETAGENT_DOMAINSIZE];
	char            netagent_type[NETAGENT_TYPESIZE];
	char            netagent_desc[NETAGENT_DESCSIZE];
	u_int32_t       netagent_flags;
	u_int32_t       netagent_data_size;
	user32_addr_t   netagent_data;
};
struct netagent_req64 {
	uuid_t          netagent_uuid;
	char            netagent_domain[NETAGENT_DOMAINSIZE];
	char            netagent_type[NETAGENT_TYPESIZE];
	char            netagent_desc[NETAGENT_DESCSIZE];
	u_int32_t       netagent_flags;
	u_int32_t       netagent_data_size;
	user64_addr_t   netagent_data __attribute__((aligned(8)));
};
struct netagentlist_req32 {
	u_int32_t       data_size;
	user32_addr_t   data;
};
struct netagentlist_req64 {
	u_int32_t       data_size;
	user64_addr_t   data __attribute__((aligned(8)));
};
struct netagent_nexus_agent {
	struct netagent                         agent;
	struct netagent_nexus           nexus_data;
};
struct net_api_stats {
	int64_t nas_iflt_attach_count;  
	int64_t nas_iflt_attach_os_count;
	int64_t nas_iflt_attach_total;  
	int64_t nas_iflt_attach_os_total;

	int64_t nas_ipf_add_count;      
	int64_t nas_ipf_add_os_count;
	int64_t nas_ipf_add_total;      
	int64_t nas_ipf_add_os_total;

	int64_t nas_sfltr_register_count;       
	int64_t nas_sfltr_register_os_count;
	int64_t nas_sfltr_register_total;       
	int64_t nas_sfltr_register_os_total;

	int64_t nas_socket_alloc_total;
	int64_t nas_socket_in_kernel_total;
	int64_t nas_socket_in_kernel_os_total;
	int64_t nas_socket_necp_clientuuid_total;

	int64_t nas_socket_domain_local_total;
	int64_t nas_socket_domain_route_total;
	int64_t nas_socket_domain_inet_total;
	int64_t nas_socket_domain_inet6_total;
	int64_t nas_socket_domain_system_total;
	int64_t nas_socket_domain_multipath_total;
	int64_t nas_socket_domain_key_total;
	int64_t nas_socket_domain_ndrv_total;
	int64_t nas_socket_domain_other_total;

	int64_t nas_socket_inet_stream_total;
	int64_t nas_socket_inet_dgram_total;
	int64_t nas_socket_inet_dgram_connected;
	int64_t nas_socket_inet_dgram_dns;      
	int64_t nas_socket_inet_dgram_no_data;  

	int64_t nas_socket_inet6_stream_total;
	int64_t nas_socket_inet6_dgram_total;
	int64_t nas_socket_inet6_dgram_connected;
	int64_t nas_socket_inet6_dgram_dns;     
	int64_t nas_socket_inet6_dgram_no_data; 

	int64_t nas_socket_mcast_join_total;
	int64_t nas_socket_mcast_join_os_total;

	int64_t nas_sock_inet6_stream_exthdr_in;
	int64_t nas_sock_inet6_stream_exthdr_out;
	int64_t nas_sock_inet6_dgram_exthdr_in;
	int64_t nas_sock_inet6_dgram_exthdr_out;

	int64_t nas_nx_flow_inet_stream_total;
	int64_t nas_nx_flow_inet_dgram_total;

	int64_t nas_nx_flow_inet6_stream_total;
	int64_t nas_nx_flow_inet6_dgram_total;

	int64_t nas_ifnet_alloc_count;
	int64_t nas_ifnet_alloc_total;
	int64_t nas_ifnet_alloc_os_count;
	int64_t nas_ifnet_alloc_os_total;

	int64_t nas_pf_addrule_total;
	int64_t nas_pf_addrule_os;

	int64_t nas_vmnet_total;
};
struct net_perf {
	uint64_t np_total_pkts; 
	uint64_t np_total_usecs;        
	uint64_t np_hist1;              
	uint64_t np_hist2;              
	uint64_t np_hist3;              
	uint64_t np_hist4;              
	uint64_t np_hist5;              
	uint8_t np_hist_bars[NET_PERF_BARS];
} net_perf_t;
struct net_str_id_entry {
	SLIST_ENTRY(net_str_id_entry) nsi_next;
	uint32_t nsi_flags;
	uint32_t nsi_id;
	uint32_t nsi_length;
	char nsi_string[__counted_by(nsi_length)];
};
struct net_thread_marks { };
struct nstat_procdetails {
	tailq_entry_procdetails         pdet_link;
	int                             pdet_pid;
	u_int64_t                       pdet_upid;
	char                            pdet_procname[64];
	uuid_t                          pdet_uuid;
	u_int32_t                       pdet_refcnt;
	u_int32_t                       pdet_magic;
};
struct nstat_provider_filter {
	u_int64_t                       npf_flags;
	u_int64_t                       npf_events;
	u_int64_t                       npf_extensions;
	pid_t                           npf_pid;
	uuid_t                          npf_uuid;
} nstat_provider_filter;
struct nstat_global_counts {
	uint64_t nstat_global_client_current;   
	uint64_t nstat_global_client_max;       
	uint64_t nstat_global_client_allocs;    

	uint64_t nstat_global_src_current;      
	uint64_t nstat_global_src_max;          
	uint64_t nstat_global_src_allocs;       
	uint64_t nstat_global_src_idlecheck_gone;

	uint64_t nstat_global_tucookie_current; 
	uint64_t nstat_global_tucookie_max;     
	uint64_t nstat_global_tucookie_allocs;  
	uint64_t nstat_global_tucookie_skip_dead; 
	uint64_t nstat_global_tucookie_skip_stopusing; 
	uint64_t nstat_global_tucookie_alloc_fail;     

	uint64_t nstat_global_tu_shad_current;  
	uint64_t nstat_global_tu_shad_max;      
	uint64_t nstat_global_tu_shad_allocs;   

	uint64_t nstat_global_gshad_current;    
	uint64_t nstat_global_gshad_max;        
	uint64_t nstat_global_gshad_allocs;     

	uint64_t nstat_global_procdetails_current;
	uint64_t nstat_global_procdetails_max;   
	uint64_t nstat_global_procdetails_allocs;
};
struct nstat_metrics {
	uint32_t nstat_src_current;             
	uint32_t nstat_src_max;                 
	uint32_t nstat_first_uint32_count;      
	                                        

	uint32_t nstat_query_request_all;       
	uint32_t nstat_query_request_one;       
	uint32_t nstat_query_description_all;   
	uint32_t nstat_query_description_one;   
	uint32_t nstat_query_update_all;        
	uint32_t nstat_query_update_one;        
	uint32_t nstat_remove_src_found;        
	uint32_t nstat_remove_src_missed;       

	uint32_t nstat_query_request_nobuf;     
	uint32_t nstat_query_request_upgrade;   
	uint32_t nstat_query_request_noupgrade; 
	uint32_t nstat_query_request_nodesc;    
	uint32_t nstat_query_request_yield;     
	uint32_t nstat_query_request_limit;     

	uint32_t nstat_query_description_nobuf; 
	uint32_t nstat_query_description_yield; 
	uint32_t nstat_query_description_limit; 

	uint32_t nstat_query_update_nobuf;      
	uint32_t nstat_query_update_upgrade;    
	uint32_t nstat_query_update_noupgrade;  
	uint32_t nstat_query_update_nodesc;     
	uint32_t nstat_query_update_yield;      
	uint32_t nstat_query_update_limit;      

	uint32_t nstat_src_add_success;         
	uint32_t nstat_src_add_no_buf;          
	uint32_t nstat_src_add_no_src_mem;      
	uint32_t nstat_src_add_send_err;        
	uint32_t nstat_src_add_while_cleanup;   

	uint32_t nstat_src_gone_idlecheck;      

	uint32_t nstat_last_uint32_count;       
	uint32_t nstat_stats_pad;
};
struct nstat_trace_entry {
	u_int32_t                       nte_seqno;
	u_int32_t                       nte_event;
	u_int64_t                       nte_qualifier;
} nstat_trace_entry;
struct nstat_cyclic_trace {
	uint32_t            ntt_next_trace_id;
	int32_t             ntt_pad;
	nstat_trace_entry   ntt_entry[NSTAT_TRACE_ENTRIES_PER_CLIENT];
} nstat_cyclic_trace;
struct nstat_client {
	struct nstat_client      *ntc_next;
	u_int32_t               ntc_watching;
	u_int32_t               ntc_added_src;
	decl_lck_mtx_data(, ntc_user_mtx);      
	kern_ctl_ref            ntc_kctl;
	u_int32_t               ntc_unit;
	nstat_src_ref_t         ntc_next_srcref;
	tailq_head_nstat_src    ntc_src_queue;
	mbuf_t                  ntc_accumulated;
	u_int32_t               ntc_flags;
	nstat_provider_filter   ntc_provider_filters[NSTAT_PROVIDER_COUNT];
	u_int64_t               ntc_context;
	u_int64_t               ntc_seq;
	struct nstat_procdetails *ntc_procdetails;
	struct nstat_metrics    ntc_metrics;
	nstat_cyclic_trace      *ntc_trace;
} nstat_client;
struct nstat_provider {
	struct nstat_provider   *next;
	nstat_provider_id_t     nstat_provider_id;
	size_t                  nstat_descriptor_length;
	errno_t                 (*nstat_lookup)(const void *__sized_by (length)data, u_int32_t length, nstat_provider_cookie_t *out_cookie);
	int                     (*nstat_gone)(nstat_provider_cookie_t cookie);
	errno_t                 (*nstat_counts)(nstat_provider_cookie_t cookie, struct nstat_counts *out_counts, int *out_gone);
	errno_t                 (*nstat_watcher_add)(nstat_client *client, nstat_msg_add_all_srcs *req);
	void                    (*nstat_watcher_remove)(nstat_client *client);
	errno_t                 (*nstat_copy_descriptor)(nstat_provider_cookie_t cookie, void *__sized_by (len)data, size_t len);
	void                    (*nstat_release)(nstat_provider_cookie_t cookie, boolean_t locked);
	bool                    (*nstat_reporting_allowed)(nstat_provider_cookie_t cookie, nstat_provider_filter *filter, u_int64_t suppression_flags);
	bool                    (*nstat_cookie_equal)(nstat_provider_cookie_t cookie1, nstat_provider_cookie_t cookie2);
	size_t                  (*nstat_copy_extension)(nstat_provider_cookie_t cookie, u_int32_t extension_id, void *buf, size_t len);
} nstat_provider;
struct nstat_src {
	tailq_entry_nstat_src   nts_client_link;    
	nstat_client            *nts_client;        
	nstat_src_ref_t         nts_srcref;         
	nstat_provider          *nts_provider;      
	nstat_provider_cookie_t nts_cookie;         
	uint32_t                nts_filter;
	bool                    nts_reported;       
	uint64_t                nts_seq;            
} nstat_src;
struct nstat_merged_provider_filter {
	u_int64_t               mf_events;      
} nstat_merged_provider_filter;
struct nstat_merged_provider_filters {
	nstat_merged_provider_filter    mpf_filters[NSTAT_PROVIDER_COUNT];
} nstat_merged_provider_filters;
struct nstat_tucookie {
	struct inpcb    *inp;
	char            pname[PNAME_MAX_LENGTH];
	bool            cached;
	union{
		struct sockaddr_in      v4;
		struct sockaddr_in6     v6;
	} local;
	union{
		struct sockaddr_in      v4;
		struct sockaddr_in6     v6;
	} remote;
	unsigned int    if_index;
	uint32_t        ifnet_properties;
};
struct nstat_ifnet_cookie {
	struct ifnet    *ifp;
	uint64_t        threshold;
};
struct nstat_counts {
	u_int64_t       nstat_rxpackets __attribute__((aligned(sizeof(u_int64_t))));
	u_int64_t       nstat_rxbytes   __attribute__((aligned(sizeof(u_int64_t))));
	u_int64_t       nstat_txpackets __attribute__((aligned(sizeof(u_int64_t))));
	u_int64_t       nstat_txbytes   __attribute__((aligned(sizeof(u_int64_t))));

	u_int64_t       nstat_cell_rxbytes      __attribute__((aligned(sizeof(u_int64_t))));
	u_int64_t       nstat_cell_txbytes      __attribute__((aligned(sizeof(u_int64_t))));
	u_int64_t       nstat_wifi_rxbytes      __attribute__((aligned(sizeof(u_int64_t))));
	u_int64_t       nstat_wifi_txbytes      __attribute__((aligned(sizeof(u_int64_t))));
	u_int64_t       nstat_wired_rxbytes     __attribute__((aligned(sizeof(u_int64_t))));
	u_int64_t       nstat_wired_txbytes     __attribute__((aligned(sizeof(u_int64_t))));

	u_int32_t       nstat_rxduplicatebytes;
	u_int32_t       nstat_rxoutoforderbytes;
	u_int32_t       nstat_txretransmit;

	u_int32_t       nstat_connectattempts;
	u_int32_t       nstat_connectsuccesses;

	u_int32_t       nstat_min_rtt;
	u_int32_t       nstat_avg_rtt;
	u_int32_t       nstat_var_rtt;
} nstat_counts;
struct nstat_sysinfo_keyval {
	u_int32_t       nstat_sysinfo_key;
	u_int32_t       nstat_sysinfo_flags;
	union {
		int64_t nstat_sysinfo_scalar;
		double  nstat_sysinfo_distribution;
		u_int8_t nstat_sysinfo_string[NSTAT_SYSINFO_KEYVAL_STRING_MAXSIZE];
	} u;
	u_int32_t       nstat_sysinfo_valsize;
	u_int8_t        reserved[4];
}  nstat_sysinfo_keyval;
struct nstat_sysinfo_counts {
	u_int32_t       nstat_sysinfo_len;
	u_int32_t       pad;
	nstat_sysinfo_keyval        nstat_sysinfo_keyvals[];
}  nstat_sysinfo_counts;
struct nstat_route_add_param {
	union{
		struct sockaddr_in      v4;
		struct sockaddr_in6     v6;
	} dst;
	union{
		struct sockaddr_in      v4;
		struct sockaddr_in6     v6;
	} mask;
	u_int32_t       ifindex;
} nstat_route_add_param;
struct nstat_tcp_add_param {
	union{
		struct sockaddr_in      v4;
		struct sockaddr_in6     v6;
	} local;
	union{
		struct sockaddr_in      v4;
		struct sockaddr_in6     v6;
	} remote;
} nstat_tcp_add_param;
struct nstat_interface_counts {
	u_int64_t       nstat_rxpackets;
	u_int64_t       nstat_rxbytes;
	u_int64_t       nstat_txpackets;
	u_int64_t       nstat_txbytes;
} nstat_interface_counts;
struct nstat_domain_info {
	char            domain_name[NSTAT_MAX_DOMAIN_NAME_LENGTH];
	char            domain_owner[NSTAT_MAX_DOMAIN_OWNER_LENGTH];
	char            domain_tracker_ctxt[NSTAT_MAX_DOMAIN_TRACKER_CONTEXT];
	char            domain_attributed_bundle_id[NSTAT_MAX_DOMAIN_ATTR_BUNDLE_ID];
	union{
		struct sockaddr_in      v4;
		struct sockaddr_in6     v6;
	} remote;
	bool            is_tracker;
	bool            is_non_app_initiated;
	bool            is_silent;
	uint8_t         reserved[1];
} nstat_domain_info __attribute__((aligned(sizeof(u_int64_t))));
struct nstat_tcp_descriptor {
	u_int64_t       upid __attribute__((aligned(sizeof(u_int64_t))));
	u_int64_t       eupid __attribute__((aligned(sizeof(u_int64_t))));
	u_int64_t       start_timestamp __attribute__((aligned(sizeof(u_int64_t))));
	u_int64_t       timestamp __attribute__((aligned(sizeof(u_int64_t))));

	u_int64_t       rx_transfer_size __attribute__((aligned(sizeof(u_int64_t))));
	u_int64_t       tx_transfer_size __attribute__((aligned(sizeof(u_int64_t))));

	activity_bitmap_t activity_bitmap;

	u_int32_t       ifindex;
	u_int32_t       state;

	u_int32_t       sndbufsize;
	u_int32_t       sndbufused;
	u_int32_t       rcvbufsize;
	u_int32_t       rcvbufused;
	u_int32_t       txunacked;
	u_int32_t       txwindow;
	u_int32_t       txcwindow;
	u_int32_t       traffic_class;
	u_int32_t       traffic_mgt_flags;

	u_int32_t       pid;
	u_int32_t       epid;

	union{
		struct sockaddr_in      v4;
		struct sockaddr_in6     v6;
	} local;

	union{
		struct sockaddr_in      v4;
		struct sockaddr_in6     v6;
	} remote;

	char            cc_algo[16];
	char            pname[64];

	uuid_t          uuid;
	uuid_t          euuid;
	uuid_t          vuuid;
	uuid_t          fuuid;
	uid_t           persona_id;
	uid_t           uid;
	union {
		struct tcp_conn_status connstatus;
		
		uint8_t                                 __pad_connstatus[4];
	};
	uint32_t        ifnet_properties        __attribute__((aligned(4)));
	uint8_t         fallback_mode;
	uint8_t         reserved[3];
} nstat_tcp_descriptor;
struct nstat_udp_descriptor {
	u_int64_t       upid __attribute__((aligned(sizeof(u_int64_t))));
	u_int64_t       eupid __attribute__((aligned(sizeof(u_int64_t))));
	u_int64_t       start_timestamp __attribute__((aligned(sizeof(u_int64_t))));
	u_int64_t       timestamp __attribute__((aligned(sizeof(u_int64_t))));

	activity_bitmap_t activity_bitmap;

	union{
		struct sockaddr_in      v4;
		struct sockaddr_in6     v6;
	} local;

	union{
		struct sockaddr_in      v4;
		struct sockaddr_in6     v6;
	} remote;

	u_int32_t       ifindex;

	u_int32_t       rcvbufsize;
	u_int32_t       rcvbufused;
	u_int32_t       traffic_class;

	u_int32_t       pid;
	char            pname[64];
	u_int32_t       epid;

	uuid_t          uuid;
	uuid_t          euuid;
	uuid_t          vuuid;
	uuid_t          fuuid;
	uid_t           persona_id;
	uid_t           uid;
	uint32_t        ifnet_properties;
	uint8_t         fallback_mode;
	uint8_t         reserved[3];
} nstat_udp_descriptor;
struct nstat_connection_descriptor {
	u_int64_t       start_timestamp __attribute__((aligned(sizeof(u_int64_t))));
	u_int64_t       timestamp;
	u_int64_t       upid;
	u_int64_t       eupid;

	u_int32_t       pid;
	u_int32_t       epid;
	u_int32_t       ifnet_properties;
	char            pname[64];
	uuid_t          uuid;   
	uuid_t          euuid;  
	uuid_t          cuuid;  
	uuid_t          puuid;  
	uuid_t          fuuid;  
	uid_t           persona_id;
	uid_t           uid;
	uint8_t         reserved[4];
} nstat_connection_descriptor;
struct nstat_route_descriptor {
	u_int64_t       id __attribute__((aligned(sizeof(u_int64_t))));
	u_int64_t       parent_id __attribute__((aligned(sizeof(u_int64_t))));
	u_int64_t       gateway_id __attribute__((aligned(sizeof(u_int64_t))));

	union{
		struct sockaddr_in      v4;
		struct sockaddr_in6     v6;
		struct sockaddr         sa;
	} dst;

	union{
		struct sockaddr_in      v4;
		struct sockaddr_in6     v6;
		struct sockaddr         sa;
	} mask;

	union{
		struct sockaddr_in      v4;
		struct sockaddr_in6     v6;
		struct sockaddr         sa;
	} gateway;

	u_int32_t       ifindex;
	u_int32_t       flags;

	u_int8_t        reserved[4];
} nstat_route_descriptor;
struct nstat_ifnet_add_param {
	u_int64_t       threshold __attribute__((aligned(sizeof(u_int64_t))));
	u_int32_t       ifindex;

	u_int8_t        reserved[4];
} nstat_ifnet_add_param;
struct nstat_ifnet_desc_cellular_status {
	u_int32_t valid_bitmask; 
	u_int32_t link_quality_metric;
	u_int32_t ul_effective_bandwidth; 
	u_int32_t ul_max_bandwidth; 
	u_int32_t ul_min_latency; 
	u_int32_t ul_effective_latency; 
	u_int32_t ul_max_latency; 
	u_int32_t ul_retxt_level; 

	u_int32_t ul_bytes_lost; 
	u_int32_t ul_min_queue_size; 
	u_int32_t ul_avg_queue_size; 
	u_int32_t ul_max_queue_size; 
	u_int32_t dl_effective_bandwidth; 
	u_int32_t dl_max_bandwidth; 
	u_int32_t config_inactivity_time; 
	u_int32_t config_backoff_time; 
	u_int16_t mss_recommended; 
	u_int8_t        reserved[2];
} nstat_ifnet_desc_cellular_status;
struct nstat_ifnet_desc_wifi_status {
	u_int32_t valid_bitmask;
	u_int32_t link_quality_metric; 
	u_int32_t ul_effective_bandwidth; 
	u_int32_t ul_max_bandwidth; 
	u_int32_t ul_min_latency; 
	u_int32_t ul_effective_latency; 
	u_int32_t ul_max_latency; 
	u_int32_t ul_retxt_level; 

	u_int32_t ul_bytes_lost; 
	u_int32_t ul_error_rate; 
	u_int32_t dl_effective_bandwidth; 
	u_int32_t dl_max_bandwidth; 
	u_int32_t dl_min_latency; 
	u_int32_t dl_effective_latency; 
	u_int32_t dl_max_latency; 
	u_int32_t dl_error_rate; 
	u_int32_t config_frequency; 
	u_int32_t config_multicast_rate; 
	u_int32_t scan_count; 
	u_int32_t scan_duration; 
} nstat_ifnet_desc_wifi_status;
struct nstat_ifnet_desc_link_status {
	u_int32_t       link_status_type;
	union {
		nstat_ifnet_desc_cellular_status        cellular;
		nstat_ifnet_desc_wifi_status            wifi;
	} u;
} nstat_ifnet_desc_link_status;
struct nstat_ifnet_descriptor {
	u_int64_t                       threshold __attribute__((aligned(sizeof(u_int64_t))));
	u_int32_t                       ifindex;
	nstat_ifnet_desc_link_status    link_status;
	unsigned int            type;
	char                            description[IF_DESCSIZE];
	char                            name[IFNAMSIZ + 1];
	u_int8_t                        reserved[3];
} nstat_ifnet_descriptor;
struct nstat_sysinfo_descriptor {
	u_int32_t       flags;
} nstat_sysinfo_descriptor;
struct nstat_sysinfo_add_param {
	u_int32_t       flags;
} nstat_sysinfo_add_param;
struct nstat_msg_hdr {
	u_int64_t       context __attribute__((aligned(sizeof(u_int64_t))));
	u_int32_t       type;
	u_int16_t       length;
	u_int16_t       flags;
} nstat_msg_hdr;
struct nstat_msg_error {
	nstat_msg_hdr   hdr;
	u_int32_t               error;  
	u_int8_t                reserved[4];
} nstat_msg_error;
struct nstat_msg_add_src {
	NSTAT_ADD_SRC_FIELDS;
	u_int8_t        param[];
} nstat_msg_add_src_req;
struct nstat_msg_add_src_header {
	NSTAT_ADD_SRC_FIELDS;
} nstat_msg_add_src_header;
struct nstat_msg_add_src_convenient {
	nstat_msg_add_src_header        hdr;
	union {
		nstat_route_add_param   route;
		nstat_tcp_add_param     tcp;
		nstat_udp_add_param     udp;
		nstat_ifnet_add_param   ifnet;
		nstat_sysinfo_add_param sysinfo;
	};
} nstat_msg_add_src_convenient;
struct nstat_msg_add_all_srcs {
	nstat_msg_hdr           hdr;
	u_int64_t               filter __attribute__((aligned(sizeof(u_int64_t))));
	nstat_event_flags_t     events __attribute__((aligned(sizeof(u_int64_t))));
	nstat_provider_id_t     provider;
	pid_t                   target_pid;
	uuid_t                  target_uuid;
} nstat_msg_add_all_srcs;
struct nstat_msg_src_added {
	nstat_msg_hdr           hdr;
	nstat_src_ref_t         srcref __attribute__((aligned(sizeof(u_int64_t))));
	nstat_provider_id_t     provider;
	u_int8_t                reserved[4];
} nstat_msg_src_added;
struct nstat_msg_rem_src {
	nstat_msg_hdr           hdr;
	nstat_src_ref_t         srcref __attribute__((aligned(sizeof(u_int64_t))));
} nstat_msg_rem_src_req;
struct nstat_msg_get_src_description {
	nstat_msg_hdr           hdr;
	nstat_src_ref_t         srcref __attribute__((aligned(sizeof(u_int64_t))));
} nstat_msg_get_src_description;
struct nstat_msg_set_filter {
	nstat_msg_hdr           hdr;
	nstat_src_ref_t         srcref __attribute__((aligned(sizeof(u_int64_t))));
	u_int32_t               filter;
	u_int8_t                reserved[4];
} nstat_msg_set_filter;
struct nstat_msg_src_description {
	NSTAT_SRC_DESCRIPTION_FIELDS;
	u_int8_t        data[];
} nstat_msg_src_description;
struct nstat_msg_src_description_header {
	NSTAT_SRC_DESCRIPTION_FIELDS;
} nstat_msg_src_description_header;
struct nstat_msg_src_description_convenient {
	nstat_msg_src_description_header    hdr;
	union {
		nstat_tcp_descriptor            tcp;
		nstat_udp_descriptor            udp;
		nstat_route_descriptor          route;
		nstat_ifnet_descriptor          ifnet;
		nstat_sysinfo_descriptor        sysinfo;
		nstat_quic_descriptor           quic;
	};
} nstat_msg_src_description_convenient;
struct nstat_msg_query_src {
	nstat_msg_hdr           hdr;
	nstat_src_ref_t         srcref __attribute__((aligned(sizeof(u_int64_t))));
} nstat_msg_query_src_req;
struct nstat_msg_src_counts {
	nstat_msg_hdr           hdr;
	nstat_src_ref_t         srcref __attribute__((aligned(sizeof(u_int64_t))));
	nstat_event_flags_t     event_flags __attribute__((aligned(sizeof(u_int64_t))));
	nstat_counts            counts;
} nstat_msg_src_counts;
struct nstat_msg_src_update {
	NSTAT_SRC_UPDATE_FIELDS;
	u_int8_t        data[];
} nstat_msg_src_update;
struct nstat_msg_src_update_hdr {
	NSTAT_SRC_UPDATE_FIELDS;
} nstat_msg_src_update_hdr;
struct nstat_msg_src_update_tcp {
	NSTAT_SRC_UPDATE_FIELDS;
	nstat_tcp_descriptor            tcp_desc;
} nstat_msg_src_update_tcp;
struct nstat_msg_src_update_udp {
	NSTAT_SRC_UPDATE_FIELDS;
	nstat_udp_descriptor            udp_desc;
} nstat_msg_src_update_udp;
struct nstat_msg_src_update_quic {
	NSTAT_SRC_UPDATE_FIELDS;
	nstat_quic_descriptor           quic_desc;
} nstat_msg_src_update_quic;
struct nstat_msg_src_update_conn {
	NSTAT_SRC_UPDATE_FIELDS;
	nstat_connection_descriptor     conn_desc;
} nstat_msg_src_update_conn;
struct nstat_msg_src_update_convenient {
	nstat_msg_src_update_hdr                hdr;
	union {
		nstat_tcp_descriptor            tcp;
		nstat_udp_descriptor            udp;
		nstat_route_descriptor          route;
		nstat_ifnet_descriptor          ifnet;
		nstat_sysinfo_descriptor        sysinfo;
		nstat_quic_descriptor           quic;
		nstat_connection_descriptor     conn;
	};
} nstat_msg_src_update_convenient;
struct nstat_msg_src_extended_item_hdr {
	u_int32_t       type;
	u_int32_t       length;
} nstat_msg_src_extended_item_hdr __attribute__((aligned(sizeof(u_int64_t))));
struct nstat_msg_src_extended_item {
	nstat_msg_src_extended_item_hdr         hdr;
	u_int8_t                                data[];
} nstat_msg_src_extended_item;
struct nstat_msg_src_extended_tcp_update {
	NSTAT_SRC_UPDATE_FIELDS;
	nstat_tcp_descriptor                    tcp;
	nstat_msg_src_extended_item_hdr         extension_hdr;
	u_int8_t                                data[];
} nstat_msg_src_extended_tcp_update;
struct nstat_msg_src_extended_udp_update {
	NSTAT_SRC_UPDATE_FIELDS;
	nstat_udp_descriptor                    udp;
	nstat_msg_src_extended_item_hdr         extension_hdr;
	u_int8_t                                data[];
} nstat_msg_src_extended_udp_update;
struct nstat_msg_src_extended_quic_update {
	NSTAT_SRC_UPDATE_FIELDS;
	nstat_quic_descriptor                   quic;
	nstat_msg_src_extended_item_hdr         extension_hdr;
	u_int8_t                                data[];
} nstat_msg_src_extended_quic_update;
struct nstat_msg_src_extended_conn_update {
	NSTAT_SRC_UPDATE_FIELDS;
	nstat_connection_descriptor             conn;
	nstat_msg_src_extended_item_hdr         extension_hdr;
	u_int8_t                                data[];
} nstat_msg_src_extended_conn_update;
struct nstat_msg_src_tcp_update_domain_extension {
	nstat_msg_src_update_hdr                hdr;
	nstat_tcp_descriptor                    tcp;
	nstat_msg_src_extended_item_hdr         extension_hdr;
	nstat_domain_info                       domain_info;
} nstat_msg_src_tcp_update_domain_extension;
struct nstat_msg_src_udp_update_domain_extension {
	nstat_msg_src_update_hdr                hdr;
	nstat_udp_descriptor                    udp;
	nstat_msg_src_extended_item_hdr         extension_hdr;
	nstat_domain_info                       domain_info;
} nstat_msg_src_udp_update_domain_extension;
struct nstat_msg_src_quic_update_domain_extension {
	nstat_msg_src_update_hdr                hdr;
	nstat_quic_descriptor                   quic;
	nstat_msg_src_extended_item_hdr         extension_hdr;
	nstat_domain_info                       domain_info;
} nstat_msg_src_quic_update_domain_extension;
struct nstat_msg_src_update_domain_extension_convenient {
	nstat_msg_src_tcp_update_domain_extension       tcp;
	nstat_msg_src_udp_update_domain_extension       udp;
	nstat_msg_src_quic_update_domain_extension      quic;
} nstat_msg_src_update_domain_extension_convenient;
struct nstat_msg_src_removed {
	nstat_msg_hdr           hdr;
	nstat_src_ref_t         srcref __attribute__((aligned(sizeof(u_int64_t))));
} nstat_msg_src_removed;
struct nstat_msg_sysinfo_counts {
	nstat_msg_hdr           hdr;
	nstat_src_ref_t         srcref __attribute__((aligned(sizeof(u_int64_t))));
	nstat_sysinfo_counts    counts;
}  nstat_msg_sysinfo_counts;
struct nstat_stats {
	u_int32_t nstat_successmsgfailures;
	u_int32_t nstat_sendcountfailures;
	u_int32_t nstat_sysinfofailures;
	u_int32_t nstat_srcupatefailures;
	u_int32_t nstat_descriptionfailures;
	u_int32_t nstat_msgremovedfailures;
	u_int32_t nstat_srcaddedfailures;
	u_int32_t nstat_msgerrorfailures;
	u_int32_t nstat_copy_descriptor_failures;
	u_int32_t nstat_provider_counts_failures;
	u_int32_t nstat_control_send_description_failures;
	u_int32_t nstat_control_send_goodbye_failures;
	u_int32_t nstat_flush_accumulated_msgs_failures;
	u_int32_t nstat_accumulate_msg_failures;
	u_int32_t nstat_control_cleanup_source_failures;
	u_int32_t nstat_handle_msg_failures;
};
struct nstat_progress_indicators {
	u_int32_t       np_numflows;            
	u_int32_t       np_conn_probe_fails;    
	u_int32_t       np_read_probe_fails;    
	u_int32_t       np_write_probe_fails;   
	u_int32_t       np_recentflows;         
	u_int32_t       np_recentflows_unacked; 
	u_int64_t       np_recentflows_rxbytes; 
	u_int64_t       np_recentflows_txbytes; 
	u_int64_t       np_recentflows_rxooo;   
	u_int64_t       np_recentflows_rxdup;   
	u_int64_t       np_recentflows_retx;    
	u_int64_t       np_reserved1;           
	u_int64_t       np_reserved2;           
	u_int64_t       np_reserved3;           
	u_int64_t       np_reserved4;           
};
struct nstat_progress_req {
	u_int64_t       np_ifindex;                 
	u_int64_t       np_recentflow_maxduration;  
	u_int64_t       np_filter_flags;            
	u_int64_t       np_transport_protocol_mask; 
};
struct nstat_sysinfo_tcp_stats {
	u_int32_t       ipv4_avgrtt;    
	u_int32_t       ipv6_avgrtt;    
	u_int32_t       send_plr;       
	u_int32_t       recv_plr;       
	u_int32_t       send_tlrto_rate; 
	u_int32_t       send_reorder_rate; 
	u_int32_t       connection_attempts; 
	u_int32_t       connection_accepts; 
	u_int32_t       ecn_client_enabled; 
	u_int32_t       ecn_server_enabled; 
	u_int32_t       ecn_client_setup; 
	u_int32_t       ecn_server_setup; 
	u_int32_t       ecn_client_success; 
	u_int32_t       ecn_server_success; 
	u_int32_t       ecn_not_supported; 
	u_int32_t       ecn_lost_syn;   
	u_int32_t       ecn_lost_synack; 
	u_int32_t       ecn_recv_ce;    
	u_int32_t       ecn_recv_ece;   
	u_int32_t       ecn_sent_ece;   
	u_int32_t       ecn_conn_recv_ce; 
	u_int32_t       ecn_conn_recv_ece; 
	u_int32_t       ecn_conn_plnoce; 
	u_int32_t       ecn_conn_pl_ce; 
	u_int32_t       ecn_conn_nopl_ce; 
	u_int32_t       ecn_fallback_synloss; 
	u_int32_t       ecn_fallback_reorder; 
	u_int32_t       ecn_fallback_ce; 
	u_int32_t       tfo_syn_data_rcv;       
	u_int32_t       tfo_cookie_req_rcv;
	u_int32_t       tfo_cookie_sent;        
	u_int32_t       tfo_cookie_invalid;
	u_int32_t       tfo_cookie_req; 
	u_int32_t       tfo_cookie_rcv; 
	u_int32_t       tfo_syn_data_sent;      
	u_int32_t       tfo_syn_data_acked;
	u_int32_t       tfo_syn_loss;   
	u_int32_t       tfo_blackhole;  
	u_int32_t       tfo_cookie_wrong;       
	u_int32_t       tfo_no_cookie_rcv;      
	u_int32_t       tfo_heuristics_disable; 
	u_int32_t       tfo_sndblackhole;       
	u_int32_t       mptcp_handover_attempt; 
	u_int32_t       mptcp_interactive_attempt;      
	u_int32_t       mptcp_aggregate_attempt;        
	u_int32_t       mptcp_fp_handover_attempt; 
	u_int32_t       mptcp_fp_interactive_attempt;
	u_int32_t       mptcp_fp_aggregate_attempt;
	u_int32_t       mptcp_heuristic_fallback;       
	u_int32_t       mptcp_fp_heuristic_fallback;    
	u_int32_t       mptcp_handover_success_wifi;    
	u_int32_t       mptcp_handover_success_cell;    
	u_int32_t       mptcp_interactive_success;              
	u_int32_t       mptcp_aggregate_success;                
	u_int32_t       mptcp_fp_handover_success_wifi; 
	u_int32_t       mptcp_fp_handover_success_cell;
	u_int32_t       mptcp_fp_interactive_success;
	u_int32_t       mptcp_fp_aggregate_success;
	u_int32_t       mptcp_handover_cell_from_wifi;  
	u_int32_t       mptcp_handover_wifi_from_cell;  
	u_int32_t       mptcp_interactive_cell_from_wifi;       
	u_int32_t       mptcp_back_to_wifi;     
	u_int64_t       mptcp_handover_cell_bytes;              
	u_int64_t       mptcp_interactive_cell_bytes;   
	u_int64_t       mptcp_aggregate_cell_bytes;
	u_int64_t       mptcp_handover_all_bytes;               
	u_int64_t       mptcp_interactive_all_bytes;
	u_int64_t       mptcp_aggregate_all_bytes;
	u_int32_t       mptcp_wifi_proxy;               
	u_int32_t       mptcp_cell_proxy;               
	u_int32_t       mptcp_triggered_cell;           
	u_int32_t       _padding;
} nstat_sysinfo_tcp_stats;
struct nstat_sysinfo_lim_stats {
	u_int8_t                ifnet_signature[NSTAT_SYSINFO_KEYVAL_STRING_MAXSIZE];
	u_int32_t               ifnet_siglen;
	u_int32_t               ifnet_type;
	struct if_lim_perf_stat lim_stat;
} nstat_sysinfo_lim_stats;
struct nstat_sysinfo_net_api_stats {
	u_int32_t               report_interval;
	u_int32_t               _padding;
	struct net_api_stats    net_api_stats;
} nstat_sysinfo_net_api_stats;
struct nstat_sysinfo_data {
	uint32_t                flags;
	uint32_t                unsent_data_cnt; 
	union {
		nstat_sysinfo_tcp_stats tcp_stats;
		nstat_sysinfo_lim_stats lim_stats;
		nstat_sysinfo_net_api_stats net_api_stats;
	} u;
} nstat_sysinfo_data;
struct nwk_wq_entry {
	void(*XNU_PTRAUTH_SIGNED_FUNCTION_PTR("nkw_wq_entry.func") func)(struct nwk_wq_entry *);
	TAILQ_ENTRY(nwk_wq_entry) nwk_wq_link;
};
struct packet_mangler {
	kern_ctl_ref                    pkt_mnglr_kcref;
	uint32_t                        pkt_mnglr_kcunit;
	uint32_t                        pkt_mnglr_flags;
	ipfilter_t                      pkt_mnglr_ipfref;
	ipfilter_t                      pkt_mnglr_ipfrefv6;
	struct ipf_filter               pkt_mnglr_ipfilter;

	uint8_t                         activate;
	Pkt_Mnglr_Flow                  dir;
	struct sockaddr_storage         lsaddr;
	struct sockaddr_storage         rsaddr;
	struct sockaddr_storage         swap_lsaddr;
	struct sockaddr_storage         swap_rsaddr;
	uint32_t                        ip_action_mask;
	uint16_t                        lport;
	uint16_t                        rport;
	uint32_t                        proto;
	uint32_t                        proto_action_mask;
};
struct pf_anchor_stackframe {
	struct pf_ruleset                       *rs;
	struct pf_rule                          *r;
	struct pf_anchor_node                   *parent;
	struct pf_anchor                        *child;
} pf_anchor_stack[64];
struct hook_desc {
	TAILQ_ENTRY(hook_desc) hd_list;
	hook_fn_t hd_fn;
	void *hd_arg;
};
struct pf_pptp_hdr {
	u_int16_t       length;
	u_int16_t       type;
	u_int32_t       magic;
};
struct pf_pptp_ctrl_hdr {
	u_int16_t       type;
	u_int16_t       reserved_0;
};
struct pf_pptp_ctrl_generic {
	u_int16_t       data[0];
};
struct pf_pptp_ctrl_start_req {
	u_int16_t       protocol_version;
	u_int16_t       reserved_1;
	u_int32_t       framing_capabilities;
	u_int32_t       bearer_capabilities;
	u_int16_t       maximum_channels;
	u_int16_t       firmware_revision;
	u_int8_t        host_name[64];
	u_int8_t        vendor_string[64];
};
struct pf_pptp_ctrl_start_rpy {
	u_int16_t       protocol_version;
	u_int8_t        result_code;
	u_int8_t        error_code;
	u_int32_t       framing_capabilities;
	u_int32_t       bearer_capabilities;
	u_int16_t       maximum_channels;
	u_int16_t       firmware_revision;
	u_int8_t        host_name[64];
	u_int8_t        vendor_string[64];
};
struct pf_pptp_ctrl_stop_req {
	u_int8_t        reason;
	u_int8_t        reserved_1;
	u_int16_t       reserved_2;
};
struct pf_pptp_ctrl_stop_rpy {
	u_int8_t        reason;
	u_int8_t        error_code;
	u_int16_t       reserved_1;
};
struct pf_pptp_ctrl_echo_req {
	u_int32_t       identifier;
};
struct pf_pptp_ctrl_echo_rpy {
	u_int32_t       identifier;
	u_int8_t        result_code;
	u_int8_t        error_code;
	u_int16_t       reserved_1;
};
struct pf_pptp_ctrl_call_out_req {
	u_int16_t       call_id;
	u_int16_t       call_sernum;
	u_int32_t       min_bps;
	u_int32_t       bearer_type;
	u_int32_t       framing_type;
	u_int16_t       rxwindow_size;
	u_int16_t       proc_delay;
	u_int8_t        phone_num[64];
	u_int8_t        sub_addr[64];
};
struct pf_pptp_ctrl_call_out_rpy {
	u_int16_t       call_id;
	u_int16_t       peer_call_id;
	u_int8_t        result_code;
	u_int8_t        error_code;
	u_int16_t       cause_code;
	u_int32_t       connect_speed;
	u_int16_t       rxwindow_size;
	u_int16_t       proc_delay;
	u_int32_t       phy_channel_id;
};
struct pf_pptp_ctrl_call_in_1st {
	u_int16_t       call_id;
	u_int16_t       call_sernum;
	u_int32_t       bearer_type;
	u_int32_t       phy_channel_id;
	u_int16_t       dialed_number_len;
	u_int16_t       dialing_number_len;
	u_int8_t        dialed_num[64];
	u_int8_t        dialing_num[64];
	u_int8_t        sub_addr[64];
};
struct pf_pptp_ctrl_call_in_2nd {
	u_int16_t       call_id;
	u_int16_t       peer_call_id;
	u_int8_t        result_code;
	u_int8_t        error_code;
	u_int16_t       rxwindow_size;
	u_int16_t       txdelay;
	u_int16_t       reserved_1;
};
struct pf_pptp_ctrl_call_in_3rd {
	u_int16_t       call_id;
	u_int16_t       reserved_1;
	u_int32_t       connect_speed;
	u_int16_t       rxwindow_size;
	u_int16_t       txdelay;
	u_int32_t       framing_type;
};
struct pf_pptp_ctrl_call_clr {
	u_int16_t       call_id;
	u_int16_t       reserved_1;
};
struct pf_pptp_ctrl_call_disc {
	u_int16_t       call_id;
	u_int8_t        result_code;
	u_int8_t        error_code;
	u_int16_t       cause_code;
	u_int16_t       reserved_1;
	u_int8_t        statistics[128];
};
struct pf_pptp_ctrl_error {
	u_int16_t       peer_call_id;
	u_int16_t       reserved_1;
	u_int32_t       crc_errors;
	u_int32_t       fr_errors;
	u_int32_t       hw_errors;
	u_int32_t       buf_errors;
	u_int32_t       tim_errors;
	u_int32_t       align_errors;
};
struct pf_pptp_ctrl_set_linkinfo {
	u_int16_t       peer_call_id;
	u_int16_t       reserved_1;
	u_int32_t       tx_accm;
	u_int32_t       rx_accm;
};
struct pf_pptp_ctrl_msg {
	struct pf_pptp_hdr                              hdr;
	struct pf_pptp_ctrl_hdr                 ctrl;
	union pf_pptp_ctrl_msg_union    msg;
};
struct pf_ike_hdr {
	u_int64_t initiator_cookie, responder_cookie;
	u_int8_t next_payload, version, exchange_type, flags;
	u_int32_t message_id, length;
};
struct sadb_msg {
	u_int8_t sadb_msg_version;
	u_int8_t sadb_msg_type;
	u_int8_t sadb_msg_errno;
	u_int8_t sadb_msg_satype;
	u_int16_t sadb_msg_len;
	u_int16_t sadb_msg_reserved;
	u_int32_t sadb_msg_seq;
	u_int32_t sadb_msg_pid;
};
struct sadb_ext {
	u_int16_t sadb_ext_len;
	u_int16_t sadb_ext_type;
};
struct sadb_sa {
	u_int16_t sadb_sa_len;
	u_int16_t sadb_sa_exttype;
	u_int32_t sadb_sa_spi;
	u_int8_t sadb_sa_replay;
	u_int8_t sadb_sa_state;
	u_int8_t sadb_sa_auth;
	u_int8_t sadb_sa_encrypt;
	u_int32_t sadb_sa_flags;
};
struct sadb_sa_2 {
	struct sadb_sa  sa;
	u_int16_t               sadb_sa_natt_port;
	union {
		u_int16_t               sadb_reserved0;
		u_int16_t               sadb_sa_natt_interval;
	};

	u_int16_t               sadb_sa_natt_offload_interval;
	u_int16_t               sadb_sa_natt_src_port;
};
struct sadb_lifetime {
	u_int16_t sadb_lifetime_len;
	u_int16_t sadb_lifetime_exttype;
	u_int32_t sadb_lifetime_allocations;
	u_int64_t sadb_lifetime_bytes;
	u_int64_t sadb_lifetime_addtime;
	u_int64_t sadb_lifetime_usetime;
};
struct sadb_address {
	u_int16_t sadb_address_len;
	u_int16_t sadb_address_exttype;
	u_int8_t sadb_address_proto;
	u_int8_t sadb_address_prefixlen;
	u_int16_t sadb_address_reserved;
};
struct sadb_key {
	u_int16_t sadb_key_len;
	u_int16_t sadb_key_exttype;
	u_int16_t sadb_key_bits;
	u_int16_t sadb_key_reserved;
};
struct sadb_ident {
	u_int16_t sadb_ident_len;
	u_int16_t sadb_ident_exttype;
	u_int16_t sadb_ident_type;
	u_int16_t sadb_ident_reserved;
	u_int64_t sadb_ident_id;
};
struct sadb_sens {
	u_int16_t sadb_sens_len;
	u_int16_t sadb_sens_exttype;
	u_int32_t sadb_sens_dpd;
	u_int8_t sadb_sens_sens_level;
	u_int8_t sadb_sens_sens_len;
	u_int8_t sadb_sens_integ_level;
	u_int8_t sadb_sens_integ_len;
	u_int32_t sadb_sens_reserved;
};
struct sadb_prop {
	u_int16_t sadb_prop_len;
	u_int16_t sadb_prop_exttype;
	u_int8_t sadb_prop_replay;
	u_int8_t sadb_prop_reserved[3];
};
struct sadb_comb {
	u_int8_t sadb_comb_auth;
	u_int8_t sadb_comb_encrypt;
	u_int16_t sadb_comb_flags;
	u_int16_t sadb_comb_auth_minbits;
	u_int16_t sadb_comb_auth_maxbits;
	u_int16_t sadb_comb_encrypt_minbits;
	u_int16_t sadb_comb_encrypt_maxbits;
	u_int32_t sadb_comb_reserved;
	u_int32_t sadb_comb_soft_allocations;
	u_int32_t sadb_comb_hard_allocations;
	u_int64_t sadb_comb_soft_bytes;
	u_int64_t sadb_comb_hard_bytes;
	u_int64_t sadb_comb_soft_addtime;
	u_int64_t sadb_comb_hard_addtime;
	u_int64_t sadb_comb_soft_usetime;
	u_int64_t sadb_comb_hard_usetime;
};
struct sadb_supported {
	u_int16_t sadb_supported_len;
	u_int16_t sadb_supported_exttype;
	u_int32_t sadb_supported_reserved;
};
struct sadb_alg {
	u_int8_t sadb_alg_id;
	u_int8_t sadb_alg_ivlen;
	u_int16_t sadb_alg_minbits;
	u_int16_t sadb_alg_maxbits;
	u_int16_t sadb_alg_reserved;
};
struct sadb_spirange {
	u_int16_t sadb_spirange_len;
	u_int16_t sadb_spirange_exttype;
	u_int32_t sadb_spirange_min;
	u_int32_t sadb_spirange_max;
	u_int32_t sadb_spirange_reserved;
};
struct sadb_x_kmprivate {
	u_int16_t sadb_x_kmprivate_len;
	u_int16_t sadb_x_kmprivate_exttype;
	u_int32_t sadb_x_kmprivate_reserved;
};
struct sadb_x_sa2 {
	u_int16_t sadb_x_sa2_len;
	u_int16_t sadb_x_sa2_exttype;
	u_int8_t sadb_x_sa2_mode;
	union {
		u_int8_t sadb_x_sa2_reserved1;
		u_int8_t sadb_x_sa2_alwaysexpire;
	};
	union {
		u_int16_t sadb_x_sa2_reserved2;
		u_int16_t sadb_x_sa2_flags;
	};
	u_int32_t sadb_x_sa2_sequence;
	u_int32_t sadb_x_sa2_reqid;
};
struct sadb_x_policy {
	u_int16_t sadb_x_policy_len;
	u_int16_t sadb_x_policy_exttype;
	u_int16_t sadb_x_policy_type;   
	u_int8_t sadb_x_policy_dir;     
	u_int8_t sadb_x_policy_reserved;
	u_int32_t sadb_x_policy_id;
	u_int32_t sadb_x_policy_reserved2;
};
struct sadb_x_ipsecif {
	u_int16_t sadb_x_ipsecif_len;
	u_int16_t sadb_x_ipsecif_exttype;
	char sadb_x_ipsecif_internal_if[IFXNAMSIZ]; 
	char sadb_x_ipsecif_outgoing_if[IFXNAMSIZ]; 
	char sadb_x_ipsecif_ipsec_if[IFXNAMSIZ];  
	u_int16_t sadb_x_ipsecif_init_disabled; 
	u_int16_t reserved;
};
struct sadb_x_ipsecrequest {
	u_int16_t sadb_x_ipsecrequest_len; 
	u_int16_t sadb_x_ipsecrequest_proto; 
	u_int8_t sadb_x_ipsecrequest_mode; 
	u_int8_t sadb_x_ipsecrequest_level; 
	u_int16_t sadb_x_ipsecrequest_reqid; 

};
struct sadb_session_id {
	u_int16_t            sadb_session_id_len;
	u_int16_t            sadb_session_id_exttype;
	u_int64_t            sadb_session_id_v[2];
} __attribute__ ((aligned(8)));
struct sastat {
	u_int32_t            spi;               
	u_int32_t            created;           
	struct sadb_lifetime lft_c;             
};
struct sadb_sastat {
	u_int16_t            sadb_sastat_len;
	u_int16_t            sadb_sastat_exttype;
	u_int32_t            sadb_sastat_dir;
	u_int32_t            sadb_sastat_reserved;
	u_int32_t            sadb_sastat_list_len;
} __attribute__ ((aligned(8)));
struct {
	char tag_name[PF_TAG_NAME_SIZE];
	uint16_t tag_id;
} pf_reserved_tag_table_t;
struct pf_reass_tag_container {
	struct m_tag           pf_reass_m_tag;
	struct pf_fragment_tag pf_reass_fragment_tag;
};
struct pf_frent {
	LIST_ENTRY(pf_frent)    fr_next;
	struct mbuf             *fr_m;
	union {
		struct ip       *fru_ipv4;
		struct ip6_hdr  *fru_ipv6;
	} fr_u;
	struct ip6_frag         fr_ip6f_opt;
	uint16_t                fr_ip6f_hlen;   
	uint16_t                fr_ip6f_extoff; 
};
struct pf_frcache {
	LIST_ENTRY(pf_frcache) fr_next;
	uint16_t        fr_off;
	uint16_t        fr_end;
};
struct pf_fragment {
	RB_ENTRY(pf_fragment) fr_entry;
	TAILQ_ENTRY(pf_fragment) frag_next;
	struct pf_addr  fr_srcx;
	struct pf_addr  fr_dstx;
	u_int8_t        fr_p;           
	u_int8_t        fr_flags;       
	u_int16_t       fr_max;         
	union {
		u_int16_t       fru_id4;
		u_int32_t       fru_id6;
	} fr_uid;
	int             fr_af;
	u_int32_t       fr_timeout;
	union {
		LIST_HEAD(pf_fragq, pf_frent) fru_queue;        
		LIST_HEAD(pf_cacheq, pf_frcache) fru_cache;     
	} fr_u;
	uint32_t        fr_csum_flags;  
	uint32_t        fr_csum;        
	uint16_t        fr_ip6_maxlen;  
};
struct pbuf_memory {
	uint8_t *__sized_by(pm_buffer_len) pm_buffer;     
	u_int pm_buffer_len;    
	u_int pm_offset;        
	u_int pm_len;           
	uint32_t pm_csum_flags;
	uint32_t pm_csum_data;
	uint8_t pm_proto;
	uint8_t pm_flowsrc;
	uint32_t pm_flowid;
	uint32_t pm_flow_gencnt;
	uint32_t pm_flags;
	struct pf_mtag pm_pftag;
	struct pf_fragment_tag  pm_pf_fragtag;
	int (*pm_action)(struct pbuf_memory *, enum pbuf_action);
	void *pm_action_cookie;
};
struct pbuf {
	enum pbuf_type  pb_type;
	union {
		struct mbuf *pbu_mbuf;
		struct pbuf_memory pbu_memory;
	} pb_u;

	void            *__sized_by(pb_contig_len) pb_data;
	uint32_t        pb_packet_len;
	uint32_t        pb_contig_len;
	uint32_t        *pb_csum_flags;
	uint32_t        *pb_csum_data;    
	uint8_t         *pb_proto;
	uint8_t         *pb_flowsrc;
	uint32_t        *pb_flowid;
	uint32_t        *pb_flow_gencnt;
	uint32_t        *pb_flags;
	struct pf_mtag  *pb_pftag;
	struct pf_fragment_tag  *pb_pf_fragtag;
	struct ifnet    *pb_ifp;
	struct pbuf     *pb_next;
} pbuf_t;
struct pfr_walktree {
	enum pfrw_op {
		PFRW_MARK,
		PFRW_SWEEP,
		PFRW_ENQUEUE,
		PFRW_GET_ADDRS,
		PFRW_GET_ASTATS,
		PFRW_POOL_GET,
		PFRW_DYNADDR_UPDATE
	}        pfrw_op;
	union {
		user_addr_t              pfrw1_addr;
		user_addr_t              pfrw1_astats;
		struct pfr_kentryworkq  *pfrw1_workq;
		struct pfr_kentry       *pfrw1_kentry;
		struct pfi_dynaddr      *pfrw1_dyn;
	}        pfrw_1;
	int      pfrw_free;
	int      pfrw_flags;
};
struct kern_pktap_filter {
	uint32_t        filter_op;
	uint32_t        filter_param;
	union {
		uint32_t        _filter_if_type;
		char            _filter_if_name[PKTAP_IFXNAMESIZE];
	} param_;
	size_t          filter_ifname_len;
	bool            filter_ifname_prefix_match;
};
struct pktap_softc {
	LIST_ENTRY(pktap_softc)         pktp_link;
	uint32_t                        pktp_unit;
	uint32_t                        pktp_dlt_raw_count;
	uint32_t                        pktp_dlt_pkttap_count;
	struct ifnet                    *pktp_ifp;
	struct kern_pktap_filter        pktp_filters[PKTAP_MAX_FILTERS];
};
struct pktap_filter {
	uint32_t        filter_op;
	uint32_t        filter_param;
	union {
		uint32_t        _filter_if_type;
		char            _filter_if_name[PKTAP_IFXNAMESIZE];
	} param_;
};
struct pktap_header {
	uint32_t                pth_length;                     
	uint32_t                pth_type_next;                  
	uint32_t                pth_dlt;                        
	char                    pth_ifname[PKTAP_IFXNAMESIZE];  
	uint32_t                pth_flags;                      
	uint32_t                pth_protocol_family;
	uint32_t                pth_frame_pre_length;
	uint32_t                pth_frame_post_length;
	pid_t                   pth_pid;                        
	char                    pth_comm[MAXCOMLEN + 1];          
	uint8_t                 pth_ipproto;
	uint16_t                pth_trace_tag;
	uint32_t                pth_svc;                        
	uint16_t                pth_iftype;
	uint16_t                pth_ifunit;
	pid_t                   pth_epid;               
	char                    pth_ecomm[MAXCOMLEN + 1]; 
	uint8_t                 pth_pad2;
	uint16_t                pth_pad3;
	uint32_t                pth_flowid;
	uint32_t                pth_comp_gencnt;
	struct timeval32        pth_tstamp;
	uuid_t                  pth_uuid;
	uuid_t                  pth_euuid;
};
struct pktap_v2_hdr {
	uint8_t                 pth_length;                     
	uint8_t                 pth_uuid_offset;                
	uint8_t                 pth_e_uuid_offset;              
	uint8_t                 pth_ifname_offset;              
	uint8_t                 pth_comm_offset;                
	uint8_t                 pth_e_comm_offset;              
	uint16_t                pth_dlt;                        
	uint16_t                pth_frame_pre_length;
	uint16_t                pth_frame_post_length;
	uint16_t                pth_iftype;
	uint16_t                pth_ipproto;
	uint32_t                pth_protocol_family;
	uint32_t                pth_svc;                        
	uint32_t                pth_flowid;
	pid_t                   pth_pid;                        
	pid_t                   pth_e_pid;                      
	uint32_t                pth_flags;                      
};
struct pktap_v2_hdr_space {
	struct pktap_v2_hdr pth_hdr;
	uint8_t pth_uuid[sizeof(uuid_t)];
	uint8_t pth_e_uuid[sizeof(uuid_t)];
	uint8_t pth_ifname[PKTAP_IFXNAMESIZE];
	uint8_t pth_comm[PKTAP_MAX_COMM_SIZE];
	uint8_t pth_e_comm[PKTAP_MAX_COMM_SIZE];
};
struct pktap_buffer_v2_hdr_extra {
	struct pktap_v2_hdr_space hdr_space;
	union pktap_header_extra extra;
};
struct pktap_header_buffer {
	struct pktap_header             pkth;
	union pktap_header_extra        extra;
};
struct pppstat  {
	unsigned int ppp_ibytes; 
	unsigned int ppp_ipackets; 
	unsigned int ppp_ierrors; 
	unsigned int ppp_obytes; 
	unsigned int ppp_opackets; 
	unsigned int ppp_oerrors; 
};
struct vjstat {
	unsigned int vjs_packets; 
	unsigned int vjs_compressed; 
	unsigned int vjs_searches; 
	unsigned int vjs_misses; 
	unsigned int vjs_uncompressedin; 
	unsigned int vjs_compressedin; 
	unsigned int vjs_errorin; 
	unsigned int vjs_tossed; 
};
struct ppp_stats {
	struct pppstat p;       
	struct vjstat vj;       
};
struct compstat {
	unsigned int unc_bytes; 
	unsigned int unc_packets; 
	unsigned int comp_bytes; 
	unsigned int comp_packets; 
	unsigned int inc_bytes; 
	unsigned int inc_packets; 
	unsigned int ratio;     
};
struct ppp_comp_stats {
	struct compstat c;      
	struct compstat d;      
};
struct ppp_idle {
	time_t xmit_idle;       
	time_t recv_idle;       
};
struct rawcb {
	LIST_ENTRY(rawcb) list;
	struct  socket *rcb_socket;     
	struct  sockaddr *rcb_faddr;    
	struct  sockaddr *rcb_laddr;    
	struct  sockproto rcb_proto;    
	uint32_t        reserved[4];            
};
struct rvi_client_t {
	LIST_ENTRY(rvi_client_t)        _cle;
	ifnet_t                         _ifp;
	uint32_t                        _unit;
	uint32_t                        _vif;
	uint32_t                        _raw_count;
	uint32_t                        _pktap_count;
};
struct restricted_port_entry {
	const char      *rpe_entitlement;   
	in_port_t       rpe_port;           
	uint16_t        rpe_flags;          
};
struct rtentry_dbg {
	struct rtentry  rtd_entry;                      
	struct rtentry  rtd_entry_saved;                
	uint32_t        rtd_inuse;                      
	uint16_t        rtd_refhold_cnt;                
	uint16_t        rtd_refrele_cnt;                
	uint32_t        rtd_lock_cnt;                   
	uint32_t        rtd_unlock_cnt;                 
	ctrace_t        rtd_alloc;
	ctrace_t        rtd_free;
	ctrace_t        rtd_refhold[CTRACE_HIST_SIZE];
	ctrace_t        rtd_refrele[CTRACE_HIST_SIZE];
	ctrace_t        rtd_lock[CTRACE_HIST_SIZE];
	ctrace_t        rtd_unlock[CTRACE_HIST_SIZE];
	TAILQ_ENTRY(rtentry_dbg) rtd_trash_link;
};
struct matchleaf_arg {
	unsigned int    ifscope;        
};
struct rtfc_arg {
	struct rtentry *rt0;
	struct radix_node_head *rnh;
};
struct route_event_nwk_wq_entry {
	struct nwk_wq_entry nwk_wqe;
	struct route_event rt_ev_arg;
};
struct rt_metrics {
	u_int32_t       rmx_locks;      
	u_int32_t       rmx_mtu;        
	u_int32_t       rmx_hopcount;   
	int32_t         rmx_expire;     
	u_int32_t       rmx_recvpipe;   
	u_int32_t       rmx_sendpipe;   
	u_int32_t       rmx_ssthresh;   
	u_int32_t       rmx_rtt;        
	u_int32_t       rmx_rttvar;     
	u_int32_t       rmx_pksent;     
	u_int32_t       rmx_filler[4];  
};
struct rtstat {
	short   rts_badredirect;        
	short   rts_dynamic;            
	short   rts_newgateway;         
	short   rts_unreach;            
	short   rts_wildcard;           
	short   rts_badrtgwroute;       
};
struct rt_msghdr {
	u_short rtm_msglen;     
	u_char  rtm_version;    
	u_char  rtm_type;       
	u_short rtm_index;      
	int     rtm_flags;      
	int     rtm_addrs;      
	pid_t   rtm_pid;        
	int     rtm_seq;        
	int     rtm_errno;      
	int     rtm_use;        
	u_int32_t rtm_inits;    
	struct rt_metrics rtm_rmx; 
};
struct rt_msghdr2 {
	u_short rtm_msglen;     
	u_char  rtm_version;    
	u_char  rtm_type;       
	u_short rtm_index;      
	int     rtm_flags;      
	int     rtm_addrs;      
	int32_t rtm_refcnt;     
	int     rtm_parentflags; 
	int     rtm_reserved;   
	int     rtm_use;        
	u_int32_t rtm_inits;    
	struct rt_metrics rtm_rmx; 
};
struct rt_msghdr_prelude {
	u_short rtm_msglen;     
};
struct rt_addrinfo {
	int     rti_addrs;
	struct  sockaddr *rti_info[RTAX_MAX];
};
struct route_old {
	void            *ro_rt;
	uint32_t        ro_flags;
	struct sockaddr ro_dst;
};
struct route {
	struct rtentry        *ro_rt;
	struct ifaddr         *ro_srcia;
	uint32_t              ro_flags;       
	struct sockaddr       ro_dst;
};
struct rtentry {
	struct  radix_node rt_nodes[2]; 
	decl_lck_mtx_data(, rt_lock);   
	uint32_t rt_refcnt;             
	uint32_t rt_flags;              
	uint32_t rt_genid;              
	struct sockaddr *rt_gateway;    
	struct ifnet *rt_ifp;           
	struct ifaddr *rt_ifa;          
	struct sockaddr *rt_genmask;    
	void *rt_llinfo;                
	void (*rt_llinfo_get_ri)        
	(struct rtentry *, struct rt_reach_info *);
	void (*rt_llinfo_get_iflri)     
	(struct rtentry *, struct ifnet_llreach_info *);
	void (*rt_llinfo_purge)(struct rtentry *); 
	void (*rt_llinfo_free)(void *); 
	void (*rt_llinfo_refresh) (struct rtentry *); 
	struct rt_metrics rt_rmx;       
	struct rtentry *rt_gwroute;     
	struct rtentry *rt_parent;      
	struct nstat_counts *rt_stats;  
	void (*rt_if_ref_fn)(struct ifnet *, int); 

	uint32_t *rt_tree_genid;        
	uint64_t rt_expire;             
	uint64_t base_calendartime;     
	uint64_t base_uptime;           
	u_int32_t rtt_hist[NRTT_HIST];  
	u_int32_t rtt_min;              
	u_int32_t rtt_expire_ts;        
	u_int8_t rtt_index;             
	struct eventhandler_lists_ctxt rt_evhdlr_ctxt;
};
struct kev_netevent_apnfallbk_data {
	pid_t           epid;           
	uuid_t          euuid;          
};
struct rt_reach_info {
	u_int32_t       ri_refcnt;      
	u_int32_t       ri_probes;      
	u_int64_t       ri_snd_expire;  
	u_int64_t       ri_rcv_expire;  
	int32_t         ri_rssi;        
	int32_t         ri_lqm;         
	int32_t         ri_npm;         
};
struct rt_addrinfo_ext {
	struct rt_addrinfo rtix_info;                    
	struct sockaddr    rtix_tiny_addr[RTAX_MAX];     
	uint8_t            rtix_next_tiny;               
};
struct rt_msghdr_common {
	u_short rtm_msglen;     
	u_char  rtm_version;    
	u_char  rtm_type;       
	u_short rtm_index;      
	int     rtm_flags;      
	int     rtm_addrs;      
	pid_t   rtm_pid;        
	int     rtm_seq;        
	int     rtm_errno;      
	int     rtm_use;        
};
struct rt_msghdr_ext {
	u_short rtm_msglen;     
	u_char  rtm_version;    
	u_char  rtm_type;       
	u_int32_t rtm_index;    
	u_int32_t rtm_flags;    
	u_int32_t rtm_reserved; 
	u_int32_t rtm_addrs;    
	pid_t   rtm_pid;        
	int     rtm_seq;        
	int     rtm_errno;      
	u_int32_t rtm_use;      
	u_int32_t rtm_inits;    
	struct rt_metrics rtm_rmx;      
	struct rt_reach_info rtm_ri;    
};
struct rtstat_64 {
	uint64_t        rts_badredirect;        
	uint64_t        rts_dynamic;            
	uint64_t        rts_newgateway;         
	uint64_t        rts_unreach;            
	uint64_t        rts_wildcard;           
	uint64_t        rts_badrtgwroute;       
};
struct ctrace {
	void    *th;                            
	void    *pc[CTRACE_STACK_SIZE];         
} ctrace_t;
struct route_event {
	struct rtentry *rt;
	struct rtentry *gwrt;
	union {
		union sockaddr_in_4_6 _rtev_ipaddr;
		char _rtev_addr_bytes[DLIL_SDLMAXLEN];
	} rt_addr;
	uint32_t route_event_code;
	eventhandler_tag evtag;
};
struct route_cb {
	u_int32_t       ip_count;       
	u_int32_t       ip6_count;      
	u_int32_t       any_count;      
};
struct walkarg {
	int     w_tmemsize;
	int     w_op, w_arg;
	caddr_t w_tmem __sized_by(w_tmemsize);
	struct sysctl_req *w_req;
};
struct net_trie_node {
	uint16_t start;
	uint16_t length:15;
	uint16_t is_leaf:1;
	uint16_t child_map;
	uint16_t metadata;
	uint16_t metadata_length;
};
struct net_trie {
	uint64_t magic;
	uint64_t version;
	struct net_trie_node *nodes     __counted_by(nodes_count);
	uint16_t *child_maps            __counted_by(CHILD_MAP_SIZE * child_maps_count);
	uint8_t *bytes                  __counted_by(bytes_count);
	void *memory                    __sized_by(trie_memory_size);
	uint16_t nodes_count;
	uint16_t child_maps_count;
	uint16_t bytes_count;
	uint16_t nodes_free_next;
	uint16_t child_maps_free_next;
	uint16_t bytes_free_next;
	uint16_t root;
	size_t trie_memory_size;
	size_t nodes_mem_size;
	size_t child_maps_mem_size;
	size_t bytes_mem_size;
};
struct bootp {
	u_char  bp_op;          
	u_char  bp_htype;       
	u_char  bp_hlen;        
	u_char  bp_hops;        
	u_int32_t bp_xid;       
	u_short bp_secs;        
	u_short bp_unused;
	iaddr_t bp_ciaddr;      
	iaddr_t bp_yiaddr;      
	iaddr_t bp_siaddr;      
	iaddr_t bp_giaddr;      
	u_char  bp_chaddr[16];  
	u_char  bp_sname[64];   
	u_char  bp_file[128];   
	u_char  bp_vend[64];    
};
struct vend {
	u_char  v_magic[4];     
	u_int32_t v_flags;      
	u_char  v_unused[56];   
};
struct nextvend {
	u_char nv_magic[4];     
	u_char nv_version;      
	unsigned short  :0;
	union {
		u_char NV0[58];
		struct {
			u_char NV1_opcode;      
			u_char NV1_xid; 
			u_char NV1_text[NVMAXTEXT];     
			u_char NV1_null;        
		} NV1;
	} nv_U;
};
struct bootp_packet {
	struct ip bp_ip;
	struct udphdr bp_udp;
	struct bootp bp_bootp;
};
struct cbrt_table_entry {
	double x;
	double cbrt_x;
	double recip_cbrt_x;
	double recip_x;
};
struct _mbuf {
	struct _mbuf    *_m_next;
	void            *_m_pad;
	uint8_t         *__sized_by(_m_len) _m_data;
	int32_t         _m_len;
};
struct dhcp {
	u_char              dp_op;      
	u_char              dp_htype;   
	u_char              dp_hlen;    
	u_char              dp_hops;    
	u_int32_t           dp_xid;     
	u_int16_t           dp_secs;    
	u_int16_t           dp_flags;   
	struct in_addr      dp_ciaddr;  
	struct in_addr      dp_yiaddr;  
	struct in_addr      dp_siaddr;  
	struct in_addr      dp_giaddr;  
	u_char              dp_chaddr[16];
	u_char              dp_sname[64];
	u_char              dp_file[128];
	u_char              dp_options[0];
};
struct dhcp_packet {
	struct ip           ip;
	struct udphdr       udp;
	struct dhcp         dhcp;
};
struct {
	const void * *      array;
	uint32_t            size;
	uint32_t            count;
} ptrlist_t;
struct uuid_search_info {
	uuid_t      target_uuid;
	char        *found_signing_id __sized_by(found_signing_id_size);
	boolean_t   found_multiple_signing_ids;
	proc_t      found_proc;
	size_t      found_signing_id_size;
};
struct flow_divert_trie_node {
	uint16_t                        start;
	uint16_t                        length;
	uint16_t                        child_map;
};
struct flow_divert_pcb {
	decl_lck_mtx_data(, mtx);
	socket_t                        so;
	RB_ENTRY(flow_divert_pcb)       rb_link;
	uint32_t                        hash;
	mbuf_t                          connect_token;
	uint32_t                        flags;
	uint32_t                        send_window;
	struct flow_divert_group        *group;
	uint32_t                        control_group_unit;
	uint32_t                        aggregate_unit;
	uint32_t                        policy_control_unit;
	int32_t                         ref_count;
	uint64_t                        bytes_written_by_app;
	uint64_t                        bytes_sent;
	uint64_t                        bytes_received;
	uint8_t                         log_level;
	SLIST_ENTRY(flow_divert_pcb)    tmp_list_entry;
	mbuf_t                          connect_packet;
	uint8_t                         *app_data __counted_by(app_data_length);
	size_t                          app_data_length;
	union sockaddr_in_4_6           local_endpoint;
	struct sockaddr                 *original_remote_endpoint;
	struct ifnet                    *original_last_outifp6;
	struct ifnet                    *original_last_outifp;
	uint8_t                         original_vflag;
	bool                            plugin_locked; 
};
struct flow_divert_trie {
	struct flow_divert_trie_node    *nodes      __counted_by(nodes_count);
	uint16_t                        *child_maps __sized_by(child_maps_size);
	uint8_t                         *bytes      __counted_by(bytes_count);
	void                            *memory     __sized_by(memory_size);
	uint16_t                        nodes_count;
	uint16_t                        child_maps_count;
	uint16_t                        bytes_count;
	uint16_t                        nodes_free_next;
	uint16_t                        child_maps_free_next;
	uint16_t                        bytes_free_next;
	uint16_t                        root;
	size_t                          memory_size;
	size_t                          child_maps_size;
};
struct flow_divert_group {
	decl_lck_rw_data(, lck);
	TAILQ_ENTRY(flow_divert_group)  chain;
	struct fd_pcb_tree              pcb_tree;
	uint32_t                        ctl_unit;
	uint8_t                         atomic_bits;
	MBUFQ_HEAD(send_queue_head)     send_queue;
	uint8_t                         *token_key __counted_by(token_key_size);
	size_t                          token_key_size;
	uint32_t                        flags;
	struct flow_divert_trie         signing_id_trie;
	int32_t                         ref_count;
	pid_t                           in_process_pid;
	int32_t                         order;
};
struct flow_divert_packet_header {
	uint8_t             packet_type;
	uint32_t            conn_id;
};
struct flow_divert_flow_state {
	uint32_t conn_id;
	uint64_t bytes_written_by_app;
	uint64_t bytes_sent;
	uint64_t bytes_received;
	uint32_t send_window;
	uint32_t send_buffer_bytes;
};
struct icmp6_hdr {
	u_int8_t        icmp6_type;     
	u_int8_t        icmp6_code;     
	u_int16_t       icmp6_cksum;    
	union {
		u_int32_t       icmp6_un_data32[1]; 
		u_int16_t       icmp6_un_data16[2]; 
		u_int8_t        icmp6_un_data8[4];  
	} icmp6_dataun;
} __attribute__((__packed__));
struct mld_hdr {
	struct icmp6_hdr        mld_icmp6_hdr;
	struct in6_addr         mld_addr; 
} __attribute__((__packed__));
struct nd_router_solicit {      
	struct icmp6_hdr        nd_rs_hdr;
}__attribute__((__packed__));
struct nd_router_advert {       
	struct icmp6_hdr        nd_ra_hdr;
	u_int32_t               nd_ra_reachable;        
	u_int32_t               nd_ra_retransmit;       
} __attribute__((__packed__));
struct nd_neighbor_solicit {    
	struct icmp6_hdr        nd_ns_hdr;
	struct in6_addr         nd_ns_target;   
}__attribute__((__packed__));
struct nd_neighbor_advert {     
	struct icmp6_hdr        nd_na_hdr;
	struct in6_addr         nd_na_target;   
}__attribute__((__packed__));
struct nd_redirect {            
	struct icmp6_hdr        nd_rd_hdr;
	struct in6_addr         nd_rd_target;   
	struct in6_addr         nd_rd_dst;      
}__attribute__((__packed__));
struct nd_opt_hdr {             
	u_int8_t        nd_opt_type;
	u_int8_t        nd_opt_len;
}__attribute__((__packed__));
struct nd_opt_prefix_info {     
	u_int8_t        nd_opt_pi_type;
	u_int8_t        nd_opt_pi_len;
	u_int8_t        nd_opt_pi_prefix_len;
	u_int8_t        nd_opt_pi_flags_reserved;
	u_int32_t       nd_opt_pi_valid_time;
	u_int32_t       nd_opt_pi_preferred_time;
	u_int32_t       nd_opt_pi_reserved2;
	struct in6_addr nd_opt_pi_prefix;
}__attribute__((__packed__));
struct nd_opt_nonce {           
	u_int8_t        nd_opt_nonce_type;
	u_int8_t        nd_opt_nonce_len;
	u_int8_t        nd_opt_nonce[ND_OPT_NONCE_LEN];
} __attribute__((__packed__));
struct nd_opt_rd_hdr {          
	u_int8_t        nd_opt_rh_type;
	u_int8_t        nd_opt_rh_len;
	u_int16_t       nd_opt_rh_reserved1;
	u_int32_t       nd_opt_rh_reserved2;
} __attribute__((__packed__));
struct nd_opt_mtu {             
	u_int8_t        nd_opt_mtu_type;
	u_int8_t        nd_opt_mtu_len;
	u_int16_t       nd_opt_mtu_reserved;
	u_int32_t       nd_opt_mtu_mtu;
}__attribute__((__packed__));
struct nd_opt_route_info {      
	u_int8_t        nd_opt_rti_type;
	u_int8_t        nd_opt_rti_len;
	u_int8_t        nd_opt_rti_prefixlen;
	u_int8_t        nd_opt_rti_flags;
	u_int32_t       nd_opt_rti_lifetime;
}__attribute__((__packed__));
struct nd_opt_rdnss {   
	u_int8_t            nd_opt_rdnss_type;
	u_int8_t            nd_opt_rdnss_len;
	u_int16_t           nd_opt_rdnss_reserved;
	u_int32_t           nd_opt_rdnss_lifetime;
	struct in6_addr     nd_opt_rdnss_addr[1];
} __attribute__((__packed__));
struct nd_opt_dnssl {   
	u_int8_t            nd_opt_dnssl_type;
	u_int8_t            nd_opt_dnssl_len;
	u_int16_t           nd_opt_dnssl_reserved;
	u_int32_t           nd_opt_dnssl_lifetime;
	u_int8_t            nd_opt_dnssl_domains[8];
} __attribute__((__packed__));
struct nd_opt_pref64 {   
	u_int8_t            nd_opt_pref64_type;
	u_int8_t            nd_opt_pref64_len;
	u_int16_t           nd_opt_pref64_scaled_lifetime_plc;
	u_int32_t           nd_opt_pref64_prefix[3];
} __attribute__((__packed__));
struct nd_opt_pvd {
	u_int8_t        nd_opt_pvd_type;
	u_int8_t        nd_opt_pvd_len;
	u_int8_t        nd_opt_flags_delay[2];
	u_int16_t       nd_opt_pvd_seq;
	u_int8_t        nd_opt_pvd_id[1];
} __attribute__((__packed__));
struct icmp6_namelookup {
	struct icmp6_hdr        icmp6_nl_hdr;
	u_int8_t        icmp6_nl_nonce[8];
	int32_t         icmp6_nl_ttl;
}__attribute__((__packed__));
struct icmp6_nodeinfo {
	struct icmp6_hdr icmp6_ni_hdr;
	u_int8_t icmp6_ni_nonce[8];
}__attribute__((__packed__));
struct ni_reply_fqdn {
	u_int32_t ni_fqdn_ttl;  
	u_int8_t ni_fqdn_namelen; 
	u_int8_t ni_fqdn_name[3]; 
}__attribute__((__packed__));
struct icmp6_router_renum {     
	struct icmp6_hdr        rr_hdr;
	u_int8_t        rr_segnum;
	u_int8_t        rr_flags;
	u_int16_t       rr_maxdelay;
	u_int32_t       rr_reserved;
} __attribute__((__packed__));
struct rr_pco_match {           
	u_int8_t        rpm_code;
	u_int8_t        rpm_len;
	u_int8_t        rpm_ordinal;
	u_int8_t        rpm_matchlen;
	u_int8_t        rpm_minlen;
	u_int8_t        rpm_maxlen;
	u_int16_t       rpm_reserved;
	struct  in6_addr        rpm_prefix;
} __attribute__((__packed__));
struct rr_pco_use {             
	u_int8_t        rpu_uselen;
	u_int8_t        rpu_keeplen;
	u_int8_t        rpu_ramask;
	u_int8_t        rpu_raflags;
	u_int32_t       rpu_vltime;
	u_int32_t       rpu_pltime;
	u_int32_t       rpu_flags;
	struct  in6_addr rpu_prefix;
} __attribute__((__packed__));
struct rr_result {              
	u_int16_t       rrr_flags;
	u_int8_t        rrr_ordinal;
	u_int8_t        rrr_matchedlen;
	u_int32_t       rrr_ifid;
	struct  in6_addr rrr_prefix;
} __attribute__((__packed__));
struct icmp6_filter {
	u_int32_t icmp6_filt[8];
};
struct icmp6errstat {
	u_quad_t icp6errs_dst_unreach_noroute;
	u_quad_t icp6errs_dst_unreach_admin;
	u_quad_t icp6errs_dst_unreach_beyondscope;
	u_quad_t icp6errs_dst_unreach_addr;
	u_quad_t icp6errs_dst_unreach_noport;
	u_quad_t icp6errs_packet_too_big;
	u_quad_t icp6errs_time_exceed_transit;
	u_quad_t icp6errs_time_exceed_reassembly;
	u_quad_t icp6errs_paramprob_header;
	u_quad_t icp6errs_paramprob_nextheader;
	u_quad_t icp6errs_paramprob_option;
	u_quad_t icp6errs_redirect; 
	u_quad_t icp6errs_unknown;
};
struct icmp6stat {

	u_quad_t icp6s_error;           
	u_quad_t icp6s_canterror;       
	u_quad_t icp6s_toofreq;         
	u_quad_t icp6s_outhist[256];

	u_quad_t icp6s_badcode;         
	u_quad_t icp6s_tooshort;        
	u_quad_t icp6s_checksum;        
	u_quad_t icp6s_badlen;          
	u_quad_t icp6s_reflect;         
	u_quad_t icp6s_inhist[256];
	u_quad_t icp6s_nd_toomanyopt;   
	struct icmp6errstat icp6s_outerrhist;
	u_quad_t icp6s_pmtuchg;         
	u_quad_t icp6s_nd_badopt;       
	u_quad_t icp6s_badns;           
	u_quad_t icp6s_badna;           
	u_quad_t icp6s_badrs;           
	u_quad_t icp6s_badra;           
	u_quad_t icp6s_badredirect;     
	u_quad_t icp6s_rfc6980_drop;    
	u_quad_t icp6s_badpkttoobig;    
};
struct  icmpstat {

	u_int32_t       icps_error;     
	u_int32_t       icps_oldshort;  
	u_int32_t       icps_oldicmp;   
	u_int32_t       icps_outhist[ICMP_MAXTYPE + 1];

	u_int32_t       icps_badcode;   
	u_int32_t       icps_tooshort;  
	u_int32_t       icps_checksum;  
	u_int32_t       icps_badlen;    
	u_int32_t       icps_reflect;   
	u_int32_t       icps_inhist[ICMP_MAXTYPE + 1];
	u_int32_t       icps_bmcastecho;
	u_int32_t       icps_bmcasttstamp; 
};
struct  ether_arp {
	struct  arphdr ea_hdr;  
	u_char  arp_sha[ETHER_ADDR_LEN];        
	u_char  arp_spa[4];     
	u_char  arp_tha[ETHER_ADDR_LEN];        
	u_char  arp_tpa[4];     
};
struct sockaddr_inarp {
	u_char  sin_len;
	u_char  sin_family;
	u_short sin_port;
	struct  in_addr sin_addr;
	struct  in_addr sin_srcaddr;
	u_short sin_tos;
	u_short sin_other;
};
struct tun_softc {
	u_short tun_flags;              


	struct  ifnet tun_if;           
	int     tun_pgrp;               
	struct  selinfo tun_rsel;       
	struct  selinfo tun_wsel;       
};
struct igmp {
	u_char          igmp_type;      
	u_char          igmp_code;      
	u_short         igmp_cksum;     
	struct in_addr  igmp_group;     
};
struct igmpv3 {
	u_char          igmp_type;      
	u_char          igmp_code;      
	u_short         igmp_cksum;     
	struct in_addr  igmp_group;     
	                                
	u_char          igmp_misc;      
	u_char          igmp_qqi;       
	u_short         igmp_numsrc;    
	 
};
struct igmp_grouprec {
	u_char          ig_type;        
	u_char          ig_datalen;     
	u_short         ig_numsrc;      
	struct in_addr  ig_group;       
	 
};
struct igmp_report {
	u_char          ir_type;        
	u_char          ir_rsv1;        
	u_short         ir_cksum;       
	u_short         ir_rsv2;        
	u_short         ir_numgrps;     
		
};
struct igmpstat_v3 {
	uint32_t igps_version;          
	uint32_t igps_len;              
	uint64_t igps_rcv_total;        
	uint64_t igps_rcv_tooshort;     
	uint64_t igps_rcv_badttl;       
	uint64_t igps_rcv_badsum;       
	uint64_t igps_rcv_v1v2_queries; 
	uint64_t igps_rcv_v3_queries;   
	uint64_t igps_rcv_badqueries;   
	uint64_t igps_rcv_gen_queries;  
	uint64_t igps_rcv_group_queries;
	uint64_t igps_rcv_gsr_queries;  
	uint64_t igps_drop_gsr_queries; 
	uint64_t igps_rcv_reports;      
	uint64_t igps_rcv_badreports;   
	uint64_t igps_rcv_ourreports;   
	uint64_t igps_rcv_nora;         
	uint64_t igps_snd_reports;      
	uint64_t __igps_pad[4];
} __attribute__((aligned(8)));
struct igmpstat {
	u_int   igps_rcv_total;         
	u_int   igps_rcv_tooshort;      
	u_int   igps_rcv_badsum;        
	u_int   igps_rcv_queries;       
	u_int   igps_rcv_badqueries;    
	u_int   igps_rcv_reports;       
	u_int   igps_rcv_badreports;    
	u_int   igps_rcv_ourreports;    
	u_int   igps_snd_reports;       
};
struct in_addr {
	in_addr_t s_addr;
};
struct sockaddr_in {
	__uint8_t       sin_len;
	sa_family_t     sin_family;
	in_port_t       sin_port;
	struct  in_addr sin_addr;
	char            sin_zero[8];
};
struct llinfo_arp {
	LIST_ENTRY(llinfo_arp) la_le;
	struct  rtentry *la_rt;
	class_queue_t la_holdq;         
	struct  if_llreach *la_llreach; 
	u_int64_t la_lastused;          
	u_int32_t la_asked;             
	u_int32_t la_maxtries;          
	u_int64_t la_probeexp;          
	u_int32_t la_prbreq_cnt;        
	u_int32_t la_flags;
};
struct arptf_arg {
	boolean_t draining;
	boolean_t probing;
	uint32_t killed;
	uint32_t aging;
	uint32_t sticky;
	uint32_t found;
	uint32_t qlen;
	uint32_t qsize;
};
struct in_multi_dbg {
	struct in_multi         inm;                    
	u_int16_t               inm_refhold_cnt;        
	u_int16_t               inm_refrele_cnt;        
	ctrace_t                inm_refhold[INM_TRACE_HIST_SIZE];
	ctrace_t                inm_refrele[INM_TRACE_HIST_SIZE];
	TAILQ_ENTRY(in_multi_dbg) inm_trash_link;
};
struct inp_flowhash_key_addr {
	union {
		struct in_addr  v4;
		struct in6_addr v6;
		u_int8_t        addr8[16];
		u_int16_t       addr16[8];
		u_int32_t       addr32[4];
	} infha;
};
struct inp_flowhash_key {
	struct inp_flowhash_key_addr    infh_laddr;
	struct inp_flowhash_key_addr    infh_faddr;
	u_int32_t                       infh_lport;
	u_int32_t                       infh_fport;
	u_int32_t                       infh_af;
	u_int32_t                       infh_proto;
	u_int32_t                       infh_rand1;
	u_int32_t                       infh_rand2;
};
struct in_addr_4in6 {
	u_int32_t       ia46_pad32[3];
	struct  in_addr ia46_addr4;
};
struct inp_stat {
	u_int64_t       rxpackets;
	u_int64_t       rxbytes;
	u_int64_t       txpackets;
	u_int64_t       txbytes;
};
struct inp_necp_attributes {
	char *inp_domain __null_terminated;
	char *inp_account __null_terminated;
	char *inp_domain_owner __null_terminated;
	char *inp_tracker_domain __null_terminated;
	char *inp_domain_context __null_terminated;
};
struct inpcb {
	decl_lck_mtx_data(, inpcb_mtx); 
	LIST_ENTRY(inpcb) inp_hash;     
	LIST_ENTRY(inpcb) inp_list;     
	void    *inp_ppcb;              
	struct inpcbinfo *inp_pcbinfo;  
	struct socket *inp_socket;      
	LIST_ENTRY(inpcb) inp_portlist; 
	RB_ENTRY(inpcb) infc_link;      
	struct inpcbport *inp_phd;      
	inp_gen_t inp_gencnt;           
	int     inp_hash_element;       
	int     inp_wantcnt;            
	int     inp_state;              
	u_short inp_fport;              
	u_short inp_lport;              
	uint32_t inp_flags;            
	uint32_t inp_flags2;           
	uint32_t inp_log_flags;
	uint32_t inp_flow;             
	uint32_t inp_lifscope;          
	uint32_t inp_fifscope;          

	uint32_t inp_sndingprog_waiters;
	u_char  inp_sndinprog_cnt;      
	u_char  inp_vflag;              

	u_char inp_ip_ttl;              
	u_char inp_ip_p;                

	struct ifnet *inp_boundifp;     
	struct ifnet *inp_last_outifp;  
	uint32_t inp_flowhash;         

	union {
		
		struct in_addr_4in6 inp46_foreign;
		struct in6_addr inp6_foreign;
	} inp_dependfaddr;
	union {
		
		struct in_addr_4in6 inp46_local;
		struct in6_addr inp6_local;
	} inp_dependladdr;
	union {
		
		struct route inp4_route;
		struct route_in6 inp6_route;
	} inp_dependroute;
	struct {
		
		u_char inp4_ip_tos;
		
		struct mbuf *inp4_options;
		
		struct ip_moptions *inp4_moptions;
	} inp_depend4;
	struct {
		
		struct mbuf *inp6_options;
		
		struct  ip6_pktopts *inp6_outputopts;
		
		struct  ip6_moptions *inp6_moptions;
		
		struct  icmp6_filter *inp6_icmp6filt;
		
		int     inp6_cksum;
		short   inp6_hops;
	} inp_depend6;

	uint64_t       inp_fadv_total_time;
	uint64_t       inp_fadv_start_time;
	uint64_t       inp_fadv_cnt;

	caddr_t inp_saved_ppcb;         
	struct inp_necp_attributes inp_necp_attributes;
	struct necp_inpcb_result inp_policyresult;
	uuid_t necp_client_uuid;

	uint32_t inp_bind_in_progress_waiters;
	thread_t inp_bind_in_progress_last_waiter_thread;

	thread_t inp_bind_in_progress_thread;

	necp_client_flow_cb necp_cb;
	size_t inp_resolver_signature_length;
	uint8_t *inp_resolver_signature __sized_by(inp_resolver_signature_length);
	u_char *__sized_by(inp_keepalive_datalen) inp_keepalive_data;     
	uint8_t inp_keepalive_datalen; 
	uint8_t inp_keepalive_type;    
	uint16_t inp_keepalive_interval; 
	uint32_t inp_nstat_refcnt __attribute__((aligned(4)));
	struct inp_stat *inp_stat;
	struct inp_stat *inp_cstat;     
	struct inp_stat *inp_wstat;     
	struct inp_stat *inp_Wstat;     
	struct inp_stat *inp_btstat;    
	uint8_t inp_stat_store[sizeof(struct inp_stat) + sizeof(u_int64_t)];
	uint8_t inp_cstat_store[sizeof(struct inp_stat) + sizeof(u_int64_t)];
	uint8_t inp_wstat_store[sizeof(struct inp_stat) + sizeof(u_int64_t)];
	uint8_t inp_Wstat_store[sizeof(struct inp_stat) + sizeof(u_int64_t)];
	uint8_t inp_btstat_store[sizeof(struct inp_stat) + sizeof(u_int64_t)];
	activity_bitmap_t inp_nw_activity;
	uint64_t inp_start_timestamp;
	uint64_t inp_connect_timestamp;

	char inp_last_proc_name[MAXCOMLEN + 1];
	char inp_e_proc_name[MAXCOMLEN + 1];
};
struct _inpcb_list_entry {
	u_int32_t   le_next;
	u_int32_t   le_prev;
};
struct inpcb_compat {
	_INPCB_LIST_ENTRY(inpcb) inp_hash;      
	struct in_addr reserved1;               
	struct in_addr reserved2;               
	u_short inp_fport;                      
	u_short inp_lport;                      
	_INPCB_LIST_ENTRY(inpcb) inp_list;      
	_INPCB_PTR(caddr_t) inp_ppcb;           
	_INPCB_PTR(struct inpcbinfo *) inp_pcbinfo;     
	_INPCB_PTR(void *) inp_socket;  
	u_char nat_owner;               
	u_int32_t nat_cookie;           
	_INPCB_LIST_ENTRY(inpcb) inp_portlist;  
	_INPCB_PTR(struct inpcbport *) inp_phd; 
	inp_gen_t inp_gencnt;           
	int inp_flags;                  
	u_int32_t inp_flow;

	u_char inp_vflag;

	u_char inp_ip_ttl;              
	u_char inp_ip_p;                
	union {
		
		struct in_addr_4in6 inp46_foreign;
		struct in6_addr inp6_foreign;
	} inp_dependfaddr;
	union {
		
		struct in_addr_4in6 inp46_local;
		struct in6_addr inp6_local;
	} inp_dependladdr;
	union {
		
		u_char inp4_route[20];
		u_char inp6_route[32];
	} inp_dependroute;
	struct {
		
		u_char inp4_ip_tos;
		
		_INPCB_PTR(struct mbuf *) inp4_options;
		
		_INPCB_PTR(struct ip_moptions *) inp4_moptions;
	} inp_depend4;

	struct {
		
		_INPCB_PTR(struct mbuf *) inp6_options;
		u_int8_t inp6_hlim;
		u_int8_t unused_uint8_1;
		ushort unused_uint16_1;
		
		_INPCB_PTR(struct ip6_pktopts *) inp6_outputopts;
		
		_INPCB_PTR(struct ip6_moptions *) inp6_moptions;
		
		_INPCB_PTR(struct icmp6_filter *) inp6_icmp6filt;
		
		int     inp6_cksum;
		u_short inp6_ifindex;
		short   inp6_hops;
	} inp_depend6;

	int hash_element;               
	_INPCB_PTR(caddr_t) inp_saved_ppcb; 
	_INPCB_PTR(struct inpcbpolicy *) inp_sp;
	u_int32_t       reserved[3];    
};
struct  xinpcb {
	u_int32_t       xi_len;         
	struct  inpcb_compat xi_inp;
	struct  xsocket xi_socket;
	u_quad_t        xi_alignment_hack;
};
struct xinpcb_list_entry {
	u_int64_t   le_next;
	u_int64_t   le_prev;
};
struct  xinpcb_n {
	u_int32_t       xi_len;         
	u_int32_t       xi_kind;        
	u_int64_t       xi_inpp;
	u_short         inp_fport;      
	u_short         inp_lport;      
	u_int64_t       inp_ppcb;       
	inp_gen_t       inp_gencnt;     
	int             inp_flags;      
	u_int32_t       inp_flow;
	u_char          inp_vflag;
	u_char          inp_ip_ttl;     
	u_char          inp_ip_p;       
	union {                         
		struct in_addr_4in6     inp46_foreign;
		struct in6_addr         inp6_foreign;
	} inp_dependfaddr;
	union {                         
		struct in_addr_4in6     inp46_local;
		struct in6_addr         inp6_local;
	} inp_dependladdr;
	struct {
		u_char  inp4_ip_tos;    
	} inp_depend4;
	struct {
		u_int8_t inp6_hlim;
		int     inp6_cksum;
		u_short inp6_ifindex;
		short   inp6_hops;
	} inp_depend6;
	u_int32_t               inp_flowhash;
	u_int32_t       inp_flags2;
};
struct  xinpgen {
	u_int32_t       xig_len;        
	u_int           xig_count;      
	inp_gen_t       xig_gen;        
	so_gen_t        xig_sogen;      
};
struct inpcbport {
	LIST_ENTRY(inpcbport) phd_hash;
	struct inpcbhead phd_pcblist;
	u_short phd_port;
};
struct intimercount {
	u_int32_t intimer_lazy; 
	u_int32_t intimer_fast; 
	u_int32_t intimer_nodelay; 
};
struct inpcbinfo {
	TAILQ_ENTRY(inpcbinfo)  ipi_entry;
	inpcb_timer_func_t      ipi_gc;
	inpcb_timer_func_t      ipi_timer;
	struct intimercount     ipi_gc_req;
	struct intimercount     ipi_timer_req;

	lck_rw_t                ipi_lock;

	struct inpcbhead        *ipi_listhead;
	uint32_t                ipi_count;

	uint32_t                ipi_twcount;

	uint64_t                ipi_gencnt;

	uint16_t                ipi_lastport;
	uint16_t                ipi_lastlow;
	uint16_t                ipi_lasthi;

	kalloc_type_view_t       ipi_zone;

	struct inpcbhead        *__counted_by(ipi_hashbase_count) ipi_hashbase;
	size_t                  ipi_hashbase_count;
	u_long                  ipi_hashmask;

	struct inpcbporthead    *__counted_by(ipi_porthashbase_count) ipi_porthashbase;
	size_t                  ipi_porthashbase_count;
	u_long                  ipi_porthashmask;

	lck_attr_t              ipi_lock_attr;
	lck_grp_t               *ipi_lock_grp;

	u_int32_t               ipi_flags;
};
struct sockaddr_inifscope {
	__uint8_t       sin_len;
	sa_family_t     sin_family;
	in_port_t       sin_port;
	struct  in_addr sin_addr;
	union {
		char    sin_zero[8];
		struct {
			__uint32_t      ifscope;
		} _in_index;
	} un;
};
struct rtqk_arg {
	struct radix_node_head *rnh;
	int updating;
	int draining;
	uint32_t killed;
	uint32_t found;
	uint64_t nextstop;
};
struct in_ifadown_arg {
	struct radix_node_head *rnh;
	struct ifaddr *ifa;
	int del;
};
struct activity_bitmap {
	uint64_t        start;          
	uint64_t        bitmap[2];      
} activity_bitmap_t;
struct net_qos_dscp_map {
	uint8_t        sotc_to_dscp[SO_TC_MAX];
	uint8_t        netsvctype_to_dscp[_NET_SERVICE_TYPE_COUNT];
};
struct dcsp_msc_map {
	uint8_t                 dscp;
	mbuf_svc_class_t        msc;
};
struct so_tcdbg {
	u_int32_t       so_tcdbg_cmd;
	int32_t         so_tcdbg_tclass;
	int32_t         so_tcdbg_netsvctype;
	uint8_t         so_tcdbg_ecn_val;  
	u_int32_t       so_tcdbg_count;
	pid_t           so_tcdbg_pid;
	u_int32_t       so_tcbbg_qos_mode;
	char            so_tcdbg_pname[(2 * MAXCOMLEN) + 1];
};
struct net_qos_param {
	u_int64_t nq_transfer_size;     
	u_int32_t nq_use_expensive:1,   
	    nq_uplink:1,                
	    nq_use_constrained:1;       
	u_int32_t nq_unused;            
};
struct in_ifaddr {
	struct ifaddr ia_ifa;           
	u_int32_t ia_net;               
	u_int32_t ia_netmask;           
	u_int32_t ia_subnet;            
	u_int32_t ia_subnetmask;        
	struct in_addr ia_netbroadcast; 
	TAILQ_ENTRY(in_ifaddr) ia_link; 
	struct sockaddr_in ia_addr;     
	struct sockaddr_in ia_dstaddr;  
	struct sockaddr_in ia_sockmask; 
	TAILQ_ENTRY(in_ifaddr) ia_hash; 
};
struct in_aliasreq {
	char ifra_name[IFNAMSIZ];       
	struct sockaddr_in ifra_addr;
	struct sockaddr_in ifra_broadaddr;
	struct sockaddr_in ifra_mask;
};
struct kev_in_data {
	struct net_event_data link_data;
	struct in_addr ia_addr;         
	u_int32_t ia_net;               
	u_int32_t ia_netmask;           
	u_int32_t ia_subnet;            
	u_int32_t ia_subnetmask;        
	struct in_addr ia_netbroadcast; 
	struct in_addr ia_dstaddr;
};
struct kev_in_collision {
	struct net_event_data link_data; 
	struct in_addr ia_ipaddr;       
	u_char hw_len;                  
	u_char hw_addr[__counted_by(hw_len)];
};
struct kev_in_arpfailure {
	struct net_event_data link_data; 
};
struct kev_in_arpalive {
	struct net_event_data link_data; 
};
struct kev_socket_event_data {
	union sockaddr_in_4_6 kev_sockname;
	union sockaddr_in_4_6 kev_peername;
};
struct kev_socket_closed {
	struct kev_socket_event_data ev_data;
};
struct kev_in_portinuse {
	u_int16_t port;         
	u_int32_t req_pid;      
	u_int32_t reserved[2];
};
struct router_info {
	struct ifnet *rti_ifp;
	int    rti_type; 
	int    rti_time; 
	SLIST_ENTRY(router_info) rti_list;
};
struct ip_msource {
	RB_ENTRY(ip_msource)    ims_link;       
	in_addr_t               ims_haddr;      
	struct ims_st {
		uint16_t        ex;             
		uint16_t        in;             
	}                       ims_st[2];      
	uint8_t                 ims_stp;        
};
struct in_msource {
	RB_ENTRY(ip_msource)    ims_link;       
	in_addr_t               ims_haddr;      
	uint8_t                 imsl_st[2];     
};
struct in_mfilter {
	struct ip_msource_tree  imf_sources; 
	u_long                  imf_nsrc;    
	uint8_t                 imf_st[2];   
};
struct in_multi {
	decl_lck_mtx_data(, inm_lock);
	u_int32_t inm_refcount;         
	u_int32_t inm_reqcnt;           
	u_int32_t inm_debug;            
	LIST_ENTRY(in_multi) inm_link;  
	struct  in_addr inm_addr;       
	struct  ifnet *inm_ifp;         
	struct  ifmultiaddr *inm_ifma;  
	u_int   inm_timer;              
	u_int   inm_state;              
	bool    inm_in_nrele;           

	struct igmp_ifinfo      *inm_igi;       
	SLIST_ENTRY(in_multi)    inm_dtle;      
	SLIST_ENTRY(in_multi)    inm_nrele;     
	u_int32_t                inm_nrelecnt;  
	struct ip_msource_tree   inm_srcs;      
	u_long                   inm_nsrc;      

	struct ifqueue           inm_scq;       
	struct timeval           inm_lastgsrtv; 
	uint16_t                 inm_sctimer;   
	uint16_t                 inm_scrv;      

	struct inm_st {
		uint16_t        iss_fmode;      
		uint16_t        iss_asm;        
		uint16_t        iss_ex;         
		uint16_t        iss_in;         
		uint16_t        iss_rec;        
	}                       inm_st[2];      

	void (*inm_trace)               
	(struct in_multi *, int);
};
struct in_multistep {
	struct in_multi *i_inm;
};
struct in_ifextra {
	uint32_t                netsig_len;
	u_int8_t                netsig[IFNET_SIGNATURELEN];
};
struct ip {
	u_char  ip_tos;                 
	u_short ip_len;                 
	u_short ip_id;                  
	u_short ip_off;                 
	u_char  ip_ttl;                 
	u_char  ip_p;                   
	u_short ip_sum;                 
	struct  in_addr ip_src, ip_dst;  
};
struct  ip_timestamp {
	u_char  ipt_code;               
	u_char  ipt_len;                
	u_char  ipt_ptr;                
	u_int   ipt_flg:4,              
	    ipt_oflw:4;                 
	u_int   ipt_oflw:4,             
	    ipt_flg:4;                  
	union ipt_timestamp {
		n_long  ipt_time[1];
		struct  ipt_ta {
			struct in_addr ipt_addr;
			n_long ipt_time;
		} ipt_ta[1];
	} ipt_timestamp;
};
struct ip6_hdr {
	union {
		struct ip6_hdrctl {
			u_int32_t ip6_un1_flow; 
			u_int16_t ip6_un1_plen; 
			u_int8_t  ip6_un1_nxt;  
			u_int8_t  ip6_un1_hlim; 
		} ip6_un1;
		u_int8_t ip6_un2_vfc;   
	} ip6_ctlun;
	struct in6_addr ip6_src;        
	struct in6_addr ip6_dst;        
} __attribute__((__packed__));
struct  ip6_ext {
	u_int8_t ip6e_nxt;
	u_int8_t ip6e_len;
} __attribute__((__packed__));
struct ip6_hbh {
	u_int8_t ip6h_nxt;      
	u_int8_t ip6h_len;      
} __attribute__((__packed__));
struct ip6_dest {
	u_int8_t ip6d_nxt;      
	u_int8_t ip6d_len;      
} __attribute__((__packed__));
struct ip6_opt {
	u_int8_t ip6o_type;
	u_int8_t ip6o_len;
} __attribute__((__packed__));
struct ip6_opt_jumbo {
	u_int8_t ip6oj_type;
	u_int8_t ip6oj_len;
	u_int8_t ip6oj_jumbo_len[4];
} __attribute__((__packed__));
struct ip6_opt_nsap {
	u_int8_t ip6on_type;
	u_int8_t ip6on_len;
	u_int8_t ip6on_src_nsap_len;
	u_int8_t ip6on_dst_nsap_len;
}__attribute__((__packed__));
struct ip6_opt_tunnel {
	u_int8_t ip6ot_type;
	u_int8_t ip6ot_len;
	u_int8_t ip6ot_encap_limit;
}__attribute__((__packed__));
struct ip6_opt_router {
	u_int8_t ip6or_type;
	u_int8_t ip6or_len;
	u_int8_t ip6or_value[2];
}__attribute__((__packed__));
struct ip6_rthdr {
	u_int8_t  ip6r_nxt;     
	u_int8_t  ip6r_len;     
	u_int8_t  ip6r_type;    
	u_int8_t  ip6r_segleft; 
} __attribute__((__packed__));
struct ip6_rthdr0 {
	u_int8_t  ip6r0_nxt;            
	u_int8_t  ip6r0_len;            
	u_int8_t  ip6r0_type;           
	u_int8_t  ip6r0_segleft;        
	u_int32_t  ip6r0_reserved;      
} __attribute__((__packed__));
struct ip6_frag {
	u_int8_t  ip6f_nxt;             
	u_int8_t  ip6f_reserved;        
	u_int16_t ip6f_offlg;           
	u_int32_t ip6f_ident;           
} __attribute__((__packed__));
struct dn_event_nwk_wq_entry {
	struct nwk_wq_entry nwk_wqe;
	struct dummynet_event dn_ev_arg;
};
struct dummynet_tag_container {
	struct m_tag            dtc_m_tag;
	struct dn_pkt_tag       dtc_dn_pkt_tag;
};
struct dn_heap_entry {
	dn_key key;      
	size_t obj_size; 
	void * object  __sized_by_or_null(obj_size);   
};
struct dn_heap {
	int size;              
	int elements;          
	int offset;            
	struct dn_heap_entry *__counted_by_or_null(size) p; 
};
struct dn_pkt_tag {
	void                *dn_pf_rule;        
	int                 dn_dir;             
	dn_key              dn_output_time;     
	struct ifnet        *dn_ifp;            
	union {
		struct sockaddr_in      _dn_dst;
		struct sockaddr_in6     _dn_dst6;
	}                   dn_dst_;
	union {
		struct route            _dn_ro; 
		struct route_in6        _dn_ro6;
	}               dn_ro_;
	struct route_in6    dn_ro6_pmtu;        
	struct ifnet        *dn_origifp;        
	u_int32_t           dn_mtu;             
	u_int32_t           dn_unfragpartlen;   
	struct ip6_exthdrs  dn_exthdrs;         
	int                 dn_flags;           
	union {
		struct ip_out_args      _dn_ipoa;
		struct ip6_out_args     _dn_ip6oa;
	}                   dn_ipoa_;
};
struct dn_flow_queue {
	struct dn_flow_queue *next;
	struct ip_flow_id id;

	struct mbuf *head, *tail; 
	u_int len;
	u_int len_bytes;
	u_int32_t numbytes;             

	u_int64_t tot_pkts;     
	u_int64_t tot_bytes;
	u_int32_t drops;

	int hash_slot;          

	int avg;                
	int count;              
	int random;             
	u_int64_t q_time;       

	struct dn_flow_set *fs; 
	int heap_pos;           
	dn_key sched_time;      

	dn_key S, F;            
};
struct dn_flow_set {
	SLIST_ENTRY(dn_flow_set)    next;

	u_short fs_nr;          
	u_short flags_fs;

	struct dn_pipe *pipe;   
	u_short parent_nr;      

	int weight;             
	int qsize;              
	int plr;                

	struct ip_flow_id flow_mask;

	int rq_size;            
	int rq_elements;        
	struct dn_flow_queue **__counted_by_or_null(rq_size + 1) rq; 

	u_int32_t last_expired; 
	int backlogged;         

	int w_q;                
	int max_th;             
	int min_th;             
	int max_p;              
	u_int c_1;              
	u_int c_2;              
	u_int c_3;              
	u_int c_4;              
	u_int * __counted_by_or_null(lookup_depth) w_q_lookup;     
	u_int lookup_depth;     
	int lookup_step;        
	int lookup_weight;      
	int avg_pkt_size;       
	int max_pkt_size;       
};
struct dn_pipe {                
	SLIST_ENTRY(dn_pipe)        next;

	int pipe_nr;            
	int bandwidth;          
	int delay;              

	struct      mbuf *head, *tail;  

	struct dn_heap scheduler_heap; 
	struct dn_heap not_eligible_heap; 
	struct dn_heap idle_heap; 

	dn_key V;               
	int sum;                
	int numbytes;           

	dn_key sched_time;      

	char if_name[IFNAMSIZ];
	struct ifnet *ifp;
	int ready; 

	struct dn_flow_set fs; 
};
struct dn_heap_32 {
	int size;
	int elements;
	int offset; 
	user32_addr_t p; 
};
struct dn_flow_queue_32 {
	user32_addr_t next;
	struct ip_flow_id id;

	user32_addr_t head, tail; 
	u_int len;
	u_int len_bytes;
	u_int32_t numbytes;     

	u_int64_t tot_pkts;     
	u_int64_t tot_bytes;
	u_int32_t drops;

	int hash_slot;                  

	int avg;                
	int count;              
	int random;             
	u_int32_t q_time;       

	user32_addr_t fs; 
	int heap_pos;           
	dn_key sched_time;      

	dn_key S, F;            
};
struct dn_flow_set_32 {
	user32_addr_t       next;

	u_short fs_nr;                  
	u_short flags_fs;

	user32_addr_t pipe;     
	u_short parent_nr;      

	int weight;             
	int qsize;              
	int plr;                

	struct ip_flow_id flow_mask;

	int rq_size;            
	int rq_elements; 
	user32_addr_t rq; 

	u_int32_t last_expired; 
	int backlogged;                 

	int w_q;                
	int max_th;             
	int min_th;             
	int max_p;              
	u_int c_1;              
	u_int c_2;              
	u_int c_3;              
	u_int c_4;              
	user32_addr_t w_q_lookup; 
	u_int lookup_depth;     
	int lookup_step;        
	int lookup_weight;      
	int avg_pkt_size;       
	int max_pkt_size;       
};
struct dn_pipe_32 {             
	user32_addr_t       next;

	int pipe_nr;            
	int bandwidth;          
	int delay;              

	user32_addr_t head, tail; 

	struct dn_heap_32 scheduler_heap; 
	struct dn_heap_32 not_eligible_heap; 
	struct dn_heap_32 idle_heap; 

	dn_key V;               
	int sum;                
	int numbytes;           

	dn_key sched_time; 

	char if_name[IFNAMSIZ];
	user32_addr_t ifp;
	int ready;              

	struct dn_flow_set_32 fs; 
};
struct dn_heap_64 {
	int size;
	int elements;
	int offset; 
	user64_addr_t p; 
};
struct dn_flow_queue_64 {
	user64_addr_t next;
	struct ip_flow_id id;

	user64_addr_t head, tail; 
	u_int len;
	u_int len_bytes;
	u_int32_t numbytes;             

	u_int64_t tot_pkts;             
	u_int64_t tot_bytes;
	u_int32_t drops;

	int hash_slot;                          

	int avg;                
	int count;              
	int random;             
	u_int32_t q_time;       

	user64_addr_t fs;               
	int heap_pos;                           
	dn_key sched_time;              

	dn_key S, F;                            
};
struct dn_flow_set_64 {
	user64_addr_t next;             

	u_short fs_nr;          
	u_short flags_fs;

	user64_addr_t pipe;     
	u_short parent_nr;      

	int weight;             
	int qsize;              
	int plr;                

	struct ip_flow_id flow_mask;

	int rq_size;            
	int rq_elements; 
	user64_addr_t rq; 

	u_int32_t last_expired; 
	int backlogged;                 

	int w_q;                
	int max_th;             
	int min_th;             
	int max_p;              
	u_int c_1;              
	u_int c_2;              
	u_int c_3;              
	u_int c_4;              
	user64_addr_t w_q_lookup; 
	u_int lookup_depth;     
	int lookup_step;        
	int lookup_weight;      
	int avg_pkt_size;       
	int max_pkt_size;       
};
struct dn_pipe_64 {             
	user64_addr_t       next;

	int pipe_nr;            
	int bandwidth;          
	int delay;              

	user64_addr_t head, tail; 

	struct dn_heap_64 scheduler_heap;       
	struct dn_heap_64 not_eligible_heap;    
	struct dn_heap_64 idle_heap;                    

	dn_key V;               
	int sum;                
	int numbytes;           

	dn_key sched_time; 

	char if_name[IFNAMSIZ];
	user64_addr_t ifp;
	int ready; 

	struct dn_flow_set_64 fs; 
};
struct dn_pipe_mini_config {
	uint32_t bandwidth;
	uint32_t delay;
	uint32_t plr;
};
struct dn_rule_mini_config {
	uint32_t dir;
	uint32_t af;
	uint32_t proto;
	uint32_t src_port;
	uint32_t dst_port;
	char ifname[IFXNAMSIZ];
};
struct dummynet_event {
	uint32_t dn_event_code;
	union {
		struct dn_pipe_mini_config _dnev_pipe_config;
		struct dn_rule_mini_config _dnev_rule_config;
	} dn_event;
};
struct encaptabtag {
	void*                   *arg;
};
struct encaptab_tag_container {
	struct m_tag            encaptab_m_tag;
	struct encaptabtag      encaptab_tag;
};
struct encaptab {
	LIST_ENTRY(encaptab) chain;
	int af;
	int proto;                      
	struct sockaddr_storage src;    
	struct sockaddr_storage srcmask;
	struct sockaddr_storage dst;    
	struct sockaddr_storage dstmask;
	int (*func)(const struct mbuf *, int, int, void *);
	const struct protosw *psw;      
	void *arg;                      
};
struct ip_flow_id {
	u_int32_t       dst_ip;
	u_int32_t       src_ip;
	u_int16_t       dst_port;
	u_int16_t       src_port;
	u_int8_t        proto;
	u_int8_t        flags;  
	u_int8_t        addr_type; 
	struct in6_addr dst_ip6;        
	struct in6_addr src_ip6;
	u_int32_t       flow_id6;
	u_int32_t       frag_id6;
};
struct ip_fw_args {
	struct mbuf             *fwa_m;         
	struct ifnet            *fwa_oif;       
	struct pf_rule          *fwa_pf_rule;   
	struct ether_header     *fwa_eh;        
	int                     fwa_flags;      
	int                     fwa_oflags;     
	union {
		struct ip_out_args  *_fwa_ipoa;     
		struct ip6_out_args *_fwa_ip6oa;    
	} fwa_ipoa_;
	union {
		struct route        *_fwa_ro;       
		struct route_in6    *_fwa_ro6;      
	} fwa_ro_;
	union {
		struct sockaddr_in  *_fwa_dst;      
		struct sockaddr_in6 *_fwa_dst6;     
	} fwa_dst_;
	struct route_in6        *fwa_ro6_pmtu;  
	struct ifnet            *fwa_origifp;   
	u_int32_t               fwa_mtu;        
	u_int32_t               fwa_unfragpartlen;  
	struct ip6_exthdrs      *fwa_exthdrs;   
	struct ip_flow_id       fwa_id;         
	u_int32_t               fwa_cookie;
};
struct ip_fw_in_args {
	struct pf_rule          *fwai_pf_rule;  
};
struct icmp_ra_addr {
	u_int32_t ira_addr;
	u_int32_t ira_preference;
};
struct icmp {
	u_char  icmp_type;              
	u_char  icmp_code;              
	u_short icmp_cksum;             
	union {
		u_char ih_pptr;                 
		struct in_addr ih_gwaddr;       
		struct ih_idseq {
			n_short icd_id;
			n_short icd_seq;
		} ih_idseq;
		int ih_void;

		
		struct ih_pmtu {
			n_short ipm_void;
			n_short ipm_nextmtu;
		} ih_pmtu;

		struct ih_rtradv {
			u_char irt_num_addrs;
			u_char irt_wpa;
			u_int16_t irt_lifetime;
		} ih_rtradv;
	} icmp_hun;
	union {
		struct id_ts {
			n_time its_otime;
			n_time its_rtime;
			n_time its_ttime;
		} id_ts;
		struct id_ip  {
			struct ip idi_ip;
			
		} id_ip;
		struct icmp_ra_addr id_radv;
		u_int32_t id_mask;
		char    id_data[1];
	} icmp_dun;
};
struct ip_srcrt {
	struct  in_addr dst;                    
	char    nop;                            
	char    srcopt[IPOPT_OFFSET + 1];       
	struct  in_addr route[MAX_IPOPTLEN / sizeof(struct in_addr)];
} ip_srcrt;
struct pktchain_elm {
	struct mbuf     *pkte_head;
	struct mbuf     *pkte_tail;
	struct in_addr  pkte_saddr;
	struct in_addr  pkte_daddr;
	uint16_t        pkte_npkts;
	uint16_t        pkte_proto;
	uint32_t        pkte_nbytes;
};
struct ip_moptions_dbg {
	struct ip_moptions      imo;                    
	u_int16_t               imo_refhold_cnt;        
	u_int16_t               imo_refrele_cnt;        
	ctrace_t                imo_alloc;
	ctrace_t                imo_free;
	ctrace_t                imo_refhold[IMO_TRACE_HIST_SIZE];
	ctrace_t                imo_refrele[IMO_TRACE_HIST_SIZE];
};
struct ipovly {
	u_char  ih_x1[9];               
	u_char  ih_pr;                  
	u_short ih_len;                 
	struct  in_addr ih_src;         
	struct  in_addr ih_dst;         
};
struct ipq {
	TAILQ_ENTRY(ipq) ipq_list;      
	struct mbuf *ipq_frags;         
	u_char  ipq_ttl;                
	u_char  ipq_p;                  
	u_short ipq_id;                 
	struct  in_addr ipq_src, ipq_dst;
	u_int32_t       ipq_nfrags;     
	uint32_t ipq_csum_flags;        
	uint32_t ipq_csum;              
};
struct ipoption {
	struct  in_addr ipopt_dst;      
	char    ipopt_list[MAX_IPOPTLEN];       
};
struct ip_moptions {
	decl_lck_mtx_data(, imo_lock);
	uint32_t imo_refcnt;            
	uint32_t imo_debug;             
	struct  ifnet *imo_multicast_ifp; 
	u_char  imo_multicast_ttl;      
	u_char  imo_multicast_loop;     
	u_short imo_num_memberships;    
	u_short imo_max_memberships;    
	u_short imo_max_filters;        
	struct  in_multi **__counted_by(imo_max_memberships) imo_membership;
	struct  in_mfilter *__counted_by(imo_max_filters) imo_mfilters;
	u_int32_t imo_multicast_vif;    
	struct  in_addr imo_multicast_addr; 
	void (*imo_trace)               
	(struct ip_moptions *, int);
};
struct ip_fwd_tag {
	struct sockaddr_in *next_hop;   
};
struct  ipstat {
	u_int32_t ips_total;            
	u_int32_t ips_badsum;           
	u_int32_t ips_tooshort;         
	u_int32_t ips_toosmall;         
	u_int32_t ips_badhlen;          
	u_int32_t ips_badlen;           
	u_int32_t ips_fragments;        
	u_int32_t ips_fragdropped;      
	u_int32_t ips_fragtimeout;      
	u_int32_t ips_forward;          
	u_int32_t ips_fastforward;      
	u_int32_t ips_cantforward;      
	u_int32_t ips_redirectsent;     
	u_int32_t ips_noproto;          
	u_int32_t ips_delivered;        
	u_int32_t ips_localout;         
	u_int32_t ips_odropped;         
	u_int32_t ips_reassembled;      
	u_int32_t ips_fragmented;       
	u_int32_t ips_ofragments;       
	u_int32_t ips_cantfrag;         
	u_int32_t ips_badoptions;       
	u_int32_t ips_noroute;          
	u_int32_t ips_badvers;          
	u_int32_t ips_rawout;           
	u_int32_t ips_toolong;          
	u_int32_t ips_notmember;        
	u_int32_t ips_nogif;            
	u_int32_t ips_badaddr;          
	u_int32_t ips_pktdropcntrl;     
	u_int32_t ips_rcv_swcsum;       
	u_int32_t ips_rcv_swcsum_bytes; 
	u_int32_t ips_snd_swcsum;       
	u_int32_t ips_snd_swcsum_bytes; 
	u_int32_t ips_adj;              
	u_int32_t ips_adj_hwcsum_clr;   
	u_int32_t ips_rxc_collisions;   
	u_int32_t ips_rxc_chained;      
	u_int32_t ips_rxc_notchain;     
	u_int32_t ips_rxc_chainsz_gt2;  
	u_int32_t ips_rxc_chainsz_gt4;  
	u_int32_t ips_rxc_notlist;      
	u_int32_t ips_raw_sappend_fail; 
	u_int32_t ips_necp_policy_drop; 
	u_int32_t ips_rcv_if_weak_match; 
	u_int32_t ips_rcv_if_no_match;  
	u_int32_t ips_input_ipf_drop;   
	u_int32_t ips_input_no_proto;   
	u_int32_t ips_src_addr_not_avail; 
};
struct ip_linklocal_stat {
	u_int32_t       iplls_in_total;
	u_int32_t       iplls_in_badttl;
	u_int32_t       iplls_out_total;
	u_int32_t       iplls_out_badttl;
};
struct ip_out_args {
	unsigned int    ipoa_boundif;   
	struct flowadv  ipoa_flowadv;   
	u_int32_t       ipoa_flags;     
	int             ipoa_sotc;      
	int             ipoa_netsvctype; 
	int32_t         qos_marking_gencount;
};
struct isakmp {
	cookie_t i_ck;          
	cookie_t r_ck;          
	uint8_t np;             
	uint8_t vers;
	uint8_t etype;          
	uint8_t flags;          
	msgid_t msgid;
	uint32_t len;           
};
struct isakmp_gen {
	uint8_t  np;       
	uint8_t  critical; 
	uint16_t len;      
};
struct ipfilt_tag_container {
	struct m_tag    ipft_m_tag;
	ipfilter_t      ipft_filter_ref;
};
struct ipf_pktopts {
	u_int32_t                       ippo_flags;
	ifnet_t                         ippo_mcast_ifnet;
	int                             ippo_mcast_loop;
	u_int8_t                        ippo_mcast_ttl;
};
struct ipf_filter {
	void            *cookie;
	const char      *name;
	ipf_input_func  ipf_input;
	ipf_output_func ipf_output;
	ipf_detach_func ipf_detach;
};
struct ipfilter {
	TAILQ_ENTRY(ipfilter)   ipf_link;
	struct ipf_filter       ipf_filter;
	struct ipfilter_list    *ipf_head;
	TAILQ_ENTRY(ipfilter)   ipf_tbr;
	uint32_t                ipf_flags;
};
struct mptcp_mpcapable_opt_common {
	uint8_t        mmco_kind;
	uint8_t        mmco_len;
	uint8_t        mmco_version:4,
	    mmco_subtype:4;
	uint8_t        mmco_flags;
} __attribute__((__packed__));
struct mptcp_mpcapable_opt_rsp {
	struct mptcp_mpcapable_opt_common mmc_common;
	mptcp_key_t mmc_localkey;
} __attribute__((__packed__));
struct mptcp_mpcapable_opt_rsp1 {
	struct mptcp_mpcapable_opt_common mmc_common;
	mptcp_key_t mmc_localkey;
	mptcp_key_t mmc_remotekey;
} __attribute__((__packed__));
struct mptcp_mpcapable_opt_rsp2 {
	struct mptcp_mpcapable_opt_rsp1 mmc_rsp1;
	uint16_t data_len;
	uint16_t csum;
} __attribute__((__packed__));
struct mptcp_mpjoin_opt_req {
	uint8_t        mmjo_kind;
	uint8_t        mmjo_len;
	uint8_t        mmjo_subtype_bkp;
	uint8_t        mmjo_addr_id;
	uint32_t       mmjo_peer_token;
	uint32_t       mmjo_rand;
} __attribute__((__packed__));
struct mptcp_mpjoin_opt_rsp {
	uint8_t        mmjo_kind;
	uint8_t        mmjo_len;
	uint8_t        mmjo_subtype_bkp;
	uint8_t        mmjo_addr_id;
	uint64_t       mmjo_mac; 
	uint32_t       mmjo_rand;
} __attribute__((__packed__));
struct mptcp_mpjoin_opt_rsp2 {
	uint8_t        mmjo_kind;
	uint8_t        mmjo_len;
	uint8_t        mmjo_reserved1:4,
	    mmjo_subtype:4;
	uint8_t        mmjo_reserved2;
	uint8_t        mmjo_mac[HMAC_TRUNCATED_ACK]; 
} __attribute__((__packed__));
struct mptcp_remaddr_opt {
	uint8_t        mr_kind;
	uint8_t        mr_len;
	uint8_t        mr_rest:4,
	    mr_subtype:4;
	uint8_t        mr_addr_id;
} __attribute__((__packed__));
struct mptcp_dss_copt {
	uint8_t        mdss_kind;
	uint8_t        mdss_len;
	uint8_t        mdss_reserved1:4,
	    mdss_subtype:4;
	uint8_t        mdss_flags;
}__attribute__((__packed__));
struct mptcp_dsn_opt {
	struct mptcp_dss_copt   mdss_copt;
	uint32_t       mdss_dsn;               
	uint32_t       mdss_subflow_seqn;      
	uint16_t       mdss_data_len;          
			
}__attribute__((__packed__));
struct mptcp_dsn64_opt {
	struct mptcp_dss_copt   mdss_copt;
	uint64_t       mdss_dsn;               
	uint32_t       mdss_subflow_seqn;      
	uint16_t       mdss_data_len;          
			
}__attribute__((__packed__));
struct mptcp_data_ack_opt {
	struct mptcp_dss_copt   mdss_copt;
	uint32_t               mdss_ack;
}__attribute__((__packed__));
struct mptcp_data_ack64_opt {
	struct mptcp_dss_copt   mdss_copt;
	uint64_t               mdss_ack;
}__attribute__((__packed__));
struct mptcp_dss_ack_opt {
	struct mptcp_dss_copt   mdss_copt;
	uint32_t       mdss_ack;               
	uint32_t       mdss_dsn;               
	uint32_t       mdss_subflow_seqn;      
	uint16_t       mdss_data_len;          
			
}__attribute__((__packed__));
struct mptcp_dss64_ack64_opt {
	struct mptcp_dss_copt   mdss_copt;
	uint64_t       mdss_ack;               
	uint64_t       mdss_dsn;               
	uint32_t       mdss_subflow_seqn;      
	uint16_t       mdss_data_len;          
			
}__attribute__((__packed__));
struct mptcp_dss32_ack64_opt {
	struct mptcp_dss_copt   mdss_copt;
	uint64_t       mdss_ack;               
	uint32_t       mdss_dsn;               
	uint32_t       mdss_subflow_seqn;      
	uint16_t       mdss_data_len;          
			
}__attribute__((__packed__));
struct mptcp_dss64_ack32_opt {
	struct mptcp_dss_copt   mdss_copt;
	uint32_t       mdss_ack;               
	uint64_t       mdss_dsn;               
	uint32_t       mdss_subflow_seqn;      
	uint16_t       mdss_data_len;          
			
}__attribute__((__packed__));
struct mptcp_fastclose_opt {
	uint8_t        mfast_kind;
	uint8_t        mfast_len;
	uint8_t        mfast_reserved:4,
	    mfast_subtype:4;
	uint8_t        mfast_reserved1;
	uint64_t       mfast_key;              
}__attribute__((__packed__));
struct mptcp_mpfail_opt {
	uint8_t        mfail_kind;
	uint8_t        mfail_len;
	uint8_t        mfail_reserved:4,
	    mfail_subtype:4;
	uint8_t        mfail_reserved1:8;
	uint64_t       mfail_dsn;
}__attribute__((__packed__));
struct mptcp_add_addr_opt {
	uint8_t         maddr_kind;
	uint8_t         maddr_len;
	uint8_t         maddr_flags:4,
	    maddr_subtype:4;
	uint8_t         maddr_addrid;
	union {
		struct {
			struct in_addr maddr_addrv4;
			uint32_t maddr_pad[3];
		};

		struct {
			struct in6_addr maddr_addrv6;
		};
	} maddr_u;
}__attribute__((__packed__));
struct mptcp_add_addr_hmac_msg_v4 {
	uint8_t         maddr_addrid;
	struct in_addr maddr_addr;
	uint16_t maddr_port;
}__attribute__((__packed__));
struct mptcp_add_addr_hmac_msg_v6 {
	uint8_t         maddr_addrid;
	struct in6_addr maddr_addr;
	uint16_t maddr_port;
}__attribute__((__packed__));
struct mptcp_mpprio_addr_opt {
	uint8_t        mpprio_kind;
	uint8_t        mpprio_len;
	uint8_t        mpprio_flags:4,
	    mpprio_subtype:4;
	uint8_t        mpprio_addrid;
}__attribute__((__packed__));
struct mptcp_subflow_event_entry {
	uint32_t    sofilt_hint_mask;
	ev_ret_t    (*sofilt_hint_ev_hdlr)(
		struct mptses *mpte,
		struct mptsub *mpts,
		uint32_t *p_mpsofilt_hint,
		uint32_t event);
} mptsub_ev_entry_t;
struct mptcp_uuid_search_info {
	uuid_t target_uuid;
	proc_t found_proc;
	boolean_t is_proc_found;
};
struct mpt_itf_info {
	uint32_t ifindex;
	uint32_t has_v4_conn:1,
	    has_v6_conn:1,
	    has_nat64_conn:1,
	    no_mptcp_support:1;
};
struct mptses {
	struct mppcb    *mpte_mppcb;            
	struct mptcb    *mpte_mptcb;            
	TAILQ_HEAD(, mptopt) mpte_sopts;        
	TAILQ_HEAD(, mptsub) mpte_subflows;     
	uint16_t        mpte_numflows;          
	uint16_t        mpte_nummpcapflows;     
	sae_associd_t   mpte_associd;           
	sae_connid_t    mpte_connid_last;       

	uint64_t        mpte_time_target;
	thread_call_t   mpte_time_thread;
	thread_call_t   mpte_stop_urgency;

	uint32_t        mpte_last_cellicon_set;
	uint32_t        mpte_cellicon_increments;

	union {
		
		struct sockaddr _mpte_src;
		struct sockaddr_in _mpte_src_v4;
		struct sockaddr_in6 _mpte_src_v6;
	} mpte_u_src;
	union {
		
		struct sockaddr _mpte_dst;
		struct sockaddr_in _mpte_dst_v4;
		struct sockaddr_in6 _mpte_dst_v6;
	} mpte_u_dst;

	struct sockaddr_in      mpte_sub_dst_v4;
	struct sockaddr_in6     mpte_sub_dst_v6;
	uint8_t         sub_dst_addr_id_v4;
	uint8_t         sub_dst_addr_id_v6;

	uint16_t        mpte_alternate_port;    

	int mpte_epid;
	uuid_t mpte_euuid;

	struct mptsub   *mpte_active_sub;       
	uint16_t mpte_flags;                    
	uint8_t mpte_svctype;                   
	uint8_t mpte_lost_aid;                  
	uint8_t mpte_addrid_last;               

	uint32_t        mpte_itfinfo_size;
	struct mpt_itf_info     _mpte_itfinfo[MPTE_ITFINFO_SIZE];
	struct mpt_itf_info     *mpte_itfinfo __counted_by(mpte_itfinfo_size);

	struct mbuf             *mpte_reinjectq;

	uint32_t        mpte_subflow_switches;  
	uint32_t        mpte_used_cell:1,
	    mpte_used_wifi:1,
	    mpte_initial_cell:1,
	    mpte_triggered_cell,
	    mpte_handshake_success:1,
	    mpte_last_added_addr_is_v4:1;

	struct mptcp_itf_stats  mpte_itfstats[MPTCP_ITFSTATS_SIZE];
	uint64_t                mpte_init_txbytes __attribute__((aligned(8)));
	uint64_t                mpte_init_rxbytes __attribute__((aligned(8)));
};
struct mptopt {
	TAILQ_ENTRY(mptopt)     mpo_entry;      
	uint32_t                mpo_flags;      
	int                     mpo_level;      
	int                     mpo_name;       
	int                     mpo_intval;     
};
struct mptsub {
	TAILQ_ENTRY(mptsub)   mpts_entry;     
	uint32_t              mpts_refcnt;    
	uint32_t              mpts_flags;     
	uint32_t              mpts_evctl;     
	sae_connid_t          mpts_connid;    
	int                   mpts_oldintval; 
	struct mptses         *mpts_mpte;     
	struct socket         *mpts_socket;   
	struct sockaddr       *mpts_src;      

	union {
		
		struct sockaddr         _mpts_dst;
		struct sockaddr_in      _mpts_dst_v4;
		struct sockaddr_in6     _mpts_dst_v6;
	} mpts_u_dst;
	u_int32_t               mpts_rel_seq;   
	u_int32_t               mpts_iss;       
	u_int32_t               mpts_ifscope;   
	uint32_t                mpts_probesoon; 
	uint32_t                mpts_probecnt;  
	uint32_t                mpts_maxseg;    
};
struct mptcp_subf_auth_entry {
	LIST_ENTRY(mptcp_subf_auth_entry) msae_next;
	u_int32_t       msae_laddr_rand;        
	u_int32_t       msae_raddr_rand;        
	mptcp_addr_id   msae_laddr_id;          
	mptcp_addr_id   msae_raddr_id;          
};
struct mptcb {
	struct mptses  *mpt_mpte;               
	mptcp_state_t   mpt_state;              
	uint32_t        mpt_flags;              
	uint8_t         mpt_version;            
	u_short         mpt_softerror;          
	mptcp_key_t     mpt_localkey;           
	mptcp_key_t     mpt_remotekey;          
	mptcp_token_t   mpt_localtoken;         
	mptcp_token_t   mpt_remotetoken;        

	int             mpt_rxtshift;           
	uint64_t        mpt_rxtstart;           
	uint64_t        mpt_rtseq;              
	uint64_t        mpt_timewait;           
	uint32_t        mpt_timer_vals;         
	uint64_t        mpt_snduna;             
	uint64_t        mpt_sndnxt;             
	uint64_t        mpt_sndmax;             
	uint64_t        mpt_local_idsn;         
	uint32_t        mpt_sndwnd;
	uint64_t        mpt_sndwl1;
	uint64_t        mpt_sndwl2;
	uint64_t        mpt_rcvnxt;             
	uint64_t        mpt_remote_idsn;        
	uint64_t        mpt_rcvadv;
	uint32_t        mpt_rcvwnd;
	LIST_HEAD(, mptcp_subf_auth_entry) mpt_subauth_list; 
	uint64_t        mpt_dsn_at_csum_fail;   
	uint32_t        mpt_ssn_at_csum_fail;   
	int32_t         mpt_gc_ticks;           

	uint32_t        mpt_notsent_lowat;      

	struct tsegqe_head      mpt_segq;
	uint32_t        mpt_reassqlen;          
};
struct mpp_mtp {
	struct mppcb            mpp;            
	struct mptses           mpp_ses;        
	struct mptcb            mtcb;           
};
struct mptcp_flow {
	uint64_t                flow_len;
	uint64_t                flow_tcpci_offset;
	uint32_t                flow_flags;
	sae_connid_t            flow_cid;
	struct sockaddr_storage flow_src;
	struct sockaddr_storage flow_dst;
	uint32_t                flow_relseq;    
	int32_t                 flow_soerror;   
	uint32_t                flow_probecnt;  
	conninfo_tcp_t          flow_ci;        
} mptcp_flow_t;
struct conninfo_mptcp {
	uint64_t        mptcpci_len;
	uint64_t        mptcpci_flow_offset;    
	uint64_t        mptcpci_nflows;         
	uint32_t        mptcpci_state;          
	uint32_t        mptcpci_mpte_flags;     
	uint32_t        mptcpci_flags;          
	uint32_t        mptcpci_ltoken;         
	uint32_t        mptcpci_rtoken;         
	uint32_t        mptcpci_notsent_lowat;  

	uint64_t        mptcpci_snduna;         
	uint64_t        mptcpci_sndnxt;         
	uint64_t        mptcpci_sndmax;         
	uint64_t        mptcpci_lidsn;          
	uint32_t        mptcpci_sndwnd;         

	uint64_t        mptcpci_rcvnxt;         
	uint64_t        mptcpci_rcvatmark;      
	uint64_t        mptcpci_ridsn;          
	uint32_t        mptcpci_rcvwnd;         

	uint8_t         mptcpci_mpte_addrid;    

	mptcp_flow_t    mptcpci_flows[1];
} conninfo_mptcp_t;
struct symptoms_advisory {
	union {
		uint32_t        sa_nwk_status_int;
		struct {
			union {
				uint16_t        sa_nwk_status;
				struct {
					uint8_t sa_wifi_status;
					uint8_t sa_cell_status;
				};
			};
			uint16_t        sa_unused;
		};
	};
} symptoms_advisory_t;
struct mptcp_symptoms_answer {
	struct symptoms_advisory advisory;
	uuid_t  uuid;
	int32_t rssi;
};
struct mptcp_symptoms_ask_uuid {
	uint32_t        cmd;
	uuid_t          uuid;
	uint32_t        priority;
};
struct kev_mptcp_data {
	int value;
};
struct mppcb {
	TAILQ_ENTRY(mppcb)      mpp_entry;      
	decl_lck_mtx_data(, mpp_lock);          
	struct mppcbinfo        *mpp_pcbinfo;   
	struct mptses           *mpp_pcbe;      
	struct socket           *mpp_socket;    
	uint32_t                mpp_flags;      
	mppcb_state_t           mpp_state;      
	int32_t                 mpp_inside;     

	uuid_t necp_client_uuid;
	struct inp_necp_attributes inp_necp_attributes;
	void (*necp_cb)(void *, int, uint32_t, uint32_t, bool *);
};
struct mppcbinfo {
	TAILQ_ENTRY(mppcbinfo)  mppi_entry;     
	TAILQ_HEAD(, mppcb)     mppi_pcbs;      
	uint32_t                mppi_count;     
	lck_attr_t              mppi_lock_attr; 
	struct mppcb         *(*mppi_alloc)(void);
	void                  (*mppi_free)(struct mppcb *);
	lck_grp_t              *mppi_lock_grp;  
	decl_lck_mtx_data(, mppi_lock);         
	uint32_t (*mppi_gc)(struct mppcbinfo *); 
	uint32_t (*mppi_timer)(struct mppcbinfo *); 
};
struct tcpiphdr {
	struct  ipovly ti_i;            
	struct  tcphdr ti_t;            
};
struct tcp_heuristic_key {
	union {
		uint8_t thk_net_signature[IFNET_SIGNATURELEN];
		in_4_6_addr thk_ip;
	};
	sa_family_t     thk_family;
};
struct tcp_heuristic {
	SLIST_ENTRY(tcp_heuristic) list;

	uint32_t        th_last_access;

	struct tcp_heuristic_key        th_key;

	uint8_t         th_tfo_data_loss; 
	uint8_t         th_tfo_req_loss; 
	uint8_t         th_tfo_data_rst; 
	uint8_t         th_tfo_req_rst; 
	uint8_t         th_mptcp_loss; 
	uint8_t         th_mptcp_success; 
	uint8_t         th_ecn_loss; 
	uint8_t         th_ecn_aggressive; 
	uint8_t         th_ecn_droprst; 
	uint8_t         th_ecn_droprxmt; 
	uint8_t         th_ecn_synrst;  
	uint32_t        th_tfo_enabled_time; 
	uint32_t        th_tfo_backoff_until; 
	uint32_t        th_tfo_backoff; 
	uint32_t        th_mptcp_backoff; 
	uint32_t        th_ecn_backoff; 

	uint8_t         th_tfo_in_backoff:1, 
	    th_mptcp_in_backoff:1,             
	    th_mptcp_heuristic_disabled:1;             
};
struct tcp_heuristics_head {
	SLIST_HEAD(tcp_heur_bucket, tcp_heuristic) tcp_heuristics;

	lck_mtx_t       thh_mtx;
};
struct tcp_cache_key {
	sa_family_t     tck_family;

	struct tcp_heuristic_key tck_src;
	in_4_6_addr tck_dst;
};
struct tcp_cache {
	SLIST_ENTRY(tcp_cache) list;

	uint32_t       tc_last_access;

	struct tcp_cache_key tc_key;

	uint8_t        tc_tfo_cookie[TFO_COOKIE_LEN_MAX];
	uint8_t        tc_tfo_cookie_len;

	uint8_t        tc_mptcp_version_confirmed:1;
	uint8_t        tc_mptcp_version; 
	uint32_t       tc_mptcp_next_version_try; 
};
struct tcp_cache_head {
	SLIST_HEAD(tcp_cache_bucket, tcp_cache) tcp_caches;

	lck_mtx_t       tch_mtx;
};
struct tcp_cache_key_src {
	struct ifnet *ifp;
	in_4_6_addr laddr;
	in_4_6_addr faddr;
	int af;
};
struct tcp_cc_debug_state {
	u_int64_t ccd_tsns;
	char ccd_srcaddr[INET6_ADDRSTRLEN];
	uint16_t ccd_srcport;
	char ccd_destaddr[INET6_ADDRSTRLEN];
	uint16_t ccd_destport;
	uint32_t ccd_snd_cwnd;
	uint32_t ccd_snd_wnd;
	uint32_t ccd_snd_ssthresh;
	uint32_t ccd_pipeack;
	uint32_t ccd_rttcur;
	uint32_t ccd_rxtcur;
	uint32_t ccd_srtt;
	uint32_t ccd_event;
	uint32_t ccd_sndcc;
	uint32_t ccd_sndhiwat;
	uint32_t ccd_bytes_acked;
	u_int8_t ccd_cc_index;
	u_int8_t ccd_unused_1__;
	u_int16_t ccd_unused_2__;
	union {
		struct {
			uint32_t ccd_last_max;
			uint32_t ccd_tcp_win;
			uint32_t ccd_target_win;
			uint32_t ccd_avg_lastmax;
			uint32_t ccd_mean_deviation;
		} cubic_state;
		struct {
			u_int32_t led_base_rtt;
		} ledbat_state;
	} u;
};
struct tcp_cc_algo {
	char name[TCP_CA_NAME_MAX];
	_Atomic uint32_t num_sockets;
	uint32_t flags;

	int (*init) (struct tcpcb *tp);

	int (*cleanup) (struct tcpcb *tp);

	void (*cwnd_init) (struct tcpcb *tp);

	void (*congestion_avd) (struct tcpcb *tp, struct tcphdr *th);

	void (*ack_rcvd) (struct tcpcb *tp, struct tcphdr *th);

	void (*pre_fr) (struct tcpcb *tp);

	void (*post_fr) (struct tcpcb *tp, struct tcphdr *th);

	void (*after_idle) (struct tcpcb *tp);

	void (*after_timeout) (struct tcpcb *tp);

	int (*delay_ack)(struct tcpcb *tp, struct tcphdr *th);

	void (*process_ecn) (struct tcpcb *tp, struct tcphdr *th, uint32_t new_bytes_marked, uint32_t packets_marked, uint32_t packets_acked);

	void (*set_bytes_acked) (struct tcpcb *tp, uint32_t acked);

	void (*switch_to)(struct tcpcb *tp);
} __attribute__((aligned(4)));
struct tcp_rcv_cc_algo {
	char name[TCP_CA_NAME_MAX];
	_Atomic uint32_t num_sockets;
	uint32_t flags;

	void (*init) (struct tcpcb *tp);

	void (*cleanup) (struct tcpcb *tp);

	void (*rwnd_init) (struct tcpcb *tp);

	void (*data_rcvd) (struct tcpcb *tp, struct tcphdr *th,
	    struct tcpopt *to, uint32_t segment_len);

	uint32_t (*get_rlwin) (struct tcpcb *tp);

	void (*after_idle) (struct tcpcb *tp);

	void (*switch_to) (struct tcpcb *tp);
} __attribute__((aligned(4)));
struct  inp_tp {
	struct  inpcb   inp;
	struct  tcpcb   tcb __attribute__((aligned(ALIGNMENT)));
};
struct tcp_last_report_stats {
	u_int32_t       tcps_connattempt;
	u_int32_t       tcps_accepts;
	u_int32_t       tcps_ecn_client_setup;
	u_int32_t       tcps_ecn_server_setup;
	u_int32_t       tcps_ecn_client_success;
	u_int32_t       tcps_ecn_server_success;
	u_int32_t       tcps_ecn_not_supported;
	u_int32_t       tcps_ecn_lost_syn;
	u_int32_t       tcps_ecn_lost_synack;
	u_int32_t       tcps_ecn_recv_ce;
	u_int32_t       tcps_ecn_recv_ece;
	u_int32_t       tcps_ecn_sent_ece;
	u_int32_t       tcps_ecn_conn_recv_ce;
	u_int32_t       tcps_ecn_conn_recv_ece;
	u_int32_t       tcps_ecn_conn_plnoce;
	u_int32_t       tcps_ecn_conn_pl_ce;
	u_int32_t       tcps_ecn_conn_nopl_ce;
	u_int32_t       tcps_ecn_fallback_synloss;
	u_int32_t       tcps_ecn_fallback_reorder;
	u_int32_t       tcps_ecn_fallback_ce;

	u_int32_t       tcps_tfo_syn_data_rcv;
	u_int32_t       tcps_tfo_cookie_req_rcv;
	u_int32_t       tcps_tfo_cookie_sent;
	u_int32_t       tcps_tfo_cookie_invalid;
	u_int32_t       tcps_tfo_cookie_req;
	u_int32_t       tcps_tfo_cookie_rcv;
	u_int32_t       tcps_tfo_syn_data_sent;
	u_int32_t       tcps_tfo_syn_data_acked;
	u_int32_t       tcps_tfo_syn_loss;
	u_int32_t       tcps_tfo_blackhole;
	u_int32_t       tcps_tfo_cookie_wrong;
	u_int32_t       tcps_tfo_no_cookie_rcv;
	u_int32_t       tcps_tfo_heuristics_disable;
	u_int32_t       tcps_tfo_sndblackhole;

	u_int32_t       tcps_mptcp_handover_attempt;
	u_int32_t       tcps_mptcp_interactive_attempt;
	u_int32_t       tcps_mptcp_aggregate_attempt;
	u_int32_t       tcps_mptcp_fp_handover_attempt;
	u_int32_t       tcps_mptcp_fp_interactive_attempt;
	u_int32_t       tcps_mptcp_fp_aggregate_attempt;
	u_int32_t       tcps_mptcp_heuristic_fallback;
	u_int32_t       tcps_mptcp_fp_heuristic_fallback;
	u_int32_t       tcps_mptcp_handover_success_wifi;
	u_int32_t       tcps_mptcp_handover_success_cell;
	u_int32_t       tcps_mptcp_interactive_success;
	u_int32_t       tcps_mptcp_aggregate_success;
	u_int32_t       tcps_mptcp_fp_handover_success_wifi;
	u_int32_t       tcps_mptcp_fp_handover_success_cell;
	u_int32_t       tcps_mptcp_fp_interactive_success;
	u_int32_t       tcps_mptcp_fp_aggregate_success;
	u_int32_t       tcps_mptcp_handover_cell_from_wifi;
	u_int32_t       tcps_mptcp_handover_wifi_from_cell;
	u_int32_t       tcps_mptcp_interactive_cell_from_wifi;
	u_int64_t       tcps_mptcp_handover_cell_bytes;
	u_int64_t       tcps_mptcp_interactive_cell_bytes;
	u_int64_t       tcps_mptcp_aggregate_cell_bytes;
	u_int64_t       tcps_mptcp_handover_all_bytes;
	u_int64_t       tcps_mptcp_interactive_all_bytes;
	u_int64_t       tcps_mptcp_aggregate_all_bytes;
	u_int32_t       tcps_mptcp_back_to_wifi;
	u_int32_t       tcps_mptcp_wifi_proxy;
	u_int32_t       tcps_mptcp_cell_proxy;
	u_int32_t       tcps_mptcp_triggered_cell;
};
struct tcptimerentry {
	LIST_ENTRY(tcptimerentry) le;   
	uint32_t timer_start;   
	uint16_t index;         
	uint16_t mode;          
	uint32_t runtime;       
};
struct tcptimerlist {
	struct timerlisthead lhead;     
	lck_mtx_t mtx;          
	lck_grp_t *mtx_grp;     
	thread_call_t call;     
	uint32_t runtime;       
	uint32_t schedtime;     
	uint32_t entries;       
	uint32_t maxentries;    

	boolean_t running;      
	boolean_t scheduled;    
	uint32_t mode;          
	uint32_t pref_mode;     
	uint32_t pref_offset;   
	uint32_t idleruns;      
	struct tcptimerentry *next_te;  
	u_int16_t probe_if_index; 
};
struct tcp_globals {};
struct tseg_qent {
	LIST_ENTRY(tseg_qent) tqe_q;
	int     tqe_len;                
	struct  tcphdr *tqe_th;         
	struct  mbuf    *tqe_m;         
};
struct sackblk {
	tcp_seq start;          
	tcp_seq end;            
};
struct sackhole {
	tcp_seq start;          
	tcp_seq end;            
	tcp_seq rxmit;          
	u_int32_t rxmit_start;  
	TAILQ_ENTRY(sackhole) scblink;  
};
struct sackhint {
	struct sackhole *nexthole;
	int     sack_bytes_rexmit;
	int sack_bytes_acked;
};
struct tcp_rxt_seg {
	tcp_seq rx_start;
	tcp_seq rx_end;
	u_int16_t rx_count;
	u_int16_t rx_flags;
	SLIST_ENTRY(tcp_rxt_seg) rx_link;
};
struct tcp_seg_sent {
	tcp_seq start_seq;
	tcp_seq end_seq;        
	uint32_t xmit_ts;
	uint8_t flags;
	uint8_t pad[3];

	TAILQ_ENTRY(tcp_seg_sent) tx_link; 
	RB_ENTRY(tcp_seg_sent)    seg_link; 
	TAILQ_ENTRY(tcp_seg_sent) ack_link; 
	TAILQ_ENTRY(tcp_seg_sent) free_link; 
};
struct tcp_seg_pool {
	TAILQ_HEAD(, tcp_seg_sent) free_segs;
	uint32_t free_segs_count;
	char pad[4];
} *tcp_seg_pool_t;
struct tcp_notify_ack_marker {
	tcp_seq notify_snd_una; 
	tcp_notify_ack_id_t notify_id;
	SLIST_ENTRY(tcp_notify_ack_marker) notify_next;
};
struct tcptemp {
	u_char  tt_ipgen[40]; 
	struct  tcphdr tt_t;
};
struct bwmeas {
	tcp_seq bw_start;       
	uint32_t bw_ts;         
	uint32_t bw_size;       
	uint32_t bw_minsizepkts; 
	uint32_t bw_maxsizepkts; 
	uint32_t bw_minsize;    
	uint32_t bw_maxsize;    
	uint32_t bw_sndbw;      
	uint32_t bw_sndbw_max;  
	uint32_t bw_rcvbw_max;  
};
struct mpt_dsn_map {
	uint64_t                mpt_dsn;        
	uint32_t                mpt_sseq;       
	uint16_t                mpt_len;        
	uint16_t                mpt_csum;       
	uint8_t                 mpt_dfin;       
};
struct tcp_ccstate {
	union {
		struct tcp_cubic_state {
			u_int32_t tc_last_max;  
			u_int32_t tc_epoch_start; 
			u_int32_t tc_origin_point; 
			u_int32_t tc_tcp_win; 
			u_int32_t tc_tcp_bytes_acked; 
			u_int32_t tc_avg_lastmax; 
			u_int32_t tc_mean_deviation; 
			float     tc_epoch_period; 
		} _cubic_state_;
		struct tcp_prague_state {
			uint16_t num_cong_events_loss;
			uint16_t num_cong_events_ce;
			uint32_t packets_acked;   
			uint32_t packets_marked;  
			uint32_t ce_counter;      
			uint32_t bytes_acked;     
			uint32_t snd_nxt_alpha;   
			uint32_t snd_nxt_cwr;     
			uint8_t ever_saw_ce:1,       
			    in_loss:1,                       
			    reduced_due_to_ce:1,             
			    unused:5;
			uint8_t pad[3];
			uint64_t scaled_alpha;    
			uint64_t alpha_ai;        
			
			struct tcp_cubic_state cubic_state;
		} _prague_state_;
		struct tcp_ledbat_state {
			uint32_t num_slowdown_events;
			uint32_t slowdown_ts;
			uint32_t slowdown_begin;
			uint32_t md_bytes_acked;
		} _ledbat_state_;
	} __u__;
};
struct tcp_rledbat_state {
	uint32_t num_slowdown_events;  
	uint32_t slowdown_ts;          
	uint32_t slowdown_begin;       
	uint32_t reduction_end;        
	uint32_t rcvd_bytes;           
	uint32_t md_rcvd_bytes;        
	uint32_t win;                  
	uint32_t ssthresh;             
	uint32_t drained_bytes;        
	uint32_t win_ws;               
};
struct accecn {
	uint32_t        t_rcv_ce_packets;                  
	uint32_t        t_snd_ce_packets;                  
	uint32_t        t_delta_ce_packets;                
	uint8_t         accecn_processed:1,                
	    unused:7;

	uint64_t        t_rcv_ect1_bytes;                  
	uint64_t        t_rcv_ect0_bytes;                  
	uint64_t        t_rcv_ce_bytes;                    
	uint64_t        t_snd_ect1_bytes;                  
	uint64_t        t_snd_ect0_bytes;                  
	uint64_t        t_snd_ce_bytes;                    
};
struct pacer {
	uint64_t rate;
	uint32_t tso_burst_size; 
	uint32_t current_size; 
	uint64_t packet_tx_time;
};
struct tcpcb {
	struct tsegqe_head t_segq;
	uint32_t t_dupacks;             
	int      t_state;               
	uint32_t t_timer[TCPT_NTIMERS]; 
	struct tcptimerentry tentry;    

	struct  inpcb *t_inpcb;         
	uint32_t        t_flags;

	tcp_seq snd_una;                
	tcp_seq snd_max;                
	tcp_seq snd_nxt;                
	tcp_seq snd_up;                 

	tcp_seq snd_wl1;                
	tcp_seq snd_wl2;                
	tcp_seq iss;                    
	tcp_seq irs;                    

	tcp_seq rcv_nxt;                
	tcp_seq rcv_adv;                
	uint32_t        rcv_wnd;        
	uint32_t        t_last_recwin;
	tcp_seq rcv_up;                 

	uint32_t        snd_wnd;        
	uint32_t        snd_cwnd;       
	uint32_t        snd_ssthresh;   
	tcp_seq snd_recover;            

	uint32_t        t_maxopd;       
	uint32_t        t_rcvtime;      
	uint32_t        t_sndtime;      
	uint32_t        t_starttime;    
	int     t_rtttime;              
	tcp_seq t_rtseq;                

	uint32_t rfbuf_ts;              
	uint32_t rfbuf_cnt;             
	uint32_t rfbuf_space;           

	int            t_rxtcur;        
	unsigned int   t_maxseg;        
	int            t_srtt;          
	int            t_rttvar;        

	uint64_t t_accsleep_ms;         
	uint32_t t_reassqlen;           
	uint32_t t_reassq_mbcnt;        
	uint16_t t_rxtshift;            
	uint32_t t_rttmin;              
	uint32_t t_rttbest;             
	uint32_t t_rttcur;              
	uint32_t t_rttupdated;          
	uint32_t t_rxt_conndroptime;    
	uint32_t t_rxtstart;            
	uint32_t max_sndwnd;            

	int     t_softerror;            

	char    t_oobflags;             
	char    t_iobc;                 

	u_int8_t        snd_scale;      
	u_int8_t        rcv_scale;      
	u_int8_t        request_r_scale; 
	u_int8_t        requested_s_scale;
	u_int8_t        tcp_cc_index;   
	u_int8_t        t_adaptive_rtimo;       
	u_int8_t        t_adaptive_wtimo;       
	u_int8_t        t_stretchack_delayed;   


	u_int16_t       t_early_rexmt_count; 
	u_int32_t       t_early_rexmt_win; 

	u_int32_t       ts_recent;      

	u_int32_t       ts_recent_age;  
	tcp_seq last_ack_sent;

	uint32_t        t_bytes_acked;  
	uint32_t        total_ect_packets_marked; 
	uint32_t        total_ect_packets_acked;  

	int             t_lastchain;    
	uint16_t        t_unacksegs;    
	uint16_t        t_unacksegs_ce; 

	uint16_t        t_forced_acks;  
	uint8_t         t_rexmtthresh;  
	uint8_t         t_rtimo_probes; 
	uint32_t        t_persist_timeout; 
	uint32_t        t_persist_stop;    
	uint32_t        t_notsent_lowat;   


	u_int32_t       rcv_unackwin;   
	u_int32_t       rcv_by_unackwin; 
	u_int32_t       rcv_by_unackhalfwin;
	u_int32_t       rcv_nostrack_ts; 
	u_int32_t       rcv_nostrack_pkts; 
	u_int16_t       rcv_waitforss;  


	u_int32_t       ecn_flags;

	u_int32_t       t_ecn_recv_ce;  
	u_int32_t       t_ecn_recv_cwr; 
	uint32_t        t_client_accecn_state;    
	uint32_t        t_server_accecn_state;    
	uint64_t        t_ecn_capable_packets_sent;     
	uint64_t        t_ecn_capable_packets_acked;    
	uint64_t        t_ecn_capable_packets_marked;   
	uint64_t        t_ecn_capable_packets_lost;     

	uint32_t        t_last_ack_tsecr;       
	uint16_t        t_prev_ace_flags;   
	uint8_t         t_prev_ip_ecn;      

	struct accecn   t_aecn;         

	struct pacer    t_pacer;        


	u_int32_t       snd_cwnd_prev;  
	u_int32_t       snd_ssthresh_prev; 
	tcp_seq snd_recover_prev;       
	int     t_srtt_prev;            
	int     t_rttvar_prev;          
	u_int32_t       t_badrexmt_time; 


	u_int32_t       t_reorderwin; 


	int16_t snd_numholes;           
	TAILQ_HEAD(sackhole_head, sackhole) snd_holes;
	tcp_seq snd_fack;               
	int     rcv_numsacks;           
	struct sackblk sackblks[MAX_SACK_BLKS]; 
	struct sackhint sackhint;       

	struct mbuf     *t_pktlist_head; 
	struct mbuf     *t_pktlist_tail; 
	u_int32_t       t_pktlist_sentlen; 

	u_int32_t       t_keepidle;     
	u_int32_t       t_keepinit;     
	u_int32_t       t_keepintvl;    
	u_int32_t       t_keepcnt;      

	u_int32_t       tso_max_segment_size;   
	u_int16_t       t_pmtud_lastseg_size;   
	u_int32_t       t_pmtud_saved_maxopd;   
	u_int32_t       t_pmtud_start_ts;       

	struct{
		u_int32_t       rxduplicatebytes;
		u_int32_t       rxoutoforderbytes;
		u_int32_t       txretransmitbytes;
		u_int16_t       synrxtshift;
		u_int16_t       rxmitsyns;
		u_int16_t       unused_pad_to_8;
		u_int32_t       rxmitpkts;
		uint32_t        delayed_acks_sent;
		uint32_t        acks_delayed;
	} t_stat;
	u_int8_t        t_syn_sent;
	u_int8_t        t_syn_rcvd;
	u_int8_t        t_notify_ack_count;
	u_int8_t        t_ecn_recv_ce_pkt; 
	u_int32_t       t_cached_maxopd; 

	uint32_t        bg_ssthresh;            
	uint32_t        t_flagsext;             

	struct bwmeas   *t_bwmeas;              
	tcp_seq         t_idleat;               
	uint8_t         t_fin_sent;
	uint8_t         t_fin_rcvd;
	uint8_t         t_rst_sent;
	uint8_t         t_rst_rcvd;
	TAILQ_ENTRY(tcpcb) t_twentry;           
	struct tcp_ccstate      *t_ccstate;     
	struct tcp_ccstate      _t_ccstate;     

	tcp_seq         t_tlphighrxt;           
	tcp_seq         t_tlphightrxt_persist;  
	uint32_t        t_tlpstart;             

	tcp_seq         t_dsack_lseq;           
	tcp_seq         t_dsack_rseq;           

	SLIST_HEAD(tcp_rxt_seghead, tcp_rxt_seg) t_rxt_segments;
	uint32_t        t_rxt_seg_count;
	uint32_t        t_rxt_seg_drop;
	tcp_seq         t_dsack_lastuna;        

	u_int32_t       t_pipeack_sample[TCP_PIPEACK_SAMPLE_COUNT];     
	tcp_seq         t_pipeack_lastuna; 
	u_int32_t       t_pipeack;
	u_int32_t       t_lossflightsize;


	u_int8_t                t_tfo_flags;
	u_int16_t               t_tfo_stats;

	u_int8_t                t_tfo_probes; 

	u_int8_t                t_tfo_probe_state;

	u_int32_t       t_rcvoopack;            
	u_int32_t       t_pawsdrop;             
	u_int32_t       t_sack_recovery_episode; 
	uint32_t        t_rack_recovery_episode; 
	uint32_t        t_rack_reo_timeout_recovery_episode; 
	u_int32_t       t_reordered_pkts;       
	u_int32_t       t_dsack_sent;           
	u_int32_t       t_dsack_recvd;          
	SLIST_HEAD(, tcp_notify_ack_marker) t_notify_ack; 
	u_int32_t       t_recv_throttle_ts;     
	u_int32_t       t_rxt_minimum_timeout;  
	uint32_t        t_challengeack_last;    
	uint32_t        t_challengeack_count;   

	u_int32_t       t_connect_time;         

	uint64_t        t_rcvwnd_limited_total_time;
	uint64_t        t_rcvwnd_limited_start_time;


	uint32_t        t_comp_rxmt_gencnt; 

	uint32_t        t_comp_ack_gencnt; 
	uint32_t        t_comp_ack_lastinc; 

	uint32_t        t_ts_offset; 

	uint32_t curr_rtt_hist[NCURR_RTT_HIST];  
	uint32_t curr_rtt_min;                   
	uint32_t curr_rtt_index;                 

	tcp_seq rcv_high;                   
	uint32_t tsv_high;                  
	struct tcp_rledbat_state t_rlstate; 

	uint32_t rcv_srtt;                  
	uint32_t rcv_rtt_est_ts;            
	uint32_t rcv_rtt_est_seq;           

	TAILQ_HEAD(tcp_seg_sent_head, tcp_seg_sent) t_segs_sent; 
	struct tcp_seg_sent_tree_head t_segs_sent_tree; 
	TAILQ_HEAD(tcp_seg_acked_head, tcp_seg_sent) t_segs_acked; 
	struct tcp_seg_pool seg_pool;

# define TCP_RACK_RECOVERY_PERSIST_MAX (16)
	struct tcp_rack {
		uint32_t        xmit_ts;
		uint32_t        end_seq;
		uint32_t        rtt; 
		tcp_seq         dsack_round_end;
		uint32_t        reo_wnd;
		uint8_t         reo_wnd_multi;
		uint8_t         reo_wnd_persist:5,
		    advanced:1,
		    dsack_round_seen:1,
		    segs_retransmitted:1;
	} rack;

	uint32_t bytes_lost;
	uint32_t bytes_retransmitted;
	uint32_t bytes_sacked;

	uuid_t          t_fsw_uuid;
	uuid_t          t_flow_uuid;
};
struct tcpopt {
	uint32_t        to_flags;   
	uint32_t        to_tsval;
	uint32_t        to_tsecr;
	uint16_t        to_mss;
	uint8_t         to_requested_s_scale;
	uint8_t         to_nsacks;                                                              
	u_char          *to_sacks __sized_by(to_sacks_size);        
	uint32_t                to_sacks_size;                                                          
	u_char          *to_tfo  __sized_by(to_tfo_size);                       
	uint32_t                to_tfo_size;                                                            
	uint8_t         to_num_accecn;                                                          
	uint8_t         *to_accecn __sized_by(to_accecn_size);      
	uint32_t                to_accecn_size;                                                         
	uint8_t         to_accecn_order;                                                        
};
struct otcpcb {
	u_int32_t t_segq;
	int     t_dupacks;              
	u_int32_t unused;               

	int     t_timer[TCPT_NTIMERS_EXT];      

	_TCPCB_PTR(struct inpcb *) t_inpcb;     
	int     t_state;                
	u_int   t_flags;

	int     t_force;                

	tcp_seq snd_una;                
	tcp_seq snd_max;                
	tcp_seq snd_nxt;                
	tcp_seq snd_up;                 

	tcp_seq snd_wl1;                
	tcp_seq snd_wl2;                
	tcp_seq iss;                    
	tcp_seq irs;                    

	tcp_seq rcv_nxt;                
	tcp_seq rcv_adv;                
	u_int32_t rcv_wnd;              
	tcp_seq rcv_up;                 

	u_int32_t snd_wnd;              
	u_int32_t snd_cwnd;             
	u_int32_t snd_ssthresh;         
	u_int   t_maxopd;               

	u_int32_t t_rcvtime;            
	u_int32_t t_starttime;          
	int     t_rtttime;              
	tcp_seq t_rtseq;                

	int     t_rxtcur;               
	u_int   t_maxseg;               
	int     t_srtt;                 
	int     t_rttvar;               

	int     t_rxtshift;             
	u_int   t_rttmin;               
	u_int32_t t_rttupdated;         
	u_int32_t max_sndwnd;           

	int     t_softerror;            

	char    t_oobflags;             
	char    t_iobc;                 

	u_char  snd_scale;              
	u_char  rcv_scale;              
	u_char  request_r_scale;        
	u_char  requested_s_scale;
	u_int32_t ts_recent;            

	u_int32_t ts_recent_age;        
	tcp_seq last_ack_sent;

	tcp_cc  cc_send;                
	tcp_cc  cc_recv;                
	tcp_seq snd_recover;            

	u_int32_t snd_cwnd_prev;        
	u_int32_t snd_ssthresh_prev;    
	u_int32_t t_badrxtwin;          
};
struct  tcpstat {
	u_int32_t       tcps_connattempt;       
	u_int32_t       tcps_accepts;           
	u_int32_t       tcps_connects;          
	u_int32_t       tcps_drops;             
	u_int32_t       tcps_conndrops;         
	u_int32_t       tcps_closed;            
	u_int32_t       tcps_segstimed;         
	u_int32_t       tcps_rttupdated;        
	u_int32_t       tcps_delack;            
	u_int32_t       tcps_timeoutdrop;       
	u_int32_t       tcps_rexmttimeo;        
	u_int32_t       tcps_persisttimeo;      
	u_int32_t       tcps_keeptimeo;         
	u_int32_t       tcps_keepprobe;         
	u_int32_t       tcps_keepdrops;         

	u_int32_t       tcps_sndtotal;          
	u_int32_t       tcps_sndpack;           
	u_int32_t       tcps_sndbyte;           
	u_int32_t       tcps_sndrexmitpack;     
	u_int32_t       tcps_sndrexmitbyte;     
	u_int32_t       tcps_sndacks;           
	u_int32_t       tcps_sndprobe;          
	u_int32_t       tcps_sndurg;            
	u_int32_t       tcps_sndwinup;          
	u_int32_t       tcps_sndctrl;           

	u_int32_t       tcps_rcvtotal;          
	u_int32_t       tcps_rcvpack;           
	u_int32_t       tcps_rcvbyte;           
	u_int32_t       tcps_rcvbadsum;         
	u_int32_t       tcps_rcvbadoff;         
	u_int32_t       tcps_rcvmemdrop;        
	u_int32_t       tcps_rcvshort;          
	u_int32_t       tcps_rcvduppack;        
	u_int32_t       tcps_rcvdupbyte;        
	u_int32_t       tcps_rcvpartduppack;    
	u_int32_t       tcps_rcvpartdupbyte;    
	u_int32_t       tcps_rcvoopack;         
	u_int32_t       tcps_rcvoobyte;         
	u_int32_t       tcps_rcvpackafterwin;   
	u_int32_t       tcps_rcvbyteafterwin;   
	u_int32_t       tcps_rcvafterclose;     
	u_int32_t       tcps_rcvwinprobe;       
	u_int32_t       tcps_rcvdupack;         
	u_int32_t       tcps_rcvacktoomuch;     
	u_int32_t       tcps_rcvackpack;        
	u_int32_t       tcps_rcvackbyte;        
	u_int32_t       tcps_rcvwinupd;         
	u_int32_t       tcps_pawsdrop;          
	u_int32_t       tcps_predack;           
	u_int32_t       tcps_preddat;           
	u_int32_t       tcps_pcbcachemiss;
	u_int32_t       tcps_cachedrtt;         
	u_int32_t       tcps_cachedrttvar;      
	u_int32_t       tcps_cachedssthresh;    
	u_int32_t       tcps_usedrtt;           
	u_int32_t       tcps_usedrttvar;        
	u_int32_t       tcps_usedssthresh;      
	u_int32_t       tcps_persistdrop;       
	u_int32_t       tcps_badsyn;            
	u_int32_t       tcps_mturesent;         
	u_int32_t       tcps_listendrop;        
	u_int32_t       tcps_synchallenge;      
	u_int32_t       tcps_rstchallenge;      

	u_int32_t       tcps_minmssdrops;       

	u_int32_t       tcps_sndrexmitbad;      
	u_int32_t       tcps_badrst;            

	u_int32_t       tcps_sc_added;          
	u_int32_t       tcps_sc_retransmitted;  
	u_int32_t       tcps_sc_dupsyn;         
	u_int32_t       tcps_sc_dropped;        
	u_int32_t       tcps_sc_completed;      
	u_int32_t       tcps_sc_bucketoverflow; 
	u_int32_t       tcps_sc_cacheoverflow;  
	u_int32_t       tcps_sc_reset;          
	u_int32_t       tcps_sc_stale;          
	u_int32_t       tcps_sc_aborted;        
	u_int32_t       tcps_sc_badack;         
	u_int32_t       tcps_sc_unreach;        
	u_int32_t       tcps_sc_zonefail;       
	u_int32_t       tcps_sc_sendcookie;     
	u_int32_t       tcps_sc_recvcookie;     

	u_int32_t       tcps_hc_added;          
	u_int32_t       tcps_hc_bucketoverflow; 

	u_int32_t       tcps_sack_recovery_episode; 
	u_int32_t       tcps_sack_rexmits;          
	u_int32_t       tcps_sack_rexmit_bytes;     
	u_int32_t       tcps_sack_rcv_blocks;       
	u_int32_t       tcps_sack_send_blocks;      
	u_int32_t       tcps_sack_sboverflow;       

	u_int32_t       tcps_rack_recovery_episode; 
	u_int32_t       tcps_rack_reordering_timeout_recovery_episode; 
	u_int32_t       tcps_rack_rexmits;          

	u_int32_t       tcps_bg_rcvtotal;       
	u_int32_t       tcps_rxtfindrop;        
	u_int32_t       tcps_fcholdpacket;      

	u_int32_t       tcps_limited_txt;       
	u_int32_t       tcps_early_rexmt;       
	u_int32_t       tcps_sack_ackadv;       

	u_int32_t       tcps_rcv_swcsum;        
	u_int32_t       tcps_rcv_swcsum_bytes;  
	u_int32_t       tcps_rcv6_swcsum;       
	u_int32_t       tcps_rcv6_swcsum_bytes; 
	u_int32_t       tcps_snd_swcsum;        
	u_int32_t       tcps_snd_swcsum_bytes;  
	u_int32_t       tcps_snd6_swcsum;       
	u_int32_t       tcps_snd6_swcsum_bytes; 
	u_int32_t       tcps_unused_1;
	u_int32_t       tcps_unused_2;
	u_int32_t       tcps_unused_3;

	u_int32_t       tcps_invalid_mpcap;     
	u_int32_t       tcps_invalid_joins;     
	u_int32_t       tcps_mpcap_fallback;    
	u_int32_t       tcps_join_fallback;     
	u_int32_t       tcps_estab_fallback;    
	u_int32_t       tcps_invalid_opt;       
	u_int32_t       tcps_mp_outofwin;       
	u_int32_t       tcps_mp_reducedwin;     
	u_int32_t       tcps_mp_badcsum;        
	u_int32_t       tcps_mp_oodata;         
	u_int32_t       tcps_mp_switches;       
	u_int32_t       tcps_mp_rcvtotal;       
	u_int32_t       tcps_mp_rcvbytes;       
	u_int32_t       tcps_mp_sndpacks;       
	u_int32_t       tcps_mp_sndbytes;       
	u_int32_t       tcps_join_rxmts;        
	u_int32_t       tcps_tailloss_rto;      
	u_int32_t       tcps_reordered_pkts;    
	u_int32_t       tcps_recovered_pkts;    
	u_int32_t       tcps_pto;               
	u_int32_t       tcps_rto_after_pto;     
	u_int32_t       tcps_tlp_recovery;      
	u_int32_t       tcps_tlp_recoverlastpkt; 
	u_int32_t       tcps_ecn_client_success; 
	u_int32_t       tcps_ecn_recv_ece;      
	u_int32_t       tcps_ecn_sent_ece;      
	u_int32_t       tcps_detect_reordering; 
	u_int32_t       tcps_delay_recovery;    
	u_int32_t       tcps_avoid_rxmt;        
	u_int32_t       tcps_unnecessary_rxmt;  
	u_int32_t       tcps_nostretchack;      
	u_int32_t       tcps_rescue_rxmt;       
	u_int32_t       tcps_pto_in_recovery;   
	u_int32_t       tcps_pmtudbh_reverted;  

	u_int32_t       tcps_dsack_disable;     
	u_int32_t       tcps_dsack_ackloss;     
	u_int32_t       tcps_dsack_badrexmt;    
	u_int32_t       tcps_dsack_sent;        
	u_int32_t       tcps_dsack_recvd;       
	u_int32_t       tcps_dsack_recvd_old;   

	u_int32_t       tcps_mp_sel_symtomsd;   
	u_int32_t       tcps_mp_sel_rtt;        
	u_int32_t       tcps_mp_sel_rto;        
	u_int32_t       tcps_mp_sel_peer;       
	u_int32_t       tcps_mp_num_probes;     
	u_int32_t       tcps_mp_verdowngrade;   
	u_int32_t       tcps_drop_after_sleep;  
	u_int32_t       tcps_probe_if;          
	u_int32_t       tcps_probe_if_conflict; 

	u_int32_t       tcps_ecn_client_setup;    
	u_int32_t       tcps_ecn_server_setup;    
	u_int32_t       tcps_ecn_server_success;  
	u_int32_t       tcps_ecn_ace_syn_not_ect; 
	u_int32_t       tcps_ecn_ace_syn_ect1;    
	u_int32_t       tcps_ecn_ace_syn_ect0;    
	u_int32_t       tcps_ecn_ace_syn_ce;      
	u_int32_t       tcps_ecn_lost_synack;   
	u_int32_t       tcps_ecn_lost_syn;      
	u_int32_t       tcps_ecn_not_supported; 
	u_int32_t       tcps_ecn_recv_ce;       
	u_int32_t       tcps_ecn_ace_recv_ce;   
	u_int32_t       tcps_ecn_conn_recv_ce;  
	u_int32_t       tcps_ecn_conn_recv_ece; 
	u_int32_t       tcps_ecn_conn_plnoce;   
	u_int32_t       tcps_ecn_conn_pl_ce;    
	u_int32_t       tcps_ecn_conn_nopl_ce;  
	u_int32_t       tcps_ecn_fallback_synloss; 
	u_int32_t       tcps_ecn_fallback_reorder; 
	u_int32_t       tcps_ecn_fallback_ce;   

	u_int32_t       tcps_tfo_syn_data_rcv;  
	u_int32_t       tcps_tfo_cookie_req_rcv;
	u_int32_t       tcps_tfo_cookie_sent;   
	u_int32_t       tcps_tfo_cookie_invalid;
	u_int32_t       tcps_tfo_cookie_req;    
	u_int32_t       tcps_tfo_cookie_rcv;    
	u_int32_t       tcps_tfo_syn_data_sent; 
	u_int32_t       tcps_tfo_syn_data_acked;
	u_int32_t       tcps_tfo_syn_loss;      
	u_int32_t       tcps_tfo_blackhole;     
	u_int32_t       tcps_tfo_cookie_wrong;  
	u_int32_t       tcps_tfo_no_cookie_rcv; 
	u_int32_t       tcps_tfo_heuristics_disable; 
	u_int32_t       tcps_tfo_sndblackhole;  
	u_int32_t       tcps_mss_to_default;    
	u_int32_t       tcps_mss_to_medium;     
	u_int32_t       tcps_mss_to_low;        
	u_int32_t       tcps_ecn_fallback_droprst; 
	u_int32_t       tcps_ecn_fallback_droprxmt; 
	u_int32_t       tcps_ecn_fallback_synrst; 

	u_int32_t       tcps_mptcp_rcvmemdrop;  
	u_int32_t       tcps_mptcp_rcvduppack;  
	u_int32_t       tcps_mptcp_rcvpackafterwin; 

	u_int32_t       tcps_timer_drift_le_1_ms;       
	u_int32_t       tcps_timer_drift_le_10_ms;      
	u_int32_t       tcps_timer_drift_le_20_ms;      
	u_int32_t       tcps_timer_drift_le_50_ms;      
	u_int32_t       tcps_timer_drift_le_100_ms;     
	u_int32_t       tcps_timer_drift_le_200_ms;     
	u_int32_t       tcps_timer_drift_le_500_ms;     
	u_int32_t       tcps_timer_drift_le_1000_ms;    
	u_int32_t       tcps_timer_drift_gt_1000_ms;    

	u_int32_t       tcps_mptcp_handover_attempt;    
	u_int32_t       tcps_mptcp_interactive_attempt; 
	u_int32_t       tcps_mptcp_aggregate_attempt;   
	u_int32_t       tcps_mptcp_fp_handover_attempt; 
	u_int32_t       tcps_mptcp_fp_interactive_attempt;
	u_int32_t       tcps_mptcp_fp_aggregate_attempt;
	u_int32_t       tcps_mptcp_heuristic_fallback;  
	u_int32_t       tcps_mptcp_fp_heuristic_fallback;       
	u_int32_t       tcps_mptcp_handover_success_wifi;       
	u_int32_t       tcps_mptcp_handover_success_cell;       
	u_int32_t       tcps_mptcp_interactive_success;         
	u_int32_t       tcps_mptcp_aggregate_success;           
	u_int32_t       tcps_mptcp_fp_handover_success_wifi;    
	u_int32_t       tcps_mptcp_fp_handover_success_cell;
	u_int32_t       tcps_mptcp_fp_interactive_success;
	u_int32_t       tcps_mptcp_fp_aggregate_success;
	u_int32_t       tcps_mptcp_handover_cell_from_wifi;     
	u_int32_t       tcps_mptcp_handover_wifi_from_cell;     
	u_int32_t       tcps_mptcp_interactive_cell_from_wifi;  
	u_int64_t       tcps_mptcp_handover_cell_bytes;         
	u_int64_t       tcps_mptcp_interactive_cell_bytes;      
	u_int64_t       tcps_mptcp_aggregate_cell_bytes;
	u_int64_t       tcps_mptcp_handover_all_bytes;          
	u_int64_t       tcps_mptcp_interactive_all_bytes;
	u_int64_t       tcps_mptcp_aggregate_all_bytes;
	u_int32_t       tcps_mptcp_back_to_wifi;        
	u_int32_t       tcps_mptcp_wifi_proxy;          
	u_int32_t       tcps_mptcp_cell_proxy;          

	u_int32_t       tcps_ka_offload_drops;  

	u_int32_t       tcps_mptcp_triggered_cell;      

	u_int32_t       tcps_fin_timeout_drops;
};
struct tcpstat_local {
	u_int64_t badformat;
	u_int64_t unspecv6;
	u_int64_t synfin;
	u_int64_t badformatipsec;
	u_int64_t noconnnolist;
	u_int64_t noconnlist;
	u_int64_t listbadsyn;
	u_int64_t icmp6unreach;
	u_int64_t deprecate6;
	u_int64_t ooopacket;
	u_int64_t rstinsynrcv;
	u_int64_t dospacket;
	u_int64_t cleanup;
	u_int64_t synwindow;
	u_int64_t linkheur_stealthdrop;
	u_int64_t linkheur_noackpri;
	u_int64_t linkheur_comprxmt;
	u_int64_t linkheur_synrxmt;
	u_int64_t linkheur_rxmtfloor;
};
struct  xtcpcb {
	u_int32_t       xt_len;
	struct  inpcb_compat    xt_inp;
	struct  otcpcb  xt_tp;
	struct  xsocket xt_socket;
	u_quad_t        xt_alignment_hack;
};
struct  xtcpcb_n {
	u_int32_t               xt_len;
	u_int32_t                       xt_kind;                

	u_int64_t t_segq;
	int     t_dupacks;              

	int t_timer[TCPT_NTIMERS_EXT];  

	int     t_state;                
	u_int   t_flags;

	int     t_force;                

	tcp_seq snd_una;                
	tcp_seq snd_max;                
	tcp_seq snd_nxt;                
	tcp_seq snd_up;                 

	tcp_seq snd_wl1;                
	tcp_seq snd_wl2;                
	tcp_seq iss;                    
	tcp_seq irs;                    

	tcp_seq rcv_nxt;                
	tcp_seq rcv_adv;                
	u_int32_t rcv_wnd;              
	tcp_seq rcv_up;                 

	u_int32_t snd_wnd;              
	u_int32_t snd_cwnd;             
	u_int32_t snd_ssthresh;         
	u_int   t_maxopd;               

	u_int32_t t_rcvtime;            
	u_int32_t t_starttime;          
	int     t_rtttime;              
	tcp_seq t_rtseq;                

	int     t_rxtcur;               
	u_int   t_maxseg;               
	int     t_srtt;                 
	int     t_rttvar;               

	int     t_rxtshift;             
	u_int   t_rttmin;               
	u_int32_t t_rttupdated;         
	u_int32_t max_sndwnd;           

	int     t_softerror;            
	char    t_oobflags;             
	char    t_iobc;                 
	u_char  snd_scale;              
	u_char  rcv_scale;              
	u_char  request_r_scale;        
	u_char  requested_s_scale;
	u_int32_t ts_recent;            

	u_int32_t ts_recent_age;        
	tcp_seq last_ack_sent;
	tcp_cc  cc_send;                
	tcp_cc  cc_recv;                
	tcp_seq snd_recover;            
	u_int32_t snd_cwnd_prev;        
	u_int32_t snd_ssthresh_prev;    
};
struct tcpprobereq {
	u_int64_t       ifindex;                
	u_int64_t       enable;                 
	u_int64_t       filter_flags;           
	u_int32_t       reserved;               
	u_int32_t       reserved2;              
};
struct tcp_respond_args {
	unsigned int ifscope;
	unsigned int nocell:1,
	    noexpensive:1,
	    awdl_unrestricted:1,
	    intcoproc_allowed:1,
	    keep_alive:1,
	    noconstrained:1,
	    management_allowed:1,
	    ultra_constrained_allowed:1;
};
struct udphdr {
	u_short uh_sport;               
	u_short uh_dport;               
	u_short uh_ulen;                
	u_short uh_sum;                 
};
struct udp_keepalive_offload {
	u_char ka_data[UDP_KEEPALIVE_OFFLOAD_DATA_SIZE];
	u_int16_t ka_interval;          
	u_int8_t ka_data_len;           
	u_int8_t ka_type;               
};
struct udp_in6 {
	struct sockaddr_in6     uin6_sin;
	u_char                  uin6_init_done : 1;
};
struct udp_ip6 {
	struct ip6_hdr          uip6_ip6;
	u_char                  uip6_init_done : 1;
};
struct  udpiphdr {
	struct  ipovly ui_i;            
	struct  udphdr ui_u;            
};
struct  udpstat {
	u_int32_t udps_ipackets;        
	u_int32_t udps_hdrops;          
	u_int32_t udps_badsum;          
	u_int32_t udps_badlen;          
	u_int32_t udps_noport;          
	u_int32_t udps_noportbcast;     
	u_int32_t udps_fullsock;        
	u_int32_t udpps_pcbcachemiss;   
	u_int32_t udpps_pcbhashmiss;    
	u_int32_t udps_opackets;        
	u_int32_t udps_fastout;         
	u_int32_t udps_nosum;           
	u_int32_t udps_noportmcast;     
	u_int32_t udps_filtermcast;     
	u_int32_t udps_rcv_swcsum;        
	u_int32_t udps_rcv_swcsum_bytes;  
	u_int32_t udps_rcv6_swcsum;       
	u_int32_t udps_rcv6_swcsum_bytes; 
	u_int32_t udps_snd_swcsum;        
	u_int32_t udps_snd_swcsum_bytes;  
	u_int32_t udps_snd6_swcsum;       
	u_int32_t udps_snd6_swcsum_bytes; 
};
struct udpstat_local {
	u_int64_t       port_unreach;
	u_int64_t       faithprefix;    
	u_int64_t       port0;
	u_int64_t       badlength;
	u_int64_t       badchksum;
	u_int64_t       badmcast;
	u_int64_t       cleanup;
	u_int64_t       badipsec;
	u_int64_t       linkheur_stealthdrop;
};
struct ah {
	u_int8_t        ah_nxt;         
	u_int8_t        ah_len;         
	u_int16_t       ah_reserve;     
	u_int32_t       ah_spi;         
		
};
struct newah {
	u_int8_t        ah_nxt;         
	u_int8_t        ah_len;         
	u_int16_t       ah_reserve;     
	u_int32_t       ah_spi;         
	u_int32_t       ah_seq;         
		
};
struct ah_algorithm_state {
	const struct ccdigest_info *digest;
	cchmac_ctx_decl(CCSHA512_STATE_SIZE, CCSHA512_BLOCK_SIZE, hmac_ctx);
};
struct ah_algorithm {
	int (*sumsiz)(struct secasvar *);
	int (*mature)(struct secasvar *);
	u_int16_t keymin;     
	u_int16_t keymax;     
	const char *name;
	int (*init)(struct ah_algorithm_state *, struct secasvar *);
	void (*update)(struct ah_algorithm_state *, caddr_t, size_t);
	void (*result)(struct ah_algorithm_state *, caddr_t, size_t);
	const struct ccdigest_info *(*digest)(void);
	size_t (*schedlen)(const struct ah_algorithm *);
	int (*schedule)(const struct ah_algorithm *, struct secasvar *);
};
struct esp {
	u_int32_t       esp_spi;        
		
			
			
				
				
				
		
};
struct newesp {
	u_int32_t       esp_spi;        
	u_int32_t       esp_seq;        
			
			
				
				
				
		
};
struct esptail {
	u_int8_t        esp_padlen;     
	u_int8_t        esp_nxt;        
		
};
struct esp_algorithm {
	uint32_t padbound;        
	int ivlenval;           
	int (*mature)(struct secasvar *);
	u_int16_t keymin;     
	u_int16_t keymax;     
	size_t (*schedlen)(const struct esp_algorithm *);
	const char *name;
	int (*ivlen)(const struct esp_algorithm *, struct secasvar *);
	int (*decrypt)(struct mbuf *, size_t,
	    struct secasvar *, const struct esp_algorithm *, int);
	int (*encrypt)(struct mbuf *, size_t, size_t,
	    struct secasvar *, const struct esp_algorithm *, int);
	int (*schedule)(const struct esp_algorithm *, struct secasvar *);
	int (*blockdecrypt)(const struct esp_algorithm *,
	    struct secasvar *, u_int8_t *, u_int8_t *);
	int (*blockencrypt)(const struct esp_algorithm *,
	    struct secasvar *, u_int8_t *, u_int8_t *);
	size_t icvlen;
	int (*finalizedecrypt)(struct secasvar *, u_int8_t *, size_t);
	int (*finalizeencrypt)(struct secasvar *, u_int8_t *, size_t);
	int (*encrypt_pkt)(struct secasvar *, uint8_t *, size_t,
	    struct newesp *, uint8_t *, size_t, uint8_t *, size_t);
	int (*decrypt_pkt)(struct secasvar *, uint8_t *, size_t,
	    struct newesp *, uint8_t *, size_t, uint8_t *, size_t);
};
struct _esp_chachapoly_ctx {
	chacha20poly1305_ctx ccp_ctx;
	uint8_t ccp_salt[ESP_CHACHAPOLY_SALT_LEN];
	bool ccp_implicit_iv;
} esp_chachapoly_ctx_s, *esp_chachapoly_ctx_t;
struct {
	ccgcm_ctx *decrypt;
	ccgcm_ctx *encrypt;
	ccgcm_ctx ctxt[0];
} aes_gcm_ctx;
struct  ip6asfrag {
	struct ip6asfrag *ip6af_down;
	struct ip6asfrag *ip6af_up;
	struct mbuf     *ip6af_m;
	int             ip6af_offset;   
	int             ip6af_frglen;   
	int             ip6af_off;      
	u_int16_t       ip6af_mff;      
};
struct in6_event {
	in6_evhdlr_code_t in6_event_code;
	struct ifnet *in6_ifp;
	struct in6_addr in6_address;
	uint32_t val;
};
struct in6_event_nwk_wq_entry {
	struct nwk_wq_entry nwk_wqe;
	struct in6_event in6_ev_arg;
};
struct in6_addr {
	union {
		__uint8_t   __u6_addr8[16];
		__uint16_t  __u6_addr16[8];
		__uint32_t  __u6_addr32[4];
	} __u6_addr;                    
} in6_addr_t;
struct sockaddr_in6 {
	__uint8_t       sin6_len;       
	sa_family_t     sin6_family;    
	in_port_t       sin6_port;      
	__uint32_t      sin6_flowinfo;  
	struct in6_addr sin6_addr;      
	__uint32_t      sin6_scope_id;  
};
struct in6_cga_hash1 {
	u_int8_t octets[IN6_CGA_HASH1_LENGTH];
};
struct in6_cga_hash2 {
	u_int8_t octets[IN6_CGA_HASH2_LENGTH];
};
struct in6_cga_singleton {
	boolean_t cga_initialized;
	decl_lck_mtx_data(, cga_mutex);
	struct in6_cga_prepare cga_prepare;
	struct iovec cga_pubkey;
	struct iovec cga_privkey;
};
struct in6_multi_dbg {
	struct in6_multi        in6m;                   
	u_int16_t               in6m_refhold_cnt;       
	u_int16_t               in6m_refrele_cnt;       
	ctrace_t                in6m_refhold[IN6M_TRACE_HIST_SIZE];
	ctrace_t                in6m_refrele[IN6M_TRACE_HIST_SIZE];
	TAILQ_ENTRY(in6_multi_dbg) in6m_trash_link;
};
struct route_in6_old {
	void            *ro_rt;
	uint32_t        ro_flags;
	struct sockaddr_in6 ro_dst;
};
struct route_in6 {
	struct rtentry  *ro_rt;

	struct ifaddr   *ro_srcia;
	uint32_t        ro_flags;       
	struct sockaddr_in6 ro_dst;
};
struct rtqk_arg {
	struct radix_node_head *rnh;
	int updating;
	int draining;
	uint32_t killed;
	uint32_t found;
	uint64_t nextstop;
};
struct addrsel_policyent {
	TAILQ_ENTRY(addrsel_policyent) ape_entry;
	struct in6_addrpolicy ape_policy;
};
struct walkarg {
	struct sysctl_req *w_req;
};
struct in6_addrlifetime {
	time_t ia6t_expire;     
	time_t ia6t_preferred;  
	u_int32_t ia6t_vltime;  
	u_int32_t ia6t_pltime;  
};
struct in6_addrlifetime_32 {
	u_int32_t ia6t_expire;
	u_int32_t ia6t_preferred;
	u_int32_t ia6t_vltime;
	u_int32_t ia6t_pltime;
};
struct in6_addrlifetime_64 {
	u_int64_t ia6t_expire;
	u_int64_t ia6t_preferred;
	u_int32_t ia6t_vltime;
	u_int32_t ia6t_pltime;
};
struct in6_addrlifetime_i {
	u_int64_t ia6ti_expire;         
	u_int64_t ia6ti_preferred;      
	u_int32_t ia6ti_vltime;         
	u_int32_t ia6ti_pltime;         
	u_int64_t ia6ti_base_calendartime; 
	u_int64_t ia6ti_base_uptime;    
};
struct in6_ifaddr {
	struct ifaddr ia_ifa;           
	struct sockaddr_in6 ia_addr;    
	struct sockaddr_in6 ia_net;     
	struct sockaddr_in6 ia_dstaddr; 
	struct sockaddr_in6 ia_prefixmask; 
	u_int32_t ia_plen;              
	TAILQ_ENTRY(in6_ifaddr) ia6_link;     
	TAILQ_ENTRY(in6_ifaddr) ia6_hash; 
	int ia6_flags;

	uint8_t   ia6_cga_collision_count;

	struct in6_addrlifetime_i ia6_lifetime;
	u_int64_t ia6_createtime;
	u_int64_t ia6_updatetime;

	struct nd_prefix *ia6_ndpr;

	LIST_HEAD(, in6_multi_mship) ia6_memberships;
};
struct in6_addrpolicy {
	struct sockaddr_in6 addr; 
	struct sockaddr_in6 addrmask; 
	int preced;             
	int label;              
	u_quad_t use;           
};
struct in6_ifstat {
	u_quad_t ifs6_in_receive;       
	u_quad_t ifs6_in_hdrerr;        
	u_quad_t ifs6_in_toobig;        
	u_quad_t ifs6_in_noroute;       
	u_quad_t ifs6_in_addrerr;       
	u_quad_t ifs6_in_protounknown;  
	                                
	u_quad_t ifs6_in_truncated;     
	u_quad_t ifs6_in_discard;       
	                                
	u_quad_t ifs6_in_deliver;       
	                                
	u_quad_t ifs6_out_forward;      
	                                
	u_quad_t ifs6_out_request;      
	                                
	u_quad_t ifs6_out_discard;      
	u_quad_t ifs6_out_fragok;       
	u_quad_t ifs6_out_fragfail;     
	u_quad_t ifs6_out_fragcreat;    
	                                
	u_quad_t ifs6_reass_reqd;       
	                                
	u_quad_t ifs6_reass_ok;         
	                                
	                                
	u_quad_t ifs6_atmfrag_rcvd;     
	u_quad_t ifs6_reass_fail;       
	                                
	                                
	u_quad_t ifs6_in_mcast;         
	u_quad_t ifs6_out_mcast;        

	u_quad_t ifs6_cantfoward_icmp6; 
	u_quad_t ifs6_addr_expiry_cnt;  
	u_quad_t ifs6_pfx_expiry_cnt;   
	u_quad_t ifs6_defrtr_expiry_cnt;        
};
struct icmp6_ifstat {
	u_quad_t ifs6_in_msg;
	u_quad_t ifs6_in_error;
	u_quad_t ifs6_in_dstunreach;
	u_quad_t ifs6_in_adminprohib;
	u_quad_t ifs6_in_timeexceed;
	u_quad_t ifs6_in_paramprob;
	u_quad_t ifs6_in_pkttoobig;
	u_quad_t ifs6_in_echo;
	u_quad_t ifs6_in_echoreply;
	u_quad_t ifs6_in_routersolicit;
	u_quad_t ifs6_in_routeradvert;
	u_quad_t ifs6_in_neighborsolicit;
	u_quad_t ifs6_in_neighboradvert;
	u_quad_t ifs6_in_redirect;
	u_quad_t ifs6_in_mldquery;
	u_quad_t ifs6_in_mldreport;
	u_quad_t ifs6_in_mlddone;

	u_quad_t ifs6_out_msg;
	u_quad_t ifs6_out_error;
	u_quad_t ifs6_out_dstunreach;
	u_quad_t ifs6_out_adminprohib;
	u_quad_t ifs6_out_timeexceed;
	u_quad_t ifs6_out_paramprob;
	u_quad_t ifs6_out_pkttoobig;
	u_quad_t ifs6_out_echo;
	u_quad_t ifs6_out_echoreply;
	u_quad_t ifs6_out_routersolicit;
	u_quad_t ifs6_out_routeradvert;
	u_quad_t ifs6_out_neighborsolicit;
	u_quad_t ifs6_out_neighboradvert;
	u_quad_t ifs6_out_redirect;
	u_quad_t ifs6_out_mldquery;
	u_quad_t ifs6_out_mldreport;
	u_quad_t ifs6_out_mlddone;
};
struct in6_ifreq {
	char    ifr_name[IFNAMSIZ];
	union {
		struct  sockaddr_in6 ifru_addr;
		struct  sockaddr_in6 ifru_dstaddr;
		int     ifru_flags;
		int     ifru_flags6;
		int     ifru_metric;
		int     ifru_intval;
		caddr_t ifru_data;
		struct in6_addrlifetime ifru_lifetime;
		struct in6_ifstat ifru_stat;
		struct icmp6_ifstat ifru_icmp6stat;
		u_int32_t ifru_scope_id[SCOPE6_ID_MAX];
	} ifr_ifru;
};
struct in6_aliasreq {
	char    ifra_name[IFNAMSIZ];
	struct  sockaddr_in6 ifra_addr;
	struct  sockaddr_in6 ifra_dstaddr;
	struct  sockaddr_in6 ifra_prefixmask;
	int     ifra_flags;
	struct in6_addrlifetime ifra_lifetime;
};
struct in6_cga_modifier {
	u_int8_t octets[IN6_CGA_MODIFIER_LENGTH];
};
struct in6_cga_prepare {
	struct in6_cga_modifier cga_modifier;
	u_int8_t cga_security_level;
	u_int8_t reserved_A[15];
};
struct in6_cga_nodecfg {
	struct iovec cga_privkey;
	struct iovec cga_pubkey;
	struct in6_cga_prepare cga_prepare;
};
struct in6_cgareq {
	char cgar_name[IFNAMSIZ];
	int cgar_flags;
	struct in6_cga_prepare cgar_cgaprep;
	struct in6_addrlifetime cgar_lifetime;
	uint8_t cgar_collision_count;
};
struct in6_cgareq_32 {
	char cgar_name[IFNAMSIZ];
	int cgar_flags;
	struct in6_cga_prepare cgar_cgaprep;
	struct in6_addrlifetime_32 cgar_lifetime;
	uint8_t cgar_collision_count;
};
struct in6_cgareq_64 {
	char cgar_name[IFNAMSIZ];
	int cgar_flags;
	struct in6_cga_prepare cgar_cgaprep;
	struct in6_addrlifetime_64 cgar_lifetime;
	uint8_t cgar_collision_count;
};
struct in6_aliasreq_32 {
	char    ifra_name[IFNAMSIZ];
	struct  sockaddr_in6 ifra_addr;
	struct  sockaddr_in6 ifra_dstaddr;
	struct  sockaddr_in6 ifra_prefixmask;
	int     ifra_flags;
	struct in6_addrlifetime_32 ifra_lifetime;
};
struct in6_aliasreq_64 {
	char    ifra_name[IFNAMSIZ];
	struct  sockaddr_in6 ifra_addr;
	struct  sockaddr_in6 ifra_dstaddr;
	struct  sockaddr_in6 ifra_prefixmask;
	int     ifra_flags;
	struct in6_addrlifetime_64 ifra_lifetime;
};
struct in6_prflags {
	struct prf_ra {
		u_char onlink : 1;
		u_char autonomous : 1;
		u_char reserved : 6;
	} prf_ra;
	u_char prf_reserved1;
	u_short prf_reserved2;
	struct prf_rr {
		u_char decrvalid : 1;
		u_char decrprefd : 1;
		u_char reserved : 6;
	} prf_rr;
	u_char prf_reserved3;
	u_short prf_reserved4;
};
struct  in6_prefixreq {
	char    ipr_name[IFNAMSIZ];
	u_char  ipr_origin;
	u_char  ipr_plen;
	u_int32_t ipr_vltime;
	u_int32_t ipr_pltime;
	struct in6_prflags ipr_flags;
	struct  sockaddr_in6 ipr_prefix;
};
struct in6_rrenumreq {
	char    irr_name[IFNAMSIZ];
	u_char  irr_origin;
	u_char  irr_m_len;      
	u_char  irr_m_minlen;   
	u_char  irr_m_maxlen;   
	u_char  irr_u_uselen;   
	u_char  irr_u_keeplen;  
	struct irr_raflagmask {
		u_char onlink : 1;
		u_char autonomous : 1;
		u_char reserved : 6;
	} irr_raflagmask;
	u_int32_t irr_vltime;
	u_int32_t irr_pltime;
	struct in6_prflags irr_flags;
	struct  sockaddr_in6 irr_matchprefix;
	struct  sockaddr_in6 irr_useprefix;
};
struct kev_in6_addrlifetime {
	u_int32_t ia6t_expire;
	u_int32_t ia6t_preferred;
	u_int32_t ia6t_vltime;
	u_int32_t ia6t_pltime;
};
struct kev_in6_data {
	struct net_event_data link_data;
	struct sockaddr_in6 ia_addr;    
	struct sockaddr_in6 ia_net;     
	struct sockaddr_in6 ia_dstaddr; 
	struct sockaddr_in6 ia_prefixmask; 
	u_int32_t ia_plen;              
	u_int32_t ia6_flags;            
	struct kev_in6_addrlifetime ia_lifetime; 
	uint8_t ia_mac[ETHER_ADDR_LEN];
};
struct ip6_msource {
	RB_ENTRY(ip6_msource)   im6s_link;      
	struct in6_addr         im6s_addr;
	struct im6s_st {
		uint16_t        ex;             
		uint16_t        in;             
	}                       im6s_st[2];     
	uint8_t                 im6s_stp;       
};
struct in6_msource {
	RB_ENTRY(ip6_msource)   im6s_link;      
	struct in6_addr         im6s_addr;      
	uint8_t                 im6sl_st[2];    
};
struct in6_mfilter {
	struct ip6_msource_tree im6f_sources; 
	u_long                  im6f_nsrc;    
	uint8_t                 im6f_st[2];   
};
struct in6_multi_mship {
	struct  in6_multi *i6mm_maddr;  
	LIST_ENTRY(in6_multi_mship) i6mm_chain;  
};
struct in6_ifextra {
	struct scope6_id        scope6_id;
	struct in6_ifstat       in6_ifstat;
	struct icmp6_ifstat     icmp6_ifstat;
	struct nd_ifinfo        nd_ifinfo;
	uint32_t                netsig_len;
	u_int8_t                netsig[IFNET_SIGNATURELEN];
	struct ipv6_prefix      nat64_prefixes[NAT64_MAX_NUM_PREFIXES];
};
struct in6_multi {
	decl_lck_mtx_data(, in6m_lock);
	u_int32_t in6m_refcount;        
	u_int32_t in6m_reqcnt;          
	u_int32_t in6m_debug;           
	LIST_ENTRY(in6_multi) in6m_entry; 
	struct  in6_addr in6m_addr;     
	uint32_t ifscope;               
	struct  ifnet *in6m_ifp;        
	struct  ifmultiaddr *in6m_ifma; 
	u_int   in6m_state;             
	u_int   in6m_timer;             
	bool    in6m_in_nrele;          

	struct mld_ifinfo       *in6m_mli;      
	SLIST_ENTRY(in6_multi)   in6m_dtle;     
	SLIST_ENTRY(in6_multi)   in6m_nrele;    
	u_int32_t                in6m_nrelecnt; 
	struct ip6_msource_tree  in6m_srcs;     
	u_long                   in6m_nsrc;     

	struct ifqueue           in6m_scq;  
	struct timeval           in6m_lastgsrtv;        
	uint16_t                 in6m_sctimer;  
	uint16_t                 in6m_scrv;     

	struct in6m_st {
		uint16_t        iss_fmode;      
		uint16_t        iss_asm;        
		uint16_t        iss_ex;         
		uint16_t        iss_in;         
		uint16_t        iss_rec;        
	}                       in6m_st[2];     

	void (*in6m_trace)              
	(struct in6_multi *, int);
};
struct in6_multistep {
	struct in6_ifaddr *i_ia;
	struct in6_multi *i_in6m;
};
struct ip6ctlparam {
	struct mbuf *ip6c_m;            
	struct icmp6_hdr *ip6c_icmp6;   
	struct ip6_hdr *ip6c_ip6;       
	int ip6c_off;                   
	struct sockaddr_in6 *ip6c_src;  
	struct sockaddr_in6 *ip6c_dst;  
	struct in6_addr *ip6c_finaldst; 
	void *ip6c_cmdarg;              
	u_int8_t ip6c_nxt;              
};
struct ip6protosw {
	TAILQ_ENTRY(ip6protosw) pr_entry; 
	struct  domain *pr_domain;      
	struct protosw *pr_protosw;     
	u_int16_t pr_type;              
	u_int16_t pr_protocol;          
	u_int32_t pr_flags;             
	int     (*pr_input)             
	(struct mbuf **, int *, int);
	int     (*pr_output)            
	(struct mbuf *m, struct socket *so,
	struct sockaddr_in6 *, struct mbuf *);
	void    (*pr_ctlinput)          
	(int, struct sockaddr *, void *, struct ifnet *);
	int     (*pr_ctloutput)         
	(struct socket *, struct sockopt *);
	struct  pr_usrreqs *pr_usrreqs; 
	void    (*pr_init)              
	(struct ip6protosw *, struct domain *);
	void    (*pr_drain)(void);      
	int     (*pr_sysctl)(void);     
	int     (*pr_lock)              
	(struct socket *so, int refcnt, void *debug);
	int     (*pr_unlock)            
	(struct socket *so, int refcnt, void *debug);
	lck_mtx_t *(*pr_getlock)        
	(struct socket *so, int flags);
	TAILQ_HEAD(, socket_filter) pr_filter_head;
	struct protosw_old *pr_old;

	void    (*pr_update_last_owner) 
	(struct socket *so, struct proc *p, struct proc *ep);

	void    (*pr_copy_last_owner) 
	(struct socket *so, struct socket *head);
};
struct inet6_tag_container {
	struct m_tag    inet6_m_tag;
	struct ip6aux   inet6_ip6a;
};
struct ip6_moptions_dbg {
	struct ip6_moptions     im6o;                   
	u_int16_t               im6o_refhold_cnt;       
	u_int16_t               im6o_refrele_cnt;       
	ctrace_t                im6o_alloc;
	ctrace_t                im6o_free;
	ctrace_t                im6o_refhold[IM6O_TRACE_HIST_SIZE];
	ctrace_t                im6o_refrele[IM6O_TRACE_HIST_SIZE];
};
struct  ip6q {
	struct ip6asfrag *ip6q_down;
	struct ip6asfrag *ip6q_up;
	u_int32_t       ip6q_ident;
	u_int8_t        ip6q_nxt;
	u_int8_t        ip6q_ecn;
	u_int8_t        ip6q_ttl;
	struct in6_addr ip6q_src, ip6q_dst;
	struct ip6q     *ip6q_next;
	struct ip6q     *ip6q_prev;
	int             ip6q_unfrglen;  
	int             ip6q_nfrag;     
	uint32_t        ip6q_csum_flags; 
	uint32_t        ip6q_csum;      
	uint32_t        ip6q_flags;
	uint32_t        ip6q_dst_ifscope, ip6q_src_ifscope;
};
struct  ip6_moptions {
	decl_lck_mtx_data(, im6o_lock);
	uint32_t im6o_refcnt;           
	uint32_t im6o_debug;            
	struct  ifnet *im6o_multicast_ifp; 
	u_char  im6o_multicast_hlim;    
	u_char  im6o_multicast_loop;    
	u_short im6o_num_memberships;   
	u_short im6o_max_memberships;   
	u_short im6o_max_filters;       
	struct  in6_multi **__counted_by(im6o_max_memberships) im6o_membership;
	struct  in6_mfilter *__counted_by(im6o_max_filters) im6o_mfilters;
	void (*im6o_trace)              
	(struct ip6_moptions *, int);
};
struct ip6_exthdrs {
	struct mbuf *ip6e_ip6;
	struct mbuf *ip6e_hbh;
	struct mbuf *ip6e_dest1;
	struct mbuf *ip6e_rthdr;
	struct mbuf *ip6e_dest2;
	boolean_t merged;
};
struct  ip6po_rhinfo {
	struct  ip6_rthdr *ip6po_rhi_rthdr; 
	struct  route_in6 ip6po_rhi_route; 
};
struct  ip6po_nhinfo {
	struct  sockaddr *ip6po_nhi_nexthop;
	struct  route_in6 ip6po_nhi_route; 
};
struct  ip6_pktopts {
	struct  mbuf *ip6po_m;  
	int     ip6po_hlim;     

	struct  in6_pktinfo *ip6po_pktinfo;

	struct  ip6po_nhinfo ip6po_nhinfo;

	struct  ip6_hbh *ip6po_hbh; 

	struct  ip6_dest *ip6po_dest1;

	struct  ip6po_rhinfo ip6po_rhinfo;

	struct  ip6_dest *ip6po_dest2;

	int     ip6po_tclass;   

	int     ip6po_minmtu;  

	int     ip6po_prefer_tempaddr;


	int ip6po_flags;
};
struct  ip6stat {
	u_quad_t ip6s_total;            
	u_quad_t ip6s_tooshort;         
	u_quad_t ip6s_toosmall;         
	u_quad_t ip6s_fragments;        
	u_quad_t ip6s_fragdropped;      
	u_quad_t ip6s_fragtimeout;      
	u_quad_t ip6s_fragoverflow;     
	u_quad_t ip6s_forward;          
	u_quad_t ip6s_cantforward;      
	u_quad_t ip6s_redirectsent;     
	u_quad_t ip6s_delivered;        
	u_quad_t ip6s_localout;         
	u_quad_t ip6s_odropped;         
	u_quad_t ip6s_reassembled;      
	u_quad_t ip6s_atmfrag_rcvd;     
	u_quad_t ip6s_fragmented;       
	u_quad_t ip6s_ofragments;       
	u_quad_t ip6s_cantfrag;         
	u_quad_t ip6s_badoptions;       
	u_quad_t ip6s_noroute;          
	u_quad_t ip6s_badvers;          
	u_quad_t ip6s_rawout;           
	u_quad_t ip6s_badscope;         
	u_quad_t ip6s_notmember;        
	u_quad_t ip6s_nxthist[256];     
	u_quad_t ip6s_m1;               
	u_quad_t ip6s_m2m[32];          
	u_quad_t ip6s_mext1;            
	u_quad_t ip6s_mext2m;           
	u_quad_t ip6s_exthdrtoolong;    
	u_quad_t ip6s_nogif;            
	u_quad_t ip6s_toomanyhdr;       

	u_quad_t ip6s_sources_none;
	u_quad_t ip6s_sources_sameif[SCOPE6_ID_MAX];
	u_quad_t ip6s_sources_otherif[SCOPE6_ID_MAX];
	u_quad_t ip6s_sources_samescope[SCOPE6_ID_MAX];
	u_quad_t ip6s_sources_otherscope[SCOPE6_ID_MAX];
	u_quad_t ip6s_sources_deprecated[SCOPE6_ID_MAX];

	u_quad_t ip6s_forward_cachehit;
	u_quad_t ip6s_forward_cachemiss;

	u_quad_t ip6s_sources_rule[IP6S_SRCRULE_COUNT];

	u_quad_t ip6s_sources_skip_expensive_secondary_if;

	u_quad_t ip6s_pktdropcntrl;

	u_quad_t ip6s_adj;
	u_quad_t ip6s_adj_hwcsum_clr;

	u_quad_t ip6s_dad_collide;

	u_quad_t ip6s_dad_loopcount;

	u_quad_t ip6s_necp_policy_drop;

	u_quad_t ip6s_clat464_in_tooshort_drop;
	u_quad_t ip6s_clat464_in_nov6addr_drop;
	u_quad_t ip6s_clat464_in_nov4addr_drop;
	u_quad_t ip6s_clat464_in_v4synthfail_drop;
	u_quad_t ip6s_clat464_in_64transfail_drop;
	u_quad_t ip6s_clat464_in_64proto_transfail_drop;
	u_quad_t ip6s_clat464_in_64frag_transfail_drop;
	u_quad_t ip6s_clat464_in_invalpbuf_drop;
	u_quad_t ip6s_clat464_in_success;
	u_quad_t ip6s_clat464_in_drop;
	u_quad_t ip6s_clat464_in_v4_drop;

	u_quad_t ip6s_clat464_out_nov6addr_drop;
	u_quad_t ip6s_clat464_out_v6synthfail_drop;
	u_quad_t ip6s_clat464_out_46transfail_drop;
	u_quad_t ip6s_clat464_out_46proto_transfail_drop;
	u_quad_t ip6s_clat464_out_46frag_transfail_drop;
	u_quad_t ip6s_clat464_out_invalpbuf_drop;
	u_quad_t ip6s_clat464_out_success;
	u_quad_t ip6s_clat464_out_drop;

	u_quad_t ip6s_clat464_v6addr_conffail;
	u_quad_t ip6s_clat464_plat64_pfx_setfail;
	u_quad_t ip6s_clat464_plat64_pfx_getfail;

	u_quad_t ip6s_overlap_frag_drop;

	u_quad_t ip6s_rcv_if_weak_match;
	u_quad_t ip6s_rcv_if_no_match;
};
struct ip6aux {
	u_int32_t ip6a_flags;


	u_char ip6a_ehsrc[ETHER_ADDR_LEN];
};
struct ip6_out_args {
	unsigned int    ip6oa_boundif;  
	struct flowadv  ip6oa_flowadv;  
	u_int32_t       ip6oa_flags;    
	int             ip6oa_sotc;             
	int             ip6oa_netsvctype;
	int32_t         qos_marking_gencount;
};
struct ipcomp {
	u_int8_t comp_nxt;      
	u_int8_t comp_flags;    
	u_int16_t comp_cpi;     
};
struct ipsec_tag {
	struct socket          *socket;
	u_int32_t               history_count;
};
struct ipsec_tag_container {
	struct m_tag            ipsec_m_tag;
	struct ipsec_tag        ipsec_tag;
};
struct secpolicyaddrrange {
	struct sockaddr_storage start;  
	struct sockaddr_storage end;    
};
struct secpolicyindex {
	u_int8_t dir;                   
	struct sockaddr_storage src;    
	struct sockaddr_storage dst;    
	u_int8_t prefs;                 
	u_int8_t prefd;                 
	u_int8_t ul_proto;             
	ifnet_t internal_if; 
	struct secpolicyaddrrange src_range;    
	struct secpolicyaddrrange dst_range;    
};
struct secpolicy {
	LIST_ENTRY(secpolicy) chain;

	int refcnt;                     
	struct secpolicyindex spidx;    
	u_int32_t id;                   
	u_int state;                    

	u_int policy;           
	struct ipsecrequest *req;

	ifnet_t ipsec_if; 
	ifnet_t outgoing_if; 

	char disabled; 

	u_int64_t created;      
	u_int64_t lastused;     
	u_int64_t lifetime;     
	u_int64_t validtime;    
};
struct ipsecrequest {
	struct ipsecrequest *next;
	struct secasindex saidx;
	                        
	u_int level;            

	struct secpolicy *sp;   
};
struct inpcbpolicy {
	struct secpolicy *sp_in;
	struct secpolicy *sp_out;
	int priv;                       
};
struct secspacq {
	LIST_ENTRY(secspacq) chain;

	struct secpolicyindex spidx;

	u_int64_t created;      
	int count;              
};
struct ipsecstat {
	u_quad_t in_success __attribute__ ((aligned(8)));  
	u_quad_t in_polvio __attribute__ ((aligned(8)));
	u_quad_t in_nosa __attribute__ ((aligned(8)));      
	u_quad_t in_inval __attribute__ ((aligned(8)));     
	u_quad_t in_nomem __attribute__ ((aligned(8)));     
	u_quad_t in_badspi __attribute__ ((aligned(8)));    
	u_quad_t in_ahreplay __attribute__ ((aligned(8)));  
	u_quad_t in_espreplay __attribute__ ((aligned(8)));  
	u_quad_t in_ahauthsucc __attribute__ ((aligned(8)));  
	u_quad_t in_ahauthfail __attribute__ ((aligned(8)));  
	u_quad_t in_espauthsucc __attribute__ ((aligned(8)));  
	u_quad_t in_espauthfail __attribute__ ((aligned(8)));  
	u_quad_t in_esphist[256] __attribute__ ((aligned(8)));
	u_quad_t in_ahhist[256] __attribute__ ((aligned(8)));
	u_quad_t in_comphist[256] __attribute__ ((aligned(8)));
	u_quad_t out_success __attribute__ ((aligned(8)));  
	u_quad_t out_polvio __attribute__ ((aligned(8)));
	u_quad_t out_nosa __attribute__ ((aligned(8)));     
	u_quad_t out_inval __attribute__ ((aligned(8)));    
	u_quad_t out_nomem __attribute__ ((aligned(8)));     
	u_quad_t out_noroute __attribute__ ((aligned(8)));  
	u_quad_t out_esphist[256] __attribute__ ((aligned(8)));
	u_quad_t out_ahhist[256] __attribute__ ((aligned(8)));
	u_quad_t out_comphist[256] __attribute__ ((aligned(8)));
};
struct ipsec_wake_pkt_info {
	u_int8_t wake_pkt[IPSEC_MAX_WAKE_PKT_LEN];
	uuid_string_t wake_uuid;
	u_int32_t wake_pkt_spi;
	u_int32_t wake_pkt_seq;
	u_int16_t wake_pkt_len;
};
struct ipsec_wake_pkt_event_data {
	uuid_string_t wake_uuid;
};
struct ipsec_output_state {
	int tunneled;
	struct mbuf *m;
	struct route_in6 ro;
	struct sockaddr *dst;
	u_int outgoing_if;
	u_int32_t dscp_mapping;
};
struct ipsec_history {
	int ih_proto;
	u_int32_t ih_spi;
};
struct mld_raopt {
	struct ip6_hbh          hbh;
	struct ip6_opt          pad;
	struct ip6_opt_router   ra;
} __packed;
struct mldv2_query {
	struct icmp6_hdr        mld_icmp6_hdr;  
	struct in6_addr         mld_addr;       
	uint8_t         mld_misc;       
	uint8_t         mld_qqi;        
	uint16_t        mld_numsrc;     
} __attribute__((__packed__));
struct mldv2_report {
	struct icmp6_hdr        mld_icmp6_hdr;
} __attribute__((__packed__));
struct mldv2_record {
	uint8_t                 mr_type;        
	uint8_t                 mr_datalen;     
	uint16_t                mr_numsrc;      
	struct in6_addr         mr_addr;        
} __attribute__((__packed__));
struct nd6svc_arg {
	int draining;
	uint32_t killed;
	uint32_t aging_lazy;
	uint32_t aging;
	uint32_t sticky;
	uint32_t found;
};
struct  llinfo_nd6 {
	struct  llinfo_nd6 *ln_next;
	struct  llinfo_nd6 *ln_prev;
	struct  rtentry *ln_rt;
	struct ifnet *ln_exclifp; 
	struct  mbuf *ln_hold;  
	uint32_t ln_asked;      
	short   ln_state;       
	short   ln_router;      
	u_int32_t ln_flags;     
	u_int64_t ln_expire;    
	u_int64_t ln_lastused;  
	struct  if_llreach *ln_llreach; 
};
struct {
		u_int32_t linkmtu;      
		u_int32_t maxmtu;       
		u_int32_t basereachable; 
		u_int32_t reachable;    
		u_int32_t retrans;      
		u_int32_t flags;        
		int recalctm;           
		u_int8_t chlim;         
		
		u_int8_t receivedra;
		
		u_int8_t collision_count;
	} ndi;
struct {
		struct nd_opt_hdr *zero;
		struct nd_opt_hdr *src_lladdr;
		struct nd_opt_hdr *tgt_lladdr;
		struct nd_opt_prefix_info *pi_beg; 
		struct nd_opt_rd_hdr *rh;
		struct nd_opt_mtu *mtu;
		struct nd_opt_hdr *__res6;
		struct nd_opt_hdr *__res7;
		struct nd_opt_hdr *__res8;
		struct nd_opt_hdr *__res9;
		struct nd_opt_hdr *__res10;
		struct nd_opt_hdr *__res11;
		struct nd_opt_hdr *__res12;
		struct nd_opt_hdr *__res13;
		struct nd_opt_nonce *nonce;
		struct nd_opt_hdr *__res15;
		struct nd_opt_hdr *__res16;
		struct nd_opt_hdr *__res17;
		struct nd_opt_hdr *__res18;
		struct nd_opt_hdr *__res19;
		struct nd_opt_hdr *__res20;
		struct nd_opt_hdr *__res21;
		struct nd_opt_hdr *__res22;
		struct nd_opt_hdr *__res23;
		struct nd_opt_route_info *rti_beg;
		struct nd_opt_hdr *__res25;
		struct nd_opt_hdr *__ended_by(last) search; 
		struct nd_opt_hdr *last;                    
		uint8_t done;
		uint8_t initialized;
		struct nd_opt_prefix_info *pi_end; 
		struct nd_opt_route_info *rti_end; 
	} nd_opt_each;
struct dadq {
	decl_lck_mtx_data(, dad_lock);
	u_int32_t dad_refcount; 
	int dad_attached;
	TAILQ_ENTRY(dadq) dad_list;
	struct ifaddr *dad_ifa;
	int dad_count;          
	int dad_ns_tcount;      
	int dad_ns_ocount;      
	int dad_ns_icount;
	int dad_na_icount;
	int dad_ns_lcount;      
	int dad_loopbackprobe;  
	uint8_t dad_lladdr[ETHER_ADDR_LEN];
	uint8_t dad_lladdrlen;
	uint32_t dad_nonce[ND_OPT_NONCE_LEN32];
	uint32_t dad_same_nonce_count; 
};
struct nd6_prproxy_prelist {
	SLIST_ENTRY(nd6_prproxy_prelist) ndprl_le;
	struct nd_prefix *ndprl_pr;             
	struct nd_prefix *ndprl_up;             
	struct ifnet    *ndprl_fwd_ifp;         
	boolean_t       ndprl_sol;              
	struct in6_addr ndprl_sol_saddr;        
};
struct nd6_prproxy_solsrc {
	TAILQ_ENTRY(nd6_prproxy_solsrc) solsrc_tqe;
	struct in6_addr solsrc_saddr;           
	struct ifnet    *solsrc_ifp;            
};
struct nd6_prproxy_soltgt {
	RB_ENTRY(nd6_prproxy_soltgt) soltgt_link; 
	struct soltgt_key_s {
		struct in6_addr taddr;          
	} soltgt_key;
	u_int64_t       soltgt_expire;          
	u_int32_t       soltgt_cnt;             
	TAILQ_HEAD(, nd6_prproxy_solsrc) soltgt_q;
};
struct nd_prefix_dbg {
	struct nd_prefix        ndpr_pr;                
	u_int16_t               ndpr_refhold_cnt;       
	u_int16_t               ndpr_refrele_cnt;       
	ctrace_t                ndpr_refhold[NDPR_TRACE_HIST_SIZE];
	ctrace_t                ndpr_refrele[NDPR_TRACE_HIST_SIZE];
};
struct nd_defrouter_dbg {
	struct nd_defrouter     nddr_dr;                
	uint16_t                nddr_refhold_cnt;       
	uint16_t                nddr_refrele_cnt;       
	ctrace_t                nddr_refhold[NDDR_TRACE_HIST_SIZE];
	ctrace_t                nddr_refrele[NDDR_TRACE_HIST_SIZE];
};
struct nd_ifinfo {
	decl_lck_mtx_data(, lock);
	boolean_t initialized;          
	u_int32_t linkmtu;              
	u_int32_t maxmtu;               
	u_int32_t basereachable;        
	u_int32_t reachable;            
	u_int32_t retrans;              
	u_int32_t flags;                
	int recalctm;                   
	u_int8_t chlim;                 
	u_int8_t _pad[3];
	u_int8_t randomseed0[8]; 
	u_int8_t randomseed1[8]; 
	u_int8_t randomid[8];   
	int32_t nprefixes;
	int32_t ndefrouters;
	boolean_t cga_initialized;
	struct in6_cga_modifier local_cga_modifier;
	uint8_t cga_collision_count;
};
struct rip6stat {
	u_quad_t rip6s_ipackets;        
	u_quad_t rip6s_isum;            
	u_quad_t rip6s_badsum;          
	u_quad_t rip6s_nosock;          
	u_quad_t rip6s_nosockmcast;     
	u_quad_t rip6s_fullsock;        

	u_quad_t rip6s_opackets;        
};
struct scope6_id {
	u_int32_t s6id_list[SCOPE6_ID_MAX];
};
struct _keystat {
	u_int32_t getspi_count; 
} keystat;
struct sadb_ext_entry {
	int ext_len;
	uint16_t ext_type;
	struct sadb_ext *__sized_by(ext_len) ext_buf;
};
struct sadb_msghdr {
	struct sadb_msg *msg;
	struct sadb_ext_entry ext[SADB_EXT_MAX + 1];
	int extoff[SADB_EXT_MAX + 1];
	int extlen[SADB_EXT_MAX + 1];
};
struct sav_dump_elem {
	struct secasvar *sav;
	u_int8_t satype;
};
struct secasindex {
	struct sockaddr_storage src;    
	struct sockaddr_storage dst;    
	u_int16_t proto;                
	u_int8_t mode;                  
	u_int32_t reqid;                
	                                
	u_int ipsec_ifindex;
};
struct secashead {
	LIST_ENTRY(secashead) chain;

	struct secasindex saidx;

	ifnet_t ipsec_if;
	u_int outgoing_if;
	u_int8_t dir;                   
	u_int8_t state;                 
	LIST_HEAD(_satree, secasvar) savtree[SADB_SASTATE_MAX + 1];

	struct route_in6 sa_route;              

	uint16_t flags;
	u_int32_t use_count;
};
struct secasvar {
	LIST_ENTRY(secasvar) chain;
	LIST_ENTRY(secasvar) spihash;
	int refcnt;                     
	u_int8_t state;                 

	u_int8_t alg_auth;              
	u_int8_t alg_enc;               
	u_int32_t spi;                  
	u_int32_t flags;                
	u_int16_t flags2;               

	struct sadb_key *__sized_by(key_auth_len) key_auth;     
	struct sadb_key *__sized_by(key_enc_len) key_enc;       
	caddr_t __sized_by(ivlen) iv;                           
	void *__sized_by(schedlen_auth) sched_auth;             
	void *__sized_by(schedlen_enc) sched_enc;               
	uint32_t key_auth_len;
	uint32_t key_enc_len;
	size_t schedlen_auth;
	size_t schedlen_enc;
	u_int ivlen;                                            

	struct secreplay *replay[MAX_REPLAY_WINDOWS]; 

	u_int64_t created;              

	struct sadb_lifetime *lft_c;    
	struct sadb_lifetime *lft_h;    
	struct sadb_lifetime *lft_s;    

	struct socket *so; 

	u_int32_t seq;                  
	pid_t pid;                      

	struct secashead *sah;          

	u_int64_t       natt_last_activity;
	u_int16_t       remote_ike_port;
	u_int16_t       natt_encapsulated_src_port;     
	u_int16_t       natt_interval; 
	u_int16_t       natt_offload_interval; 
	uint32_t        flowid;

	u_int8_t        always_expire; 
};
struct secreplay {
	u_int8_t wsize;                          
	u_int32_t count;                         
	u_int32_t seq;                           
	u_int32_t lastseq;                       
	caddr_t __sized_by(wsize) bitmap;        
	int overflow;                            
};
struct secreg {
	LIST_ENTRY(secreg) chain;

	struct socket *so;
};
struct secacq {
	LIST_ENTRY(secacq) chain;

	struct secasindex saidx;

	u_int32_t seq;          
	u_int64_t created;      
	int count;              
};
struct key_cb {
	int key_count;
	int any_count;
};
struct pfkeystat {
	u_quad_t out_total;             
	u_quad_t out_bytes;             
	u_quad_t out_msgtype[256];      
	u_quad_t out_invlen;            
	u_quad_t out_invver;            
	u_quad_t out_invmsgtype;        
	u_quad_t out_tooshort;          
	u_quad_t out_nomem;             
	u_quad_t out_dupext;            
	u_quad_t out_invexttype;        
	u_quad_t out_invsatype;         
	u_quad_t out_invaddr;           
	u_quad_t in_total;              
	u_quad_t in_bytes;              
	u_quad_t in_msgtype[256];       
	u_quad_t in_msgtarget[3];       
	u_quad_t in_nomem;              
	u_quad_t sockerr;               
};
struct keycb {
	struct rawcb kp_raw;    
	int kp_promisc;         
	int kp_registered;      
};
struct nfs_etype {
	uint32_t count;
	uint32_t selected;  
	nfs_supported_kerberos_etypes etypes[NFS_MAX_ETYPES];
};
struct nfs_args {
	int             version;        
	user32_addr_t addr;             
	uint8_t         addrlen;        
	int             sotype;         
	int             proto;          
	user32_addr_t fh;               
	int             fhsize;         
	int             flags;          
	int             wsize;          
	int             rsize;          
	int             readdirsize;    
	int             timeo;          
	int             retrans;        
	int             maxgrouplist;   
	int             readahead;      
	int             leaseterm;      
	int             deadthresh;     
	user32_addr_t hostname; 
	int             acregmin;       
	int             acregmax;       
	int             acdirmin;       
	int             acdirmax;       
	uint32_t        auth;           
	uint32_t        deadtimeout;    
};
struct user_nfs_args {
	int             version;        
	user_addr_t     addr __attribute((aligned(8)));         
	uint8_t         addrlen;        
	int             sotype;         
	int             proto;          
	user_addr_t     fh __attribute((aligned(8)));           
	int             fhsize;         
	int             flags;          
	int             wsize;          
	int             rsize;          
	int             readdirsize;    
	int             timeo;          
	int             retrans;        
	int             maxgrouplist;   
	int             readahead;      
	int             leaseterm;      
	int             deadthresh;     
	user_addr_t     hostname __attribute((aligned(8)));     
	int             acregmin;       
	int             acregmax;       
	int             acdirmin;       
	int             acdirmax;       
	uint32_t        auth;           
	uint32_t        deadtimeout;    
};
struct nfsd_args {
	int     sock;           
	user32_addr_t   name;           
	int     namelen;        
};
struct user_nfsd_args {
	int             sock;           
	user_addr_t     name __attribute((aligned(8)));         
	int             namelen;        
};
struct nfs_exphandle {
	uint32_t        nxh_version;            
	uint32_t        nxh_fsid;               
	uint32_t        nxh_expid;              
	uint16_t        nxh_flags;              
	uint8_t         nxh_reserved;           
	uint32_t        nxh_fidlen;             
};
struct nfs_filehandle {
	uint32_t                nfh_len;        
	struct nfs_exphandle    nfh_xh;         
	unsigned char           nfh_fid[NFS_MAX_FID_SIZE]; 
	unsigned char           *nfh_fhp;       
};
struct nfs_sec {
	int count;
	uint32_t flavors[NX_MAX_SEC_FLAVORS];
};
struct nfs_export_net_args {
	uint32_t                nxna_flags;     
	struct xucred           nxna_cred;      
	struct sockaddr_storage nxna_addr;      
	struct sockaddr_storage nxna_mask;      
	struct nfs_sec          nxna_sec;       
};
struct nfs_export_args {
	uint32_t                nxa_fsid;       
	uint32_t                nxa_expid;      
	user32_addr_t           nxa_fspath;     
	user32_addr_t           nxa_exppath;    
	uint32_t                nxa_flags;      
	uint32_t                nxa_netcount;   
	user32_addr_t           nxa_nets;       
};
struct user_nfs_export_args {
	uint32_t                nxa_fsid;       
	uint32_t                nxa_expid;      
	user_addr_t             nxa_fspath;     
	user_addr_t             nxa_exppath;    
	uint32_t                nxa_flags;      
	uint32_t                nxa_netcount;   
	user_addr_t             nxa_nets;       
};
struct nfs_export_stat_desc {
	uint32_t rec_vers;              
	uint64_t rec_count;             
}__attribute__((__packed__));
struct nfs_export_stat_rec {
	char     path[RPCMNT_PATHLEN + 1];
	uint64_t ops;           
	uint64_t bytes_read;    
	uint64_t bytes_written; 
}__attribute__((__packed__));
struct nfs_user_stat_desc {
	uint32_t rec_vers;      
	uint32_t rec_count;     
}__attribute__((__packed__));
struct nfs_user_stat_user_rec {
	u_char                  rec_type;
	uid_t                   uid;
	struct sockaddr_storage sock;
	uint64_t                ops;
	uint64_t                bytes_read;
	uint64_t                bytes_written;
	time_t                  tm_start;
	time_t                  tm_last;
}__attribute__((__packed__));
struct nfs_user_stat_path_rec {
	u_char  rec_type;
	char    path[RPCMNT_PATHLEN + 1];
}__attribute__((__packed__));
struct nfs_export_options {
	uint32_t                nxo_flags;      
	kauth_cred_t            nxo_cred;       
	struct nfs_sec          nxo_sec;        
};
struct nfs_netopt {
	struct radix_node               no_rnodes[2];   
	struct nfs_export_options       no_opt;         
	struct sockaddr                 *no_addr;       
	struct sockaddr                 *no_mask;       
};
struct nfsstatcount64 {
	uint32_t        hi;
	uint32_t        lo;
} nfsstatcount64;
struct nfs_export_stat_counters {
	struct nfsstatcount64 ops;              
	struct nfsstatcount64 bytes_read;       
	struct nfsstatcount64 bytes_written;    
};
struct nfs_user_stat_node {
	TAILQ_ENTRY(nfs_user_stat_node) lru_link;
	LIST_ENTRY(nfs_user_stat_node)  hash_link;
	uid_t                   uid;
	struct sockaddr_storage sock;
	uint64_t                ops;
	uint64_t                bytes_read;
	uint64_t                bytes_written;
	time_t                  tm_start;
	time_t                  tm_last;
};
struct nfs_active_user_list {
	struct nfs_user_stat_lru_head           user_lru;
	struct nfs_user_stat_hashtbl_head       user_hashtbl[NFS_USER_STAT_HASH_SIZE];
	uint32_t                                node_count;
	lck_mtx_t user_mutex;
};
struct nfs_export {
	LIST_ENTRY(nfs_export)          nx_next;        
	LIST_ENTRY(nfs_export)          nx_hash;        
	struct nfs_export               *nx_parent;     
	uint32_t                        nx_id;          
	uint32_t                        nx_flags;       
	struct nfs_exportfs             *nx_fs;         
	char                            *nx_path;       
	struct nfs_filehandle           nx_fh;          
	struct nfs_export_options       nx_defopt;      
	uint32_t                        nx_expcnt;      
	struct radix_node_head          *nx_rtable[AF_MAX + 1]; 
	struct nfs_export_stat_counters nx_stats;       
	struct nfs_active_user_list     nx_user_list;   
	struct timeval                  nx_exptime;     
};
struct nfs_exportfs {
	LIST_ENTRY(nfs_exportfs)        nxfs_next;      
	uint32_t                        nxfs_id;        
	char                            *nxfs_path;     
	LIST_HEAD(, nfs_export)          nxfs_exports;   
};
struct nfserr_info {
	const char *    nei_name;
	const int       nei_error;
	const int       nei_index;
} nfserr_info_t;
struct lockd_ans {
	int             la_version;             
	int             la_errno;               
	u_int64_t       la_xid;                 
	int             la_flags;               
	pid_t           la_pid;                 
	off_t           la_start;               
	off_t           la_len;                 
	int             la_fh_len;              
	u_int8_t        la_fh[NFSV3_MAX_FH_SIZE];
};
struct lockd_notify {
	int                     ln_version;             
	int                     ln_flags;               
	int                     ln_pad;                 
	int                     ln_addrcount;           
	struct sockaddr_storage *ln_addr;               
};
struct nfs_testmapid {
	uint32_t                ntm_lookup;     
	uint32_t                ntm_grpflag;    
	uint32_t                ntm_id;         
	uint32_t                pad;
	guid_t                  ntm_guid;       
	char                    ntm_name[MAXIDNAMELEN]; 
};
struct nfs_hooks_in {
	int       (*f_vinvalbuf)(vnode_t, int, vfs_context_t, int);
	int       (*f_buf_page_inval)(vnode_t, off_t);
};
struct nfs_hooks_out {
	void *    (*f_get_bsdthreadtask_info)(thread_t);
};
struct nfsm_chain {
	mbuf_t          nmc_mhead;      
	mbuf_t          nmc_mcur;       
	caddr_t         nmc_ptr;        
	size_t          nmc_left;       
	uint32_t        nmc_flags;      
};
struct gss_seq {
	SLIST_ENTRY(gss_seq)    gss_seqnext;
	uint32_t                gss_seqnum;
};
struct nfsrv_sock {
	TAILQ_ENTRY(nfsrv_sock) ns_chain;       
	TAILQ_ENTRY(nfsrv_sock) ns_svcq;        
	TAILQ_ENTRY(nfsrv_sock) ns_wgq;         
	struct nfsrv_uc_arg *ns_ua;             
	lck_rw_t        ns_rwlock;              
	socket_t        ns_so;
	mbuf_t          ns_nam;
	mbuf_t          ns_raw;
	mbuf_t          ns_rawend;
	mbuf_t          ns_rec;
	mbuf_t          ns_recend;
	mbuf_t          ns_frag;
	int             ns_flag;
	int             ns_sotype;
	size_t          ns_cc;
	u_int32_t       ns_reclen;              
	u_int32_t       ns_recslen;             
	int             ns_reccnt;
	u_int32_t       ns_sref;
	time_t          ns_timestamp;           
	lck_mtx_t       ns_wgmutex;             
	time_t          ns_wgtime;              
	LIST_HEAD(, nfsrv_descript) ns_tq;      
	LIST_HEAD(nfsrv_wg_delayhash, nfsrv_descript) ns_wdelayhashtbl[NFS_WDELAYHASHSIZ];
};
struct nfsd {
	TAILQ_ENTRY(nfsd)       nfsd_chain;     
	TAILQ_ENTRY(nfsd)       nfsd_queue;     
	int                     nfsd_flag;      
	struct nfsrv_sock       *nfsd_slp;      
	struct nfsrv_descript   *nfsd_nd;       
};
struct nfsrv_descript {
	time_t                  nd_time;        
	off_t                   nd_off;         
	off_t                   nd_eoff;        
	LIST_ENTRY(nfsrv_descript) nd_hash;     
	LIST_ENTRY(nfsrv_descript) nd_tq;       
	LIST_HEAD(, nfsrv_descript) nd_coalesce; 
	struct nfsm_chain       nd_nmreq;       
	mbuf_t                  nd_mrep;        
	mbuf_t                  nd_nam;         
	mbuf_t                  nd_nam2;        
	u_int32_t               nd_procnum;     
	int                     nd_stable;      
	int                     nd_vers;        
	int                     nd_len;         
	int                     nd_repstat;     
	u_int32_t               nd_retxid;      
	struct timeval          nd_starttime;   
	struct nfs_filehandle   nd_fh;          
	uint32_t                nd_sec;         
	struct nfs_gss_svc_ctx  *nd_gss_context;
	uint32_t                nd_gss_seqnum;  
	mbuf_t                  nd_gss_mb;      
	kauth_cred_t            nd_cr;          
};
struct nfs_dlmount {
	struct sockaddr_in ndm_saddr;           
	char            ndm_host[MAXHOSTNAMELEN];
	char            *ndm_path;              
	char            *ndm_mntfrom;           
	u_int32_t               ndm_nfsv3;              
	u_int32_t               ndm_sotype;             
	u_int32_t               ndm_fhlen;              
	u_char          ndm_fh[NFSX_V3FHMAX];   
};
struct nfs_diskless {
	struct nfs_dlmount nd_root;     
	struct nfs_dlmount nd_private;  
};
struct nfs_uquad {
	u_int32_t       nfsuquad[2];
};
struct nfs_specdata {
	uint32_t specdata1;     
	uint32_t specdata2;     
};
struct nfs_fsid {
	uint64_t major;
	uint64_t minor;
};
struct nfs_stateid {
	uint32_t        seqid;
	uint32_t        other[3];
};
struct nfsrvcache {
	TAILQ_ENTRY(nfsrvcache) rc_lru;         
	LIST_ENTRY(nfsrvcache) rc_hash;         
	u_int32_t       rc_xid;                         
	union {
		mbuf_t ru_repmb;                
		int ru_repstat;                 
	} rc_un;
	sa_family_t rc_family;                  
	union nethostaddr rc_haddr;             
	u_int32_t rc_proc;                      
	u_char  rc_state;               
	u_char  rc_flag;                
};
struct nfs_gss_svc_ctx {
	lck_mtx_t               gss_svc_mtx;
	LIST_ENTRY(nfs_gss_svc_ctx)     gss_svc_entries;
	uint32_t                gss_svc_handle;         
	uint32_t                gss_svc_refcnt;         
	uint32_t                gss_svc_proc;           
	uid_t                   gss_svc_uid;            
	gid_t                   gss_svc_gids[NGROUPS];  
	uint32_t                gss_svc_ngroups;        
	uint64_t                gss_svc_incarnation;    
	uint32_t                gss_svc_seqmax;         
	uint32_t                gss_svc_seqwin;         
	uint32_t                *gss_svc_seqbits;       
	gssd_cred               gss_svc_cred_handle;    
	gssd_ctx                gss_svc_context;        
	gss_ctx_id_t            gss_svc_ctx_id;         
	u_char                  *gss_svc_token;         
	uint32_t                gss_svc_tokenlen;       
	uint32_t                gss_svc_major;          
	uint32_t                gss_svc_minor;          
};
struct xdrbuf {
	union {
		struct {
			char *                  xbb_base;       
			size_t                  xbb_size;       
			size_t                  xbb_len;        
		} xb_buffer;
	} xb_u;
	char *          xb_ptr;         
	size_t          xb_left;        
	size_t          xb_growsize;    
	xdrbuf_type     xb_type;        
	uint32_t        xb_flags;       
};
struct workq_usec_var {
	uint32_t usecs;
	uint64_t abstime;
};
struct workq_threadreq_extended_param_s {
	struct work_interval *trp_work_interval;
};
struct workq_threadreq_s {
	union {
		struct priority_queue_entry_sched tr_entry;
		STAILQ_ENTRY(workq_threadreq_s) tr_link;
		struct {
			thread_t tr_thread;
			
			struct work_interval *tr_work_interval;
		};
	};
	uint16_t           tr_count;
	workq_tr_flags_t   tr_flags;
	workq_tr_state_t   tr_state;
	thread_qos_t       tr_qos;                 

	kq_index_t         tr_kq_override_index;   
	kq_index_t         tr_kq_qos_index;        
} workq_threadreq_s, *workq_threadreq_t;
struct workqueue {
	thread_call_t   wq_delayed_call;
	thread_call_t   wq_immediate_call;
	thread_call_t   wq_death_call;

	union {
		struct turnstile *wq_turnstile;
		struct mpsc_queue_chain wq_destroy_link;
	};

	lck_ticket_t    wq_lock;

	uint64_t        wq_thread_call_last_run;
	struct os_refcnt wq_refcnt;
	workq_state_flags_t _Atomic wq_flags;
	uint32_t        wq_fulfilled;
	uint32_t        wq_creations;
	uint32_t        wq_timer_interval;
	uint32_t        wq_event_manager_priority;
	uint32_t        wq_reqcount;  
	uint16_t        wq_thdying_count;
	uint16_t        wq_threads_scheduled;
	uint16_t        wq_constrained_threads_scheduled;
	uint16_t        wq_nthreads;
	uint16_t        wq_thidlecount;
	uint16_t        wq_thscheduled_count[WORKQ_NUM_BUCKETS]; 

	workq_threadreq_t wq_event_manager_threadreq;

	_Atomic wq_thactive_t wq_thactive;
	_Atomic uint64_t wq_lastblocked_ts[WORKQ_NUM_QOS_BUCKETS];

	struct proc    *wq_proc;
	struct uthread *wq_creator;
	turnstile_inheritor_t wq_inheritor;
	thread_t wq_turnstile_updater; 
	struct workq_uthread_head wq_thrunlist;
	struct workq_uthread_head wq_thnewlist;
	struct workq_uthread_head wq_thidlelist;

	struct priority_queue_sched_max wq_overcommit_queue;
	struct priority_queue_sched_max wq_constrained_queue;
	struct priority_queue_sched_max wq_special_queue;

	uint8_t wq_cooperative_queue_scheduled_count[WORKQ_NUM_QOS_BUCKETS];
	uint16_t wq_cooperative_queue_best_req_qos: 3, 
	    wq_cooperative_queue_has_limited_max_size:1, 
	    wq_exceeded_active_constrained_thread_limit:1,
	    unused:11;
	struct workq_threadreq_tailq wq_cooperative_queue[WORKQ_NUM_QOS_BUCKETS];
};
struct workq_dispatch_config {
	uint32_t wdc_version;
	uint32_t wdc_flags;
	uint64_t wdc_queue_serialno_offs;
	uint64_t wdc_queue_label_offs;
} __attribute__((packed, aligned(4)));
struct {
	uint32_t        cres_pkt_alloc_failures;
	uint32_t        __cres_reserved[1];
} channel_ring_error_stats, *channel_ring_error_stats_t;
struct {
	uint64_t        crsu_total_slots_transferred;
	uint64_t        crsu_total_bytes_transferred;
	uint64_t        crsu_number_of_syncs;
	uint32_t        crsu_min_slots_transferred;
	uint32_t        crsu_max_slots_transferred;
	uint32_t        crsu_slots_per_sync;
	uint32_t        crsu_slots_per_sync_ma;
	uint64_t        crsu_bytes_per_sync;
	uint64_t        crsu_bytes_per_sync_ma;
	uint32_t        __crsu_reserved[2];
} channel_ring_user_stats, *channel_ring_user_stats_t;
struct {
	uint64_t        crs_total_slots_transferred;
	uint64_t        crs_total_bytes_transferred;
	uint64_t        crs_number_of_transfers;
	uint32_t        crs_min_slots_transferred;
	uint32_t        crs_max_slots_transferred;
	uint32_t        crs_slots_per_second;
	uint32_t        crs_slots_per_second_ma;
	uint64_t        crs_bytes_per_second;
	uint64_t        crs_bytes_per_second_ma;
	uint32_t        __crs_reserved[2];
} channel_ring_stats, *channel_ring_stats_t;
struct netif_qstats {
	uint64_t        nq_total_pkts;  
	uint64_t        nq_total_bytes; 
	uint64_t        nq_num_xfers;   
	uint32_t        nq_min_pkts;    
	uint32_t        nq_max_pkts;    
	uint32_t        nq_pkts_ps;     
	uint32_t        nq_pkts_ps_ma;  
	uint64_t        nq_bytes_ps;    
	uint64_t        nq_bytes_ps_ma; 
};
struct netif_qstats_info {
	uint64_t                            nqi_qset_id;
	uint16_t                            nqi_queue_flag;
	uint16_t                            nqi_queue_idx;
	packet_svc_class_t                  nqi_svc;
	struct netif_qstats                 nqi_stats;
};
struct {
	uuid_t          npi_prov_uuid;          
	struct nxprov_params npi_prov_params;   
	uint32_t        npi_instance_uuids_count;
	uint32_t        __npi_align_reserved;
	uuid_t          npi_instance_uuids[0];  
} nexus_provider_info, *nexus_provider_info_t;
struct {
	ring_id_t               ncre_ring_id;
	uint32_t                __ncre_align_reserved;
	channel_ring_stats              ncre_stats;
	channel_ring_user_stats         ncre_user_stats;
	channel_ring_error_stats        ncre_error_stats;
} nexus_channel_ring_entry, *nexus_channel_ring_entry_t;
struct {
	uuid_t          nce_uuid;       
	uint32_t        nce_flags;      
	pid_t           nce_pid;        
	int             nce_fd;         
	nexus_port_t    nce_port;       
	uint32_t        nce_tx_rings;   
	uint32_t        nce_rx_rings;   
	uint32_t        __nce_align_reserved;
	uint32_t        nce_ring_count; 
	nexus_channel_ring_entry nce_ring_entries[__counted_by(nce_ring_count)]; 
} nexus_channel_entry, *nexus_channel_entry_t;
struct {
	uuid_t          nci_instance_uuid;      
	uint32_t        nci_channel_entries_count;
	uint32_t        __nci_align_reserved;
	nexus_channel_entry     nci_channel_entries[__counted_by(nci_channel_entries_count)]; 
} nexus_channel_info, *nexus_channel_info_t;
struct __nx_stats_fsw {
	struct ip_stats                 nxs_ipstat;
	struct ip6_stats                nxs_ip6stat;
	struct tcp_stats                nxs_tcpstat;
	struct udp_stats                nxs_udpstat;
	struct quic_stats               nxs_quicstat;
};
struct __nx_stats_channel_errors {
	channel_ring_error_stats_t      nxs_cres;
};
struct __kern_nexus_adv_metadata {
	uint16_t                 knam_version;
	uint16_t                 __reserved;
	nexus_advisory_type_t    knam_type;
};
struct __kern_netif_intf_advisory {
	uint32_t                           cksum;
	uint32_t                           _reserved;
	struct ifnet_interface_advisory    adv;
} __attribute__((aligned(sizeof(uint64_t))));
struct netif_nexus_advisory {
	uint64_t nna_version;
	union {
		struct __kern_netif_intf_advisory __kern_intf_adv;
		uint8_t __nna_intf_adv[NX_INTF_ADV_SIZE];
	};
} __attribute__((aligned(sizeof(uint64_t))));
struct sk_nexusadv {
	uint64_t nxadv_ver;             
	uint64_t nxadv_fg_sendts;       
	uint64_t nxadv_rt_sendts;       
	union {
		struct __kern_netif_intf_advisory _nxadv_intf_adv;
		uint8_t _nxadv_reserved[NX_INTF_ADV_SIZE];
	};
} __attribute__((aligned(sizeof(uint64_t))));
struct sk_stats_flow_track {
	uint64_t        sft_bytes;      
	uint64_t        sft_packets;    
	uint64_t        sft_spackets;   
	sk_stats_flow_track_state_t sft_state;  
	uint32_t        sft_rtt;        
	uint32_t        sft_seq;        
	uint16_t        sft_max_win;    
	uint8_t         sft_wscale;     
};
struct sk_stats_flow {
	uuid_t          sf_nx_uuid;             
	uuid_t          sf_uuid;                
	char            sf_if_name[IFNAMSIZ];   
	uint32_t        sf_if_index;            
	uint32_t        sf_bucket_idx;          

	pid_t           sf_pid;                 
	pid_t           sf_epid;                
	char            sf_proc_name[32];       
	char            sf_eproc_name[32];      

	uint32_t        sf_flags;               
	nexus_port_t    sf_nx_port;             

	uint8_t         sf_protocol;            
	packet_svc_class_t sf_svc_class;        
	flowadv_idx_t   sf_adv_idx;             
	struct flow_key sf_key __attribute__((__aligned__(16)));

	volatile struct sk_stats_flow_track sf_ltrack; 
	volatile struct sk_stats_flow_track sf_rtrack; 

	activity_bitmap_t sf_activity;          
};
struct flow_stats {
	struct sk_stats_flow    fs_stats;

	os_refcnt_t             fs_refcnt;
};
struct sk_stats_flow_owner {
	uuid_t          sfo_nx_uuid;            
	char            sfo_if_name[IFNAMSIZ];  
	uint32_t        sfo_bucket_idx;         

	char            sfo_name[32];           
	pid_t           sfo_pid;                

	nexus_port_t    sfo_nx_port;            
	boolean_t       sfo_nx_port_pid_bound;  
	boolean_t       sfo_nx_port_destroyed;  
} __attribute__((aligned(64)));
struct sk_stats_flow_route {
	uuid_t          sfr_nx_uuid;            
	uuid_t          sfr_uuid;               
	char            sfr_if_name[IFNAMSIZ];  

	uint32_t        sfr_bucket_idx;         
	uint32_t        sfr_id_bucket_idx;      

	uint32_t        sfr_flags;              
	uint32_t        sfr_usecnt;             
	int64_t         sfr_expire;             

	union sockaddr_in_4_6 sfr_laddr;        
	union sockaddr_in_4_6 sfr_faddr;        
	union sockaddr_in_4_6 sfr_gaddr;        

	uint8_t         sfr_ether_dhost[ETHER_ADDR_LEN]
	__attribute__((aligned(64)));
};
struct sk_stats_net_if {
	uuid_t          sns_nx_uuid;            
	char            sns_if_name[IFNAMSIZ];  

	struct netif_stats      sns_nifs;       
} __attribute__((aligned(64)));
struct sk_stats_flow_switch {
	uuid_t          sfs_nx_uuid;            
	char            sfs_if_name[IFNAMSIZ];  

	struct fsw_stats        sfs_fsws;       
} __attribute__((aligned(64)));
struct sk_stats_userstack {
	uuid_t                  sus_nx_uuid;    
	char            sus_if_name[IFNAMSIZ];  
	pid_t                   sus_owner_pid;  

	struct ip_stats         sus_ip;         
	struct ip6_stats        sus_ip6;        
	struct tcp_stats        sus_tcp;        
	struct udp_stats        sus_udp;        
	struct quic_stats       sus_quic;       
} __attribute__((aligned(64)));
struct sk_stats_flow_adv_ent {
	uuid_t          sfae_flow_id;           
	uint32_t        sfae_flags;             
};
struct sk_stats_flow_adv {
	uuid_t          sfa_nx_uuid;            
	char            sfa_if_name[IFNAMSIZ];  
	pid_t           sfa_owner_pid;          

	uint32_t        sfa_entries_count;      
	struct sk_stats_flow_adv_ent    sfa_entries[__counted_by(sfa_entries_count)]; 
};
struct netns_ctl_dump_header {
	union {
		uint32_t        ncdh_addr[4];
		struct in_addr  ncdh_inaddr;
		struct in6_addr ncdh_in6addr;
	};
	uint8_t         ncdh_addr_len;
	uint8_t         ncdh_proto;
	uint32_t        ncdh_n_records;
} __attribute__((aligned(32)));
struct netns_ctl_dump_record {
	in_port_t ncdr_port;
	in_port_t ncdr_port_end;
	uint32_t  ncdr_skywalk_refs;
	uint32_t  ncdr_bsd_refs;
	uint32_t  ncdr_pf_refs;
	uint32_t  ncdr_listener_refs;
} __attribute__((aligned(32)));
struct sk_stats_protons_token {
	uint8_t                 spt_protocol;
	uint32_t                spt_refcnt;
	pid_t                   spt_pid;
	pid_t                   spt_epid;
};
struct sk_stats_flowidns_header {
	uint64_t sfh_nallocs;
	uint64_t sfh_nreleases;
	uint64_t sfh_ncollisions;
	uint32_t sfh_domain;
	uint32_t sfh_nrecords;
} __attribute__((aligned(32)));
struct sk_stats_flowidns_record {
	union {
		uint32_t        _addr[4];
		struct in_addr  _v4;
		struct in6_addr _v6;
	} sfr_laddr;
	union {
		uint32_t        _addr[4];
		struct in_addr  _v4;
		struct in6_addr _v6;
	} sfr_raddr;
	union {
		struct {
			uint16_t _lport;
			uint16_t _rport;
		} sfr_ports;
		uint32_t sfr_spi;
		uint32_t sfr_protoid;
	};
	uint32_t sfr_flowid;
	uint8_t  sfr_ipproto;
	uint8_t  sfr_af;
} __attribute__((aligned(32)));
struct sk_stats_region {
	char            sreg_name[64];          
	uuid_t          sreg_uuid;              
	sk_stats_region_id_t sreg_id;           
	uint32_t        sreg_mode;              

	uint64_t        sreg_r_seg_size;        
	uint64_t        sreg_c_seg_size;        
	uint64_t        sreg_seg_cnt;           
	uint64_t        sreg_seg_objs;          
	uint64_t        sreg_r_obj_size;        
	uint64_t        sreg_r_obj_cnt;         
	uint64_t        sreg_c_obj_size;        
	uint64_t        sreg_c_obj_cnt;         
	uint64_t        sreg_align;             
	uint64_t        sreg_max_frags;         

	uint64_t        sreg_meminuse;          
	uint64_t        sreg_w_meminuse;        
	uint64_t        sreg_memtotal;          
	uint64_t        sreg_seginuse;          
	uint64_t        sreg_rescale;           
	uint64_t        sreg_hash_size;         
	uint64_t        sreg_alloc;             
	uint64_t        sreg_free;              
};
struct sk_stats_arena {
	char                    sar_name[64];
	sk_stats_arena_type_t   sar_type;
	uint64_t                sar_mapsize;
	uuid_t                  sar_regions_uuid[SREG_MAX];
	pid_t                   sar_mapped_pids[SK_STATS_ARENA_MAPPED_PID_MAX];
};
struct sk_stats_cache {
	char            sca_name[64];           
	uuid_t          sca_uuid;               
	uuid_t          sca_ruuid;              
	uint32_t        sca_mode;               
	uint64_t        sca_bufsize;            
	uint64_t        sca_objsize;            
	uint64_t        sca_chunksize;          
	uint64_t        sca_slabsize;           
	uint64_t        sca_bufalign;           
	uint64_t        sca_objalign;           

	uint64_t        sca_cpu_mag_size;       
	uint64_t        sca_cpu_mag_resize;     
	uint64_t        sca_cpu_mag_purge;      
	uint64_t        sca_cpu_mag_reap;       
	uint64_t        sca_depot_full;         
	uint64_t        sca_depot_empty;        
	uint64_t        sca_depot_ws_zero;      
	uint64_t        sca_depot_contention_factor; 

	uint64_t        sca_cpu_rounds;         
	uint64_t        sca_cpu_prounds;

	uint64_t        sca_sl_create;          
	uint64_t        sca_sl_destroy;         
	uint64_t        sca_sl_alloc;           
	uint64_t        sca_sl_free;            
	uint64_t        sca_sl_alloc_fail;      
	uint64_t        sca_sl_partial;         
	uint64_t        sca_sl_empty;           
	uint64_t        sca_sl_bufinuse;        
	uint64_t        sca_sl_rescale;         
	uint64_t        sca_sl_hash_size;       
};
struct skmem_sysctl {
	uint32_t        version;
	struct {
		SKMEM_SYSCTL_TCP_LIST
	} tcp;
	struct {
		struct {
			SKMEM_SYSCTL_KERN_IPC_LIST
		} ipc;
	} kern;
} skmem_sysctl;
struct acct {
	char      ac_comm[10];  
	comp_t    ac_utime;     
	comp_t    ac_stime;     
	comp_t    ac_etime;     
	u_int32_t ac_btime;     
	uid_t     ac_uid;       
	gid_t     ac_gid;       
	u_int16_t ac_mem;       
	comp_t    ac_io;        
	dev_t     ac_tty;       

	u_int8_t  ac_flag;      
};
struct user_aiocb {
	int             aio_fildes;             
	off_t           aio_offset; 
	user_addr_t     aio_buf;                
	user_size_t     aio_nbytes;             
	int             aio_reqprio;    
	struct user_sigevent aio_sigevent;      
	int             aio_lio_opcode;         
};
struct user64_aiocb {
	int             aio_fildes;             
	user64_off_t            aio_offset; 
	user64_addr_t   aio_buf;                
	user64_size_t   aio_nbytes;             
	int             aio_reqprio;    
	struct user64_sigevent aio_sigevent;    
	int             aio_lio_opcode;         
};
struct user32_aiocb {
	int             aio_fildes;             
	user32_off_t            aio_offset;             
	user32_addr_t   aio_buf;                
	user32_size_t   aio_nbytes;             
	int             aio_reqprio;            
	struct user32_sigevent  aio_sigevent;           
	int             aio_lio_opcode;         
};
struct proc_taskinfo_internal {
	uint64_t                pti_virtual_size;   
	uint64_t                pti_resident_size;  
	uint64_t                pti_total_user;         
	uint64_t                pti_total_system;
	uint64_t                pti_threads_user;       
	uint64_t                pti_threads_system;
	int32_t                 pti_policy;             
	int32_t                 pti_faults;             
	int32_t                 pti_pageins;    
	int32_t                 pti_cow_faults; 
	int32_t                 pti_messages_sent;      
	int32_t                 pti_messages_received; 
	int32_t                 pti_syscalls_mach;  
	int32_t                 pti_syscalls_unix;  
	int32_t                 pti_csw;            
	int32_t                 pti_threadnum;          
	int32_t                 pti_numrunning;         
	int32_t                 pti_priority;           
};
struct proc_threadinfo_internal {
	uint64_t                pth_user_time;      
	uint64_t                pth_system_time;    
	int32_t                 pth_cpu_usage;      
	int32_t                 pth_policy;             
	int32_t                 pth_run_state;      
	int32_t                 pth_flags;          
	int32_t                 pth_sleep_time;     
	int32_t                 pth_curpri;             
	int32_t                 pth_priority;           
	int32_t                 pth_maxpriority;                
	char                    pth_name[MAXTHREADNAMESIZE];            
};
struct proc_threadschedinfo_internal {
	uint64_t               int_time_ns;         
};
struct proc_regioninfo_internal {
	uint32_t                pri_protection;
	uint32_t                pri_max_protection;
	uint32_t                pri_inheritance;
	uint32_t                pri_flags;              
	uint64_t                pri_offset;
	uint32_t                pri_behavior;
	uint32_t                pri_user_wired_count;
	uint32_t                pri_user_tag;
	uint32_t                pri_pages_resident;
	uint32_t                pri_pages_shared_now_private;
	uint32_t                pri_pages_swapped_out;
	uint32_t                pri_pages_dirtied;
	uint32_t                pri_ref_count;
	uint32_t                pri_shadow_depth;
	uint32_t                pri_share_mode;
	uint32_t                pri_private_pages_resident;
	uint32_t                pri_shared_pages_resident;
	uint32_t                pri_obj_id;
	uint32_t                pri_depth;
	uint64_t                pri_address;
	uint64_t                pri_size;
};
struct bufattr {
	uint64_t ba_flags;      
	void *ba_verify_ctx;
};
struct buf {
	LIST_ENTRY(buf) b_hash;         
	LIST_ENTRY(buf) b_vnbufs;       
	TAILQ_ENTRY(buf) b_freelist;    
	int     b_timestamp;            
	struct timeval b_timestamp_tv; 
	int     b_whichq;               
	volatile uint32_t       b_flags;        
	volatile uint32_t       b_lflags;       
	int     b_error;                
	int     b_bufsize;              
	int     b_bcount;               
	int     b_resid;                
	dev_t   b_dev;                  
	uintptr_t       b_datap;        
	daddr64_t       b_lblkno;       
	daddr64_t       b_blkno;        
	void    (*b_iodone)(buf_t, void *);     
	vnode_t b_vp;                   
	kauth_cred_t b_rcred;           
	kauth_cred_t b_wcred;           
	void *  b_upl;                  
	buf_t   b_real_bp;              
	TAILQ_ENTRY(buf)        b_act;  
	void *  b_drvdata;              
	void *  b_fsprivate;            
	void *  b_transaction;          
	int     b_dirtyoff;             
	int     b_dirtyend;             
	int     b_validoff;             
	int     b_validend;             

	uint32_t b_redundancy_flags;

	proc_t  b_proc;                 
	struct bufattr b_attr;
	off_t   b_lblksize;           
	vnode_t b_vnop_vp;            
};
struct bufstats {
	long    bufs_incore;            
	long    bufs_busyincore;        
	long    bufs_vmhits;            
	long    bufs_miss;                      
	long    bufs_sleeps;            
	long    bufs_eblk;                      
	uint32_t    bufs_iobufmax;          
	uint32_t    bufs_iobufinuse;        
	long    bufs_iobufsleeps;       
	long    bufs_iobufinuse_vdev;   
};
struct _cs_profile_register_t {
	uuid_t uuid;

	const void *sig_data;
	size_t sig_size;

	const void *data;
	size_t size;
} cs_profile_register_t;
struct commpage_timeofday_data {
	uint64_t        TimeStamp_tick;
	uint64_t        TimeStamp_sec;
	uint64_t        TimeStamp_frac;
	uint64_t        Ticks_scale;
	uint64_t        Ticks_per_sec;
} new_commpage_timeofday_data_t;
struct bdevsw {
	open_close_fcn_t        *d_open;
	open_close_fcn_t        *d_close;
	strategy_fcn_t          *d_strategy;
	ioctl_fcn_t             *d_ioctl;
	dump_fcn_t              *d_dump;
	psize_fcn_t             *d_psize;
	int                     d_type;
};
struct cdevsw {
	open_close_fcn_t        *d_open;
	open_close_fcn_t        *d_close;
	read_write_fcn_t        *d_read;
	read_write_fcn_t        *d_write;
	ioctl_fcn_t             *d_ioctl;
	stop_fcn_t              *d_stop;
	reset_fcn_t             *d_reset;
	struct  tty             **d_ttys;
	select_fcn_t            *d_select;
	mmap_fcn_t              *d_mmap;
	strategy_fcn_t          *d_strategy;
	rsvd_fcn_t              *d_reserved_1;
	rsvd_fcn_t              *d_reserved_2;
	int                     d_type;
};
struct linesw {
	l_open_t        *l_open;
	l_close_t       *l_close;
	l_read_t        *l_read;
	l_write_t       *l_write;
	l_ioctl_t       *l_ioctl;
	l_rint_t        *l_rint;
	l_start_t       *l_start;
	l_modem_t       *l_modem;
};
struct swdevt {
	dev_t   sw_dev;
	int     sw_flags;
	int     sw_nblks;
	struct  vnode *sw_vp;
};
struct fcpx {
	aes_encrypt_ctx         *cpx_iv_aes_ctx_ptr;
	cpx_flags_t             cpx_flags;
	uint16_t                cpx_max_key_len;
	uint16_t                cpx_key_len;
	uint8_t                 cpx_cached_key[VFS_CP_MAX_CACHEBUFLEN];
} fcpx_t;
struct cp_key {
	uint8_t len;
	void *key;
} cp_key_t;
struct {
	void     *key;
	unsigned key_len;
	void     *iv_key;
	unsigned iv_key_len;
	uint32_t flags;
} cp_raw_key_s;
struct {
	void     *key;
	unsigned key_len;
	cp_key_class_t dp_class;
} cp_wrapped_key_s;
struct {
	union {
		ino64_t                 inode;
		cp_crypto_id_t  crypto_id;
	};
	uint32_t                        volume;
	pid_t                           pid;
	uid_t                           uid;
	cp_key_revision_t       key_revision;
} cp_cred_s;
struct {
	void *buf;
	user_ssize_t size;
} decmpfs_vector;
struct decmpfs_cnode {
	uint8_t cmp_state;
	uint8_t cmp_minimal_xattr;   
	uint32_t cmp_type;
	uint32_t lockcount;
	void    *lockowner;          
	uint64_t uncompressed_size __attribute__((aligned(8)));
	uint64_t nchildren __attribute__((aligned(8))); 
	uint64_t total_size __attribute__((aligned(8)));
	uint64_t decompression_flags;
	lck_rw_t compressed_data_lock;
};
struct {
	int                                   decmpfs_registration;
	decmpfs_validate_compressed_file_func validate;
	decmpfs_adjust_fetch_region_func      adjust_fetch;
	decmpfs_fetch_uncompressed_data_func  fetch;
	decmpfs_free_compressed_data_func     free_data;
	decmpfs_get_decompression_flags_func  get_flags;
} decmpfs_registration;
struct{
	uint64_t               offset;
	uint64_t               length;
} dk_extent_t;
struct{
	char                   path[128];
} dk_firmware_path_t;
struct{
	uint64_t               blockCount;
	uint32_t               blockSize;

	uint8_t                reserved0096[4];    
} dk_format_capacity_t;
struct{
	dk_format_capacity_t * capacities;
	uint32_t               capacitiesCount;    

	uint8_t                reserved0096[4];    
} dk_format_capacities_t;
struct{
	uint64_t               offset;
	uint64_t               length;

	uint32_t               options;

	uint8_t                reserved0160[4];    
} dk_synchronize_t;
struct{
	dk_extent_t *          extents;
	uint32_t               extentsCount;

	uint32_t               options;

} dk_unmap_t;
struct{
	uint64_t           flags;
	uint64_t           hotfile_size;           
	uint64_t           hibernate_minsize;
	uint64_t           swapfile_pinning;

	uint64_t           padding[4];
} dk_corestorage_info_t;
struct{
	uint64_t           offset;
	uint64_t           length;
	uint8_t            provisionType;
	uint8_t            reserved[7];
} dk_provision_extent_t;
struct{
	uint64_t                offset;         
	uint64_t                length;         
	uint64_t                options;        
	uint32_t                reserved;       
	uint32_t                extentsCount;   
	dk_provision_extent_t * extents;        
} dk_provision_status_t;
struct{
	uint64_t               options;        
	uint64_t               reserved;       
	uint64_t               description_size;
	char *                 description;
} dk_error_description_t;
struct{
	uint64_t               offset;
	uint64_t               length;

	uint8_t                reserved0128[12];   

	dev_t                  dev;
} dk_physical_extent_t;
struct{
	dk_extent_t *          extents;
	uint32_t               extentsCount;

	uint8_t                tier;

	uint8_t                reserved0104[3];    
} dk_set_tier_t;
struct{
	boolean_t mi_mdev; 
	boolean_t mi_phys; 
	uint32_t mi_base; 
	uint64_t mi_size; 
} dk_memdev_info_t;
struct _dk_cs_pin {
	dk_extent_t     cp_extent;
	int64_t         cp_flags;
} _dk_cs_pin_t;
struct _dk_cs_map {
	dk_extent_t     cm_extent;
	uint64_t        cm_bytes_mapped;
} _dk_cs_map_t;
struct _dk_cs_unmap {
	dk_extent_t                  *extents;
	uint32_t                     extentsCount;
	uint32_t                     options;
} _dk_cs_unmap_t;
struct dk_apfs_wbc_range {
	dev_t dev;              
	uint32_t count;         
	dk_extent_t extents[2]; 
} dk_apfs_wbc_range_t;
struct doc_tombstone {
	struct vnode     *t_lastop_parent;
	struct vnode     *t_lastop_item;
	uint32_t                  t_lastop_parent_vid;
	uint32_t                  t_lastop_item_vid;
	uint64_t          t_lastop_fileid;
	uint64_t          t_lastop_document_id;
	unsigned char     t_lastop_filename[NAME_MAX + 1];
};
struct domain_old {
	int     dom_family;             
	const char *dom_name;
	void    (*dom_init)(void);      
	int     (*dom_externalize)      
	(struct mbuf *);
	void    (*dom_dispose)          
	(struct mbuf *);
	struct  protosw_old *dom_protosw; 
	struct  domain_old *dom_next;
	int     (*dom_rtattach)         
	(void **, int);
	int     dom_rtoffset;           
	int     dom_maxrtkey;           
	int     dom_protohdrlen;        
	int     dom_refs;               
	lck_mtx_t *dom_mtx;             
	uint32_t dom_flags;
	uint32_t reserved[2];
};
struct domain {
	int     dom_family;             
	uint32_t dom_flags;             
	uint32_t dom_refs;              
	lck_mtx_t *dom_mtx;             
	decl_lck_mtx_data(, dom_mtx_s);
	TAILQ_ENTRY(domain) dom_entry;  
	TAILQ_HEAD(, protosw) dom_protosw; 
	void    (*dom_init)             
	(struct domain *);
	int     (*dom_externalize)      
	(struct mbuf *);
	void    (*dom_dispose)          
	(struct mbuf *);
	int     (*dom_rtattach)         
	(void **, int);
	int     dom_rtoffset;           
	int     dom_maxrtkey;           
	int     dom_protohdrlen;        
	const char *dom_name;
	struct domain_old *dom_old;     
};
struct dtrace_diftype {
        uint8_t dtdt_kind;              
        uint8_t dtdt_ckind;             
        uint8_t dtdt_flags;             
        uint8_t dtdt_pad;               
        uint32_t dtdt_size;             
} dtrace_diftype_t;
struct dtrace_difv {
        uint32_t dtdv_name;             
        uint32_t dtdv_id;               
        uint8_t dtdv_kind;              
        uint8_t dtdv_scope;             
        uint16_t dtdv_flags;            
        dtrace_diftype_t dtdv_type;     
} dtrace_difv_t;
struct dof_hdr {
        uint8_t dofh_ident[DOF_ID_SIZE]; 
        uint32_t dofh_flags;            
        uint32_t dofh_hdrsize;          
        uint32_t dofh_secsize;          
        uint32_t dofh_secnum;           
        uint64_t dofh_secoff;           
        uint64_t dofh_loadsz;           
        uint64_t dofh_filesz;           
        uint64_t dofh_pad;              
} dof_hdr_t;
struct dof_sec {
        uint32_t dofs_type;     
        uint32_t dofs_align;    
        uint32_t dofs_flags;    
        uint32_t dofs_entsize;  
        uint64_t dofs_offset;   
        uint64_t dofs_size;     
} dof_sec_t;
struct dof_ecbdesc {
        dof_secidx_t dofe_probes;       
        dof_secidx_t dofe_pred;         
        dof_secidx_t dofe_actions;      
        uint32_t dofe_pad;              
        uint64_t dofe_uarg;             
} dof_ecbdesc_t;
struct dof_probedesc {
        dof_secidx_t dofp_strtab;       
        dof_stridx_t dofp_provider;     
        dof_stridx_t dofp_mod;          
        dof_stridx_t dofp_func;         
        dof_stridx_t dofp_name;         
        uint32_t dofp_id;               
} dof_probedesc_t;
struct dof_actdesc {
        dof_secidx_t dofa_difo;         
        dof_secidx_t dofa_strtab;       
        uint32_t dofa_kind;             
        uint32_t dofa_ntuple;           
        uint64_t dofa_arg;              
        uint64_t dofa_uarg;             
} dof_actdesc_t;
struct dof_difohdr {
        dtrace_diftype_t dofd_rtype;    
        dof_secidx_t dofd_links[1];     
} dof_difohdr_t;
struct dof_relohdr {
        dof_secidx_t dofr_strtab;       
        dof_secidx_t dofr_relsec;       
        dof_secidx_t dofr_tgtsec;       
} dof_relohdr_t;
struct dof_relodesc {
        dof_stridx_t dofr_name;         
        uint32_t dofr_type;             
        uint64_t dofr_offset;           
        uint64_t dofr_data;             
} dof_relodesc_t;
struct dof_optdesc {
        uint32_t dofo_option;           
        dof_secidx_t dofo_strtab;       
        uint64_t dofo_value;            
} dof_optdesc_t;
struct dof_provider {
	dof_secidx_t dofpv_strtab;	
	dof_secidx_t dofpv_probes;	
	dof_secidx_t dofpv_prargs;	
	dof_secidx_t dofpv_proffs;	
	dof_stridx_t dofpv_name;	
	dof_attr_t dofpv_provattr;	
	dof_attr_t dofpv_modattr;	
	dof_attr_t dofpv_funcattr;	
	dof_attr_t dofpv_nameattr;	
	dof_attr_t dofpv_argsattr;	
	dof_secidx_t dofpv_prenoffs;	
} dof_provider_t;
struct dof_probe {
	uint64_t dofpr_addr;		
	dof_stridx_t dofpr_func;	
	dof_stridx_t dofpr_name;	
	dof_stridx_t dofpr_nargv;	
	dof_stridx_t dofpr_xargv;	
	uint32_t dofpr_argidx;		
	uint32_t dofpr_offidx;		
	uint8_t dofpr_nargc;		
	uint8_t dofpr_xargc;		
	uint16_t dofpr_noffs;		
	uint32_t dofpr_enoffidx;	
	uint16_t dofpr_nenoffs;		
	uint16_t dofpr_pad1;		
	uint32_t dofpr_pad2;		
} dof_probe_t;
struct dof_xlator {
        dof_secidx_t dofxl_members;     
        dof_secidx_t dofxl_strtab;      
        dof_stridx_t dofxl_argv;        
        uint32_t dofxl_argc;            
        dof_stridx_t dofxl_type;        
        dof_attr_t dofxl_attr;          
} dof_xlator_t;
struct dof_xlmember {
        dof_secidx_t dofxm_difo;        
        dof_stridx_t dofxm_name;        
        dtrace_diftype_t dofxm_type;    
} dof_xlmember_t;
struct dof_xlref {
        dof_secidx_t dofxr_xlator;      
        uint32_t dofxr_member;          
        uint32_t dofxr_argn;            
} dof_xlref_t;
struct dtrace_difo {
        dif_instr_t *dtdo_buf;          
        uint64_t *dtdo_inttab;          
        char *dtdo_strtab;              
        dtrace_difv_t *dtdo_vartab;     
        uint_t dtdo_len;                
        uint_t dtdo_intlen;             
        uint_t dtdo_strlen;             
        uint_t dtdo_varlen;             
        dtrace_diftype_t dtdo_rtype;    
        uint_t dtdo_refcnt;             
        uint_t dtdo_destructive;        
        dof_relodesc_t *dtdo_kreltab;   
        dof_relodesc_t *dtdo_ureltab;   
        struct dt_node **dtdo_xlmtab;   
        uint_t dtdo_krelen;             
        uint_t dtdo_urelen;             
        uint_t dtdo_xlmlen;             
} dtrace_difo_t;
struct dtrace_probedesc {
        dtrace_id_t dtpd_id;                    
        char dtpd_provider[DTRACE_PROVNAMELEN]; 
        char dtpd_mod[DTRACE_MODNAMELEN];       
        char dtpd_func[DTRACE_FUNCNAMELEN];     
        char dtpd_name[DTRACE_NAMELEN];         
} dtrace_probedesc_t;
struct dtrace_repldesc {
        dtrace_probedesc_t dtrpd_match;         
        dtrace_probedesc_t dtrpd_create;        
} dtrace_repldesc_t;
struct dtrace_preddesc {
        dtrace_difo_t *dtpdd_difo;              
        struct dtrace_predicate *dtpdd_predicate; 
} dtrace_preddesc_t;
struct dtrace_actdesc {
        dtrace_difo_t *dtad_difo;               
        struct dtrace_actdesc *dtad_next;       
        dtrace_actkind_t dtad_kind;             
        uint32_t dtad_ntuple;                   
        uint64_t dtad_arg;                      
        uint64_t dtad_uarg;                     
        int dtad_refcnt;                        
} dtrace_actdesc_t;
struct dtrace_ecbdesc {
        dtrace_actdesc_t *dted_action;          
        dtrace_preddesc_t dted_pred;            
        dtrace_probedesc_t dted_probe;          
        uint64_t dted_uarg;                     
        int dted_refcnt;                        
        uint64_t dted_probegen;                 
} dtrace_ecbdesc_t;
struct dtrace_recdesc {
        dtrace_actkind_t dtrd_action;           
        uint32_t dtrd_size;                     
        uint32_t dtrd_offset;                   
        uint16_t dtrd_alignment;                
        uint16_t dtrd_format;                   
        uint64_t dtrd_arg;                      
        uint64_t dtrd_uarg;                     
} dtrace_recdesc_t;
struct dtrace_eprobedesc {
        dtrace_epid_t dtepd_epid;               
        dtrace_id_t dtepd_probeid;              
        uint64_t dtepd_uarg;                    
        uint32_t dtepd_size;                    
        int dtepd_nrecs;                        
        dtrace_recdesc_t dtepd_rec[1];          
} dtrace_eprobedesc_t;
struct dtrace_aggdesc {
	DTRACE_PTR(char, dtagd_name);		
	dtrace_aggvarid_t dtagd_varid;		
	int dtagd_flags;			
	dtrace_aggid_t dtagd_id;		
	dtrace_epid_t dtagd_epid;		
	uint32_t dtagd_size;			
	int dtagd_nrecs;			
	uint32_t dtagd_pad;			
	dtrace_recdesc_t dtagd_rec[1];		
} dtrace_aggdesc_t;
struct dtrace_fmtdesc {
        DTRACE_PTR(char, dtfd_string);          
        int dtfd_length;                        
        uint16_t dtfd_format;                   
} dtrace_fmtdesc_t;
struct dtrace_bufdesc {
        uint64_t dtbd_size;                     
        uint32_t dtbd_cpu;                      
        uint32_t dtbd_errors;                   
        uint64_t dtbd_drops;                    
        DTRACE_PTR(char, dtbd_data);            
        uint64_t dtbd_oldest;                   
	uint64_t dtbd_timestamp;		
} dtrace_bufdesc_t;
struct dtrace_rechdr {
	dtrace_epid_t dtrh_epid;		
	uint32_t dtrh_timestamp_hi;		
	uint32_t dtrh_timestamp_lo;		
} dtrace_rechdr_t;
struct dtrace_status {
        uint64_t dtst_dyndrops;                 
        uint64_t dtst_dyndrops_rinsing;         
        uint64_t dtst_dyndrops_dirty;           
        uint64_t dtst_specdrops;                
        uint64_t dtst_specdrops_busy;           
        uint64_t dtst_specdrops_unavail;        
        uint64_t dtst_errors;                   
        uint64_t dtst_filled;                   
        uint64_t dtst_stkstroverflows;          
        uint64_t dtst_dblerrors;                
        char dtst_killed;                       
        char dtst_exiting;                      
        char dtst_pad[6];                       
} dtrace_status_t;
struct dtrace_conf {
        uint_t dtc_difversion;                  
        uint_t dtc_difintregs;                  
        uint_t dtc_diftupregs;                  
        uint_t dtc_ctfmodel;                    
        uint_t dtc_pad[8];                      
} dtrace_conf_t;
struct dtrace_argdesc {
        dtrace_id_t dtargd_id;                  
        int dtargd_ndx;                         
        int dtargd_mapping;                     
        char dtargd_native[DTRACE_ARGTYPELEN];  
        char dtargd_xlate[DTRACE_ARGTYPELEN];   
} dtrace_argdesc_t;
struct dtrace_ppriv {
	uint32_t dtpp_flags;			
	uid_t dtpp_uid;				
	zoneid_t dtpp_zoneid;			
} dtrace_ppriv_t;
struct dtrace_attribute {
        dtrace_stability_t dtat_name;           
        dtrace_stability_t dtat_data;           
        dtrace_class_t dtat_class;              
} dtrace_attribute_t;
struct dtrace_pattr {
        dtrace_attribute_t dtpa_provider;       
        dtrace_attribute_t dtpa_mod;            
        dtrace_attribute_t dtpa_func;           
        dtrace_attribute_t dtpa_name;           
        dtrace_attribute_t dtpa_args;           
} dtrace_pattr_t;
struct dtrace_providerdesc {
        char dtvd_name[DTRACE_PROVNAMELEN];     
        dtrace_pattr_t dtvd_attr;               
        dtrace_ppriv_t dtvd_priv;               
} dtrace_providerdesc_t;
struct dof_helper {
        char dofhp_mod[DTRACE_MODNAMELEN];      
        uint64_t dofhp_addr;                    
        uint64_t dofhp_dof;                     
} dof_helper_t;
struct dof_ioctl_data {
	uint64_t dofiod_count;
	dof_helper_t dofiod_helpers[1];
} dof_ioctl_data_t;
struct dtrace_probe {
	dtrace_id_t dtpr_id;			
	dtrace_ecb_t *dtpr_ecb;			
	dtrace_ecb_t *dtpr_ecb_last;		
	void *dtpr_arg;				
	dtrace_cacheid_t dtpr_predcache;	
	int dtpr_aframes;			
	dtrace_provider_t *dtpr_provider;	
	char *dtpr_mod;				
	char *dtpr_func;			
	char *dtpr_name;			
	dtrace_probe_t *dtpr_nextprov;		
	dtrace_probe_t *dtpr_prevprov;		
	dtrace_probe_t *dtpr_nextmod;		
	dtrace_probe_t *dtpr_prevmod;		
	dtrace_probe_t *dtpr_nextfunc;		
	dtrace_probe_t *dtpr_prevfunc;		
	dtrace_probe_t *dtpr_nextname;		
	dtrace_probe_t *dtpr_prevname;		
	dtrace_genid_t dtpr_gen;		
};
struct dtrace_probekey {
	const char *dtpk_prov;			
	dtrace_probekey_f *dtpk_pmatch;		
	const char *dtpk_mod;			
	dtrace_probekey_f *dtpk_mmatch;		
	const char *dtpk_func;			
	dtrace_probekey_f *dtpk_fmatch;		
	const char *dtpk_name;			
	dtrace_probekey_f *dtpk_nmatch;		
	dtrace_id_t dtpk_id;			
} dtrace_probekey_t;
struct dtrace_hashbucket {
	struct dtrace_hashbucket *dthb_next;	
	void *dthb_chain;			
	int dthb_len;				
} dtrace_hashbucket_t;
struct dtrace_hash {
	dtrace_hashbucket_t **dth_tab;	
	int dth_size;			
	int dth_mask;			
	int dth_nbuckets;		
	uintptr_t dth_nextoffs;		
	uintptr_t dth_prevoffs;		
	dtrace_strkey_f *dth_getstr;	
	uintptr_t dth_stroffs;		
} dtrace_hash_t;
struct dtrace_ecb {
	dtrace_epid_t dte_epid;			
	uint32_t dte_alignment;			
	size_t dte_needed;			
	size_t dte_size;			
	dtrace_predicate_t *dte_predicate;	
	dtrace_action_t *dte_action;		
	dtrace_ecb_t *dte_next;			
	dtrace_state_t *dte_state;		
	uint32_t dte_cond;			
	dtrace_probe_t *dte_probe;		
	dtrace_action_t *dte_action_last;	
	uint64_t dte_uarg;			
};
struct dtrace_predicate {
	dtrace_difo_t *dtp_difo;		
	dtrace_cacheid_t dtp_cacheid;		
	int dtp_refcnt;				
};
struct dtrace_action {
	dtrace_actkind_t dta_kind;		
	uint16_t dta_intuple;			
	uint32_t dta_refcnt;			
	dtrace_difo_t *dta_difo;		
	dtrace_recdesc_t dta_rec;		
	dtrace_action_t *dta_prev;		
	dtrace_action_t *dta_next;		
};
struct dtrace_aggregation {
	dtrace_action_t dtag_action;		
	dtrace_aggid_t dtag_id;			
	dtrace_ecb_t *dtag_ecb;			
	dtrace_action_t *dtag_first;		
	uint32_t dtag_base;			
	uint8_t dtag_hasarg;			
	uint64_t dtag_initial;			
	void (*dtag_aggregate)(uint64_t *, uint64_t, uint64_t);
} dtrace_aggregation_t;
struct dtrace_buffer {
	uint64_t dtb_offset;			
	uint64_t dtb_cur_limit;			
	uint64_t dtb_limit;			
	uint64_t dtb_size;			
	uint32_t dtb_flags;			
	uint32_t dtb_drops;			
	caddr_t dtb_tomax;			
	caddr_t dtb_xamot;			
	uint32_t dtb_xamot_flags;		
	uint32_t dtb_xamot_drops;		
	uint64_t dtb_xamot_offset;		
	uint32_t dtb_errors;			
	uint32_t dtb_xamot_errors;		
	uint64_t dtb_pad1;
	uint64_t dtb_switched;			
	uint64_t dtb_interval;			
	uint64_t dtb_pad2[4];			
} dtrace_buffer_t;
struct dtrace_aggkey {
	uint32_t dtak_hashval;			
	uint32_t dtak_action:4;			
	uint32_t dtak_size:28;			
	caddr_t dtak_data;			
	struct dtrace_aggkey *dtak_next;	
} dtrace_aggkey_t;
struct dtrace_aggbuffer {
	uintptr_t dtagb_hashsize;		
	uintptr_t dtagb_free;			
	dtrace_aggkey_t **dtagb_hash;		
} dtrace_aggbuffer_t;
struct dtrace_speculation {
	dtrace_speculation_state_t dtsp_state;	
	int dtsp_cleaning;			
	dtrace_buffer_t *dtsp_buffer;		
} dtrace_speculation_t;
struct dtrace_key {
	uint64_t dttk_value;			
	uint64_t dttk_size;			
} dtrace_key_t;
struct dtrace_tuple {
	uint32_t dtt_nkeys;			
	uint32_t dtt_pad;			
	dtrace_key_t dtt_key[1];		
} dtrace_tuple_t;
struct dtrace_dynvar {
	uint64_t dtdv_hashval;			
	struct dtrace_dynvar *dtdv_next;	
	void *dtdv_data;			
	dtrace_tuple_t dtdv_tuple;		
} dtrace_dynvar_t;
struct dtrace_dynhash {
	dtrace_dynvar_t *dtdh_chain;		
	uintptr_t dtdh_lock;			
} dtrace_dynhash_t;
struct dtrace_dstate_percpu {
	dtrace_dynvar_t *dtdsc_free;		
	dtrace_dynvar_t *dtdsc_dirty;		
	dtrace_dynvar_t *dtdsc_rinsing;		
	dtrace_dynvar_t *dtdsc_clean;		
	uint64_t dtdsc_drops;			
	uint64_t dtdsc_dirty_drops;		
	uint64_t dtdsc_rinsing_drops;		
} dtrace_dstate_percpu_t;
struct dtrace_dstate {
	void *dtds_base;			
	size_t dtds_size;			
	size_t dtds_hashsize;			
	size_t dtds_chunksize;			
	dtrace_dynhash_t *dtds_hash;		
	dtrace_dstate_state_t dtds_state;	
	dtrace_dstate_percpu_t *__zpercpu dtds_percpu;	
} dtrace_dstate_t;
struct dtrace_statvar {
	uint64_t dtsv_data;			
	size_t dtsv_size;			
	int dtsv_refcnt;			
	dtrace_difv_t dtsv_var;			
} dtrace_statvar_t;
struct dtrace_vstate {
	dtrace_state_t *dtvs_state;		
	dtrace_statvar_t **dtvs_globals;	
	int dtvs_nglobals;			
	dtrace_difv_t *dtvs_tlocals;		
	int dtvs_ntlocals;			
	dtrace_statvar_t **dtvs_locals;		
	int dtvs_nlocals;			
	dtrace_dstate_t dtvs_dynvars;		
} dtrace_vstate_t;
struct dtrace_mstate {
	uintptr_t dtms_scratch_base;		
	uintptr_t dtms_scratch_ptr;		
	size_t dtms_scratch_size;		
	uint32_t dtms_present;			
	uint64_t dtms_arg[5];			
	dtrace_epid_t dtms_epid;		
	uint64_t dtms_timestamp;		
	hrtime_t dtms_walltimestamp;		
	uint64_t dtms_machtimestamp;		
	uint64_t dtms_machctimestamp;		
	int dtms_stackdepth;			
	int dtms_ustackdepth;			
	struct dtrace_probe *dtms_probe;	
	uintptr_t dtms_caller;			
	uint64_t dtms_ucaller;			
	int dtms_ipl;				
	int dtms_fltoffs;			
	uintptr_t dtms_strtok;			
	uintptr_t dtms_strtok_limit;		
	uint32_t dtms_access;			
	dtrace_difo_t *dtms_difo;		
} dtrace_mstate_t;
struct dtrace_helper_action {
	int dtha_generation;			
	int dtha_nactions;			
	dtrace_difo_t *dtha_predicate;		
	dtrace_difo_t **dtha_actions;		
	struct dtrace_helper_action *dtha_next;	
} dtrace_helper_action_t;
struct dtrace_helper_provider {
	int dthp_generation;			
	uint32_t dthp_ref;			
	dof_helper_t dthp_prov;			
} dtrace_helper_provider_t;
struct dtrace_helpers {
	dtrace_helper_action_t **dthps_actions;	
	dtrace_vstate_t dthps_vstate;		
	dtrace_helper_provider_t **dthps_provs;	
	uint_t dthps_nprovs;			
	uint_t dthps_maxprovs;			
	int dthps_generation;			
	pid_t dthps_pid;			
	int dthps_deferred;			
	struct dtrace_helpers *dthps_next;	
	struct dtrace_helpers *dthps_prev;	
} dtrace_helpers_t;
struct dtrace_helptrace {
	dtrace_helper_action_t	*dtht_helper;	
	int dtht_where;				
	int dtht_nlocals;			
	int dtht_fault;				
	int dtht_fltoffs;			
	uint64_t dtht_illval;			
	uint64_t dtht_locals[1];		
} dtrace_helptrace_t;
struct dtrace_cred {
	cred_t			*dcr_cred;
	uint8_t			dcr_destructive;
	uint8_t			dcr_visible;
	uint16_t		dcr_action;
} dtrace_cred_t;
struct dtrace_format {
	uint64_t dtf_refcount;
	char dtf_str[];
} dtrace_format_t;
struct dtrace_state {
	dev_t dts_dev;				
	int dts_necbs;				
	dtrace_ecb_t **dts_ecbs;		
	dtrace_epid_t dts_epid;			
	size_t dts_needed;			
	struct dtrace_state *dts_anon;		
	dtrace_activity_t dts_activity;		
	dtrace_vstate_t dts_vstate;		
	dtrace_buffer_t *dts_buffer;		
	dtrace_buffer_t *dts_aggbuffer;		
	dtrace_speculation_t *dts_speculations;	
	int dts_nspeculations;			
	int dts_naggregations;			
	dtrace_aggregation_t **dts_aggregations; 
	vmem_t *dts_aggid_arena;		
	uint64_t dts_errors;			
	uint32_t dts_speculations_busy;		
	uint32_t dts_speculations_unavail;	
	uint32_t dts_stkstroverflows;		
	uint32_t dts_dblerrors;			
	uint32_t dts_reserve;			
	hrtime_t dts_laststatus;		
	cyclic_id_t dts_cleaner;		
	cyclic_id_t dts_deadman;		
	hrtime_t dts_alive;			
	char dts_speculates;			
	char dts_destructive;			
	int dts_nformats;			
	dtrace_format_t **dts_formats;		
	dtrace_optval_t dts_options[DTRACEOPT_MAX]; 
	dtrace_cred_t dts_cred;			
	size_t dts_nretained;			
	uint64_t dts_arg_error_illval;
	uint32_t dts_buf_over_limit;		
	uint64_t **dts_rstate;			
};
struct dtrace_provider {
	dtrace_pattr_t dtpv_attr;		
	dtrace_ppriv_t dtpv_priv;		
	dtrace_pops_t dtpv_pops;		
	char *dtpv_name;			
	void *dtpv_arg;				
	uint_t dtpv_defunct;			
	struct dtrace_provider *dtpv_next;	
	uint64_t dtpv_probe_count;		
	uint64_t dtpv_ecb_count;		
};
struct dtrace_meta {
	dtrace_mops_t dtm_mops;			
	char *dtm_name;				
	void *dtm_arg;				
	uint64_t dtm_count;			
};
struct dtrace_enabling {
	dtrace_ecbdesc_t **dten_desc;		
	int dten_ndesc;				
	int dten_maxdesc;			
	dtrace_vstate_t *dten_vstate;		
	dtrace_genid_t dten_probegen;		
	dtrace_ecbdesc_t *dten_current;		
	int dten_error;				
	int dten_primed;			
	struct dtrace_enabling *dten_prev;	
	struct dtrace_enabling *dten_next;	
} dtrace_enabling_t;
struct dtrace_anon {
	dtrace_state_t *dta_state;		
	dtrace_enabling_t *dta_enabling;	
	processorid_t dta_beganon;		
} dtrace_anon_t;
struct dtrace_string {
	dtrace_string_t *dtst_next;
	dtrace_string_t *dtst_prev;
	uint32_t dtst_refcount;
	char dtst_str[];
} dtrace_string_t;
struct dtrace_match_cond {
	int (*dmc_func)(dtrace_probedesc_t*, void*);
	void *dmc_data;
} dtrace_match_cond_t;
struct dtrace_toxrange {
	uintptr_t	dtt_base;		
	uintptr_t	dtt_limit;		
} dtrace_toxrange_t;
struct dtrace_ptss_page_entry {
	struct dtrace_ptss_page_entry*  next;
	user_addr_t                     addr;
	user_addr_t                     write_addr;
};
struct dtrace_ptss_page {
	struct dtrace_ptss_page*       next;
	struct dtrace_ptss_page_entry  entries[DTRACE_PTSS_ENTRIES_PER_PAGE];
};
struct eventreq {
	int      er_type;
	int      er_handle;
	void    *er_data;
	int      er_rcnt;
	int      er_wcnt;
	int      er_ecnt;
	int      er_eventbits;
};
struct kevent {
	uintptr_t       ident;  
	int16_t         filter; 
	uint16_t        flags;  
	uint32_t        fflags; 
	intptr_t        data;   
	void            *udata; 
};
struct kevent64_s {
	uint64_t        ident;          
	int16_t         filter;         
	uint16_t        flags;          
	uint32_t        fflags;         
	int64_t         data;           
	uint64_t        udata;          
	uint64_t        ext[2];         
};
struct eventhandler_lists_ctxt {
	TAILQ_HEAD(, eventhandler_list)  eventhandler_lists;
	int eventhandler_lists_initted;
	decl_lck_mtx_data(, eventhandler_mutex);
};
struct eventhandler_entry_arg {
	uuid_t ee_fm_uuid;      
	uuid_t ee_fr_uuid;      
};
struct eventhandler_entry {
	TAILQ_ENTRY(eventhandler_entry) ee_link;
	int                             ee_priority;
	struct eventhandler_entry_arg   ee_arg;
};
struct eventhandler_list {
	char                            el_name[EVENTHANDLER_MAX_NAME];
	int                             el_flags;
	u_int                           el_runcount;
	decl_lck_mtx_data(, el_lock);
	TAILQ_ENTRY(eventhandler_list)  el_link;
	TAILQ_HEAD(, eventhandler_entry) el_entries;
};
struct knote_lock_ctx {
	struct knote               *knlc_knote;
	thread_t                    knlc_thread;
	uintptr_t                   knlc_waiters;
	LIST_ENTRY(knote_lock_ctx)  knlc_link;
};
struct kqueue {
	lck_spin_t          kq_lock;      
	kq_state_t          kq_state;     
	uint16_t            kq_level;     
	uint32_t            kq_count;     
	struct proc        *kq_p;         
	struct knote_locks  kq_knlocks;   
};
struct kqfile {
	struct kqueue       kqf_kqueue;     
	struct kqtailq      kqf_queue;      
	struct kqtailq      kqf_suppressed; 
	struct selinfo      kqf_sel;        
};
struct kqworkq {
	struct kqueue       kqwq_kqueue;
	struct kqtailq      kqwq_queue[KQWQ_NBUCKETS];       
	struct kqtailq      kqwq_suppressed[KQWQ_NBUCKETS];  
	workq_threadreq_s   kqwq_request[KQWQ_NBUCKETS];     
};
struct kqworkloop {
	struct kqueue       kqwl_kqueue;                  
	struct kqtailq      kqwl_queue[KQWL_NBUCKETS];    
	struct kqtailq      kqwl_suppressed;              
	workq_threadreq_s   kqwl_request;                 

	lck_spin_t          kqwl_statelock;               
	thread_t            kqwl_owner;                   
	os_ref_atomic_t     kqwl_retains;                 
	thread_qos_t        kqwl_wakeup_qos;              
	_Atomic uint8_t     kqwl_iotier_override;         



	struct turnstile   *kqwl_turnstile;               
	kqueue_id_t         kqwl_dynamicid;               
	uint64_t            kqwl_params;                  
	LIST_ENTRY(kqworkloop) kqwl_hashlink;             
};
struct user64_kevent {
	uint64_t        ident;  
	int16_t         filter; 
	uint16_t        flags;  
	uint32_t        fflags; 
	int64_t         data;   
	user_addr_t     udata;  
};
struct user32_kevent {
	uint32_t        ident;  
	int16_t         filter; 
	uint16_t        flags;  
	uint32_t        fflags; 
	int32_t         data;   
	user32_addr_t   udata;  
};
struct kevent_qos_s {
	uint64_t        ident;          
	int16_t         filter;         
	uint16_t        flags;          
	int32_t         qos;            
	uint64_t        udata;          
	uint32_t        fflags;         
	uint32_t        xflags;         
	int64_t         data;           
	uint64_t        ext[4];         
};
struct knote {
	TAILQ_ENTRY(knote)       kn_tqe;            
	SLIST_ENTRY(knote)       kn_link;           
	SLIST_ENTRY(knote)       kn_selnext;        

	kn_status_t              kn_status : 12;
	uintptr_t
	    kn_qos_index:4,                         
	    kn_qos_override:3,                      
	    kn_is_fd:1,                             
	    kn_vnode_kqok:1,
	    kn_vnode_use_ofst:1;
	uintptr_t                   kn_kq_packed : KNOTE_KQ_PACKED_BITS;

	union {
		uintptr_t           kn_hook; 
		uint32_t            kn_hook32;
	};

	union {
		struct fileproc    *XNU_PTRAUTH_SIGNED_PTR("knote.fp") kn_fp;
		struct proc        *XNU_PTRAUTH_SIGNED_PTR("knote.proc") kn_proc;
		struct ipc_port    *XNU_PTRAUTH_SIGNED_PTR("knote.ipc_port") kn_ipc_port;
		struct ipc_pset    *XNU_PTRAUTH_SIGNED_PTR("knote.ipc_pset") kn_ipc_pset;
		struct thread_call *XNU_PTRAUTH_SIGNED_PTR("knote.thcall") kn_thcall;
		struct thread      *XNU_PTRAUTH_SIGNED_PTR("knote.thread") kn_thread;
	};

	struct kevent_internal_s {
		uint64_t    kei_ident;      
		uint16_t    kei_flags;      
		int32_t     kei_qos;        
		uint64_t    kei_udata;      
		uint32_t    kei_fflags;     
		uint32_t    kei_sfflags;    
		int64_t     kei_sdata;      
		uint64_t    kei_ext[4];     
	} kn_kevent;

};
struct kevent_ctx_s {
	uint64_t         kec_data_avail;    
	union {
		user_addr_t    kec_data_out;      
		struct pollfd *kec_poll_fds;      
	};
	user_size_t      kec_data_size;     
	user_size_t      kec_data_resid;    
	uint64_t         kec_deadline;      
	struct fileproc *kec_fp;            
	int              kec_fd;            

	int              kec_process_nevents;       
	int              kec_process_noutputs;      
	unsigned int     kec_process_flags;         
	user_addr_t      kec_process_eventlist;     
};
struct filterops {
	bool    f_isfd;               
	bool    f_adjusts_qos;    
	bool    f_extended_codes; 

	int     (*f_attach)(struct knote *kn, struct kevent_qos_s *kev);
	void    (*f_detach)(struct knote *kn);
	int     (*f_event)(struct knote *kn, long hint);
	int     (*f_touch)(struct knote *kn, struct kevent_qos_s *kev);
	int     (*f_process)(struct knote *kn, struct kevent_qos_s *kev);

	bool    (*f_allow_drop)(struct knote *kn, struct kevent_qos_s *kev);
	void    (*f_post_register_wait)(struct uthread *uth, struct knote *kn,
	    struct _kevent_register *ss_kr);
	void    (*f_sanitized_copyout)(struct knote *kn, struct kevent_qos_s *kev);
};
struct fasttrap_probe_spec {
	pid_t				ftps_pid;
	fasttrap_provider_type_t	ftps_provider_type;
	fasttrap_probe_type_t		ftps_probe_type;
	uint32_t			ftps_arch_subinfo;	
	char				ftps_func[DTRACE_FUNCNAMELEN];
	char				ftps_mod[DTRACE_MODNAMELEN];

	uint64_t			ftps_pc;
	uint64_t			ftps_size;
	uint64_t			ftps_noffs;
	uint64_t			ftps_offs[1];
} fasttrap_probe_spec_t;
struct fasttrap_instr_query {
	uint64_t		ftiq_pc;
	pid_t			ftiq_pid;
	fasttrap_instr_t	ftiq_instr;
} fasttrap_instr_query_t;
struct fasttrap_proc {
	pid_t ftpc_pid;				
	uint64_t ftpc_acount;			
	uint64_t ftpc_rcount;			
	lck_mtx_t ftpc_mtx;			
	struct fasttrap_proc *ftpc_next;	
} fasttrap_proc_t;
struct fasttrap_provider {
	pid_t ftp_pid;				
	fasttrap_provider_type_t ftp_provider_type;	
	char ftp_name[DTRACE_PROVNAMELEN];	
	dtrace_provider_id_t ftp_provid;	
	uint_t ftp_marked;			
	uint_t ftp_retired;			
	lck_mtx_t ftp_mtx;			
	lck_mtx_t ftp_cmtx;			
	uint64_t ftp_pcount;			
	uint64_t ftp_rcount;			
	uint64_t ftp_ccount;			
	uint64_t ftp_mcount;			
	fasttrap_proc_t *ftp_proc;		
	struct fasttrap_provider *ftp_next;	
} fasttrap_provider_t;
struct fasttrap_id {
	fasttrap_probe_t *fti_probe;		
	fasttrap_id_t *fti_next;		
	fasttrap_probe_type_t fti_ptype;	
};
struct fasttrap_id_tp {
	fasttrap_id_t fit_id;
	fasttrap_tracepoint_t *fit_tp;
} fasttrap_id_tp_t;
struct fasttrap_probe {
	dtrace_id_t ftp_id;			
	pid_t ftp_pid;				
	fasttrap_provider_t *ftp_prov;		
	user_addr_t ftp_faddr;			
	size_t ftp_fsize;			
	uint64_t ftp_gen;			
	uint64_t ftp_ntps;			
	uint8_t *ftp_argmap;			
	uint8_t ftp_nargs;			
	uint8_t ftp_enabled;			
	uint8_t ftp_triggered;
	char *ftp_xtypes;			
	char *ftp_ntypes;			
	fasttrap_id_tp_t ftp_tps[1];		
};
struct fasttrap_tracepoint {
	fasttrap_proc_t *ftt_proc;		
	user_addr_t ftt_pc;			
	pid_t ftt_pid;				
	fasttrap_machtp_t ftt_mtp;		
	fasttrap_id_t *ftt_ids;			
	fasttrap_id_t *ftt_retids;		
	fasttrap_tracepoint_t *ftt_next;	
};
struct fasttrap_bucket {
	lck_mtx_t ftb_mtx;			
	void *ftb_data;				

	uint8_t ftb_pad[64 - sizeof (lck_mtx_t) - sizeof (void *)];
} fasttrap_bucket_t;
struct fasttrap_hash {
	ulong_t fth_nent;			
	ulong_t fth_mask;			
	fasttrap_bucket_t *fth_table;		
} fasttrap_hash_t;
struct fbt_probe {
	struct fbt_probe *fbtp_hashnext;
	machine_inst_t	*fbtp_patchpoint;
	int8_t			fbtp_rval;
	machine_inst_t	fbtp_patchval;
	machine_inst_t	fbtp_savedval;
        machine_inst_t  fbtp_currentval;
	uintptr_t		fbtp_roffset;
	dtrace_id_t		fbtp_id;
	char			fbtp_name[MAX_FBTP_NAME_CHARS];
	struct modctl	*fbtp_ctl;
	int		fbtp_loadcnt;
	struct fbt_probe *fbtp_next;
} fbt_probe_t;
struct flock {
	off_t   l_start;        
	off_t   l_len;          
	pid_t   l_pid;          
	short   l_type;         
	short   l_whence;       
};
struct flocktimeout {
	struct flock    fl;             
	struct timespec timeout;        
};
struct filedesc {
	lck_mtx_t           fd_lock;        
	uint8_t             fd_fpdrainwait; 
	filedesc_flags_t    fd_flags;       
	u_short             fd_cmask;       
	int                 fd_nfiles;      
	int                 fd_afterlast;   
	int                 fd_freefile;    

	int                 fd_knlistsize;  
	int                 unused_padding;
	struct fileproc   **XNU_PTRAUTH_SIGNED_PTR("filedesc.fd_ofiles") fd_ofiles; 
	char               *fd_ofileflags;  

	struct  klist      *fd_knlist;      

	struct  kqworkq    *fd_wqkqueue;    
	struct  vnode      *fd_cdir;        
	struct  vnode      *fd_rdir;        
	lck_rw_t            fd_dirs_lock;   

	lck_mtx_t           fd_kqhashlock;  
	u_long              fd_kqhashmask;  
	struct  kqwllist   *fd_kqhash;      

	lck_mtx_t           fd_knhashlock;  
	u_long              fd_knhashmask;  
	struct  klist      *fd_knhash;      
};
struct fdt_iterator {
	int              fdti_fd;
	struct fileproc *fdti_fp;
};
struct fileproc_guard {
	struct select_set *fpg_wset;
	guardid_t         fpg_guard;
};
struct fileproc {
	os_refcnt_t      fp_iocount;
	_Atomic fileproc_vflags_t fp_vflags;
	fileproc_flags_t fp_flags;
	uint16_t         fp_guard_attrs;
	struct fileglob *XNU_PTRAUTH_SIGNED_PTR("fileproc.fp_glob") fp_glob;
	union {
		struct select_set     *fp_wset;   
		struct fileproc_guard *XNU_PTRAUTH_SIGNED_PTR("fileproc.fp_guard") fp_guard;  
	};
};
struct fileops {
	file_type_t     fo_type;        
	int (*fo_read)      (struct fileproc *fp, struct uio *uio,
	    int flags, vfs_context_t ctx);
	int (*fo_write)     (struct fileproc *fp, struct uio *uio,
	    int flags, vfs_context_t ctx);
	int (*fo_ioctl)(struct fileproc *fp, u_long com,
	    caddr_t data, vfs_context_t ctx);
	int (*fo_select)    (struct fileproc *fp, int which,
	    void *wql, vfs_context_t ctx);
	int (*fo_close)     (struct fileglob *fg, vfs_context_t ctx);
	int (*fo_kqfilter)  (struct fileproc *fp, struct knote *, struct kevent_qos_s *);
	int (*fo_drain)     (struct fileproc *fp, vfs_context_t ctx);
};
struct fileglob {
	LIST_ENTRY(fileglob) f_msglist;     
	uint32_t             fg_flag;       
	os_ref_atomic_t      fg_count;      
	uint32_t             fg_msgcount;   
	int32_t              fg_lflags;     
	kauth_cred_t         XNU_PTRAUTH_SIGNED_PTR("fileglob.fg_cred") fg_cred;        
	const struct fileops *XNU_PTRAUTH_SIGNED_PTR("fileglob.fg_ops") fg_ops;
	off_t                fg_offset;
	uintptr_t            fg_data;       
	struct fd_vn_data   *XNU_PTRAUTH_SIGNED_PTR("fileglob.fg_vn_data") fg_vn_data;  
	lck_mtx_t            fg_lock;
};
struct user64_namespace_handler_info {
	user64_addr_t  token;
	user64_addr_t  flags;
	user64_addr_t  fdptr;
} user64_namespace_handler_info;
struct user32_namespace_handler_info {
	user32_addr_t  token;
	user32_addr_t  flags;
	user32_addr_t  fdptr;
} user32_namespace_handler_info;
struct namespace_handler_info {
	user_addr_t  token;
	user_addr_t  flags;
	user_addr_t  fdptr;
} namespace_handler_info;
struct user64_namespace_handler_info_ext {
	user64_addr_t  token;
	user64_addr_t  flags;
	user64_addr_t  fdptr;
	user64_addr_t  infoptr;
} user64_namespace_handler_info_ext;
struct user32_namespace_handler_info_ext {
	user32_addr_t  token;
	user32_addr_t  flags;
	user32_addr_t  fdptr;
	user32_addr_t  infoptr;
} user32_namespace_handler_info_ext;
struct namespace_handler_info_ext {
	user_addr_t  token;
	user_addr_t  flags;
	user_addr_t  fdptr;
	user_addr_t  infoptr;
} namespace_handler_info_ext;
struct user64_namespace_handler_data {
	user64_addr_t token;
	user64_addr_t flags;
	user64_addr_t fdptr;
	user64_addr_t infoptr;
	user64_addr_t objid;
	user64_addr_t reserved1;
	user64_addr_t reserved2;
	user64_addr_t reserved3;
} user64_namespace_handler_data;
struct user32_namespace_handler_data {
	user32_addr_t token;
	user32_addr_t flags;
	user32_addr_t fdptr;
	user32_addr_t infoptr;
	user32_addr_t objid;
	user32_addr_t reserved1;
	user32_addr_t reserved2;
	user32_addr_t reserved3;
} user32_namespace_handler_data;
struct namespace_handler_data {
	user_addr_t token;
	user_addr_t flags;
	user_addr_t fdptr;
	user_addr_t infoptr;
	user_addr_t objid;
	user_addr_t reserved1;
	user_addr_t reserved2;
	user_addr_t reserved3;
} namespace_handler_data;
struct user64_package_ext_info {
	user64_addr_t strings;
	uint32_t      num_entries;
	uint32_t      max_width;
} user64_package_ext_info;
struct user32_package_ext_info {
	user32_addr_t strings;
	uint32_t      num_entries;
	uint32_t      max_width;
} user32_package_ext_info;
struct package_ext_info {
	const char *strings;
	uint32_t    num_entries;
	uint32_t    max_width;
} package_ext_info;
struct disk_conditioner_info {
	int enabled;
	uint64_t access_time_usec; 
	uint64_t read_throughput_mbps; 
	uint64_t write_throughput_mbps; 
	int is_ssd; 

	uint32_t ioqueue_depth;
	uint32_t maxreadcnt;
	uint32_t maxwritecnt;
	uint32_t segreadcnt;
	uint32_t segwritecnt;
} disk_conditioner_info;
struct fsioc_cas_bsdflags {
	uint32_t expected_flags;        
	uint32_t new_flags;             
	uint32_t actual_flags;          
};
struct fsioc_graft_fs {
	uint32_t graft_version;
	uint32_t graft_type;
	uint32_t graft_4cc;
	uint64_t graft_flags;
	uint64_t dir_ino;

	void *authentic_manifest;
	size_t authentic_manifest_size;
	void *user_manifest;
	size_t user_manifest_size;
	void *payload;
	size_t payload_size;
} fsioc_graft_fs_t;
struct fsioc_ungraft_fs {
	uint64_t ungraft_flags;
} fsioc_ungraft_fs_t;
struct fsioc_auth_fs {
	vnode_t authvp;
	uint64_t flags;
} fsioc_auth_fs_t;
struct fsioc_exclave_fs_register {
	uint32_t fs_tag;
} fsioc_exclave_fs_register_t;
struct {
	uint32_t fs_tag;       
	fsid_t fsid;           
	uint64_t base_dir;     
	uint64_t graft_file;   
} exclave_fs_base_dir_t;
struct {
	uint32_t count;       
	                      
	                      
	exclave_fs_base_dir_t *base_dirs; 
} exclave_fs_get_base_dirs_t;
struct {
	uint64_t        gi_graft_file;            
	uint64_t        gi_graft_dir;             
	uint64_t        gi_inum_base;             
	uint64_t        gi_inum_len:56;           
	uint64_t        gi_graft_lut_reduction:8; 
	uint64_t        gi_graft_flags;           
} fsioc_graft_info_t;
struct {
	uint16_t        ggi_count;       
	                                 
	                                 
	uint16_t        ggi_graft_index; 
	                                 
	uint8_t         ggi_is_in_graft; 
	uint8_t         ggi_padding[3];  
	user64_addr_t   ggi_buffer;      
} fsioc_get_graft_info_t;
struct generic_firmlink {
	uint8_t array[FIRMLINK_STRUCT_LEN];
} generic_firmlink_t;
struct fsevent_clone_args {
	int8_t  *event_list;
	int32_t  num_events;
	int32_t  event_queue_depth;
	int32_t *fd;
} fsevent_clone_args;
struct fsevent_dev_filter_args {
	uint32_t  num_devices;
	dev_t    *devices;
} fsevent_dev_filter_args;
struct fse_info {
	ino64_t    ino;
	dev_t      dev;
	int32_t    mode;
	uid_t      uid;
	uint32_t   document_id;
	uint64_t   nlink;
} fse_info;
struct gmonhdr {
	uint32_t lpc;           
	uint32_t hpc;           
	uint32_t ncnt;          
	int32_t version;        
	int32_t profrate;       
	int32_t spare[3];       
};
struct gmonhdr_64 {
	uint64_t lpc;           
	uint64_t hpc;           
	uint32_t ncnt;          
	int32_t version;        
	int32_t profrate;       
	int32_t spare[3];       
};
struct tostruct {
	uint32_t        selfpc;
	int32_t         count;
	uint16_t        link;
	uint16_t        order;
};
struct tostruct_64 {
	uint64_t        selfpc;
	int32_t         count;
	uint16_t        link;
	uint16_t        order;
};
struct rawarc {
	uint32_t        raw_frompc;
	uint32_t        raw_selfpc;
	int32_t         raw_count;
};
struct rawarc_64 {
	uint64_t        raw_frompc;
	uint64_t        raw_selfpc;
	int32_t         raw_count;
};
struct gmonparam {
	int             state;
	u_short         *kcount;
	u_long          kcountsize;
	u_short         *froms;
	u_long          fromssize;
	tostruct_t      *tos;
	u_long          tossize;
	long            tolimit;
	u_long          lowpc;
	u_long          highpc;
	u_long          textsize;
	u_long          hashfraction;
};
struct gmon_data {
	uint32_t type; 
	uint32_t size; 
} gmon_data_t;
struct rawarc_order {
	uint32_t    raw_frompc;
	uint32_t    raw_selfpc;
	uint32_t    raw_count;
	uint32_t    raw_order;
};
struct rawarc_order_64 {
	uint64_t    raw_frompc;
	uint64_t    raw_selfpc;
	uint32_t    raw_count;
	uint32_t    raw_order;
};
struct image_params {
	user_addr_t     ip_user_fname;          
	user_addr_t     ip_user_argv;           
	user_addr_t     ip_user_envv;           
	int             ip_seg;                 
	struct vnode    *ip_vp;                 
	struct vnode_attr       *ip_vattr;      
	struct vnode_attr       *ip_origvattr;  
	cpu_type_t      ip_origcputype;         
	cpu_subtype_t   ip_origcpusubtype;      
	char            *ip_vdata;              
	int             ip_flags;               
	int             ip_argc;                
	int             ip_envc;                
	int             ip_applec;              

	char            *ip_startargv;          
	char            *ip_endargv;    
	char            *ip_endenvv;    

	char            *ip_strings;            
	char            *ip_strendp;            

	char            *ip_subsystem_root_path;        

	int             ip_argspace;    
	int             ip_strspace;            

	user_size_t     ip_arch_offset;         
	user_size_t     ip_arch_size;           
	char            ip_interp_buffer[IMG_SHSIZE];   
	int             ip_interp_sugid_fd;             

	struct vfs_context      *ip_vfs_context;        
	struct nameidata *ip_ndp;               
	thread_t        ip_new_thread;          

	struct label    *ip_execlabelp;         
	struct label    *ip_scriptlabelp;       
	struct vnode    *ip_scriptvp;           
	unsigned int    ip_csflags;             
	int             ip_mac_return;          
	void            *ip_px_sa;              
	void            *ip_px_sfa;             
	void            *ip_px_spa;             
	vm_map_t        ip_free_map;            
	struct ip_px_smpx_s {
		void        *array;
		void        *data;
		uint64_t    datalen;
	}               ip_px_smpx;             
	void            *ip_px_persona;         
	void            *ip_px_pcred_info;      
	void            *ip_cs_error;           
	char            *ip_inherited_shared_region_id;  

	uint64_t ip_dyld_fsid;
	uint64_t ip_dyld_fsobjid;
	uint64_t ip_inherited_jop_pid;
	unsigned int    ip_simulator_binary;    
};
struct imgsrc_info {
	uint32_t        ii_height;      
	uint32_t        ii_flags;       
	dev_t           ii_dev;         
	char            ii_reserved[24];
} *imgsrc_info_t;
struct mnt_imgsrc_args {
	uint32_t        mi_height;      
	uint32_t        mi_flags;       
	const char*     mi_devpath;     
};
struct user64_mnt_imgsrc_args {
	uint32_t        mi_height;
	uint32_t        mi_flags;
	user64_addr_t   mi_devpath;
};
struct user32_mnt_imgsrc_args {
	uint32_t        mi_height;
	uint32_t        mi_flags;
	user32_addr_t   mi_devpath;
};
struct ttysize {
	unsigned short  ts_lines;
	unsigned short  ts_cols;
	unsigned short  ts_xxx;
	unsigned short  ts_yyy;
};
struct tchars {
	char    t_intrc;        
	char    t_quitc;        
	char    t_startc;       
	char    t_stopc;        
	char    t_eofc;         
	char    t_brkc;         
};
struct ltchars {
	char    t_suspc;        
	char    t_dsuspc;       
	char    t_rprntc;       
	char    t_flushc;       
	char    t_werasc;       
	char    t_lnextc;       
};
struct sgttyb {
	char    sg_ispeed;              
	char    sg_ospeed;              
	char    sg_erase;               
	char    sg_kill;                
	short   sg_flags;               
};
struct ipc_perm {
	uid_t           uid;            
	gid_t           gid;            
	uid_t           cuid;           
	gid_t           cgid;           
	mode_t          mode;           
	unsigned short  _seq;           
	key_t           _key;           
};
struct IPCS_command {
	int             ipcs_magic;     
	int             ipcs_op;        
	int             ipcs_cursor;    
	int             ipcs_datalen;   
	void            *ipcs_data;     
};
struct user_IPCS_command {
	int             ipcs_magic;     
	int             ipcs_op;        
	int             ipcs_cursor;    
	int             ipcs_datalen;   
	user_addr_t     ipcs_data;      
};
struct user32_IPCS_command {
	int             ipcs_magic;     
	int             ipcs_op;        
	int             ipcs_cursor;    
	int             ipcs_datalen;   
	user32_addr_t   ipcs_data;      
};
struct kd_storage {
	union kds_ptr kds_next;
	uint32_t kds_bufindx;
	uint32_t kds_bufcnt;
	uint32_t kds_readlast;
	uint32_t kds_lostevents:1;
	uint32_t unused:31;
	uint64_t kds_timestamp;

	kd_buf kds_records[TRACE_EVENTS_PER_STORAGE_UNIT];
};
struct kd_region {
	struct kd_storage *kdr_addr;
	uint32_t           kdr_size;
};
struct kd_bufinfo {
	union  kds_ptr kd_list_head;
	union  kds_ptr kd_list_tail;
	bool kd_lostevents;
	uint32_t _pad;
	uint64_t kd_prev_timebase;
	uint32_t num_bufs;
	uint64_t latest_past_event_timestamp;
	bool continuous_timestamps;
} __attribute__((aligned(MAX_CPU_CACHE_LINE_SIZE))) __attribute__((packed));
struct kd_control {
	union kds_ptr kds_free_list;
	uint32_t enabled:1,
	    mode:3,
	    _pad0:28;
	uint32_t kdebug_events_per_storage_unit;
	uint32_t kdebug_min_storage_units_per_cpu;
	uint32_t kdebug_kdcopybuf_count;
	uint32_t kdebug_kdcopybuf_size;
	uint32_t kdebug_cpus;
	uint32_t alloc_cpus;
	uint32_t kdc_flags;
	kdebug_emit_filter_t kdc_emit;
	kdebug_live_flags_t kdc_live_flags;
	uint64_t kdc_oldest_time;
	int kdc_storage_used;

	lck_spin_t kdc_storage_lock;

	struct kd_coproc *kdc_coprocs;

	kd_event_matcher disable_event_match;
	kd_event_matcher disable_event_mask;
};
struct kd_buffer {
	int kdb_event_count;
	int kdb_storage_count;
	int kdb_storage_threshold;
	uint32_t kdb_region_count;
	struct kd_bufinfo *kdb_info;
	struct kd_region *kd_bufs;
	kd_buf *kdcopybuf;
};
struct kd_record {
	int32_t  cpu;
	uint32_t debugid;
	int64_t timestamp;
	kd_buf_argtype arg1;
	kd_buf_argtype arg2;
	kd_buf_argtype arg3;
	kd_buf_argtype arg4;
	kd_buf_argtype arg5;
} __attribute__((packed));
struct kd_callback {
	kd_callback_fn func;
	void *context;
	char iop_name[8];
};
struct ktriage_strings {
	int num_strings;
	const char **strings;
} ktriage_strings_t;
struct ctl_event_data {
	u_int32_t   ctl_id;             
	u_int32_t   ctl_unit;
};
struct ctl_info {
	u_int32_t   ctl_id;                             
	char        ctl_name[MAX_KCTL_NAME];            
};
struct sockaddr_ctl {
	u_char      sc_len;     
	u_char      sc_family;  
	u_int16_t   ss_sysaddr; 
	u_int32_t   sc_id;      
	u_int32_t   sc_unit;    
	u_int32_t   sc_reserved[5];
};
struct xkctl_reg {
	u_int32_t       xkr_len;
	u_int32_t       xkr_kind;
	u_int32_t       xkr_id;
	u_int32_t       xkr_reg_unit;
	u_int32_t       xkr_flags;
	u_int64_t       xkr_kctlref;
	u_int32_t       xkr_recvbufsize;
	u_int32_t       xkr_sendbufsize;
	u_int32_t       xkr_lastunit;
	u_int32_t       xkr_pcbcount;
	u_int64_t       xkr_connect;
	u_int64_t       xkr_disconnect;
	u_int64_t       xkr_send;
	u_int64_t       xkr_send_list;
	u_int64_t       xkr_setopt;
	u_int64_t       xkr_getopt;
	u_int64_t       xkr_rcvd;
	char            xkr_name[MAX_KCTL_NAME];
};
struct xkctlpcb {
	u_int32_t       xkp_len;
	u_int32_t       xkp_kind;
	u_int64_t       xkp_kctpcb;
	u_int32_t       xkp_unit;
	u_int32_t       xkp_kctlid;
	u_int64_t       xkp_kctlref;
	char            xkp_kctlname[MAX_KCTL_NAME];
};
struct kctlstat {
	u_int64_t       kcs_reg_total __attribute__((aligned(8)));
	u_int64_t       kcs_reg_count __attribute__((aligned(8)));
	u_int64_t       kcs_pcbcount __attribute__((aligned(8)));
	u_int64_t       kcs_gencnt __attribute__((aligned(8)));
	u_int64_t       kcs_connections __attribute__((aligned(8)));
	u_int64_t       kcs_conn_fail __attribute__((aligned(8)));
	u_int64_t       kcs_send_fail __attribute__((aligned(8)));
	u_int64_t       kcs_send_list_fail __attribute__((aligned(8)));
	u_int64_t       kcs_enqueue_fail __attribute__((aligned(8)));
	u_int64_t       kcs_enqueue_fullsock __attribute__((aligned(8)));
	u_int64_t       kcs_bad_kctlref __attribute__((aligned(8)));
	u_int64_t       kcs_tbl_size_too_big __attribute__((aligned(8)));
	u_int64_t       kcs_enqdata_mb_alloc_fail __attribute__((aligned(8)));
	u_int64_t       kcs_enqdata_sbappend_fail __attribute__((aligned(8)));
};
struct kern_ctl_reg {
	char            ctl_name[MAX_KCTL_NAME];
	u_int32_t       ctl_id;
	u_int32_t       ctl_unit;

	u_int32_t   ctl_flags;
	u_int32_t   ctl_sendsize;
	u_int32_t   ctl_recvsize;

	ctl_connect_func    ctl_connect;
	ctl_disconnect_func ctl_disconnect;
	ctl_send_func               ctl_send;
	ctl_setopt_func             ctl_setopt;
	ctl_getopt_func             ctl_getopt;
	ctl_rcvd_func               ctl_rcvd;   
	ctl_send_list_func          ctl_send_list;
	ctl_bind_func           ctl_bind;
	ctl_setup_func                  ctl_setup;
};
struct kern_event_msg {
	u_int32_t       total_size;     
	u_int32_t       vendor_code;    
	u_int32_t       kev_class;      
	u_int32_t       kev_subclass;   
	u_int32_t       id;             
	u_int32_t       event_code;     
	u_int32_t       event_data[XNU_KERN_EVENT_DATA_SIZE];   
};
struct kev_request {
	u_int32_t       vendor_code;
	u_int32_t       kev_class;
	u_int32_t       kev_subclass;
};
struct kev_vendor_code {
	u_int32_t       vendor_code;
	char            vendor_string[KEV_VENDOR_CODE_MAX_STR_LEN];
};
struct xkevtpcb {
	u_int32_t       kep_len;
	u_int32_t       kep_kind;
	u_int64_t       kep_evtpcb;
	u_int32_t       kep_vendor_code_filter;
	u_int32_t       kep_class_filter;
	u_int32_t       kep_subclass_filter;
};
struct kevtstat {
	u_int64_t       kes_pcbcount __attribute__((aligned(8)));
	u_int64_t       kes_gencnt __attribute__((aligned(8)));
	u_int64_t       kes_badvendor __attribute__((aligned(8)));
	u_int64_t       kes_toobig __attribute__((aligned(8)));
	u_int64_t       kes_nomem __attribute__((aligned(8)));
	u_int64_t       kes_fullsock __attribute__((aligned(8)));
	u_int64_t       kes_posted __attribute__((aligned(8)));
};
struct kev_d_vectors {
	u_int32_t       data_length;    
	void            *data_ptr;      
};
struct kev_msg {
	u_int32_t vendor_code;          
	u_int32_t kev_class;            
	u_int32_t kev_subclass;         
	u_int32_t event_code;           
	struct kev_d_vectors dv[N_KEV_VECTORS]; 
};
struct kern_event_pcb {
	decl_lck_mtx_data(, evp_mtx);   
	LIST_ENTRY(kern_event_pcb) evp_link;    
	struct socket *evp_socket;              
	u_int32_t evp_vendor_code_filter;
	u_int32_t evp_class_filter;
	u_int32_t evp_subclass_filter;
};
struct memorystatus_priority_entry {
	pid_t pid;
	int32_t priority;
	uint64_t user_data;
	int32_t limit;  
	memorystatus_proc_state_t state;
} memorystatus_priority_entry_t;
struct memorystatus_priority_entry_v2 {
	pid_t    pid;
	int32_t  priority;
	uint64_t user_data;
	int32_t  limit; 
	memorystatus_proc_state_t state;
	uint64_t priority_start_mtime;

	uint8_t  _reserved[96];
} memorystatus_priority_entry_v2_t;
struct memorystatus_properties_entry_v1 {
	int version;
	pid_t pid;
	int32_t priority;
	int use_probability;
	uint64_t user_data;
	int32_t limit;  
	memorystatus_proc_state_t state;
	char proc_name[MAXCOMLEN + 1];
	char __pad1[3];
} memorystatus_properties_entry_v1_t;
struct memorystatus_properties_freeze_entry_v1 {
	int version;
	pid_t pid;
	uint32_t priority;
	char proc_name[(2 * MAXCOMLEN) + 1];
	char __pad1[3];
} memorystatus_properties_freeze_entry_v1;
struct memorystatus_kernel_stats {
	uint32_t free_pages;
	uint32_t active_pages;
	uint32_t inactive_pages;
	uint32_t throttled_pages;
	uint32_t purgeable_pages;
	uint32_t wired_pages;
	uint32_t speculative_pages;
	uint32_t filebacked_pages;
	uint32_t anonymous_pages;
	uint32_t compressor_pages;
	uint64_t compressions;
	uint64_t decompressions;
	uint64_t total_uncompressed_pages_in_compressor;
	uint64_t zone_map_size;
	uint64_t zone_map_capacity;
	uint64_t largest_zone_size;
	char     largest_zone_name[MACH_ZONE_NAME_MAX_LEN];
} memorystatus_kernel_stats_t;
struct jetsam_snapshot_entry {
	pid_t    pid;
	char     name[(2 * MAXCOMLEN) + 1];
	int32_t  priority;
	memorystatus_proc_state_t state;
	uint32_t fds;
	memorystatus_freeze_skip_reason_t jse_freeze_skip_reason; 
	uint8_t  uuid[16];
	uint64_t user_data;
	uint64_t killed;
	uint64_t pages;
	uint64_t max_pages_lifetime;
	uint64_t purgeable_pages;
	uint64_t jse_internal_pages;
	uint64_t jse_internal_compressed_pages;
	uint64_t jse_purgeable_nonvolatile_pages;
	uint64_t jse_purgeable_nonvolatile_compressed_pages;
	uint64_t jse_alternate_accounting_pages;
	uint64_t jse_alternate_accounting_compressed_pages;
	uint64_t jse_iokit_mapped_pages;
	uint64_t jse_page_table_pages;
	uint64_t jse_memory_region_count;
	uint64_t jse_gencount;                  
	uint64_t jse_starttime;                 
	uint64_t jse_killtime;                  
	uint64_t jse_idle_delta;                
	uint64_t jse_coalition_jetsam_id;       
	struct timeval64 cpu_time;
	uint64_t jse_thaw_count;
	uint64_t jse_frozen_to_swap_pages;
	uint64_t csflags;
	uint32_t cs_trust_level;
	uint64_t jse_neural_nofootprint_total_pages;
} memorystatus_jetsam_snapshot_entry_t;
struct jetsam_snapshot {
	uint64_t snapshot_time;                 
	uint64_t notification_time;             
	uint64_t js_gencount;                   
	memorystatus_kernel_stats_t stats;      
	size_t entry_count;
	memorystatus_jetsam_snapshot_entry_t entries[];
} memorystatus_jetsam_snapshot_t;
struct memorystatus_priority_properties {
	int32_t  priority;
	uint64_t user_data;
} memorystatus_priority_properties_t;
struct memorystatus_memlimit_properties {
	int32_t memlimit_active;                
	uint32_t memlimit_active_attr;
	int32_t memlimit_inactive;              
	uint32_t memlimit_inactive_attr;
} memorystatus_memlimit_properties_t;
struct memorystatus_memlimit_properties2 {
	memorystatus_memlimit_properties_t v1;
	uint32_t memlimit_increase;             
	uint32_t memlimit_increase_bytes;       
} memorystatus_memlimit_properties2_t;
struct memorystatus_diag_memlimit_properties {
	uint64_t memlimit;                       
	bool     threshold_enabled;              
} memorystatus_diag_memlimit_properties_t;
struct memstat_bucket {
	TAILQ_HEAD(, proc) list;
	uint32_t count;
	uint32_t relaunch_high_count;
} memstat_bucket_t;
struct memorystatus_internal_probabilities {
	char proc_name[MAXCOMLEN + 1];
	int use_probability;
} memorystatus_internal_probabilities_t;
struct memorystatus_freeze_entry {
	int32_t pid;
	uint32_t flags;
	uint32_t pages;
} memorystatus_freeze_entry_t;
struct throttle_interval_t {
	uint32_t mins;
	uint32_t burst_multiple;
	uint32_t pageouts;
	uint32_t max_pageouts;
	mach_timespec_t ts;
} throttle_interval_t;
struct memorystatus_freezer_stats_t {
	uint64_t mfs_process_considered_count;

	uint64_t mfs_error_excess_shared_memory_count;
	uint64_t mfs_error_low_private_shared_ratio_count;
	uint64_t mfs_error_no_compressor_space_count;
	uint64_t mfs_error_no_swap_space_count;
	uint64_t mfs_error_below_min_pages_count;
	uint64_t mfs_error_low_probability_of_use_count;
	uint64_t mfs_error_elevated_count;
	uint64_t mfs_error_other_count;

	uint64_t mfs_below_threshold_count;

	uint64_t mfs_skipped_full_count;

	uint64_t mfs_skipped_shared_mb_high_count;

	uint64_t mfs_shared_pages_skipped;

	uint64_t mfs_bytes_refrozen;
	uint64_t mfs_refreeze_count;

	uint64_t mfs_processes_frozen;
	uint64_t mfs_processes_thawed;


	uint64_t mfs_processes_frozen_webcontent;
	uint64_t mfs_processes_thawed_webcontent;

	uint64_t mfs_processes_frozen_xpc_service;

	uint64_t mfs_processes_thawed_fg;
	uint64_t mfs_processes_thawed_fg_xpc_service;

	uint64_t mfs_freeze_pid_mismatches;
	uint64_t mfs_demote_pid_mismatches;

	uint64_t mfs_budget_exhaustion_duration_remaining;

	uint64_t mfs_processes_fg_resumed;
};
struct _global_frozen_procs {
	uint64_t gfp_num_frozen;

	struct {
		pid_t fp_pid;
		proc_name_t fp_name;
	} gfp_procs[FREEZER_CONTROL_GET_PROCS_MAX_COUNT];
} global_frozen_procs_t;
struct _memorystatus_freezer_trial_identifiers_v1 {
	int version; 
	uuid_string_t treatment_id;
	uuid_string_t experiment_id;
	int deployment_id;
} memorystatus_freezer_trial_identifiers_v1;
struct _vm_object_query_data_ {
	vm_object_id_t object_id;
	mach_vm_size_t virtual_size;
	mach_vm_size_t resident_size;
	mach_vm_size_t wired_size;
	mach_vm_size_t reusable_size;
	mach_vm_size_t compressed_size;
	struct {
		uint64_t vo_no_footprint : 1; 
		uint64_t vo_ledger_tag   : 3; 
		uint64_t purgable        : 2; 
	};
};
struct _vmobject_list_output_ {
	uint64_t entries;
	vm_object_query_data_t data[0];
};
struct mbuf_stat {
	u_int32_t       mbufs;          
	u_int32_t       clusters;       
	u_int32_t       clfree;         
	u_int32_t       drops;          
	u_int32_t       wait;           
	u_int32_t       drain;          
	u_short         mtypes[256];    
	u_int32_t       mcfail;         
	u_int32_t       mpfail;         
	u_int32_t       msize;          
	u_int32_t       mclbytes;       
	u_int32_t       minclsize;      
	u_int32_t       mlen;           
	u_int32_t       mhlen;          
	u_int32_t       bigclusters;    
	u_int32_t       bigclfree;      
	u_int32_t       bigmclbytes;    
};
struct {
	int32_t buf_interface; 
	int32_t buf_sndbuf; 
} mbuf_buffer_status_t;
struct sflt_filter {
	sflt_handle                     sf_handle;
	int                             sf_flags;
	char                            *sf_name;

	sf_unregistered_func            sf_unregistered;
	sf_attach_func                  sf_attach;
	sf_detach_func                  sf_detach;

	sf_notify_func                  sf_notify;
	sf_getpeername_func             sf_getpeername;
	sf_getsockname_func             sf_getsockname;
	sf_data_in_func                 sf_data_in;
	sf_data_out_func                sf_data_out;
	sf_connect_in_func              sf_connect_in;
	sf_connect_out_func             sf_connect_out;
	sf_bind_func                    sf_bind;
	sf_setoption_func               sf_setoption;
	sf_getoption_func               sf_getoption;
	sf_listen_func                  sf_listen;
	sf_ioctl_func                   sf_ioctl;
	struct sflt_filter_ext {
		unsigned int            sf_ext_len;
		sf_accept_func          sf_ext_accept;
		void                    *sf_ext_rsvd[5];        
	} sf_ext;
};
struct lockf {
	short   lf_flags;           
	short   lf_type;            
	off_t   lf_start;           
	off_t   lf_end;             
	caddr_t lf_id;              
	struct  lockf **lf_head;    
	struct  vnode *lf_vnode;    
	struct  lockf *lf_next;     
	struct  locklist lf_blkhd;  
	TAILQ_ENTRY(lockf) lf_block;
	struct  proc *lf_owner;     
};
struct mcache_obj {
	struct mcache_obj       *obj_next;
} mcache_obj_t;
struct mcache_bkt {
	void            *bkt_next;      
	struct mcache_bkttype *bkt_type; 
	void            *bkt_obj[1];    
} mcache_bkt_t;
struct mcache_bktlist {
	mcache_bkt_t    *bl_list;       
	u_int32_t       bl_total;       
	u_int32_t       bl_min;         
	u_int32_t       bl_reaplimit;   
	u_int64_t       bl_alloc;       
} mcache_bktlist_t;
struct mcache_bkttype {
	int             bt_bktsize;     
	size_t          bt_minbuf;      
	size_t          bt_maxbuf;      
	struct mcache   *bt_cache;      
} mcache_bkttype_t;
struct mcache_cpu {
	decl_lck_mtx_data(, cc_lock);
	mcache_bkt_t    *cc_filled;     
	mcache_bkt_t    *cc_pfilled;    
	u_int64_t       cc_alloc;       
	u_int64_t       cc_free;        
	int             cc_objs;        
	int             cc_pobjs;       
	int             cc_bktsize;     
} __attribute__((aligned(MAX_CPU_CACHE_LINE_SIZE))) mcache_cpu_t;
struct mcache {
	LIST_ENTRY(mcache) mc_list;     
	char            mc_name[32];    
	struct zone     *mc_slab_zone;  
	mcache_allocfn_t mc_slab_alloc; 
	mcache_freefn_t mc_slab_free;   
	mcache_auditfn_t mc_slab_audit; 
	mcache_logfn_t mc_slab_log;     
	mcache_notifyfn_t mc_slab_notify; 
	void            *mc_private;    
	size_t          mc_bufsize;     
	size_t          mc_align;       
	u_int32_t       mc_flags;       
	u_int32_t       mc_purge_cnt;   
	u_int32_t       mc_enable_cnt;  
	u_int32_t       mc_waiter_cnt;  
	u_int32_t       mc_wretry_cnt;  
	u_int32_t       mc_nwretry_cnt; 
	u_int32_t       mc_nwfail_cnt;  
	decl_lck_mtx_data(, mc_sync_lock); 
	lck_grp_t       *mc_sync_lock_grp;
	lck_grp_t       *mc_cpu_lock_grp;

	decl_lck_mtx_data(, mc_bkt_lock);
	lck_grp_t       *mc_bkt_lock_grp;
	mcache_bkttype_t *cache_bkttype;        
	mcache_bktlist_t mc_full;               
	mcache_bktlist_t mc_empty;              
	size_t          mc_chunksize;           
	u_int32_t       mc_bkt_contention;      
	u_int32_t       mc_bkt_contention_prev; 

	mcache_cpu_t    mc_cpu[1]
	__attribute__((aligned(MAX_CPU_CACHE_LINE_SIZE)));
} mcache_t;
struct mcache_audit {
	struct mcache_audit *mca_next;  
	void            *mca_addr;      
	mcache_t        *mca_cache;     
	size_t          mca_contents_size; 
	void            *mca_contents;  
	void            *mca_uptr;      
	uint32_t        mca_uflags;     
	uint32_t        mca_next_trn;
	struct mca_trn {
		struct thread   *mca_thread;    
		uint32_t        mca_tstamp;
		uint16_t        mca_depth;
		void            *mca_stack[MCACHE_STACK_DEPTH];
	} mca_trns[MCA_TRN_MAX];
} mcache_audit_t;
struct {
	__uint64_t version;
	__uint64_t originalSize;
	__uint64_t reserved[4];
} model_encryption_header_t;
struct monotonic_config {
	uint64_t event;
	uint64_t allowed_ctr_mask;
	uint64_t cpu_mask;
};
struct vfsstatfs {
	uint32_t        f_bsize;        
	size_t          f_iosize;       
	uint64_t        f_blocks;       
	uint64_t        f_bfree;        
	uint64_t        f_bavail;       
	uint64_t        f_bused;        
	uint64_t        f_files;        
	uint64_t        f_ffree;        
	fsid_t          f_fsid;         
	uid_t           f_owner;        
	uint64_t        f_flags;        
	char            f_fstypename[MFSTYPENAMELEN];
	char            f_mntonname[MAXPATHLEN];
	char            f_mntfromname[MAXPATHLEN];
	uint32_t        f_fssubtype;     
	void            *f_reserved[2];         
};
struct vfs_attr {
	uint64_t        f_supported;
	uint64_t        f_active;

	uint64_t        f_objcount;     
	uint64_t        f_filecount;    
	uint64_t        f_dircount;     
	uint64_t        f_maxobjcount;  

	uint32_t        f_bsize;        
	size_t          f_iosize;       
	uint64_t        f_blocks;       
	uint64_t        f_bfree;        
	uint64_t        f_bavail;       
	uint64_t        f_bused;        
	uint64_t        f_files;        
	uint64_t        f_ffree;        
	fsid_t          f_fsid;         
	uid_t           f_owner;        

	vol_capabilities_attr_t f_capabilities;
	vol_attributes_attr_t f_attributes;

	struct timespec f_create_time;  
	struct timespec f_modify_time;  
	struct timespec f_access_time;  
	struct timespec f_backup_time;  

	uint32_t        f_fssubtype;    

	char            *f_vol_name;    

	uint16_t        f_signature;    
	uint16_t        f_carbon_fsid;  
	uuid_t          f_uuid;         
	uint64_t        f_quota;        
	uint64_t        f_reserved;     
};
struct vfsconf {
	uint32_t vfc_reserved1;         
	char    vfc_name[MFSNAMELEN];   
	int     vfc_typenum;            
	int     vfc_refcount;           
	int     vfc_flags;              
	uint32_t vfc_reserved2;         
	uint32_t vfc_reserved3;         
};
struct vfsidctl {
	int             vc_vers;        
	fsid_t          vc_fsid;        
	void            *vc_ptr;        
	size_t          vc_len;         
	u_int32_t       vc_spare[12];   
};
struct user_vfsidctl {
	int                              vc_vers;       
	fsid_t                   vc_fsid;               
	user_addr_t              vc_ptr __attribute((aligned(8)));      
	user_size_t              vc_len;                
	u_int32_t                vc_spare[12];  
};
struct user32_vfsidctl {
	int                              vc_vers;       
	fsid_t                   vc_fsid;               
	user32_addr_t    vc_ptr;                
	user32_size_t    vc_len;                
	u_int32_t                vc_spare[12];  
};
struct vfsquery {
	u_int32_t       vq_flags;
	u_int32_t       vq_spare[31];
};
struct vfs_server {
	int32_t  vs_minutes;                    
	u_int8_t vs_server_name[MAXHOSTNAMELEN * 3]; 
};
struct netfs_status {
	u_int32_t       ns_status;              
	char            ns_mountopts[512];      
	uint32_t        ns_waittime;            
	uint32_t        ns_threadcount;         
	uint64_t        ns_threadids[0];        
};
struct vfsioattr {
	u_int32_t       io_maxreadcnt;          
	u_int32_t       io_maxwritecnt;         
	u_int32_t       io_segreadcnt;          
	u_int32_t       io_segwritecnt;         
	u_int32_t       io_maxsegreadsize;      
	u_int32_t       io_maxsegwritesize;     
	u_int32_t       io_devblocksize;        
	u_int32_t       io_flags;                       
	union {
		int64_t io_max_swappin_available;
		
		void *io_reserved[2];
	};
};
struct vfs_fsentry {
	struct vfsops * vfe_vfsops;     
	int             vfe_vopcnt;     
	struct vnodeopv_desc ** vfe_opvdescs; 
	int                     vfe_fstypenum;  
	char            vfe_fsname[MFSNAMELEN]; 
	uint32_t        vfe_flags;              
	void *              vfe_reserv[2];
};
struct vfsops {
	int  (*vfs_mount)(struct mount *mp, vnode_t devvp, user_addr_t data, vfs_context_t context);

	int  (*vfs_start)(struct mount *mp, int flags, vfs_context_t context);

	int  (*vfs_unmount)(struct mount *mp, int mntflags, vfs_context_t context);

	int  (*vfs_root)(struct mount *mp, struct vnode **vpp, vfs_context_t context);

	int  (*vfs_quotactl)(struct mount *mp, int cmds, uid_t uid, caddr_t arg, vfs_context_t context);

	int  (*vfs_getattr)(struct mount *mp, struct vfs_attr *vfa, vfs_context_t context);


	int  (*vfs_sync)(struct mount *mp, int waitfor, vfs_context_t context);

	int  (*vfs_vget)(struct mount *mp, ino64_t ino, struct vnode **vpp, vfs_context_t context);

	int  (*vfs_fhtovp)(struct mount *mp, int fhlen, unsigned char *fhp, struct vnode **vpp,
	    vfs_context_t context);

	int  (*vfs_vptofh)(struct vnode *vp, int *fhlen, unsigned char *fhp, vfs_context_t context);

	int  (*vfs_init)(struct vfsconf *vfsc);

	int  (*vfs_sysctl)(int *, u_int, user_addr_t, size_t *, user_addr_t, size_t, vfs_context_t context);

	int  (*vfs_setattr)(struct mount *mp, struct vfs_attr *vfa, vfs_context_t context);

	int  (*vfs_ioctl)(struct mount *mp, u_long command, caddr_t data,
	    int flags, vfs_context_t context);

	int  (*vfs_vget_snapdir)(struct mount *mp, struct vnode **vpp, vfs_context_t context);
	void *vfs_reserved5;
	void *vfs_reserved4;
	void *vfs_reserved3;
	void *vfs_reserved2;
	void *vfs_reserved1;
};
struct fs_snapshot_mount_args {
	mount_t sm_mp;
	struct componentname *sm_cnp;
};
struct fs_snapshot_revert_args {
	struct componentname *sr_cnp;
};
struct fs_snapshot_root_args {
	struct componentname *sr_cnp;
};
struct fs_role_mount_args {
	mount_t root_mp;
	uint32_t mount_role;
} fs_role_mount_args_t;
struct fhandle {
	unsigned int    fh_len;                         
	unsigned char   fh_data[NFS_MAX_FH_SIZE];       
};
struct mount {
	TAILQ_ENTRY(mount)      mnt_list;                   
	int32_t                 mnt_count;                  
	lck_mtx_t               mnt_mlock;                  
	const struct vfsops     * XNU_PTRAUTH_SIGNED_PTR("mount.vfsops") mnt_op;        
	struct vfstable         * XNU_PTRAUTH_SIGNED_PTR("mount.mnt_vtable") mnt_vtable;        
	struct vnode            * XNU_PTRAUTH_SIGNED_PTR("mount.mnt_vnodecovered") mnt_vnodecovered;    
	struct vnodelst         mnt_vnodelist;              
	struct vnodelst         mnt_workerqueue;            
	struct vnodelst         mnt_newvnodes;              
	uint32_t                mnt_flag;                   
	uint32_t                mnt_kern_flag;              
	uint32_t                mnt_compound_ops;           
	uint32_t                mnt_lflag;                  
	uint32_t                mnt_maxsymlinklen;          
	struct vfsstatfs        mnt_vfsstat;                
	qaddr_t                 mnt_data;                   
	uint32_t                mnt_maxreadcnt;             
	uint32_t                mnt_maxwritecnt;            
	uint32_t                mnt_segreadcnt;             
	uint32_t                mnt_segwritecnt;            
	uint32_t                mnt_maxsegreadsize;         
	uint32_t                mnt_maxsegwritesize;        
	uint32_t                mnt_alignmentmask;          
	uint32_t                mnt_devblocksize;           
	uint32_t                mnt_ioqueue_depth;          
	uint32_t                mnt_ioscale;                
	uint32_t                mnt_ioflags;                
	uint32_t                mnt_minsaturationbytecount; 
	pending_io_t            mnt_pending_write_size __attribute__((aligned(sizeof(pending_io_t))));  
	pending_io_t            mnt_pending_read_size  __attribute__((aligned(sizeof(pending_io_t))));  
	struct timeval          mnt_last_write_issued_timestamp;
	struct timeval          mnt_last_write_completed_timestamp;
	int64_t                 mnt_max_swappin_available;

	lck_rw_t                mnt_rwlock;                 
	lck_mtx_t               mnt_renamelock;             
	vnode_t                 mnt_devvp;                  
	uint32_t                mnt_devbsdunit;             
	uint64_t                mnt_throttle_mask;          
	void                    *mnt_throttle_info;         
	int32_t                 mnt_crossref;               
	int32_t                 mnt_iterref;                
	uid_t                   mnt_fsowner;
	gid_t                   mnt_fsgroup;

	struct label            *mnt_mntlabel;              

	vnode_t                 mnt_realrootvp;
	uint32_t                mnt_realrootvp_vid;
	uint32_t                mnt_generation;
	int                     mnt_authcache_ttl;
	char                    fstypename_override[MFSTYPENAMELEN];

	uint32_t                mnt_iobufinuse;

	void                    *mnt_disk_conditioner_info;

	lck_mtx_t               mnt_iter_lock;              

	uint64_t                mnt_mount_id;               
	uint32_t                mnt_supl_kern_flag;         
};
struct vfstable {
	const struct vfsops *vfc_vfsops;
	char        vfc_name[MFSNAMELEN];   
	int         vfc_typenum;            
	int         vfc_refcount;           
	int         vfc_flags;              
	int         (*vfc_mountroot)(mount_t, vnode_t, vfs_context_t);      
	struct      vfstable *vfc_next;     
	int32_t     vfc_reserved1;
	int32_t     vfc_reserved2;
	int         vfc_vfsflags;           
	void       *vfc_descptr;            
	uint32_t    vfc_descsize;           
	struct sysctl_oid       *vfc_sysctl;    
};
struct vfsmount_args {
	union {
		struct {
			char * mnt_fspec;
			void * mnt_fsdata;
		} mnt_localfs_args;
		struct {
			void *  mnt_fsdata;             
		} mnt_remotefs_args;
	} mountfs_args;
};
struct user64_statfs {
	short           f_otype;                
	short           f_oflags;               
	user64_long_t   f_bsize;                
	user64_long_t   f_iosize;               
	user64_long_t   f_blocks;               
	user64_long_t   f_bfree;                
	user64_long_t   f_bavail;               
	user64_long_t   f_files;                
	user64_long_t   f_ffree;                
	fsid_t          f_fsid;                 
	uid_t           f_owner;                
	short           f_reserved1;            
	short           f_type;                 
	user64_long_t   f_flags;                
	user64_long_t   f_reserved2[2];         
	char            f_fstypename[MFSNAMELEN]; 
	char            f_mntonname[MNAMELEN];  
	char            f_mntfromname[MNAMELEN];
	char            f_reserved3;    
	user64_long_t   f_reserved4[4]; 
};
struct user32_statfs {
	short           f_otype;                
	short           f_oflags;               
	user32_long_t   f_bsize;                
	user32_long_t   f_iosize;               
	user32_long_t   f_blocks;               
	user32_long_t   f_bfree;                
	user32_long_t   f_bavail;               
	user32_long_t   f_files;                
	user32_long_t   f_ffree;                
	fsid_t          f_fsid;                 
	uid_t           f_owner;                
	short           f_reserved1;    
	short           f_type;                 
	user32_long_t       f_flags;            
	user32_long_t f_reserved2[2];   
	char            f_fstypename[MFSNAMELEN]; 
	char            f_mntonname[MNAMELEN];  
	char            f_mntfromname[MNAMELEN];
	char            f_reserved3;    
	user32_long_t   f_reserved4[4]; 
};
struct user_msqid_ds {
	struct ipc_perm msg_perm;       
	struct msg      *msg_first;     
	struct msg      *msg_last;      
	user_msglen_t   msg_cbytes;     
	user_msgqnum_t  msg_qnum;       
	user_msglen_t   msg_qbytes;     
	pid_t           msg_lspid;      
	pid_t           msg_lrpid;      
	user_time_t     msg_stime;      
	__int32_t       msg_pad1;       
	user_time_t     msg_rtime;      
	__int32_t       msg_pad2;       
	user_time_t     msg_ctime;      
	__int32_t       msg_pad3;       
	__int32_t       msg_pad4[4];
};
struct user64_msqid_ds {
	struct ipc_perm msg_perm;       
	__int32_t       msg_first;      
	__int32_t       msg_last;       
	user64_msglen_t msg_cbytes;     
	user64_msgqnum_t        msg_qnum;       
	user64_msglen_t msg_qbytes;     
	pid_t           msg_lspid;      
	pid_t           msg_lrpid;      
	user64_time_t   msg_stime;      
	__int32_t       msg_pad1;       
	user64_time_t   msg_rtime;      
	__int32_t       msg_pad2;       
	user64_time_t   msg_ctime;      
	__int32_t       msg_pad3;       
	__int32_t       msg_pad4[4];
} __attribute__((__packed__));
struct user32_msqid_ds {
	struct __ipc_perm_new   msg_perm; 
	__int32_t       msg_first;      
	__int32_t       msg_last;       
	user32_msglen_t msg_cbytes;     
	user32_msgqnum_t        msg_qnum;       
	user32_msglen_t msg_qbytes;     
	pid_t           msg_lspid;      
	pid_t           msg_lrpid;      
	user32_time_t           msg_stime;      
	__int32_t       msg_pad1;       
	user32_time_t           msg_rtime;      
	__int32_t       msg_pad2;       
	user32_time_t           msg_ctime;      
	__int32_t       msg_pad3;       
	__int32_t       msg_pad4[4];    
};
struct msqid_kernel {
	struct  user_msqid_ds u;
	struct  label *label;   
};
struct  msgbuf {
	int             msg_magic;
	int             msg_size;
	int             msg_bufx;               
	int             msg_bufr;               
	char    *msg_bufc;              
};
struct nameidata {
	user_addr_t ni_dirp;            
	enum    uio_seg ni_segflg;      
	enum    path_operation ni_op;   
	struct  vnode *ni_startdir;     
	struct  vnode *ni_rootdir;      
	struct  vnode *ni_usedvp;       
	struct  vnode *ni_vp;           
	struct  vnode *ni_dvp;          
	u_int   ni_pathlen;             
	char    *ni_next;               
	char    ni_pathbuf[PATHBUFLEN];
	u_long  ni_loopcnt;             

	struct componentname ni_cnd;
	int32_t ni_flag;
	int ni_ncgeneration;            
};
struct  namecache {
	TAILQ_ENTRY(namecache)  nc_entry;       
	TAILQ_ENTRY(namecache)  nc_child;       
	union {
		LIST_ENTRY(namecache)  nc_link; 
		TAILQ_ENTRY(namecache) nc_negentry; 
	} nc_un;
	struct smrq_link        nc_hash;        
	uint32_t                nc_vid;         
	uint32_t                nc_counter;     
	vnode_t                 nc_dvp;         
	vnode_t                 nc_vp;          
	unsigned int            nc_hashval;     
	const char              *nc_name;       
};
struct  nchstats {
	long    ncs_goodhits;           
	long    ncs_neghits;            
	long    ncs_badhits;            
	long    ncs_miss;               
	long    ncs_pass2;              
	long    ncs_2passes;            
	long    ncs_stolen;
	long    ncs_enters;
	long    ncs_deletes;
	long    ncs_badvid;
};
struct {
	long        np_uid_high;
	long        np_uid_low;
} np_uid_t;
struct {
	netaddr_t   np_receiver;
	netaddr_t   np_owner;
	np_uid_t    np_puid;
	np_uid_t    np_sid;
} network_port_t;
struct kpersona_info {
	uint32_t persona_info_version;

	uid_t    persona_id;
	int      persona_type;
	gid_t    persona_gid; 
	uint32_t persona_ngroups; 
	gid_t    persona_groups[NGROUPS]; 
	uid_t    persona_gmuid; 
	char     persona_name[MAXLOGNAME + 1];

	uid_t    persona_uid;
} __attribute__((packed));
struct persona {
	os_refcnt_t  pna_refcount;
	int32_t      pna_valid;

	uid_t        pna_id;
	persona_type_t pna_type;
	char         pna_login[MAXLOGNAME + 1];
	char         *pna_path;
	uid_t        pna_uid;

	LIST_ENTRY(persona) pna_list;

	LIST_HEAD(, proc)   pna_members;

	lck_mtx_t    pna_lock;

};
struct pgo_metadata_footer {
	uint32_t number_of_pairs;

	uint32_t  offset_to_pairs;

	uint32_t magic;
};
struct pipebuf {
	u_int   cnt;            
	u_int   in;             
	u_int   out;            
	u_int   size;           
	caddr_t OS_PTRAUTH_SIGNED_PTR("pipe.buffer") buffer; 
};
struct pipe {
	struct  pipebuf pipe_buffer;    
	struct  selinfo pipe_sel;       
	pid_t   pipe_pgid;              
	struct  pipe *pipe_peer;        
	u_int   pipe_state;             
	int     pipe_busy;              
	lck_mtx_t *pipe_mtxp;           
	struct  timespec st_atimespec;  
	struct  timespec st_mtimespec;  
	struct  timespec st_ctimespec;  
	struct  label *pipe_label;      
};
struct pollfd {
	int     fd;
	short   events;
	short   revents;
};
struct pseminfo {
	unsigned int    psem_flags;
	unsigned int    psem_usecount;
	mode_t          psem_mode;
	uid_t           psem_uid;
	gid_t           psem_gid;
	char            psem_name[PSEMNAMLEN + 1];      
	void *          psem_semobject;
	struct label *  psem_label;
	pid_t           psem_creator_pid;
	uint64_t        psem_creator_uniqueid;
};
struct pshminfo {
	unsigned int pshm_flags;
	unsigned int pshm_usecount;
	off_t        pshm_length;
	mode_t       pshm_mode;
	uid_t        pshm_uid;
	gid_t        pshm_gid;
	char         pshm_name[PSHMNAMLEN + 1];
	void         *pshm_memobject;
	struct label *pshm_label;
};
struct proc_ident {
	uint64_t        p_uniqueid;
	pid_t           p_pid;
	int             p_idversion;
};
struct syscall_filter_callbacks {
	int version;
	const syscall_filter_cbfunc_t unix_filter_cbfunc;
	const syscall_filter_cbfunc_t mach_filter_cbfunc;
	const kobject_filter_cbfunc_t kobj_filter_cbfunc;
};
struct proc_policy_attribute {
	uint32_t        ppattr_attribute;  
	uint32_t        ppattr_resv;       
	uint64_t        ppattr_value1;     
	uint64_t        ppattr_value2;     
	uint64_t        ppattr_value3;     
	uint64_t        ppattr_resv1[4];    
} proc_policy_attribute_t;
struct proc_policy_cpuusage_attr {
	uint32_t        ppattr_cpu_attr;  
	uint32_t        ppattr_cpu_percentage;       
	uint64_t        ppattr_cpu_attr_interval;     
	uint64_t        ppattr_cpu_attr_deadline;     
} proc_policy_cpuusage_attr_t;
struct proc_bsdinfo {
	uint32_t                pbi_flags;              
	uint32_t                pbi_status;
	uint32_t                pbi_xstatus;
	uint32_t                pbi_pid;
	uint32_t                pbi_ppid;
	uid_t                   pbi_uid;
	gid_t                   pbi_gid;
	uid_t                   pbi_ruid;
	gid_t                   pbi_rgid;
	uid_t                   pbi_svuid;
	gid_t                   pbi_svgid;
	uint32_t                rfu_1;                  
	char                    pbi_comm[MAXCOMLEN];
	char                    pbi_name[2 * MAXCOMLEN];  
	uint32_t                pbi_nfiles;
	uint32_t                pbi_pgid;
	uint32_t                pbi_pjobc;
	uint32_t                e_tdev;                 
	uint32_t                e_tpgid;                
	int32_t                 pbi_nice;
	uint64_t                pbi_start_tvsec;
	uint64_t                pbi_start_tvusec;
};
struct proc_bsdshortinfo {
	uint32_t                pbsi_pid;               
	uint32_t                pbsi_ppid;              
	uint32_t                pbsi_pgid;              
	uint32_t                pbsi_status;            
	char                    pbsi_comm[MAXCOMLEN];   
	uint32_t                pbsi_flags;              
	uid_t                   pbsi_uid;               
	gid_t                   pbsi_gid;               
	uid_t                   pbsi_ruid;              
	gid_t                   pbsi_rgid;              
	uid_t                   pbsi_svuid;             
	gid_t                   pbsi_svgid;             
	uint32_t                pbsi_rfu;               
};
struct proc_taskinfo {
	uint64_t                pti_virtual_size;       
	uint64_t                pti_resident_size;      
	uint64_t                pti_total_user;         
	uint64_t                pti_total_system;
	uint64_t                pti_threads_user;       
	uint64_t                pti_threads_system;
	int32_t                 pti_policy;             
	int32_t                 pti_faults;             
	int32_t                 pti_pageins;            
	int32_t                 pti_cow_faults;         
	int32_t                 pti_messages_sent;      
	int32_t                 pti_messages_received;  
	int32_t                 pti_syscalls_mach;      
	int32_t                 pti_syscalls_unix;      
	int32_t                 pti_csw;                
	int32_t                 pti_threadnum;          
	int32_t                 pti_numrunning;         
	int32_t                 pti_priority;           
};
struct proc_taskallinfo {
	struct proc_bsdinfo     pbsd;
	struct proc_taskinfo    ptinfo;
};
struct proc_threadinfo {
	uint64_t                pth_user_time;          
	uint64_t                pth_system_time;        
	int32_t                 pth_cpu_usage;          
	int32_t                 pth_policy;             
	int32_t                 pth_run_state;          
	int32_t                 pth_flags;              
	int32_t                 pth_sleep_time;         
	int32_t                 pth_curpri;             
	int32_t                 pth_priority;           
	int32_t                 pth_maxpriority;        
	char                    pth_name[MAXTHREADNAMESIZE];    
};
struct proc_regioninfo {
	uint32_t                pri_protection;
	uint32_t                pri_max_protection;
	uint32_t                pri_inheritance;
	uint32_t                pri_flags;              
	uint64_t                pri_offset;
	uint32_t                pri_behavior;
	uint32_t                pri_user_wired_count;
	uint32_t                pri_user_tag;
	uint32_t                pri_pages_resident;
	uint32_t                pri_pages_shared_now_private;
	uint32_t                pri_pages_swapped_out;
	uint32_t                pri_pages_dirtied;
	uint32_t                pri_ref_count;
	uint32_t                pri_shadow_depth;
	uint32_t                pri_share_mode;
	uint32_t                pri_private_pages_resident;
	uint32_t                pri_shared_pages_resident;
	uint32_t                pri_obj_id;
	uint32_t                pri_depth;
	uint64_t                pri_address;
	uint64_t                pri_size;
};
struct proc_workqueueinfo {
	uint32_t        pwq_nthreads;           
	uint32_t        pwq_runthreads;         
	uint32_t        pwq_blockedthreads;     
	uint32_t        pwq_state;
};
struct proc_fileinfo {
	uint32_t                fi_openflags;
	uint32_t                fi_status;
	off_t                   fi_offset;
	int32_t                 fi_type;
	uint32_t                fi_guardflags;
};
struct proc_exitreasonbasicinfo {
	uint32_t                        beri_namespace;
	uint64_t                        beri_code;
	uint64_t                        beri_flags;
	uint32_t                        beri_reason_buf_size;
} __attribute__((packed));
struct proc_exitreasoninfo {
	uint32_t                        eri_namespace;
	uint64_t                        eri_code;
	uint64_t                        eri_flags;
	uint32_t                        eri_reason_buf_size;
	uint64_t                        eri_kcd_buf;
} __attribute__((packed));
struct vinfo_stat {
	uint32_t        vst_dev;        
	uint16_t        vst_mode;       
	uint16_t        vst_nlink;      
	uint64_t        vst_ino;        
	uid_t           vst_uid;        
	gid_t           vst_gid;        
	int64_t         vst_atime;      
	int64_t         vst_atimensec;  
	int64_t         vst_mtime;      
	int64_t         vst_mtimensec;  
	int64_t         vst_ctime;      
	int64_t         vst_ctimensec;  
	int64_t         vst_birthtime;  
	int64_t         vst_birthtimensec;      
	off_t           vst_size;       
	int64_t         vst_blocks;     
	int32_t         vst_blksize;    
	uint32_t        vst_flags;      
	uint32_t        vst_gen;        
	uint32_t        vst_rdev;       
	int64_t         vst_qspare[2];  
};
struct vnode_info {
	struct vinfo_stat       vi_stat;
	int                     vi_type;
	int                     vi_pad;
	fsid_t                  vi_fsid;
};
struct vnode_info_path {
	struct vnode_info       vip_vi;
	char                    vip_path[MAXPATHLEN];   
};
struct vnode_fdinfo {
	struct proc_fileinfo    pfi;
	struct vnode_info       pvi;
};
struct vnode_fdinfowithpath {
	struct proc_fileinfo    pfi;
	struct vnode_info_path  pvip;
};
struct proc_regionwithpathinfo {
	struct proc_regioninfo  prp_prinfo;
	struct vnode_info_path  prp_vip;
};
struct proc_regionpath {
	uint64_t prpo_addr;
	uint64_t prpo_regionlength;
	char prpo_path[MAXPATHLEN];
};
struct proc_vnodepathinfo {
	struct vnode_info_path  pvi_cdir;
	struct vnode_info_path  pvi_rdir;
};
struct proc_threadwithpathinfo {
	struct proc_threadinfo  pt;
	struct vnode_info_path  pvip;
};
struct in4in6_addr {
	u_int32_t               i46a_pad32[3];
	struct in_addr          i46a_addr4;
};
struct in_sockinfo {
	int                                     insi_fport;             
	int                                     insi_lport;             
	uint64_t                                insi_gencnt;            
	uint32_t                                insi_flags;             
	uint32_t                                insi_flow;

	uint8_t                                 insi_vflag;             
	uint8_t                                 insi_ip_ttl;            
	uint32_t                                rfu_1;                  
	union {
		struct in4in6_addr      ina_46;
		struct in6_addr         ina_6;
	}                                       insi_faddr;             
	union {
		struct in4in6_addr      ina_46;
		struct in6_addr         ina_6;
	}                                       insi_laddr;             
	struct {
		u_char                  in4_tos;                        
	}                                       insi_v4;
	struct {
		uint8_t                 in6_hlim;
		int                     in6_cksum;
		u_short                 in6_ifindex;
		short                   in6_hops;
	}                                       insi_v6;
};
struct tcp_sockinfo {
	struct in_sockinfo              tcpsi_ini;
	int                             tcpsi_state;
	int                             tcpsi_timer[TSI_T_NTIMERS];
	int                             tcpsi_mss;
	uint32_t                        tcpsi_flags;
	uint32_t                        rfu_1;          
	uint64_t                        tcpsi_tp;       
};
struct un_sockinfo {
	uint64_t                                unsi_conn_so;   
	uint64_t                                unsi_conn_pcb;  
	union {
		struct sockaddr_un      ua_sun;
		char                    ua_dummy[SOCK_MAXADDRLEN];
	}                                       unsi_addr;      
	union {
		struct sockaddr_un      ua_sun;
		char                    ua_dummy[SOCK_MAXADDRLEN];
	}                                       unsi_caddr;     
};
struct ndrv_info {
	uint32_t        ndrvsi_if_family;
	uint32_t        ndrvsi_if_unit;
	char            ndrvsi_if_name[IF_NAMESIZE];
};
struct kern_event_info {
	uint32_t        kesi_vendor_code_filter;
	uint32_t        kesi_class_filter;
	uint32_t        kesi_subclass_filter;
};
struct kern_ctl_info {
	uint32_t        kcsi_id;
	uint32_t        kcsi_reg_unit;
	uint32_t        kcsi_flags;                     
	uint32_t        kcsi_recvbufsize;               
	uint32_t        kcsi_sendbufsize;               
	uint32_t        kcsi_unit;
	char            kcsi_name[MAX_KCTL_NAME];       
};
struct vsock_sockinfo {
	uint32_t        local_cid;
	uint32_t        local_port;
	uint32_t        remote_cid;
	uint32_t        remote_port;
};
struct sockbuf_info {
	uint32_t                sbi_cc;
	uint32_t                sbi_hiwat;                      
	uint32_t                sbi_mbcnt;
	uint32_t                sbi_mbmax;
	uint32_t                sbi_lowat;
	short                   sbi_flags;
	short                   sbi_timeo;
};
struct socket_info {
	struct vinfo_stat                       soi_stat;
	uint64_t                                soi_so;         
	uint64_t                                soi_pcb;        
	int                                     soi_type;
	int                                     soi_protocol;
	int                                     soi_family;
	short                                   soi_options;
	short                                   soi_linger;
	short                                   soi_state;
	short                                   soi_qlen;
	short                                   soi_incqlen;
	short                                   soi_qlimit;
	short                                   soi_timeo;
	u_short                                 soi_error;
	uint32_t                                soi_oobmark;
	struct sockbuf_info                     soi_rcv;
	struct sockbuf_info                     soi_snd;
	int                                     soi_kind;
	uint32_t                                rfu_1;          
	union {
		struct in_sockinfo      pri_in;                 
		struct tcp_sockinfo     pri_tcp;                
		struct un_sockinfo      pri_un;                 
		struct ndrv_info        pri_ndrv;               
		struct kern_event_info  pri_kern_event;         
		struct kern_ctl_info    pri_kern_ctl;           
		struct vsock_sockinfo   pri_vsock;              
	}                                       soi_proto;
};
struct socket_fdinfo {
	struct proc_fileinfo    pfi;
	struct socket_info      psi;
};
struct psem_info {
	struct vinfo_stat       psem_stat;
	char                    psem_name[MAXPATHLEN];
};
struct psem_fdinfo {
	struct proc_fileinfo    pfi;
	struct psem_info        pseminfo;
};
struct pshm_info  {
	struct vinfo_stat       pshm_stat;
	uint64_t                pshm_mappaddr;
	char                    pshm_name[MAXPATHLEN];
};
struct pshm_fdinfo {
	struct proc_fileinfo    pfi;
	struct pshm_info        pshminfo;
};
struct pipe_info {
	struct vinfo_stat       pipe_stat;
	uint64_t                pipe_handle;
	uint64_t                pipe_peerhandle;
	int                     pipe_status;
	int                     rfu_1;  
};
struct pipe_fdinfo {
	struct proc_fileinfo    pfi;
	struct pipe_info        pipeinfo;
};
struct kqueue_info {
	struct vinfo_stat       kq_stat;
	uint32_t                kq_state;
	uint32_t                rfu_1;  
};
struct kqueue_dyninfo {
	struct kqueue_info kqdi_info;
	uint64_t kqdi_servicer;
	uint64_t kqdi_owner;
	uint32_t kqdi_sync_waiters;
	uint8_t  kqdi_sync_waiter_qos;
	uint8_t  kqdi_async_qos;
	uint16_t kqdi_request_state;
	uint8_t  kqdi_events_qos;
	uint8_t  kqdi_pri;
	uint8_t  kqdi_pol;
	uint8_t  kqdi_cpupercent;
	uint8_t  _kqdi_reserved0[4];
	uint64_t _kqdi_reserved1[4];
};
struct kqueue_fdinfo {
	struct proc_fileinfo    pfi;
	struct kqueue_info      kqueueinfo;
};
struct appletalk_info {
	struct vinfo_stat       atalk_stat;
};
struct appletalk_fdinfo {
	struct proc_fileinfo    pfi;
	struct appletalk_info   appletalkinfo;
};
struct proc_fdinfo {
	int32_t                 proc_fd;
	uint32_t                proc_fdtype;
};
struct proc_fileportinfo {
	uint32_t                proc_fileport;
	uint32_t                proc_fdtype;
};
struct proc_channel_info {
	uuid_t                  chi_instance;
	uint32_t                chi_port;
	uint32_t                chi_type;
	uint32_t                chi_flags;
	uint32_t                rfu_1;
};
struct channel_fdinfo {
	struct proc_fileinfo    pfi;
	struct proc_channel_info channelinfo;
};
struct proc_uniqidentifierinfo {
	uint8_t                 p_uuid[16];             
	uint64_t                p_uniqueid;             
	uint64_t                p_puniqueid;            
	int32_t                 p_idversion;            
	int32_t                 p_orig_ppidversion;     
	uint64_t                p_reserve2;             
	uint64_t                p_reserve3;             
};
struct proc_bsdinfowithuniqid {
	struct proc_bsdinfo             pbsd;
	struct proc_uniqidentifierinfo  p_uniqidentifier;
};
struct proc_archinfo {
	cpu_type_t              p_cputype;
	cpu_subtype_t           p_cpusubtype;
};
struct proc_pidcoalitioninfo {
	uint64_t coalition_id[COALITION_NUM_TYPES];
	uint64_t reserved1;
	uint64_t reserved2;
	uint64_t reserved3;
};
struct proc_originatorinfo {
	uuid_t                  originator_uuid;        
	pid_t                   originator_pid;         
	uint64_t                p_reserve2;
	uint64_t                p_reserve3;
	uint64_t                p_reserve4;
};
struct proc_ipctableinfo {
	uint32_t               table_size;
	uint32_t               table_free;
};
struct proc_threadschedinfo {
	uint64_t               int_time_ns;         
};
struct proc_threadcounts_data {
	uint64_t ptcd_instructions;
	uint64_t ptcd_cycles;
	uint64_t ptcd_user_time_mach;
	uint64_t ptcd_system_time_mach;
	uint64_t ptcd_energy_nj;
};
struct proc_threadcounts {
	uint16_t ptc_len;
	uint16_t ptc_reserved0;
	uint32_t ptc_reserved1;
	struct proc_threadcounts_data ptc_counts[];
};
struct proc_delegated_signal_info {
	audit_token_t instigator;
	audit_token_t target;
};
struct kevent_extinfo {
	struct kevent_qos_s kqext_kev;
	uint64_t kqext_sdata;
	int kqext_status;
	int kqext_sfflags;
	uint64_t kqext_reserved[2];
};
struct session {
	lck_mtx_t               s_mlock;             
	LIST_ENTRY(session)     s_hash;              
	struct proc            *s_leader;            
	struct vnode           *s_ttyvp;             
	struct tty             *s_ttyp;              
	uint32_t                s_ttyvid;            
	pid_t                   s_ttypgrpid;         
	dev_t _Atomic           s_ttydev;            
	pid_t                   s_sid;               
	os_ref_atomic_t         s_refcount;
	char                    s_login[MAXLOGNAME]; 
};
struct pgrp {
	union {
		lck_mtx_t       pg_mlock;       
		struct smr_node pg_smr_node;
	};
	struct smrq_slink       pg_hash;        
	LIST_HEAD(, proc)       pg_members;     
	struct session         *pg_session;     
	pid_t                   pg_id;          
	int                     pg_jobc;        
	os_ref_atomic_t         pg_refcount;
	os_ref_atomic_t         pg_hashref;
};
struct  sigacts {
	user_addr_t ps_sigact[NSIG];    
	user_addr_t ps_trampact[NSIG];  
	sigset_t ps_catchmask[NSIG];    
	sigset_t ps_sigonstack;         
	sigset_t ps_sigintr;            
	sigset_t ps_sigreset;           
	sigset_t ps_signodefer;         
	sigset_t ps_siginfo;            
	sigset_t ps_oldmask;            
	_Atomic uint32_t ps_sigreturn_validation; 
	int     ps_flags;               
	int     ps_sig;                 
	int     ps_code;                
	int     ps_addr;                
};
struct proc {
	union {
		LIST_ENTRY(proc) p_list;                
		struct smr_node  p_smr_node;
	};
	struct  proc *  XNU_PTRAUTH_SIGNED_PTR("proc.p_pptr") p_pptr;   
	proc_ro_t       p_proc_ro;
	pid_t           p_ppid;                 
	pid_t           p_pgrpid;               
	uid_t           p_uid;
	gid_t           p_gid;
	uid_t           p_ruid;
	gid_t           p_rgid;
	uid_t           p_svuid;
	gid_t           p_svgid;
	pid_t           p_sessionid;
	uint64_t        p_puniqueid;            

	lck_mtx_t       p_mlock;                
	pid_t           p_pid;                  
	char            p_stat;                 
	char            p_shutdownstate;
	char            p_kdebug;               
	char            p_btrace;               

	LIST_ENTRY(proc) p_pglist;              
	LIST_ENTRY(proc) p_sibling;             
	LIST_HEAD(, proc) p_children;           
	TAILQ_HEAD(, uthread) p_uthlist;        

	struct smrq_slink p_hash;               


	lck_mtx_t       p_ucred_mlock;          
	lck_mtx_t       p_audit_mlock;          

	struct  filedesc p_fd;                  
	struct  pstats *p_stats;                
	SMR_POINTER(struct plimit *) p_limit;
	SMR_POINTER(struct pgrp *XNU_PTRAUTH_SIGNED_PTR("proc.p_pgrp")) p_pgrp; 

	struct sigacts  p_sigacts;
	lck_spin_t      p_slock;                

	int             p_siglist;              
	unsigned int    p_flag;                 
	unsigned int    p_lflag;                
	unsigned int    p_listflag;             
	unsigned int    p_ladvflag;             
	os_ref_atomic_t p_refcount;             
	os_ref_atomic_t p_waitref;              
	int             p_childrencnt;          
	int             p_parentref;            
	pid_t           p_oppid;                
	u_int           p_xstat;                
	int             p_aio_total_count;              


	struct  itimerval p_realtimer;          
	struct  timeval p_rtime;                
	struct  itimerval p_vtimer_user;        
	struct  itimerval p_vtimer_prof;        

	struct  timeval p_rlim_cpu;             
	int             p_debugger;             
	boolean_t       sigwait;        
	void    *sigwait_thread;        
	void    *exit_thread;           
	pid_t   si_pid;                 
	u_int   si_status;              
	u_int   si_code;                
	uid_t   si_uid;                 

	void * vm_shm;                  
	int             p_ractive;
	pid_t             p_responsible_pid;    

	int                             p_dtrace_probes;                
	u_int                           p_dtrace_count;                 
	uint8_t                         p_dtrace_stop;                  
	user_addr_t                     p_dtrace_argv;                  
	user_addr_t                     p_dtrace_envp;                  
	lck_mtx_t                       p_dtrace_sprlock;               
	struct dtrace_ptss_page*        p_dtrace_ptss_pages;            
	struct dtrace_ptss_page_entry*  p_dtrace_ptss_free_list;        
	struct dtrace_helpers*          p_dtrace_helpers;               
	struct dof_ioctl_data*          p_dtrace_lazy_dofs;             

	__xnu_struct_group(proc_forkcopy_data, p_forkcopy, {
		u_int   p_argslen;       
		int     p_argc;                 
		user_addr_t user_stack;         
		struct  vnode * XNU_PTRAUTH_SIGNED_PTR("proc.p_textvp") p_textvp;       
		off_t   p_textoff;              

		sigset_t p_sigmask;             
		sigset_t p_sigignore;   
		sigset_t p_sigcatch;    
		sigset_t p_workq_allow_sigmask; 

		u_char  p_priority;     
		u_char  p_resv0;        
		char    p_nice;         
		u_char  p_resv1;        

		
		command_t   p_comm;
		proc_name_t p_name;     
		uint8_t p_xhighbits;    
		pid_t   p_contproc;     

		uint32_t        p_pcaction;     
		uint8_t p_uuid[16];                                

		uint8_t p_responsible_uuid[16]; 

		
		cpu_type_t      p_cputype;
		cpu_subtype_t   p_cpusubtype;
	});

	TAILQ_HEAD(, aio_workq_entry ) p_aio_activeq;   
	TAILQ_HEAD(, aio_workq_entry ) p_aio_doneq;     

	struct klist p_klist;  

	struct  rusage_superset *p_ru;  
	thread_t        p_signalholder;
	thread_t        p_transholder;
	int             p_sigwaitcnt;
	u_short p_acflag;       
	volatile u_short p_vfs_iopolicy;        

	user_addr_t     p_threadstart;          
	user_addr_t     p_wqthread;             
	int     p_pthsize;                      
	uint32_t        p_pth_tsd_offset;       
	user_addr_t     p_stack_addr_hint;      
	struct workqueue *_Atomic p_wqptr;                      

	struct  timeval p_start;                
	void *  p_rcall;
	void *  p_pthhash;                      
	volatile uint64_t was_throttled __attribute__((aligned(8))); 
	volatile uint64_t did_throttle __attribute__((aligned(8)));  

	uint64_t        p_dispatchqueue_offset;
	uint64_t        p_dispatchqueue_serialno_offset;
	uint64_t        p_dispatchqueue_label_offset;
	uint64_t        p_return_to_kernel_offset;
	uint64_t        p_mach_thread_self_offset;
	uint64_t        p_pthread_wq_quantum_offset;
	uint8_t p_crash_behavior;  
	bool p_posix_spawn_failed; 
	bool p_disallow_map_with_linking; 

	uint8_t           p_memstat_freeze_skip_reason; 
	uint32_t          p_memstat_state;              
	int32_t           p_memstat_effectivepriority;  
	int32_t           p_memstat_requestedpriority;  
	int32_t           p_memstat_assertionpriority;  
	uint32_t          p_memstat_dirty;              
	TAILQ_ENTRY(proc) p_memstat_list;               
	uint64_t          p_memstat_userdata;           
	uint64_t          p_memstat_idledeadline;       
	uint64_t          p_memstat_prio_start;         
	uint64_t          p_memstat_idle_delta;         
	int32_t           p_memstat_memlimit;           
	int32_t           p_memstat_memlimit_active;    
	int32_t           p_memstat_memlimit_inactive;  
	int32_t           p_memstat_relaunch_flags;     
	uint32_t          p_memstat_freeze_sharedanon_pages; 
	uint32_t          p_memstat_frozen_count;
	uint32_t          p_memstat_thaw_count;
	uint32_t          p_memstat_last_thaw_interval; 

	_Atomic uint32_t  p_user_faults; 

	uint32_t          p_memlimit_increase; 

	uint64_t p_crash_behavior_deadline; 

	uint32_t          p_crash_count;      
	uint32_t          p_throttle_timeout; 

	struct os_reason     *p_exit_reason;


	char * p_subsystem_root_path;
};
struct user32_extern_proc {
	union {
		struct {
			uint32_t __p_forw;      
			uint32_t __p_back;
		} p_st1;
		struct user32_timeval __p_starttime;    
	} p_un;
	uint32_t        p_vmspace;      
	uint32_t        p_sigacts;      
	int             p_flag;                 
	char    p_stat;                 
	pid_t   p_pid;                  
	pid_t   p_oppid;                
	int             p_dupfd;                
	uint32_t user_stack;    
	uint32_t exit_thread;  
	int             p_debugger;             
	boolean_t       sigwait;        
	u_int   p_estcpu;        
	int             p_cpticks;       
	fixpt_t p_pctcpu;        
	uint32_t        p_wchan;         
	uint32_t        p_wmesg;         
	u_int   p_swtime;        
	u_int   p_slptime;       
	struct  user32_itimerval p_realtimer;   
	struct  user32_timeval p_rtime; 
	u_quad_t p_uticks;              
	u_quad_t p_sticks;              
	u_quad_t p_iticks;              
	int             p_traceflag;            
	uint32_t        p_tracep;       
	int             p_siglist;              
	uint32_t        p_textvp;       
	int             p_holdcnt;              
	sigset_t p_sigmask;     
	sigset_t p_sigignore;   
	sigset_t p_sigcatch;    
	u_char  p_priority;     
	u_char  p_usrpri;       
	char    p_nice;         
	char    p_comm[MAXCOMLEN + 1];
	uint32_t        p_pgrp; 
	uint32_t        p_addr; 
	u_short p_xstat;        
	u_short p_acflag;       
	uint32_t        p_ru;   
};
struct user64_extern_proc {
	union {
		struct {
			user_addr_t __p_forw;   
			user_addr_t __p_back;
		} p_st1;
		struct user64_timeval __p_starttime;    
	} p_un;
	user_addr_t     p_vmspace;      
	user_addr_t             p_sigacts;      
	int             p_flag;                 
	char    p_stat;                 
	pid_t   p_pid;                  
	pid_t   p_oppid;                
	int             p_dupfd;                
	user_addr_t user_stack __attribute((aligned(8)));       
	user_addr_t exit_thread;  
	int             p_debugger;             
	boolean_t       sigwait;        
	u_int   p_estcpu;        
	int             p_cpticks;       
	fixpt_t p_pctcpu;        
	user_addr_t     p_wchan __attribute((aligned(8)));       
	user_addr_t     p_wmesg;         
	u_int   p_swtime;        
	u_int   p_slptime;       
	struct  user64_itimerval p_realtimer;   
	struct  user64_timeval p_rtime; 
	u_quad_t p_uticks;              
	u_quad_t p_sticks;              
	u_quad_t p_iticks;              
	int             p_traceflag;            
	user_addr_t     p_tracep __attribute((aligned(8)));     
	int             p_siglist;              
	user_addr_t     p_textvp __attribute((aligned(8)));     
	int             p_holdcnt;              
	sigset_t p_sigmask;     
	sigset_t p_sigignore;   
	sigset_t p_sigcatch;    
	u_char  p_priority;     
	u_char  p_usrpri;       
	char    p_nice;         
	char    p_comm[MAXCOMLEN + 1];
	user_addr_t     p_pgrp __attribute((aligned(8)));       
	user_addr_t     p_addr; 
	u_short p_xstat;        
	u_short p_acflag;       
	user_addr_t     p_ru __attribute((aligned(8))); 
};
struct proc_platform_ro_data {
	uint32_t p_platform;
	uint32_t p_min_sdk;
	uint32_t p_sdk;
};
struct task_token_ro_data {
	security_token_t sec_token;
	audit_token_t audit_token;
};
struct task_filter_ro_data {
	uint8_t *__unsafe_indexable mach_trap_filter_mask; 
	uint8_t *__unsafe_indexable mach_kobj_filter_mask; 
};
struct proc_ro {
	struct proc *pr_proc;
	struct task *pr_task;

	__xnu_struct_group(proc_ro_data, proc_data, {
		uint64_t p_uniqueid;                               
		int p_idversion;                                   
		pid_t p_orig_ppid;                                 
		int p_orig_ppidversion;                            
		uint32_t p_csflags;
		SMR_POINTER(struct ucred *) p_ucred;               
		uint8_t *__unsafe_indexable syscall_filter_mask;   
		struct proc_platform_ro_data p_platform_data;
	});

	__xnu_struct_group(task_ro_data, task_data, {
		
		struct task_token_ro_data task_tokens;
		struct task_filter_ro_data task_filters;
		uint32_t t_flags_ro;                               
		uint32_t task_control_port_options;
	});
};
struct ipctlparam {
	struct ip   *ipc_icmp_ip;  
	struct mbuf *ipc_m;        
	struct icmp *ipc_icmp;     
	size_t       ipc_off;      
};
struct protosw_old {
	short   pr_type;                
	struct  domain *pr_domain;      
	short   pr_protocol;            
	unsigned int pr_flags;          
	void    (*pr_input)             
	(struct mbuf *, int len);
	int     (*pr_output)            
	(struct mbuf *m, struct socket *so);
	void    (*pr_ctlinput)          
	(int, struct sockaddr *, void *, struct ifnet *);
	int     (*pr_ctloutput)         
	(struct socket *, struct sockopt *);
	void    *pr_ousrreq;
	void    (*pr_init)(void);       
	void    (*pr_unused)(void);     
	void    (*pr_unused2)(void);    
	void    (*pr_drain)(void);      
	int     (*pr_sysctl)            
	(int *, u_int, void *, size_t *, void *, size_t);
	struct  pr_usrreqs_old *pr_usrreqs; 
	int     (*pr_lock)              
	(struct socket *so, int refcnt, void *debug);
	int     (*pr_unlock)            
	(struct socket *so, int refcnt, void *debug);
	lck_mtx_t * __single (*pr_getlock)        
	(struct socket *so, int flags);
	TAILQ_HEAD(, socket_filter) pr_filter_head;
	struct protosw_old *pr_next;    
	u_int32_t       reserved[1];    
};
struct protosw {
	TAILQ_ENTRY(protosw) pr_entry; 
	struct  domain *pr_domain;      
	struct protosw *pr_protosw;     
	u_int16_t pr_type;              
	u_int16_t pr_protocol;          
	u_int32_t pr_flags;             
	void    (*pr_input)             
	(struct mbuf *, int len);
	int     (*pr_output)            
	(struct mbuf *m, struct socket *so);
	void    (*pr_ctlinput)          
	(int, struct sockaddr *, void *, struct ifnet *);
	int     (*pr_ctloutput)         
	(struct socket *, struct sockopt *);
	struct  pr_usrreqs *pr_usrreqs; 
	void    (*pr_init)              
	(struct protosw *, struct domain *);
	void    (*pr_drain)(void);      
	int     (*pr_sysctl)            
	(int *, u_int, void *, size_t *, void *, size_t);
	int     (*pr_lock)              
	(struct socket *so, int refcnt, void *debug);
	int     (*pr_unlock)            
	(struct socket *so, int refcnt, void *debug);
	lck_mtx_t * __single (*pr_getlock)        
	(struct socket *so, int flags);
	TAILQ_HEAD(, socket_filter) pr_filter_head;
	struct protosw_old *pr_old;

	void    (*pr_update_last_owner) 
	(struct socket *so, struct proc *p, struct proc *ep);

	void    (*pr_copy_last_owner) 
	(struct socket *so, struct socket *head);
};
struct pr_usrreqs_old {
	int     (*pru_abort)(struct socket *so);
	int     (*pru_accept)(struct socket *so, struct sockaddr **nam);
	int     (*pru_attach)(struct socket *so, int proto, struct proc *p);
	int     (*pru_bind)(struct socket *so, struct sockaddr *nam,
	    struct proc *p);
	int     (*pru_connect)(struct socket *so, struct sockaddr *nam,
	    struct proc *p);
	int     (*pru_connect2)(struct socket *so1, struct socket *so2);
	int     (*pru_control)(struct socket *so, u_long cmd, caddr_t data,
	    struct ifnet *ifp, struct proc *p);
	int     (*pru_detach)(struct socket *so);
	int     (*pru_disconnect)(struct socket *so);
	int     (*pru_listen)(struct socket *so, struct proc *p);
	int     (*pru_peeraddr)(struct socket *so, struct sockaddr **nam);
	int     (*pru_rcvd)(struct socket *so, int flags);
	int     (*pru_rcvoob)(struct socket *so, struct mbuf *m, int flags);
	int     (*pru_send)(struct socket *so, int flags, struct mbuf *m,
	    struct sockaddr *addr, struct mbuf *control,
	    struct proc *p);
	int     (*pru_sense)(struct socket *so, void  *sb, int isstat64);
	int     (*pru_shutdown)(struct socket *so);
	int     (*pru_sockaddr)(struct socket *so, struct sockaddr **nam);
	int     (*pru_sosend)(struct socket *so, struct sockaddr *addr,
	    struct uio *uio, struct mbuf *top, struct mbuf *control,
	    int flags);
	int     (*pru_soreceive)(struct socket *so, struct sockaddr **paddr,
	    struct uio *uio, struct mbuf **mp0, struct mbuf *__single *controlp,
	    int *flagsp);
	int     (*pru_sopoll)(struct socket *so, int events,
	    struct ucred *cred, void *);
};
struct pr_usrreqs {
	uint32_t pru_flags;     
	int     (*pru_abort)(struct socket *);
	int     (*pru_accept)(struct socket *, struct sockaddr **);
	int     (*pru_attach)(struct socket *, int proto, struct proc *);
	int     (*pru_bind)(struct socket *, struct sockaddr *, struct proc *);
	int     (*pru_connect)(struct socket *, struct sockaddr *,
	    struct proc *);
	int     (*pru_connect2)(struct socket *, struct socket *);
	int     (*pru_connectx)(struct socket *, struct sockaddr *,
	    struct sockaddr *, struct proc *, uint32_t,
	    sae_associd_t, sae_connid_t *, uint32_t, void *, uint32_t,
	    struct uio *, user_ssize_t *);
	int     (*pru_control)(struct socket *,
	    u_long cmd, caddr_t __sized_by(IOCPARM_LEN(cmd)) data,
	    struct ifnet *, struct proc *);
	int     (*pru_detach)(struct socket *);
	int     (*pru_disconnect)(struct socket *);
	int     (*pru_disconnectx)(struct socket *,
	    sae_associd_t, sae_connid_t);
	int     (*pru_listen)(struct socket *, struct proc *);
	int     (*pru_peeraddr)(struct socket *, struct sockaddr **);
	int     (*pru_rcvd)(struct socket *, int);
	int     (*pru_rcvoob)(struct socket *, struct mbuf *, int);
	int     (*pru_send)(struct socket *, int, struct mbuf *,
	    struct sockaddr *, struct mbuf *, struct proc *);
	int     (*pru_send_list)(struct socket *, struct mbuf *, u_int *, int);
	int     (*pru_sense)(struct socket *, void *, int);
	int     (*pru_shutdown)(struct socket *);
	int     (*pru_sockaddr)(struct socket *, struct sockaddr **);
	int     (*pru_sopoll)(struct socket *, int, struct ucred *, void *);
	int     (*pru_soreceive)(struct socket *, struct sockaddr **,
	    struct uio *, struct mbuf **, struct mbuf **, int *);
	int     (*pru_sosend)(struct socket *, struct sockaddr *,
	    struct uio *, struct mbuf *, struct mbuf *, int);
	int     (*pru_sosend_list)(struct socket *, struct mbuf *, size_t, u_int *, int);
	int     (*pru_socheckopt)(struct socket *, struct sockopt *);
	int     (*pru_preconnect)(struct socket *so);
	int     (*pru_defunct)(struct socket *);
};
struct ksyn_waitq_element {
	char opaque[48];
};
struct pthread_functions_s {
	int version;

	void (*pthread_init)(void);

	void *__unused_was_fill_procworkqueue;
	void *__unused1;
	void *__unused2;
	void *__unused_was_workqueue_exit;
	void *__unused_was_workqueue_mark_exiting;
	void *__unused_was_workqueue_thread_yielded;

	void (*pth_proc_hashinit)(proc_t p);
	void (*pth_proc_hashdelete)(proc_t p);

	int (*bsdthread_create)(struct proc *p, user_addr_t user_func, user_addr_t user_funcarg, user_addr_t user_stack, user_addr_t user_pthread, uint32_t flags, user_addr_t *retval);
	int (*bsdthread_register)(struct proc *p, user_addr_t threadstart, user_addr_t wqthread, int pthsize, user_addr_t dummy_value, user_addr_t targetconc_ptr, uint64_t dispatchqueue_offset, int32_t *retval);
	int (*bsdthread_terminate)(struct proc *p, user_addr_t stackaddr, size_t size, uint32_t kthport, uint32_t sem, int32_t *retval);
	int (*thread_selfid)(struct proc *p, uint64_t *retval);
	void *__unused_was_workq_kernreturn;
	void *__unused_was_workq_open;

	int (*psynch_mutexwait)(proc_t p, user_addr_t mutex, uint32_t mgen, uint32_t  ugen, uint64_t tid, uint32_t flags, uint32_t *retval);
	int (*psynch_mutexdrop)(proc_t p, user_addr_t mutex, uint32_t mgen, uint32_t  ugen, uint64_t tid, uint32_t flags, uint32_t *retval);
	int (*psynch_cvbroad)(proc_t p, user_addr_t cv, uint64_t cvlsgen, uint64_t cvudgen, uint32_t flags, user_addr_t mutex, uint64_t mugen, uint64_t tid, uint32_t *retval);
	int (*psynch_cvsignal)(proc_t p, user_addr_t cv, uint64_t cvlsgen, uint32_t cvugen, int thread_port, user_addr_t mutex, uint64_t mugen, uint64_t tid, uint32_t flags, uint32_t *retval);
	int (*psynch_cvwait)(proc_t p, user_addr_t cv, uint64_t cvlsgen, uint32_t cvugen, user_addr_t mutex, uint64_t mugen, uint32_t flags, int64_t sec, uint32_t nsec, uint32_t * retval);
	int (*psynch_cvclrprepost)(proc_t p, user_addr_t cv, uint32_t cvgen, uint32_t cvugen, uint32_t cvsgen, uint32_t prepocnt, uint32_t preposeq, uint32_t flags, int *retval);
	int (*psynch_rw_longrdlock)(proc_t p, user_addr_t rwlock, uint32_t lgenval, uint32_t ugenval, uint32_t rw_wc, int flags, uint32_t *retval);
	int (*psynch_rw_rdlock)(proc_t p, user_addr_t rwlock, uint32_t lgenval, uint32_t ugenval, uint32_t rw_wc, int flags, uint32_t *retval);
	int (*psynch_rw_unlock)(proc_t p, user_addr_t rwlock, uint32_t lgenval, uint32_t ugenval, uint32_t rw_wc, int flags, uint32_t *retval);
	int (*psynch_rw_wrlock)(proc_t p, user_addr_t rwlock, uint32_t lgenval, uint32_t ugenval, uint32_t rw_wc, int flags, uint32_t *retval);
	int (*psynch_rw_yieldwrlock)(proc_t p, user_addr_t rwlock, uint32_t lgenval, uint32_t ugenval, uint32_t rw_wc, int flags, uint32_t *retval);

	void *__unused_was_workqueue_get_sched_callback;

	int (*bsdthread_register2)(struct proc *p, user_addr_t threadstart, user_addr_t wqthread, uint32_t flags, user_addr_t stack_addr_hint, user_addr_t targetconc_ptr, uint32_t dispatchqueue_offset, uint32_t tsd_offset, int32_t *retval);

	void *__unused_was_bsdthread_ctl;
	void *__unused_was_workq_reqthreads;

	void *__unused_was_thread_qos_from_pthread_priority;
	void *__unused_was_get_pwq_state_kdp;
	void *__unused3;
	void *__unused_was_pthread_priority_canonicalize2;
	void *__unused_was_workq_thread_has_been_unbound;

	void (*pthread_find_owner)(thread_t thread, struct stackshot_thread_waitinfo *waitinfo);
	void *(*pthread_get_thread_kwq)(thread_t thread);

	void *__unused_was_workq_threadreq;

	int  (*workq_handle_stack_events)(proc_t p, thread_t th, vm_map_t map,
	    user_addr_t stackaddr, mach_port_name_t kport,
	    user_addr_t events, int nevents, int upcall_flags);

	int (*workq_create_threadstack)(proc_t p, vm_map_t vmap,
	    mach_vm_offset_t *out_addr);

	int (*workq_destroy_threadstack)(proc_t p, vm_map_t vmap,
	    mach_vm_offset_t stackaddr);

	void (*workq_setup_thread)(proc_t p, thread_t th, vm_map_t map,
	    user_addr_t stackaddr, mach_port_name_t kport, int th_qos,
	    int setup_flags, int upcall_flags);

	void (*workq_markfree_threadstack)(proc_t p, thread_t, vm_map_t map,
	    user_addr_t stackaddr);

	void * _pad[83];
} * pthread_functions_t;
struct pthread_callbacks_s {
	int version;

	uint32_t config_thread_max;
	uint32_t (*get_task_threadmax)(void);

	uint64_t (*proc_get_register)(struct proc *t);
	void (*proc_set_register)(struct proc *t);

	user_addr_t (*proc_get_threadstart)(struct proc *t);
	void (*proc_set_threadstart)(struct proc *t, user_addr_t addr);
	user_addr_t (*proc_get_wqthread)(struct proc *t);
	void (*proc_set_wqthread)(struct proc *t, user_addr_t addr);
	int (*proc_get_pthsize)(struct proc *t);
	void (*proc_set_pthsize)(struct proc *t, int size);

	thread_t (*task_findtid)(task_t t, uint64_t tid);
	void (*thread_deallocate_safe)(thread_t);
	bool (*proc_get_jit_entitled)(struct proc *t);
	void (*proc_set_dispatchqueue_offset)(struct proc *t, uint64_t offset);
	bool (*proc_get_pthread_jit_allowlist2)(struct proc *t, bool *late_out);
	void *__unused_was_proc_get_wqinitingptr;
	void *__unused_was_proc_get_wqptr;

	wait_result_t (*psynch_wait_prepare)(uintptr_t kwq,
	    struct turnstile **tstore, thread_t owner, block_hint_t block_hint,
	    uint64_t deadline);

	void (*psynch_wait_update_complete)(struct turnstile *turnstile);

	void (*psynch_wait_complete)(uintptr_t kwq, struct turnstile **tstore);

	void (*psynch_wait_cleanup)(void);

	kern_return_t (*psynch_wait_wakeup)(uintptr_t kwq,
	    struct ksyn_waitq_element *kwe, struct turnstile **tstore);

	void (*psynch_wait_update_owner)(uintptr_t kwq, thread_t owner,
	    struct turnstile **tstore);

	void* (*proc_get_pthhash)(struct proc *t);
	void (*proc_set_pthhash)(struct proc *t, void* ptr);

	void *__unused_was_uthread_get_threadlist;
	void *__unused_was_uthread_set_threadlist;
	void *__unused_was_uthread_get_sigmask;
	void *__unused_was_uthread_set_sigmask;

	void* (*uthread_get_uukwe)(struct uthread *t);
	void *__unused_was_uthread_get_returnval;
	void (*uthread_set_returnval)(struct uthread *t, int val);
	int (*uthread_is_cancelled)(struct uthread *t);

	ipc_space_t (*task_get_ipcspace)(task_t t);
	void *__unused_was_ipc_port_copyout_send;

	kern_return_t (*vm_map_page_info)(vm_map_t map, vm_map_offset_t offset, vm_page_info_flavor_t flavor, vm_page_info_t info, mach_msg_type_number_t *count);
	mach_port_name_t (*ipc_port_copyout_send_pinned)(ipc_port_t sright, ipc_space_t space);

	kern_return_t (*thread_set_wq_state32)(thread_t thread, thread_state_t state);

	void (*thread_exception_return)(void);
	void (*thread_bootstrap_return)(void);

	void *__unused_was_absolutetime_to_microtime;
	void *__unused_was_thread_set_workq_pri;
	void *__unused_was_thread_set_workq_qos;

	struct uthread* (*get_bsdthread_info)(thread_t th);
	void *__unused_was_thread_sched_call;
	void *__unused_was_thread_static_param;
	void *__unused_was_thread_create_workq_waiting_parameter;
	kern_return_t (*thread_policy_set_internal)(thread_t t, thread_policy_flavor_t flavour, thread_policy_t info, mach_msg_type_number_t count);

	void *__unused_was_thread_affinity_set;

	void (*unix_syscall_return)(int error);

	void *__unused_was_zalloc;
	void *__unused_was_zfree;
	void *__unused_was_zinit;

	void (*__pthread_testcancel)(int);

	kern_return_t (*mach_port_deallocate)(ipc_space_t space, mach_port_name_t name);
	kern_return_t (*semaphore_signal_internal_trap)(mach_port_name_t sema_name);
	vm_map_t (*current_map)(void);

	void *__unused_was_convert_thread_to_port;
	void *__unused_was_thread_create;

	kern_return_t (*thread_resume)(thread_act_t target_act);

	int (*kevent_workq_internal)(struct proc *p,
	    user_addr_t changelist, int nchanges,
	    user_addr_t eventlist, int nevents,
	    user_addr_t data_out, user_size_t *data_available,
	    unsigned int flags, int32_t *retval);


	void *__unused_was_proc_get_dispatchqueue_serialno_offset;
	void *__unused_was_proc_set_dispatchqueue_serialno_offset;

	void *__unused_was_proc_usynch_thread_qos_add_override_for_resource_check_owner;
	void (*proc_set_workqueue_quantum_offset)(struct proc *p, uint64_t offset);

	uint32_t (*proc_get_pthread_tsd_offset)(struct proc *p);
	void (*proc_set_pthread_tsd_offset)(struct proc *p, uint32_t pthread_tsd_offset);

	kern_return_t (*thread_set_tsd_base)(thread_t thread, mach_vm_offset_t tsd_base);

	int     (*proc_usynch_get_requested_thread_qos)(struct uthread *);
	uint64_t (*proc_get_mach_thread_self_tsd_offset)(struct proc *p);
	void (*proc_set_mach_thread_self_tsd_offset)(struct proc *p, uint64_t mach_thread_self_tsd_offset);

	kern_return_t (*thread_policy_get)(thread_t t, thread_policy_flavor_t flavor, thread_policy_t info, mach_msg_type_number_t *count, boolean_t *get_default);
	boolean_t (*qos_main_thread_active)(void);

	kern_return_t (*thread_set_voucher_name)(mach_port_name_t name);

	boolean_t (*proc_usynch_thread_qos_add_override_for_resource)(task_t task, struct uthread *, uint64_t tid, int override_qos, boolean_t first_override_for_resource, user_addr_t resource, int resource_type);
	boolean_t (*proc_usynch_thread_qos_remove_override_for_resource)(task_t task, struct uthread *, uint64_t tid, user_addr_t resource, int resource_type);
	void *__unused_was_proc_usynch_thread_qos_reset_override_for_resource;

	void *__unused_was_proc_init_wqptr_or_wait;

	uint16_t (*thread_set_tag)(thread_t thread, uint16_t tag);
	uint16_t (*thread_get_tag)(thread_t thread);

	void *__unused_was_thread_create_pinned;

	kern_return_t (*thread_terminate_pinned)(thread_t thread);
	ipc_port_t (*convert_thread_to_port_pinned)(thread_t th);

	user_addr_t (*proc_get_stack_addr_hint)(struct proc *p);
	void (*proc_set_stack_addr_hint)(struct proc *p, user_addr_t stack_addr_hint);

	kern_return_t (*thread_create_immovable)(task_t parent_task, thread_t *new_thread);
	void (*proc_set_return_to_kernel_offset)(struct proc *t, uint64_t offset);

	void *__unused_was_workloop_fulfill_threadreq;
	void (*thread_will_park_or_terminate)(thread_t thread);

	void *__unused_was_qos_max_parallelism;

	user_addr_t (*proc_get_user_stack)(struct proc *p);
	void *__unused_was_proc_set_user_stack;

	void* _pad[69];
} *pthread_callbacks_t;
struct os_reason {
	decl_lck_mtx_data(, osr_lock);
	os_refcnt_t                     osr_refcount;
	uint32_t                        osr_namespace;
	uint64_t                        osr_code;
	uint64_t                        osr_flags;
	uint32_t                        osr_bufsize;
	struct kcdata_descriptor        osr_kcd_descriptor;
	char                            *osr_kcd_buf;
} *os_reason_t;
struct _exception_info {
	int os_reason;
	int signal;
	exception_type_t exception_type;
	mach_exception_data_type_t mx_code;
	mach_exception_data_type_t mx_subcode;
	struct kt_info {
		int kt_subsys;
		uint32_t kt_error;
	} kt_info;
} exception_info_t;
struct  rusage {
	struct timeval ru_utime;        
	struct timeval ru_stime;        
};
struct rusage_info_v0 {
	uint8_t  ri_uuid[16];
	uint64_t ri_user_time;
	uint64_t ri_system_time;
	uint64_t ri_pkg_idle_wkups;
	uint64_t ri_interrupt_wkups;
	uint64_t ri_pageins;
	uint64_t ri_wired_size;
	uint64_t ri_resident_size;
	uint64_t ri_phys_footprint;
	uint64_t ri_proc_start_abstime;
	uint64_t ri_proc_exit_abstime;
};
struct rusage_info_v1 {
	uint8_t  ri_uuid[16];
	uint64_t ri_user_time;
	uint64_t ri_system_time;
	uint64_t ri_pkg_idle_wkups;
	uint64_t ri_interrupt_wkups;
	uint64_t ri_pageins;
	uint64_t ri_wired_size;
	uint64_t ri_resident_size;
	uint64_t ri_phys_footprint;
	uint64_t ri_proc_start_abstime;
	uint64_t ri_proc_exit_abstime;
	uint64_t ri_child_user_time;
	uint64_t ri_child_system_time;
	uint64_t ri_child_pkg_idle_wkups;
	uint64_t ri_child_interrupt_wkups;
	uint64_t ri_child_pageins;
	uint64_t ri_child_elapsed_abstime;
};
struct rusage_info_v2 {
	uint8_t  ri_uuid[16];
	uint64_t ri_user_time;
	uint64_t ri_system_time;
	uint64_t ri_pkg_idle_wkups;
	uint64_t ri_interrupt_wkups;
	uint64_t ri_pageins;
	uint64_t ri_wired_size;
	uint64_t ri_resident_size;
	uint64_t ri_phys_footprint;
	uint64_t ri_proc_start_abstime;
	uint64_t ri_proc_exit_abstime;
	uint64_t ri_child_user_time;
	uint64_t ri_child_system_time;
	uint64_t ri_child_pkg_idle_wkups;
	uint64_t ri_child_interrupt_wkups;
	uint64_t ri_child_pageins;
	uint64_t ri_child_elapsed_abstime;
	uint64_t ri_diskio_bytesread;
	uint64_t ri_diskio_byteswritten;
};
struct rusage_info_v3 {
	uint8_t  ri_uuid[16];
	uint64_t ri_user_time;
	uint64_t ri_system_time;
	uint64_t ri_pkg_idle_wkups;
	uint64_t ri_interrupt_wkups;
	uint64_t ri_pageins;
	uint64_t ri_wired_size;
	uint64_t ri_resident_size;
	uint64_t ri_phys_footprint;
	uint64_t ri_proc_start_abstime;
	uint64_t ri_proc_exit_abstime;
	uint64_t ri_child_user_time;
	uint64_t ri_child_system_time;
	uint64_t ri_child_pkg_idle_wkups;
	uint64_t ri_child_interrupt_wkups;
	uint64_t ri_child_pageins;
	uint64_t ri_child_elapsed_abstime;
	uint64_t ri_diskio_bytesread;
	uint64_t ri_diskio_byteswritten;
	uint64_t ri_cpu_time_qos_default;
	uint64_t ri_cpu_time_qos_maintenance;
	uint64_t ri_cpu_time_qos_background;
	uint64_t ri_cpu_time_qos_utility;
	uint64_t ri_cpu_time_qos_legacy;
	uint64_t ri_cpu_time_qos_user_initiated;
	uint64_t ri_cpu_time_qos_user_interactive;
	uint64_t ri_billed_system_time;
	uint64_t ri_serviced_system_time;
};
struct rusage_info_v4 {
	uint8_t  ri_uuid[16];
	uint64_t ri_user_time;
	uint64_t ri_system_time;
	uint64_t ri_pkg_idle_wkups;
	uint64_t ri_interrupt_wkups;
	uint64_t ri_pageins;
	uint64_t ri_wired_size;
	uint64_t ri_resident_size;
	uint64_t ri_phys_footprint;
	uint64_t ri_proc_start_abstime;
	uint64_t ri_proc_exit_abstime;
	uint64_t ri_child_user_time;
	uint64_t ri_child_system_time;
	uint64_t ri_child_pkg_idle_wkups;
	uint64_t ri_child_interrupt_wkups;
	uint64_t ri_child_pageins;
	uint64_t ri_child_elapsed_abstime;
	uint64_t ri_diskio_bytesread;
	uint64_t ri_diskio_byteswritten;
	uint64_t ri_cpu_time_qos_default;
	uint64_t ri_cpu_time_qos_maintenance;
	uint64_t ri_cpu_time_qos_background;
	uint64_t ri_cpu_time_qos_utility;
	uint64_t ri_cpu_time_qos_legacy;
	uint64_t ri_cpu_time_qos_user_initiated;
	uint64_t ri_cpu_time_qos_user_interactive;
	uint64_t ri_billed_system_time;
	uint64_t ri_serviced_system_time;
	uint64_t ri_logical_writes;
	uint64_t ri_lifetime_max_phys_footprint;
	uint64_t ri_instructions;
	uint64_t ri_cycles;
	uint64_t ri_billed_energy;
	uint64_t ri_serviced_energy;
	uint64_t ri_interval_max_phys_footprint;
	uint64_t ri_runnable_time;
};
struct rusage_info_v5 {
	uint8_t  ri_uuid[16];
	uint64_t ri_user_time;
	uint64_t ri_system_time;
	uint64_t ri_pkg_idle_wkups;
	uint64_t ri_interrupt_wkups;
	uint64_t ri_pageins;
	uint64_t ri_wired_size;
	uint64_t ri_resident_size;
	uint64_t ri_phys_footprint;
	uint64_t ri_proc_start_abstime;
	uint64_t ri_proc_exit_abstime;
	uint64_t ri_child_user_time;
	uint64_t ri_child_system_time;
	uint64_t ri_child_pkg_idle_wkups;
	uint64_t ri_child_interrupt_wkups;
	uint64_t ri_child_pageins;
	uint64_t ri_child_elapsed_abstime;
	uint64_t ri_diskio_bytesread;
	uint64_t ri_diskio_byteswritten;
	uint64_t ri_cpu_time_qos_default;
	uint64_t ri_cpu_time_qos_maintenance;
	uint64_t ri_cpu_time_qos_background;
	uint64_t ri_cpu_time_qos_utility;
	uint64_t ri_cpu_time_qos_legacy;
	uint64_t ri_cpu_time_qos_user_initiated;
	uint64_t ri_cpu_time_qos_user_interactive;
	uint64_t ri_billed_system_time;
	uint64_t ri_serviced_system_time;
	uint64_t ri_logical_writes;
	uint64_t ri_lifetime_max_phys_footprint;
	uint64_t ri_instructions;
	uint64_t ri_cycles;
	uint64_t ri_billed_energy;
	uint64_t ri_serviced_energy;
	uint64_t ri_interval_max_phys_footprint;
	uint64_t ri_runnable_time;
	uint64_t ri_flags;
};
struct rusage_info_v6 {
	uint8_t  ri_uuid[16];
	uint64_t ri_user_time;
	uint64_t ri_system_time;
	uint64_t ri_pkg_idle_wkups;
	uint64_t ri_interrupt_wkups;
	uint64_t ri_pageins;
	uint64_t ri_wired_size;
	uint64_t ri_resident_size;
	uint64_t ri_phys_footprint;
	uint64_t ri_proc_start_abstime;
	uint64_t ri_proc_exit_abstime;
	uint64_t ri_child_user_time;
	uint64_t ri_child_system_time;
	uint64_t ri_child_pkg_idle_wkups;
	uint64_t ri_child_interrupt_wkups;
	uint64_t ri_child_pageins;
	uint64_t ri_child_elapsed_abstime;
	uint64_t ri_diskio_bytesread;
	uint64_t ri_diskio_byteswritten;
	uint64_t ri_cpu_time_qos_default;
	uint64_t ri_cpu_time_qos_maintenance;
	uint64_t ri_cpu_time_qos_background;
	uint64_t ri_cpu_time_qos_utility;
	uint64_t ri_cpu_time_qos_legacy;
	uint64_t ri_cpu_time_qos_user_initiated;
	uint64_t ri_cpu_time_qos_user_interactive;
	uint64_t ri_billed_system_time;
	uint64_t ri_serviced_system_time;
	uint64_t ri_logical_writes;
	uint64_t ri_lifetime_max_phys_footprint;
	uint64_t ri_instructions;
	uint64_t ri_cycles;
	uint64_t ri_billed_energy;
	uint64_t ri_serviced_energy;
	uint64_t ri_interval_max_phys_footprint;
	uint64_t ri_runnable_time;
	uint64_t ri_flags;
	uint64_t ri_user_ptime;
	uint64_t ri_system_ptime;
	uint64_t ri_pinstructions;
	uint64_t ri_pcycles;
	uint64_t ri_energy_nj;
	uint64_t ri_penergy_nj;
	uint64_t ri_secure_time_in_system;
	uint64_t ri_secure_ptime_in_system;
	uint64_t ri_neural_footprint;
	uint64_t ri_lifetime_max_neural_footprint;
	uint64_t ri_interval_max_neural_footprint;
	uint64_t ri_reserved[9];
};
struct rusage_superset {
	struct rusage           ru;
	rusage_info_current     ri;
};
struct rusage_info_child {
	uint64_t ri_child_user_time;
	uint64_t ri_child_system_time;
	uint64_t ri_child_pkg_idle_wkups;
	uint64_t ri_child_interrupt_wkups;
	uint64_t ri_child_pageins;
	uint64_t ri_child_elapsed_abstime;
};
struct  user64_rusage {
	struct user64_timeval ru_utime; 
	struct user64_timeval ru_stime; 
	user64_long_t   ru_maxrss;              
	user64_long_t   ru_ixrss;               
	user64_long_t   ru_idrss;               
	user64_long_t   ru_isrss;               
	user64_long_t   ru_minflt;              
	user64_long_t   ru_majflt;              
	user64_long_t   ru_nswap;               
	user64_long_t   ru_inblock;             
	user64_long_t   ru_oublock;             
	user64_long_t   ru_msgsnd;              
	user64_long_t   ru_msgrcv;              
	user64_long_t   ru_nsignals;    
	user64_long_t   ru_nvcsw;               
	user64_long_t   ru_nivcsw;              
};
struct  user32_rusage {
	struct user32_timeval ru_utime; 
	struct user32_timeval ru_stime; 
	user32_long_t   ru_maxrss;              
	user32_long_t   ru_ixrss;               
	user32_long_t   ru_idrss;               
	user32_long_t   ru_isrss;               
	user32_long_t   ru_minflt;              
	user32_long_t   ru_majflt;              
	user32_long_t   ru_nswap;               
	user32_long_t   ru_inblock;             
	user32_long_t   ru_oublock;             
	user32_long_t   ru_msgsnd;              
	user32_long_t   ru_msgrcv;              
	user32_long_t   ru_nsignals;    
	user32_long_t   ru_nvcsw;               
	user32_long_t   ru_nivcsw;              
};
struct rlimit {
	rlim_t  rlim_cur;               
	rlim_t  rlim_max;               
};
struct proc_rlimit_control_wakeupmon {
	uint32_t wm_flags;
	int32_t wm_rate;
};
struct pstats {
	struct  rusage            p_ru;         
	struct  rusage            p_cru;        

	struct uprof {                  
		struct uprof *pr_next;  
		caddr_t pr_base;        
		u_int32_t       pr_size;        
		u_int32_t       pr_off;         
		u_int32_t       pr_scale;       
		u_int32_t       pr_addr;        
		u_int32_t       pr_ticks;       
	} p_prof;

	uint64_t ps_start;              
	struct  rusage_info_child ri_child;     
	struct user_uprof {                         
		struct user_uprof *pr_next;  
		user_addr_t         pr_base;    
		user_size_t         pr_size;    
		user_ulong_t    pr_off;         
		user_ulong_t    pr_scale;       
		user_ulong_t    pr_addr;        
		user_ulong_t    pr_ticks;       
	} user_p_prof;
};
struct plimit {
	struct smr_node  pl_node;
	struct rlimit    pl_rlimit[RLIM_NLIMITS];
	os_refcnt_t      pl_refcnt;
};
struct thsc_cpi {
	uint64_t tcpi_instructions;
	uint64_t tcpi_cycles;
};
struct thsc_time_cpi {
	uint64_t ttci_instructions;
	uint64_t ttci_cycles;
	uint64_t ttci_user_time_mach;
	uint64_t ttci_system_time_mach;
};
struct thsc_time_energy_cpi {
	uint64_t ttec_instructions;
	uint64_t ttec_cycles;
	uint64_t ttec_user_time_mach;
	uint64_t ttec_system_time_mach;
	uint64_t ttec_energy_nj;
};
struct _iopol_param_t {
	int iop_scope;  
	int iop_iotype;
	int iop_policy;
};
struct sbuf {
	char            *s_buf;         
	void            *s_unused;      
	int              s_size;        
	int              s_len;         
	int              s_flags;       
};
struct sdt_probedesc {
	char                    *sdpd_name;     
	int                     sdpd_namelen;
	char                    *sdpd_func;     
	const char              *sdpd_prov;     
	unsigned long           sdpd_offset;    
	struct sdt_probedesc    *sdpd_next;     
} sdt_probedesc_t;
struct module {
	int sdt_nprobes;
	sdt_probedesc_t *sdt_probes;
};
struct sdt_provider {
	const char                      *sdtp_name;     
	const char                      *sdtp_prefix;   
	dtrace_pattr_t          *sdtp_attr;     
	dtrace_provider_id_t    sdtp_id;        
} sdt_provider_t;
struct sdt_probe {
	sdt_provider_t  *sdp_provider;          
	char            *sdp_name;              
	int             sdp_namelen;            
	dtrace_id_t     sdp_id;                 
	struct modctl   *sdp_ctl;               
	int             sdp_loadcnt;            
	int             sdp_primary;            
	sdt_instr_t     *sdp_patchpoint;        
	sdt_instr_t     sdp_patchval;           
	sdt_instr_t     sdp_savedval;           
	struct sdt_probe *sdp_next;             
	struct sdt_probe *sdp_hashnext;         
} sdt_probe_t;
struct sdt_argdesc {
	const char *sda_provider;               
	const char *sda_name;                   
	const int sda_ndx;                      
	const int sda_mapping;                  
	const char *sda_native;                 
	const char *sda_xlate;                  
} sdt_argdesc_t;
struct selinfo {
	union {
		struct  waitq si_waitq; 
		uint8_t si_waitq_storage[WQ_OPAQUE_SIZE]; 
	};
	struct  klist si_note;          
	u_int   si_flags;               
};
struct sem {
	unsigned short  semval;         
	pid_t           sempid;         
	unsigned short  semncnt;        
	unsigned short  semzcnt;        
};
struct sembuf {
	unsigned short  sem_num;        
	short           sem_op;         
	short           sem_flg;        
};
struct user_semid_ds {
	struct ipc_perm sem_perm;       
	struct sem      *sem_base;      
	unsigned short  sem_nsems;      
	user_time_t     sem_otime;      
	__int32_t       sem_pad1;       
	user_time_t     sem_ctime;      
	                                
	                                
	__int32_t       sem_pad2;       
	__int32_t       sem_pad3[4];    
};
struct user64_semid_ds {
	struct ipc_perm sem_perm;       
	int32_t sem_base;       
	unsigned short  sem_nsems;      
	user64_time_t   sem_otime;      
	int32_t sem_pad1;       
	user64_time_t   sem_ctime;      
	                                
	                                
	int32_t sem_pad2;       
	int32_t sem_pad3[4];    
};
struct user32_semid_ds {
	struct ipc_perm sem_perm;       
	int32_t sem_base;       
	unsigned short  sem_nsems;      
	user32_time_t   sem_otime;      
	int32_t sem_pad1;       
	user32_time_t   sem_ctime;      
	                                
	                                
	int32_t sem_pad2;       
	int32_t sem_pad3[4];    
};
struct sem_undo {
	int     un_next_idx;    
	struct  proc *un_proc;          
	short   un_cnt;                 
	struct undo {
		short   une_adjval;     
		short   une_num;        
		int     une_id;         
		struct undo *une_next;  
	} *un_ent;                      
};
struct seminfo {
	int     semmap,         
	    semmni,             
	    semmns,             
	    semmnu,             
	    semmsl,             
	    semopm,             
	    semume,             
	    semusz,             
	    semvmx,             
	    semaem;             
};
struct semid_kernel {
	struct  user_semid_ds u;
	struct  label *label;   
};
struct user_shmid_ds {
	struct ipc_perm shm_perm;       
	user_size_t     shm_segsz;      
	pid_t           shm_lpid;       
	pid_t           shm_cpid;       
	short           shm_nattch;     
	user_time_t     shm_atime;      
	user_time_t     shm_dtime;      
	user_time_t     shm_ctime;      
	user_addr_t     shm_internal;   
};
struct user32_shmid_ds {
	struct ipc_perm shm_perm;       
	uint32_t        shm_segsz;      
	pid_t           shm_lpid;       
	pid_t           shm_cpid;       
	short           shm_nattch;     
	uint32_t                shm_atime;      
	uint32_t                shm_dtime;      
	uint32_t                shm_ctime;      
	user32_addr_t   shm_internal;   
};
struct shminfo {
	int64_t shmmax;         
	int64_t shmmin;         
	int64_t shmmni;         
	int64_t shmseg;         
	int64_t shmall;         
};
struct shmid_kernel {
	struct user_shmid_ds u;
	struct label *label;    
};
struct user64_sigevent {
	int             sigev_notify;                   
	int             sigev_signo;                    
	union user64_sigval sigev_value;                        
	user64_addr_t   sigev_notify_function;          
	user64_addr_t   sigev_notify_attributes;        
};
struct user32_sigevent {
	int             sigev_notify;                   
	int             sigev_signo;                    
	union user32_sigval sigev_value;                        
	user32_addr_t   sigev_notify_function;          
	user32_addr_t   sigev_notify_attributes;        
};
struct user_sigevent {
	int             sigev_notify;                   
	int             sigev_signo;                    
	union user_sigval sigev_value;                  
	user_addr_t     sigev_notify_function;          
	user_addr_t     sigev_notify_attributes;        
};
struct __siginfo {
	int     si_signo;               
	int     si_errno;               
	int     si_code;                
	pid_t   si_pid;                 
	uid_t   si_uid;                 
	int     si_status;              
	void    *si_addr;               
	union sigval si_value;          
	long    si_band;                
	unsigned long   __pad[7];       
} siginfo_t;
struct user_siginfo {
	int             si_signo;       
	int             si_errno;       
	int             si_code;        
	pid_t           si_pid;         
	uid_t           si_uid;         
	int             si_status;      
	user_addr_t     si_addr;        
	union user_sigval si_value;     
	user_long_t     si_band;        
	user_ulong_t    pad[7];         
} user_siginfo_t;
struct user64_siginfo {
	int             si_signo;       
	int             si_errno;       
	int             si_code;        
	pid_t           si_pid;         
	uid_t           si_uid;         
	int             si_status;      
	user64_addr_t   si_addr;        
	union user64_sigval si_value;   
	user64_long_t   si_band;        
	user64_ulong_t  __pad[7];               
} user64_siginfo_t;
struct user32_siginfo {
	int             si_signo;       
	int             si_errno;       
	int             si_code;        
	pid_t           si_pid;         
	uid_t           si_uid;         
	int             si_status;      
	user32_addr_t   si_addr;        
	union user32_sigval     si_value;       
	user32_long_t   si_band;        
	user32_ulong_t  __pad[7];               
} user32_siginfo_t;
struct  __sigaction {
	union __sigaction_u __sigaction_u;  
	void    (*sa_tramp)(void *, int, int, siginfo_t *, void *);
	sigset_t sa_mask;               
	int     sa_flags;               
};
struct  sigaction {
	union __sigaction_u __sigaction_u;  
	sigset_t sa_mask;               
	int     sa_flags;               
};
struct  user32_sigaction {
	union __user32_sigaction_u __sigaction_u;  
	sigset_t sa_mask;               
	int     sa_flags;               
};
struct  __user32_sigaction {
	union __user32_sigaction_u __sigaction_u;  
	user32_addr_t sa_tramp;
	sigset_t sa_mask;               
	int     sa_flags;               
};
struct  user64_sigaction {
	union __user64_sigaction_u __sigaction_u;  
	sigset_t sa_mask;               
	int     sa_flags;               
};
struct  __user64_sigaction {
	union __user64_sigaction_u __sigaction_u;  
	user64_addr_t   sa_tramp;       
	sigset_t sa_mask;               
	int     sa_flags;               
};
struct  kern_sigaction {
	union __kern_sigaction_u __sigaction_u;  
	sigset_t sa_mask;               
	int     sa_flags;               
};
struct  __kern_sigaction {
	union __kern_sigaction_u __sigaction_u;  
	user_addr_t     sa_tramp;       
	sigset_t sa_mask;               
	int     sa_flags;               
};
struct  user32_sigaltstack {
	user32_addr_t   ss_sp;          
	user32_size_t   ss_size;        
	int                 ss_flags;   
};
struct  user64_sigaltstack {
	user64_addr_t   ss_sp;          
	user64_size_t   ss_size;        
	int             ss_flags;       
};
struct  kern_sigaltstack {
	user_addr_t     ss_sp;          
	user_size_t     ss_size;        
	int             ss_flags;       
};
struct  sigstack {
	char    *ss_sp;                 
	int     ss_onstack;             
};
struct  linger {
	int     l_onoff;                
	int     l_linger;               
};
struct sockaddr {
	__uint8_t       sa_len;         
	sa_family_t     sa_family;      
	char            sa_data[14];    
};
struct __sockaddr_header {
	__uint8_t           sa_len;
	sa_family_t         sa_family;
};
struct sockaddr_storage {
	__uint8_t       ss_len;         
	sa_family_t     ss_family;      
	char                    __ss_pad1[_SS_PAD1SIZE];
	__int64_t       __ss_align;     
	char                    __ss_pad2[_SS_PAD2SIZE];
};
struct msghdr {
	void            *__sized_by(msg_namelen) msg_name; 
	socklen_t       msg_namelen;    
	struct          iovec *msg_iov; 
	int             msg_iovlen;     
	void            *__sized_by(msg_controllen) msg_control; 
	socklen_t       msg_controllen; 
	int             msg_flags;      
};
struct cmsghdr {
	socklen_t       cmsg_len;       
	int             cmsg_level;     
	int             cmsg_type;      

};
struct data_stats {
	u_int64_t       rxpackets;
	u_int64_t       rxbytes;
	u_int64_t       txpackets;
	u_int64_t       txbytes;
};
struct socket {
	int     so_zone;                
	short   so_type;                
	uint16_t so_protocol;
	int     so_family;
	u_short so_error;               
	u_int32_t so_options;           
	short   so_linger;              
	short   so_state;               
	void    *so_pcb;                
	struct  protosw *so_proto;      
	struct  socket *so_head;        
	TAILQ_HEAD(, socket) so_incomp; 
	TAILQ_HEAD(, socket) so_comp;   
	TAILQ_ENTRY(socket) so_list;    
	short   so_qlen;                
	short   so_incqlen;             
	short   so_qlimit;              
	short   so_timeo;               
	pid_t   so_pgid;                
	u_int32_t so_oobmark;           
	struct sockbuf {
		uint32_t       sb_cc;          
		uint32_t       sb_hiwat;       
		uint32_t       sb_mbcnt;       
		uint32_t       sb_mbmax;       
		uint32_t       sb_ctl;         
		uint32_t       sb_lowat;       
		struct mbuf     *sb_mb;         
		struct mbuf     *sb_mbtail;     
		struct mbuf     *sb_lastrecord; 
		struct socket   *sb_so;         
		struct selinfo  sb_sel;         
		struct timeval  sb_timeo;       
		uint32_t       sb_flags;       
		uint32_t       sb_idealsize;   
		void    (*sb_upcall)(struct socket *, void *arg, int waitf);
		void    *sb_upcallarg;          
		uint32_t       sb_wantlock;    
		uint32_t       sb_waiters;     
		thread_t        sb_cfil_thread; 
		uint32_t       sb_cfil_refs;   
		uint32_t       sb_preconn_hiwat; 
		struct mbuf   *sb_sendhead;
		int            sb_sendoff;
	} so_rcv, so_snd;
	caddr_t so_tpcb;                

	void            (*so_event)(struct socket *, void *, uint32_t);
	void            *so_eventarg;   
	kauth_cred_t    so_cred;        
	so_gen_t so_gencnt;             
	STAILQ_ENTRY(socket) so_cache_ent;      
	caddr_t         so_saved_pcb;           
	u_int64_t       cache_timestamp;        
	uint32_t        so_eventmask;           

	pid_t           last_pid;       
	u_int64_t       last_upid;      

	struct socket_filter_entry *so_filt;    
	u_int32_t       so_flags;               

	u_int32_t       so_flags1;

	uint32_t        so_upcallusecount; 
	int             so_usecount;    
	int             so_retaincnt;
	uint16_t        so_traffic_class;
	int8_t          so_netsvctype;
	uint8_t         so_restrictions;
	thread_t        so_send_filt_thread;

	void    *lock_lr[SO_LCKDBG_MAX];        
	void    *unlock_lr[SO_LCKDBG_MAX];      
	u_int8_t        next_lock_lr;
	u_int8_t        next_unlock_lr;

	u_int16_t       so_pktheadroom; 

	u_int32_t       so_ifdenied_notifies; 

	thread_t        so_background_thread;   
	struct data_stats so_tc_stats[SO_TC_STATS_MAX];
	struct klist    so_klist;               

	struct flow_divert_pcb  *so_fd_pcb;     

	struct soflow_db    *so_flow_db;


	pid_t           e_pid;          
	u_int64_t       e_upid;         
	pid_t           so_rpid;        

	uuid_t          last_uuid;      
	uuid_t          e_uuid;         
	uuid_t          so_vuuid;       
	uuid_t          so_ruuid;       

	uid_t           so_persona_id;  

	int32_t         so_policy_gencnt; 

	u_int64_t       so_extended_bk_start;

	u_int8_t        so_fallback_mode;

	u_int8_t        so_log_seqn;    
	uint8_t         so_mpkl_send_proto;
	uuid_t          so_mpkl_send_uuid;
};
struct xsockbuf {
	u_int32_t       sb_cc;
	u_int32_t       sb_hiwat;
	u_int32_t       sb_mbcnt;
	u_int32_t       sb_mbmax;
	int32_t         sb_lowat;
	short           sb_flags;
	short           sb_timeo;
};
struct xsocket {
	u_int32_t               xso_len;        
	_XSOCKET_PTR(struct socket *) xso_so;   
	short                   so_type;
	short                   so_options;
	short                   so_linger;
	short                   so_state;
	_XSOCKET_PTR(caddr_t)   so_pcb;         
	int                     xso_protocol;
	int                     xso_family;
	short                   so_qlen;
	short                   so_incqlen;
	short                   so_qlimit;
	short                   so_timeo;
	u_short                 so_error;
	pid_t                   so_pgid;
	u_int32_t               so_oobmark;
	struct xsockbuf         so_rcv;
	struct xsockbuf         so_snd;
	uid_t                   so_uid;         
};
struct  xsocket_n {
	u_int32_t               xso_len;        
	u_int32_t               xso_kind;       
	u_int64_t               xso_so;         
	short                   so_type;
	u_int32_t               so_options;
	short                   so_linger;
	short                   so_state;
	u_int64_t               so_pcb;         
	int                     xso_protocol;
	int                     xso_family;
	short                   so_qlen;
	short                   so_incqlen;
	short                   so_qlimit;
	short                   so_timeo;
	u_short                 so_error;
	pid_t                   so_pgid;
	u_int32_t               so_oobmark;
	uid_t                   so_uid;         
	pid_t                   so_last_pid;
	pid_t                   so_e_pid;
	so_gen_t                so_gencnt;
	u_int32_t               so_flags;
	u_int32_t               so_flags1;
	int32_t                 so_usecount;
	int32_t                 so_retaincnt;
	u_int32_t               xso_filter_flags;
};
struct xsockbuf_n {
	u_int32_t               xsb_len;        
	u_int32_t               xsb_kind;       
	u_int32_t               sb_cc;
	u_int32_t               sb_hiwat;
	u_int32_t               sb_mbcnt;
	u_int32_t               sb_mbmax;
	int32_t                 sb_lowat;
	short                   sb_flags;
	short                   sb_timeo;
};
struct xsockstat_n {
	u_int32_t               xst_len;        
	u_int32_t               xst_kind;       
	struct data_stats       xst_tc_stats[SO_TC_STATS_MAX];
};
struct soextbkidlestat {
	u_int32_t       so_xbkidle_maxperproc;
	u_int32_t       so_xbkidle_time;
	u_int32_t       so_xbkidle_rcvhiwat;
	int32_t         so_xbkidle_notsupp;
	int32_t         so_xbkidle_toomany;
	int32_t         so_xbkidle_wantok;
	int32_t         so_xbkidle_active;
	int32_t         so_xbkidle_nocell;
	int32_t         so_xbkidle_notime;
	int32_t         so_xbkidle_forced;
	int32_t         so_xbkidle_resumed;
	int32_t         so_xbkidle_expired;
	int32_t         so_xbkidle_resched;
	int32_t         so_xbkidle_nodlgtd;
	int32_t         so_xbkidle_drained;
};
struct sockopt {
	enum    sopt_dir sopt_dir; 
	int     sopt_level;     
	int     sopt_name;      
	user_addr_t sopt_val;   
	size_t  sopt_valsize;   
	struct  proc *sopt_p;   
};
struct kextcb {
	struct kextcb *e_next;          
	void *e_fcb;                    
	struct NFDescriptor *e_nfd;     
	struct sockif *e_soif;          
	struct sockutil *e_sout;        
};
struct so_procinfo {
	pid_t           spi_pid;
	pid_t           spi_epid;
	uuid_t          spi_uuid;
	uuid_t          spi_euuid;
	int             spi_delegated;
	char            spi_proc_name[MAXCOMLEN + 1];
	char            spi_e_proc_name[MAXCOMLEN + 1];
};
struct recv_msg_elem {
	struct uio *uio;
	struct sockaddr *psa;
	struct mbuf *controlp;
	int which;
	int flags;
};
struct tracker_metadata {
	uint32_t flags;
	char domain[TRACKER_DOMAIN_MAX + 1];
	char domain_owner[TRACKER_DOMAIN_MAX + 1];
} tracker_metadata_t;
struct tracker_metadata_short {
	uint32_t flags;
	char domain[TRACKER_DOMAIN_SHORT_MAX + 1];
	char domain_owner[TRACKER_DOMAIN_SHORT_MAX + 1];
} tracker_metadata_short_t;
struct msghdr_x {
	void            *__sized_by(msg_namelen) msg_name; 
	socklen_t       msg_namelen;    
	struct iovec    *msg_iov;       
	int             msg_iovlen;     
	void            *__sized_by(msg_controllen) msg_control; 
	socklen_t       msg_controllen; 
	int             msg_flags;      
	size_t          msg_datalen;    
};
struct user_msghdr {
	user_addr_t     msg_name;               
	socklen_t       msg_namelen;            
	vm_address_t    msg_iov;                
	int             msg_iovlen;             
	user_addr_t     msg_control;            
	socklen_t       msg_controllen;         
	int             msg_flags;              
};
struct user64_msghdr {
	user64_addr_t   msg_name;               
	socklen_t       msg_namelen;            
	user64_addr_t   msg_iov;                
	int             msg_iovlen;             
	user64_addr_t   msg_control;            
	socklen_t       msg_controllen;         
	int             msg_flags;              
};
struct user32_msghdr {
	user32_addr_t   msg_name;       
	socklen_t       msg_namelen;    
	user32_addr_t   msg_iov;        
	int             msg_iovlen;     
	user32_addr_t   msg_control;    
	socklen_t       msg_controllen; 
	int             msg_flags;      
};
struct user_msghdr_x {
	user_addr_t     msg_name;       
	socklen_t       msg_namelen;    
	vm_address_t    msg_iov;        
	int             msg_iovlen;     
	user_addr_t     msg_control;    
	socklen_t       msg_controllen; 
	int             msg_flags;      
	size_t          msg_datalen;    
};
struct user64_msghdr_x {
	user64_addr_t   msg_name;       
	socklen_t       msg_namelen;    
	user64_addr_t   msg_iov;        
	int             msg_iovlen;     
	user64_addr_t   msg_control;    
	socklen_t       msg_controllen; 
	int             msg_flags;      
	user64_size_t   msg_datalen;    
};
struct user32_msghdr_x {
	user32_addr_t   msg_name;       
	socklen_t       msg_namelen;    
	user32_addr_t   msg_iov;        
	int             msg_iovlen;     
	user32_addr_t   msg_control;    
	socklen_t       msg_controllen; 
	int             msg_flags;      
	user32_size_t   msg_datalen;    
};
struct user_sa_endpoints {
	unsigned int    sae_srcif;      
	user_addr_t     sae_srcaddr;    
	socklen_t       sae_srcaddrlen; 
	user_addr_t     sae_dstaddr;    
	socklen_t       sae_dstaddrlen; 
};
struct user64_sa_endpoints {
	unsigned int    sae_srcif;      
	user64_addr_t   sae_srcaddr;    
	socklen_t       sae_srcaddrlen; 
	user64_addr_t   sae_dstaddr;    
	socklen_t       sae_dstaddrlen; 
};
struct user32_sa_endpoints {
	unsigned int    sae_srcif;      
	user32_addr_t   sae_srcaddr;    
	socklen_t       sae_srcaddrlen; 
	user32_addr_t   sae_dstaddr;    
	socklen_t       sae_dstaddrlen; 
};
struct _ps_port_action {
	pspa_t                  port_type;
	exception_mask_t        mask;
	mach_port_name_t        new_port;
	exception_behavior_t    behavior;
	thread_state_flavor_t   flavor;
	int                     which;
} _ps_port_action_t;
struct _posix_spawn_port_actions {
	int                     pspa_alloc;
	int                     pspa_count;
	_ps_port_action_t       pspa_actions[];
} *_posix_spawn_port_actions_t;
struct _ps_mac_policy_extension {
	char                    policyname[128];
	union {
		
		uint64_t        data;
		
		uint64_t        dataoff;
	};
	uint64_t                datalen;
} _ps_mac_policy_extension_t;
struct _posix_spawn_mac_policy_extensions {
	int                     psmx_alloc;
	int                     psmx_count;
	_ps_mac_policy_extension_t psmx_extensions[];
} *_posix_spawn_mac_policy_extensions_t;
struct _posix_spawn_coalition_info {
	struct {
		uint64_t psci_id;
		uint32_t psci_role;
		uint32_t psci_reserved1;
		uint64_t psci_reserved2;
	} psci_info[COALITION_NUM_TYPES];
};
struct _posix_spawn_posix_cred_info {
	uint32_t pspci_flags;    
	uid_t    pspci_uid;      
	gid_t    pspci_gid;      
	uint32_t pspci_ngroups;  
	gid_t    pspci_groups[NGROUPS];
	uid_t    pspci_gmuid;    
	char     pspci_login[MAXLOGNAME + 1];
};
struct _posix_spawn_persona_info {
	uid_t    pspi_id;       
	uint32_t pspi_flags;    
	uid_t    pspi_uid;      
	gid_t    pspi_gid;      
	uint32_t pspi_ngroups;  
	gid_t    pspi_groups[NGROUPS];
	uid_t    pspi_gmuid;    
};
struct _posix_spawnattr {
	short           psa_flags;              
	short           flags_padding;  
	sigset_t        psa_sigdefault;         
	sigset_t        psa_sigmask;            
	pid_t           psa_pgroup;             
	cpu_type_t      psa_binprefs[NBINPREFS];   
	int             psa_pcontrol;           
	int             psa_apptype;            
	uint64_t        psa_cpumonitor_percent; 
	uint64_t        psa_cpumonitor_interval; 
	uint64_t        psa_reserved;

	short       psa_jetsam_flags;           
	short           short_padding;          
	int         psa_priority;               
	int         psa_memlimit_active;        
	int         psa_memlimit_inactive;      

	uint64_t        psa_qos_clamp;          
	task_role_t     psa_darwin_role;           
	int             psa_thread_limit;       

	uint64_t        psa_max_addr;           
	bool            psa_no_smt;
	bool            psa_tecs;
	int             psa_platform;           

	cpu_subtype_t      psa_subcpuprefs[NBINPREFS];   
	uint32_t        psa_options;             
	uint32_t        psa_port_soft_limit;     
	uint32_t        psa_port_hard_limit;     
	uint32_t        psa_filedesc_soft_limit; 
	uint32_t        psa_filedesc_hard_limit; 
	uint32_t        psa_crash_behavior;      
	int             psa_dataless_iopolicy;   
	uint64_t        psa_crash_behavior_deadline; 
	uint8_t         psa_launch_type;         
	uint16_t        psa_sec_flags;           

	uint32_t        psa_crash_count;
	uint32_t        psa_throttle_timeout;

	uint32_t        psa_kqworkloop_soft_limit; 
	uint32_t        psa_kqworkloop_hard_limit; 

	_posix_spawn_port_actions_t    psa_ports;  
	_posix_spawn_mac_policy_extensions_t psa_mac_extensions; 
	struct _posix_spawn_coalition_info *psa_coalition_info;  
	struct _posix_spawn_persona_info   *psa_persona_info;    
	struct _posix_spawn_posix_cred_info *psa_posix_cred_info; 
	char                                *psa_subsystem_root_path; 
	char                                *psa_conclave_id;         
} *_posix_spawnattr_t;
struct _psfa_action {
	psfa_t  psfaa_type;                         
	union {
		int psfaa_filedes;                  
		mach_port_name_t psfaa_fileport;    
	};
	union {
		struct {
			int     psfao_oflag;            
			mode_t  psfao_mode;             
			char    psfao_path[PATH_MAX];   
		} psfaa_openargs;
		struct {
			int psfad_newfiledes;           
		} psfaa_dup2args;
		struct {
			char    psfac_path[PATH_MAX];   
		} psfaa_chdirargs;
	};
} _psfa_action_t;
struct _posix_spawn_file_actions {
	int             psfa_act_alloc;         
	int             psfa_act_count;         
	_psfa_action_t  psfa_act_acts[];        
} *_posix_spawn_file_actions_t;
struct _posix_spawn_args_desc {
	__darwin_size_t         attr_size;      
	_posix_spawnattr_t      attrp;          
	__darwin_size_t file_actions_size;      
	_posix_spawn_file_actions_t
	    file_actions;                       
	__darwin_size_t port_actions_size;      
	_posix_spawn_port_actions_t
	    port_actions;                       
	__darwin_size_t mac_extensions_size;
	_posix_spawn_mac_policy_extensions_t
	    mac_extensions;                     
	__darwin_size_t coal_info_size;
	struct _posix_spawn_coalition_info *coal_info;  

	__darwin_size_t persona_info_size;
	struct _posix_spawn_persona_info   *persona_info;

	__darwin_size_t posix_cred_info_size;
	struct _posix_spawn_posix_cred_info *posix_cred_info;

	__darwin_size_t subsystem_root_path_size;
	char *subsystem_root_path;

	__darwin_size_t conclave_id_size;
	char *conclave_id;
};
struct user32__posix_spawn_args_desc {
	uint32_t        attr_size;              
	uint32_t        attrp;                  
	uint32_t        file_actions_size;      
	uint32_t        file_actions;           
	uint32_t        port_actions_size;      
	uint32_t        port_actions;           
	uint32_t        mac_extensions_size;
	uint32_t        mac_extensions;
	uint32_t        coal_info_size;
	uint32_t        coal_info;
	uint32_t        persona_info_size;
	uint32_t        persona_info;
	uint32_t        posix_cred_info_size;
	uint32_t        posix_cred_info;
	uint32_t        subsystem_root_path_size;
	uint32_t        subsystem_root_path;
	uint32_t        conclave_id_size;
	uint32_t        conclave_id;
};
struct user__posix_spawn_args_desc {
	user_size_t     attr_size;              
	user_addr_t     attrp;                  
	user_size_t     file_actions_size;      
	user_addr_t     file_actions;           
	user_size_t     port_actions_size;      
	user_addr_t     port_actions;           
	user_size_t     mac_extensions_size;    
	user_addr_t     mac_extensions;         
	user_size_t     coal_info_size;
	user_addr_t     coal_info;
	user_size_t     persona_info_size;
	user_addr_t     persona_info;
	user_size_t     posix_cred_info_size;
	user_addr_t     posix_cred_info;
	user_size_t     subsystem_root_path_size;
	user_addr_t     subsystem_root_path;
	user_size_t     conclave_id_size;
	user_addr_t     conclave_id;
};
struct stackshot_config {
	int             sc_pid;                 
	uint64_t        sc_flags;               
	uint64_t        sc_delta_timestamp;     

	uint64_t        sc_buffer;              
	uint32_t        sc_size;                

	uint64_t        sc_out_buffer_addr;     
	uint64_t        sc_out_size_addr;       
	uint64_t                sc_pagetable_mask;      
} stackshot_config_t;
struct stackshot_stats {
	uint64_t        ss_last_start;          
	uint64_t        ss_last_end;            
	uint64_t        ss_count;               
	uint64_t        ss_duration;            
} stackshot_stats_t;
struct user64_stat {
	dev_t           st_dev;         
	ino_t           st_ino;         
	mode_t          st_mode;        
	nlink_t         st_nlink;       
	uid_t           st_uid;         
	gid_t           st_gid;         
	dev_t           st_rdev;        
	off_t           st_size;        
	blkcnt_t        st_blocks;      
	blksize_t       st_blksize;     
	__uint32_t      st_flags;       
	__uint32_t      st_gen;         
	__int32_t       st_lspare;      
	__int64_t       st_qspare[2];   
};
struct user32_stat {
	dev_t           st_dev;         
	ino_t           st_ino;         
	mode_t          st_mode;        
	nlink_t         st_nlink;       
	uid_t           st_uid;         
	gid_t           st_gid;         
	dev_t           st_rdev;        
	off_t           st_size;        
	blkcnt_t        st_blocks;      
	blksize_t       st_blksize;     
	__uint32_t      st_flags;       
	__uint32_t      st_gen;         
	__int32_t       st_lspare;      
	__int64_t       st_qspare[2];   
};
struct user64_stat64 {
	dev_t           st_dev;                                 
	mode_t          st_mode;                                
	nlink_t         st_nlink;                               
	ino64_t         st_ino;                                 
	uid_t           st_uid;                                 
	gid_t           st_gid;                                 
	dev_t           st_rdev;                                
	struct user64_timespec st_atimespec;            
	struct user64_timespec st_mtimespec;            
	struct user64_timespec st_ctimespec;            
	struct user64_timespec st_birthtimespec;        
	off_t           st_size;                                
	blkcnt_t        st_blocks;                              
	blksize_t       st_blksize;                             
	__uint32_t      st_flags;                               
	__uint32_t      st_gen;                                 
	__uint32_t      st_lspare;                              
	__int64_t       st_qspare[2];                   
};
struct ctlname {
	char    *ctl_name;      
	int     ctl_type;       
};
struct sysctl_req {
	struct proc     *p;
	int             lock;
	user_addr_t     oldptr;         
	size_t          oldlen;         
	size_t          oldidx;         
	int             (*oldfunc)(struct sysctl_req *, const void *, size_t);
	user_addr_t     newptr;         
	size_t          newlen;         
	size_t          newidx;         
	int             (*newfunc)(struct sysctl_req *, void *, size_t);
};
struct sysctl_oid {
	struct sysctl_oid_list * OS_PTRAUTH_SIGNED_PTR("sysctl_oid.oid_parent") oid_parent;
	SLIST_ENTRY(sysctl_oid) oid_link;
	int             oid_number;
	int             oid_kind;
	void            *oid_arg1;
	int             oid_arg2;
	const char      *oid_name;
	int             (*oid_handler)SYSCTL_HANDLER_ARGS;
	const char      *oid_fmt;
	const char      *oid_descr; 
	int             oid_version;
	int             oid_refcnt;
};
struct experiment_spec {
	void *ptr; 
	uint64_t min_value; 
	uint64_t max_value; 
	uint64_t original_value; 
	_Atomic bool modified; 
};
struct user32_pcred {
	char          pc_lock[72];    
	user32_addr_t pc_ucred;       
	uid_t         p_ruid;         
	uid_t         p_svuid;        
	gid_t         p_rgid;         
	gid_t         p_svgid;        
	int           p_refcnt;       
};
struct user64_pcred {
	char          pc_lock[72];      
	user64_addr_t pc_ucred;         
	uid_t         p_ruid;           
	uid_t         p_svuid;          
	gid_t         p_rgid;           
	gid_t         p_svgid;          
	int           p_refcnt;         
};
struct user32_kinfo_proc {
	struct  user32_extern_proc kp_proc;     
	struct  user32_eproc {
		user32_addr_t e_paddr;          
		user32_addr_t e_sess;                   
		struct  user32_pcred e_pcred;           
		struct  _ucred e_ucred;         
		struct  user32_vmspace e_vm; 
		pid_t   e_ppid;                 
		pid_t   e_pgid;                 
		int     e_jobc;                 
		dev_t   e_tdev;                 
		pid_t   e_tpgid;                
		user32_addr_t   e_tsess;        
		char    e_wmesg[WMESGLEN + 1];    
		segsz_t e_xsize;                
		short   e_xrssize;              
		short   e_xccount;              
		short   e_xswrss;
		int32_t e_flag;
		char    e_login[COMAPT_MAXLOGNAME];     
		int32_t e_spare[4];
	} kp_eproc;
};
struct user64_kinfo_proc {
	struct  user64_extern_proc kp_proc;     
	struct  user64_eproc {
		user_addr_t e_paddr;            
		user_addr_t e_sess;                     
		struct  user64_pcred e_pcred;           
		struct  _ucred e_ucred;         
		struct   user_vmspace e_vm; 
		pid_t   e_ppid;                 
		pid_t   e_pgid;                 
		int     e_jobc;                 
		dev_t   e_tdev;                 
		pid_t   e_tpgid;                
		user64_addr_t   e_tsess __attribute((aligned(8)));      
		char    e_wmesg[WMESGLEN + 1];    
		segsz_t e_xsize;                
		short   e_xrssize;              
		short   e_xccount;              
		short   e_xswrss;
		int32_t e_flag;
		char    e_login[COMAPT_MAXLOGNAME];     
		int32_t e_spare[4];
	} kp_eproc;
};
struct xsw_usage {
	u_int64_t       xsu_total;
	u_int64_t       xsu_avail;
	u_int64_t       xsu_used;
	u_int32_t       xsu_pagesize;
	boolean_t       xsu_encrypted;
};
struct loadavg {
	fixpt_t ldavg[3];
	long    fscale;
};
struct user32_loadavg {
	fixpt_t ldavg[3];
	user32_long_t       fscale;
};
struct user64_loadavg {
	fixpt_t ldavg[3];
	user64_long_t       fscale;
};
struct sysent {         
	sy_call_t       *sy_call;       
	int32_t         sy_return_type; 
	int16_t         sy_narg;        
	uint16_t        sy_arg_bytes;   
};
struct sockaddr_sys {
	u_char          ss_len;         
	u_char          ss_family;      
	u_int16_t       ss_sysaddr;     
	u_int32_t       ss_reserved[7]; 
};
struct  xsystmgen {
	u_int32_t       xg_len; 
	u_int64_t       xg_count;       
	u_int64_t       xg_gen; 
	u_int64_t       xg_sogen;       
};
struct termios {
	tcflag_t        c_iflag;        
	tcflag_t        c_oflag;        
	tcflag_t        c_cflag;        
	tcflag_t        c_lflag;        
	cc_t            c_cc[NCCS];     
	speed_t         c_ispeed;       
	speed_t         c_ospeed;       
};
struct user_termios {
	user_tcflag_t   c_iflag;        
	user_tcflag_t   c_oflag;        
	user_tcflag_t   c_cflag;        
	user_tcflag_t   c_lflag;        
	cc_t            c_cc[NCCS];     
	user_speed_t    c_ispeed __attribute((aligned(8)));     
	user_speed_t    c_ospeed;       
};
struct termios32 {
	__uint32_t      c_iflag;        
	__uint32_t      c_oflag;        
	__uint32_t      c_cflag;        
	__uint32_t      c_lflag;        
	cc_t            c_cc[NCCS];     
	__uint32_t      c_ispeed;       
	__uint32_t      c_ospeed;       
};
struct timeb {
	time_t          time;           
	unsigned short  millitm;        
	short           timezone;       
	short           dstflag;        
};
struct tms {
	clock_t tms_utime;      
	clock_t tms_stime;      
	clock_t tms_cutime;     
	clock_t tms_cstime;     
};
struct ntptimeval {
	struct timespec time;           
	long maxerror;                  
	long esterror;                  
	long tai;                       
	int time_state;                 
};
struct timex {
	unsigned int modes;             
	long    offset;                 
	long    freq;                   
	long    maxerror;               
	long    esterror;               
	int     status;                 
	long    constant;               
	long    precision;              
	long    tolerance;              
	long    ppsfreq;                
	long    jitter;                 
	int     shift;                  
	long    stabil;                 
	long    jitcnt;                 
	long    calcnt;                 
	long    errcnt;                 
	long    stbcnt;                 
};
struct DTTrustCacheRange {
	vm_offset_t paddr;
	size_t length;
} DTTrustCacheRange;
struct _trust_cache_offsets {
	uint32_t num_caches;

	uint32_t offsets[0];
} __attribute__((__packed__)) trust_cache_offsets_t;
struct clist {
	int     c_cc;           
	int     c_cn;           
	u_char  *c_cf;          
	u_char  *c_cl;          
	u_char  *c_cs;          
	u_char  *c_ce;          
	u_char  *c_cq;          
};
struct tty {
	lck_mtx_t       t_lock;         

	struct  clist t_rawq;           
	long    t_rawcc;                
	struct  clist t_canq;           
	long    t_cancc;                
	struct  clist t_outq;           
	long    t_outcc;                
	int     t_line;                 
	dev_t   t_dev;                  
	int     t_state;                
	int     t_flags;                
	int     t_timeout;              
	struct  pgrp *t_pgrp;           
	struct  session *t_session;     
	struct  selinfo t_rsel;         
	struct  selinfo t_wsel;         
	struct  termios t_termios;      
	struct  winsize t_winsize;      
	                                
	void    (*t_oproc)(struct tty *);
	void    (*t_stop)(struct tty *, int);
	int     (*t_param)(struct tty *, struct termios *);
	void    *t_sc;                  
	int     t_column;               
	int     t_rocount, t_rocol;     
	int     t_hiwat;                
	int     t_lowat;                
	int     t_gen;                  
	void    *t_iokit;               
	os_ref_atomic_t t_refcnt;
	thread_t t_locked_thread;       
};
struct speedtab {
	int sp_speed;
	int sp_code;
};
struct winsize {
	unsigned short  ws_row;         
	unsigned short  ws_col;         
	unsigned short  ws_xpixel;      
	unsigned short  ws_ypixel;      
};
struct cl_extent {
	daddr64_t       b_addr;
	daddr64_t       e_addr;
};
struct cl_wextent {
	daddr64_t       b_addr;
	daddr64_t       e_addr;
	int             io_flags;
};
struct cl_readahead {
	lck_mtx_t       cl_lockr;
	daddr64_t       cl_lastr;                       
	daddr64_t       cl_maxra;                       
	int             cl_ralen;                       
};
struct cl_writebehind {
	lck_mtx_t       cl_lockw;
	void    *       cl_scmap;                       
	off_t           cl_last_write;                  
	off_t           cl_seq_written;                 
	int             cl_sparse_pushes;               
	int             cl_sparse_wait;                 
	int             cl_number;                      
	struct cl_wextent cl_clusters[MAX_CLUSTERS];    
};
struct cs_blob {
	struct cs_blob  *csb_next;
	vnode_t         csb_vnode;
	void            *csb_ro_addr;
	__xnu_struct_group(cs_cpu_info, csb_cpu_info, {
		cpu_type_t      csb_cpu_type;
		cpu_subtype_t   csb_cpu_subtype;
	});
	__xnu_struct_group(cs_signer_info, csb_signer_info, {
		unsigned int    csb_flags;
		unsigned int    csb_signer_type;
	});
	off_t           csb_base_offset;        
	off_t           csb_start_offset;       
	off_t           csb_end_offset;         
	vm_size_t       csb_mem_size;
	vm_offset_t     csb_mem_offset;
	void            *csb_mem_kaddr;
	unsigned char   csb_cdhash[CS_CDHASH_LEN];
	const struct cs_hash  *csb_hashtype;
	int             csb_hash_pageshift;
	int             csb_hash_firstlevel_pageshift;   
	const CS_CodeDirectory *csb_cd;
	const char      *csb_teamid;
	const CS_GenericBlob *csb_entitlements_blob;    
	const CS_GenericBlob *csb_der_entitlements_blob;    

	void *XNU_PTRAUTH_SIGNED_PTR("cs_blob.csb_entitlements") csb_entitlements;

	unsigned int    csb_reconstituted;      
	__xnu_struct_group(cs_blob_platform_flags, csb_platform_flags, {
		
		unsigned int    csb_platform_binary:1;
		unsigned int    csb_platform_path:1;
	});

	unsigned int    csb_validation_category;

	uint64_t    csb_auxiliary_info;

};
struct ubc_info {
	memory_object_t         ui_pager;       
	memory_object_control_t ui_control;     
	vnode_t                 XNU_PTRAUTH_SIGNED_PTR("ubc_info.ui_vnode") ui_vnode;       
	kauth_cred_t            ui_ucred;       
	off_t                   ui_size;        
	uint32_t                ui_flags;       
	uint32_t                cs_add_gen;     

	struct  cl_readahead   *cl_rahead;      
	struct  cl_writebehind *cl_wbehind;     

	struct timespec         cs_mtime;       
	struct  cs_blob         * XNU_PTRAUTH_SIGNED_PTR("ubc_info.cs_blob") cs_blobs; 
};
struct user_ucontext64 {
	int                             uc_onstack;
	sigset_t                        uc_sigmask;     
	struct user64_sigaltstack       uc_stack;       
	user_addr_t                     uc_link;        
	user_size_t                     uc_mcsize;      
	user_addr_t                     uc_mcontext64;  
} user_ucontext64_t;
struct user_ucontext32 {
	int                             uc_onstack;
	sigset_t                        uc_sigmask;     
	struct user32_sigaltstack       uc_stack;       
	user32_addr_t                   uc_link;        
	user32_size_t                   uc_mcsize;      
	user32_addr_t                   uc_mcontext;    
} user_ucontext32_t;
struct kern_iovec {
	u_int64_t       iov_base;       
	u_int64_t       iov_len;        
};
struct user_iovec {
	user_addr_t     iov_base;       
	user_size_t     iov_len;        
};
struct user32_iovec {
	uint32_t        iov_base;       
	uint32_t        iov_len;        
};
struct user64_iovec {
	uint64_t        iov_base;       
	uint64_t        iov_len;        
};
struct uio {
	void * XNU_PTRAUTH_SIGNED_PTR("uio.uio_iovs") uio_iovs;       
	void * XNU_PTRAUTH_SIGNED_PTR("uio.uio_iovbase") uio_iovbase; 
	int             uio_max_iovs;   
	int             uio_iovcnt;     
	off_t           uio_offset;
	enum uio_seg    uio_segflg;
	enum uio_rw     uio_rw;
	user_size_t     uio_resid_64;
	u_int32_t       uio_flags;
};
struct  sockaddr_un {
	unsigned char   sun_len;        
	sa_family_t     sun_family;     
	char            sun_path[104];  
};
struct _unpcb_list_entry {
	u_int32_t   le_next;
	u_int32_t   le_prev;
};
struct  unpcb_compat {
	_UNPCB_LIST_ENTRY(unpcb_compat) unp_link;       
	_UNPCB_PTR(struct socket *)     unp_socket;     
	_UNPCB_PTR(struct vnode *)      unp_vnode;      
	u_int32_t                       unp_ino;        
	_UNPCB_PTR(struct unpcb_compat *) unp_conn;     
	u_int32_t                       unp_refs;
	_UNPCB_LIST_ENTRY(unpcb_compat) unp_reflink;    
	_UNPCB_PTR(struct sockaddr_un *) unp_addr;      
	int                             unp_cc;         
	int                             unp_mbcnt;      
	unp_gen_t                       unp_gencnt;     
};
struct  xunpgen {
	u_int32_t       xug_len;
	u_int           xug_count;
	unp_gen_t       xug_gen;
	so_gen_t        xug_sogen;
};
struct uthread {
	u_int64_t uu_arg[8]; 
	int uu_rval[2];
	char uu_cursig; 
	bool uu_workq_pthread_kill_allowed;
	uint16_t syscall_code; 

	int     uu_exception;
	mach_exception_code_t uu_code;  
	mach_exception_subcode_t uu_subcode;

	union {
		struct _select_data {
			u_int64_t abstime;
			int count;
			struct select_nocancel_args *args;  
			int32_t *retval;                    
		} uus_select_data;

		struct kevent_ctx_s uus_kevent;

		struct _kevent_register {
			struct kevent_qos_s kev;            
			thread_t handoff_thread;            
			struct kqworkloop *kqwl;
			int eventout;                       
			user_addr_t ueventlist;             
		} uus_kevent_register;                   

		struct _kauth {
			user_addr_t message;                
		} uus_kauth;

		struct ksyn_waitq_element uus_kwe;       

		struct _waitid_data {
			struct waitid_nocancel_args *args;  
			int32_t *retval;                    
		} uus_waitid_data;

		struct _wait4_data {
			struct wait4_nocancel_args *args;   
			int32_t *retval;                    
		} uus_wait4_data;

		struct _workq_park_data {
			uint64_t idle_stamp;
			uint64_t workloop_params;
			uint32_t fulfilled_snapshot;
			uint32_t yields;
			void *thread_request;                
			uint32_t upcall_flags;
			bool has_stack;
			thread_qos_t qos;
		} uus_workq_park_data;                   

		struct _ulock_wait_data {
			struct ull *ull;
			thread_t owner_thread;
			thread_t old_owner;
			int32_t *retval;
			uint flags;
		} uus_ulock_wait_data;

		struct _bsdthread_terminate {
			user_addr_t      ulock_addr;
			mach_port_name_t kport;
		} uus_bsdthread_terminate;

		struct _exec_data {
			struct image_params *imgp;
		} uus_exec_data;
	} uu_save;

	struct _select {
		
		u_int32_t * XNU_PTRAUTH_SIGNED_PTR("uthread.uu_select.ibits") ibits;
		u_int32_t * XNU_PTRAUTH_SIGNED_PTR("uthread.uu_select.obits") obits;
		uint    nbytes; 
	} uu_select;                    

	void * uu_userstate;
	struct select_set *uu_selset;            
	int uu_flag;
	sigset_t uu_siglist;                            
	sigset_t uu_sigwait;                            
	sigset_t uu_sigmask;                            
	sigset_t uu_oldmask;                            
	user_addr_t uu_sigreturn_token;                 
	uint32_t uu_sigreturn_diversifier;              
	int uu_pending_sigreturn;                       

	TAILQ_ENTRY(uthread) uu_list;       

	struct kaudit_record    *uu_ar;                 
	struct task    *uu_aio_task;                    

	union {
		lck_mtx_t  *uu_mtx;
		struct knote_lock_ctx *uu_knlock;
	};

	lck_spin_t      uu_rethrottle_lock;     
	TAILQ_ENTRY(uthread) uu_throttlelist;   
	void    *       uu_throttle_info;       
	int8_t          uu_on_throttlelist;
	bool            uu_lowpri_window;
	bool            uu_was_rethrottled;
	bool            uu_is_throttled;
	bool            uu_throttle_bc;
	bool            uu_defer_reclaims;

	uint16_t uu_pri;                        
	caddr_t uu_wchan;                       
	int (*uu_continuation)(int);
	const char *uu_wmesg;                   

	struct kern_sigaltstack uu_sigstk;
	vnode_t         uu_vreclaims;
	vnode_t         uu_cdir;                
	int             uu_dupfd;               

	u_int32_t       uu_network_marks;       

	struct workq_threadreq_s *uu_kqr_bound;
	TAILQ_ENTRY(uthread) uu_workq_entry;
	vm_offset_t uu_workq_stackaddr;
	mach_port_name_t uu_workq_thport;
	struct uu_workq_policy {
		
		uint16_t qos_req : 4;
		
		uint16_t qos_max : 4;
		
		uint16_t qos_override : 4;
		
		uint16_t qos_bucket : 4;
	} uu_workq_pri;

	uint16_t uu_workq_flags;
	kq_index_t uu_kqueue_override;

	int             uu_proc_refcount;

	uint32_t        t_dtrace_errno; 
	siginfo_t       t_dtrace_siginfo;
	uint64_t        t_dtrace_resumepid; 
	uint8_t         t_dtrace_stop;  
	uint8_t         t_dtrace_sig;   

	union __tdu {
		struct __tds {
			uint8_t _t_dtrace_on;   
			uint8_t _t_dtrace_step; 
			uint8_t _t_dtrace_ret;  
			uint8_t _t_dtrace_ast;  
			uint8_t _t_dtrace_reg;  
		} _tds;
		u_int32_t _t_dtrace_ft;           
	} _tdu;

	user_addr_t     t_dtrace_pc;    
	user_addr_t     t_dtrace_npc;   
	user_addr_t     t_dtrace_scrpc; 
	user_addr_t     t_dtrace_astpc; 

	struct dtrace_ptss_page_entry*  t_dtrace_scratch; 

	uint64_t        t_dtrace_regv;  
	void *t_dtrace_syscall_args;
	char *pth_name;

	struct doc_tombstone *t_tombstone;

	uint64_t t_fs_private;

	struct os_reason *uu_exit_reason;

};
struct  user {
};
struct  utsname {
	char    sysname[_SYS_NAMELEN];  
	char    nodename[_SYS_NAMELEN]; 
	char    release[_SYS_NAMELEN];  
	char    version[_SYS_NAMELEN];  
	char    machine[_SYS_NAMELEN];  
};
struct vmspace {
	int     vm_refcnt;      
	caddr_t vm_shm;         

	segsz_t vm_rssize;      
	segsz_t vm_swrss;       
	segsz_t vm_tsize;       
	segsz_t vm_dsize;       
	segsz_t vm_ssize;       
	caddr_t vm_taddr;       
	caddr_t vm_daddr;       
	caddr_t vm_maxsaddr;    
};
struct user32_vmspace {
	int             vm_refcnt;      
	uint32_t        vm_shm;                 
	segsz_t         vm_rssize;              
	segsz_t         vm_swrss;               
	segsz_t         vm_tsize;               
	segsz_t         vm_dsize;               
	segsz_t         vm_ssize;               
	uint32_t        vm_taddr;       
	uint32_t        vm_daddr;       
	uint32_t vm_maxsaddr;   
};
struct user_vmspace {
	int             vm_refcnt;      
	user_addr_t     vm_shm __attribute((aligned(8)));                       
	segsz_t         vm_rssize;              
	segsz_t         vm_swrss;               
	segsz_t         vm_tsize;               
	segsz_t         vm_dsize;               
	segsz_t         vm_ssize;               
	user_addr_t     vm_taddr __attribute((aligned(8)));       
	user_addr_t     vm_daddr;       
	user_addr_t vm_maxsaddr;        
};
struct componentname {
	uint32_t        cn_nameiop;     
	uint32_t        cn_flags;       
	vfs_context_t   cn_context;
	struct nameidata *cn_ndp;       



	char    *cn_pnbuf;      
	int     cn_pnlen;       
	char    *cn_nameptr;    
	int     cn_namelen;     
	uint32_t        cn_hash;        
	uint32_t        cn_consume;     
};
struct vnode_fsparam {
	struct mount * vnfs_mp;         
	enum vtype      vnfs_vtype;             
	const char * vnfs_str;          
	struct vnode * vnfs_dvp;                        
	void * vnfs_fsnode;                     
	int(**vnfs_vops)(void *);               
	int vnfs_markroot;                      
	int vnfs_marksystem;            
	dev_t vnfs_rdev;                        
	off_t vnfs_filesize;            
	struct componentname * vnfs_cnp; 
	uint32_t vnfs_flags;            
};
struct vnode_trigger_info {
	trigger_vnode_resolve_callback_t        vti_resolve_func;
	trigger_vnode_unresolve_callback_t      vti_unresolve_func;
	trigger_vnode_rearm_callback_t          vti_rearm_func;
	trigger_vnode_reclaim_callback_t        vti_reclaim_func;
	void *                                  vti_data;   
	uint32_t                                vti_flags;  
};
struct vnode_trigger_param {
	struct vnode_fsparam                    vnt_params; 
	trigger_vnode_resolve_callback_t        vnt_resolve_func;
	trigger_vnode_unresolve_callback_t      vnt_unresolve_func;
	trigger_vnode_rearm_callback_t          vnt_rearm_func;
	trigger_vnode_reclaim_callback_t        vnt_reclaim_func;
	void *                                  vnt_data;   
	uint32_t                                vnt_flags;  
};
struct vnode_attr {
	uint64_t        va_supported;
	uint64_t        va_active;

	int             va_vaflags;

	dev_t           va_rdev;        
	uint64_t        va_nlink;       
	uint64_t        va_total_size;  
	uint64_t        va_total_alloc; 
	uint64_t        va_data_size;   
	uint64_t        va_data_alloc;  
	uint32_t        va_iosize;      

	uid_t           va_uid;         
	gid_t           va_gid;         
	mode_t          va_mode;        
	uint32_t        va_flags;       
	struct kauth_acl *va_acl;       

	struct timespec va_create_time; 
	struct timespec va_access_time; 
	struct timespec va_modify_time; 
	struct timespec va_change_time; 
	struct timespec va_backup_time; 

	uint64_t        va_fileid;      
	uint64_t        va_linkid;      
	uint64_t        va_parentid;    
	uint32_t        va_fsid;        
	uint64_t        va_filerev;     	
	uint32_t        va_gen;         	
	uint32_t        va_encoding;    

	enum vtype      va_type;        
	char *          va_name;        
	guid_t          va_uuuid;       
	guid_t          va_guuid;       

	uint64_t        va_nchildren;     
	uint64_t        va_dirlinkcount;  

	struct kauth_acl *va_base_acl;
	struct timespec va_addedtime;   

	uint32_t va_dataprotect_class;  
	uint32_t va_dataprotect_flags;  

	uint32_t va_document_id;

	uint32_t        va_devid;       
	uint32_t        va_objtype;     
	uint32_t        va_objtag;      
	uint32_t        va_user_access; 
	uint8_t         va_finderinfo[32];      
	uint64_t        va_rsrc_length; 
	uint64_t        va_rsrc_alloc;  
	fsid_t          va_fsid64;      

	uint32_t va_write_gencount;     

	uint64_t va_private_size; 
	uint64_t va_clone_id;     
	uint64_t va_extflags;     
	uint64_t va_recursive_gencount; 
	uint64_t va_attribution_tag;    
	uint32_t va_clone_refcnt;       

};
struct vnodeopv_entry_desc {
	struct vnodeop_desc *opve_op;   
	int (*opve_impl)(void *);               
};
struct vnodeopv_desc {
	int(***opv_desc_vector_p)(void *);
	const struct vnodeopv_entry_desc *opv_desc_ops;   
};
struct vnop_generic_args {
	struct vnodeop_desc *a_desc;
};
struct io_compression_stats {
	uint64_t uncompressed_size;
	uint64_t compressed_size;
	uint32_t buffer_size_compression_dist[IOCS_BUFFER_NUM_SIZE_BUCKETS][IOCS_BUFFER_NUM_COMPRESSION_BUCKETS];
	uint32_t block_compressed_size_dist[IOCS_BLOCK_NUM_SIZE_BUCKETS];
};
struct iocs_store_buffer_entry {
	char     path_name[IOCS_SBE_PATH_LEN];
	struct io_compression_stats iocs;
};
struct vnop_lookup_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_dvp;
	vnode_t *a_vpp;
	struct componentname *a_cnp;
	vfs_context_t a_context;
};
struct vnop_create_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_dvp;
	vnode_t *a_vpp;
	struct componentname *a_cnp;
	struct vnode_attr *a_vap;
	vfs_context_t a_context;
};
struct vnop_whiteout_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_dvp;
	struct componentname *a_cnp;
	int a_flags;
	vfs_context_t a_context;
};
struct vnop_mknod_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_dvp;
	vnode_t *a_vpp;
	struct componentname *a_cnp;
	struct vnode_attr *a_vap;
	vfs_context_t a_context;
};
struct vnop_open_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	int a_mode;
	vfs_context_t a_context;
};
struct vnop_compound_open_args {
	struct vnodeop_desc *a_desc;

	vnode_t a_dvp;                          
	vnode_t *a_vpp;                         
	int a_fmode;                            
	struct componentname *a_cnp;            
	struct vnode_attr *a_vap;               
	uint32_t a_flags;                       
	uint32_t *a_status;                     

	vfs_context_t a_context;                        

	int (*a_open_create_authorizer)(        
		vnode_t dvp,                            
		struct componentname *cnp,              
		struct vnode_attr *vap,                 
		vfs_context_t ctx,                      
		void *reserved);                        

	int (*a_open_existing_authorizer)(      
		vnode_t vp,                             
		struct componentname *cnp,              
		int fmode,                              
		vfs_context_t ctx,                      
		void *reserved);                        

	void *a_reserved;
};
struct vnop_close_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	int a_fflag;
	vfs_context_t a_context;
};
struct vnop_access_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	int a_action;
	vfs_context_t a_context;
};
struct vnop_getattr_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	struct vnode_attr *a_vap;
	vfs_context_t a_context;
};
struct vnop_setattr_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	struct vnode_attr *a_vap;
	vfs_context_t a_context;
};
struct vnop_read_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	struct uio *a_uio;
	int a_ioflag;
	vfs_context_t a_context;
};
struct vnop_write_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	struct uio *a_uio;
	int a_ioflag;
	vfs_context_t a_context;
};
struct vnop_ioctl_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	u_long a_command;
	caddr_t a_data;
	int a_fflag;
	vfs_context_t a_context;
};
struct vnop_select_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	int a_which;
	int a_fflags;
	void *a_wql;
	vfs_context_t a_context;
};
struct vnop_exchange_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_fvp;
	vnode_t a_tvp;
	int a_options;
	vfs_context_t a_context;
};
struct vnop_revoke_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	int a_flags;
	vfs_context_t a_context;
};
struct vnop_mmap_check_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	int a_flags;
	vfs_context_t a_context;
};
struct vnop_mmap_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	int a_fflags;
	vfs_context_t a_context;
};
struct vnop_mnomap_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	vfs_context_t a_context;
};
struct vnop_fsync_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	int a_waitfor;
	vfs_context_t a_context;
};
struct vnop_remove_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_dvp;
	vnode_t a_vp;
	struct componentname *a_cnp;
	int a_flags;
	vfs_context_t a_context;
};
struct vnop_compound_remove_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_dvp;                          
	vnode_t *a_vpp;                         
	struct componentname *a_cnp;            
	struct vnode_attr *a_vap;               
	uint32_t a_flags;                       
	vfs_context_t a_context;                
	int (*a_remove_authorizer)(             
		vnode_t dvp,                            
		vnode_t vp,                             
		struct componentname *cnp,              
		vfs_context_t ctx,                      
		void *reserved);                        
	void *a_reserved;                       
};
struct vnop_link_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	vnode_t a_tdvp;
	struct componentname *a_cnp;
	vfs_context_t a_context;
};
struct vnop_rename_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_fdvp;
	vnode_t a_fvp;
	struct componentname *a_fcnp;
	vnode_t a_tdvp;
	vnode_t a_tvp;
	struct componentname *a_tcnp;
	vfs_context_t a_context;
};
struct vnop_renamex_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_fdvp;
	vnode_t a_fvp;
	struct componentname *a_fcnp;
	vnode_t a_tdvp;
	vnode_t a_tvp;
	struct componentname *a_tcnp;
	struct vnode_attr *a_vap;               
	vfs_rename_flags_t a_flags;
	vfs_context_t a_context;
};
struct vnop_compound_rename_args {
	struct vnodeop_desc *a_desc;

	vnode_t a_fdvp;                 
	vnode_t *a_fvpp;                
	struct componentname *a_fcnp;   
	struct vnode_attr *a_fvap;

	vnode_t a_tdvp;                 
	vnode_t *a_tvpp;                
	struct componentname *a_tcnp;   
	struct vnode_attr *a_tvap;

	uint32_t a_flags;               
	vfs_context_t a_context;        
	int (*a_rename_authorizer)(                     
		vnode_t fdvp,                           
		vnode_t fvp,                            
		struct componentname *fcnp,             
		vnode_t tdvp,                           
		vnode_t tvp,                            
		struct componentname *tcnp,             
		vfs_context_t ctx,                      
		void *reserved);                        
	void *a_reserved;               
};
struct vnop_mkdir_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_dvp;
	vnode_t *a_vpp;
	struct componentname *a_cnp;
	struct vnode_attr *a_vap;
	vfs_context_t a_context;
};
struct vnop_compound_mkdir_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_dvp;                  
	vnode_t *a_vpp;                 
	struct componentname *a_cnp;    
	struct vnode_attr *a_vap;       
	uint32_t a_flags;               
	vfs_context_t a_context;        
	void *a_reserved;               
};
struct vnop_rmdir_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_dvp;
	vnode_t a_vp;
	struct componentname *a_cnp;
	vfs_context_t a_context;
};
struct vnop_compound_rmdir_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_dvp;                          
	vnode_t *a_vpp;                         
	struct componentname *a_cnp;            
	struct vnode_attr *a_vap;               
	uint32_t a_flags;                       
	vfs_context_t a_context;                
	int (*a_rmdir_authorizer)(              
		vnode_t dvp,                            
		vnode_t vp,                             
		struct componentname *cnp,              
		vfs_context_t ctx,                      
		void *reserved);                        
	void *a_reserved;                       
};
struct vnop_symlink_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_dvp;
	vnode_t *a_vpp;
	struct componentname *a_cnp;
	struct vnode_attr *a_vap;
	char *a_target;
	vfs_context_t a_context;
};
struct vnop_readdir_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	struct uio *a_uio;
	int a_flags;
	int *a_eofflag;
	int *a_numdirent;
	vfs_context_t a_context;
};
struct vnop_readdirattr_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	struct attrlist *a_alist;
	struct uio *a_uio;
	uint32_t a_maxcount;
	uint32_t a_options;
	uint32_t *a_newstate;
	int *a_eofflag;
	uint32_t *a_actualcount;
	vfs_context_t a_context;
};
struct vnop_getattrlistbulk_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	struct attrlist *a_alist;
	struct vnode_attr *a_vap;
	struct uio *a_uio;
	void *a_private;
	uint64_t a_options;
	int32_t *a_eofflag;
	int32_t *a_actualcount;
	vfs_context_t a_context;
};
struct vnop_readlink_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	struct uio *a_uio;
	vfs_context_t a_context;
};
struct vnop_inactive_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	vfs_context_t a_context;
};
struct vnop_reclaim_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	vfs_context_t a_context;
};
struct vnop_pathconf_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	int a_name;
	int32_t *a_retval;
	vfs_context_t a_context;
};
struct vnop_advlock_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	caddr_t a_id;
	int a_op;
	struct flock *a_fl;
	int a_flags;
	vfs_context_t a_context;
	struct timespec *a_timeout;
};
struct vnop_allocate_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	off_t a_length;
	u_int32_t a_flags;
	off_t *a_bytesallocated;
	off_t a_offset;
	vfs_context_t a_context;
};
struct vnop_pagein_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	upl_t a_pl;
	upl_offset_t a_pl_offset;
	off_t a_f_offset;
	size_t a_size;
	int a_flags;
	vfs_context_t a_context;
};
struct vnop_pageout_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	upl_t a_pl;
	upl_offset_t a_pl_offset;
	off_t a_f_offset;
	size_t a_size;
	int a_flags;
	vfs_context_t a_context;
};
struct vnop_searchfs_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	void *a_searchparams1;
	void *a_searchparams2;
	struct attrlist *a_searchattrs;
	uint32_t a_maxmatches;
	struct timeval *a_timelimit;
	struct attrlist *a_returnattrs;
	uint32_t *a_nummatches;
	uint32_t a_scriptcode;
	uint32_t a_options;
	struct uio *a_uio;
	struct searchstate *a_searchstate;
	vfs_context_t a_context;
};
struct vnop_copyfile_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_fvp;
	vnode_t a_tdvp;
	vnode_t a_tvp;
	struct componentname *a_tcnp;
	int a_mode;
	int a_flags;
	vfs_context_t a_context;
};
struct vnop_clonefile_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_fvp;
	vnode_t a_dvp;
	vnode_t *a_vpp;
	struct componentname *a_cnp;
	struct vnode_attr *a_vap;
	uint32_t a_flags;
	vfs_context_t a_context;
	int (*a_dir_clone_authorizer)(  
		struct vnode_attr *vap,         
		kauth_action_t action,         
		struct vnode_attr *dvap,         
		vnode_t sdvp,         
		mount_t mp,         
		dir_clone_authorizer_op_t vattr_op,         
		uint32_t flags,         
		vfs_context_t ctx,                      
		void *reserved);                        
	void *a_reserved;               
};
struct vnop_getxattr_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	const char * a_name;
	uio_t a_uio;
	size_t *a_size;
	int a_options;
	vfs_context_t a_context;
};
struct vnop_setxattr_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	const char * a_name;
	uio_t a_uio;
	int a_options;
	vfs_context_t a_context;
};
struct vnop_removexattr_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	const char * a_name;
	int a_options;
	vfs_context_t a_context;
};
struct vnop_listxattr_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	uio_t a_uio;
	size_t *a_size;
	int a_options;
	vfs_context_t a_context;
};
struct vnop_blktooff_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	daddr64_t a_lblkno;
	off_t *a_offset;
};
struct vnop_offtoblk_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	off_t a_offset;
	daddr64_t *a_lblkno;
};
struct vnop_blockmap_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	off_t a_foffset;
	size_t a_size;
	daddr64_t *a_bpn;
	size_t *a_run;
	void *a_poff;
	int a_flags;
	vfs_context_t a_context;
};
struct vnop_strategy_args {
	struct vnodeop_desc *a_desc;
	struct buf *a_bp;
};
struct vnop_bwrite_args {
	struct vnodeop_desc *a_desc;
	buf_t a_bp;
};
struct vnop_kqfilt_add_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	struct knote *a_kn;
	vfs_context_t a_context;
};
struct vnop_kqfilt_remove_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	uintptr_t a_ident;
	vfs_context_t a_context;
};
struct vnop_monitor_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	uint32_t a_events;
	uint32_t a_flags;
	void *a_handle;
	vfs_context_t a_context;
};
struct vnop_setlabel_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	struct label *a_vl;
	vfs_context_t a_context;
};
struct vnode {
	lck_mtx_t v_lock;                       
	TAILQ_ENTRY(vnode) v_freelist;          
	TAILQ_ENTRY(vnode) v_mntvnodes;         
	TAILQ_HEAD(, namecache) v_ncchildren;   
	LIST_HEAD(, namecache) v_nclinks;       
	vnode_t  v_defer_reclaimlist;           
	uint32_t v_listflag;                    
	uint32_t v_flag;                        
	uint16_t v_lflag;                       
	uint8_t  v_iterblkflags;                
	uint8_t  v_references;                  
	int32_t  v_kusecount;                   
	int32_t  v_usecount;                    
	int32_t  v_iocount;                     
	void *   XNU_PTRAUTH_SIGNED_PTR("vnode.v_owner") v_owner; 
	uint8_t  v_ext_flag;                    
	uint8_t  v_type;                        
	uint16_t v_tag;                         
	uint32_t v_id;                          
	union {
		struct mount    * XNU_PTRAUTH_SIGNED_PTR("vnode.v_data") vu_mountedhere;  
		struct socket   * XNU_PTRAUTH_SIGNED_PTR("vnode.vu_socket") vu_socket;     
		struct specinfo * XNU_PTRAUTH_SIGNED_PTR("vnode.vu_specinfo") vu_specinfo;   
		struct fifoinfo * XNU_PTRAUTH_SIGNED_PTR("vnode.vu_fifoinfo") vu_fifoinfo;   
		struct ubc_info * XNU_PTRAUTH_SIGNED_PTR("vnode.vu_ubcinfo") vu_ubcinfo;    
	} v_un;
	struct  buflists v_cleanblkhd;          
	struct  buflists v_dirtyblkhd;          
	struct klist v_knotes;                  
	kauth_cred_t    XNU_PTRAUTH_SIGNED_PTR("vnode.v_cred") v_cred; 
	kauth_action_t  v_authorized_actions;   
	int             v_cred_timestamp;       
	int             v_nc_generation;        
	int32_t         v_numoutput;            
	int32_t         v_writecount;           
	uint32_t        v_holdcount;            
	const char *v_name;                     
	vnode_t XNU_PTRAUTH_SIGNED_PTR("vnode.v_parent") v_parent;                       
	struct lockf    *v_lockf;               
	int(**v_op)(void *);                    
	mount_t XNU_PTRAUTH_SIGNED_PTR("vnode.v_mount") v_mount;                        
	void *  v_data;                         
	struct label *v_label;                  


};
struct fd_vn_data {
	lck_mtx_t fv_lock;   
	off_t     fv_offset; 
	void      *fv_dircookie; 
	caddr_t   fv_buf;    
	size_t    fv_bufsiz;  
	size_t    fv_bufdone; 
	size_t    fv_bufallocsiz; 
	off_t     fv_soff;   
	off_t     fv_eoff;   
	int       fv_eofflag;
};
struct vnodeop_desc {
	int     vdesc_offset;           
	const char *vdesc_name;         
	int     vdesc_flags;            

	int     *vdesc_vp_offsets;      
	int     vdesc_vpp_offset;       
	int     vdesc_cred_offset;      
	int     vdesc_proc_offset;      
	int     vdesc_componentname_offset; 
	int     vdesc_context_offset;   
	caddr_t *vdesc_transports;
};
struct sockaddr_vm {
	__uint8_t      svm_len;        
	sa_family_t    svm_family;     
	__uint16_t     svm_reserved1;
	__uint32_t     svm_port;       
	__uint32_t     svm_cid;        
} __attribute__((__packed__));
struct xvsockpcb {
	u_int32_t      xv_len;            
	u_int64_t      xv_vsockpp;
	u_int32_t      xvp_local_cid;     
	u_int32_t      xvp_local_port;    
	u_int32_t      xvp_remote_cid;    
	u_int32_t      xvp_remote_port;   
	u_int32_t      xvp_rxcnt;         
	u_int32_t      xvp_txcnt;         
	u_int32_t      xvp_peer_rxhiwat;  
	u_int32_t      xvp_peer_rxcnt;    
	pid_t          xvp_last_pid;      
	vsock_gen_t    xvp_gencnt;        
	struct xsocket xv_socket;
};
struct  xvsockpgen {
	u_int32_t      xvg_len;      
	u_int64_t      xvg_count;    
	vsock_gen_t    xvg_gen;      
	so_gen_t       xvg_sogen;    
};
struct vsockpcb {
	TAILQ_ENTRY(vsockpcb) all;
	LIST_ENTRY(vsockpcb) bound;
	struct socket *so;
	struct vsock_address local_address;
	struct vsock_address remote_address;
	struct vsock_transport *transport;
	uint32_t fwd_cnt;
	uint32_t tx_cnt;
	uint32_t peer_buf_alloc;
	uint32_t peer_fwd_cnt;
	uint32_t last_buf_alloc;
	uint32_t last_fwd_cnt;
	size_t waiting_send_size;
	vsock_gen_t vsock_gencnt;
};
struct vsockpcbinfo {
	lck_rw_t all_lock;
	lck_rw_t bound_lock;
	TAILQ_HEAD(, vsockpcb) all;
	LIST_HEAD(, vsockpcb) bound;
	uint32_t last_port;
	lck_mtx_t port_lock;
	uint64_t all_pcb_count;
	vsock_gen_t vsock_gencnt;
};
struct vsock_address {
	uint32_t cid;
	uint32_t port;
};
struct vsock_transport {
	void *provider;
	int (*get_cid)(void *provider, uint32_t *cid);
	int (*attach_socket)(void *provider);
	int (*detach_socket)(void *provider);
	int (*put_message)(void *provider, struct vsock_address src, struct vsock_address dst,
	    enum vsock_operation op, uint32_t buf_alloc, uint32_t fwd_cnt, mbuf_t m);
};
struct work_interval_notification {
	uint64_t        start;
	uint64_t        finish;
	uint64_t        deadline;
	uint64_t        next_start;
	uint32_t        notify_flags;
	uint32_t        create_flags;
};
struct work_interval_create_params {
	uint64_t        wicp_id;          
	mach_port_name_t wicp_port;       
	uint32_t        wicp_create_flags;
};
struct work_interval_workload_id_params {
	uint32_t        wlidp_flags;            
	uint32_t        wlidp_wicreate_flags;   
	uint64_t        wlidp_name;             
	uint64_t        wlidp_syscall_mask[2];  
};
struct _attrlist_buf {
	char    *base;
	char    *fixedcursor;
	char    *varcursor;
	ssize_t allocated;
	ssize_t needed;
	attribute_set_t actual;
	attribute_set_t valid;
};
struct getvolattrlist_attrtab {
	attrgroup_t     attr;
	uint64_t        bits;
	ssize_t         size;
};
struct getattrlist_attrtab {
	attrgroup_t     attr;
	uint64_t        bits;
	ssize_t         size;
	kauth_action_t  action;
};
struct _attrlist_paths {
	char *fullpathptr;
	ssize_t fullpathlen;
	size_t fullpathbuflen;
	char *relpathptr;
	ssize_t relpathlen;
	size_t relpathbuflen;
	char *REALpathptr;
	ssize_t REALpathlen;
	size_t REALpathbuflen;
};
struct {
	void (* callout)(int, void *);
	void *context;
} fs_buffer_cache_gc_callout_t;
struct buf_iterate_info_t {
	int flag;
	struct buflists *listhead;
};
struct string_t {
	LIST_ENTRY(string_t)  hash_chain;
	char                  *str;
	uint32_t              strbuflen;
	uint32_t              refcount;
} string_t;
struct nameidata_state {
	u_long  ni_loopcnt;
	char *ni_next;
	u_int ni_pathlen;
	int32_t ni_flag;
	char *cn_nameptr;
	int cn_namelen;
	int cn_flags;
	uint32_t cn_hash;
};
struct clios {
	lck_mtx_t io_mtxp;
	u_int  io_completed;       
	u_int  io_issued;          
	int    io_error;           
	int    io_wanted;          
};
struct cl_direct_read_lock {
	LIST_ENTRY(cl_direct_read_lock)         chain;
	int32_t                                                         ref_count;
	vnode_t                                                         vp;
	lck_rw_t                                                        rw_lock;
};
struct verify_buf {
	TAILQ_ENTRY(verify_buf) vb_entry;
	buf_t vb_cbp;
	void* vb_callback_arg;
	int32_t vb_whichq;
};
struct vfs_drt_hashentry {
	u_int64_t       dhe_control;

	u_int32_t       dhe_bitvector[MAX_DRT_BITVECTOR_PAGES / 32];
};
struct vfs_drt_clustermap {
	u_int32_t               scm_magic;      
	u_int32_t               scm_modulus;    
	u_int32_t               scm_buckets;    
	u_int32_t               scm_lastclean;  
	u_int32_t               scm_iskips;     

	struct vfs_drt_hashentry scm_hashtable[0];
};
struct cpx {
	aes_encrypt_ctx         *cpx_iv_aes_ctx_ptr;
	cpx_flags_t             cpx_flags;
	uint16_t                cpx_max_key_len;
	uint16_t                cpx_key_len;
	uint8_t                 cpx_cached_key[];
};
struct {
	cp_vfs_callback_arg_type_t type;
	union {
		cp_lock_state_t lock_state;
		cp_ep_state_t   ep_state;
		cp_cx_state_t   cx_state;
	};
	int             valid_uuid;
	uuid_t          volume_uuid;
} cp_vfs_callback_arg;
struct saved_mount_fields {
	uint32_t        mnt_maxreadcnt;         
	uint32_t        mnt_maxwritecnt;        
	uint32_t        mnt_segreadcnt;         
	uint32_t        mnt_segwritecnt;        
	uint32_t        mnt_ioqueue_depth;      
	uint32_t        mnt_ioscale;            
};
struct _disk_conditioner_info_t {
	disk_conditioner_info dcinfo; 
	struct saved_mount_fields mnt_fields; 

	daddr64_t last_blkno; 
	struct timeval last_io_timestamp; 
};
struct open_vnode {
	LIST_ENTRY(open_vnode) chain;
	vnode_t vp;
	dev_t dev;
	uint64_t file_id;
	uint32_t open_count;
};
struct registered_fs_tag {
	LIST_ENTRY(registered_fs_tag) link;
	uint32_t fstag;
	uint32_t flags;
	vnode_t vp;
	dev_t dev;
	fsioc_graft_info_t graft_info;
} registered_fs_tag_t;
struct {
	uint32_t length;
	uint32_t returned_attrs[5];
	int32_t name_offset;
	uint32_t name_length;
	uint32_t obj_type;
	uint64_t file_id;
	off_t data_length;
} __attribute__((packed)) exclave_fs_dirent_t;
struct {
	uint8_t lz4state[lz4_encode_scratch_size]__attribute((aligned(LZ4_SCRATCH_ALIGN)));
} lz4_encode_scratch_t;
struct vnode_iocs_context {
	struct sysctl_req *addr;
	unsigned long current_offset;
	unsigned long length;
};
struct iocs_store_buffer {
	void*                   buffer;
	uint32_t                current_position;
	uint32_t                marked_point;
};
struct unmount_info {
	int     u_errs; 
	int     u_busy; 
	int     u_count; 
	int     u_only_non_system;
};
struct _vnode_authorize_context {
	vnode_t         vp;
	struct vnode_attr *vap;
	vnode_t         dvp;
	struct vnode_attr *dvap;
	vfs_context_t   ctx;
	int             flags;
	int             flags_valid;
} *vauth_ctx;
struct vnode_trace_paths_context {
	uint64_t count;
	unsigned long path[NPATH_WORDS + (4 - (NPATH_WORDS % 4)) - 1];
};
struct cdirargs {
	vnode_t olddp;
	vnode_t newdp;
};
struct getfsstat_struct {
	user_addr_t     sfsp;
	user_addr_t     *mp;
	int             count;
	int             maxcount;
	int             flags;
	int             error;
};
struct setxattr_ctx {
	struct nameidata nd;
	char attrname[XATTR_MAXNAMELEN + 1];
	UIO_STACKBUF(uio_buf, 1);
};
struct {
	u_int32_t _key;
	u_int32_t _value;
} unicode_mappings32;
struct {
	u_int16_t _key;
	u_int16_t _value;
} unicode_mappings16;
struct vniodesc {
	vnode_t         vnio_vnode;     
	int             vnio_fflags;    
};
struct  pager_struct {
	boolean_t       is_device;
};
struct pager_file {
	queue_chain_t   pf_chain;       
	struct  vnode   *pf_vp;         
	u_int           pf_count;       
	u_char          *pf_bmap;       
	long            pf_npgs;        
	long            pf_pfree;       
	long            pf_lowat;       
	long            pf_hipage;      
	long            pf_hint;        
	char            *pf_name;       
	boolean_t       pf_prefer;
	int             pf_index;       
	void *          pf_lock;        
} *pager_file_t;
struct bs_map {
	struct vnode    *vp;
	void            *bs;
};
struct {
	unsigned int index:8;   
	unsigned int offset:24; 
} pf_entry;
struct vstruct {
	boolean_t       is_device;      
	pager_file_t    vs_pf;          
	pf_entry        **vs_pmap;      
	unsigned int
	 vs_swapfile:1;  
	short           vs_count;       
	int             vs_size;        
	struct vnode    *vs_vp;         
} *vnode_pager_t;
struct fd_set {
	__int32_t       fds_bits[__DARWIN_howmany(__DARWIN_FD_SETSIZE, __DARWIN_NFDBITS)];
} fd_set;
struct fsobj_id {
	u_int32_t fid_objno;
	u_int32_t fid_generation;
} fsobj_id_t;
struct secure_boot_cryptex_args {
	u_int32_t sbc_version;
	u_int32_t sbc_4cc;
	int sbc_authentic_manifest_fd;
	int sbc_user_manifest_fd;
	int sbc_payload_fd;
	u_int64_t sbc_flags;
} __attribute__((aligned(4), packed))  secure_boot_cryptex_args_t;
struct iovec {
	void *   iov_base;      
	size_t   iov_len;       
};
struct timeval64 {
	__int64_t               tv_sec;         
	__int64_t               tv_usec;        
};
struct ch_event_result {
	uint32_t tx_data;
	uint32_t rx_data;
};
struct ch_selinfo {
	decl_lck_mtx_data(, csi_lock);
	struct selinfo  csi_si;
	uint32_t        csi_flags;
	uint32_t        csi_pending;
	uint64_t        csi_eff_interval;
	uint64_t        csi_interval;
	thread_call_t   csi_tcall;
};
struct __kern_slot_desc {
	union {
		struct __kern_quantum *sd_qum;
		struct __kern_packet *sd_pkt;
		struct __kern_buflet *sd_buf;
		void *sd_md;                    
	};

};
struct slot_ctx {
	void                    *slot_ctx_arg;   
};
struct kern_channel {
	decl_lck_mtx_data(, ch_lock);
	struct nexus_adapter    *ch_na;
	struct kern_nexus       *ch_nexus;
	struct ch_info          *ch_info;
	struct kern_pbufpool    *ch_pp;

	uint32_t                ch_refcnt;
	volatile uint32_t       ch_flags;       

	ring_id_t               ch_first[NR_ALL];
	ring_id_t               ch_last[NR_ALL];

	struct __user_channel_schema *ch_schema;

	struct ch_selinfo       *ch_si[NR_ALL];

	STAILQ_ENTRY(kern_channel) ch_link;
	STAILQ_ENTRY(kern_channel) ch_link_if_adv;
	void                    *ch_ctx;
	mach_vm_offset_t        ch_schema_offset;
	struct skmem_arena_mmap_info ch_mmap;
	int                     ch_fd;          
	pid_t                   ch_pid;         
	char                    ch_name[32];    
};
struct chreq {
	char            cr_name[CHREQ_NAMELEN];         
	uuid_t          cr_spec_uuid;                   
	struct ch_ev_thresh cr_tx_lowat;                
	struct ch_ev_thresh cr_rx_lowat;                
	nexus_port_t    cr_port;                        
	uint32_t        cr_mode;                        
	uint32_t        cr_pipe_id;                     
	ring_id_t       cr_ring_id;                     
	ring_set_t      cr_ring_set;                    
	ch_endpoint_t   cr_real_endpoint;               
	ch_endpoint_t   cr_endpoint;                    
	mach_vm_size_t  cr_memsize;                     
	mach_vm_offset_t cr_memoffset;                  
};
struct __kern_channel_ring {
	struct __user_channel_ring      *ckr_ring;

	uint32_t                ckr_flags;      
	slot_idx_t              ckr_num_slots;  
	uint32_t                ckr_max_pkt_len;
	uint32_t                ckr_largest;    
	const slot_idx_t        ckr_lim; 
	enum txrx               ckr_tx;  

	volatile slot_idx_t     ckr_khead;
	volatile slot_idx_t     ckr_ktail;
	volatile slot_idx_t     ckr_khead_pre;
	volatile slot_idx_t     ckr_rhead;
	volatile slot_idx_t     ckr_rtail;

	uint32_t                ckr_transfer_decay;

	uint64_t                ckr_ready_bytes;
	uint64_t                ckr_ready_slots;

	decl_lck_spin_data(, ckr_slock);
	struct thread *ckr_owner; 
	uint32_t ckr_busy;      
	uint32_t ckr_want;      
	uint32_t ckr_state;     

	volatile uint32_t       ckr_alloc_ws;

	struct nexus_adapter *ckr_na;   
	struct kern_pbufpool *ckr_pp;   

	struct __slot_desc *__counted_by(ckr_usds_cnt) ckr_usds;   
	slot_idx_t ckr_usds_cnt;
	struct __slot_desc *__counted_by(ckr_ksds_cnt) ckr_ksds;   
	slot_idx_t ckr_ksds_cnt;
	struct __slot_desc *ckr_ksds_last; 
	struct skmem_cache *ckr_ksds_cache; 

	uint32_t        ckr_ring_id;      

	boolean_t       ckr_rate_limited; 

	uint64_t        *__counted_by(ckr_scratch_cnt)ckr_scratch;
	slot_idx_t      ckr_scratch_cnt;
	int (*ckr_na_sync)(struct __kern_channel_ring *,
	    struct proc *, uint32_t);
	int(*volatile ckr_na_notify)(struct __kern_channel_ring *,
	    struct proc *, uint32_t);

	int (*ckr_prologue)(struct kern_channel *,
	    struct __kern_channel_ring *, const slot_idx_t,
	    uint32_t *, uint64_t *, struct proc *);
	void (*ckr_finalize)(struct kern_channel *,
	    struct __kern_channel_ring *, const slot_idx_t, struct proc *);

	uint64_t        ckr_sync_time;

	int (*ckr_save_notify)(struct __kern_channel_ring *kring,
	    struct proc *, uint32_t flags);

	kern_packet_svc_class_t ckr_svc;

	uint32_t        ckr_slot_ctxs_set; 
	struct slot_ctx *__counted_by(ckr_slot_ctxs_cnt)ckr_slot_ctxs; 
	uint32_t        ckr_slot_ctxs_cnt;
	void            *ckr_ctx;       

	struct ch_selinfo ckr_si;       



	decl_lck_mtx_data(, ckr_qlock);


	uint32_t        ckr_users;      

	int64_t         ckr_tbr_token;
	int64_t         ckr_tbr_depth;
	uint64_t        ckr_tbr_last;

	channel_ring_error_stats ckr_err_stats
	__attribute__((aligned(sizeof(uint64_t))));

	channel_ring_stats ckr_stats
	__attribute__((aligned(sizeof(uint64_t))));
	uint64_t        ckr_accumulated_bytes;
	uint64_t        ckr_accumulated_slots;
	uint64_t        ckr_accumulate_start; 

	channel_ring_user_stats ckr_usr_stats
	__attribute__((aligned(sizeof(uint64_t))));
	uint64_t        ckr_user_accumulated_bytes;
	uint64_t        ckr_user_accumulated_slots;
	uint64_t        ckr_user_accumulated_syncs;
	uint64_t        ckr_user_accumulate_start; 

	lck_grp_t       *ckr_qlock_group;
	lck_grp_t       *ckr_slock_group;

	char            ckr_name[64];   

	uint64_t        ckr_rx_dequeue_ts; 
	uint64_t        ckr_rx_enqueue_ts; 
} __attribute__((__aligned__(CHANNEL_CACHE_ALIGN_MAX)));
struct __notif_dest {
	uint8_t dest_type;
	union {
		struct nx_flowswitch *dest_fsw;
		struct nx_netif          *dest_netif;
	};
	const char *dest_desc;
};
struct slot_prop {
	uint16_t sp_flags;              
	uint16_t sp_len;                
	uint32_t sp_idx;                
	mach_vm_address_t sp_ext_ptr;   
	mach_vm_address_t sp_buf_ptr;   
	mach_vm_address_t sp_mdata_ptr; 
	uint32_t _sp_pad[8];            
} slot_prop_t __attribute__((aligned(sizeof(uint64_t))));
struct os_channel_event_packet_transmit_status {
	packet_id_t    packet_id;
	int32_t        packet_status;
} os_channel_event_packet_transmit_status_t;
struct os_channel_event_packet_transmit_expired {
	packet_id_t    packet_id;
	uint64_t       packet_tx_expiration_deadline;
	uint64_t       packet_tx_expiration_timestamp;
	uint16_t       packet_tx_expiration_status;
	uint16_t       packet_tx_expiration_origin;
}  os_channel_event_packet_transmit_expired_t;
struct __kern_channel_event_metadata {
	os_channel_event_type_t    emd_etype;
	uint32_t                   emd_nevents;
};
struct __kern_channel_event {
	os_channel_event_type_t    ev_type;
	uint32_t                   ev_flags;
	uint16_t                   _reserved;
	uint16_t                   ev_dlen;
	uint8_t                    ev_data[__counted_by(ev_dlen)];
};
struct __user_channel_schema {
	const uint32_t  csm_ver;                
	const volatile uint32_t csm_flags;      
	char      csm_kern_name[CHANNEL_SCHEMA_KERN_NAME];
	uuid_t    csm_kern_uuid;


	uint32_t  csm_tx_rings;   
	uint32_t  csm_rx_rings;   

	uint32_t  csm_allocator_ring_pairs;

	uint32_t  csm_num_event_rings;
	uint32_t  csm_large_buf_alloc_rings;

	const uint32_t          csm_flowadv_max;
	const mach_vm_offset_t  csm_flowadv_ofs
	__attribute__((aligned(sizeof(uint64_t))));

	const uint64_t  csm_md_redzone_cookie   
	__attribute__((aligned(sizeof(uint64_t))));
	const nexus_meta_type_t csm_md_type;    
	const nexus_meta_subtype_t csm_md_subtype; 

	const mach_vm_offset_t  csm_stats_ofs
	__attribute__((aligned(sizeof(uint64_t))));
	const nexus_stats_type_t csm_stats_type;

	const mach_vm_offset_t csm_nexusadv_ofs
	__attribute__((aligned(sizeof(uint64_t))));

	struct {
		const mach_vm_offset_t  ring_off; 
		const mach_vm_offset_t  sd_off;   
	} csm_ring_ofs[__counted_by(csm_tx_rings + csm_rx_rings +
	csm_allocator_ring_pairs + csm_num_event_rings + csm_large_buf_alloc_rings)]
	__attribute__((aligned(sizeof(uint64_t))));
};
struct __user_slot_desc {
	obj_idx_t       sd_md_idx;      
	uint16_t        sd_flags;       
	uint16_t        sd_len;         
};
struct __slot_desc {
	union {
		struct __user_slot_desc _sd_user;
		uint64_t                _sd_private[1];
	};
};
struct __user_channel_ring {
	volatile slot_idx_t     ring_head;      
	const volatile slot_idx_t ring_tail;    
	const volatile slot_idx_t ring_khead;   

	const uint32_t  ring_num_slots; 
	const uint32_t  ring_def_buf_size;  
	const uint32_t  ring_large_buf_size;  
	const uint16_t  ring_md_size;   
	const uint16_t  ring_bft_size;  
	const uint16_t  ring_id;        
	const uint16_t  ring_kind;      

	const mach_vm_offset_t  ring_def_buf_base
	__attribute((aligned(sizeof(uint64_t))));
	const mach_vm_offset_t  ring_large_buf_base
	__attribute((aligned(sizeof(uint64_t))));
	const mach_vm_offset_t  ring_md_base    
	__attribute((aligned(sizeof(uint64_t))));
	const mach_vm_offset_t  ring_sd_base    
	__attribute((aligned(sizeof(uint64_t))));
	const mach_vm_offset_t  ring_bft_base
	__attribute((aligned(sizeof(uint64_t))));

	const volatile uint64_t ring_sync_time 
	__attribute((aligned(sizeof(uint64_t))));
	const volatile uint64_t ring_notify_time 
	__attribute((aligned(sizeof(uint64_t))));
	const volatile uint32_t ring_alloc_ws;
	const volatile uint32_t ring_alloc_buf_ws;
};
struct __flowadv_entry {
	union {
		uint64_t        fae_id_64[2];
		uint32_t        fae_id_32[4];
		uuid_t          fae_id; 
	};
	volatile uint32_t       fae_ce_cnt;
	volatile uint32_t       fae_pkt_cnt;
	volatile uint32_t       fae_flags;  
	uint32_t                fae_flowid;
} __attribute__((aligned(sizeof(uint64_t))));
struct ch_ev_thresh {
	channel_threshold_unit_t cet_unit;
	uint32_t                cet_value;
};
struct ch_info {
	union {
		uint64_t  cinfo_ch_id_64[2];
		uint32_t  cinfo_ch_id_32[4];
		uuid_t    cinfo_ch_id;          
	};
	uint32_t          cinfo_ch_mode;        
	ring_id_t         cinfo_ch_ring_id;     
	struct nxprov_params cinfo_nxprov_params; 
	uuid_t            cinfo_nx_uuid;        
	nexus_port_t      cinfo_nx_port;        
	uint32_t          cinfo_num_bufs;       
	mach_vm_size_t    cinfo_mem_map_size;   
	mach_vm_address_t cinfo_mem_base;       
	mach_vm_offset_t  cinfo_schema_offset;  
	ring_id_t         cinfo_first_tx_ring;  
	ring_id_t         cinfo_last_tx_ring;   
	ring_id_t         cinfo_first_rx_ring;  
	ring_id_t         cinfo_last_rx_ring;   
	struct ch_ev_thresh cinfo_tx_lowat;     
	struct ch_ev_thresh cinfo_rx_lowat;     
} __attribute__((aligned(sizeof(uint64_t))));
struct ch_init {
	uint32_t        ci_version;     
	uint32_t        ci_ch_mode;     
	ring_id_t       ci_ch_ring_id;  
	nexus_port_t    ci_nx_port;     
	uuid_t          ci_nx_uuid;     
	user_addr_t     ci_key;         
	uint32_t        ci_key_len;     
	uint32_t        __ci_align;     
	struct ch_ev_thresh ci_tx_lowat; 
	struct ch_ev_thresh ci_rx_lowat; 
	guardid_t       ci_guard;       
};
struct skoid {
	struct sysctl_oid_list  sko_oid_list;   
	struct sysctl_oid       sko_oid;        
	char                    sko_name[SKOID_NAME_SIZE];      
};
struct _slot {
	uint32_t                _hash;
	struct cuckoo_node      *_node;
};
struct _bucket {
	struct _slot            _slots[_CHT_BUCKET_SLOTS];
	decl_lck_mtx_data(, _lock);
	uint8_t                 _inuse;
} __attribute__((aligned(_CHT_CACHELINE_CHUNK)));
struct cuckoo_hashtable {
	uint32_t        _bitmask;       
	uint32_t        _n_buckets;     

	volatile uint32_t _n_entries;   
	uint32_t          _capacity;    
	uint32_t          _rcapacity;   

	bool            _busy;
	uint32_t        _resize_waiters;
	decl_lck_rw_data(, _resize_lock);
	decl_lck_mtx_data(, _lock);

	struct _bucket  *__counted_by(_n_buckets) _buckets;

	int (*_obj_cmp)(struct cuckoo_node *node, void *key);
	void (*_obj_retain)(struct cuckoo_node *);
	void (*_obj_release)(struct cuckoo_node *);
} __attribute__((aligned(_CHT_CACHELINE_CHUNK)));
struct _bfs_node {
	uint32_t        bkt_idx;
	uint8_t         prev_node_idx;
	uint8_t         prev_slot_idx;
};
struct cuckoo_node {
	struct cuckoo_node *next;
};
struct cuckoo_hashtable_params {
	size_t cht_capacity;
	cuckoo_obj_cmp_func cht_obj_cmp;
	cuckoo_obj_retain_func cht_obj_retain;
	cuckoo_obj_release_func cht_obj_release;
};
struct skmem_arena {
	decl_lck_mtx_data(, ar_lock);           
	uint32_t                ar_refcnt;      

	TAILQ_ENTRY(skmem_arena) ar_link;       
	char                    ar_name[64];    
	skmem_arena_type_t      ar_type;        
	uint32_t                ar_flags;       
	size_t                  ar_zsize;       
	IOSKArenaRef            ar_ar;          

	struct skmem_region     *ar_regions[SKMEM_REGIONS]; 

	mach_vm_size_t          ar_mapsize;     
	uint32_t                ar_mapcnt;      
	uint32_t                ar_maprdrcnt;   
	SLIST_HEAD(, skmem_arena_mmap_info) ar_map_head; 
};
struct skmem_arena_mmap_info {
	SLIST_ENTRY(skmem_arena_mmap_info)      ami_link;
	struct skmem_arena      *ami_arena;     
	IOSKMapperRef           ami_mapref;     
	task_t                  ami_maptask;    
	mach_vm_address_t       ami_mapaddr;    
	mach_vm_size_t          ami_mapsize;    
	boolean_t               ami_redirect;   
};
struct skmem_arena_nexus {
	struct skmem_arena      arn_cmn;        

	struct kern_pbufpool    *arn_rx_pp;     
	struct kern_pbufpool    *arn_tx_pp;     
	uint32_t                arn_mode;       
	nexus_meta_type_t       arn_md_type;    
	nexus_meta_subtype_t    arn_md_subtype; 
	int                     arn_ksd_nodefunct;

	struct skmem_cache      *arn_schema_cache; 
	struct skmem_cache      *arn_ring_cache;   
	struct skmem_cache      *arn_txaksd_cache; 
	struct skmem_cache      *arn_rxfksd_cache; 

	void                    *__sized_by(arn_stats_obj_size)arn_stats_obj;
	size_t                  arn_stats_obj_size;

	struct __flowadv_entry  *__counted_by(arn_flowadv_entries)arn_flowadv_obj;
	size_t                  arn_flowadv_entries;

	void                    *arn_nexusadv_obj;
};
struct skmem_arena_necp {
	struct skmem_arena      arc_cmn;        

	struct skmem_cache      *arc_kstats_cache;
};
struct skmem_arena_system {
	struct skmem_arena      ars_cmn;        

	void                    *ars_sysctls_obj;
	size_t                  ars_sysctls_objsize;
};
struct skmem_bufctl {
	SLIST_ENTRY(skmem_bufctl) bc_link;      
	void                    *__sized_by(bc_lim) bc_addr;       
	void                    *bc_addrm;      
	struct skmem_slab       *bc_slab;       
	uint32_t                bc_lim;         
	uint32_t                bc_flags;       
	uint32_t                bc_idx;         
	volatile uint32_t       bc_usecnt;      
};
struct skmem_bufctl_audit {
	SLIST_ENTRY(skmem_bufctl) bc_link;      
	void                    *__sized_by(bc_lim) bc_addr;       
	void                    *bc_addrm;      
	struct skmem_slab       *bc_slab;       
	uint32_t                bc_lim;         
	uint32_t                bc_flags;       
	uint32_t                bc_idx;         
	volatile uint32_t       bc_usecnt;      
	struct thread           *bc_thread;     
	uint32_t                bc_timestamp;   
	uint32_t                bc_depth;       
	void                    *bc_stack[SKMEM_STACK_DEPTH]; 
};
struct skmem_bufctl_bkt {
	SLIST_HEAD(, skmem_bufctl) bcb_head;    
};
struct skmem_slab {
	TAILQ_ENTRY(skmem_slab) sl_link;        
	struct skmem_cache      *sl_cache;      
	void                    *sl_base;       
	void                    *sl_basem;      
	struct sksegment        *sl_seg;        
	struct sksegment        *sl_segm;       
	SLIST_HEAD(, skmem_bufctl) sl_head;     
	uint32_t                sl_refcnt;      
	uint32_t                sl_chunks;      
};
struct skmem_magtype {
	int                     mt_magsize;     
	int                     mt_align;       
	size_t                  mt_minbuf;      
	size_t                  mt_maxbuf;      
	struct skmem_cache      *mt_cache;      
	char                    mt_cname[64];   
};
struct skmem_mag {
	SLIST_ENTRY(skmem_mag)  mg_link;        
	struct skmem_magtype    *mg_magtype;    
	size_t                  mg_count;       
	void                    *mg_round[__counted_by(mg_count)];   
};
struct skmem_maglist {
	SLIST_HEAD(, skmem_mag) ml_list;        
	uint32_t                ml_total;       
	uint32_t                ml_min;         
	uint32_t                ml_reaplimit;   
	uint64_t                ml_alloc;       
};
struct skmem_cpu_cache {
	decl_lck_mtx_data(, cp_lock);
	struct skmem_mag        *cp_loaded;     
	struct skmem_mag        *cp_ploaded;    
	uint64_t                cp_alloc;       
	uint64_t                cp_free;        
	int                     cp_rounds;      
	int                     cp_prounds;     
	int                     cp_magsize;     
} __attribute__((aligned(CHANNEL_CACHE_ALIGN_MAX)));
struct skmem_obj_info {
	void                    *__sized_by(oi_size) oi_addr;       
	struct skmem_bufctl     *oi_bc;         
	uint32_t                oi_size;        
	obj_idx_t               oi_idx_reg;     
	obj_idx_t               oi_idx_seg;     
} __attribute__((__packed__));
struct skmem_obj {
	struct skmem_obj        *mo_next;       
	struct skmem_obj_info   mo_info;        
	struct skmem_obj_info   mo_minfo;       
};
struct skmem_cache {
	uint32_t        skm_mode;               
	skmem_ctor_fn_t skm_ctor;               
	skmem_dtor_fn_t skm_dtor;               
	skmem_reclaim_fn_t skm_reclaim;         
	void            *skm_private;           

	decl_lck_mtx_data(, skm_dp_lock);       
	struct skmem_magtype *skm_magtype;      
	struct skmem_maglist skm_full;          
	struct skmem_maglist skm_empty;         

	decl_lck_mtx_data(, skm_sl_lock);       
	skmem_slab_alloc_fn_t skm_slab_alloc;   
	skmem_slab_free_fn_t skm_slab_free;     
	size_t          skm_chunksize;          
	size_t          skm_objsize;            
	size_t          skm_slabsize;           
	size_t          skm_hash_initial;       
	size_t          skm_hash_limit;         
	size_t          skm_hash_shift;         
	size_t          skm_hash_mask;          
	size_t          skm_hash_size;
	struct skmem_bufctl_bkt *__counted_by(skm_hash_size) skm_hash_table; 
	TAILQ_HEAD(, skmem_slab) skm_sl_partial_list; 
	TAILQ_HEAD(, skmem_slab) skm_sl_empty_list;   
	struct skmem_region *skm_region;        

	uint32_t        skm_cpu_mag_size;       
	uint32_t        skm_cpu_mag_resize;     
	uint32_t        skm_cpu_mag_purge;      
	uint32_t        skm_cpu_mag_reap;       
	uint64_t        skm_depot_contention;   
	uint64_t        skm_depot_contention_prev; 
	uint32_t        skm_depot_full;         
	uint32_t        skm_depot_empty;        
	uint32_t        skm_depot_ws_zero;      
	uint32_t        skm_sl_rescale;         
	uint32_t        skm_sl_create;          
	uint32_t        skm_sl_destroy;         
	uint32_t        skm_sl_alloc;           
	uint32_t        skm_sl_free;            
	uint32_t        skm_sl_partial;         
	uint32_t        skm_sl_empty;           
	uint64_t        skm_sl_alloc_fail;      
	uint64_t        skm_sl_bufinuse;        
	uint64_t        skm_sl_bufmax;          

	TAILQ_ENTRY(skmem_cache) skm_link;      
	char            skm_name[64];           
	uuid_t          skm_uuid;               
	size_t          skm_bufsize;            
	size_t          skm_bufalign;           
	size_t          skm_objalign;           

	decl_lck_mtx_data(, skm_rs_lock);       
	struct thread    *skm_rs_owner;         
	uint32_t        skm_rs_busy;            
	uint32_t        skm_rs_want;            
	size_t          skm_cpu_cache_count;
	struct skmem_cpu_cache  skm_cpu_cache[__counted_by(skm_cpu_cache_count)]
	__attribute__((aligned(CHANNEL_CACHE_ALIGN_MAX)));
};
struct sksegment {
	TAILQ_ENTRY(sksegment)  sg_link;        
	RB_ENTRY(sksegment)     sg_node;        
	struct skmem_region     *sg_region;     

	IOSKMemoryBufferRef     sg_md;          
	mach_vm_address_t       sg_start;       
	mach_vm_address_t       sg_end;         

	uint32_t                sg_index;       
	sksegment_type_t        sg_type;        
	sksegment_state_t       sg_state;       
};
struct sksegment_bkt {
	TAILQ_HEAD(, sksegment) sgb_head;       
};
struct skmem_region_params {
	const char              *srp_name;      
	skmem_region_id_t       srp_id;         
	uint32_t                srp_cflags;     
	uint32_t                srp_r_seg_size; 
	uint32_t                srp_c_seg_size; 
	uint32_t                srp_seg_cnt;    

	uint32_t                srp_r_obj_size; 
	uint32_t                srp_r_obj_cnt;  
	uint32_t                srp_c_obj_size; 
	uint32_t                srp_c_obj_cnt;  
	size_t                  srp_align;      

	nexus_meta_type_t       srp_md_type;    
	nexus_meta_subtype_t    srp_md_subtype; 
	uint16_t                srp_max_frags;  
};
struct skmem_region {
	decl_lck_mtx_data(, skr_lock);          

	uint64_t                skr_meminuse;   
	uint64_t                skr_w_meminuse; 
	uint64_t                skr_memtotal;   
	uint64_t                skr_alloc;      
	uint64_t                skr_free;       
	uint32_t                skr_seginuse;   
	uint32_t                skr_rescale;    

	struct skmem_region_params skr_params;  
	TAILQ_ENTRY(skmem_region) skr_link;     
	char                    skr_name[64];   
	uuid_t                  skr_uuid;       
	uint32_t                skr_mode;       
	uint32_t                skr_size;       
	IOSKMemoryBufferSpec    skr_bufspec;    
	IOSKRegionSpec          skr_regspec;    
	IOSKRegionRef           skr_reg;        
	struct zone             *skr_zreg;      
	void                    *skr_private;   
	struct skmem_cache      *skr_cache[SKR_MAX_CACHES]; 


	sksegment_ctor_fn_t     skr_seg_ctor;   
	sksegment_dtor_fn_t     skr_seg_dtor;   
	uint32_t                skr_seg_objs;   
	uint32_t                skr_seg_bmap_len; 
	size_t                  skr_seg_bmap_size;
	bitmap_t                *__sized_by(skr_seg_bmap_size) skr_seg_bmap;  
	uint32_t                skr_seg_free_cnt; 
	uint32_t                skr_hash_initial; 
	uint32_t                skr_hash_limit; 
	uint32_t                skr_hash_shift; 
	uint32_t                skr_hash_mask;  
	size_t                  skr_hash_size;
	struct sksegment_bkt    *__counted_by(skr_hash_size) skr_hash_table; 
	TAILQ_HEAD(segfreehead, sksegment) skr_seg_free; 
	RB_HEAD(segtfreehead, sksegment) skr_seg_tfree; 
	uint32_t                skr_seg_waiters; 

	uint32_t                skr_refcnt;     

	struct skmem_region     *skr_mirror;
};
struct flowidns_flowid_tree_node {
	RB_ENTRY(flowidns_flowid_tree_node) fftn_link;
	struct flowidns_flow_key            fftn_flowkey;
	flowidns_flowid_t                   fftn_flowid;
};
struct flowidns_domain {
	decl_lck_mtx_data(, fd_mtx);
	struct flowidns_flowid_tree    fd_flowid_tree;
	uint32_t                       fd_id;
	uint64_t                       fd_nallocs;
	uint64_t                       fd_nreleases;
	uint64_t                       fd_ncollisions;
};
struct flowidns_flow_key {
	union {
		struct in_addr  _v4;
		struct in6_addr _v6;
	} ffk_laddr; 
	union {
		struct in_addr  _v4;
		struct in6_addr _v6;
	} ffk_raddr; 
	union {
		struct {
			uint16_t _lport; 
			uint16_t _rport; 
		} ffk_ports;
		uint32_t ffk_spi; 
		uint32_t ffk_protoid; 
	};
	uint8_t ffk_af; 
	uint8_t ffk_proto; 
};
struct ns_reservation {
	RB_ENTRY(ns_reservation) nsr_link;
	uint32_t nsr_refs[NETNS_OWNER_MAX + 1];
	in_port_t nsr_port;
	bool nsr_reuseport:1;
};
struct ns {
	RB_ENTRY(ns)    ns_link;

	void            *ns_addr_key;

	union {
		uint32_t        ns_addr[4];
		struct in_addr  ns_inaddr;
		struct in6_addr ns_in6addr;
	};
	uint8_t         ns_addr_len;
	uint8_t         ns_proto;

	in_port_t       ns_last_ephemeral_port_down;
	in_port_t       ns_last_ephemeral_port_up;

	uint8_t         ns_is_freeable;

	uint32_t        ns_n_reservations;
	struct ns_reservation_tree ns_reservations;
};
struct ns_token {
	ifnet_t                 nt_ifp;
	LIST_ENTRY(ns_token)    nt_ifp_link;
	LIST_ENTRY(ns_token)    nt_all_link;
	uint32_t                nt_state;       

	union {
		uint32_t        nt_addr[4];
		struct in_addr  nt_inaddr;
		struct in6_addr nt_in6addr;
	};
	uint8_t                 nt_addr_len;
	uint8_t                 nt_proto;
	in_port_t               nt_port;
	uint32_t                nt_flags;

	struct ns_flow_info     *nt_flow_info;
};
struct ns_flow_info {
	uuid_t                  nfi_flow_uuid
	__attribute((aligned(sizeof(uint64_t))));

	struct ifnet            *nfi_ifp;       
	union sockaddr_in_4_6   nfi_laddr;      
	union sockaddr_in_4_6   nfi_faddr;      
	uint8_t                 nfi_protocol;   
	uint8_t                 nfi_pad[3];     
	pid_t                   nfi_owner_pid;
	pid_t                   nfi_effective_pid;
	char                    nfi_owner_name[MAXCOMLEN + 1];
	char                    nfi_effective_name[MAXCOMLEN + 1];
};
struct protons_token {
	RB_ENTRY(protons_token) pt_link;
	os_refcnt_t             pt_refcnt;
	pid_t                   pt_pid;
	pid_t                   pt_epid;
	uint8_t                 pt_protocol;
	uint8_t                 pt_flags;
};
struct nexus_pkt_stats {
	uint64_t nps_pkts;
	uint64_t nps_bytes;
};
struct nexus_adapter {
	volatile uint32_t               na_flags;       
	nexus_adapter_type_t            na_type;        
	const nexus_meta_type_t         na_md_type;     
	const nexus_meta_subtype_t      na_md_subtype;  

	nexus_port_t na_nx_port;

	uint32_t na_channels;

	uint32_t na_num_rx_rings;
	uint32_t na_num_tx_rings;

	uint32_t na_num_allocator_ring_pairs;

	uint32_t na_num_event_rings;

	uint32_t na_num_large_buf_alloc_rings;

	uint32_t na_rx_rings_cnt;
	uint32_t na_tx_rings_cnt;
	uint32_t na_alloc_free_rings_cnt;
	uint32_t na_event_rings_cnt;
	uint32_t na_large_buf_alloc_rings_cnt;
	uint32_t na_slot_ctxs_cnt;
	uint32_t na_scratch_cnt;
	uint32_t na_all_rings_cnt;

	uint64_t na_work_ts;            

	struct __kern_channel_ring *__counted_by(na_tx_rings_cnt) na_tx_rings; 
	struct __kern_channel_ring *__counted_by(na_rx_rings_cnt) na_rx_rings; 
	struct __kern_channel_ring *__counted_by(na_all_rings_cnt) na_all_rings;

	struct kern_nexus *na_nx;

	volatile uint32_t na_refcount;

	int na_si_users[NR_ALL];         
	struct ch_selinfo na_si[NR_ALL]; 

	struct skmem_arena *na_arena;

	uint32_t na_num_tx_slots;
	uint32_t na_num_rx_slots;
	uint32_t na_num_allocator_slots;
	uint32_t na_num_event_slots;
	uint32_t na_num_large_buf_alloc_slots;

	uint32_t na_total_slots;

	const uint32_t na_flowadv_max;  

	const nexus_stats_type_t na_stats_type; 

	struct __kern_channel_ring *__counted_by(na_alloc_free_rings_cnt)na_alloc_rings;
	struct __kern_channel_ring *__counted_by(na_alloc_free_rings_cnt)na_free_rings;
	struct __kern_channel_ring *__counted_by(na_event_rings_cnt)na_event_rings;
	struct __kern_channel_ring *__counted_by(na_large_buf_alloc_rings_cnt)na_large_buf_alloc_rings;

	uint64_t na_ch_mit_ival;        

	struct kern_nexus_domain_provider *na_nxdom_prov;

	struct slot_ctx *__counted_by(na_slot_ctxs_cnt)na_slot_ctxs;

	kern_packet_t *__counted_by(na_scratch_cnt)na_scratch;

	struct __kern_channel_ring *__counted_by(0) na_tail; 

	void *na_private;

	struct ifnet *na_ifp;
	uint8_t na_kring_svc_lut[KPKT_SC_MAX_CLASSES];


	char na_name[NEXUS_ADAPTER_NAMELEN];    
	uuid_t na_uuid;

	int (*na_activate)(struct nexus_adapter *, na_activate_mode_t);
	int (*na_special)(struct nexus_adapter *, struct kern_channel *,
	    struct chreq *, nxspec_cmd_t);
	int (*na_txsync)(struct __kern_channel_ring *kring, struct proc *,
	    uint32_t flags);
	int (*na_rxsync)(struct __kern_channel_ring *kring, struct proc *,
	    uint32_t flags);

	int (*na_notify)(struct __kern_channel_ring *kring, struct proc *,
	    uint32_t flags);

	int (*na_channel_event_notify)(struct nexus_adapter *,
	    struct __kern_channel_event *, uint16_t);
	int (*na_config)(struct nexus_adapter *,
	    uint32_t *txr, uint32_t *txd, uint32_t *rxr, uint32_t *rxd);
	int (*na_krings_create)(struct nexus_adapter *, struct kern_channel *);
	void (*na_krings_delete)(struct nexus_adapter *, struct kern_channel *,
	    boolean_t);
	void (*na_dtor)(struct nexus_adapter *);
	void (*na_free)(struct nexus_adapter *);

	void (*na_rx)(struct nexus_adapter *,
	    struct __kern_packet *, struct nexus_pkt_stats *);
};
struct nxctl_add_traffic_rule_inet_iocargs {
	char atri_ifname[IFNAMSIZ];
	struct ifnet_traffic_descriptor_inet atri_td;
	struct ifnet_traffic_rule_action_steer atri_ra;
	uint32_t atri_flags;
	uuid_t atri_uuid;
};
struct nxctl_remove_traffic_rule_iocargs {
	uuid_t rtr_uuid;
};
struct nxctl_traffic_rule_generic_iocinfo {
	uuid_t trg_uuid;
	char trg_procname[NTR_PROCNAME_SZ];
	char trg_ifname[IFNAMSIZ];
};
struct nxctl_traffic_rule_inet_iocinfo {
	struct nxctl_traffic_rule_generic_iocinfo tri_common;
	struct ifnet_traffic_descriptor_inet tri_td;
	struct ifnet_traffic_rule_action_steer tri_ra;
};
struct nxctl_get_traffic_rules_iocargs {
	uint8_t gtr_type;
	uint32_t gtr_size;
	uint32_t gtr_count;
	union {
		void *gtr_buf;
		uint64_t gtr_buf64;
	};
};
struct nx_mbq {
	decl_lck_mtx_data(, nx_mbq_lock);
	class_queue_t           nx_mbq_q;
	lck_grp_t               *nx_mbq_grp;
	struct __kern_channel_ring *nx_mbq_kring;
};
struct nx_pktq {
	decl_lck_mtx_data(, nx_pktq_lock);
	class_queue_t           nx_pktq_q;
	lck_grp_t               *nx_pktq_grp;
	struct __kern_channel_ring *nx_pktq_kring;
};
struct nxctl_traffic_rule_type {
	uint8_t ntrt_type;
	nxctl_traffic_rule_validate_cb_t *ntrt_validate;
	nxctl_traffic_rule_find_cb_t *ntrt_find;
	nxctl_traffic_rule_find_by_uuid_cb_t *ntrt_find_by_uuid;
	nxctl_traffic_rule_link_cb_t *ntrt_link;
	nxctl_traffic_rule_unlink_cb_t *ntrt_unlink;
	nxctl_traffic_rule_notify_cb_t *ntrt_notify;
	nxctl_traffic_rule_create_cb_t *ntrt_create;
	nxctl_traffic_rule_destroy_cb_t *ntrt_destroy;
	nxctl_traffic_rule_get_all_cb_t *ntrt_get_all;
	struct nxctl_traffic_rule_inet_storage *ntrt_storage;
};
struct nxctl_traffic_rule {
	struct nxctl_traffic_rule_type *ntr_type;
	uint32_t ntr_flags;
	os_refcnt_t ntr_refcnt;
	uuid_t ntr_uuid;
	char ntr_procname[NTR_PROCNAME_SZ];
	char ntr_ifname[IFNAMSIZ];
	SLIST_ENTRY(nxctl_traffic_rule) ntr_storage_link;
};
struct nxctl_traffic_rule_inet {
	struct nxctl_traffic_rule ntri_common;
	SLIST_ENTRY(nxctl_traffic_rule_inet) ntri_storage_link;
	struct ifnet_traffic_descriptor_inet ntri_td;
	struct ifnet_traffic_rule_action_steer ntri_ra;
};
struct nxctl_traffic_rule_inet_if {
	char rii_ifname[IFNAMSIZ];
	struct nxctl_traffic_rule_inet_head rii_lists[NINETRULEMASKS];
	uint32_t rii_count;
	SLIST_ENTRY(nxctl_traffic_rule_inet_if) rii_link;
};
struct nxctl_traffic_rule_inet_storage {
	struct nxctl_traffic_rule_inet_if_head ris_if_list;
	uint32_t ris_count;
};
struct nxctl_traffic_rule_storage {
	struct nxctl_traffic_rule_head rs_list;
	uint32_t rs_count;
};
struct nxctl {
	decl_lck_mtx_data(, nxctl_lock);
	uint32_t                nxctl_refcnt;
	uint32_t                nxctl_flags;
	uuid_t                  nxctl_uuid;
	uuid_t                  nxctl_proc_uuid;
	uint64_t                nxctl_proc_uniqueid;
	STAILQ_ENTRY(nxctl)     nxctl_link;
	struct fileproc         *nxctl_fp;
	kauth_cred_t            nxctl_cred;
	struct nxctl_traffic_rule_storage *nxctl_traffic_rule_storage;
};
struct nxbind {
	uint32_t                nxb_flags;
	pid_t                   nxb_pid;
	uint64_t                nxb_uniqueid;
	uuid_t                  nxb_exec_uuid;
	uint32_t                nxb_key_len;
	void                    *__sized_by(nxb_key_len) nxb_key;
};
struct nx_port_info {
	uintptr_t               npi_nah;
	struct nxbind           *npi_nxb;
	void                    *npi_info;
};
struct nx_port_info_header {
	nx_port_info_type_t     ih_type;
	size_t                  ih_size;
};
struct kern_nexus_advisory {
	struct skmem_region     *nxv_reg;
	void                    *__sized_by(nxv_adv_size) nxv_adv;
	nexus_advisory_type_t   nxv_adv_type;
	union {
		struct sk_nexusadv             *flowswitch_nxv_adv;
		struct netif_nexus_advisory    *netif_nxv_adv;
	};
	uint32_t                nxv_adv_size;
};
struct kern_nexus {
	uint32_t                nx_refcnt;
	volatile uint32_t       nx_flags;
	void                    *nx_ctx;
	nexus_ctx_release_fn_t  nx_ctx_release;
	struct kern_nexus_provider *nx_prov;
	uint64_t                nx_id;
	uuid_t                  nx_uuid;
	STAILQ_ENTRY(kern_nexus) nx_prov_link;
	RB_ENTRY(kern_nexus)    nx_link;
	STAILQ_HEAD(, kern_channel) nx_ch_head;
	uint32_t                nx_ch_count;
	STAILQ_HEAD(, kern_channel) nx_ch_nonxref_head;
	decl_lck_rw_data(, nx_ch_if_adv_lock);
	STAILQ_HEAD(, kern_channel) nx_ch_if_adv_head;
	void                    *nx_arg;
	struct kern_pbufpool    *nx_rx_pp;
	struct kern_pbufpool    *nx_tx_pp;
	struct kern_nexus_advisory nx_adv;

	struct nx_port_info     *__counted_by(nx_num_ports) nx_ports;
	bitmap_t                *__sized_by(nx_ports_bmap_size) nx_ports_bmap;
	nexus_port_size_t       nx_active_ports;
	nexus_port_size_t       nx_num_ports;
	size_t                  nx_ports_bmap_size;
};
struct kern_nexus_provider {
	uint32_t                        nxprov_refcnt;
	uint32_t                        nxprov_flags;
	STAILQ_ENTRY(kern_nexus_provider) nxprov_link;
	STAILQ_HEAD(, kern_nexus)       nxprov_nx_head;
	uint32_t                        nxprov_nx_count;
	struct nxctl                    *nxprov_ctl;
	uuid_t                          nxprov_uuid;
	struct kern_nexus_domain_provider *nxprov_dom_prov;
	union {
		struct kern_nexus_provider_init nxprov_ext;
		struct kern_nexus_netif_provider_init nxprov_netif_ext;
	};
	struct nxprov_params            *nxprov_params;
	struct skmem_region_params      nxprov_region_params[SKMEM_REGIONS];
};
struct kern_nexus_domain_provider {
	STAILQ_ENTRY(kern_nexus_domain_provider) nxdom_prov_link;
	STAILQ_ENTRY(kern_nexus_domain_provider) nxdom_prov_detaching_link;
	char                    nxdom_prov_name[64];
	uuid_t                  nxdom_prov_uuid;
	uint64_t                nxdom_prov_gencnt;
	uint32_t                nxdom_prov_refcnt;
	uint32_t                nxdom_prov_flags;
	struct nxdom            *nxdom_prov_dom;
	struct kern_nexus_domain_provider_init nxdom_prov_ext;
	struct nxdom_prov_cb {
		int (*dp_cb_init)(struct kern_nexus_domain_provider *);
		void (*dp_cb_fini)(struct kern_nexus_domain_provider *);
		int (*dp_cb_params)(struct kern_nexus_domain_provider *,
		    const uint32_t, const struct nxprov_params *,
		    struct nxprov_params *,
		    struct skmem_region_params[SKMEM_REGIONS], uint32_t);
		int (*dp_cb_mem_new)(struct kern_nexus_domain_provider *,
		    struct kern_nexus *, struct nexus_adapter *);
		int (*dp_cb_config)(struct kern_nexus_domain_provider *,
		    struct kern_nexus *, struct nx_cfg_req *, int,
		    struct proc *, kauth_cred_t);
		int (*dp_cb_nx_ctor)(struct kern_nexus *);
		void (*dp_cb_nx_dtor)(struct kern_nexus *);
		int (*dp_cb_nx_mem_info)(struct kern_nexus *,
		    struct kern_pbufpool **, struct kern_pbufpool **);
		size_t (*dp_cb_nx_mib_get)(struct kern_nexus *,
		    struct nexus_mib_filter *, void *, size_t, struct proc *);
		int (*dp_cb_nx_stop)(struct kern_nexus *);
	} nxdom_prov_cb;
};
struct nxp_bounds {
	uint32_t        nb_def;
	uint32_t        nb_min;
	uint32_t        nb_max;
};
struct nxdom {
	STAILQ_ENTRY(nxdom) nxdom_link;
	STAILQ_HEAD(, kern_nexus_domain_provider) nxdom_prov_head;
	nexus_type_t    nxdom_type;
	nexus_meta_type_t nxdom_md_type;
	nexus_meta_subtype_t nxdom_md_subtype;
	uint32_t        nxdom_flags;
	struct nxp_bounds nxdom_ports;
	struct nxp_bounds nxdom_tx_rings;
	struct nxp_bounds nxdom_rx_rings;
	struct nxp_bounds nxdom_tx_slots;
	struct nxp_bounds nxdom_rx_slots;
	struct nxp_bounds nxdom_buf_size;
	struct nxp_bounds nxdom_large_buf_size;
	struct nxp_bounds nxdom_meta_size;
	struct nxp_bounds nxdom_stats_size;
	struct nxp_bounds nxdom_pipes;
	struct nxp_bounds nxdom_extensions;
	struct nxp_bounds nxdom_mhints;
	struct nxp_bounds nxdom_flowadv_max;
	struct nxp_bounds nxdom_nexusadv_size;
	struct nxp_bounds nxdom_capabilities;
	struct nxp_bounds nxdom_qmap;
	struct nxp_bounds nxdom_max_frags;
	struct skmem_region_params nxdom_region_params[SKMEM_REGIONS];
	const char      *nxdom_name;

	void (*nxdom_init)(struct nxdom *);             
	void (*nxdom_terminate)(struct nxdom *);        
	void (*nxdom_fini)(struct nxdom *);             
	int (*nxdom_find_port)                          
	(struct kern_nexus *, boolean_t, nexus_port_t *);
	boolean_t (*nxdom_port_is_reserved)             
	(struct kern_nexus *, nexus_port_t);
	int (*nxdom_bind_port)                          
	(struct kern_nexus *, nexus_port_t *, struct nxbind *, void *);
	int (*nxdom_unbind_port)                        
	(struct kern_nexus *, nexus_port_t);
	int (*nxdom_connect)                            
	(struct kern_nexus_domain_provider *, struct kern_nexus *,
	struct kern_channel *, struct chreq *, struct kern_channel *,
	struct nxbind *, struct proc *);
	void (*nxdom_disconnect)                        
	(struct kern_nexus_domain_provider *, struct kern_nexus *,
	struct kern_channel *);
	void (*nxdom_defunct)                           
	(struct kern_nexus_domain_provider *, struct kern_nexus *,
	struct kern_channel *, struct proc *);
	void (*nxdom_defunct_finalize)                  
	(struct kern_nexus_domain_provider *, struct kern_nexus *,
	struct kern_channel *, boolean_t);
};
struct nxprov_adjusted_params {
	nexus_meta_subtype_t *adj_md_subtype;
	uint32_t *adj_stats_size;
	uint32_t *adj_flowadv_max;
	uint32_t *adj_nexusadv_size;
	uint32_t *adj_caps;
	uint32_t *adj_tx_rings;
	uint32_t *adj_rx_rings;
	uint32_t *adj_tx_slots;
	uint32_t *adj_rx_slots;
	uint32_t *adj_alloc_rings;
	uint32_t *adj_free_rings;
	uint32_t *adj_alloc_slots;
	uint32_t *adj_free_slots;
	uint32_t *adj_buf_size;
	uint32_t *adj_buf_region_segment_size;
	uint32_t *adj_pp_region_config_flags;
	uint32_t *adj_max_frags;
	uint32_t *adj_event_rings;
	uint32_t *adj_event_slots;
	uint32_t *adj_max_buffers;
	uint32_t *adj_large_buf_size;
};
struct nexus_mdata {
	union {
		uuid_t          __uuid;         
		uint8_t         __val8[16];
		uint16_t        __val16[8];
		uint32_t        __val32[4];
		uint64_t        __val64[2];
	} __flowid_u;
} nexus_mdata_t __attribute((aligned(8)));
struct nxctl_init {
	uint32_t        ni_version;     
	uint32_t        __ni_align;     
	guardid_t       ni_guard;       
};
struct nxprov_params {
	nexus_name_t    nxp_name;       
	uint32_t        nxp_namelen;    
	nexus_type_t    nxp_type;       
	nexus_meta_type_t nxp_md_type;  
	nexus_meta_subtype_t nxp_md_subtype; 
	uint32_t        nxp_flags;      
	uint32_t        nxp_format;     
	uint32_t        nxp_tx_rings;   
	uint32_t        nxp_rx_rings;   
	uint32_t        nxp_tx_slots;   
	uint32_t        nxp_rx_slots;   
	uint32_t        nxp_buf_size;   
	uint32_t        nxp_meta_size;  
	uint32_t        nxp_stats_size; 
	uint32_t        nxp_pipes;      
	nexus_extension_t nxp_extensions;  
	uint32_t        nxp_mhints;        
	uint32_t        nxp_ifindex;       
	uint32_t        nxp_flowadv_max;   
	nexus_qmap_type_t nxp_qmap;        
	uint32_t        nxp_capabilities;  
	uint32_t        nxp_nexusadv_size; 
	uint32_t        nxp_max_frags;     
	boolean_t       nxp_reject_on_close;
	uint32_t        nxp_large_buf_size;   
} __attribute__((aligned(64)));
struct nxprov_reg {
	uint32_t        nxpreg_version;         
	uint32_t        nxpreg_requested;       
	struct nxprov_params nxpreg_params;     
};
struct nxprov_reg_ent {
	uuid_t          npre_prov_uuid;         
	struct nxprov_params npre_prov_params;  
};
struct nxprov_list_req {
	uint32_t                nrl_num_regs;   
	uint32_t                __nrl_align;    
	user_addr_t             nrl_regs;       
};
struct nx_list_req {
	uuid_t                  nl_prov_uuid;   
	uint32_t                nl_num_nx_uuids; 
	uint32_t                __nl_align;     
	user_addr_t             nl_nx_uuids;    
};
struct nx_bind_req {
	uuid_t                  nb_nx_uuid;     
	nexus_port_t            nb_port;        
	uint32_t                nb_flags;       
	uuid_t                  nb_exec_uuid;   
	user_addr_t             nb_key;         
	uint32_t                nb_key_len;     
	pid_t                   nb_pid;         
};
struct nx_unbind_req {
	uuid_t                  nu_nx_uuid;     
	nexus_port_t            nu_port;        
};
struct ch_list_req {
	uuid_t                  cl_nx_uuid;     
	uint32_t                cl_num_ch_uuids; 
	uint32_t                __cl_align;     
	user_addr_t             cl_ch_uuids;    
};
struct nexus_mib_filter {
	uint32_t                nmf_type;       
	uint64_t                nmf_bitmap;     

	uuid_t                  nmf_nx_uuid;    
	uuid_t                  nmf_flow_id;    
	pid_t                   nmf_pid;        
	struct info_tuple       nmf_info_tuple; 
};
struct nx_cfg_req {
	uuid_t                  nc_nx_uuid;     
	nxcfg_cmd_t             nc_cmd;         
	uint32_t                nc_req_len;     
	user_addr_t             nc_req;         
};
struct nx_spec_req {
	union {
		char            nsru_name[NX_SPEC_IF_NAMELEN];
		uuid_t          nsru_uuid;
		struct ifnet    *nsru_ifp;
	} nsr_u __attribute__((aligned(sizeof(uint64_t))));     
	uint32_t                nsr_flags;                      
	uuid_t                  nsr_if_uuid;    
};
struct flow_demux_pattern {
	uint16_t                fdp_offset;
	uint16_t                fdp_len;
	uint8_t                 fdp_mask[FLOW_DEMUX_MAX_LEN];
	uint8_t                 fdp_value[FLOW_DEMUX_MAX_LEN];
};
struct nx_flow_req {
	nexus_port_t                    nfr_nx_port;
	uint16_t                        nfr_ethertype;
	ether_addr_t                    nfr_etheraddr;
	union sockaddr_in_4_6           nfr_saddr;
	union sockaddr_in_4_6           nfr_daddr;
	uint8_t                         nfr_ip_protocol;
	uint8_t                         nfr_transport_protocol;
	uint16_t                        nfr_flags;
	uuid_t                          nfr_flow_uuid;
	packet_svc_class_t              nfr_svc_class;
	uuid_t                          nfr_euuid;
	uint32_t                        nfr_policy_id;
	uint32_t                        nfr_skip_policy_id;
	pid_t                           nfr_epid;
	flowadv_idx_t                   nfr_flowadv_idx;
	uuid_t                          nfr_bind_key;
	uint64_t                        nfr_qset_id;
	uuid_t                          nfr_parent_flow_uuid;
	uint8_t                         nfr_flow_demux_count;
	struct flow_demux_pattern       nfr_flow_demux_patterns[MAX_FLOW_DEMUX_PATTERN];
	union {
		struct {
			char                    _nfr_kernel_field_start[0];
			void                    *nfr_context;
			struct proc             *nfr_proc;
			struct ifnet            *nfr_ifp;
			struct flow_route       *nfr_route;
			struct ns_token         *nfr_port_reservation;
			struct protons_token    *nfr_proto_reservation;
			struct flow_stats       *nfr_flow_stats;
			pid_t                   nfr_pid;
			uint32_t                nfr_saddr_gencnt;
			void                    *nfr_ipsec_reservation;
			uint32_t                nfr_inp_flowhash;
			uint8_t                 _nfr_kernel_pad[4];
			char                    _nfr_kernel_field_end[0];
		};
		struct {
			uint8_t                 _nfr_opaque[80];
			
			char                    _nfr_common_field_end[0];
		};
	};
};
struct flow_ip_addr {
	union {
		struct in_addr  _v4;
		struct in6_addr _v6;
		uint8_t         _addr8[16];
		uint16_t        _addr16[8];
		uint32_t        _addr32[4];
		uint64_t        _addr64[2];
	};
};
struct flow_key {
	uint16_t                fk_mask;
	uint8_t                 fk_ipver;
	uint8_t                 fk_proto;
	uint16_t                fk_sport;
	uint16_t                fk_dport;
	struct flow_ip_addr     fk_src;
	struct flow_ip_addr     fk_dst;
	uint64_t                fk_pad[1];      
} __attribute__((__aligned__(16)));
struct nx_qset_info {
	uint64_t        nqi_id;
	uint16_t        nqi_flags;
	uint8_t         nqi_num_rx_queues;
	uint8_t         nqi_num_tx_queues;
};
struct nx_llink_info {
	uuid_t          nli_netif_uuid;            
	uint64_t        nli_link_id;
	uint16_t        nli_link_id_internal;
	uint8_t         nli_state;
	uint8_t         nli_flags;
	uint16_t        nli_qset_cnt;
	struct nx_qset_info nli_qset[NETIF_LLINK_MAX_QSETS];
};
struct nx_llink_info_req {
	uint16_t        nlir_version;
	uint16_t        nlir_llink_cnt;
	struct nx_llink_info nlir_llink[__counted_by(nlir_llink_cnt)];
};
struct nexus_controller {
};
struct nexus_attr {
	uint64_t        nxa_requested;  
	uint64_t        nxa_tx_rings;   
	uint64_t        nxa_rx_rings;   
	uint64_t        nxa_tx_slots;   
	uint64_t        nxa_rx_slots;   
	uint64_t        nxa_buf_size;   
	uint64_t        nxa_meta_size;  
	uint64_t        nxa_stats_size; 
	uint64_t        nxa_anonymous;  
	uint64_t        nxa_pipes;      
	uint64_t        nxa_extensions; 
	uint64_t        nxa_mhints;     
	uint64_t        nxa_ifindex;    
	uint64_t        nxa_flowadv_max; 
	uint64_t        nxa_qmap;       
	uint64_t        nxa_checksum_offload;   
	uint64_t        nxa_user_packet_pool;   
	uint64_t        nxa_nexusadv_size;      
	uint64_t        nxa_user_channel;       
	uint64_t        nxa_max_frags;  
	uint64_t        nxa_reject_on_close;
	uint64_t        nxa_large_buf_size;  
};
struct packet_id {
	uint8_t     pktid_version;
	uint8_t     pktid_payload_type;
	uint16_t    pktid_sequence_number;
	uint32_t    pktid_timestamp;
	uint32_t    pktid_stream_identifier;
	uint32_t    _reserved;
} packet_id_t;
struct __flow {
	union {
		
		struct __flow_init {
			
			struct __flow_l3 {
				union {
					struct __flow_l3_ipv4_addrs {
						struct in_addr _src;
						struct in_addr _dst;
					} _l3_ipv4;
					struct __flow_l3_ipv6_addrs {
						struct in6_addr _src;
						struct in6_addr _dst;
					} _l3_ipv6;
				};
				uint8_t  _l3_ip_ver;
				uint8_t  _l3_proto;
				uint8_t  _l3_hlen;
				unsigned _l3_is_frag : 1;
				unsigned _l3_is_first_frag : 1;
				unsigned _l3_reserved_flags : 6;
				uint32_t _l3_frag_id;
				mach_vm_address_t _l3_ptr;
			} __l3;
			
			struct __flow_classq {
				uint32_t _fcq_hash;  
				uint32_t _fcq_flags; 
			} __classq;
			
			uint32_t __ulen;      
			uint8_t  __ulp_encap; 
			uint8_t  __pad[3];
			uint64_t __pad64[2];
			
			struct __flow_source {
				union {
					
					uint64_t _fsrc_id_64[2];
					uint32_t _fsrc_id_32[4];
					uuid_t   _fsrc_id;
				} __attribute__((aligned(sizeof(uint64_t))));
				flowadv_idx_t _fsrc_fidx; 
				uint8_t       _fsrc_type; 
				uint8_t       _fsrc_pad[3];
			} __source;
			
			struct __flow_policy {
				uint32_t _fpc_id; 
				uint32_t _fpc_skip_id; 
				union {
					
					uint64_t _fpc_euuid_64[2];
					uint32_t _fpc_euuid_32[4];
					uuid_t   _fpc_euuid;
				} __attribute__((aligned(sizeof(uint64_t))));
			} __policy;
		} flow_init;
		uint64_t flow_init_data[16];
	} __attribute((aligned(16)));





	union {
		struct __flow_l4 {
			union {
				struct __flow_l4_tcp {
					in_port_t _src;
					in_port_t _dst;
					uint32_t _seq;
					uint32_t _ack;
					union {
						struct {
							uint8_t _tcp_res:4;
							uint8_t _off:4;
							uint8_t _flags;
							uint16_t _win;
						};
						uint32_t _ofw;
					};
				} _l4_tcp;
				struct __flow_l4_udp {
					in_port_t _src;
					in_port_t _dst;
					uint32_t _ls;
				} _l4_udp;
				struct __flow_l4_esp {
					uint32_t _spi;
				} _l4_esp;
			};
			uint8_t _l4_hlen;
			uint8_t _l4_agg_fast;
			uint8_t _l4_pad[6];
			mach_vm_address_t _l4_ptr;
		} flow_l4;
		uint64_t flow_l4_data[4];
	} __attribute((aligned(sizeof(uint64_t))));
} __attribute((aligned(16)));
struct __buflet {
	union {
		
		uint64_t __buflet_next;
		
		const mach_vm_address_t __nbft_addr;
	};
	const mach_vm_address_t __baddr;
	const obj_idx_t __bft_idx;
	const obj_idx_t __bidx;
	const obj_idx_t __nbft_idx;
	const uint32_t  __dlim;         
	uint32_t        __doff;         
	uint32_t        __dlen;         
	const uint16_t  __flag;
} __attribute((packed));
struct __user_buflet {
	struct __buflet buf_com;
};
struct __metadata_preamble {
	union {
		uint64_t        _mdp_next;      
		uint64_t        mdp_redzone;    
	};
	const obj_idx_t         mdp_idx;        
	uint16_t                mdp_type;       
	uint16_t                mdp_subtype;    
};
struct __quantum {
	union {
		uuid_t          __uuid;         
		uint8_t         __val8[16];
		uint16_t        __val16[8];
		uint32_t        __val32[4];
		uint64_t        __val64[2];
	} __flow_id_u;

	uint32_t                __q_len;

	uint32_t                __q_svc_class;  

	volatile uint16_t       __q_flags;      
	uint16_t                __q_pad[3];
} __attribute((aligned(sizeof(uint64_t))));
struct __user_quantum {
	struct __quantum qum_com;

	struct __user_buflet    qum_buf[1];             
	uint16_t qum_usecnt;
} __attribute((aligned(sizeof(uint64_t))));
struct __packet_com {
	uint16_t __link_flags;                          

	uint8_t __headroom;
	uint8_t __l2_len;

	uint32_t __csum_flags;                          
	union {
		struct {
			uint16_t __csum_start_off;      
			uint16_t __csum_value;          
		} __csum_rx;
		struct {
			uint16_t __csum_start_off;      
			uint16_t __csum_stuff_off;      
		} __csum_tx;
		uint32_t __csum_data;
	};

	uint32_t __comp_gencnt;

	packet_trace_id_t __trace_id;

	uint8_t __aggr_type;                     
	uint8_t __seg_cnt;                       

	uint16_t __proto_seg_sz;                 

	union {
		volatile uint32_t __flags32[2];
		volatile uint64_t __flags;              
	};
} __attribute((aligned(sizeof(uint64_t))));
struct __packet {
	union {
		uint64_t                __pkt_data[4];
		struct __packet_com     __pkt_com;
	};
};
struct __packet_opt_com {
	union {
		uint64_t        __token_data[2];
		uint8_t         __token[PKT_OPT_MAX_TOKEN_SIZE];
	};
	uint64_t        __expire_ts;
	uint64_t        __pkt_tx_time;
	uint16_t        __vlan_tag;
	uint16_t        __token_len;
	uint8_t         __token_type;
	uint8_t         __expiry_action;
	uint8_t         __app_type;
	uint8_t         __app_metadata;
} __attribute((aligned(sizeof(uint64_t))));
struct __packet_opt {
	union {
		uint64_t                __pkt_opt_data[5];
		struct __packet_opt_com __pkt_opt_com;
	};
};
struct __user_packet {
	struct __user_quantum   pkt_qum;



	struct __packet pkt_com;

	struct __packet_opt pkt_com_opt;


	const uint16_t  pkt_bufs_max;       
	const uint16_t  pkt_bufs_cnt;       
} __attribute((aligned(sizeof(uint64_t))));
struct __kern_buflet {
	struct __buflet buf_com;
	const struct skmem_bufctl *buf_ctl;

} __attribute((packed));
struct __kern_buflet_ext {
	struct __kern_buflet kbe_overlay;
	struct __user_buflet const *kbe_buf_user;

	SLIST_ENTRY(__kern_buflet_ext) kbe_buf_upp_link;

	pid_t kbe_buf_pid;
} __attribute((packed));
struct __kern_quantum {
	struct __quantum qum_com;

	SLIST_ENTRY(__kern_quantum)     qum_upp_link;
	const struct kern_pbufpool      *qum_pp;
	const struct __user_quantum     *qum_user;
	const struct __kern_slot_desc   *qum_ksd;
	struct __kern_buflet            qum_buf[1];     
	pid_t                           qum_pid;
} __attribute((aligned(sizeof(uint64_t))));
struct __packet_compl {
	union {
		uint64_t        compl_data64[3];
		struct {
			uintptr_t       _cb_arg;
			uintptr_t       _cb_data;
			uint32_t        _tx_status;
			uint32_t        _pad;
		} compl_data;
	};
	uint8_t        compl_callbacks;
	uint32_t        compl_context;
};
struct __kern_packet {
	struct __kern_quantum   pkt_qum;

	struct __packet         pkt_com;

	struct __packet_opt     *pkt_com_opt;

	uint64_t                pkt_timestamp;

	struct __kern_packet    *pkt_nextpkt;

	union {
		struct mbuf             *pkt_mbuf;
		struct __kern_packet    *pkt_pkt;
	};
	struct __flow           *pkt_flow;       

	struct __packet_compl   *pkt_tx_compl;   

	void *      pkt_priv;   


	const uint16_t  pkt_bufs_max;       
	const uint16_t  pkt_bufs_cnt;       
	uint32_t        pkt_chain_count;    
	uint32_t        pkt_chain_bytes;    

	nexus_port_t    pkt_nx_port;        
	uint16_t        pkt_vpna_gencnt;

	packet_trace_tag_t       pkt_trace_tag;
	uint8_t                  pkt_qset_idx;
	uint8_t                  _pad[1];
} __attribute((aligned(sizeof(uint64_t))));
struct kern_pbufpool_u_htbl {
	struct kern_pbufpool_u_bkt upp_hash[KERN_PBUFPOOL_U_HASH_SIZE];
};
struct kern_pbufpool_u_bkt {
	SLIST_HEAD(, __kern_quantum) upp_head;
};
struct kern_pbufpool_u_bft_bkt {
	SLIST_HEAD(, __kern_buflet_ext) upp_head;
};
struct kern_pbufpool {
	decl_lck_mtx_data(, pp_lock);
	uint32_t                pp_refcnt;
	uint32_t                pp_flags;
	uint32_t                pp_buf_obj_size[PBUFPOOL_MAX_BUF_REGIONS];
	uint32_t                pp_buf_size[PBUFPOOL_MAX_BUF_REGIONS];
	uint16_t                pp_max_frags;

	struct skmem_cache      *pp_buf_cache[PBUFPOOL_MAX_BUF_REGIONS];
	struct skmem_cache      *pp_kmd_cache;
	struct skmem_cache      *pp_kbft_cache[PBUFPOOL_MAX_BUF_REGIONS];

	struct skmem_region     *pp_buf_region[PBUFPOOL_MAX_BUF_REGIONS];
	struct skmem_region     *pp_kmd_region;
	struct skmem_region     *pp_umd_region;
	struct skmem_region     *pp_ubft_region;
	struct skmem_region     *pp_kbft_region;

	struct kern_pbufpool_u_bkt *__counted_by(pp_u_hash_table_size) pp_u_hash_table;
	uint64_t                pp_u_bufinuse;

	struct kern_pbufpool_u_bft_bkt *__counted_by(pp_u_bft_hash_table_size) pp_u_bft_hash_table;
	uint64_t                pp_u_bftinuse;

	void                    *pp_ctx;
	pbuf_ctx_retain_fn_t    pp_ctx_retain;
	pbuf_ctx_release_fn_t   pp_ctx_release;
	nexus_meta_type_t       pp_md_type;
	nexus_meta_subtype_t    pp_md_subtype;
	uint32_t                pp_midx_start;
	uint32_t                pp_bidx_start;
	pbufpool_name_t         pp_name;
	pbuf_seg_ctor_fn_t      pp_pbuf_seg_ctor;
	pbuf_seg_dtor_fn_t      pp_pbuf_seg_dtor;

	uint32_t                pp_u_hash_table_size;
	uint32_t                pp_u_bft_hash_table_size;
};
struct ipf {
	struct ipf      *ipf_down;
	struct ipf      *ipf_up;
	struct __kern_packet *ipf_pkt;
	int             ipf_len;        
	int             ipf_off;        
	uint16_t        ipf_mff;        
};
struct ipf_key {
	uint64_t        ipfk_addr[4];   
	uint32_t        ipfk_ident;     
	uint16_t        ipfk_len;       
};
struct ipfq {
	struct ipf      *ipfq_down;     
	struct ipf      *ipfq_up;
	struct ipfq     *ipfq_next;     
	struct ipfq     *ipfq_prev;
	uint64_t        ipfq_timestamp; 
	struct ipf_key  ipfq_key;       
	uint16_t        ipfq_nfrag;     
	int             ipfq_unfraglen; 
	bool            ipfq_is_dirty;  
};
struct fsw_ip_frag_mgr {
	struct skoid    ipfm_skoid;
	struct ipfq     ipfm_q;         
	uint32_t        ipfm_q_limit;   
	uint32_t        ipfm_q_count;   
	uint32_t        ipfm_f_limit;   
	uint32_t        ipfm_f_count;   
	decl_lck_mtx_data(, ipfm_lock); 
	thread_call_t   ipfm_timeout_tcall;     

	struct ifnet    *ipfm_ifp;
	struct fsw_stats *ipfm_stats;   
};
struct nexus_vp_adapter {
	struct nexus_adapter vpna_up;

	struct nx_flowswitch *vpna_fsw;
	nexus_port_t    vpna_nx_port;
	uint16_t        vpna_gencnt;
	boolean_t       vpna_retry;
	boolean_t       vpna_pid_bound;
	boolean_t       vpna_defunct;
	pid_t           vpna_pid;
};
struct nx_flowswitch {
	decl_lck_rw_data(, fsw_lock);
	uint32_t                fsw_tx_rings;
	uint32_t                fsw_rx_rings;

	struct kern_nexus       *fsw_nx;

	classq_pkt_type_t       fsw_classq_enq_ptype;
	boolean_t               fsw_classq_enabled;

	pkt_copy_from_pkt_t     *fsw_pkt_copy_from_pkt;
	pkt_copy_from_mbuf_t    *fsw_pkt_copy_from_mbuf;
	pkt_copy_to_mbuf_t      *fsw_pkt_copy_to_mbuf;

	uint8_t                 fsw_frame_headroom;
	uint32_t                fsw_src_lla_gencnt;
	uint32_t                fsw_pending_nonviable;
	uint32_t                fsw_low_power_gencnt;

	struct flow_mgr         *fsw_flow_mgr;
	netagent_session_t      fsw_agent_session;
	uuid_t                  fsw_agent_uuid;
	struct ifnet            *fsw_ifp;        
	struct nexus_adapter    *fsw_nifna;      
	uint32_t                fsw_state_flags; 


	union {
		uint64_t _buf[1];
		uint8_t _eth_src[ETHER_ADDR_LEN];
	} __fsw_slladdr __attribute((aligned(sizeof(uint64_t))));


	int (*fsw_resolve)(struct nx_flowswitch *, struct flow_route *,
	    struct __kern_packet *);
	void (*fsw_frame)(struct nx_flowswitch *, struct flow_route *,
	    struct __kern_packet *);
	sa_family_t (*fsw_demux)(struct nx_flowswitch *,
	    struct __kern_packet *);

	struct fsw_stats        fsw_stats;

	decl_lck_mtx_data(, fsw_detach_barrier_lock);
	uint32_t                fsw_detach_flags;        
	uint32_t                fsw_detach_barriers;
	uint32_t                fsw_detach_waiters;

	uint32_t                fsw_ifp_dlt;

	uint32_t                fsw_rx_largest_size;

	void (*fsw_ctor)(struct nx_flowswitch *, struct flow_route *);

	struct __nx_stats_fsw   *fsw_closed_na_stats;

	struct fsw_ip_frag_mgr  *fsw_ipfm;

	struct skoid            fsw_skoid;

	struct netem            *fsw_input_netem;

	struct kern_channel     *fsw_dev_ch;
	struct kern_channel     *fsw_host_ch;

	decl_lck_mtx_data(, fsw_reap_lock);
	uint32_t                fsw_reap_flags;  
	uint32_t                fsw_reap_requests;
	struct thread           *fsw_reap_thread;
	char                    fsw_reap_name[MAXTHREADNAMESIZE];

	uint64_t                fsw_reap_last;
	uint64_t                fsw_drain_channel_chk_last;
	uint64_t                fsw_drain_netif_chk_last;
	uint64_t                fsw_rx_stall_chk_last;

	decl_lck_mtx_data(, fsw_linger_lock);
	struct flow_entry_linger_head fsw_linger_head;
	uint32_t                fsw_linger_cnt;

	fsw_tso_mode_t          fsw_tso_mode;
	uint32_t                fsw_tso_sw_mtu;
	uint32_t                fsw_tso_hw_v4_mtu;
	uint32_t                fsw_tso_hw_v6_mtu;

};
struct filter_pktq {
	struct __kern_packet *fp_head;
	struct __kern_packet **fp_tailp;
};
struct netif_list_flowtable {
	struct netif_flow_head  lft_flow_list;
};
struct netif_gso_ip_tcp_state {
	void (*update)(struct netif_gso_ip_tcp_state*,
	    struct __kern_packet *pkt, uint8_t *__bidi_indexable baddr);
	void (*internal)(struct netif_gso_ip_tcp_state*, uint32_t partial,
	    uint16_t payload_len, uint32_t *csum_flags);
	union {
		struct ip *ip;
		struct ip6_hdr *ip6;
	} hdr;
	int af;
	struct tcphdr *tcp;
	struct kern_pbufpool *pp;
	uint32_t psuedo_hdr_csum;
	uint32_t tcp_seq;
	uint16_t hlen;
	uint16_t mss;
	uint16_t ip_id;
	uint8_t mac_hlen;
	uint8_t ip_hlen;
	uint8_t tcp_hlen;
	boolean_t copy_data_sum;
};
struct flow_agg {
	union {
		struct {
			union {
				void *          _fa_sobj;
				struct mbuf *   _fa_smbuf;      
				struct __kern_packet *_fa_spkt; 
			};
			uint8_t *__indexable _fa_sptr;        
			bool     _fa_sobj_is_pkt; 
			
			bool     _fa_sobj_is_short;
			uint32_t _fa_tcp_seq;     
			uint32_t _fa_ulen;        
			uint32_t _fa_total;       
			
			flow_agg_fix_pkt_sum_func _fa_fix_pkt_sum;
		} __flow_agg;
		uint64_t __flow_agg_data[5];
	};
};
struct ip_tcp_mask {
	struct ip       ip_m;
	struct tcphdr   tcp_m;
	uint32_t        tcp_option_m[MAX_TCPOPTLEN / sizeof(uint32_t)];
};
struct ip6_tcp_mask {
	struct ip6_hdr  ip6_m;
	struct tcphdr   tcp_m;
	uint32_t        tcp_option_m[5]; 
};
struct _dbuf_array {
	union {
		struct __kern_buflet *dba_buflet[MAX_BUFLET_COUNT];
		struct mbuf *dba_mbuf[MAX_BUFLET_COUNT];
	};
	uint8_t dba_num_dbufs;
	bool dba_is_buflet;
} _dbuf_array_t;
struct flow_owner_bucket {
	decl_lck_mtx_data(, fob_lock);
	struct flow_owner_tree  fob_owner_head;
	uint16_t                fob_busy_flags;
	uint16_t                fob_open_waiters;
	uint16_t                fob_close_waiters;
	uint16_t                fob_dtor_waiters;
	const size_t            fob_idx;
};
struct flow_owner {
	RB_ENTRY(flow_owner)    fo_link;
	struct flow_entry_id_tree fo_flow_entry_id_head;
	const struct flow_owner_bucket *fo_bucket;
	void                    *fo_context;
	pid_t                   fo_pid;
	bool                    fo_nx_port_pid_bound;
	bool                    fo_nx_port_destroyed;
	bool                    fo_low_latency;
	nexus_port_t            fo_nx_port;
	uuid_t                  fo_key;

	struct nexus_adapter *  const fo_nx_port_na;
	struct nx_flowswitch *  const fo_fsw;

	bitmap_t                *__counted_by(fo_num_flowadv_bmaps)fo_flowadv_bmap;
	uint32_t                fo_flowadv_max;
	uint32_t                fo_num_flowadv;
	uint32_t                fo_num_flowadv_bmaps;

	char                    fo_name[FLOW_PROCESS_NAME_LENGTH];
};
struct flow_track_rtt {
	uint64_t        frtt_timestamp; 
	uint64_t        frtt_last;      
	uint32_t        frtt_seg_begin; 
	uint32_t        frtt_seg_end;   
	uint32_t        frtt_usec;      
};
struct flow_track {
	uint32_t fse_seqlo;     
	uint32_t fse_seqhi;     
	uint32_t fse_seqlast;   
	uint16_t fse_max_win;   
	uint16_t fse_mss;       
	uint8_t fse_state;      
	uint8_t fse_wscale;     
	uint16_t fse_flags;     
	uint32_t fse_syn_ts;    
	uint32_t fse_syn_cnt;   

	struct flow_track_rtt   fse_rtt;        
} __sk_aligned(8);
struct flow_llhdr {
	uint32_t                flh_gencnt;     

	const uint8_t           flh_off;
	const uint8_t           flh_len;
	uint16_t                flh_pad;        

	union _flh_u {
		uint64_t        _buf[2];
		struct {
			uint16_t _eth_pad;
			struct ether_header _eth;
		} _eth_padded;
	}  __sk_aligned(8)      _flh;
};
struct kern_flow_demux_pattern {
	struct flow_demux_pattern  fdp_demux_pattern;
	flow_demux_memcmp_mask_t   fdp_memcmp_mask;
};
struct flow_entry {
	os_refcnt_t             fe_refcnt;
	struct flow_key         fe_key;
	uint32_t                fe_flags;
	uint32_t                fe_key_hash;
	struct cuckoo_node      fe_cnode;

	uuid_t                  fe_uuid __sk_aligned(8);
	nexus_port_t            fe_nx_port;
	uint32_t                fe_laddr_gencnt;
	uint32_t                fe_want_nonviable;
	uint32_t                fe_want_withdraw;
	uint8_t                 fe_transport_protocol;

	uint16_t                fe_rx_frag_count;
	uint32_t                fe_rx_pktq_bytes;
	decl_lck_mtx_data(, fe_rx_pktq_lock);
	struct pktq             fe_rx_pktq;
	TAILQ_ENTRY(flow_entry) fe_rx_link;
	flow_rx_action_t        fe_rx_process;
	uint64_t                fe_rx_worker_tid;

	uint32_t                fe_rx_largest_size;

	bool                    fe_tx_is_cont_frag;
	uint32_t                fe_tx_frag_id;
	struct pktq             fe_tx_pktq;
	TAILQ_ENTRY(flow_entry) fe_tx_link;
	flow_tx_action_t        fe_tx_process;

	uuid_t                  fe_eproc_uuid __sk_aligned(8);
	flowadv_idx_t           fe_adv_idx;
	kern_packet_svc_class_t fe_svc_class;
	uint32_t                fe_policy_id;   
	uint32_t                fe_skip_policy_id; 

	struct nx_flowswitch *  const fe_fsw;
	struct ns_token         *fe_port_reservation;
	struct protons_token    *fe_proto_reservation;
	void                    *fe_ipsec_reservation;

	struct flow_track       fe_ltrack;      
	struct flow_track       fe_rtrack;      

	struct flow_stats       *fe_stats;
	struct flow_route       *fe_route;

	RB_ENTRY(flow_entry)    fe_id_link;

	TAILQ_ENTRY(flow_entry) fe_linger_link;
	uint64_t                fe_linger_expire; 
	uint32_t                fe_linger_wait;   

	pid_t                   fe_pid;
	pid_t                   fe_epid;
	char                    fe_proc_name[FLOW_PROCESS_NAME_LENGTH];
	char                    fe_eproc_name[FLOW_PROCESS_NAME_LENGTH];

	uint32_t                fe_flowid; 

	struct netif_qset      *fe_qset;
	uint64_t                fe_qset_id;
	flow_qset_select_t      fe_qset_select;
	uint32_t                fe_tr_genid;

	decl_lck_rw_data(, fe_child_list_lock);
	struct flow_entry_list          fe_child_list;
	TAILQ_ENTRY(flow_entry)         fe_child_link;
	uint8_t                         fe_demux_pattern_count;
	struct kern_flow_demux_pattern  *__counted_by(fe_demux_pattern_count)fe_demux_patterns;
	uint8_t                         *__sized_by_or_null(FLOW_DEMUX_MAX_LEN) fe_demux_pkt_data;
};
struct flow_entry_dead {
	LIST_ENTRY(flow_entry_dead)     fed_link;

	boolean_t               fed_want_nonviable;
	boolean_t               fed_want_clonotify;

	union {
		uint64_t        fed_uuid_64[2];
		uint32_t        fed_uuid_32[4];
		uuid_t          fed_uuid;
	} __sk_aligned(8);
};
struct flow_route {
	RB_ENTRY(flow_route)    fr_link;
	RB_ENTRY(flow_route)    fr_id_link;

	union sockaddr_in_4_6   fr_laddr;       
	union sockaddr_in_4_6   fr_faddr;       
	union sockaddr_in_4_6   fr_gaddr;       

	struct flow_llhdr       fr_llhdr;

	void                    *fr_addr_key;

	uuid_t                  fr_uuid __sk_aligned(8);

	decl_lck_spin_data(, fr_reflock);
	uint64_t                fr_expire;
	volatile uint32_t       fr_usecnt;

	uint32_t                fr_flags;
	uint32_t                fr_laddr_gencnt; 
	uint32_t                fr_addr_len;     

	volatile uint32_t       fr_want_configure;
	volatile uint32_t       fr_want_probe;

	decl_lck_mtx_data(, fr_lock);

	eventhandler_tag        fr_rt_evhdlr_tag;
	struct rtentry          *fr_rt_dst;
	struct rtentry          *fr_rt_gw;

	uuid_t                  fr_nx_uuid __sk_aligned(8);

	const struct flow_mgr   *fr_mgr;
	const struct flow_route_bucket  *fr_frb;
	const struct flow_route_id_bucket *fr_frib;
};
struct flow_route_bucket {
	decl_lck_rw_data(, frb_lock);
	struct flow_route_tree  frb_head;
	const uint32_t          frb_idx;
};
struct flow_route_id_bucket {
	decl_lck_rw_data(, frib_lock);
	struct flow_route_id_tree       frib_head;
	const uint32_t                  frib_idx;
};
struct flow_mgr {
	char            fm_name[IFNAMSIZ];
	uuid_t          fm_uuid;
	RB_ENTRY(flow_mgr) fm_link;

	struct cuckoo_hashtable *fm_flow_table;
	size_t   fm_flow_hash_count[FKMASK_IDX_MAX]; 
	uint16_t fm_flow_hash_masks[FKMASK_IDX_MAX];

	void      *__sized_by(fm_owner_bucket_tot_sz) fm_owner_buckets;     
	size_t    fm_owner_buckets_cnt;  
	size_t    fm_owner_bucket_sz;    
	size_t    fm_owner_bucket_tot_sz; 

	void      *__sized_by(fm_route_bucket_tot_sz) fm_route_buckets;     
	size_t    fm_route_buckets_cnt;  
	size_t    fm_route_bucket_sz;    
	size_t    fm_route_bucket_tot_sz; 

	void      *__sized_by(fm_route_id_bucket_tot_sz) fm_route_id_buckets;    
	size_t    fm_route_id_buckets_cnt; 
	size_t    fm_route_id_bucket_sz;   
	size_t    fm_route_id_bucket_tot_sz; 
};
struct mac_audit_record {
	int type;               
	int length;             
	u_char *data;           
	LIST_ENTRY(mac_audit_record) records;
};
struct mhdr {
	size_t                   mh_size;
	au_malloc_type_t        *mh_type;
	u_long                   mh_magic;
	char                     mh_data[0];
};
struct  au_malloc_type {
	SInt64           mt_size;
	SInt64           mt_maxsize;
	SInt32           mt_inuse;
	SInt32           mt_maxused;
	unsigned         mt_type;
	unsigned         mt_magic;
	const char      *mt_shortdesc;
	const char      *mt_lastcaller;
};
struct cv {
	const char      *cv_description;
	int              cv_waiters;
};
struct mtx {
	lck_mtx_t       *mtx_lock;
};
struct rwlock {
	lck_rw_t        *rw_lock;
};
struct slck {
	lck_mtx_t       *sl_mtx;
	int              sl_locked;
	int              sl_waiting;
};
struct rlck {
	lck_mtx_t       *rl_mtx;
	uint32_t         rl_recurse;
	thread_t         rl_thread;
};
struct bsm_domain {
	u_short bd_bsm_domain;
	int     bd_local_domain;
};
struct bsm_errno {
	int              be_bsm_errno;
	int              be_local_errno;
};
struct bsm_fcntl_cmd {
	u_short bfc_bsm_fcntl_cmd;
	int     bfc_local_fcntl_cmd;
};
struct evclass_elem {
	au_event_t event;
	au_class_t class;
	LIST_ENTRY(evclass_elem) entry;
};
struct evclass_list {
	LIST_HEAD(, evclass_elem) head;
};
struct bsm_socket_type {
	u_short bst_bsm_socket_type;
	int     bst_local_socket_type;
};
struct auditpipe_ioctl_preselect {
	au_id_t         aip_auid;
	au_mask_t       aip_mask;
};
struct audit_pipe_entry {
	void                            *ape_record;
	u_int                            ape_record_len;
	TAILQ_ENTRY(audit_pipe_entry)    ape_queue;
};
struct audit_pipe_preselect {
	au_id_t                                  app_auid;
	au_mask_t                                app_mask;
	TAILQ_ENTRY(audit_pipe_preselect)        app_list;
};
struct audit_pipe {
	int                              ap_open;       
	u_int                            ap_flags;

	struct selinfo                   ap_selinfo;
	pid_t                            ap_sigio;

	struct mtx                       ap_mtx;

	struct slck                      ap_sx;

	struct cv                        ap_cv;

	u_int                            ap_qlen;
	u_int                            ap_qlimit;
	u_int                            ap_qbyteslen;
	u_int                            ap_qoffset;

	u_int64_t                        ap_inserts;    
	u_int64_t                        ap_reads;      
	u_int64_t                        ap_drops;      

	int                              ap_preselect_mode;
	au_mask_t                        ap_preselect_flags;
	au_mask_t                        ap_preselect_naflags;
	TAILQ_HEAD(, audit_pipe_preselect)      ap_preselect_list;

	TAILQ_HEAD(, audit_pipe_entry)   ap_queue;

	TAILQ_ENTRY(audit_pipe)          ap_list;
};
struct vnode_au_info {
	mode_t  vn_mode;
	uid_t   vn_uid;
	gid_t   vn_gid;
	dev_t   vn_dev;
	long    vn_fsid;
	long    vn_fileid;
	long    vn_gen;
};
struct groupset {
	gid_t   gidset[NGROUPS];
	u_int   gidset_size;
};
struct socket_au_info {
	int                     sai_domain;
	int                     sai_type;
	int                     sai_protocol;

	struct sockaddr_storage sai_faddr;

	struct sockaddr_storage sai_laddr;
};
struct  au_qctrl64 {
	u_int64_t               aq64_hiwater;
	u_int64_t               aq64_lowater;
	u_int64_t               aq64_bufsz;
	u_int64_t               aq64_delay;
	int64_t                 aq64_minfree;
};
struct posix_ipc_perm {
	uid_t   pipc_uid;
	gid_t   pipc_gid;
	mode_t  pipc_mode;
};
struct au_identity_info {
	u_int32_t       signer_type;
	char            *signing_id;
	u_char          signing_id_trunc;
	char            *team_id;
	u_char          team_id_trunc;
	u_int8_t        *cdhash;
	u_int16_t       cdhash_len;
};
struct audit_record {
	u_int32_t               ar_magic;
	int                     ar_event;
	int                     ar_retval; 
	int                     ar_errno;  
	struct timespec         ar_starttime;
	struct timespec         ar_endtime;
	u_int64_t               ar_valid_arg;  

	struct xucred           ar_subj_cred;
	uid_t                   ar_subj_ruid;
	gid_t                   ar_subj_rgid;
	gid_t                   ar_subj_egid;
	uid_t                   ar_subj_auid; 
	pid_t                   ar_subj_asid; 
	pid_t                   ar_subj_pid;
	struct au_tid           ar_subj_term;
	struct au_tid_addr      ar_subj_term_addr;
	struct au_mask          ar_subj_amask;

	uid_t                   ar_arg_euid;
	uid_t                   ar_arg_ruid;
	uid_t                   ar_arg_suid;
	gid_t                   ar_arg_egid;
	gid_t                   ar_arg_rgid;
	gid_t                   ar_arg_sgid;
	pid_t                   ar_arg_pid;
	pid_t                   ar_arg_asid;
	struct au_tid           ar_arg_termid;
	struct au_tid_addr      ar_arg_termid_addr;
	uid_t                   ar_arg_uid;
	uid_t                   ar_arg_auid;
	gid_t                   ar_arg_gid;
	struct groupset         ar_arg_groups;
	int                     ar_arg_fd;
	int                     ar_arg_fflags;
	mode_t                  ar_arg_mode;
	uint32_t                ar_arg_value32;
	uint64_t                ar_arg_value64;
	user_addr_t             ar_arg_addr;
	user_size_t             ar_arg_len;
	int                     ar_arg_mask;
	u_int                   ar_arg_signum;
	char                    ar_arg_login[MAXLOGNAME];
	int                     ar_arg_ctlname[CTL_MAXNAME];
	struct socket_au_info   ar_arg_sockinfo;
	char                    *ar_arg_upath1;
	char                    *ar_arg_upath2;
	char                    *ar_arg_kpath1;         
	char                    *ar_arg_kpath2;         
	char                    *ar_vnode1_mac_labels;
	char                    *ar_vnode2_mac_labels;
	char                    *ar_cred_mac_labels;
	char                    *ar_arg_mac_string;
	char                    *ar_arg_text;
	void                    *ar_arg_opaque;         
	void                    *ar_arg_data;           
	u_int16_t               ar_arg_opq_size;        
	u_char                  ar_arg_data_type;       
	u_char                  ar_arg_data_count;      
	struct au_mask          ar_arg_amask;
	struct vnode_au_info    ar_arg_vnode1;
	struct vnode_au_info    ar_arg_vnode2;
	int                     ar_arg_cmd;
	int                     ar_arg_svipc_cmd;
	struct ipc_perm         ar_arg_svipc_perm;
	int                     ar_arg_svipc_id;
	user_addr_t             ar_arg_svipc_addr;
	struct posix_ipc_perm   ar_arg_pipc_perm;
	mach_port_name_t        ar_arg_mach_port1;      
	mach_port_name_t        ar_arg_mach_port2;      
	union auditon_udata     ar_arg_auditon;
	char                    *ar_arg_argv;
	int                     ar_arg_argc;
	char                    *ar_arg_envv;
	int                     ar_arg_envc;
	int                     ar_arg_exitstatus;
	int                     ar_arg_exitretval;
	struct sockaddr_storage ar_arg_sockaddr;
	int                     ar_arg_fd2;

	LIST_HEAD(mac_audit_record_list_t, mac_audit_record)    * ar_mac_records;
	int                     ar_forced_by_mac;
	struct au_identity_info ar_arg_identity;
};
struct kaudit_record {
	struct audit_record              k_ar;
	u_int32_t                        k_ar_commit;
	void                            *k_udata;       
	u_int                            k_ulen;        
	struct uthread                  *k_uthread;     
	TAILQ_ENTRY(kaudit_record)       k_q;
};
struct au_sentry {
	auditinfo_addr_t        se_auinfo;      

	long                    se_refcnt;      
	long                    se_procnt;      
	ipc_port_t              se_port;        
	union {
		LIST_ENTRY(au_sentry)   se_link;        
		struct smr_node         se_smr_node;
	};
};
struct au_history {
	struct au_sentry        *ptr;
	struct au_sentry         se;
	void                    *stack[AU_HISTORY_MAX_STACK_DEPTH];
	unsigned int             stack_depth;
	au_history_event_t       event;
};
struct  audit_sdev_entry {
	void                            *ase_record;
	u_int                            ase_record_len;
	TAILQ_ENTRY(audit_sdev_entry)    ase_queue;
};
struct audit_sdev {
	int             asdev_open;


	u_int           asdev_flags;

	struct selinfo  asdev_selinfo;
	pid_t           asdev_sigio;

	au_id_t         asdev_auid;
	au_asid_t       asdev_asid;

	struct mtx      asdev_mtx;

	struct slck     asdev_sx;

	struct cv       asdev_cv;

	u_int           asdev_qlen;
	u_int           asdev_qlimit;

	u_int           asdev_qbyteslen;

	u_int           asdev_qoffset;

	u_int64_t       asdev_inserts;  
	u_int64_t       asdev_reads;    
	u_int64_t       asdev_drops;    

	TAILQ_HEAD(, audit_sdev_entry)  asdev_queue;

	TAILQ_ENTRY(audit_sdev)         asdev_list;
};
struct au_sentry_debug {
	auditinfo_addr_t        se_auinfo;
	int64_t                 se_refcnt;      
	int64_t                 se_procnt;      
	int64_t                 se_ptcnt;       
};
struct crypt_walker_ctx {
	size_t length;
	const struct ccmode_cbc *ccmode;
	cccbc_ctx *crypt_ctx;
	cccbc_iv *iv;
} *crypt_walker_ctx_t;
struct hmac_walker_ctx {
	const struct ccdigest_info *di;
	struct cchmac_ctx *hmac_ctx;
} *hmac_walker_ctx_t;
struct gss_cfx_mic_token_desc_struct {
	uint8_t TOK_ID[2];      
	uint8_t Flags;
	uint8_t Filler[5];
	uint8_t SND_SEQ[8];
} gss_cfx_mic_token_desc, *gss_cfx_mic_token;
struct gss_cfx_wrap_token_desc_struct {
	uint8_t TOK_ID[2];      
	uint8_t Flags;
	uint8_t Filler;
	uint8_t EC[2];
	uint8_t RRC[2];
	uint8_t SND_SEQ[8];
} gss_cfx_wrap_token_desc, *gss_cfx_wrap_token;
struct gss_1964_mic_token_desc_struct {
	uint8_t TOK_ID[2];      
	uint8_t Sign_Alg[2];
	uint8_t Filler[4];      
} gss_1964_mic_token_desc, *gss_1964_mic_token;
struct gss_1964_wrap_token_desc_struct {
	uint8_t TOK_ID[2];      
	uint8_t Sign_Alg[2];
	uint8_t Seal_Alg[2];
	uint8_t Filler[2];      
} gss_1964_wrap_token_desc, *gss_1964_wrap_token;
struct gss_1964_delete_token_desc_struct {
	uint8_t TOK_ID[2];      
	uint8_t Sign_Alg[2];
	uint8_t Filler[4];      
} gss_1964_delete_token_desc, *gss_1964_delete_token;
struct gss_1964_header_desc_struct {
	uint8_t App0;           
	uint8_t AppLen[];       
} gss_1964_header_desc, *gss_1964_header;
struct gss_1964_token_body_struct {
	uint8_t OIDType;        
	uint8_t OIDLen;         
	uint8_t kerb_mech[9];   
	gss_1964_tok_type body;
	uint8_t SND_SEQ[8];
	uint8_t Hash[];         
} gss_1964_token_body_desc, *gss_1964_token_body;
struct lucid_key {
	uint32_t etype;
	struct {
		uint32_t key_len;
		uint8_t *key_val;
	} key;
};
struct key_data_1964 {
	uint32_t sign_alg;
	uint32_t seal_alg;
};
struct key_data_4121 {
	uint32_t acceptor_subkey;
};
struct lucid_protocol {
	uint32_t proto;
	union {
		key_data_1964 data_1964;
		key_data_4121 data_4121;
	} lucid_protocol_u;
};
struct lucid_context {
	uint32_t vers;
	uint32_t initiate;
	uint32_t endtime;
	uint64_t send_seq;
	uint64_t recv_seq;
	lucid_protocol key_data;
	lucid_key ctx_key;
};
struct lucid_context_version {
	uint32_t        version;
} *lucid_context_version_t;
struct krb5_key {
	void   *key_val;
	size_t key_len;
} krb5_key_t;
struct key_schedule {
	cccbc_ctx *enc;
	cccbc_ctx *dec;
	krb5_key_t ikeys[2];  
};
struct crypto_ctx {
	uint32_t etype;
	uint32_t flags;
	size_t mpad;             
	lck_mtx_t lock;
	lucid_context_t gss_ctx;  
	void *key;   
	const struct ccdigest_info *di;
	const struct ccmode_cbc *enc_mode;
	const struct ccmode_cbc *dec_mode;
	struct key_schedule ks;
	uint32_t digest_size;
	uint32_t keylen;
	krb5_key_t ckeys[2];  
} *crypto_ctx_t;
struct gss_ctx_id_desc {
	lucid_context  gss_lucid_ctx;
	struct crypto_ctx  gss_cryptor;
} *gss_ctx_id_t;
struct gss_buffer_desc_struct {
	size_t length;
	void *value;
} gss_buffer_desc, *gss_buffer_t;
struct hmac_ctx_struct {
	size_t keylen;
	uint8_t *key;
	ccdigest_ctx_t di_ctx;
} hmac_ctx, hmac_ctx_t[1];
struct classq_pkt {
	union {
		struct mbuf             *cp_mbuf;       
	};
	classq_pkt_type_t       cp_ptype;
} classq_pkt_t;
struct pktcntr {
	u_int64_t       packets;
	u_int64_t       bytes;
};
struct _class_queue_ {
	union {
		MBUFQ_HEAD(mq_head) __mbufq; 
	} __pktq_u;
	u_int32_t       qlen;   
	u_int32_t       qlim;   
	u_int64_t       qsize;  
	classq_type_t   qtype;  
	classq_state_t  qstate; 
	classq_pkt_type_t       qptype; 
} class_queue_t;
struct blue_stats {
	int32_t                 q_pmark;
	u_int32_t               _pad;
	u_int64_t               drop_forced;
	u_int64_t               drop_unforced;
	u_int64_t               marked_packets;
};
struct flowq {
#pragma pack(push,1)
	union {
		MBUFQ_HEAD(mbufq_head) __mbufq; 
	} __fq_pktq_u;
#pragma pack(pop)
	uint32_t       fq_flowhash;    
	uint32_t       fq_bytes;       
	int32_t        fq_deficit;     
	fq_if_group_t  *fq_group;          
	uint8_t        fq_flags;       
	uint8_t        fq_sc_index; 
	bool           fq_in_dqlist;
	fq_tfc_type_t  fq_tfc_type;
	uint8_t        __fq_pad_uint8[4];
	uint64_t       fq_min_qdelay; 
	uint64_t       fq_getqtime;    
	uint32_t       fq_pkts_since_last_report;
	uint64_t       fq_next_tx_time;
	union {
		uint64_t   fq_updatetime; 
		
		uint64_t   fq_empty_purge_time;
	};
	LIST_ENTRY(flowq) fq_hashlink; 
	union {
		STAILQ_ENTRY(flowq) fq_actlink; 
		
		TAILQ_ENTRY(flowq) fq_empty_link;
	};
	STAILQ_ENTRY(flowq) fq_dqlink;
	classq_pkt_t   fq_dq_head;
	classq_pkt_t   fq_dq_tail;
};
struct redparams {
	int th_min;             
	int th_max;             
	int inv_pmax;           
};
struct red_stats {
	int32_t         q_avg;
	u_int32_t       _pad;
	u_int32_t       drop_forced;
	u_int32_t       drop_unforced;
	u_int32_t       marked_packets;
};
struct sfbstats {
	u_int64_t               drop_early;
	u_int64_t               drop_pbox;
	u_int64_t               drop_queue;
	u_int64_t               marked_packets;
	u_int64_t               pbox_packets;
	u_int64_t               pbox_time;
	u_int64_t               hold_time;
	u_int64_t               dequeue_avg;
	u_int64_t               rehash_intval;
	u_int64_t               num_rehash;
	u_int64_t               null_flowid;
	u_int64_t               flow_controlled;
	u_int64_t               flow_feedback;
	u_int64_t               dequeue_stall;
};
struct sfbbinstats {
	int16_t         pmark;          
	u_int16_t       pkts;           
	u_int32_t       bytes;          
};
struct sfb_stats {
	u_int32_t               allocation;
	u_int32_t               dropthresh;
	u_int32_t               clearpkts;
	u_int32_t               current;
	u_int64_t               target_qdelay;
	u_int64_t               update_interval;
	u_int64_t               min_estdelay;
	u_int32_t               delay_fcthreshold;
	u_int32_t               flags;
	struct sfbstats         sfbstats;
	struct sfbbins {
		struct sfbbinstats stats[SFB_LEVELS][SFB_BINS];
	} binstats[2] __attribute__((aligned(8)));
};
struct sfb_bins {
	u_int32_t               fudge;
	struct sfbbinstats      stats[SFB_LEVELS][SFB_BINS];
	struct timespec         freezetime[SFB_LEVELS][SFB_BINS];
};
struct sfb_fcl {
	u_int32_t               cnt;
	struct flowadv_fclist   fclist;
};
struct sfb {
	u_int32_t       sfb_flags;      
	u_int32_t       sfb_qlim;
	u_int32_t       sfb_qid;
	u_int16_t       sfb_allocation;
	u_int16_t       sfb_drop_thresh;
	u_int32_t       sfb_clearpkts;
	u_int64_t       sfb_eff_rate;   
	struct timespec sfb_getqtime;   
	struct timespec sfb_holdtime;   
	struct ifnet    *sfb_ifp;       

	u_int64_t       sfb_target_qdelay;
	struct timespec sfb_update_interval;
	u_int64_t       sfb_fc_threshold; 

	u_int64_t       sfb_min_qdelay;
	struct timespec sfb_update_time;

	struct timespec sfb_hinterval;  
	struct timespec sfb_nextreset;  

	struct timespec sfb_pboxtime;   
	struct timespec sfb_pboxfreeze;

	u_int32_t       sfb_current;    
	struct sfb_bins (*sfb_bins)[ 2];

	struct sfb_fcl  (*sfb_fc_lists)[ SFB_BINS];

	struct sfbstats sfb_stats __attribute__((aligned(8)));
} sfb_t;
struct cqrq_purge_sc {
	mbuf_svc_class_t        sc;     
	u_int32_t               flow;   
	u_int32_t               packets; 
	u_int32_t               bytes;  
} cqrq_purge_sc_t;
struct cqrq_throttle {
	u_int32_t               set;    
	u_int32_t               level;  
} cqrq_throttle_t;
struct cqrq_stat_sc {
	mbuf_svc_class_t        sc;     
	u_int8_t                grp_idx; 
	u_int32_t               packets; 
	u_int32_t               bytes;  
} cqrq_stat_sc_t;
struct tb_regulator {
	u_int64_t       tbr_rate_raw;   
	u_int32_t       tbr_percent;    
	int64_t         tbr_rate;       
	int64_t         tbr_depth;      

	int64_t         tbr_token;      
	int64_t         tbr_filluptime; 
	u_int64_t       tbr_last;       

};
struct tb_profile {
	u_int64_t       rate;   
	u_int32_t       percent; 
	u_int32_t       depth;  
};
struct ifclassq {
	decl_lck_mtx_data(, ifcq_lock);

	os_refcnt_t     ifcq_refcnt;
	struct ifnet    *ifcq_ifp;      
	u_int32_t       ifcq_len;       
	u_int32_t       ifcq_maxlen;
	struct pktcntr  ifcq_xmitcnt;
	struct pktcntr  ifcq_dropcnt;

	u_int32_t       ifcq_type;      
	u_int32_t       ifcq_flags;     
	u_int32_t       ifcq_sflags;    
	u_int32_t       ifcq_target_qdelay; 
	u_int32_t       ifcq_bytes;     
	u_int32_t       ifcq_pkt_drop_limit;
	uint64_t        ifcq_doorbells;
	void            *ifcq_disc;     
	struct ifclassq_disc_slot {
		u_int32_t       qid;
		void            *cl;
	} ifcq_disc_slots[IFCQ_SC_MAX]; 

	struct tb_regulator     ifcq_tbr;       
};
struct if_ifclassq_stats {
	u_int32_t       ifqs_len;
	u_int32_t       ifqs_maxlen;
	uint64_t        ifqs_doorbells;
	struct pktcntr  ifqs_xmitcnt;
	struct pktcntr  ifqs_dropcnt;
	u_int32_t       ifqs_scheduler;
	struct fq_codel_classstats      ifqs_fq_codel_stats;
} __attribute__((aligned(8)));
struct aqm_tag_container {
	struct m_tag            aqm_m_tag;
	uint64_t                aqm_tag;
};
struct _pktsched_pkt_ {
	classq_pkt_t            __pkt;
	classq_pkt_t            __tail;
	uint32_t                __plen;
	uint32_t                __pcnt;
} pktsched_pkt_t;
struct callout {
	void            *c_arg;                 
	void            (*c_func)(void *);      
};
struct cbq_classstats {
	u_int32_t       handle;
	u_int32_t       depth;

	struct pktcntr  xmit_cnt;       
	struct pktcntr  drop_cnt;       
	u_int32_t       over;           
	u_int32_t       borrows;        
	u_int32_t       overactions;    
	u_int32_t       delays;         

	int             priority;
	int             maxidle;
	int             minidle;
	int             offtime;
	int             qmax;
	int             ns_per_byte;
	int             wrr_allot;

	int             qcnt;           
	int             avgidle;

	classq_type_t   qtype;
	union {
		
		struct red_stats        red[RIO_NDROPPREC];
		struct blue_stats       blue;
		struct sfb_stats        sfb;
	};
	classq_state_t  qstate;
} class_stats_t;
struct fairq_classstats {
	u_int32_t               class_handle;
	u_int32_t               priority;

	u_int32_t               qlength;
	u_int32_t               qlimit;
	struct pktcntr          xmit_cnt;  
	struct pktcntr          drop_cnt;  

	classq_type_t           qtype;
	union {
		
		struct red_stats        red[RIO_NDROPPREC];
		struct blue_stats       blue;
		struct sfb_stats        sfb;
	};
	classq_state_t          qstate;
};
struct fcl_stat {
	u_int32_t fcl_flow_control;
	u_int32_t fcl_flow_feedback;
	u_int32_t fcl_dequeue_stall;
	u_int32_t fcl_flow_control_fail;
	u_int64_t fcl_drop_overflow;
	u_int64_t fcl_drop_early;
	u_int32_t fcl_drop_memfailure;
	u_int32_t fcl_flows_cnt;
	u_int32_t fcl_newflows_cnt;
	u_int32_t fcl_oldflows_cnt;
	u_int64_t fcl_pkt_cnt;
	u_int64_t fcl_dequeue;
	u_int64_t fcl_dequeue_bytes;
	u_int64_t fcl_byte_cnt;
	u_int32_t fcl_throttle_on;
	u_int32_t fcl_throttle_off;
	u_int32_t fcl_throttle_drops;
	u_int32_t fcl_dup_rexmts;
	u_int32_t fcl_pkts_compressible;
	u_int32_t fcl_pkts_compressed;
	uint64_t fcl_min_qdelay;
	uint64_t fcl_max_qdelay;
	uint64_t fcl_avg_qdelay;
	uint32_t fcl_overwhelming;
	uint64_t fcl_ce_marked;
	uint64_t fcl_ce_reported;
	uint64_t fcl_ce_mark_failures;
	uint64_t fcl_l4s_pkts;
	uint64_t fcl_ignore_tx_time;
	uint64_t fcl_paced_pkts;
	uint64_t fcl_fcl_pacemaker_needed;
};
struct fq_if_classq {
	uint32_t fcl_pri;      
	uint32_t fcl_service_class;    
	uint32_t fcl_quantum;          
	uint32_t fcl_drr_max;          
	int64_t  fcl_budget;             
	uint64_t fcl_next_tx_time;      
	flowq_stailq_t fcl_new_flows;   
	flowq_stailq_t fcl_old_flows;   
	struct fcl_stat fcl_stat;
	uint8_t fcl_flags;
} fq_if_classq_t;
struct fq_codel_classq_group {
	uint64_t                fqg_target_qdelays[FQ_TFC_CNT];
	uint64_t                fqg_update_intervals[FQ_TFC_CNT];
	pktsched_bitmap_t       fqg_bitmaps[FQ_IF_MAX_STATE];
	TAILQ_ENTRY(fq_codel_classq_group) fqg_grp_link;
	uint32_t                fqg_bytes;     
	uint32_t                fqg_len;       
	uint8_t                 fqg_flags;     
	uint8_t                 fqg_index;     
	fq_if_classq_t          fqg_classq[FQ_IF_MAX_CLASSES]; 
	struct flowq            *fqg_large_flow; 
} fq_if_group_t;
struct fq_if_bitmap_ops {
	fq_if_bitmaps_ffs       ffs;
	fq_if_bitmaps_zeros     zeros;
	fq_if_bitmaps_cpy       cpy;
	fq_if_bitmaps_clr       clr;
	fq_if_bitmaps_move      move;
} bitmap_ops_t;
struct fq_codel_sched_data {
	struct ifclassq         *fqs_ifq;       
	flowq_list_t            *fqs_flows __counted_by(fqs_flows_count); 
	uint32_t                fqs_flows_count;
	uint32_t                fqs_pkt_droplimit;  
	uint8_t                 fqs_throttle;   
	uint8_t                 fqs_flags;      
	struct flowadv_fclist   fqs_fclist; 
	struct flowq            *fqs_large_flow; 
	TAILQ_HEAD(, flowq)     fqs_empty_list; 
	fq_grp_tailq_t          fqs_combined_grp_list;
	uint32_t                fqs_empty_list_cnt;
	pktsched_bitmap_t       fqs_combined_grp_bitmap;
	classq_pkt_type_t       fqs_ptype;
	thread_call_t           fqs_pacemaker_tcall;
	bitmap_ops_t            *fqs_bm_ops;
	fq_if_group_t           *fqs_classq_groups[FQ_IF_MAX_GROUPS];
} fq_if_t;
struct fq_codel_flowstats {
	u_int32_t       fqst_min_qdelay;
	u_int32_t       fqst_flags;
	u_int32_t       fqst_bytes;
	u_int32_t       fqst_flowhash;
};
struct fq_codel_classstats {
	u_int32_t       fcls_pri;
	u_int32_t       fcls_service_class;
	u_int32_t       fcls_quantum;
	u_int32_t       fcls_drr_max;
	int64_t         fcls_budget;
	u_int64_t       fcls_target_qdelay;
	u_int64_t       fcls_l4s_target_qdelay;
	u_int64_t       fcls_update_interval;
	u_int32_t       fcls_flow_control;
	u_int32_t       fcls_flow_feedback;
	u_int32_t       fcls_dequeue_stall;
	u_int32_t       fcls_flow_control_fail;
	u_int64_t       fcls_drop_overflow;
	u_int64_t       fcls_drop_early;
	u_int32_t       fcls_drop_memfailure;
	u_int32_t       fcls_flows_cnt;
	u_int32_t       fcls_newflows_cnt;
	u_int32_t       fcls_oldflows_cnt;
	u_int64_t       fcls_pkt_cnt;
	u_int64_t       fcls_dequeue;
	u_int64_t       fcls_dequeue_bytes;
	u_int64_t       fcls_byte_cnt;
	u_int32_t       fcls_throttle_on;
	u_int32_t       fcls_throttle_off;
	u_int32_t       fcls_throttle_drops;
	u_int32_t       fcls_dup_rexmts;
	u_int32_t       fcls_flowstats_cnt;
	struct fq_codel_flowstats fcls_flowstats[FQ_IF_MAX_FLOWSTATS];
	u_int32_t       fcls_pkts_compressible;
	u_int32_t       fcls_pkts_compressed;
	uint64_t        fcls_min_qdelay;
	uint64_t        fcls_max_qdelay;
	uint64_t        fcls_avg_qdelay;
	uint32_t        fcls_overwhelming;
	uint64_t        fcls_ce_marked;
	uint64_t        fcls_ce_reported;
	uint64_t        fcls_ce_mark_failures;
	uint64_t        fcls_l4s_pkts;
	uint64_t        fcls_ignore_tx_time;
	uint64_t        fcls_paced_pkts;
	uint64_t        fcls_fcl_pacing_needed;
};
struct service_curve {
	u_int32_t fl;   
	u_int64_t m1;   
	u_int32_t d;    
	u_int64_t m2;   
};
struct hfsc_classstats {
	u_int32_t               class_id;
	u_int32_t               class_handle;
	struct service_curve    rsc;
	struct service_curve    fsc;
	struct service_curve    usc;    

	u_int64_t               total;  
	u_int64_t               cumul;  
	                                
	u_int64_t               d;              
	u_int64_t               e;              
	u_int64_t               vt;             
	u_int64_t               f;              

	u_int64_t               initvt;         
	u_int64_t               vtoff;          
	u_int64_t               cvtmax;         
	u_int64_t               myf;            
	u_int64_t               cfmin;          
	u_int64_t               cvtmin;         
	u_int64_t               myfadj;         
	u_int64_t               vtadj;          
	u_int64_t               cur_time;
	u_int32_t               machclk_freq;

	u_int32_t               qlength;
	u_int32_t               qlimit;
	struct pktcntr          xmit_cnt;
	struct pktcntr          drop_cnt;
	u_int32_t               period;

	u_int32_t               vtperiod;       
	u_int32_t               parentperiod;   
	int                     nactive;        

	classq_type_t           qtype;
	union {
		
		struct red_stats        red[RIO_NDROPPREC];
		struct blue_stats       blue;
		struct sfb_stats        sfb;
	};
	classq_state_t          qstate;
};
struct priq_classstats {
	u_int32_t               class_handle;
	u_int32_t               priority;

	u_int32_t               qlength;
	u_int32_t               qlimit;
	u_int32_t               period;
	struct pktcntr          xmitcnt;  
	struct pktcntr          dropcnt;  

	classq_type_t           qtype;
	union {
		
		struct red_stats        red[RIO_NDROPPREC];
		struct blue_stats       blue;
		struct sfb_stats        sfb;
	};
	classq_state_t          qstate;
};
struct bind_mount {
	struct vnode * bindm_rootvp;       
	struct vnode * bindm_lowerrootvp;  
	uint32_t bindm_lowerrootvid;       
	uint64_t bindm_flags;
};
struct bind_node {
	LIST_ENTRY(bind_node) bind_hash; 
	struct vnode * bind_lowervp;     
	struct vnode * bind_vnode;       
	uint32_t bind_lowervid;          
	uint32_t bind_myvid;
	uint32_t bind_flags;
};
struct vnodeop_desc_fake {
	int vdesc_offset;
	const char * vdesc_name;
};
struct devfs_stats {
	int                 nodes;
	int                 entries;
	int                 mounts;
	int                 stringspace;
};
struct devnode {
	devfstype_t         dn_type;
	os_ref_atomic_t     dn_refcount;
	u_short             dn_mode;
	uid_t               dn_uid;
	gid_t               dn_gid;
	struct timespec     dn_atime;
	struct timespec     dn_mtime;
	struct timespec     dn_ctime;
	int(***dn_ops)(void *);
	int                 dn_links;
	struct devfsmount * dn_dvm; 
	struct vnode *      dn_vn;
	int                 dn_len;
	devdirent_t *       dn_linklist;
	devnode_t *         dn_nextsibling;
	devnode_t * *       dn_prevsiblingp;
	devnode_type_t      dn_typeinfo;
	int                 dn_change;
	int                 dn_update;
	int                 dn_access;
	int                 dn_lflags;
	ino_t               dn_ino;
	int                 (*dn_clone)(dev_t dev, int action);
	struct label *      dn_label;   
};
struct devdirent {
	char                de_name[DEVMAXNAMESIZE];
	devnode_t *         de_dnp;     
	devnode_t *         de_parent;  
	devdirent_t *       de_next;    
	devdirent_t *       *de_prevp;  
	devdirent_t *       de_nextlink;
	devdirent_t *       *de_prevlinkp;
};
struct devfsmount {
	struct mount *      mount;
	devdirent_t *       plane_root;
};
struct devfs_vnode_event {
	vnode_t                 dve_vp;
	uint32_t                dve_vid;
	uint32_t                dve_events;
} *devfs_vnode_event_t;
struct devfs_event_log {
	size_t                  del_max;
	size_t                  del_used;
	devfs_vnode_event_t     del_entries;
} *devfs_event_log_t;
struct fdescnode {
	LIST_ENTRY(fdescnode)   fd_hash;        
	struct vnode            *fd_vnode;      
	fdntype                 fd_type;        
	int                     fd_fd;          
	const char              *fd_link;       
	int                     fd_ix;          
};
struct fifoinfo {
	unsigned int    fi_flags;
	struct socket   *fi_readsock;
	struct socket   *fi_writesock;
	long        fi_readers;
	long        fi_writers;
	unsigned int    fi_count;
};
struct null_mount {
	struct vnode * nullm_rootvp;       
	struct vnode * nullm_secondvp;     
	struct vnode * nullm_lowerrootvp;  
	uint32_t nullm_lowerrootvid;       
	lck_mtx_t nullm_lock;              
	uint64_t nullm_flags;
	uid_t uid;
	gid_t gid;
};
struct null_mount_conf {
	uint64_t flags;
};
struct null_node {
	LIST_ENTRY(null_node) null_hash; 
	struct vnode * null_lowervp;     
	struct vnode * null_vnode;       
	uint32_t null_lowervid;          
	uint32_t null_myvid;
	uint32_t null_flags;
};
struct vnodeop_desc_fake {
	int vdesc_offset;
	const char * vdesc_name;
};
struct routefs_args {
	char    route_path[MAXPATHLEN];
	vnode_t route_rvp; 
};
struct routefs_mount {
	char    route_path[MAXPATHLEN];
	mount_t route_mount;
	vnode_t route_rvp; 
	int route_vpvid; 
};
struct specinfo {
	struct  vnode **si_hashchain;
	struct  vnode *si_specnext;
	long    si_flags;
	dev_t   si_rdev;
	int32_t si_opencount;
	daddr_t si_size;                
	daddr64_t       si_lastr;       
	u_int64_t       si_devsize;     

	u_int8_t        si_initted;
	u_int8_t        si_throttleable;
	u_int16_t       si_isssd;
	u_int32_t       si_devbsdunit;
	u_int64_t       si_throttle_mask;
	thread_t        si_mountingowner;
};
struct _throttle_io_info_t {
	lck_mtx_t       throttle_lock;

	struct timeval  throttle_last_write_timestamp;
	struct timeval  throttle_min_timer_deadline;
	struct timeval  throttle_window_start_timestamp[THROTTLE_LEVEL_END + 1]; 
	struct timeval  throttle_last_IO_timestamp[THROTTLE_LEVEL_END + 1];
	pid_t           throttle_last_IO_pid[THROTTLE_LEVEL_END + 1];
	struct timeval  throttle_start_IO_period_timestamp[THROTTLE_LEVEL_END + 1];
	int32_t throttle_inflight_count[THROTTLE_LEVEL_END + 1];

	TAILQ_HEAD(, uthread) throttle_uthlist[THROTTLE_LEVEL_END + 1];         
	int             throttle_next_wake_level;

	thread_call_t   throttle_timer_call;
	int32_t throttle_timer_ref;
	int32_t throttle_timer_active;

	int32_t throttle_io_count;
	int32_t throttle_io_count_begin;
	int    *throttle_io_periods;
	uint32_t throttle_io_period_num;

	int32_t throttle_refcnt;
	int32_t throttle_alloc;
	int32_t throttle_disabled;
	int32_t throttle_is_fusion_with_priority;
};
struct user_sigframe64 {
	user64_siginfo_t        sinfo;
	struct user_ucontext64  uctx;
	mcontext64_t            mctx;
};
struct user_sigframe32 {
	user32_addr_t           puctx;
	user32_addr_t           token;
	user32_siginfo_t        sinfo;
	struct user_ucontext32  uctx;
	mcontext32_t            mctx;
};
struct arm64_decode_entry {
	uint32_t mask;
	uint32_t value;
	uint8_t type;
};
struct frame {
	struct frame *backchain;
	uintptr_t retaddr;
};
struct xcArg {
	processorid_t   cpu;
	dtrace_xcall_t  f;
	void           *arg;
} xcArg_t;
struct frame {
	struct frame *backchain;
	uintptr_t retaddr;
};
struct blmeta {
	union {
		daddr_t     bmu_avail;  
		u_daddr_t   bmu_bitmap; 
	} u;
	daddr_t         bm_bighint;     
} blmeta_t;
struct blist {
	daddr_t         bl_blocks;      
	daddr_t         bl_radix;       
	daddr_t         bl_skip;        
	daddr_t         bl_free;        
	blmeta_t        *bl_root;       
	daddr_t         bl_rootblks;    
} *blist_t;
struct wrap_timer_call {
	cyc_handler_t           hdlr;
	cyc_time_t              when;
	uint64_t                deadline;
	int                     cpuid;
	boolean_t               suspended;
	struct timer_call       call;

	LIST_ENTRY(wrap_timer_call) entries;
} wrap_timer_call_t;
struct cyc_list {
	cyc_omni_handler_t cyl_omni;
	wrap_timer_call_t cyl_wrap_by_cpus[];
} cyc_list_t;
struct wrap_thread_call {
	thread_call_t TChdl;
	cyc_handler_t hdlr;
	cyc_time_t when;
	uint64_t deadline;
} wrap_thread_call_t;
struct blist_hdl {
	blist_t blist;
};
struct dtrace_proc_awaited_entry {
	struct dtrace_procdesc			*pdesc;
	LIST_ENTRY(dtrace_proc_awaited_entry)	entries;
} dtrace_proc_awaited_entry_t;
struct dtrace_invop_hdlr {
	int (*dtih_func)(uintptr_t, uintptr_t *, uintptr_t);
	struct dtrace_invop_hdlr *dtih_next;
} dtrace_invop_hdlr_t;
struct fasttrap_tracepoint_spec {
	pid_t fttps_pid;
	user_addr_t fttps_pc;
} fasttrap_tracepoint_spec_t;
struct lockstat_probe {
	const char      *lsp_func;
	const char      *lsp_name;
	int             lsp_probe;
	dtrace_id_t     lsp_id;
	const char      *lsp_args;
} lockstat_probe_t;
struct profile_probe {
	char            prof_name[PROF_NAMELEN];
	dtrace_id_t     prof_id;
	int             prof_kind;
	hrtime_t        prof_interval;
	cyclic_id_t     prof_cyclic;
} profile_probe_t;
struct profile_probe_percpu {
	hrtime_t        profc_expected;
	hrtime_t        profc_interval;
	profile_probe_t *profc_probe;
} profile_probe_percpu_t;
struct dtrace_sdt_def {
	uintptr_t      dsd_addr;    
	const char     *dsd_prov;   
	const char     *dsd_name;   
} __attribute__((__packed__))  dtrace_sdt_def_t;
struct {
	unsigned char           mach_trap_arg_count; 
	unsigned char           mach_trap_u32_words; 
	unsigned char           mach_trap_returns_port;
	unsigned char           __mach_trap_padding;
	kern_return_t         (*mach_trap_function)(void *);
} mach_trap_t;
struct mach_call_args {
	syscall_arg_t arg1;
	syscall_arg_t arg2;
	syscall_arg_t arg3;
	syscall_arg_t arg4;
	syscall_arg_t arg5;
	syscall_arg_t arg6;
	syscall_arg_t arg7;
	syscall_arg_t arg8;
	syscall_arg_t arg9;
};
struct machtrace_sysent {
	dtrace_id_t     stsy_entry;
	dtrace_id_t     stsy_return;
	kern_return_t   (*stsy_underlying)(void *);
	int32_t         stsy_return_type;
} machtrace_sysent_t;
struct systrace_sysent {
	dtrace_id_t     stsy_entry;
	dtrace_id_t     stsy_return;
	int32_t         (*stsy_underlying)(struct proc *, void *, int *);
	int32_t         stsy_return_type;
} systrace_sysent_t;
struct	instable {
	struct instable	*it_indirect;	
	uchar_t		it_adrmode;
	uint_t		it_invalid64:1;		
	uint_t		it_always64:1;		
	uint_t		it_invalid32:1;		
	uint_t		it_stackop:1;		
	uint_t		it_vexwoxmm:1;		
	uint_t		it_avxsuf:1;		
} instable_t;
struct dis_gather_regs {
	uint_t dgr_arg0;	
	uint_t dgr_arg1;	
	uint_t dgr_arg2;	
	const char *dgr_suffix;	
} dis_gather_regs_t;
struct xcArg {
	processorid_t cpu;
	dtrace_xcall_t f;
	void *arg;
} xcArg_t;
struct frame {
	struct frame *backchain;
	uintptr_t retaddr;
};
struct frame {
	struct frame *backchain;
	uintptr_t retaddr;
};
struct sigframe32 {
	int             retaddr;
	user32_addr_t   catcher; 
	int             sigstyle;
	int             sig;
	user32_addr_t   sinfo;  
	user32_addr_t   uctx;   
	user32_addr_t   token;
};
struct {
	int flavor; natural_t state_count; size_t  mcontext_size;
} xstate_info_t;
