struct kcdata_item {
	uint32_t type;
	uint32_t size; 
	               
	uint64_t flags;
	char data[]; 
};
struct kcdata_subtype_descriptor {
	uint8_t kcs_flags;

	uint8_t kcs_elem_type;                              
	uint16_t kcs_elem_offset;                           
	uint32_t kcs_elem_size;                             
	char                 kcs_name[KCDATA_DESC_MAXLEN];  
};
struct kcdata_type_definition {
	uint32_t kct_type_identifier;
	uint32_t kct_num_elements;
	char kct_name[KCDATA_DESC_MAXLEN];
	struct kcdata_subtype_descriptor kct_elements[];
};
struct stack_snapshot_frame32 {
	uint32_t lr;
	uint32_t sp;
};
struct stack_snapshot_frame64 {
	uint64_t lr;
	uint64_t sp;
};
struct dyld_uuid_info_32 {
	uint32_t imageLoadAddress; 
	uuid_t   imageUUID;
};
struct dyld_uuid_info_64 {
	uint64_t imageLoadAddress; 
	uuid_t   imageUUID;
};
struct dyld_uuid_info_64_v2 {
	uint64_t imageLoadAddress; 
	uuid_t   imageUUID;
	uint64_t imageSlidBaseAddress; 
};
struct dyld_shared_cache_loadinfo_v2 {
	uint64_t sharedCacheSlide;      
	uuid_t   sharedCacheUUID;
	uint64_t sharedCacheUnreliableSlidBaseAddress;  
	uint64_t sharedCacheSlidFirstMapping; 
	uint32_t sharedCacheID; 
	uint32_t sharedCacheFlags;
};
struct dyld_shared_cache_loadinfo {
	uint64_t sharedCacheSlide;      
	uuid_t   sharedCacheUUID;
	uint64_t sharedCacheUnreliableSlidBaseAddress;  
	uint64_t sharedCacheSlidFirstMapping; 
};
struct dyld_aot_cache_uuid_info {
	uint64_t x86SlidBaseAddress; 
	uuid_t x86UUID; 
	uint64_t aotSlidBaseAddress; 
	uuid_t aotUUID; 
};
struct user32_dyld_uuid_info {
	uint32_t        imageLoadAddress;       
	uuid_t                  imageUUID;                      
};
struct user64_dyld_uuid_info {
	uint64_t        imageLoadAddress;       
	uuid_t                  imageUUID;                      
};
struct user64_dyld_aot_info {
	uint64_t x86LoadAddress;
	uint64_t aotLoadAddress;
	uint64_t aotImageSize;
	uint8_t  aotImageKey[DYLD_AOT_IMAGE_KEY_SIZE];
};
struct mem_and_io_snapshot {
	uint32_t        snapshot_magic;
	uint32_t        free_pages;
	uint32_t        active_pages;
	uint32_t        inactive_pages;
	uint32_t        purgeable_pages;
	uint32_t        wired_pages;
	uint32_t        speculative_pages;
	uint32_t        throttled_pages;
	uint32_t        filebacked_pages;
	uint32_t        compressions;
	uint32_t        decompressions;
	uint32_t        compressor_size;
	int32_t         busy_buffer_count;
	uint32_t        pages_wanted;
	uint32_t        pages_reclaimed;
	uint8_t         pages_wanted_reclaimed_valid; 
} __attribute__((packed));
struct thread_snapshot_v2 {
	uint64_t  ths_thread_id;
	uint64_t  ths_wait_event;
	uint64_t  ths_continuation;
	uint64_t  ths_total_syscalls;
	uint64_t  ths_voucher_identifier;
	uint64_t  ths_dqserialnum;
	uint64_t  ths_user_time;
	uint64_t  ths_sys_time;
	uint64_t  ths_ss_flags;
	uint64_t  ths_last_run_time;
	uint64_t  ths_last_made_runnable_time;
	uint32_t  ths_state;
	uint32_t  ths_sched_flags;
	int16_t   ths_base_priority;
	int16_t   ths_sched_priority;
	uint8_t   ths_eqos;
	uint8_t ths_rqos;
	uint8_t ths_rqos_override;
	uint8_t ths_io_tier;
} __attribute__((packed));
struct thread_snapshot_v3 {
	uint64_t ths_thread_id;
	uint64_t ths_wait_event;
	uint64_t ths_continuation;
	uint64_t ths_total_syscalls;
	uint64_t ths_voucher_identifier;
	uint64_t ths_dqserialnum;
	uint64_t ths_user_time;
	uint64_t ths_sys_time;
	uint64_t ths_ss_flags;
	uint64_t ths_last_run_time;
	uint64_t ths_last_made_runnable_time;
	uint32_t ths_state;
	uint32_t ths_sched_flags;
	int16_t ths_base_priority;
	int16_t ths_sched_priority;
	uint8_t ths_eqos;
	uint8_t ths_rqos;
	uint8_t ths_rqos_override;
	uint8_t ths_io_tier;
	uint64_t ths_thread_t;
} __attribute__((packed));
struct thread_snapshot_v4 {
	uint64_t ths_thread_id;
	uint64_t ths_wait_event;
	uint64_t ths_continuation;
	uint64_t ths_total_syscalls;
	uint64_t ths_voucher_identifier;
	uint64_t ths_dqserialnum;
	uint64_t ths_user_time;
	uint64_t ths_sys_time;
	uint64_t ths_ss_flags;
	uint64_t ths_last_run_time;
	uint64_t ths_last_made_runnable_time;
	uint32_t ths_state;
	uint32_t ths_sched_flags;
	int16_t ths_base_priority;
	int16_t ths_sched_priority;
	uint8_t ths_eqos;
	uint8_t ths_rqos;
	uint8_t ths_rqos_override;
	uint8_t ths_io_tier;
	uint64_t ths_thread_t;
	uint64_t ths_requested_policy;
	uint64_t ths_effective_policy;
} __attribute__((packed));
struct thread_group_snapshot {
	uint64_t tgs_id;
	char tgs_name[16];
} __attribute__((packed));
struct thread_group_snapshot_v2 {
	uint64_t tgs_id;
	char tgs_name[16];
	uint64_t tgs_flags;
} __attribute__((packed));
struct thread_group_snapshot_v3 {
	uint64_t tgs_id;
	char tgs_name[16];
	uint64_t tgs_flags;
	char tgs_name_cont[16];
} __attribute__((packed));
struct jetsam_coalition_snapshot {
	uint64_t jcs_id;
	uint64_t jcs_flags;
	uint64_t jcs_thread_group;
	uint64_t jcs_leader_task_uniqueid;
} __attribute__((packed));
struct instrs_cycles_snapshot {
	uint64_t ics_instructions;
	uint64_t ics_cycles;
} __attribute__((packed));
struct instrs_cycles_snapshot_v2 {
	uint64_t ics_instructions;
	uint64_t ics_cycles;
	uint64_t ics_p_instructions;
	uint64_t ics_p_cycles;
} __attribute__((packed));
struct thread_delta_snapshot_v2 {
	uint64_t  tds_thread_id;
	uint64_t  tds_voucher_identifier;
	uint64_t  tds_ss_flags;
	uint64_t  tds_last_made_runnable_time;
	uint32_t  tds_state;
	uint32_t  tds_sched_flags;
	int16_t   tds_base_priority;
	int16_t   tds_sched_priority;
	uint8_t   tds_eqos;
	uint8_t   tds_rqos;
	uint8_t   tds_rqos_override;
	uint8_t   tds_io_tier;
} __attribute__ ((packed));
struct thread_delta_snapshot_v3 {
	uint64_t  tds_thread_id;
	uint64_t  tds_voucher_identifier;
	uint64_t  tds_ss_flags;
	uint64_t  tds_last_made_runnable_time;
	uint32_t  tds_state;
	uint32_t  tds_sched_flags;
	int16_t   tds_base_priority;
	int16_t   tds_sched_priority;
	uint8_t   tds_eqos;
	uint8_t   tds_rqos;
	uint8_t   tds_rqos_override;
	uint8_t   tds_io_tier;
	uint64_t  tds_requested_policy;
	uint64_t  tds_effective_policy;
} __attribute__ ((packed));
struct io_stats_snapshot {
	uint64_t         ss_disk_reads_count;
	uint64_t         ss_disk_reads_size;
	uint64_t         ss_disk_writes_count;
	uint64_t         ss_disk_writes_size;
	uint64_t         ss_io_priority_count[STACKSHOT_IO_NUM_PRIORITIES];
	uint64_t         ss_io_priority_size[STACKSHOT_IO_NUM_PRIORITIES];
	uint64_t         ss_paging_count;
	uint64_t         ss_paging_size;
	uint64_t         ss_non_paging_count;
	uint64_t         ss_non_paging_size;
	uint64_t         ss_data_count;
	uint64_t         ss_data_size;
	uint64_t         ss_metadata_count;
	uint64_t         ss_metadata_size;
} __attribute__ ((packed));
struct task_snapshot_v2 {
	uint64_t  ts_unique_pid;
	uint64_t  ts_ss_flags;
	uint64_t  ts_user_time_in_terminated_threads;
	uint64_t  ts_system_time_in_terminated_threads;
	uint64_t  ts_p_start_sec;
	uint64_t  ts_task_size;
	uint64_t  ts_max_resident_size;
	uint32_t  ts_suspend_count;
	uint32_t  ts_faults;
	uint32_t  ts_pageins;
	uint32_t  ts_cow_faults;
	uint32_t  ts_was_throttled;
	uint32_t  ts_did_throttle;
	uint32_t  ts_latency_qos;
	int32_t   ts_pid;
	char      ts_p_comm[32];
} __attribute__ ((packed));
struct transitioning_task_snapshot {
	uint64_t  tts_unique_pid;
	uint64_t  tts_ss_flags;
	uint64_t  tts_transition_type;
	int32_t   tts_pid;
	char      tts_p_comm[32];
} __attribute__ ((packed));
struct task_delta_snapshot_v2 {
	uint64_t  tds_unique_pid;
	uint64_t  tds_ss_flags;
	uint64_t  tds_user_time_in_terminated_threads;
	uint64_t  tds_system_time_in_terminated_threads;
	uint64_t  tds_task_size;
	uint64_t  tds_max_resident_size;
	uint32_t  tds_suspend_count;
	uint32_t  tds_faults;
	uint32_t  tds_pageins;
	uint32_t  tds_cow_faults;
	uint32_t  tds_was_throttled;
	uint32_t  tds_did_throttle;
	uint32_t  tds_latency_qos;
} __attribute__ ((packed));
struct stackshot_task_codesigning_info {
	uint64_t csflags;
	uint32_t cs_trust_level;
} __attribute__ ((packed));
struct stackshot_cpu_times {
	uint64_t user_usec;
	uint64_t system_usec;
} __attribute__((packed));
struct stackshot_cpu_times_v2 {
	uint64_t user_usec;
	uint64_t system_usec;
	uint64_t runnable_usec;
} __attribute__((packed));
struct stackshot_duration {
	uint64_t stackshot_duration;
	uint64_t stackshot_duration_outer;
} __attribute__((packed));
struct stackshot_duration_v2 {
	uint64_t stackshot_duration;
	uint64_t stackshot_duration_outer;
	uint64_t stackshot_duration_prior;
} __attribute__((packed));
struct stackshot_fault_stats {
	uint32_t sfs_pages_faulted_in;      
	uint64_t sfs_time_spent_faulting;   
	uint64_t sfs_system_max_fault_time; 
	uint8_t  sfs_stopped_faulting;      
} __attribute__((packed));
struct stackshot_thread_waitinfo {
	uint64_t owner;         
	uint64_t waiter;        
	uint64_t context;       
	uint8_t wait_type;      
} __attribute__((packed)) thread_waitinfo_t;
struct stackshot_thread_waitinfo_v2 {
	uint64_t owner;         
	uint64_t waiter;        
	uint64_t context;       
	uint8_t wait_type;      
	int16_t portlabel_id;   
	uint32_t wait_flags;    
} __attribute__((packed)) thread_waitinfo_v2_t;
struct stackshot_thread_turnstileinfo {
	uint64_t waiter;        
	uint64_t turnstile_context; 
	uint8_t turnstile_priority;
	uint8_t number_of_hops;
	uint64_t turnstile_flags;               
} __attribute__((packed)) thread_turnstileinfo_t;
struct stackshot_thread_turnstileinfo_v2 {
	uint64_t waiter;        
	uint64_t turnstile_context; 
	uint8_t turnstile_priority;
	uint8_t number_of_hops;
	uint64_t turnstile_flags; 
	int16_t portlabel_id;   
} __attribute__((packed)) thread_turnstileinfo_v2_t;
struct portlabel_info {
	int16_t portlabel_id;         
	uint16_t portlabel_flags;           
	uint8_t portlabel_domain;           
} __attribute__((packed));
struct stackshot_cpu_architecture {
	int32_t cputype;
	int32_t cpusubtype;
} __attribute__((packed));
struct stack_snapshot_stacktop {
	uint64_t sp;
	uint8_t stack_contents[8];
};
struct stackshot_latency_collection {
	uint64_t latency_version;
	uint64_t setup_latency;
	uint64_t total_task_iteration_latency;
	uint64_t total_terminated_task_iteration_latency;
} __attribute__((packed));
struct stackshot_latency_collection_v2 {
	uint64_t latency_version;
	uint64_t setup_latency_mt;
	uint64_t total_task_iteration_latency_mt;
	uint64_t total_terminated_task_iteration_latency_mt;
	uint64_t task_queue_building_latency_mt;
	uint64_t terminated_task_queue_building_latency_mt;
	uint64_t cpu_wait_latency_mt;
	int32_t  main_cpu_number;
	int32_t  calling_cpu_number;
	uint64_t buffer_size;
	uint64_t buffer_used;
	uint64_t buffer_overhead;
	uint64_t buffer_count;
} __attribute__((packed));
struct stackshot_latency_cpu {
	int32_t  cpu_number;
	int32_t  cluster_type;
	uint64_t init_latency_mt;
	uint64_t workqueue_latency_mt;
	uint64_t total_latency_mt;
	uint64_t total_cycles;
	uint64_t total_instrs;
	uint64_t tasks_processed;
	uint64_t threads_processed;
	uint64_t faulting_time_mt;
	uint64_t total_buf;
	uint64_t intercluster_buf_used;
} __attribute__((packed));
struct stackshot_latency_task {
	uint64_t task_uniqueid;
	uint64_t setup_latency;
	uint64_t task_thread_count_loop_latency;
	uint64_t task_thread_data_loop_latency;
	uint64_t cur_tsnap_latency;
	uint64_t pmap_latency;
	uint64_t bsd_proc_ids_latency;
	uint64_t misc_latency;
	uint64_t misc2_latency;
	uint64_t end_latency;
} __attribute__((packed));
struct stackshot_latency_thread {
	uint64_t thread_id;
	uint64_t cur_thsnap1_latency;
	uint64_t dispatch_serial_latency;
	uint64_t dispatch_label_latency;
	uint64_t cur_thsnap2_latency;
	uint64_t thread_name_latency;
	uint64_t sur_times_latency;
	uint64_t user_stack_latency;
	uint64_t kernel_stack_latency;
	uint64_t misc_latency;
} __attribute__((packed));
struct stackshot_suspension_info {
	uint64_t tss_last_start; 
	uint64_t tss_last_end;   
	uint64_t tss_count;      
	uint64_t tss_duration;   
} __attribute__((packed));
struct stackshot_suspension_source {
	uint64_t tss_time;     
	uint64_t tss_tid;      
	int tss_pid;           
	char tss_procname[65]; 
} __attribute__((packed));
struct thread_exclaves_info {
	uint64_t tei_scid;              
	uint32_t tei_thread_offset;     
	uint32_t tei_flags;             
} __attribute__((packed));
struct thread_crash_exclaves_info {
	uint64_t tcei_scid;              
	uint64_t tcei_thread_id;         
	uint32_t tcei_flags;             
} __attribute__((packed));
struct exclave_scresult_info {
	uint64_t esc_id;
	uint64_t esc_flags;             
} __attribute__((packed));
struct exclave_ipcstackentry_info {
	uint64_t eise_asid;                     
	uint64_t eise_tnid;                     
	uint64_t eise_invocationid;             
	uint64_t eise_flags;                    
} __attribute__((packed));
struct exclave_addressspace_info {
	uint64_t eas_id;                        
	uint64_t eas_flags;                     
	uint64_t eas_layoutid;                  
	uint64_t eas_slide;                     
	uint64_t eas_asroot;                    
} __attribute__((packed));
struct exclave_textlayout_info_v1 {
	uint64_t layout_id;
	uint64_t etl_flags;                     
} __attribute__((packed));
struct exclave_textlayout_info {
	uint64_t layout_id;
	uint64_t etl_flags;                     
	uint32_t sharedcache_index;             
} __attribute__((packed));
struct exclave_textlayout_segment {
	uuid_t layoutSegment_uuid;
	uint64_t layoutSegment_loadAddress;     
} __attribute__((packed));
struct exclave_textlayout_segment_v2 {
	uuid_t layoutSegment_uuid;
	uint64_t layoutSegment_loadAddress;     
	uint64_t layoutSegment_rawLoadAddress;  
} __attribute__((packed));
struct crashinfo_proc_uniqidentifierinfo {
	uint8_t                 p_uuid[16];             
	uint64_t                p_uniqueid;             
	uint64_t                p_puniqueid;            
	uint64_t                p_reserve2;             
	uint64_t                p_reserve3;             
	uint64_t                p_reserve4;             
} __attribute__((packed));
struct kernel_triage_info_v1 {
	char triage_string1[MAX_TRIAGE_STRING_LEN];
	char triage_string2[MAX_TRIAGE_STRING_LEN];
	char triage_string3[MAX_TRIAGE_STRING_LEN];
	char triage_string4[MAX_TRIAGE_STRING_LEN];
	char triage_string5[MAX_TRIAGE_STRING_LEN];
} __attribute__((packed));
struct crashinfo_jit_address_range {
	uint64_t start_address;
	uint64_t end_address;
} __attribute__((packed));
struct crashinfo_mb {
	uint64_t start_address;
	uint64_t data[64];
} __attribute__((packed));
struct btinfo_thread_state_data_t {
	uint32_t flavor;
	uint32_t count;
	int tstate[];
};
struct btinfo_sc_load_info64 {
	uint64_t sharedCacheSlide;
	uuid_t   sharedCacheUUID;
	uint64_t sharedCacheBaseAddress;
};
struct btinfo_sc_load_info {
	uint32_t sharedCacheSlide;
	uuid_t   sharedCacheUUID;
	uint32_t sharedCacheBaseAddress;
};
struct exit_reason_snapshot {
	uint32_t ers_namespace;
	uint64_t ers_code;
	uint64_t ers_flags;
} __attribute__((packed));
struct codesigning_exit_reason_info {
	uint64_t  ceri_virt_addr;
	uint64_t  ceri_file_offset;
	char      ceri_pathname[EXIT_REASON_CODESIG_PATH_MAX];
	char      ceri_filename[EXIT_REASON_CODESIG_PATH_MAX];
	uint64_t  ceri_codesig_modtime_secs;
	uint64_t  ceri_codesig_modtime_nsecs;
	uint64_t  ceri_page_modtime_secs;
	uint64_t  ceri_page_modtime_nsecs;
	uint8_t   ceri_path_truncated;
	uint8_t   ceri_object_codesigned;
	uint8_t   ceri_page_codesig_validated;
	uint8_t   ceri_page_codesig_tainted;
	uint8_t   ceri_page_codesig_nx;
	uint8_t   ceri_page_wpmapped;
	uint8_t   ceri_page_slid;
	uint8_t   ceri_page_dirty;
	uint32_t  ceri_page_shadow_depth;
} __attribute__((packed));
struct mac {
	size_t           m_buflen;
	char            *m_string;
};
struct user_mac {
	user_size_t     m_buflen;
	user_addr_t     m_string;
};
struct user32_mac {
	uint32_t        m_buflen;
	uint32_t        m_string;
};
struct user64_mac {
	uint64_t        m_buflen;
	uint64_t        m_string;
};
struct mac_module_data_element {
	unsigned int key_size;
	unsigned int value_size;
	unsigned int value_type;
	char *key;
	char *value;
};
struct mac_module_data_list {
	unsigned int count;
	unsigned int type;
	struct mac_module_data_element list[1];
};
struct mac_module_data {
	void *base_addr;                
	unsigned int size;
	unsigned int count;
	struct mac_module_data_element data[1]; 
};
struct mac_policy_list_element {
	struct mac_policy_conf *mpc;
};
struct mac_policy_list {
	u_int                           numloaded;
	u_int                           max;
	u_int                           maxindex;
	u_int                           staticmax;
	u_int                           chunks;
	u_int                           freehint;
	struct mac_policy_list_element  *entries;
};
struct mac_label_listener {
	mac_policy_handle_t             mll_handle;
	SLIST_ENTRY(mac_label_listener) mll_list;
};
struct mac_label_element {
	char                            mle_name[MAC_MAX_LABEL_ELEMENT_NAME];
	struct mac_label_listeners_t    mle_listeners;
	SLIST_ENTRY(mac_label_element)  mle_list;
};
struct mac_policy_ops {
	mpo_audit_check_postselect_t            *mpo_audit_check_postselect;
	mpo_audit_check_preselect_t             *mpo_audit_check_preselect;

	mpo_reserved_hook_t                     *mpo_reserved01;
	mpo_reserved_hook_t                     *mpo_reserved02;
	mpo_reserved_hook_t                     *mpo_reserved03;
	mpo_reserved_hook_t                     *mpo_reserved04;

	mpo_cred_check_label_update_execve_t    *mpo_cred_check_label_update_execve;
	mpo_cred_check_label_update_t           *mpo_cred_check_label_update;
	mpo_cred_check_visible_t                *mpo_cred_check_visible;
	mpo_cred_label_associate_fork_t         *mpo_cred_label_associate_fork;
	mpo_cred_label_associate_kernel_t       *mpo_cred_label_associate_kernel;
	mpo_cred_label_associate_t              *mpo_cred_label_associate;
	mpo_cred_label_associate_user_t         *mpo_cred_label_associate_user;
	mpo_cred_label_destroy_t                *mpo_cred_label_destroy;
	mpo_cred_label_externalize_audit_t      *mpo_cred_label_externalize_audit;
	mpo_cred_label_externalize_t            *mpo_cred_label_externalize;
	mpo_cred_label_init_t                   *mpo_cred_label_init;
	mpo_cred_label_internalize_t            *mpo_cred_label_internalize;
	mpo_cred_label_update_execve_t          *mpo_cred_label_update_execve;
	mpo_cred_label_update_t                 *mpo_cred_label_update;

	mpo_devfs_label_associate_device_t      *mpo_devfs_label_associate_device;
	mpo_devfs_label_associate_directory_t   *mpo_devfs_label_associate_directory;
	mpo_devfs_label_copy_t                  *mpo_devfs_label_copy;
	mpo_devfs_label_destroy_t               *mpo_devfs_label_destroy;
	mpo_devfs_label_init_t                  *mpo_devfs_label_init;
	mpo_devfs_label_update_t                *mpo_devfs_label_update;

	mpo_file_check_change_offset_t          *mpo_file_check_change_offset;
	mpo_file_check_create_t                 *mpo_file_check_create;
	mpo_file_check_dup_t                    *mpo_file_check_dup;
	mpo_file_check_fcntl_t                  *mpo_file_check_fcntl;
	mpo_file_check_get_offset_t             *mpo_file_check_get_offset;
	mpo_file_check_get_t                    *mpo_file_check_get;
	mpo_file_check_inherit_t                *mpo_file_check_inherit;
	mpo_file_check_ioctl_t                  *mpo_file_check_ioctl;
	mpo_file_check_lock_t                   *mpo_file_check_lock;
	mpo_file_check_mmap_downgrade_t         *mpo_file_check_mmap_downgrade;
	mpo_file_check_mmap_t                   *mpo_file_check_mmap;
	mpo_file_check_receive_t                *mpo_file_check_receive;
	mpo_file_check_set_t                    *mpo_file_check_set;
	mpo_file_label_init_t                   *mpo_file_label_init;       
	mpo_file_label_destroy_t                *mpo_file_label_destroy;    
	mpo_file_label_associate_t              *mpo_file_label_associate;  
	mpo_file_notify_close_t                 *mpo_file_notify_close;

	mpo_proc_check_launch_constraints_t     *mpo_proc_check_launch_constraints;
	mpo_proc_notify_service_port_derive_t   *mpo_proc_notify_service_port_derive;
	mpo_proc_check_set_task_exception_port_t *mpo_proc_check_set_task_exception_port;
	mpo_proc_check_set_thread_exception_port_t *mpo_proc_check_set_thread_exception_port;

	mpo_reserved_hook_t                     *mpo_reserved08;
	mpo_reserved_hook_t                     *mpo_reserved09;
	mpo_reserved_hook_t                     *mpo_reserved10;
	mpo_reserved_hook_t                     *mpo_reserved11;
	mpo_reserved_hook_t                     *mpo_reserved12;
	mpo_reserved_hook_t                     *mpo_reserved13;
	mpo_reserved_hook_t                     *mpo_reserved14;
	mpo_reserved_hook_t                     *mpo_reserved15;
	mpo_reserved_hook_t                     *mpo_reserved16;
	mpo_reserved_hook_t                     *mpo_reserved17;
	mpo_reserved_hook_t                     *mpo_reserved18;
	mpo_reserved_hook_t                     *mpo_reserved19;
	mpo_reserved_hook_t                     *mpo_reserved20;
	mpo_reserved_hook_t                     *mpo_reserved21;
	mpo_reserved_hook_t                     *mpo_reserved22;

	mpo_necp_check_open_t                   *mpo_necp_check_open;
	mpo_necp_check_client_action_t          *mpo_necp_check_client_action;

	mpo_file_check_library_validation_t     *mpo_file_check_library_validation;

	mpo_vnode_notify_setacl_t               *mpo_vnode_notify_setacl;
	mpo_vnode_notify_setattrlist_t          *mpo_vnode_notify_setattrlist;
	mpo_vnode_notify_setextattr_t           *mpo_vnode_notify_setextattr;
	mpo_vnode_notify_setflags_t             *mpo_vnode_notify_setflags;
	mpo_vnode_notify_setmode_t              *mpo_vnode_notify_setmode;
	mpo_vnode_notify_setowner_t             *mpo_vnode_notify_setowner;
	mpo_vnode_notify_setutimes_t            *mpo_vnode_notify_setutimes;
	mpo_vnode_notify_truncate_t             *mpo_vnode_notify_truncate;
	mpo_vnode_check_getattrlistbulk_t       *mpo_vnode_check_getattrlistbulk;

	mpo_proc_check_get_task_special_port_t  *mpo_proc_check_get_task_special_port;
	mpo_proc_check_set_task_special_port_t  *mpo_proc_check_set_task_special_port;

	mpo_vnode_notify_swap_t                 *mpo_vnode_notify_swap;
	mpo_vnode_notify_unlink_t               *mpo_vnode_notify_unlink;
	mpo_vnode_check_swap_t                  *mpo_vnode_check_swap;
	mpo_reserved_hook_t                     *mpo_reserved33;
	mpo_reserved_hook_t                     *mpo_reserved34;
	mpo_mount_notify_mount_t                *mpo_mount_notify_mount;
	mpo_vnode_check_copyfile_t              *mpo_vnode_check_copyfile;

	mpo_mount_check_quotactl_t              *mpo_mount_check_quotactl;
	mpo_mount_check_fsctl_t                 *mpo_mount_check_fsctl;
	mpo_mount_check_getattr_t               *mpo_mount_check_getattr;
	mpo_mount_check_label_update_t          *mpo_mount_check_label_update;
	mpo_mount_check_mount_t                 *mpo_mount_check_mount;
	mpo_mount_check_remount_t               *mpo_mount_check_remount;
	mpo_mount_check_setattr_t               *mpo_mount_check_setattr;
	mpo_mount_check_stat_t                  *mpo_mount_check_stat;
	mpo_mount_check_umount_t                *mpo_mount_check_umount;
	mpo_mount_label_associate_t             *mpo_mount_label_associate;
	mpo_mount_label_destroy_t               *mpo_mount_label_destroy;
	mpo_mount_label_externalize_t           *mpo_mount_label_externalize;
	mpo_mount_label_init_t                  *mpo_mount_label_init;
	mpo_mount_label_internalize_t           *mpo_mount_label_internalize;

	mpo_proc_check_expose_task_with_flavor_t *mpo_proc_check_expose_task_with_flavor;
	mpo_proc_check_get_task_with_flavor_t   *mpo_proc_check_get_task_with_flavor;
	mpo_proc_check_task_id_token_get_task_t *mpo_proc_check_task_id_token_get_task;

	mpo_pipe_check_ioctl_t                  *mpo_pipe_check_ioctl;
	mpo_pipe_check_kqfilter_t               *mpo_pipe_check_kqfilter;
	mpo_reserved_hook_t                     *mpo_reserved41;
	mpo_pipe_check_read_t                   *mpo_pipe_check_read;
	mpo_pipe_check_select_t                 *mpo_pipe_check_select;
	mpo_pipe_check_stat_t                   *mpo_pipe_check_stat;
	mpo_pipe_check_write_t                  *mpo_pipe_check_write;
	mpo_pipe_label_associate_t              *mpo_pipe_label_associate;
	mpo_reserved_hook_t                     *mpo_reserved42;
	mpo_pipe_label_destroy_t                *mpo_pipe_label_destroy;
	mpo_reserved_hook_t                     *mpo_reserved43;
	mpo_pipe_label_init_t                   *mpo_pipe_label_init;
	mpo_reserved_hook_t                     *mpo_reserved44;
	mpo_proc_check_syscall_mac_t            *mpo_proc_check_syscall_mac;

	mpo_policy_destroy_t                    *mpo_policy_destroy;
	mpo_policy_init_t                       *mpo_policy_init;
	mpo_policy_initbsd_t                    *mpo_policy_initbsd;
	mpo_policy_syscall_t                    *mpo_policy_syscall;

	mpo_system_check_sysctlbyname_t         *mpo_system_check_sysctlbyname;
	mpo_proc_check_inherit_ipc_ports_t      *mpo_proc_check_inherit_ipc_ports;
	mpo_vnode_check_rename_t                *mpo_vnode_check_rename;
	mpo_kext_check_query_t                  *mpo_kext_check_query;
	mpo_proc_notify_exec_complete_t         *mpo_proc_notify_exec_complete;
	mpo_proc_notify_cs_invalidated_t        *mpo_proc_notify_cs_invalidated;
	mpo_proc_check_syscall_unix_t           *mpo_proc_check_syscall_unix;
	mpo_reserved_hook_t                     *mpo_reserved45;
	mpo_proc_check_set_host_special_port_t  *mpo_proc_check_set_host_special_port;
	mpo_proc_check_set_host_exception_port_t *mpo_proc_check_set_host_exception_port;
	mpo_exc_action_check_exception_send_t   *mpo_exc_action_check_exception_send;
	mpo_exc_action_label_associate_t        *mpo_exc_action_label_associate;
	mpo_exc_action_label_populate_t         *mpo_exc_action_label_populate;
	mpo_exc_action_label_destroy_t          *mpo_exc_action_label_destroy;
	mpo_exc_action_label_init_t             *mpo_exc_action_label_init;
	mpo_exc_action_label_update_t           *mpo_exc_action_label_update;

	mpo_vnode_check_trigger_resolve_t       *mpo_vnode_check_trigger_resolve;
	mpo_mount_check_mount_late_t            *mpo_mount_check_mount_late;
	mpo_mount_check_snapshot_mount_t        *mpo_mount_check_snapshot_mount;
	mpo_vnode_notify_reclaim_t              *mpo_vnode_notify_reclaim;
	mpo_skywalk_flow_check_connect_t        *mpo_skywalk_flow_check_connect;
	mpo_skywalk_flow_check_listen_t         *mpo_skywalk_flow_check_listen;

	mpo_posixsem_check_create_t             *mpo_posixsem_check_create;
	mpo_posixsem_check_open_t               *mpo_posixsem_check_open;
	mpo_posixsem_check_post_t               *mpo_posixsem_check_post;
	mpo_posixsem_check_unlink_t             *mpo_posixsem_check_unlink;
	mpo_posixsem_check_wait_t               *mpo_posixsem_check_wait;
	mpo_posixsem_label_associate_t          *mpo_posixsem_label_associate;
	mpo_posixsem_label_destroy_t            *mpo_posixsem_label_destroy;
	mpo_posixsem_label_init_t               *mpo_posixsem_label_init;
	mpo_posixshm_check_create_t             *mpo_posixshm_check_create;
	mpo_posixshm_check_mmap_t               *mpo_posixshm_check_mmap;
	mpo_posixshm_check_open_t               *mpo_posixshm_check_open;
	mpo_posixshm_check_stat_t               *mpo_posixshm_check_stat;
	mpo_posixshm_check_truncate_t           *mpo_posixshm_check_truncate;
	mpo_posixshm_check_unlink_t             *mpo_posixshm_check_unlink;
	mpo_posixshm_label_associate_t          *mpo_posixshm_label_associate;
	mpo_posixshm_label_destroy_t            *mpo_posixshm_label_destroy;
	mpo_posixshm_label_init_t               *mpo_posixshm_label_init;

	mpo_proc_check_debug_t                  *mpo_proc_check_debug;
	mpo_proc_check_fork_t                   *mpo_proc_check_fork;
	mpo_reserved_hook_t                     *mpo_reserved61;
	mpo_reserved_hook_t                     *mpo_reserved62;
	mpo_proc_check_getaudit_t               *mpo_proc_check_getaudit;
	mpo_proc_check_getauid_t                *mpo_proc_check_getauid;
	mpo_reserved_hook_t                     *mpo_reserved63;
	mpo_proc_check_mprotect_t               *mpo_proc_check_mprotect;
	mpo_proc_check_sched_t                  *mpo_proc_check_sched;
	mpo_proc_check_setaudit_t               *mpo_proc_check_setaudit;
	mpo_proc_check_setauid_t                *mpo_proc_check_setauid;
	mpo_reserved_hook_t                     *mpo_reserved64;
	mpo_proc_check_signal_t                 *mpo_proc_check_signal;
	mpo_proc_check_wait_t                   *mpo_proc_check_wait;
	mpo_proc_check_dump_core_t              *mpo_proc_check_dump_core;
	mpo_proc_check_remote_thread_create_t   *mpo_proc_check_remote_thread_create;

	mpo_socket_check_accept_t               *mpo_socket_check_accept;
	mpo_socket_check_accepted_t             *mpo_socket_check_accepted;
	mpo_socket_check_bind_t                 *mpo_socket_check_bind;
	mpo_socket_check_connect_t              *mpo_socket_check_connect;
	mpo_socket_check_create_t               *mpo_socket_check_create;
	mpo_reserved_hook_t                     *mpo_reserved46;
	mpo_reserved_hook_t                     *mpo_reserved47;
	mpo_reserved_hook_t                     *mpo_reserved48;
	mpo_socket_check_listen_t               *mpo_socket_check_listen;
	mpo_socket_check_receive_t              *mpo_socket_check_receive;
	mpo_socket_check_received_t             *mpo_socket_check_received;
	mpo_reserved_hook_t                     *mpo_reserved49;
	mpo_socket_check_send_t                 *mpo_socket_check_send;
	mpo_socket_check_stat_t                 *mpo_socket_check_stat;
	mpo_socket_check_setsockopt_t           *mpo_socket_check_setsockopt;
	mpo_socket_check_getsockopt_t           *mpo_socket_check_getsockopt;

	mpo_proc_check_get_movable_control_port_t *mpo_proc_check_get_movable_control_port;
	mpo_proc_check_dyld_process_info_notify_register_t *mpo_proc_check_dyld_process_info_notify_register;
	mpo_proc_check_setuid_t                 *mpo_proc_check_setuid;
	mpo_proc_check_seteuid_t                *mpo_proc_check_seteuid;
	mpo_proc_check_setreuid_t               *mpo_proc_check_setreuid;
	mpo_proc_check_setgid_t                 *mpo_proc_check_setgid;
	mpo_proc_check_setegid_t                *mpo_proc_check_setegid;
	mpo_proc_check_setregid_t               *mpo_proc_check_setregid;
	mpo_proc_check_settid_t                 *mpo_proc_check_settid;
	mpo_proc_check_memorystatus_control_t   *mpo_proc_check_memorystatus_control;
	mpo_reserved_hook_t                     *mpo_reserved60;

	mpo_thread_telemetry_t                  *mpo_thread_telemetry;

	mpo_iokit_check_open_service_t          *mpo_iokit_check_open_service;

	mpo_system_check_acct_t                 *mpo_system_check_acct;
	mpo_system_check_audit_t                *mpo_system_check_audit;
	mpo_system_check_auditctl_t             *mpo_system_check_auditctl;
	mpo_system_check_auditon_t              *mpo_system_check_auditon;
	mpo_system_check_host_priv_t            *mpo_system_check_host_priv;
	mpo_system_check_nfsd_t                 *mpo_system_check_nfsd;
	mpo_system_check_reboot_t               *mpo_system_check_reboot;
	mpo_system_check_settime_t              *mpo_system_check_settime;
	mpo_system_check_swapoff_t              *mpo_system_check_swapoff;
	mpo_system_check_swapon_t               *mpo_system_check_swapon;
	mpo_socket_check_ioctl_t                *mpo_socket_check_ioctl;

	mpo_sysvmsg_label_associate_t           *mpo_sysvmsg_label_associate;
	mpo_sysvmsg_label_destroy_t             *mpo_sysvmsg_label_destroy;
	mpo_sysvmsg_label_init_t                *mpo_sysvmsg_label_init;
	mpo_sysvmsg_label_recycle_t             *mpo_sysvmsg_label_recycle;
	mpo_sysvmsq_check_enqueue_t             *mpo_sysvmsq_check_enqueue;
	mpo_sysvmsq_check_msgrcv_t              *mpo_sysvmsq_check_msgrcv;
	mpo_sysvmsq_check_msgrmid_t             *mpo_sysvmsq_check_msgrmid;
	mpo_sysvmsq_check_msqctl_t              *mpo_sysvmsq_check_msqctl;
	mpo_sysvmsq_check_msqget_t              *mpo_sysvmsq_check_msqget;
	mpo_sysvmsq_check_msqrcv_t              *mpo_sysvmsq_check_msqrcv;
	mpo_sysvmsq_check_msqsnd_t              *mpo_sysvmsq_check_msqsnd;
	mpo_sysvmsq_label_associate_t           *mpo_sysvmsq_label_associate;
	mpo_sysvmsq_label_destroy_t             *mpo_sysvmsq_label_destroy;
	mpo_sysvmsq_label_init_t                *mpo_sysvmsq_label_init;
	mpo_sysvmsq_label_recycle_t             *mpo_sysvmsq_label_recycle;
	mpo_sysvsem_check_semctl_t              *mpo_sysvsem_check_semctl;
	mpo_sysvsem_check_semget_t              *mpo_sysvsem_check_semget;
	mpo_sysvsem_check_semop_t               *mpo_sysvsem_check_semop;
	mpo_sysvsem_label_associate_t           *mpo_sysvsem_label_associate;
	mpo_sysvsem_label_destroy_t             *mpo_sysvsem_label_destroy;
	mpo_sysvsem_label_init_t                *mpo_sysvsem_label_init;
	mpo_sysvsem_label_recycle_t             *mpo_sysvsem_label_recycle;
	mpo_sysvshm_check_shmat_t               *mpo_sysvshm_check_shmat;
	mpo_sysvshm_check_shmctl_t              *mpo_sysvshm_check_shmctl;
	mpo_sysvshm_check_shmdt_t               *mpo_sysvshm_check_shmdt;
	mpo_sysvshm_check_shmget_t              *mpo_sysvshm_check_shmget;
	mpo_sysvshm_label_associate_t           *mpo_sysvshm_label_associate;
	mpo_sysvshm_label_destroy_t             *mpo_sysvshm_label_destroy;
	mpo_sysvshm_label_init_t                *mpo_sysvshm_label_init;
	mpo_sysvshm_label_recycle_t             *mpo_sysvshm_label_recycle;

	mpo_proc_notify_exit_t                  *mpo_proc_notify_exit;
	mpo_mount_check_snapshot_revert_t       *mpo_mount_check_snapshot_revert;
	mpo_vnode_check_getattr_t               *mpo_vnode_check_getattr;
	mpo_mount_check_snapshot_create_t       *mpo_mount_check_snapshot_create;
	mpo_mount_check_snapshot_delete_t       *mpo_mount_check_snapshot_delete;
	mpo_vnode_check_clone_t                 *mpo_vnode_check_clone;
	mpo_proc_check_get_cs_info_t            *mpo_proc_check_get_cs_info;
	mpo_proc_check_set_cs_info_t            *mpo_proc_check_set_cs_info;

	mpo_iokit_check_hid_control_t           *mpo_iokit_check_hid_control;

	mpo_vnode_check_access_t                *mpo_vnode_check_access;
	mpo_vnode_check_chdir_t                 *mpo_vnode_check_chdir;
	mpo_vnode_check_chroot_t                *mpo_vnode_check_chroot;
	mpo_vnode_check_create_t                *mpo_vnode_check_create;
	mpo_vnode_check_deleteextattr_t         *mpo_vnode_check_deleteextattr;
	mpo_vnode_check_exchangedata_t          *mpo_vnode_check_exchangedata;
	mpo_vnode_check_exec_t                  *mpo_vnode_check_exec;
	mpo_vnode_check_getattrlist_t           *mpo_vnode_check_getattrlist;
	mpo_vnode_check_getextattr_t            *mpo_vnode_check_getextattr;
	mpo_vnode_check_ioctl_t                 *mpo_vnode_check_ioctl;
	mpo_vnode_check_kqfilter_t              *mpo_vnode_check_kqfilter;
	mpo_vnode_check_label_update_t          *mpo_vnode_check_label_update;
	mpo_vnode_check_link_t                  *mpo_vnode_check_link;
	mpo_vnode_check_listextattr_t           *mpo_vnode_check_listextattr;
	mpo_vnode_check_lookup_t                *mpo_vnode_check_lookup;
	mpo_vnode_check_open_t                  *mpo_vnode_check_open;
	mpo_vnode_check_read_t                  *mpo_vnode_check_read;
	mpo_vnode_check_readdir_t               *mpo_vnode_check_readdir;
	mpo_vnode_check_readlink_t              *mpo_vnode_check_readlink;
	mpo_vnode_check_rename_from_t           *mpo_vnode_check_rename_from;
	mpo_vnode_check_rename_to_t             *mpo_vnode_check_rename_to;
	mpo_vnode_check_revoke_t                *mpo_vnode_check_revoke;
	mpo_vnode_check_select_t                *mpo_vnode_check_select;
	mpo_vnode_check_setattrlist_t           *mpo_vnode_check_setattrlist;
	mpo_vnode_check_setextattr_t            *mpo_vnode_check_setextattr;
	mpo_vnode_check_setflags_t              *mpo_vnode_check_setflags;
	mpo_vnode_check_setmode_t               *mpo_vnode_check_setmode;
	mpo_vnode_check_setowner_t              *mpo_vnode_check_setowner;
	mpo_vnode_check_setutimes_t             *mpo_vnode_check_setutimes;
	mpo_vnode_check_stat_t                  *mpo_vnode_check_stat;
	mpo_vnode_check_truncate_t              *mpo_vnode_check_truncate;
	mpo_vnode_check_unlink_t                *mpo_vnode_check_unlink;
	mpo_vnode_check_write_t                 *mpo_vnode_check_write;
	mpo_vnode_label_associate_devfs_t       *mpo_vnode_label_associate_devfs;
	mpo_vnode_label_associate_extattr_t     *mpo_vnode_label_associate_extattr;
	mpo_vnode_label_associate_file_t        *mpo_vnode_label_associate_file;
	mpo_vnode_label_associate_pipe_t        *mpo_vnode_label_associate_pipe;
	mpo_vnode_label_associate_posixsem_t    *mpo_vnode_label_associate_posixsem;
	mpo_vnode_label_associate_posixshm_t    *mpo_vnode_label_associate_posixshm;
	mpo_vnode_label_associate_singlelabel_t *mpo_vnode_label_associate_singlelabel;
	mpo_vnode_label_associate_socket_t      *mpo_vnode_label_associate_socket;
	mpo_vnode_label_copy_t                  *mpo_vnode_label_copy;
	mpo_vnode_label_destroy_t               *mpo_vnode_label_destroy;
	mpo_vnode_label_externalize_audit_t     *mpo_vnode_label_externalize_audit;
	mpo_vnode_label_externalize_t           *mpo_vnode_label_externalize;
	mpo_vnode_label_init_t                  *mpo_vnode_label_init;
	mpo_vnode_label_internalize_t           *mpo_vnode_label_internalize;
	mpo_vnode_label_recycle_t               *mpo_vnode_label_recycle;
	mpo_vnode_label_store_t                 *mpo_vnode_label_store;
	mpo_vnode_label_update_extattr_t        *mpo_vnode_label_update_extattr;
	mpo_vnode_label_update_t                *mpo_vnode_label_update;
	mpo_vnode_notify_create_t               *mpo_vnode_notify_create;
	mpo_vnode_check_signature_t             *mpo_vnode_check_signature;
	mpo_vnode_check_uipc_bind_t             *mpo_vnode_check_uipc_bind;
	mpo_vnode_check_uipc_connect_t          *mpo_vnode_check_uipc_connect;

	mpo_proc_check_run_cs_invalid_t         *mpo_proc_check_run_cs_invalid;
	mpo_proc_check_suspend_resume_t         *mpo_proc_check_suspend_resume;

	mpo_thread_userret_t                    *mpo_thread_userret;

	mpo_iokit_check_set_properties_t        *mpo_iokit_check_set_properties;

	mpo_vnode_check_supplemental_signature_t *mpo_vnode_check_supplemental_signature;

	mpo_vnode_check_searchfs_t              *mpo_vnode_check_searchfs;

	mpo_priv_check_t                        *mpo_priv_check;
	mpo_priv_grant_t                        *mpo_priv_grant;

	mpo_proc_check_map_anon_t               *mpo_proc_check_map_anon;

	mpo_vnode_check_fsgetpath_t             *mpo_vnode_check_fsgetpath;

	mpo_iokit_check_open_t                  *mpo_iokit_check_open;

	mpo_proc_check_ledger_t                 *mpo_proc_check_ledger;

	mpo_vnode_notify_rename_t               *mpo_vnode_notify_rename;

	mpo_vnode_check_setacl_t                *mpo_vnode_check_setacl;

	mpo_vnode_notify_deleteextattr_t        *mpo_vnode_notify_deleteextattr;

	mpo_system_check_kas_info_t             *mpo_system_check_kas_info;

	mpo_vnode_check_lookup_preflight_t      *mpo_vnode_check_lookup_preflight;

	mpo_vnode_notify_open_t                 *mpo_vnode_notify_open;

	mpo_system_check_info_t                 *mpo_system_check_info;

	mpo_pty_notify_grant_t                  *mpo_pty_notify_grant;
	mpo_pty_notify_close_t                  *mpo_pty_notify_close;

	mpo_vnode_find_sigs_t                   *mpo_vnode_find_sigs;

	mpo_kext_check_load_t                   *mpo_kext_check_load;
	mpo_kext_check_unload_t                 *mpo_kext_check_unload;

	mpo_proc_check_proc_info_t              *mpo_proc_check_proc_info;
	mpo_vnode_notify_link_t                 *mpo_vnode_notify_link;
	mpo_iokit_check_filter_properties_t     *mpo_iokit_check_filter_properties;
	mpo_iokit_check_get_property_t          *mpo_iokit_check_get_property;
};
struct mac_policy_conf {
	const char              *mpc_name;              
	const char              *mpc_fullname;          
	char const * const *mpc_labelnames;     
	unsigned int             mpc_labelname_count;   
	const struct mac_policy_ops     *mpc_ops;               
	int                      mpc_loadtime_flags;    
	int                     *mpc_field_off;         
	int                      mpc_runtime_flags;     
	mpc_t                    mpc_list;              
	void                    *mpc_data;              
};
struct label {
	struct label **l_owner;
	long           l_perpolicy[MAC_MAX_SLOTS];
};
struct file_list {
	struct  file_list *f_next;
	char    *f_fn;                  
	u_char  f_type;                 
	u_char  f_flags;                
	short   f_special;              
	char    *f_needs;
	char    *f_extra;               
};
struct device {
	int     d_type;                 
	const char      *d_name;        
	int     d_slave;                
	int     d_flags;                
	struct  device *d_next;         
	char    *d_init;                
};
struct opt {
	char    *op_name;
	char    *op_value;
	struct  opt *op_next;
};
struct kasan_quarantine_result {
	vm_address_t            addr;
	struct zone            *zone;
};
struct san_type_desc {
	uint16_t type; 
	union {
		struct {
			uint16_t issigned : 1;
			uint16_t width    : 15;
		}; 
		struct {
			uint16_t float_desc;
		}; 
	};
	const char name[];
};
struct san_src_loc {
	const char *filename;
	uint32_t line;
	uint32_t col;
};
struct ubsan_overflow_desc {
	struct san_src_loc loc;
	struct san_type_desc *ty;
};
struct ubsan_unreachable_desc {
	struct san_src_loc loc;
};
struct ubsan_shift_desc {
	struct san_src_loc loc;
	struct san_type_desc *lhs_t;
	struct san_type_desc *rhs_t;
};
struct ubsan_align_desc {
	struct san_src_loc loc;
	struct san_type_desc *ty;
	uint8_t align;
	uint8_t kind;
};
struct ubsan_ptroverflow_desc {
	struct san_src_loc loc;
};
struct ubsan_oob_desc {
	struct san_src_loc loc;
	struct san_type_desc *array_ty;
	struct san_type_desc *index_ty;
};
struct ubsan_load_invalid_desc {
	struct san_src_loc loc;
	struct san_type_desc *type;
};
struct ubsan_nullability_arg_desc {
	struct san_src_loc loc;
	struct san_src_loc attr_loc;
	int arg_index;
};
struct ubsan_nullability_ret_desc {
	struct san_src_loc loc;
};
struct ubsan_missing_ret_desc {
	struct san_src_loc loc;
};
struct ubsan_float_desc {
	struct san_src_loc loc;
	struct san_type_desc *type_from;
	struct san_type_desc *type_to;
};
struct ubsan_implicit_conv_desc {
	struct san_src_loc loc;
	struct san_type_desc *type_from;
	struct san_type_desc *type_to;
	unsigned char kind;
};
struct ubsan_func_type_mismatch_desc {
	struct san_src_loc loc;
	struct san_type_desc *type;
};
struct ubsan_vla_bound_desc {
	struct san_src_loc loc;
	struct san_type_desc *type;
};
struct ubsan_invalid_builtin {
	struct san_src_loc loc;
	unsigned char kind;
};
struct ubsan_violation {
	ubsan_violation_type_t ubsan_type;
	uint64_t lhs;
	uint64_t rhs;
	union {
		struct ubsan_overflow_desc *overflow;
		struct ubsan_unreachable_desc *unreachable;
		struct ubsan_shift_desc *shift;
		struct ubsan_align_desc *align;
		struct ubsan_ptroverflow_desc *ptroverflow;
		struct ubsan_oob_desc *oob;
		struct ubsan_load_invalid_desc *invalid;
		struct ubsan_nullability_arg_desc *nonnull_arg;
		struct ubsan_nullability_ret_desc *nonnull_ret;
		struct ubsan_missing_ret_desc *missing_ret;
		struct ubsan_float_desc *flt;
		struct ubsan_implicit_conv_desc *implicit;
		struct ubsan_func_type_mismatch_desc *func_mismatch;
		struct ubsan_vla_bound_desc *vla_bound;
		struct ubsan_invalid_builtin *invalid_builtin;
		const char *func;
	};
	struct san_src_loc *loc;
} ubsan_violation_t;
struct ubsan_buf {
	char    *ub_buf;
	size_t  ub_buf_size;
	size_t  ub_written;
	bool    ub_err;
} ubsan_buf_t;
struct ksancov_buf_desc {
	uintptr_t ptr;  
	size_t sz;      
};
struct ksancov_header {
	uint32_t         kh_magic;
	_Atomic uint32_t kh_enabled;
} ksancov_header_t;
struct ksancov_trace {
	ksancov_header_t kt_hdr;         
	uint32_t         kt_maxent;      
	_Atomic uint32_t kt_head;        
	uint64_t         kt_entries[];   
} ksancov_trace_t;
struct ksancov_trace_stksize_entry {
	uintptr_t pc;                      
	uint32_t  stksize;                 
} ksancov_trace_stksize_ent_t;
struct ksancov_counters {
	ksancov_header_t kc_hdr;
	uint32_t         kc_nedges;       
	uint8_t          kc_hits[];       
} ksancov_counters_t;
struct ksancov_edgemap {
	uint32_t  ke_magic;
	uint32_t  ke_nedges;
	uintptr_t ke_addrs[];             
} ksancov_edgemap_t;
struct ksancov_on_demand_msg {
	char bundle[ 64];
	ksancov_on_demand_operation_t operation;
	union {
		uint64_t gate;
		struct {
			uint32_t start;
			uint32_t stop;
		} range;
	};
};
struct clock_frequency_info_t {
	unsigned long bus_clock_rate_hz;
	unsigned long cpu_clock_rate_hz;
	unsigned long dec_clock_rate_hz;
	unsigned long bus_clock_rate_num;
	unsigned long bus_clock_rate_den;
	unsigned long bus_to_cpu_rate_num;
	unsigned long bus_to_cpu_rate_den;
	unsigned long bus_to_dec_rate_num;
	unsigned long bus_to_dec_rate_den;
	unsigned long timebase_frequency_hz;
	unsigned long timebase_frequency_num;
	unsigned long timebase_frequency_den;
	unsigned long long bus_frequency_hz;
	unsigned long long bus_frequency_min_hz;
	unsigned long long bus_frequency_max_hz;
	unsigned long long cpu_frequency_hz;
	unsigned long long cpu_frequency_min_hz;
	unsigned long long cpu_frequency_max_hz;
	unsigned long long prf_frequency_hz;
	unsigned long long prf_frequency_min_hz;
	unsigned long long prf_frequency_max_hz;
	unsigned long long mem_frequency_hz;
	unsigned long long mem_frequency_min_hz;
	unsigned long long mem_frequency_max_hz;
	unsigned long long fix_frequency_hz;
};
struct timebase_freq_t {
	unsigned long timebase_num;
	unsigned long timebase_den;
};
struct PE_Video {
	unsigned long   v_baseAddr;     
	unsigned long   v_rowBytes;     
	unsigned long   v_width;        
	unsigned long   v_height;       
	unsigned long   v_depth;        
	unsigned long   v_display;      
	char            v_pixelFormat[64];
	unsigned long   v_offset;       
	unsigned long   v_length;       
	unsigned char   v_rotate;       
	unsigned char   v_scale;        
	char            reserved1[2];
	long            reserved2;
};
struct PE_state {
	boolean_t       initialized;
	PE_Video        video;
	void            *deviceTreeHead;
	void            *bootArgs;
	vm_size_t       deviceTreeSize;
} PE_state_t;
struct PE_panic_save_context {
	void *psc_buffer;
	uint32_t psc_offset;
	uint32_t psc_length;
} PE_panic_save_context_t;
struct boot_progress_element {
	unsigned int        width;
	unsigned int        height;
	int                 yOffset;
	unsigned int        res[5];
	unsigned char       data[0];
};
struct {
	ulcon_t ulcon;
	ucon_t ucon;
	ufcon_t ufcon;
	uint32_t umcon;
	utrstat_t utrstat;
	uint32_t uerstat;
	ufstat_t ufstat;
	uint32_t umstat;
	utxh_t utxh;
	urxh_t urxh;
	ubrdiv_t ubrdiv;
	uint32_t uabrcnt;
	uint8_t rsvd0[4];
	uint32_t utxoffset;
	uint32_t urxoffset;
	uint32_t uver;
} apple_uart_registers_t;
struct Boot_Video {
	unsigned long   v_baseAddr;     
	unsigned long   v_display;      
	unsigned long   v_rowBytes;     
	unsigned long   v_width;        
	unsigned long   v_height;       
	unsigned long   v_depth;        
};
struct boot_args {
	uint16_t                Revision;                       
	uint16_t                Version;                        
	uint32_t                virtBase;                       
	uint32_t                physBase;                       
	uint32_t                memSize;                        
	uint32_t                topOfKernelData;        
	Boot_Video              Video;                          
	uint32_t                machineType;            
	void                    *deviceTreeP;           
	uint32_t                deviceTreeLength;       
	char                    CommandLine[BOOT_LINE_LENGTH];  
	uint32_t                bootFlags;              
	uint32_t                memSizeActual;          
} boot_args;
struct {
	uint64_t record_id;             
	uint32_t num_records;           
	uint32_t record_size_bytes;     
} dbg_top_level_header_t;
struct {
	uint64_t record_id; 
	uint64_t length;    
	uint64_t physaddr;  
} dbg_record_header_t;
struct {
	uint64_t timestamp;
	uint32_t cp_state;          
	uint32_t cp_state_arg;      
} dbg_cpr_state_entry_t;
struct {
	uint32_t rdptr;
	uint32_t wrptr;
	uint32_t num_cp_state_entries;
	uint32_t checksum;
	dbg_cpr_state_entry_t cp_state_entries[CPR_MAX_STATE_ENTRIES];
} dbg_cpr_t;
struct {
	dbg_top_level_header_t  top_level_header;
	dbg_record_header_t     records[DEBUG_REGISTRY_MAX_RECORDS];

	dbg_cpr_t               ap_cpr_region;
} dbg_registry_t;
struct {
	uartdr_t uartdr;
	uartrsr_uartecr_t uartrsr_uartecr;
	uint8_t _reserved0[0x10];
	uartfr_t uartfr;
	uint8_t _reserved1[0x4];
	uartilpr_t uartilpr;
	uartibrd_t uartibrd;
	uartfbrd_t uartfbrd;
	uartlcr_h_t uartlcr_h;
	uartcr_t uartcr;
	uartifls_t uartifls;
	uartimsc_t uartimsc;
	uartris_t uartris;
	uartmis_t uartmis;
	uarticr_t uarticr;
	uartdmacr_t uartdmacr;
	uint8_t _reserved2[0x34];
	uint8_t _reserved3[0x10];
	uint8_t _reserved4[0xf40];
	uint8_t _reserved5[0x10];
	uart_periph_id0_t uart_periph_id0;
	uart_periph_id1_t uart_periph_id1;
	uart_periph_id2_t uart_periph_id2;
	uart_periph_id3_t uart_periph_id3;
	uart_pcell_id0_t uart_pcell_id0;
	uart_pcell_id1_t uart_pcell_id1;
	uart_pcell_id2_t uart_pcell_id2;
	uart_pcell_id3_t uart_pcell_id3;
} pl011_registers_t;
struct Boot_Video {
	unsigned long   v_baseAddr;     
	unsigned long   v_display;      
	unsigned long   v_rowBytes;     
	unsigned long   v_width;        
	unsigned long   v_height;       
	unsigned long   v_depth;        
};
struct boot_args {
	uint16_t                Revision;                       
	uint16_t                Version;                        
	uint64_t                virtBase;                       
	uint64_t                physBase;                       
	uint64_t                memSize;                        
	uint64_t                topOfKernelData;        
	Boot_Video              Video;                          
	uint32_t                machineType;            
	void                    *deviceTreeP;           
	uint32_t                deviceTreeLength;       
	char                    CommandLine[BOOT_LINE_LENGTH];  
	uint64_t                bootFlags;              
	uint64_t                memSizeActual;          
} boot_args;
struct EfiMemoryRange {
	uint32_t Type;
	uint32_t Pad;
	uint64_t PhysicalStart;
	uint64_t VirtualStart;
	uint64_t NumberOfPages;
	uint64_t Attribute;
} EfiMemoryRange;
struct Boot_VideoV1 {
	uint32_t        v_baseAddr;     
	uint32_t        v_display;      
	uint32_t        v_rowBytes;     
	uint32_t        v_width;        
	uint32_t        v_height;       
	uint32_t        v_depth;        
};
struct Boot_Video {
	uint32_t        v_display;      
	uint32_t        v_rowBytes;     
	uint32_t        v_width;        
	uint32_t        v_height;       
	uint32_t        v_depth;        
	uint8_t         v_rotate;       
	uint8_t         v_resv_byte[3]; 
	uint32_t        v_resv[6];      
	uint64_t        v_baseAddr;     
};
struct boot_icon_element {
	unsigned int    width;
	unsigned int    height;
	int             y_offset_from_center;
	unsigned int    data_size;
	unsigned int    __reserved1[4];
	unsigned char   data[0];
};
struct boot_args {
	uint16_t    Revision;   
	uint16_t    Version;    

	uint8_t     efiMode;
	uint8_t     debugMode;
	uint16_t    flags;

	char        CommandLine[BOOT_LINE_LENGTH];

	uint32_t    MemoryMap;
	uint32_t    MemoryMapSize;
	uint32_t    MemoryMapDescriptorSize;
	uint32_t    MemoryMapDescriptorVersion;

	Boot_VideoV1 VideoV1;   

	uint32_t    deviceTreeP;  
	uint32_t    deviceTreeLength;

	uint32_t    kaddr;        
	uint32_t    ksize;        

	uint32_t    efiRuntimeServicesPageStart;
	uint32_t    efiRuntimeServicesPageCount;
	uint64_t    efiRuntimeServicesVirtualPageStart;

	uint32_t    efiSystemTable;
	uint32_t    kslide;

	uint32_t    performanceDataStart;
	uint32_t    performanceDataSize;

	uint32_t    keyStoreDataStart;
	uint32_t    keyStoreDataSize;
	uint64_t    bootMemStart;
	uint64_t    bootMemSize;
	uint64_t    PhysicalMemorySize;
	uint64_t    FSBFrequency;
	uint64_t    pciConfigSpaceBaseAddress;
	uint32_t    pciConfigSpaceStartBusNumber;
	uint32_t    pciConfigSpaceEndBusNumber;
	uint32_t    csrActiveConfig;
	uint32_t    csrCapabilities;
	uint32_t    boot_SMC_plimit;
	uint16_t    bootProgressMeterStart;
	uint16_t    bootProgressMeterEnd;
	Boot_Video  Video;      

	uint32_t    apfsDataStart;
	uint32_t    apfsDataSize;

	uint64_t    KC_hdrs_vaddr;

	uint64_t    arvRootHashStart; 
	uint64_t    arvRootHashSize;

	uint64_t    arvManifestStart; 
	uint64_t    arvManifestSize;

	uint64_t    bsARVRootHashStart;
	uint64_t    bsARVRootHashSize;

	uint64_t    bsARVManifestStart;
	uint64_t    bsARVManifestSize;

	uint32_t    __reserved4[692];
} boot_args;
struct {
	EFI_UINT32  Data1;
	EFI_UINT16  Data2;
	EFI_UINT16  Data3;
	EFI_UINT8   Data4[8];
} EFI_GUID;
struct {
	EFI_UINT16  Year;
	EFI_UINT8   Month;
	EFI_UINT8   Day;
	EFI_UINT8   Hour;
	EFI_UINT8   Minute;
	EFI_UINT8   Second;
	EFI_UINT8   Pad1;
	EFI_UINT32  Nanosecond;
	EFI_INT16   TimeZone;
	EFI_UINT8   Daylight;
	EFI_UINT8   Pad2;
} EFI_TIME;
struct {
	EFI_UINT64  Signature;
	EFI_UINT32  Revision;
	EFI_UINT32  HeaderSize;
	EFI_UINT32  CRC32;
	EFI_UINT32  Reserved;
} __attribute__((aligned(8))) EFI_TABLE_HEADER;
struct {
	EFI_UINT32            Type;
	EFI_UINT32            Pad;
	EFI_PHYSICAL_ADDRESS  PhysicalStart;
	EFI_VIRTUAL_ADDRESS   VirtualStart;
	EFI_UINT64            NumberOfPages;
	EFI_UINT64            Attribute;
} __attribute__((aligned(8))) EFI_MEMORY_DESCRIPTOR;
struct {
	EFI_UINT32  Resolution;
	EFI_UINT32  Accuracy;
	EFI_BOOLEAN SetsToZero;
} __attribute__((aligned(4))) EFI_TIME_CAPABILITIES;
struct {
	EFI_TABLE_HEADER              Hdr;

	EFI_PTR32                     GetTime;
	EFI_PTR32                     SetTime;
	EFI_PTR32                     GetWakeupTime;
	EFI_PTR32                     SetWakeupTime;

	EFI_PTR32                     SetVirtualAddressMap;
	EFI_PTR32                     ConvertPointer;

	EFI_PTR32                     GetVariable;
	EFI_PTR32                     GetNextVariableName;
	EFI_PTR32                     SetVariable;

	EFI_PTR32                     GetNextHighMonotonicCount;
	EFI_PTR32                     ResetSystem;

} __attribute__((aligned(8))) EFI_RUNTIME_SERVICES_32;
struct {
	EFI_TABLE_HEADER              Hdr;

	EFI_PTR64                     GetTime;
	EFI_PTR64                     SetTime;
	EFI_PTR64                     GetWakeupTime;
	EFI_PTR64                     SetWakeupTime;

	EFI_PTR64                     SetVirtualAddressMap;
	EFI_PTR64                     ConvertPointer;

	EFI_PTR64                     GetVariable;
	EFI_PTR64                     GetNextVariableName;
	EFI_PTR64                     SetVariable;

	EFI_PTR64                     GetNextHighMonotonicCount;
	EFI_PTR64                     ResetSystem;

} __attribute__((aligned(8))) EFI_RUNTIME_SERVICES_64;
struct {
	EFI_GUID  VendorGuid;
	EFI_PTR32 VendorTable;
} EFI_CONFIGURATION_TABLE_32;
struct {
	EFI_GUID  VendorGuid;
	EFI_PTR64 VendorTable;
} __attribute__((aligned(8))) EFI_CONFIGURATION_TABLE_64;
struct EFI_SYSTEM_TABLE_32 {
	EFI_TABLE_HEADER              Hdr;

	EFI_PTR32                     FirmwareVendor;
	EFI_UINT32                    FirmwareRevision;

	EFI_HANDLE32                  ConsoleInHandle;
	EFI_PTR32                     ConIn;

	EFI_HANDLE32                  ConsoleOutHandle;
	EFI_PTR32                     ConOut;

	EFI_HANDLE32                  StandardErrorHandle;
	EFI_PTR32                     StdErr;

	EFI_PTR32                     RuntimeServices;
	EFI_PTR32                     BootServices;

	EFI_UINT32                    NumberOfTableEntries;
	EFI_PTR32                     ConfigurationTable;
} __attribute__((aligned(8))) EFI_SYSTEM_TABLE_32;
struct EFI_SYSTEM_TABLE_64 {
	EFI_TABLE_HEADER              Hdr;

	EFI_PTR64                     FirmwareVendor;
	EFI_UINT32                    FirmwareRevision;

	EFI_UINT32                    __pad;

	EFI_HANDLE64                  ConsoleInHandle;
	EFI_PTR64                     ConIn;

	EFI_HANDLE64                  ConsoleOutHandle;
	EFI_PTR64                     ConOut;

	EFI_HANDLE64                  StandardErrorHandle;
	EFI_PTR64                     StdErr;

	EFI_PTR64                     RuntimeServices;
	EFI_PTR64                     BootServices;

	EFI_UINT64                    NumberOfTableEntries;
	EFI_PTR64                     ConfigurationTable;
} __attribute__((aligned(8))) EFI_SYSTEM_TABLE_64;
struct {
	uint32_t arm_rev : 4,  
	    arm_part         : 12,
	    arm_arch         : 4,
	    arm_variant      : 4,
	    arm_implementor  : 8;
} arm_cpuid_bits_t;
struct {
	boolean_t    c_valid;            
	boolean_t    c_unified;          
	uint32_t     c_isize;            
	boolean_t    c_i_ppage;          
	uint32_t     c_dsize;            
	boolean_t    c_d_ppage;          
	cache_type_t c_type;             
	uint32_t     c_linesz;           
	uint32_t     c_assoc;            
	uint32_t     c_l2size;           
	uint32_t     c_bulksize_op;      
	uint32_t     c_inner_cache_size; 

} cache_info_t;
struct {
	uint32_t
	    RB:4, 
	    SP:4, 
	    DP:4, 
	    TE:4, 
	    D:4, 
	    SR:4, 
	    SV:4, 
	    RM:4; 
} arm_mvfr0_t;
struct {
	uint32_t
	    FZ:4, 
	    DN:4, 
	    LS:4, 
	    I:4, 
	    SP:4, 
	    HPFP:4, 
	    RSVP:8; 
} arm_mvfr1_t;
struct {
	uint32_t neon;
	uint32_t neon_hpfp;
	uint32_t neon_fp16;
} arm_mvfp_info_t;
struct {
	volatile uint64_t       TimeBase;
	volatile uint32_t       TimeStamp_sec;
	volatile uint32_t       TimeStamp_usec;
	volatile uint32_t       TimeBaseTicks_per_sec;
	volatile uint32_t       TimeBaseTicks_per_usec;
	volatile uint64_t       TimeBase_magic;
	volatile uint32_t       TimeBase_add;
	volatile uint32_t       TimeBase_shift;
} commpage_timeofday_data_t;
struct reset_handler_data {
	vm_offset_t     assist_reset_handler;           
	vm_offset_t     cpu_data_entries;                       
} reset_handler_data_t;
struct cpu_data_entry {
	void                           *cpu_data_paddr;         
	struct  cpu_data               *cpu_data_vaddr;         
} cpu_data_entry_t;
struct rtclock_timer {
	mpqueue_head_t                  queue;
	uint64_t                        deadline;
	uint32_t                        is_set:1,
	    has_expired:1,
	:0;
} rtclock_timer_t;
struct {
	uint64_t irq_ex_cnt;
	uint64_t irq_ex_cnt_wake;
	uint64_t ipi_cnt;
	uint64_t ipi_cnt_wake;
	uint64_t timer_cnt;
	uint64_t undef_ex_cnt;
	uint64_t unaligned_cnt;
	uint64_t vfp_cnt;
	uint64_t data_ex_cnt;
	uint64_t instr_ex_cnt;
} cpu_stat_t;
struct cpu_data {
	unsigned short                  cpu_number;
	_Atomic cpu_flags_t             cpu_flags;
	int                             cpu_type;
	int                             cpu_subtype;
	int                             cpu_threadtype;

	void *                          XNU_PTRAUTH_SIGNED_PTR("cpu_data.istackptr") istackptr;
	vm_offset_t                     intstack_top;
	void *                          XNU_PTRAUTH_SIGNED_PTR("cpu_data.excepstackptr") excepstackptr;
	vm_offset_t                     excepstack_top;
	thread_t                        cpu_active_thread;
	vm_offset_t                     cpu_active_stack;
	cpu_id_t                        cpu_id;
	volatile cpu_signal_t           cpu_signal;
	ast_t                           cpu_pending_ast;
	cache_dispatch_t                cpu_cache_dispatch;

	uint64_t                        cpu_base_timebase;
	uint64_t                        cpu_timebase;
	bool                            cpu_hibernate; 
	bool                            cpu_running;
	bool                            cluster_master;
	bool                            in_state_transition;

	uint32_t                        cpu_decrementer;
	get_decrementer_t               cpu_get_decrementer_func;
	set_decrementer_t               cpu_set_decrementer_func;
	fiq_handler_t                   cpu_get_fiq_handler;

	void                            *cpu_tbd_hardware_addr;
	void                            *cpu_tbd_hardware_val;

	processor_idle_t                cpu_idle_notify;
	uint64_t                        cpu_idle_latency;
	uint64_t                        cpu_idle_pop;

	vm_offset_t                     cpu_reset_handler;
	uintptr_t                       cpu_reset_assist;
	uint32_t                        cpu_reset_type;

	unsigned int                    interrupt_source;
	void                            *cpu_int_state;
	IOInterruptHandler              interrupt_handler;
	void                            *interrupt_nub;
	void                            *interrupt_target;
	void                            *interrupt_refCon;

	idle_timer_t                    idle_timer_notify;
	void                            *idle_timer_refcon;
	uint64_t                        idle_timer_deadline;

	uint64_t                        rtcPop;
	rtclock_timer_t                 rtclock_timer;
	struct _rtclock_data_           *rtclock_datap;

	arm_debug_state_t               *cpu_user_debug; 
	vm_offset_t                     cpu_debug_interface_map;

	volatile int                    debugger_active;
	volatile int                    PAB_active; 

	void                            *cpu_xcall_p0;
	void                            *cpu_xcall_p1;
	void                            *cpu_imm_xcall_p0;
	void                            *cpu_imm_xcall_p1;


	vm_offset_t                     coresight_base[CORESIGHT_REGIONS];


	uint64_t                        cpu_regmap_paddr;

	uint32_t                        cpu_phys_id;
	platform_error_handler_t        platform_error_handler;

	int                             cpu_mcount_off;

	volatile unsigned int           cpu_sleep_token;
	unsigned int                    cpu_sleep_token_last;

	cluster_type_t                  cpu_cluster_type;
	uint32_t                        cpu_cluster_id;
	uint32_t                        cpu_l2_id;
	uint32_t                        cpu_l2_size;
	uint32_t                        cpu_l3_id;
	uint32_t                        cpu_l3_size;

	enum {
		CPU_NOT_HALTED = 0,
		CPU_HALTED,
		CPU_HALTED_WITH_STATE
	}                               halt_status;


	uint64_t                        *cpu_kpc_buf[2];
	uint64_t                        *cpu_kpc_shadow;
	uint64_t                        *cpu_kpc_reload;


	cpu_stat_t                      cpu_stat;
	dbgwrap_thread_state_t          halt_state;
	uint64_t ipi_pc;
	uint64_t ipi_lr;
	uint64_t ipi_fp;

	uint64_t                        cpu_tpidr_el0;


} cpu_data_t;
struct sysreg_restore {
	uint64_t                tcr_el1;
} sysreg_restore_t;
struct ml_topology_cpu {
	unsigned int                    cpu_id;
	uint32_t                        phys_id;
	unsigned int                    cluster_id;
	unsigned int                    die_id;
	cluster_type_t                  cluster_type;
	uint32_t                        l2_access_penalty; 
	uint32_t                        l2_cache_size;
	uint32_t                        l2_cache_id;
	uint32_t                        l3_cache_size;
	uint32_t                        l3_cache_id;
	vm_offset_t                     cpu_IMPL_regs;
	uint64_t                        cpu_IMPL_pa;
	uint64_t                        cpu_IMPL_len;
	vm_offset_t                     cpu_UTTDBG_regs;
	uint64_t                        cpu_UTTDBG_pa;
	uint64_t                        cpu_UTTDBG_len;
	vm_offset_t                     coresight_regs;
	uint64_t                        coresight_pa;
	uint64_t                        coresight_len;
	unsigned int                    die_cluster_id;
	unsigned int                    cluster_core_id;
} ml_topology_cpu_t;
struct ml_topology_cluster {
	unsigned int                    cluster_id;
	cluster_type_t                  cluster_type;
	unsigned int                    num_cpus;
	unsigned int                    first_cpu_id;
	uint64_t                        cpu_mask;
	unsigned int                    die_id;
	unsigned int                    die_cluster_id;
	vm_offset_t                     acc_IMPL_regs;
	uint64_t                        acc_IMPL_pa;
	uint64_t                        acc_IMPL_len;
	vm_offset_t                     cpm_IMPL_regs;
	uint64_t                        cpm_IMPL_pa;
	uint64_t                        cpm_IMPL_len;
} ml_topology_cluster_t;
struct ml_topology_info {
	unsigned int                    version;
	unsigned int                    num_cpus;
	unsigned int                    max_cpu_id;
	unsigned int                    num_clusters;
	unsigned int                    max_cluster_id;
	unsigned int                    max_die_id;
	ml_topology_cpu_t               *cpus;
	ml_topology_cluster_t           *clusters;
	ml_topology_cpu_t               *boot_cpu;
	ml_topology_cluster_t           *boot_cluster;
	unsigned int                    chip_revision;
	unsigned int                    cluster_types;
	unsigned int                    cluster_type_num_cpus[MAX_CPU_TYPES];
	unsigned int                    cluster_type_num_clusters[MAX_CPU_TYPES];
	unsigned int                    cluster_power_down;
} ml_topology_info_t;
struct {
 uint8_t signature[16];
 uint64_t cpu_capabilities64;
 uint8_t _unused[6];
 uint16_t version;
 uint32_t cpu_capabilities;
 uint8_t _unused0[2];
 uint16_t cache_linesize;
 volatile uint32_t sched_gen;
 volatile uint32_t memory_pressure;
 volatile uint32_t spin_count;
 volatile uint8_t active_cpus;
 uint8_t physical_cpus;
 uint8_t logical_cpus;
 uint8_t cpu_clusters;
 uint64_t memory_size;
 uint32_t cpufamily;
 volatile uint32_t kdebug_enable;
 volatile uint32_t atm_diagnostic_config;
 uint8_t cp_dtrace_dof_enabled;
 uint8_t cp_kernel_page_shift; 
 uint8_t cp_user_page_shift; 
 uint8_t _unused2;
	volatile struct {
 uint64_t nt_tsc_base;
 uint32_t nt_scale;
 uint32_t nt_shift;
 uint64_t nt_ns_base;
 uint32_t nt_generation;
 uint32_t gtod_generation;
 uint64_t gtod_ns_base;
 uint64_t gtod_sec_base;
	} time_data;
	volatile union {
		struct {
 uint64_t time;
 uint64_t time_supported;
		} _;
		uint8_t _fill[64];
	} approx;
 volatile uint64_t cont_timebase;
 volatile uint64_t boottime_usec;
	new_commpage_timeofday_data_t new_time_data;
 uint64_t unused;
 uint64_t dyld_system_flags;
 uint8_t cpu_to_cluster[256];

 uint8_t unused2[3536];
 uint64_t arm_cpu_capabilities;
 uint8_t cp_aprr_shadow_supported;
 uint8_t user_timebase_type;
 uint8_t unused3[6];
 uint64_t cp_aprr_shadow_jit_rw;
 uint64_t cp_aprr_shadow_jit_rx;
 uint32_t unused4;
 uint32_t arm_cpufamily;
 uint64_t cp_aprr_shadow_tpro_rw;
 uint64_t cp_aprr_shadow_tpro_ro;
 uint64_t cp_asb_target_value;
 uint64_t cp_asb_target_address;
 uint64_t cp_asb_target_kern_value;
 uint64_t cp_asb_target_kern_address;
} x86_64_commpage_t;
struct {
	machdep_call_routine_t      routine;
	int                         nargs;
} machdep_call_t;
struct {
	uint32_t        arm_32bit_isa   : 4,
	    arm_thumb_ver   : 4,
	    arm_jazelle             : 4,
	    arm_thumb2              : 4,
	    reserved                : 16;
} arm_feature_bits_t;
struct{
	uint32_t endianness_support     : 4;
	uint32_t exception_1_support    : 4;
	uint32_t exception_2_support    : 4;
	uint32_t sign_zero_ext_support  : 4;
	uint32_t if_then_support        : 4;
	uint32_t immediate_support      : 4;
	uint32_t interworking_support   : 4;
	uint32_t jazelle_support        : 4;
}
syscp_ID_instructions_feat_1_reg;
struct {
	boolean_t               memory_mapped_core_debug;
	boolean_t               coprocessor_core_debug;
	uint32_t                num_watchpoint_pairs;
	uint32_t                num_breakpoint_pairs;
} arm_debug_info_t;
struct{
	vm_offset_t far;
}
ex_cb_state_t;
struct ml_cpu_info {
	unsigned long           vector_unit;
	unsigned long           cache_line_size;
	unsigned long           l1_icache_size;
	unsigned long           l1_dcache_size;
	unsigned long           l2_settings;
	unsigned long           l2_cache_size;
	unsigned long           l3_settings;
	unsigned long           l3_cache_size;
};
struct ml_processor_info {
	cpu_id_t                        cpu_id;
	vm_offset_t                     start_paddr;
	boolean_t                       supports_nap;
	void                            *platform_cache_dispatch;
	time_base_enable_t              time_base_enable;
	processor_idle_t                processor_idle;
	idle_tickle_t                   *idle_tickle;
	idle_timer_t                    idle_timer;
	void                            *idle_timer_refcon;
	vm_offset_t                     powergate_stub_addr;
	uint32_t                        powergate_stub_length;
	uint32_t                        powergate_latency;
	platform_error_handler_t        platform_error_handler;
	uint64_t                        regmap_paddr;
	uint32_t                        phys_id;
	uint32_t                        log_id;
	uint32_t                        l2_access_penalty; 
	uint32_t                        cluster_id;
	cluster_type_t                  cluster_type;
	uint32_t                        l2_cache_id;
	uint32_t                        l2_cache_size;
	uint32_t                        l3_cache_id;
	uint32_t                        l3_cache_size;
};
struct  tbd_ops {
	fiq_handler_t     tbd_fiq_handler;
	get_decrementer_t tbd_get_decrementer;
	set_decrementer_t tbd_set_decrementer;
};
struct arm_matrix_cpu_state {
};
struct _preemption_disable_pcpu {
	struct _preemption_disable_snap {
		
		uint64_t pds_mach_time;
		
		uint64_t pds_int_mach_time;
	}
	pdp_start;

	_Atomic uint64_t pdp_max_mach_duration;
	bool pdp_abandon;
};
struct _rtclock_data_ {
	uint32_t                                                rtc_sec_divisor;
	uint32_t                                                rtc_usec_divisor;
	mach_timebase_info_data_t               rtc_timebase_const;
	union {
		uint64_t                abstime;
		struct {
			uint32_t        low;
			uint32_t        high;
		} abstime_val;
	}                                                               rtc_base;
	union {
		uint64_t                abstime;
		struct {
			uint32_t        low;
			uint32_t        high;
		} abstime_val;
	}                                                               rtc_adj;
	tbd_ops_data_t                                  rtc_timebase_func;

	vm_offset_t                                             rtc_timebase_addr;
	vm_offset_t                                             rtc_timebase_val;
} rtclock_data_t;
struct jmp_buf {
	int   jmp_buf[28];
} jmp_buf_t;
struct perfcontrol_state {
	uint64_t opaque[8] __attribute__((aligned(8)));
};
struct machine_thread {

	uint32_t                  arm_machine_flags;       
	arm_context_t *           contextData;             
	arm_saved_state_t *       XNU_PTRAUTH_SIGNED_PTR("machine_thread.upcb") upcb;   
	arm_neon_saved_state_t *  XNU_PTRAUTH_SIGNED_PTR("machine_thread.uNeon") uNeon; 
	arm_saved_state_t *       kpcb;                    


	long                      reserved4;
	uint64_t                  recover_far;

	arm_debug_state_t        *DebugData;
	vm_address_t              cthread_self;               

	uint64_t                  recover_esr;

	void *                    XNU_PTRAUTH_SIGNED_PTR("machine_thread.kstackptr") kstackptr; 
	struct perfcontrol_state  perfctrl_state;
	uint64_t                  reserved5;



	uint64_t                  reserved6;
	union {
		long              pcpu_data_base_and_cpu_number;
		const uint16_t    cpu_number;
	};
	struct cpu_data *         CpuDatap;               
	unsigned int              preemption_count;       
	uint16_t                  exception_trace_code;
	bool                      reserved7;
	bool                      reserved8;

	uint64_t                  reserved11;

};
struct lowglo {
	unsigned char lgVerCode[8];            
	uint64_t      lgZero;                  
	uint64_t      lgStext;                 
	uint64_t      lgVersion;               
	uint64_t      lgOSVersion;             
	uint64_t      lgKmodptr;               
	uint64_t      lgTransOff;              
	uint64_t      lgRebootFlag;            
	uint64_t      lgManualPktAddr;         
	uint64_t      lgAltDebugger;           
	uint64_t      lgPmapMemQ;              
	uint64_t      lgPmapMemPageOffset;     
	uint64_t      lgPmapMemChainOffset;    
	uint64_t      lgStaticAddr;            
	uint64_t      lgStaticSize;            
	uint64_t      lgLayoutMajorVersion;    
	uint64_t      lgLayoutMagic;           
	uint64_t      lgPmapMemStartAddr;      
	uint64_t      lgPmapMemEndAddr;        
	uint64_t      lgPmapMemPagesize;       
	uint64_t      lgPmapMemFromArrayMask;  
	uint64_t      lgPmapMemFirstppnum;     
	uint64_t      lgPmapMemPackedShift;    
	uint64_t      lgPmapMemPackedBaseAddr; 
	uint64_t      lgLayoutMinorVersion;    
	uint64_t      lgPageShift;             
	uint64_t      lgVmFirstPhys;           
	uint64_t      lgVmLastPhys;            
	uint64_t      lgPhysMapBase;           
	uint64_t      lgPhysMapEnd;            
	uint64_t      lgPmapIoRangePtr;        
	uint64_t      lgNumPmapIoRanges;       
	uint64_t      lgCompressorBufferAddr;  
	uint64_t      lgCompressorSizeAddr;    
} lowglo;
struct {
	uint64_t        el0_not_implemented             : 1,
	    el0_aarch64_only                : 1,
	    el0_aarch32_and_64              : 1,
	    el1_not_implemented             : 1,
	    el1_aarch64_only                : 1,
	    el1_aarch32_and_64              : 1,
	    el2_not_implemented             : 1,
	    el2_aarch64_only                : 1,
	    el2_aarch32_and_64              : 1,
	    el3_not_implemented             : 1,
	    el3_aarch64_only                : 1,
	    el3_aarch32_and_64              : 1,
	    reserved                                : 52;
} arm_feature_bits_t;
struct {
	uint32_t        num_watchpoint_pairs;
	uint32_t        num_breakpoint_pairs;
} arm_debug_info_t;
struct pal_hib_ctx {
};
struct {
	uint64_t dockChannelRegPhysBase;
	uint64_t dockChannelRegVirtBase;
	uint32_t dockChannelWstatMask;
	uint64_t hibUartRegPhysBase;
	uint64_t hibUartRegVirtBase;
	uint64_t hmacRegBase;
	uint64_t kernelSlide;
} pal_hib_globals_t;
struct{
	uint64_t ttbr0;
	uint64_t ttbr1;
	uint64_t memSlide;
} pal_hib_tramp_result_t;
struct bank_element {
	unsigned int  be_type:31,                
	    be_voucher_ref:1;                    
	os_ref_atomic_t be_refs;                 
	unsigned int  be_made;                   
};
struct bank_task {
	struct bank_element       bt_elem;                 
	struct proc_persona_info  bt_proc_persona;         
	ledger_t                  bt_ledger;               
	queue_head_t              bt_accounts_to_pay;      
	queue_head_t              bt_accounts_to_charge;   
	decl_lck_mtx_data(, bt_acc_to_pay_lock);           
	decl_lck_mtx_data(, bt_acc_to_charge_lock);        
	uint32_t                  bt_persona_uid;          
	uint32_t                  bt_hasentitlement:1;     
};
struct bank_persona {
	uint32_t persona_id;
	uint32_t persona_uid;
};
struct bank_account {
	struct bank_element ba_elem;                 
	ledger_t            ba_bill;                 
	bank_task_t         ba_merchant;             
	bank_task_t         ba_holder;               
	bank_task_t         ba_secureoriginator;     
	bank_task_t         ba_proximateprocess;     
	queue_chain_t       ba_next_acc_to_pay;      
	queue_chain_t       ba_next_acc_to_charge;   
	struct bank_persona ba_so_persona;           
};
struct _bank_ledger_indices {
	int cpu_time;
	int energy;
};
struct proc_persona_info {
	uint64_t unique_pid;
	int32_t  pid;
	uint32_t flags;
	uint32_t pidversion;
	uint32_t persona_id;
	uint32_t uid;
	uint32_t gid;
	uint8_t  macho_uuid[16];
};
struct persona_token {
	struct proc_persona_info originator;
	struct proc_persona_info proximate;
};
struct persona_modify_info {
	uint32_t persona_id;
	uint64_t unique_pid;
};
struct console_ops {
	void (*putc)(char, bool);
	int (*getc)(bool);
};
struct console_printbuf_state {
	int pos;
	int total;
	int flags;
	char str[SERIAL_CONS_BUF_SIZE];
};
struct vc_progress_user_options {
	uint32_t options;
	uint32_t x_pos;
	uint32_t y_pos;
	uint32_t resv[8];
};
struct vc_info {
	unsigned int    v_height;       
	unsigned int    v_width;        
	unsigned int    v_depth;
	unsigned int    v_rowbytes;
	unsigned long   v_baseaddr;
	unsigned int    v_type;
	char            v_name[32];
	uint64_t        v_physaddr;
	unsigned int    v_rows;         
	unsigned int    v_columns;      
	unsigned int    v_rowscanbytes; 
	unsigned int    v_scale;
	unsigned int    v_rotate;
	unsigned int    v_reserved[3];
};
struct vc_progress_element {
	unsigned int        version;
	unsigned int        flags;
	unsigned int        time;
	unsigned char       count;
	unsigned char       res[3];
	int                 width;
	int                 height;
	int                 dx;
	int                 dy;
	int                 transparent;
	unsigned int        res2[3];
};
struct ccdrbg_nistctr_state {
	uint8_t Key[DRBG_CTR_MAX_KEYLEN];
	uint8_t V[DRBG_CTR_MAX_BLOCKLEN];
	uint64_t reseed_counter; 
	struct ccdrbg_nistctr_custom custom;
};
struct _ccmode_gcm_key {
	unsigned char H[16];   
	unsigned char X[16];   
	unsigned char Y[16];   
	unsigned char Y_0[16]; 
	unsigned char buf[16];  

	uint16_t state;    
	uint16_t flags;    
	uint32_t buf_nbytes; 

	uint64_t aad_nbytes; 
	uint64_t text_nbytes; 

	const struct ccmode_ecb *ecb;          
	void *ecb_key;                         
	int encdec; 

	CC_ALIGNED(16) unsigned char u[]; 
};
struct _ccmode_cbc_key {
	const struct ccmode_ecb *ecb;
	cc_unit u[];
};
struct _ccmode_cfb_key {
	const struct ccmode_ecb *ecb;
	size_t pad_len;
	cc_unit u[];
};
struct _ccmode_cfb8_key {
	const struct ccmode_ecb *ecb;
	cc_unit u[];
};
struct _ccmode_ctr_key {
	const struct ccmode_ecb *ecb;
	size_t pad_offset;
	cc_unit u[];
};
struct _ccmode_ofb_key {
	const struct ccmode_ecb *ecb;
	size_t pad_len;
	cc_unit u[];
};
struct _ccmode_xts_key {
	const struct ccmode_ecb *ecb;
	const struct ccmode_ecb *ecb_encrypt;
	cc_unit u[];
};
struct _ccmode_xts_tweak {
	size_t  blocks_processed;
	cc_unit u[];
};
struct _ccmode_ccm_key {
	const struct ccmode_ecb *ecb;
	cc_unit u[];
};
struct _ccmode_omac_key {
	const struct ccmode_ecb *ecb;
	size_t tweak_len;
	cc_unit u[];
};
struct ccn_rjsf_state {
	uint8_t u[2];
	const cc_unit *s;
	const cc_unit *t;
};
struct cc_ws {
	void *ctx;
	cc_size nunits;
	cc_size offset;
	cc_unit *(*CC_SPTR(cc_ws, alloc))(cc_ws_t ws, cc_size n);
	void(*CC_SPTR(cc_ws, free))(cc_ws_t ws);
};
struct x86_affinity_set {
	struct x86_affinity_set     *next;
	struct x86_cpu_cache        *cache;
	processor_set_t             pset;
	uint32_t                    num;
} x86_affinity_set_t;
struct rtclock_timer {
	mpqueue_head_t          queue;
	uint64_t                deadline;
	uint64_t                when_set;
	boolean_t               has_expired;
} rtclock_timer_t;
struct {
	struct x86_64_tss       *cdi_ktssu;
	struct x86_64_tss       *cdi_ktssb;
	x86_64_desc_register_t  cdi_gdtu;
	x86_64_desc_register_t  cdi_gdtb;
	x86_64_desc_register_t  cdi_idtu;
	x86_64_desc_register_t  cdi_idtb;
	struct real_descriptor  *cdi_ldtu;
	struct real_descriptor  *cdi_ldtb;
	vm_offset_t             cdi_sstku;
	vm_offset_t             cdi_sstkb;
} cpu_desc_index_t;
struct {
	addr64_t        cu_isf;         
	uint64_t        cu_tmp;         
	addr64_t        cu_user_gs_base;
} cpu_uber_t;
struct {
	boolean_t pltype;
	int plevel;
	uint64_t plbt[MAX_TRACE_BTFRAMES];
} plrecord_t;
struct {
	pcid_t                  cpu_pcid_free_hint;
	pcid_ref_t              cpu_pcid_refcounts[PMAP_PCID_MAX_PCID];
	pmap_t                  cpu_pcid_last_pmap_dispatched[PMAP_PCID_MAX_PCID];
} pcid_cdata_t;
struct cpu_data {
	struct pal_cpu_data     cpu_pal_data;           
	struct cpu_data         *cpu_this;              
	vm_offset_t             cpu_pcpu_base;
	thread_t                cpu_active_thread;
	thread_t                cpu_nthread;
	int                     cpu_number;             
	void                    *cpu_int_state;         
	vm_offset_t             cpu_active_stack;       
	vm_offset_t             cpu_kernel_stack;       
	vm_offset_t             cpu_int_stack_top;
	volatile int            cpu_signals;            
	volatile int            cpu_prior_signals;      
	ast_t                   cpu_pending_ast;
	int                     cpu_interrupt_level;
	volatile int            cpu_preemption_level;
	volatile int            cpu_running;
	rtclock_timer_t         rtclock_timer;
	volatile addr64_t       cpu_active_cr3 __attribute((aligned(64)));
	union {
		volatile uint32_t cpu_tlb_invalid;
		struct {
			volatile uint16_t cpu_tlb_invalid_local;
			volatile uint16_t cpu_tlb_invalid_global;
		};
	};
	uint64_t                cpu_ip_desc[2];
	volatile task_map_t     cpu_task_map;
	volatile addr64_t       cpu_task_cr3;
	addr64_t                cpu_kernel_cr3;
	volatile addr64_t       cpu_ucr3;
	volatile addr64_t       cpu_shadowtask_cr3;
	boolean_t               cpu_pagezero_mapped;
	cpu_uber_t              cpu_uber;

	uintptr_t               cd_estack;
	int                     cpu_xstate;
	int                     cpu_curtask_has_ldt;
	int                     cpu_curthread_do_segchk;

	void                    *cd_shadow;
	union {
		volatile uint32_t cpu_tlb_invalid_count;
		struct {
			volatile uint16_t cpu_tlb_invalid_local_count;
			volatile uint16_t cpu_tlb_invalid_global_count;
		};
	};

	uint16_t                cpu_tlb_gen_counts_local[MAX_CPUS];
	uint16_t                cpu_tlb_gen_counts_global[MAX_CPUS];

	struct processor        *cpu_processor;
	struct real_descriptor  *cpu_ldtp;
	struct cpu_desc_table   *cpu_desc_tablep;
	cpu_desc_index_t        cpu_desc_index;
	int                     cpu_ldt;

	uint32_t                cpu_hwIntCnt[HWINTCNT_SIZE];    
	uint64_t                cpu_hwIntpexits[HWINTCNT_SIZE];
	uint64_t                cpu_dr7; 
	uint64_t                cpu_int_event_time;     
	pal_rtc_nanotime_t      *cpu_nanotime;          
	uint32_t                cpu_pmap_pcid_enabled;
	pcid_t                  cpu_active_pcid;
	pcid_t                  cpu_last_pcid;
	pcid_t                  cpu_kernel_pcid;
	volatile pcid_ref_t     *cpu_pmap_pcid_coherentp;
	volatile pcid_ref_t     *cpu_pmap_pcid_coherentp_kernel;
	pcid_cdata_t            *cpu_pcid_data;
	uint64_t                cpu_aperf;
	uint64_t                cpu_mperf;
	uint64_t                cpu_c3res;
	uint64_t                cpu_c6res;
	uint64_t                cpu_c7res;
	uint64_t                cpu_itime_total;
	uint64_t                cpu_rtime_total;
	uint64_t                cpu_ixtime;
	uint64_t                cpu_idle_exits;
	uint64_t                cpu_rtimes[CPU_RTIME_BINS];
	uint64_t                cpu_itimes[CPU_ITIME_BINS];
	uint64_t                cpu_gpmcs[4];
	uint64_t                cpu_max_observed_int_latency;
	int                     cpu_max_observed_int_latency_vector;
	volatile boolean_t      cpu_NMI_acknowledged;
	uint64_t                debugger_entry_time;
	uint64_t                debugger_ipi_time;
	uint32_t                cpu_nested_istack;
	uint32_t                cpu_nested_istack_events;
	x86_saved_state64_t     *cpu_fatal_trap_state;
	x86_saved_state64_t     *cpu_post_fatal_trap_state;
	int                     cpu_type;
	int                     cpu_subtype;
	int                     cpu_threadtype;
	boolean_t               cpu_iflag;
	boolean_t               cpu_boot_complete;
	int                     cpu_hibernate;
	struct x86_lcpu         lcpu;
	int                     cpu_phys_number;        
	cpu_id_t                cpu_id;                 
	boolean_t               cpu_rendezvous_in_progress;
	uint32_t                cpu_soft_apic_lvt_timer;
} cpu_data_t;
struct x86_cpu_cache {
	struct x86_cpu_cache *next;     
	struct x86_die      *die;       
	uint8_t             maxcpus;    
	uint8_t             nlcpus;     
	uint8_t             type;       
	uint8_t             level;      
	uint16_t            ways;       
	uint16_t            partitions; 
	uint16_t            line_size;  
	uint32_t            cache_size; 
	struct x86_lcpu     *cpus[0];   
} x86_cpu_cache_t;
struct x86_lcpu {
	struct x86_lcpu     *next_in_core;
	struct x86_lcpu     *next_in_die;
	struct x86_lcpu     *next_in_pkg;
	struct x86_lcpu     *lcpu;      
	struct x86_core     *core;      
	struct x86_die      *die;       
	struct x86_pkg      *package;   
	struct cpu_data     *cpu;       
	uint32_t            flags;
	uint32_t            cpu_num;    
	uint32_t            lnum;       
	uint32_t            pnum;       
	boolean_t           master;     
	boolean_t           primary;    
	volatile lcpu_state_t       state;
	volatile boolean_t  stopped;    
	uint64_t            rtcPop;     
	uint64_t            rtcDeadline;
	x86_cpu_cache_t     *caches[MAX_CACHE_DEPTH];
	void                *pmStats;   
	void                *pmState;   
} x86_lcpu_t;
struct x86_core {
	struct x86_core     *next_in_die;
	struct x86_core     *next_in_pkg;
	struct x86_die      *die;       
	struct x86_pkg      *package;   
	struct x86_lcpu     *lcpus;     
	uint32_t            flags;
	uint32_t            lcore_num;  
	uint32_t            pcore_num;  
	uint32_t            num_lcpus;  
	uint32_t            active_lcpus;
	void                *pmStats;   
	void                *pmState;   
} x86_core_t;
struct x86_die {
	struct x86_die      *next_in_pkg;
	struct x86_lcpu     *lcpus;     
	struct x86_core     *cores;     
	struct x86_pkg      *package;   
	uint32_t            flags;
	uint32_t            ldie_num;   
	uint32_t            pdie_num;   
	uint32_t            num_cores;  
	x86_cpu_cache_t     *LLC;       
	void                *pmStats;   
	void                *pmState;   
} x86_die_t;
struct x86_pkg {
	struct x86_pkg      *next;      
	struct x86_lcpu     *lcpus;     
	struct x86_core     *cores;     
	struct x86_die      *dies;      
	uint32_t            flags;
	uint32_t            lpkg_num;   
	uint32_t            ppkg_num;   
	uint32_t            num_dies;   
	void                *pmStats;   
	void                *pmState;   
	struct mca_state    *mca_state; 
	uint64_t            package_idle_exits;
	uint32_t            num_idle;
} x86_pkg_t;
struct x86_topology_parameters {
	uint32_t            LLCDepth;
	uint32_t            nCoresSharingLLC;
	uint32_t            nLCPUsSharingLLC;
	uint32_t            maxSharingLLC;
	uint32_t            nLThreadsPerCore;
	uint32_t            nPThreadsPerCore;
	uint32_t            nLCoresPerDie;
	uint32_t            nPCoresPerDie;
	uint32_t            nLDiesPerPackage;
	uint32_t            nPDiesPerPackage;
	uint32_t            nLThreadsPerDie;
	uint32_t            nPThreadsPerDie;
	uint32_t            nLThreadsPerPackage;
	uint32_t            nPThreadsPerPackage;
	uint32_t            nLCoresPerPackage;
	uint32_t            nPCoresPerPackage;
	uint32_t            nPackages;
	boolean_t           stable;
} x86_topology_parameters_t;
struct diagWork {                       
	unsigned int dgLock;                    
	unsigned int dgFlags;                   

	unsigned int dgMisc0;
	unsigned int dgMisc1;
	unsigned int dgMisc2;
	unsigned int dgMisc3;
	unsigned int dgMisc4;
	unsigned int dgMisc5;
} diagWork;
struct exec {
	unsigned long a_text;   
	unsigned long a_data;   
	unsigned long a_bss;    
	unsigned long a_syms;   
	unsigned long a_entry;  
	unsigned long a_trsize; 
	unsigned long a_drsize; 
};
struct hpetReg {
	uint64_t        GCAP_ID;                
	uint64_t        rsv1;
	uint64_t        GEN_CONF;               
	uint64_t        rsv2;
	uint64_t        GINTR_STA;              
	uint64_t        rsv3[25];
	uint64_t        MAIN_CNT;               
	uint64_t        rsv4;
	uint64_t        TIM0_CONF;              
	uint64_t        TIM0_COMP;              
	uint64_t        rsv5[2];
	uint64_t        TIM1_CONF;              
	uint64_t        TIM1_COMP;              
	uint64_t        rsv6[2];
	uint64_t        TIM2_CONF;              
	uint64_t        TIM2_COMP;              
	uint64_t        rsv7[2];
} hpetReg;
struct hpetTimer {
	uint64_t        Config;         
	uint64_t        Compare;        
} hpetTimer_t;
struct hpetInfo {
	uint64_t        hpetCvtt2n;
	uint64_t        hpetCvtn2t;
	uint64_t        tsc2hpet;
	uint64_t        hpet2tsc;
	uint64_t        bus2hpet;
	uint64_t        hpet2bus;
	uint32_t        rcbaArea;
	uint32_t        rcbaAreap;
};
struct hpetRequest {
	uint32_t        flags;
	uint32_t        hpetOffset;
	uint32_t        hpetVector;
};
struct iopb_tss {
	struct i386_tss tss;            
	isa_iopb        bitmap;         
	unsigned int    barrier;        
	queue_head_t    io_port_list;   
	int             iopb_desc[2];   
};
struct {
	void            (*init)(void);
	uint32_t        (*read)(lapic_register_t);
	void            (*write)(lapic_register_t, uint32_t);
	uint64_t        (*read_icr)(void);
	void            (*write_icr)(uint32_t, uint32_t);
} lapic_ops_table_t;
struct lbr_data {
	uint64_t *from;
	uint64_t *to;
};
struct {
	volatile uintptr_t      interlock __kernel_data_semantics;
} lck_spin_t;
struct {
	machdep_call_routine_t      routine;
	int                         nargs;
	int                         bsd_style;
} machdep_call_t;
struct ml_processor_info {
	cpu_id_t                        cpu_id;
	boolean_t                       boot_cpu;
	vm_offset_t                     start_paddr;
	boolean_t                       supports_nap;
	unsigned long           l2cr_value;
	time_base_enable_t      time_base_enable;
};
struct ml_cpu_info {
	uint32_t        vector_unit;
	uint32_t        cache_line_size;
	uint32_t        l1_icache_size;
	uint32_t        l1_dcache_size;
	uint32_t        l2_settings;
	uint32_t        l2_cache_size;
	uint32_t        l3_settings;
	uint32_t        l3_cache_size;
};
struct cpu_desc_table64 {
	struct fake_descriptor  gdt[GDTSZ]       __attribute__ ((aligned(16)));
	struct x86_64_tss       ktss             __attribute__ ((aligned(16)));
	struct sysenter_stack   sstk             __attribute__ ((aligned(16)));
	uint8_t                 *fstkp;
} cpu_desc_table64_t;
struct {
	uint8_t                 fstk[FSTK_SZ]  __attribute__ ((aligned(16)));
} cpu_fault_stack_t;
struct pal_hib_ctx {
	char reserved;
};
struct pal_rtc_nanotime {
	volatile uint64_t       tsc_base;       
	volatile uint64_t       ns_base;        
	uint32_t                scale;          
	uint32_t                shift;          
	                                        
	volatile uint32_t       generation;     
	uint32_t                spare1;
};
struct pal_cpu_data {
};
struct pal_pcb {
};
struct pal_apic_table {
};
struct pal_efi_registers {
	uint64_t rcx;
	uint64_t rdx;
	uint64_t r8;
	uint64_t r9;
	uint64_t rax;
};
struct {
	uint64_t        opaque[6];
} panic_hook_t;
struct panic_phys_range {
	uint32_t type;
	uint64_t phys_start;
	uint64_t len;
} panic_phys_range_t;
struct pmap {
	lck_rw_t        pmap_rwl __attribute((aligned(64)));
	pmap_paddr_t    pm_cr3 __attribute((aligned(64))); 
	pmap_paddr_t    pm_ucr3;        
	pml4_entry_t    *pm_pml4;       
	pml4_entry_t    *pm_upml4;      
	pmap_paddr_t    pm_eptp;        

	task_map_t      pm_task_map;
	boolean_t       pagezero_accessible;
	boolean_t       pm_vm_map_cs_enforced; 
	pcid_t          pmap_pcid_cpus[PMAP_PCID_MAX_CPUS];
	volatile uint8_t pmap_pcid_coherency_vector[PMAP_PCID_MAX_CPUS];
	boolean_t       pm_shared;
	os_refcnt_t     ref_count;
	pdpt_entry_t    *pm_pdpt;       
	vm_object_t     pm_obj;         
	vm_object_t     pm_obj_pdpt;    
	vm_object_t     pm_obj_pml4;    
	ledger_t        ledger;         
	uint64_t        corrected_compressed_ptes_count;
};
struct pmap_memory_regions {
	ppnum_t base;            
	ppnum_t alloc_up;        
	ppnum_t alloc_down;      
	ppnum_t alloc_frag_up;   
	ppnum_t alloc_frag_down; 
	ppnum_t end;             
	uint32_t type;
	uint64_t attribute;
} pmap_memory_region_t;
struct pv_rooted_entry {
	queue_head_t            qlink;
	vm_map_offset_t         va_and_flags;   
	pmap_t                  pmap;   
} *pv_rooted_entry_t;
struct pv_hashed_entry {
	queue_head_t            qlink;
	vm_map_offset_t         va_and_flags;
	pmap_t                  pmap;
	ppnum_t                 ppn;
	struct pv_hashed_entry  *nexth;
} *pv_hashed_entry_t;
struct {
	pmap_pv_assertion_t incident;
	pmap_pagetable_corruption_t reason;
	pmap_pagetable_corruption_action_t action;
	pmap_t  pmap;
	vm_map_offset_t vaddr;
	pt_entry_t pte;
	ppnum_t ppn;
	pmap_t pvpmap;
	vm_map_offset_t pvva;
	uint64_t abstime;
	int adj_ptes_count;
	uint64_t adj_ptes[PMPTCR_MAX_ADJ_PTES];
} pmap_pagetable_corruption_record_t;
struct{
	kern_return_t       (*pmCPUStateInit)(void);
	void                (*cstateInit)(void);
	uint64_t            (*MachineIdle)(uint64_t maxIdleDuration);
	uint64_t            (*GetDeadline)(x86_lcpu_t *lcpu);
	uint64_t            (*SetDeadline)(x86_lcpu_t *lcpu, uint64_t);
	void                (*Deadline)(x86_lcpu_t *lcpu);
	boolean_t           (*exitIdle)(x86_lcpu_t *lcpu);
	void                (*markCPURunning)(x86_lcpu_t *lcpu);
	int                 (*pmCPUControl)(uint32_t cmd, void *datap);
	void                (*pmCPUHalt)(void);
	uint64_t            (*getMaxSnoop)(void);
	void                (*setMaxBusDelay)(uint64_t time);
	uint64_t            (*getMaxBusDelay)(void);
	void                (*setMaxIntDelay)(uint64_t time);
	uint64_t            (*getMaxIntDelay)(void);
	void                (*pmCPUSafeMode)(x86_lcpu_t *lcpu, uint32_t flags);
	void                (*pmTimerStateSave)(void);
	void                (*pmTimerStateRestore)(void);
	kern_return_t       (*exitHalt)(x86_lcpu_t *lcpu);
	kern_return_t       (*exitHaltToOff)(x86_lcpu_t *lcpu);
	void                (*markAllCPUsOff)(void);
	void                (*pmSetRunCount)(uint32_t count);
	boolean_t           (*pmIsCPUUnAvailable)(x86_lcpu_t *lcpu);
	int                 (*pmChooseCPU)(int startCPU, int endCPU, int preferredCPU);
	int                 (*pmIPIHandler)(void *state);
	void                (*pmThreadTellUrgency)(int urgency, uint64_t rt_period, uint64_t rt_deadline);
	void                (*pmActiveRTThreads)(boolean_t active);
	boolean_t           (*pmInterruptPrewakeApplicable)(void);
	void                (*pmThreadGoingOffCore)(thread_t old_thread, boolean_t transfer_load,
	    uint64_t last_dispatch, boolean_t thread_runnable);
} pmDispatch_t;
struct pm_rtc_nanotime {
	uint64_t        tsc_base;               
	uint64_t        ns_base;                
	uint32_t        scale;                  
	uint32_t        shift;                  
	uint32_t        generation;             
} pm_rtc_nanotime_t;
struct {
	uint64_t            (*setRTCPop)(uint64_t time);
	void                (*resyncDeadlines)(int cpu);
	void                (*initComplete)(void);
	x86_lcpu_t          *(*GetLCPU)(int cpu);
	x86_core_t          *(*GetCore)(int cpu);
	x86_die_t           *(*GetDie)(int cpu);
	x86_pkg_t           *(*GetPackage)(int cpu);
	x86_lcpu_t          *(*GetMyLCPU)(void);
	x86_core_t          *(*GetMyCore)(void);
	x86_die_t           *(*GetMyDie)(void);
	x86_pkg_t           *(*GetMyPackage)(void);
	x86_pkg_t           *(*GetPkgRoot)(void);
	void                (*LockCPUTopology)(int lock);
	boolean_t           (*GetHibernate)(int cpu);
	processor_t         (*LCPUtoProcessor)(int lcpu);
	processor_t         (*ThreadBind)(processor_t proc);
	uint32_t            (*GetSavedRunCount)(void);
	void                (*pmSendIPI)(int cpu);
	void                (*GetNanotimeInfo)(pm_rtc_nanotime_t *);
	int                 (*ThreadGetUrgency)(uint64_t *rt_period, uint64_t *rt_deadline);
	uint32_t            (*timerQueueMigrate)(int cpu);
	void                (*RTCClockAdjust)(uint64_t adjustment);
	x86_topology_parameters_t   *topoParms;
	boolean_t           (*InterruptPending)(void);
	boolean_t           (*IsInterrupting)(uint8_t vector);
	void                (*InterruptStats)(uint64_t intrs[256]);
	void                (*DisableApicTimer)(void);
} pmCallBacks_t;
struct x86_lbr_record {
	uint64_t        from_rip;
	uint64_t        to_rip;
	uint64_t        info;
};
struct x86_lbrs {
	uint64_t                lbr_tos;
	struct x86_lbr_record   lbrs[X86_MAX_LBRS];
} x86_lbrs_t;
struct {
	void     (*rtc_config)(void);
	uint64_t (*rtc_set)(uint64_t, uint64_t);
} rtc_timer_t;
struct real_descriptor {
	uint32_t        limit_low:16,   
	    base_low:16,                
	    base_med:8,                 
	    access:8,                   
	    limit_high:4,               
	    granularity:4,              
	    base_high:8;                
};
struct real_descriptor64 {
	uint32_t        limit_low16:16, 
	    base_low16:16,              
	    base_med8:8,                
	    access8:8,                  
	    limit_high4:4,              
	    granularity4:4,             
	    base_high8:8,               
	    base_top32:32,              
	    reserved32:32;              
};
struct real_gate {
	uint32_t        offset_low:16,  
	    selector:16,
	    word_count:8,
	    access:8,
	    offset_high:16;             
};
struct real_gate64 {
	uint32_t        offset_low16:16,        
	    selector16:16,
	    IST:3,
	    zeroes5:5,
	    access8:8,
	    offset_high16:16,                   
	    offset_top32:32,                    
	    reserved32:32;                      
};
struct fake_descriptor {
	uint32_t        offset:32;              
	uint32_t        lim_or_seg:20;          
	                                        
	uint32_t        size_or_wdct:4;         
	                                        
	uint32_t        access:8;               
};
struct fake_descriptor64 {
	uint64_t        offset64;               
	uint32_t        lim_or_seg:20;          
	                                        
	uint32_t        size_or_IST:4;          
	                                        
	uint32_t        access:8;               
	uint32_t        reserved:32;            
};
struct jmp_buf {
	int     jmp_buf[6];     
} jmp_buf_t;
struct x86_kernel_state {
	uint64_t        k_rbx;  
	uint64_t        k_rsp;
	uint64_t        k_rbp;
	uint64_t        k_r12;
	uint64_t        k_r13;
	uint64_t        k_r14;
	uint64_t        k_r15;
	uint64_t        k_rip;
};
struct machine_thread {
	x86_saved_state_t       *iss;
	void                    *ifps;
	void                    *ids;
	decl_simple_lock_data(, lock);           
	xstate_t                xstate;


	struct pal_pcb          pal_pcb;
	uint32_t                specFlags;
	uint64_t                thread_gpu_ns;
	uint32_t                last_xcpm_ttd;
	uint8_t                 last_xcpm_index;
	int                     mthr_do_segchk;
	int                     insn_state_copyin_failure_errorcode;    
	x86_instruction_state_t *insn_state;
	x86_lbrs_t              lbrs;
	bool                    insn_copy_optout;
};
struct tscInfo {
	uint64_t        busFCvtt2n;
	uint64_t        busFCvtn2t;
	uint64_t        tscFreq;
	uint64_t        tscFCvtt2n;
	uint64_t        tscFCvtn2t;
	uint64_t        tscGranularity;
	uint64_t        bus2tsc;
	uint64_t        busFreq;
	uint32_t        flex_ratio;
	uint32_t        flex_ratio_min;
	uint32_t        flex_ratio_max;
};
struct i386_tss {
	uint32_t        back_link;      
	uint32_t        esp0;           
	uint32_t        ss0;            
	uint32_t        esp1;           
	uint32_t        ss1;            
	uint32_t        esp2;           
	uint32_t        ss2;            
	uint32_t        cr3;            
	uint32_t        eip;
	uint32_t        eflags;
	uint32_t        eax;
	uint32_t        ecx;
	uint32_t        edx;
	uint32_t        ebx;
	uint32_t        esp;            
	uint32_t        ebp;
	uint32_t        esi;
	uint32_t        edi;
	uint32_t        es;
	uint32_t        cs;
	uint32_t        ss;             
	uint32_t        ds;
	uint32_t        fs;
	uint32_t        gs;
	uint32_t        ldt;            
	uint16_t        trace_trap;     
	uint16_t        io_bit_map_offset;
};
struct sysenter_stack {
	uint64_t        sysestack[64];  
	uint64_t        top;            
};
struct x86_64_tss {
	uint32_t        reserved1;
	uint64_t        rsp0;           
	uint64_t        rsp1;           
	uint64_t        rsp2;           
	uint32_t        reserved2;
	uint32_t        reserved3;
	uint64_t        ist1;           
	uint64_t        ist2;           
	uint64_t        ist3;           
	uint64_t        ist4;           
	uint64_t        ist5;           
	uint64_t        ist6;           
	uint64_t        ist7;           
	uint32_t        reserved4;
	uint32_t        reserved5;
	uint16_t        reserved6;
	uint16_t        io_bit_map_offset;
};
struct intel_ucupdate {
	uint32_t header_version;
	uint32_t update_revision;
	uint32_t date;
	uint32_t processor_signature;
	uint32_t checksum;
	uint32_t loader_revision;
	uint32_t processor_flags;
	uint32_t data_size;
	uint32_t total_size;

	uint32_t reserved0;
	uint32_t reserved1;
	uint32_t reserved2;

	uint32_t data;
};
struct hvg_hcall_output_regs {
	uint64_t   rax;
	uint64_t   rdi;
	uint64_t   rsi;
	uint64_t   rdx;
	uint64_t   rcx;
	uint64_t   r8;
	uint64_t   r9;
} hvg_hcall_output_regs_t;
struct ipc_entry {
	union {
		struct ipc_object *XNU_PTRAUTH_SIGNED_PTR("ipc_entry.ie_object") ie_object;
		struct ipc_port   *XNU_PTRAUTH_SIGNED_PTR("ipc_entry.ie_object") ie_port;
		struct ipc_pset   *XNU_PTRAUTH_SIGNED_PTR("ipc_entry.ie_object") ie_pset;
		struct ipc_object *XNU_PTRAUTH_SIGNED_PTR("ipc_entry.ie_object") volatile ie_volatile_object;
		struct ipc_entry_table *XNU_PTRAUTH_SIGNED_PTR("ipc_entry.ie_self") ie_self;
	};
	union {
		struct {
			ipc_entry_bits_t    ie_bits;
			union {
				mach_port_index_t ie_next;         
				ipc_table_index_t ie_request;      
			};

			
			uint32_t            ie_dist;
			mach_port_index_t   ie_index;
		};
		struct smr_node             ie_smr_node;
	};
};
struct ipc_eventlink {
	ipc_port_t                  el_port;             
	thread_t                    el_thread;           
	struct ipc_eventlink_base   *el_base;            
	uint64_t                    el_sync_counter;     
	uint64_t                    el_wait_counter;     
};
struct ipc_eventlink_base {
	struct ipc_eventlink          elb_eventlink[2];  
	struct waitq                  elb_waitq;         
	os_refcnt_t                   elb_ref_count;     
	uint8_t                       elb_type;
};
struct ipc_importance_elem {
	os_ref_atomic_t                         iie_bits;       
	mach_voucher_attr_value_reference_t     iie_made;       
	queue_head_t                            iie_kmsgs;      
	uint32_t                                iie_externcnt;  
	uint32_t                                iie_externdrop; 
	uint32_t iie_refs_added;                        
	uint32_t iie_refs_dropped;                      
	uint32_t iie_kmsg_refs_added;                   
	uint32_t iie_kmsg_refs_inherited;               
	uint32_t iie_kmsg_refs_coalesced;               
	uint32_t iie_kmsg_refs_dropped;                 
	uint32_t iie_task_refs_added;                   
	uint32_t iie_task_refs_added_inherit_from;      
	uint32_t iie_task_refs_added_transition;        
	uint32_t iie_task_refs_self_added;              
	uint32_t iie_task_refs_inherited;               
	uint32_t iie_task_refs_coalesced;               
	uint32_t iie_task_refs_dropped;                 
};
struct ipc_importance_task {
	struct ipc_importance_elem iit_elem;    
	task_t                  iit_task;       
	queue_head_t            iit_inherits;   
	queue_t                 iit_updateq;    
	queue_chain_t           iit_updates;    
	queue_chain_t           iit_props;      
	uint64_t                iit_updatetime; 
	uint64_t                iit_transitions;
	uint32_t                iit_assertcnt;  
	uint32_t                iit_legacy_externcnt;  
	uint32_t                iit_legacy_externdrop; 
	uint32_t                iit_receiver:1, 
	    iit_denap:1,                        
	    iit_donor:1,                        
	    iit_live_donor:1,                          
	    iit_updatepolicy:1,                        
	    iit_reserved:3,                            
	    iit_filelocks:24;                          
};
struct ipc_importance_inherit {
	struct ipc_importance_elem      iii_elem;         
	boolean_t                       iii_donating;     
	uint32_t                        iii_depth;        
	ipc_importance_task_t           iii_to_task;      
	ipc_importance_elem_t           iii_from_elem;    
	queue_chain_t                   iii_inheritance;  
};
struct ipc_kmsg {
	queue_chain_t              ikm_link;
	ipc_port_t                 XNU_PTRAUTH_SIGNED_PTR("kmsg.ikm_voucher_port") ikm_voucher_port;   
	struct ipc_importance_elem *ikm_importance;  
	queue_chain_t              ikm_inheritance;  
	uint16_t                   ikm_aux_size;     
	ipc_kmsg_keep_alive_t      ikm_keep_alive;   
	uint8_t                    __ikm_padding;
	uint32_t                   ikm_ppriority;    
	uint32_t                   ikm_signature;    
	ipc_object_copyin_flags_t  ikm_flags;
	mach_msg_qos_t             ikm_qos_override; 

	mach_msg_type_name_t       ikm_voucher_type: 6; 
	ipc_kmsg_type_t            ikm_type: 2;

	union {
		
		uint32_t           ikm_big_data[IKM_BIG_MSG_SIZE / 4];
		struct {
			uint32_t   ikm_small_data[IKM_SMALL_MSG_SIZE / 4];
			void *XNU_PTRAUTH_SIGNED_PTR("kmsg.ikm_kdata") ikm_kdata;
			void *XNU_PTRAUTH_SIGNED_PTR("kmsg.ikm_udata") ikm_udata;
			mach_msg_size_t ikm_kdata_size;
			mach_msg_size_t ikm_udata_size;
		} __attribute__((packed, aligned(4)));
	};
};
struct ipc_object_waitq {
	struct ipc_object       iowq_object;
	struct waitq            iowq_waitq;
};
struct ipc_mqueue {
	circle_queue_head_t     imq_messages;
	mach_port_seqno_t       imq_seqno;
	mach_port_name_t        imq_receiver_name;
	uint16_t                imq_msgcount;
	uint16_t                imq_qlimit;
	uint32_t                imq_context;
	union {
		
		struct klist            imq_klist;
		struct knote            *XNU_PTRAUTH_SIGNED_PTR("ipc_mqueue.knote") imq_inheritor_knote;
		struct turnstile        *XNU_PTRAUTH_SIGNED_PTR("ipc_mqueue.turnstile") imq_inheritor_turnstile;
		thread_t                XNU_PTRAUTH_SIGNED_PTR("ipc_mqueue.thread_ref") imq_inheritor_thread_ref;
		thread_t                XNU_PTRAUTH_SIGNED_PTR("ipc_mqueue.srp_owner_thread") imq_srp_owner_thread;
	};
} *ipc_mqueue_t;
struct ipc_notify_nsenders {
	ipc_port_t              ns_notify;
	mach_port_mscount_t     ns_mscount;
	boolean_t               ns_is_kobject;
} ipc_notify_nsenders_t;
struct ipc_object {
	ipc_object_bits_t _Atomic io_bits;
	ipc_object_refs_t _Atomic io_references;
} __attribute__((aligned(8)));
struct ipc_port_request {
	union {
		struct ipc_port                *ipr_soright;
		struct host_notify_entry *XNU_PTRAUTH_SIGNED_PTR("ipc_port_request.ipr_hnotify") ipr_hnotify;
		struct ipc_port_request *XNU_PTRAUTH_SIGNED_PTR("ipc_port_request.ipr_hn_slot") ipr_hn_slot;
	};

	union {
		mach_port_name_t                ipr_name;
		ipc_port_request_index_t        ipr_next;
	};
};
struct ipc_port {
	struct ipc_object               ip_object;
	union {
		
		WAITQ_FLAGS(ip_waitq
		    , ip_fullwaiters:1            
		    , ip_sprequests:1             
		    , ip_spimportant:1            
		    , ip_impdonation:1            
		    , ip_tempowner:1              
		    , ip_guarded:1                
		    , ip_strict_guard:1           
		    , ip_specialreply:1           
		    , ip_sync_link_state:3        
		    , ip_sync_bootstrap_checkin:1 
		    , ip_immovable_receive:1      
		    , ip_immovable_send:1         
		    , ip_no_grant:1               
		    , ip_tg_block_tracking:1      
		    , ip_pinned:1                 
		    , ip_service_port:1           
		    , ip_has_watchport:1          
		    , ip_kernel_iotier_override:2 
		    , ip_kernel_qos_override:3    
		    , ip_reply_port_semantics:3   
		    );
		struct waitq            ip_waitq;
	};

	struct ipc_mqueue               ip_messages;

	union {
		struct ipc_space       *XNU_PTRAUTH_SIGNED_PTR("ipc_port.ip_receiver") ip_receiver;
		struct ipc_port        *XNU_PTRAUTH_SIGNED_PTR("ipc_port.ip_destination") ip_destination;
		ipc_port_timestamp_t    ip_timestamp;
	};

	union {
		uintptr_t               ip_kobject; 
		ipc_importance_task_t   ip_imp_task; 
		struct ipc_port        *ip_sync_inheritor_port;
		struct knote           *ip_sync_inheritor_knote;
		struct turnstile       *ip_sync_inheritor_ts;
	};

	union {
		int                     ip_pid;
		struct task_watchport_elem *XNU_PTRAUTH_SIGNED_PTR("ipc_port.ip_twe") ip_twe;
		struct ipc_port *XNU_PTRAUTH_SIGNED_PTR("ipc_port.ip_pdrequest") ip_pdrequest;
	};

	struct ipc_port                *ip_nsrequest;
	ipc_port_request_table_t XNU_PTRAUTH_SIGNED_PTR("ipc_port.ip_request") ip_requests;
	struct turnstile               *ip_send_turnstile;
	mach_vm_address_t               ip_context;

	mach_port_mscount_t             ip_mscount;
	mach_port_rights_t              ip_srights;
	mach_port_rights_t              ip_sorights;

	union {
		ipc_kobject_label_t XNU_PTRAUTH_SIGNED_PTR("ipc_port.kolabel") ip_kolabel;
		
		void * XNU_PTRAUTH_SIGNED_PTR("ipc_port.ip_splabel") ip_splabel;
	};

};
struct thread_attr_for_ipc_propagation {
	union {
		struct {
			uint64_t tafip_iotier:2,
			    tafip_qos:3;
		};
		uint64_t tafip_value;
	};
	uint64_t tafip_reserved;
};
struct ipc_pset {
	struct ipc_object       ips_object;
	struct waitq_set        ips_wqset;
	struct klist            ips_klist;
};
struct {
	ipc_port_t              icc_release_port;
	ipc_port_t              icc_deleted_port;
} ipc_copyin_cleanup_t;
struct {
	waitq_link_list_t       icrc_free_list;
	mach_msg_guarded_port_descriptor_t *icrc_guarded_desc;
} ipc_copyin_rcleanup_t;
struct ipc_service_port_label {
	void * XNU_PTRAUTH_SIGNED_PTR("ipc_service_port_label.ispl_sblabel") ispl_sblabel; 
	mach_port_context_t               ispl_launchd_context;     
	mach_port_name_t                  ispl_launchd_name;        
	ipc_service_port_label_flags_t    ispl_flags;
};
struct ipc_voucher {
	os_ref_atomic_t         iv_refs;        
	iv_index_t              iv_table[MACH_VOUCHER_ATTR_KEY_NUM];
	ipc_port_t              iv_port;        
	struct smrq_slink       iv_hash_link;   
};
struct ivac_entry_s {
	iv_value_handle_t       ivace_value;
	iv_value_refs_t         ivace_layered:1,     
	    ivace_releasing:1,                       
	    ivace_free:1,                            
	    ivace_persist:1,                         
	    ivace_refs:28;                           
	union {
		iv_value_refs_t ivaceu_made;         
		iv_index_t      ivaceu_layer;        
	} ivace_u;
	iv_index_t              ivace_next;          
	iv_index_t              ivace_index;         
};
struct ipc_voucher_attr_control {
	boolean_t               ivac_is_growing;        
	ivac_entry_t            ivac_table;             
	iv_index_t              ivac_table_size;        
	iv_index_t              ivac_init_table_size;   
	iv_index_t              ivac_freelist;          
	lck_spin_t              ivac_lock_data;
	iv_index_t              ivac_key_index;
};
struct ipc_voucher_attr_recipe_data {
	mach_voucher_attr_key_t                 key;
	mach_voucher_attr_recipe_command_t      command;
	ipc_voucher_t                           previous_voucher;
	mach_voucher_attr_content_size_t        content_size;
	uint8_t                                 content[];
} ipc_voucher_attr_recipe_data_t;
struct ipc_voucher_attr_manager {
	ipc_voucher_attr_manager_release_value_t        ivam_release_value;
	ipc_voucher_attr_manager_get_value_t            ivam_get_value;
	ipc_voucher_attr_manager_extract_content_t      ivam_extract_content;
	ipc_voucher_attr_manager_command_t              ivam_command;
	ipc_voucher_attr_manager_flags                  ivam_flags;
};
struct main_bin_spec_note {
	uint32_t version;       
	uint32_t type;          
	uint64_t address;       
	uuid_t   uuid;          
	uint32_t log2_pagesize; 
	uint32_t unused;        
} __attribute__((packed)) main_bin_spec_note_t;
struct load_binary_spec_note {
	uint32_t version;    
	uuid_t   uuid;       
	uint64_t address;    
	uint64_t slide;      
	                     
	                     
	char     name_cstring[LOAD_BINARY_NAME_BUF_SIZE];
} __attribute__((packed)) load_binary_spec_note_t;
struct addrable_bits_note {
	uint32_t version;            
	uint32_t addressing_bits;    
	uint64_t unused;             
} __attribute__((packed)) addrable_bits_note_t;
struct panic_context_note {
	uuid_string_t kernel_uuid_string;
} __attribute__((packed)) panic_context_note_t;
struct kdp_fault_result {
	kdp_fault_result_flags_t flags;
	uint64_t time_spent_faulting;
};
struct  corehdr {
	short   th_opcode;              
	union {
		unsigned int    tu_block;       
		unsigned int    tu_code;        
		char    tu_rpl[1];      
	} th_u;
	char    th_data[0];             
}__attribute__((packed));
struct user32_dyld_image_info {
	user32_addr_t   imageLoadAddress;       
	user32_addr_t   imageFilePath;          
	user32_ulong_t  imageFileModDate;       
};
struct user64_dyld_image_info {
	user64_addr_t   imageLoadAddress;       
	user64_addr_t   imageFilePath;          
	user64_ulong_t  imageFileModDate;       
};
struct user32_dyld_all_image_infos {
	uint32_t                                        version;
	uint32_t                                        infoArrayCount;
	user32_addr_t                           infoArray;
	user32_addr_t                           notification;
	dyld_bool                                       processDetachedFromSharedRegion;
	dyld_bool                                       libSystemInitialized;
	user32_addr_t                           dyldImageLoadAddress;
	user32_addr_t                           jitInfo;
	user32_addr_t                           dyldVersion;
	user32_addr_t                           errorMessage;
	user32_addr_t                           terminationFlags;
	user32_addr_t                           coreSymbolicationShmPage;
	user32_addr_t                           systemOrderFlag;
	user32_size_t uuidArrayCount; 
	user32_addr_t uuidArray;
	user32_addr_t dyldAllImageInfosAddress;

	user32_addr_t initialImageCount;
	user32_addr_t errorKind;
	user32_addr_t errorClientOfDylibPath;
	user32_addr_t errorTargetDylibPath;
	user32_addr_t errorSymbol;
	user32_addr_t sharedCacheSlide;
	uint8_t sharedCacheUUID[16];
	user32_addr_t   sharedCacheBaseAddress;
	uint64_t        timestamp;
	user32_addr_t   dyldpath;
	mach_port_name_t notifyMachPorts[DYLD_MAX_PROCESS_INFO_NOTIFY_COUNT];
	user32_addr_t   reserved[5];
	user32_addr_t compact_dyld_image_info_addr;
	user32_size_t compact_dyld_image_info_size;
};
struct user64_dyld_all_image_infos {
	uint32_t                                        version;
	uint32_t                                        infoArrayCount;
	user64_addr_t                           infoArray;
	user64_addr_t                           notification;
	dyld_bool                                       processDetachedFromSharedRegion;
	dyld_bool                                       libSystemInitialized;
	user64_addr_t                           dyldImageLoadAddress;
	user64_addr_t                           jitInfo;
	user64_addr_t                           dyldVersion;
	user64_addr_t                           errorMessage;
	user64_addr_t                           terminationFlags;
	user64_addr_t                           coreSymbolicationShmPage;
	user64_addr_t                           systemOrderFlag;
	user64_size_t uuidArrayCount; 
	user64_addr_t uuidArray;
	user64_addr_t dyldAllImageInfosAddress;

	user64_addr_t initialImageCount;
	user64_addr_t errorKind;
	user64_addr_t errorClientOfDylibPath;
	user64_addr_t errorTargetDylibPath;
	user64_addr_t errorSymbol;
	user64_addr_t sharedCacheSlide;
	uint8_t sharedCacheUUID[16];
	user64_addr_t   sharedCacheBaseAddress;
	uint64_t        timestamp;
	user64_addr_t   dyldPath;
	mach_port_name_t notifyMachPorts[DYLD_MAX_PROCESS_INFO_NOTIFY_COUNT];
	user64_addr_t   reserved[9];
	user64_addr_t compact_dyld_image_info_addr;
	user64_size_t compact_dyld_image_info_size;
	uint32_t        platform;
	uint32_t                                aotInfoArrayCount;
	user64_addr_t                           aotInfoArray;
	uint64_t                                aotTimestamp;
};
struct {
	void                        *saved_state;
	thread_t                    kdp_thread;
	int                         kdp_cpu;
	uint32_t                    session_key;
	unsigned int                conn_seq;
	unsigned short              reply_port;
	unsigned short              exception_port;
	boolean_t                   is_conn;
	boolean_t                   is_halted;
	unsigned char               exception_seq;
	boolean_t                   exception_ack_needed;
} kdp_glob_t;
struct kdp_core_out_state {
	STAILQ_HEAD(, kdp_output_stage) kcos_out_stage;
	struct kdp_output_stage *       kcos_encryption_stage;
	bool                            kcos_enforce_encryption;
	uint64_t                        kcos_totalbytes;
	uint64_t                        kcos_bytes_written;
	uint64_t                        kcos_lastpercent;
	kern_return_t                   kcos_error;
};
struct kdp_output_stage_funcs {
	void (*kosf_reset)(struct kdp_output_stage *stage);
	kern_return_t (*kosf_outproc)(struct kdp_output_stage *stage, unsigned int request,
	    char *corename, uint64_t length, void *panic_data);
	void (*kosf_free)(struct kdp_output_stage *stage);
};
struct kdp_output_stage {
	STAILQ_ENTRY(kdp_output_stage) kos_next;
	bool                           kos_initialized;
	struct kdp_core_out_state *    kos_outstate;
	struct kdp_output_stage_funcs  kos_funcs;
	uint64_t                       kos_bytes_written; 
	bool                           kos_bypass;
	void *                         kos_data;
	size_t                         kos_data_size;
};
struct {
	kdp_req_t       request:7;      
	unsigned        is_reply:1;     
	unsigned        seq:8;          
	unsigned        len:16;         
	unsigned        key;            
} KDP_PACKED kdp_hdr_t;
struct {                        
	kdp_hdr_t       hdr;
	uint16_t        req_reply_port; 
	uint16_t        exc_note_port;  
	char            greeting[0];    
} KDP_PACKED kdp_connect_req_t;
struct {                        
	kdp_hdr_t       hdr;
	kdp_error_t     error;
} KDP_PACKED kdp_connect_reply_t;
struct {                        
	kdp_hdr_t       hdr;
} KDP_PACKED kdp_disconnect_req_t;
struct {                        
	kdp_hdr_t       hdr;
} KDP_PACKED kdp_disconnect_reply_t;
struct {
	kdp_hdr_t hdr;
	uint16_t req_reply_port; 
} KDP_PACKED kdp_reattach_req_t;
struct {                        
	kdp_hdr_t       hdr;
} KDP_PACKED kdp_hostinfo_req_t;
struct {
	uint32_t                cpus_mask;      
	uint32_t                cpu_type;
	uint32_t                cpu_subtype;
} KDP_PACKED kdp_hostinfo_t;
struct {                        
	kdp_hdr_t       hdr;
	kdp_hostinfo_t  hostinfo;
} KDP_PACKED kdp_hostinfo_reply_t;
struct {                        
	kdp_hdr_t       hdr;
} KDP_PACKED kdp_version_req_t;
struct {                        
	kdp_hdr_t       hdr;
	uint32_t        version;
	uint32_t        feature;
	uint32_t        pad0;
	uint32_t        pad1;
} KDP_PACKED kdp_version_reply_t;
struct {                        
	kdp_hdr_t       hdr;
} KDP_PACKED kdp_regions_req_t;
struct {
	uint32_t        address;
	uint32_t        nbytes;
	uint32_t        protection;     
} KDP_PACKED kdp_region_t;
struct {                        
	kdp_hdr_t       hdr;
	uint32_t        nregions;
	kdp_region_t    regions[0];
} KDP_PACKED kdp_regions_reply_t;
struct {                        
	kdp_hdr_t       hdr;
} KDP_PACKED kdp_maxbytes_req_t;
struct {                        
	kdp_hdr_t       hdr;
	uint32_t        max_bytes;
} KDP_PACKED kdp_maxbytes_reply_t;
struct {                        
	kdp_hdr_t       hdr;
	uint32_t        address;
	uint32_t        nbytes;
} KDP_PACKED kdp_readmem_req_t;
struct {                        
	kdp_hdr_t       hdr;
	kdp_error_t     error;
	char            data[0];
} KDP_PACKED kdp_readmem_reply_t;
struct {                        
	kdp_hdr_t       hdr;
	uint64_t        address;
	uint32_t        nbytes;
} KDP_PACKED kdp_readmem64_req_t;
struct {                        
	kdp_hdr_t       hdr;
	kdp_error_t     error;
	char            data[0];
} KDP_PACKED kdp_readmem64_reply_t;
struct {                        
	kdp_hdr_t       hdr;
	uint64_t        address;
	uint32_t        nbytes;
	uint16_t        lcpu;
} KDP_PACKED kdp_readphysmem64_req_t;
struct {                        
	kdp_hdr_t       hdr;
	kdp_error_t     error;
	char            data[0];
} KDP_PACKED kdp_readphysmem64_reply_t;
struct {                        
	kdp_hdr_t       hdr;
	uint32_t        address;
	uint32_t        nbytes;
	char            data[0];
} KDP_PACKED kdp_writemem_req_t;
struct {                        
	kdp_hdr_t       hdr;
	kdp_error_t     error;
} KDP_PACKED kdp_writemem_reply_t;
struct {                        
	kdp_hdr_t       hdr;
	uint64_t        address;
	uint32_t        nbytes;
	char            data[0];
} KDP_PACKED kdp_writemem64_req_t;
struct {                        
	kdp_hdr_t       hdr;
	kdp_error_t     error;
} KDP_PACKED kdp_writemem64_reply_t;
struct {                        
	kdp_hdr_t       hdr;
	uint64_t        address;
	uint32_t        nbytes;
	uint16_t        lcpu;
	char            data[0];
} KDP_PACKED kdp_writephysmem64_req_t;
struct {                        
	kdp_hdr_t       hdr;
	kdp_error_t     error;
} KDP_PACKED kdp_writephysmem64_reply_t;
struct {                        
	kdp_hdr_t       hdr;
	uint16_t        lcpu;
	uint16_t        address;
	uint16_t        nbytes;
	char            data[0];
} KDP_PACKED kdp_writeioport_req_t;
struct {                        
	kdp_hdr_t       hdr;
	kdp_error_t     error;
} KDP_PACKED kdp_writeioport_reply_t;
struct {                        
	kdp_hdr_t       hdr;
	uint16_t        lcpu;
	uint16_t        address;
	uint16_t        nbytes;
} KDP_PACKED kdp_readioport_req_t;
struct {                        
	kdp_hdr_t       hdr;
	kdp_error_t     error;
	char            data[0];
} KDP_PACKED kdp_readioport_reply_t;
struct {                        
	kdp_hdr_t       hdr;
	uint32_t        address;
	uint16_t        lcpu;
	char            data[0];
} KDP_PACKED kdp_writemsr64_req_t;
struct {                        
	kdp_hdr_t       hdr;
	kdp_error_t     error;
} KDP_PACKED kdp_writemsr64_reply_t;
struct {                        
	kdp_hdr_t       hdr;
	uint32_t        address;
	uint16_t        lcpu;
} KDP_PACKED kdp_readmsr64_req_t;
struct {                        
	kdp_hdr_t       hdr;
	kdp_error_t     error;
	char            data[0];
} KDP_PACKED kdp_readmsr64_reply_t;
struct {                        
	kdp_hdr_t       hdr;
	uint32_t        cpu;
	uint32_t        flavor;
} KDP_PACKED kdp_readregs_req_t;
struct {                        
	kdp_hdr_t       hdr;
	kdp_error_t     error;          
	char            data[0];
} KDP_PACKED kdp_readregs_reply_t;
struct {                        
	kdp_hdr_t       hdr;
	uint32_t        cpu;
	uint32_t        flavor;
	char            data[0];
} KDP_PACKED kdp_writeregs_req_t;
struct {                        
	kdp_hdr_t       hdr;
	kdp_error_t     error;
} KDP_PACKED kdp_writeregs_reply_t;
struct {                        
	kdp_hdr_t       hdr;
	char            file_args[0];
} KDP_PACKED kdp_load_req_t;
struct {                        
	kdp_hdr_t       hdr;
	kdp_error_t     error;
} KDP_PACKED kdp_load_reply_t;
struct {                        
	kdp_hdr_t       hdr;
} KDP_PACKED kdp_imagepath_req_t;
struct {                        
	kdp_hdr_t       hdr;
	char            path[0];
} KDP_PACKED kdp_imagepath_reply_t;
struct {                        
	kdp_hdr_t       hdr;
} KDP_PACKED kdp_suspend_req_t;
struct {                        
	kdp_hdr_t       hdr;
} KDP_PACKED kdp_suspend_reply_t;
struct {                        
	kdp_hdr_t       hdr;
	uint32_t        cpu_mask;
} KDP_PACKED kdp_resumecpus_req_t;
struct {                        
	kdp_hdr_t       hdr;
} KDP_PACKED kdp_resumecpus_reply_t;
struct {
	kdp_hdr_t hdr;
	uint32_t      address;
} KDP_PACKED kdp_breakpoint_req_t;
struct {
	kdp_hdr_t hdr;
	kdp_error_t error;
} KDP_PACKED kdp_breakpoint_reply_t;
struct {
	kdp_hdr_t hdr;
	uint64_t        address;
} KDP_PACKED kdp_breakpoint64_req_t;
struct {
	kdp_hdr_t hdr;
	kdp_error_t error;
} KDP_PACKED kdp_breakpoint64_reply_t;
struct {                        
	uint32_t        cpu;
	uint32_t        exception;
	uint32_t        code;
	uint32_t        subcode;
} KDP_PACKED kdp_exc_info_t;
struct {                        
	kdp_hdr_t       hdr;
	uint32_t        n_exc_info;
	kdp_exc_info_t  exc_info[0];
} KDP_PACKED kdp_exception_t;
struct {                        
	kdp_hdr_t       hdr;
} KDP_PACKED kdp_exception_ack_t;
struct {                        
	kdp_hdr_t       hdr;
} KDP_PACKED kdp_kernelversion_req_t;
struct {                        
	kdp_hdr_t       hdr;
	char            version[0];
} KDP_PACKED kdp_kernelversion_reply_t;
struct {                        
	kdp_hdr_t               hdr;
	uint32_t                term_code;      
	uint32_t                exit_code;
} KDP_PACKED kdp_termination_t;
struct {
	kdp_hdr_t       hdr;
} KDP_PACKED kdp_termination_ack_t;
struct {                        
	kdp_hdr_t       hdr;
	char            name[50];
	char            destip[16];
	char            routerip[16];
	uint32_t        port;
	kdp_dumpinfo_t  type;
} KDP_PACKED kdp_dumpinfo_req_t;
struct {                        
	kdp_hdr_t       hdr;
	char            name[50];
	char            destip[16];
	char            routerip[16];
	uint32_t        port;
	kdp_dumpinfo_t  type;
} KDP_PACKED kdp_dumpinfo_reply_t;
struct kdp_manual_pkt {
	unsigned char       data[KDP_MANUAL_PACKET_SIZE];
	unsigned int        len;
	boolean_t           input;
} KDP_PACKED;
struct kdp_in_addr {
	uint32_t s_addr;
};
struct kdp_ether_addr {
	u_char ether_addr_octet[ETHER_ADDR_LEN];
};
struct  kdp_ether_header {
	u_char  ether_dhost[ETHER_ADDR_LEN];
	u_char  ether_shost[ETHER_ADDR_LEN];
	u_short ether_type;
};
struct {
	kern_return_t (*kcc_coredump_init)(void *refcon, void *context); 
	kern_return_t (*kcc_coredump_get_summary)(void *refcon, core_save_summary_cb callback, void *context);
	kern_return_t (*kcc_coredump_save_segment_descriptions)(void *refcon, core_save_segment_descriptions_cb callback, void *context);
	kern_return_t (*kcc_coredump_save_thread_state)(void *refcon, void *buf, core_save_thread_state_cb callback, void *context);
	kern_return_t (*kcc_coredump_save_sw_vers)(void *refcon, core_save_sw_vers_cb callback, void *context) __deprecated_msg("please switch to kcc_coredump_save_sw_vers_detail");
	kern_return_t (*kcc_coredump_save_segment_data)(void *refcon, core_save_segment_data_cb callback, void *context);
	kern_return_t (*kcc_coredump_save_misc_data)(void *refcon, core_save_misc_data_cb callback, void *context) __deprecated_msg("please switch to kcc_coredump_save_note_*");
	kern_return_t (*kcc_coredump_save_note_summary)(void *refcon, core_save_note_summary_cb callback, void *context);
	kern_return_t (*kcc_coredump_save_note_descriptions)(void *refcon, core_save_note_descriptions_cb callback, void *context);
	kern_return_t (*kcc_coredump_save_note_data)(void *refcon, core_save_note_data_cb callback, void *context);
	kern_return_t (*kcc_coredump_save_sw_vers_detail)(void *refcon, core_save_sw_vers_detail_cb callback, void *context);
} kern_coredump_callback_config;
struct kern_userspace_coredump_context {
	task_t task;
};
struct affinity_set {
	struct affinity_space *aset_space;      
	queue_chain_t   aset_affinities;        
	queue_head_t    aset_threads;           
	uint32_t        aset_thread_count;      
	uint32_t        aset_tag;               
	uint32_t        aset_num;               
	processor_set_t aset_pset;              
};
struct mach_assert_hdr {
	mach_assert_type_t      type;
	unsigned                lineno : 24;
	const char             *filename;
} __attribute__((packed, aligned(4)));
struct mach_assert_default {
	struct mach_assert_hdr  hdr;
	const char             *expr;
} __attribute__((packed, aligned(4)));
struct mach_assert_3x {
	struct mach_assert_hdr  hdr;
	const char             *a;
	const char             *op;
	const char             *b;
} __attribute__((packed, aligned(4)));
struct backtrace_control {
	backtrace_flags_t btc_flags;
	uintptr_t btc_frame_addr;
	void *btc_user_thread;
	backtrace_user_copy_fn btc_user_copy;
	void *btc_user_copy_context;
	int64_t btc_addr_offset;
};
struct backtrace_user_info {
	backtrace_info_t btui_info;
	errno_t btui_error;
	unsigned int btui_async_start_index;
	uintptr_t btui_async_frame_addr;
	uintptr_t btui_next_frame_addr;
};
struct circle_queue_head {
	queue_entry_t head;
} circle_queue_head_t, *circle_queue_t;
struct  clock_ops {
	int             (*c_config)(void);              

	int             (*c_init)(void);                

	kern_return_t   (*c_gettime)(   
		mach_timespec_t                 *cur_time);

	kern_return_t   (*c_getattr)(   
		clock_flavor_t                  flavor,
		clock_attr_t                    attr,
		mach_msg_type_number_t  *count);
};
struct  clock {
	clock_ops_t             cl_ops;         
	struct ipc_port         *cl_service;    
};
struct coalition_ledger_indices {
	int logical_writes;
};
struct compact_id_table {
	void                  **cidt_array[COMPACT_ID_SLAB_COUNT];
	bitmap_t               *cidt_bitmap[COMPACT_ID_SLAB_COUNT];
	lck_mtx_t               cidt_lock;
	struct thread          *cidt_allocator;
	bool                    cidt_waiters;
	uint32_t                cidt_count;
	compact_id_t            cidt_first_free;
};
struct __CodeDirectory {
	uint32_t magic;                                 
	uint32_t length;                                
	uint32_t version;                               
	uint32_t flags;                                 
	uint32_t hashOffset;                    
	uint32_t identOffset;                   
	uint32_t nSpecialSlots;                 
	uint32_t nCodeSlots;                    
	uint32_t codeLimit;                             
	uint8_t hashSize;                               
	uint8_t hashType;                               
	uint8_t platform;                               
	uint8_t pageSize;                               
	uint32_t spare2;                                

	char end_earliest[0];

	uint32_t scatterOffset;                 
	char end_withScatter[0];

	uint32_t teamOffset;                    
	char end_withTeam[0];

	uint32_t spare3;                                
	uint64_t codeLimit64;                   
	char end_withCodeLimit64[0];

	uint64_t execSegBase;                   
	uint64_t execSegLimit;                  
	uint64_t execSegFlags;                  
	char end_withExecSeg[0];

	uint32_t runtime;
	uint32_t preEncryptOffset;
	char end_withPreEncryptOffset[0];

	uint8_t linkageHashType;
	uint8_t linkageApplicationType;
	uint16_t linkageApplicationSubType;
	uint32_t linkageOffset;
	uint32_t linkageSize;
	char end_withLinkage[0];

} CS_CodeDirectory
__attribute__ ((aligned(1)));
struct __BlobIndex {
	uint32_t type;                                  
	uint32_t offset;                                
} CS_BlobIndex
__attribute__ ((aligned(1)));
struct __SC_SuperBlob {
	uint32_t magic;                                 
	uint32_t length;                                
	uint32_t count;                                 
	CS_BlobIndex index[];                   
} CS_SuperBlob
__attribute__ ((aligned(1)));
struct __SC_GenericBlob {
	uint32_t magic;                                 
	uint32_t length;                                
	char data[];
} CS_GenericBlob
__attribute__ ((aligned(1)));
struct __SC_Scatter {
	uint32_t count;                                 
	uint32_t base;                                  
	uint64_t targetOffset;                  
	uint64_t spare;                                 
} SC_Scatter
__attribute__ ((aligned(1)));
struct launch_constraint_data {
	cs_launch_type_t launch_type;
};
struct additional_panic_data_buffer {
	const char *producer_name;
	void *buf;
	int len;
};
struct kernel_panic_reason {
	char            buf[1024];
} *kernel_panic_reason_t;
struct kdp_core_encryption_key_descriptor {
	uint64_t kcekd_format;
	uint16_t kcekd_size;
	void *   kcekd_key;
};
struct ecc_event {
	uint8_t         id;     
	uint8_t         count;  
	uint64_t        data[ECC_EVENT_INFO_DATA_ENTRIES] __attribute__((aligned(8))); 
};
struct {
	ecc_version_t version;
	ecc_flags_t flags;
	uint64_t physaddr;
	uint32_t ce_count;
	uint32_t vendor;
	uint32_t reserved[4];
} ecc_event_t;
struct {
	mcc_ecc_version_t version;
	mcc_flags_t flags;
	uint32_t status;
	uint32_t amcc;
	uint32_t plane;
	uint32_t bank;
	uint32_t way;
	uint32_t index;
	uint32_t bit_off_cl;
	uint32_t bit_off_within_hcl;
} mcc_ecc_event_t;
struct {
	uint32_t gpu_id;
	uint32_t gpu_max_domains;
} gpu_descriptor;
struct exception_action {
	struct ipc_port         * XNU_PTRAUTH_SIGNED_PTR("exception_action.port") port; 
	thread_state_flavor_t   flavor;         
	exception_behavior_t    behavior;       
	boolean_t               privileged;     
	boolean_t               hardened;       
	struct label            *label;         
};
struct hardened_exception_action {
	struct exception_action ea;
	uint32_t                signed_pc_key;
	exception_mask_t        exception;
};
struct ext_paniclog_handle {
	LIST_ENTRY(ext_paniclog_handle) handles;
	uuid_t uuid;
	char data_id[MAX_DATA_ID_SIZE];
	void * XNU_PTRAUTH_SIGNED_PTR("ext_paniclog_handle.buf_addr") buf_addr;
	uint32_t max_len;
	uint32_t used_len;
	ext_paniclog_create_options_t options;
	ext_paniclog_flags_t flags;
	uint8_t active;
} ext_paniclog_handle_t;
struct ext_paniclog_header {
	uint32_t len;
	uuid_t uuid;
	ext_paniclog_flags_t flags;
} ext_paniclog_header_t;
struct  host {
	decl_lck_mtx_data(, lock);               
	ipc_port_t XNU_PTRAUTH_SIGNED_PTR("host.special") special[HOST_MAX_SPECIAL_PORT + 1];
	struct exception_action exc_actions[EXC_TYPES_COUNT];
};
struct {
	uint64_t total_user_time;
	uint64_t total_system_time;
	uint64_t task_interrupt_wakeups;
	uint64_t task_platform_idle_wakeups;
	uint64_t task_timer_wakeups_bin_1;
	uint64_t task_timer_wakeups_bin_2;
	uint64_t total_ptime;
	uint64_t total_pset_switches;
	uint64_t task_gpu_ns;
	uint64_t task_energy;
} expired_task_statistics_t;
struct hvg_hcall_args {
	uint64_t args[6];
} hvg_hcall_args_t;
struct hvg_hcall_output {
	uint64_t regs[7];
} hvg_hcall_output_t;
struct hvg_hcall_vmcore_file {
	char tag[57];   
} hvg_hcall_vmcore_file_t;
struct {
	mach_msg_header_t header;
	uint64_t addr;
	uint64_t size;
	uint64_t value;
} hv_ion_message_t;
struct {
	uint64_t addr;
	uint64_t size;
	uint64_t value;
	uint32_t port_name;
	uint32_t flags;
} hv_ion_t;
struct  {
	const hv_trap_t *traps;
	unsigned trap_count;
} hv_trap_table_t;
struct {
	void (*dispatch)(void *vcpu);
	void (*preempt)(void *vcpu);
	void (*suspend)(void);
	void (*thread_destroy)(void *vcpu);
	void (*task_destroy)(void *vm);
	void (*volatile_state)(void *vcpu, int state);
	void (*resume)(void);
	void (*memory_pressure)(void);
} hv_callbacks_t;
struct ipc_kobject_ops {
	ipc_kobject_type_t iko_op_type;
	unsigned long
	    iko_op_stable        : 1,
	    iko_op_permanent     : 1;
	const char        *iko_op_name;
	void (*iko_op_no_senders)(ipc_port_t port, mach_port_mscount_t mscount);
	void (*iko_op_destroy)(ipc_port_t port);
} *ipc_kobject_ops_t;
struct ipc_kobject_label {
	ipc_label_t   ikol_label;       
	ipc_port_t XNU_PTRAUTH_SIGNED_PTR("ipc_kobject_label.ikol_alt_port") ikol_alt_port;
};
struct kalloc_heap {
	zone_stats_t        kh_stats;
	const char         *__unsafe_indexable kh_name;
	zone_kheap_id_t     kh_heap_id;
	vm_tag_t            kh_tag;
	uint16_t            kh_type_hash;
	zone_id_t           kh_zstart;
	struct kalloc_heap *kh_views;
} *kalloc_heap_t;
struct kalloc_type_view {
	struct zone_view        kt_zv;
	const char             *kt_signature __unsafe_indexable;
	kalloc_type_flags_t     kt_flags;
	uint32_t                kt_size;
	zone_t                  kt_zearly;
	zone_t                  kt_zsig;
};
struct kalloc_type_var_view {
	kalloc_type_version_t   kt_version;
	uint16_t                kt_size_hdr;
	uint32_t                kt_size_type;
	zone_stats_t            kt_stats;
	const char             *__unsafe_indexable kt_name;
	zone_view_t             kt_next;
	zone_id_t               kt_heap_start;
	uint8_t                 kt_zones[KHEAP_NUM_ZONES];
	const char             * __unsafe_indexable kt_sig_hdr;
	const char             * __unsafe_indexable kt_sig_type;
	kalloc_type_flags_t     kt_flags;
};
struct kcdata_item {
	uint32_t type;
	uint32_t size; 
	               
	uint64_t flags;
	char data[]; 
};
struct kcdata_subtype_descriptor {
	uint8_t kcs_flags;

	uint8_t kcs_elem_type;                              
	uint16_t kcs_elem_offset;                           
	uint32_t kcs_elem_size;                             
	char                 kcs_name[KCDATA_DESC_MAXLEN];  
};
struct kcdata_type_definition {
	uint32_t kct_type_identifier;
	uint32_t kct_num_elements;
	char kct_name[KCDATA_DESC_MAXLEN];
	struct kcdata_subtype_descriptor kct_elements[];
};
struct stack_snapshot_frame32 {
	uint32_t lr;
	uint32_t sp;
};
struct stack_snapshot_frame64 {
	uint64_t lr;
	uint64_t sp;
};
struct dyld_uuid_info_32 {
	uint32_t imageLoadAddress; 
	uuid_t   imageUUID;
};
struct dyld_uuid_info_64 {
	uint64_t imageLoadAddress; 
	uuid_t   imageUUID;
};
struct dyld_uuid_info_64_v2 {
	uint64_t imageLoadAddress; 
	uuid_t   imageUUID;
	uint64_t imageSlidBaseAddress; 
};
struct dyld_shared_cache_loadinfo_v2 {
	uint64_t sharedCacheSlide;      
	uuid_t   sharedCacheUUID;
	uint64_t sharedCacheUnreliableSlidBaseAddress;  
	uint64_t sharedCacheSlidFirstMapping; 
	uint32_t sharedCacheID; 
	uint32_t sharedCacheFlags;
};
struct dyld_shared_cache_loadinfo {
	uint64_t sharedCacheSlide;      
	uuid_t   sharedCacheUUID;
	uint64_t sharedCacheUnreliableSlidBaseAddress;  
	uint64_t sharedCacheSlidFirstMapping; 
};
struct dyld_aot_cache_uuid_info {
	uint64_t x86SlidBaseAddress; 
	uuid_t x86UUID; 
	uint64_t aotSlidBaseAddress; 
	uuid_t aotUUID; 
};
struct user32_dyld_uuid_info {
	uint32_t        imageLoadAddress;       
	uuid_t                  imageUUID;                      
};
struct user64_dyld_uuid_info {
	uint64_t        imageLoadAddress;       
	uuid_t                  imageUUID;                      
};
struct user64_dyld_aot_info {
	uint64_t x86LoadAddress;
	uint64_t aotLoadAddress;
	uint64_t aotImageSize;
	uint8_t  aotImageKey[DYLD_AOT_IMAGE_KEY_SIZE];
};
struct mem_and_io_snapshot {
	uint32_t        snapshot_magic;
	uint32_t        free_pages;
	uint32_t        active_pages;
	uint32_t        inactive_pages;
	uint32_t        purgeable_pages;
	uint32_t        wired_pages;
	uint32_t        speculative_pages;
	uint32_t        throttled_pages;
	uint32_t        filebacked_pages;
	uint32_t        compressions;
	uint32_t        decompressions;
	uint32_t        compressor_size;
	int32_t         busy_buffer_count;
	uint32_t        pages_wanted;
	uint32_t        pages_reclaimed;
	uint8_t         pages_wanted_reclaimed_valid; 
} __attribute__((packed));
struct thread_snapshot_v2 {
	uint64_t  ths_thread_id;
	uint64_t  ths_wait_event;
	uint64_t  ths_continuation;
	uint64_t  ths_total_syscalls;
	uint64_t  ths_voucher_identifier;
	uint64_t  ths_dqserialnum;
	uint64_t  ths_user_time;
	uint64_t  ths_sys_time;
	uint64_t  ths_ss_flags;
	uint64_t  ths_last_run_time;
	uint64_t  ths_last_made_runnable_time;
	uint32_t  ths_state;
	uint32_t  ths_sched_flags;
	int16_t   ths_base_priority;
	int16_t   ths_sched_priority;
	uint8_t   ths_eqos;
	uint8_t ths_rqos;
	uint8_t ths_rqos_override;
	uint8_t ths_io_tier;
} __attribute__((packed));
struct thread_snapshot_v3 {
	uint64_t ths_thread_id;
	uint64_t ths_wait_event;
	uint64_t ths_continuation;
	uint64_t ths_total_syscalls;
	uint64_t ths_voucher_identifier;
	uint64_t ths_dqserialnum;
	uint64_t ths_user_time;
	uint64_t ths_sys_time;
	uint64_t ths_ss_flags;
	uint64_t ths_last_run_time;
	uint64_t ths_last_made_runnable_time;
	uint32_t ths_state;
	uint32_t ths_sched_flags;
	int16_t ths_base_priority;
	int16_t ths_sched_priority;
	uint8_t ths_eqos;
	uint8_t ths_rqos;
	uint8_t ths_rqos_override;
	uint8_t ths_io_tier;
	uint64_t ths_thread_t;
} __attribute__((packed));
struct thread_snapshot_v4 {
	uint64_t ths_thread_id;
	uint64_t ths_wait_event;
	uint64_t ths_continuation;
	uint64_t ths_total_syscalls;
	uint64_t ths_voucher_identifier;
	uint64_t ths_dqserialnum;
	uint64_t ths_user_time;
	uint64_t ths_sys_time;
	uint64_t ths_ss_flags;
	uint64_t ths_last_run_time;
	uint64_t ths_last_made_runnable_time;
	uint32_t ths_state;
	uint32_t ths_sched_flags;
	int16_t ths_base_priority;
	int16_t ths_sched_priority;
	uint8_t ths_eqos;
	uint8_t ths_rqos;
	uint8_t ths_rqos_override;
	uint8_t ths_io_tier;
	uint64_t ths_thread_t;
	uint64_t ths_requested_policy;
	uint64_t ths_effective_policy;
} __attribute__((packed));
struct thread_group_snapshot {
	uint64_t tgs_id;
	char tgs_name[16];
} __attribute__((packed));
struct thread_group_snapshot_v2 {
	uint64_t tgs_id;
	char tgs_name[16];
	uint64_t tgs_flags;
} __attribute__((packed));
struct thread_group_snapshot_v3 {
	uint64_t tgs_id;
	char tgs_name[16];
	uint64_t tgs_flags;
	char tgs_name_cont[16];
} __attribute__((packed));
struct jetsam_coalition_snapshot {
	uint64_t jcs_id;
	uint64_t jcs_flags;
	uint64_t jcs_thread_group;
	uint64_t jcs_leader_task_uniqueid;
} __attribute__((packed));
struct instrs_cycles_snapshot {
	uint64_t ics_instructions;
	uint64_t ics_cycles;
} __attribute__((packed));
struct instrs_cycles_snapshot_v2 {
	uint64_t ics_instructions;
	uint64_t ics_cycles;
	uint64_t ics_p_instructions;
	uint64_t ics_p_cycles;
} __attribute__((packed));
struct thread_delta_snapshot_v2 {
	uint64_t  tds_thread_id;
	uint64_t  tds_voucher_identifier;
	uint64_t  tds_ss_flags;
	uint64_t  tds_last_made_runnable_time;
	uint32_t  tds_state;
	uint32_t  tds_sched_flags;
	int16_t   tds_base_priority;
	int16_t   tds_sched_priority;
	uint8_t   tds_eqos;
	uint8_t   tds_rqos;
	uint8_t   tds_rqos_override;
	uint8_t   tds_io_tier;
} __attribute__ ((packed));
struct thread_delta_snapshot_v3 {
	uint64_t  tds_thread_id;
	uint64_t  tds_voucher_identifier;
	uint64_t  tds_ss_flags;
	uint64_t  tds_last_made_runnable_time;
	uint32_t  tds_state;
	uint32_t  tds_sched_flags;
	int16_t   tds_base_priority;
	int16_t   tds_sched_priority;
	uint8_t   tds_eqos;
	uint8_t   tds_rqos;
	uint8_t   tds_rqos_override;
	uint8_t   tds_io_tier;
	uint64_t  tds_requested_policy;
	uint64_t  tds_effective_policy;
} __attribute__ ((packed));
struct io_stats_snapshot {
	uint64_t         ss_disk_reads_count;
	uint64_t         ss_disk_reads_size;
	uint64_t         ss_disk_writes_count;
	uint64_t         ss_disk_writes_size;
	uint64_t         ss_io_priority_count[STACKSHOT_IO_NUM_PRIORITIES];
	uint64_t         ss_io_priority_size[STACKSHOT_IO_NUM_PRIORITIES];
	uint64_t         ss_paging_count;
	uint64_t         ss_paging_size;
	uint64_t         ss_non_paging_count;
	uint64_t         ss_non_paging_size;
	uint64_t         ss_data_count;
	uint64_t         ss_data_size;
	uint64_t         ss_metadata_count;
	uint64_t         ss_metadata_size;
} __attribute__ ((packed));
struct task_snapshot_v2 {
	uint64_t  ts_unique_pid;
	uint64_t  ts_ss_flags;
	uint64_t  ts_user_time_in_terminated_threads;
	uint64_t  ts_system_time_in_terminated_threads;
	uint64_t  ts_p_start_sec;
	uint64_t  ts_task_size;
	uint64_t  ts_max_resident_size;
	uint32_t  ts_suspend_count;
	uint32_t  ts_faults;
	uint32_t  ts_pageins;
	uint32_t  ts_cow_faults;
	uint32_t  ts_was_throttled;
	uint32_t  ts_did_throttle;
	uint32_t  ts_latency_qos;
	int32_t   ts_pid;
	char      ts_p_comm[32];
} __attribute__ ((packed));
struct transitioning_task_snapshot {
	uint64_t  tts_unique_pid;
	uint64_t  tts_ss_flags;
	uint64_t  tts_transition_type;
	int32_t   tts_pid;
	char      tts_p_comm[32];
} __attribute__ ((packed));
struct task_delta_snapshot_v2 {
	uint64_t  tds_unique_pid;
	uint64_t  tds_ss_flags;
	uint64_t  tds_user_time_in_terminated_threads;
	uint64_t  tds_system_time_in_terminated_threads;
	uint64_t  tds_task_size;
	uint64_t  tds_max_resident_size;
	uint32_t  tds_suspend_count;
	uint32_t  tds_faults;
	uint32_t  tds_pageins;
	uint32_t  tds_cow_faults;
	uint32_t  tds_was_throttled;
	uint32_t  tds_did_throttle;
	uint32_t  tds_latency_qos;
} __attribute__ ((packed));
struct stackshot_task_codesigning_info {
	uint64_t csflags;
	uint32_t cs_trust_level;
} __attribute__ ((packed));
struct stackshot_cpu_times {
	uint64_t user_usec;
	uint64_t system_usec;
} __attribute__((packed));
struct stackshot_cpu_times_v2 {
	uint64_t user_usec;
	uint64_t system_usec;
	uint64_t runnable_usec;
} __attribute__((packed));
struct stackshot_duration {
	uint64_t stackshot_duration;
	uint64_t stackshot_duration_outer;
} __attribute__((packed));
struct stackshot_duration_v2 {
	uint64_t stackshot_duration;
	uint64_t stackshot_duration_outer;
	uint64_t stackshot_duration_prior;
} __attribute__((packed));
struct stackshot_fault_stats {
	uint32_t sfs_pages_faulted_in;      
	uint64_t sfs_time_spent_faulting;   
	uint64_t sfs_system_max_fault_time; 
	uint8_t  sfs_stopped_faulting;      
} __attribute__((packed));
struct stackshot_thread_waitinfo {
	uint64_t owner;         
	uint64_t waiter;        
	uint64_t context;       
	uint8_t wait_type;      
} __attribute__((packed)) thread_waitinfo_t;
struct stackshot_thread_waitinfo_v2 {
	uint64_t owner;         
	uint64_t waiter;        
	uint64_t context;       
	uint8_t wait_type;      
	int16_t portlabel_id;   
	uint32_t wait_flags;    
} __attribute__((packed)) thread_waitinfo_v2_t;
struct stackshot_thread_turnstileinfo {
	uint64_t waiter;        
	uint64_t turnstile_context; 
	uint8_t turnstile_priority;
	uint8_t number_of_hops;
	uint64_t turnstile_flags;               
} __attribute__((packed)) thread_turnstileinfo_t;
struct stackshot_thread_turnstileinfo_v2 {
	uint64_t waiter;        
	uint64_t turnstile_context; 
	uint8_t turnstile_priority;
	uint8_t number_of_hops;
	uint64_t turnstile_flags; 
	int16_t portlabel_id;   
} __attribute__((packed)) thread_turnstileinfo_v2_t;
struct portlabel_info {
	int16_t portlabel_id;         
	uint16_t portlabel_flags;           
	uint8_t portlabel_domain;           
} __attribute__((packed));
struct stackshot_cpu_architecture {
	int32_t cputype;
	int32_t cpusubtype;
} __attribute__((packed));
struct stack_snapshot_stacktop {
	uint64_t sp;
	uint8_t stack_contents[8];
};
struct stackshot_latency_collection {
	uint64_t latency_version;
	uint64_t setup_latency;
	uint64_t total_task_iteration_latency;
	uint64_t total_terminated_task_iteration_latency;
} __attribute__((packed));
struct stackshot_latency_collection_v2 {
	uint64_t latency_version;
	uint64_t setup_latency_mt;
	uint64_t total_task_iteration_latency_mt;
	uint64_t total_terminated_task_iteration_latency_mt;
	uint64_t task_queue_building_latency_mt;
	uint64_t terminated_task_queue_building_latency_mt;
	uint64_t cpu_wait_latency_mt;
	int32_t  main_cpu_number;
	int32_t  calling_cpu_number;
	uint64_t buffer_size;
	uint64_t buffer_used;
	uint64_t buffer_overhead;
	uint64_t buffer_count;
} __attribute__((packed));
struct stackshot_latency_cpu {
	int32_t  cpu_number;
	int32_t  cluster_type;
	uint64_t init_latency_mt;
	uint64_t workqueue_latency_mt;
	uint64_t total_latency_mt;
	uint64_t total_cycles;
	uint64_t total_instrs;
	uint64_t tasks_processed;
	uint64_t threads_processed;
	uint64_t faulting_time_mt;
	uint64_t total_buf;
	uint64_t intercluster_buf_used;
} __attribute__((packed));
struct stackshot_latency_task {
	uint64_t task_uniqueid;
	uint64_t setup_latency;
	uint64_t task_thread_count_loop_latency;
	uint64_t task_thread_data_loop_latency;
	uint64_t cur_tsnap_latency;
	uint64_t pmap_latency;
	uint64_t bsd_proc_ids_latency;
	uint64_t misc_latency;
	uint64_t misc2_latency;
	uint64_t end_latency;
} __attribute__((packed));
struct stackshot_latency_thread {
	uint64_t thread_id;
	uint64_t cur_thsnap1_latency;
	uint64_t dispatch_serial_latency;
	uint64_t dispatch_label_latency;
	uint64_t cur_thsnap2_latency;
	uint64_t thread_name_latency;
	uint64_t sur_times_latency;
	uint64_t user_stack_latency;
	uint64_t kernel_stack_latency;
	uint64_t misc_latency;
} __attribute__((packed));
struct stackshot_suspension_info {
	uint64_t tss_last_start; 
	uint64_t tss_last_end;   
	uint64_t tss_count;      
	uint64_t tss_duration;   
} __attribute__((packed));
struct stackshot_suspension_source {
	uint64_t tss_time;     
	uint64_t tss_tid;      
	int tss_pid;           
	char tss_procname[65]; 
} __attribute__((packed));
struct thread_exclaves_info {
	uint64_t tei_scid;              
	uint32_t tei_thread_offset;     
	uint32_t tei_flags;             
} __attribute__((packed));
struct thread_crash_exclaves_info {
	uint64_t tcei_scid;              
	uint64_t tcei_thread_id;         
	uint32_t tcei_flags;             
} __attribute__((packed));
struct exclave_scresult_info {
	uint64_t esc_id;
	uint64_t esc_flags;             
} __attribute__((packed));
struct exclave_ipcstackentry_info {
	uint64_t eise_asid;                     
	uint64_t eise_tnid;                     
	uint64_t eise_invocationid;             
	uint64_t eise_flags;                    
} __attribute__((packed));
struct exclave_addressspace_info {
	uint64_t eas_id;                        
	uint64_t eas_flags;                     
	uint64_t eas_layoutid;                  
	uint64_t eas_slide;                     
	uint64_t eas_asroot;                    
} __attribute__((packed));
struct exclave_textlayout_info_v1 {
	uint64_t layout_id;
	uint64_t etl_flags;                     
} __attribute__((packed));
struct exclave_textlayout_info {
	uint64_t layout_id;
	uint64_t etl_flags;                     
	uint32_t sharedcache_index;             
} __attribute__((packed));
struct exclave_textlayout_segment {
	uuid_t layoutSegment_uuid;
	uint64_t layoutSegment_loadAddress;     
} __attribute__((packed));
struct exclave_textlayout_segment_v2 {
	uuid_t layoutSegment_uuid;
	uint64_t layoutSegment_loadAddress;     
	uint64_t layoutSegment_rawLoadAddress;  
} __attribute__((packed));
struct crashinfo_proc_uniqidentifierinfo {
	uint8_t                 p_uuid[16];             
	uint64_t                p_uniqueid;             
	uint64_t                p_puniqueid;            
	uint64_t                p_reserve2;             
	uint64_t                p_reserve3;             
	uint64_t                p_reserve4;             
} __attribute__((packed));
struct kernel_triage_info_v1 {
	char triage_string1[MAX_TRIAGE_STRING_LEN];
	char triage_string2[MAX_TRIAGE_STRING_LEN];
	char triage_string3[MAX_TRIAGE_STRING_LEN];
	char triage_string4[MAX_TRIAGE_STRING_LEN];
	char triage_string5[MAX_TRIAGE_STRING_LEN];
} __attribute__((packed));
struct crashinfo_jit_address_range {
	uint64_t start_address;
	uint64_t end_address;
} __attribute__((packed));
struct crashinfo_mb {
	uint64_t start_address;
	uint64_t data[64];
} __attribute__((packed));
struct btinfo_thread_state_data_t {
	uint32_t flavor;
	uint32_t count;
	int tstate[];
};
struct btinfo_sc_load_info64 {
	uint64_t sharedCacheSlide;
	uuid_t   sharedCacheUUID;
	uint64_t sharedCacheBaseAddress;
};
struct btinfo_sc_load_info {
	uint32_t sharedCacheSlide;
	uuid_t   sharedCacheUUID;
	uint32_t sharedCacheBaseAddress;
};
struct exit_reason_snapshot {
	uint32_t ers_namespace;
	uint64_t ers_code;
	uint64_t ers_flags;
} __attribute__((packed));
struct codesigning_exit_reason_info {
	uint64_t  ceri_virt_addr;
	uint64_t  ceri_file_offset;
	char      ceri_pathname[EXIT_REASON_CODESIG_PATH_MAX];
	char      ceri_filename[EXIT_REASON_CODESIG_PATH_MAX];
	uint64_t  ceri_codesig_modtime_secs;
	uint64_t  ceri_codesig_modtime_nsecs;
	uint64_t  ceri_page_modtime_secs;
	uint64_t  ceri_page_modtime_nsecs;
	uint8_t   ceri_path_truncated;
	uint8_t   ceri_object_codesigned;
	uint8_t   ceri_page_codesig_validated;
	uint8_t   ceri_page_codesig_tainted;
	uint8_t   ceri_page_codesig_nx;
	uint8_t   ceri_page_wpmapped;
	uint8_t   ceri_page_slid;
	uint8_t   ceri_page_dirty;
	uint32_t  ceri_page_shadow_depth;
} __attribute__((packed));
struct kern_apfs_reflock {
	union {
		cond_swi_var64_s kern_apfs_rl_data;
		struct {
			uint64_t kern_apfs_rl_owner: SWI_COND_OWNER_BITS,
			    kern_apfs_rl_waiters: KERN_APFS_REFLOCK_WAITERS_BIT,
			    kern_apfs_rl_delayed_free: 1,
			    kern_apfs_rl_wake: 1,
			    kern_apfs_rl_allocated: 1,
			    kern_apfs_rl_allow_force: 1,
			    kern_apfs_rl_count: KERN_APFS_REFLOCK_REFCOUNT_BIT;
		};
	};
} *kern_apfs_reflock_t;
struct kcdata_compress_descriptor {
	z_stream kcd_cd_zs;
	void *kcd_cd_base;
	uint64_t kcd_cd_offset;
	size_t kcd_cd_maxoffset;
	uint64_t kcd_cd_mark_begin;
	kcd_cd_flag_t kcd_cd_flags;
	kcd_compression_type_t kcd_cd_compression_type;
	void (*kcd_cd_memcpy_f)(void *, const void *, size_t);
	mach_vm_address_t kcd_cd_totalout_addr;
	mach_vm_address_t kcd_cd_totalin_addr;
};
struct kcdata_descriptor {
	uint32_t            kcd_length;
	uint16_t kcd_flags;
	uint16_t kcd_user_flags; 
	mach_vm_address_t kcd_addr_begin;
	mach_vm_address_t kcd_addr_end;
	struct kcdata_compress_descriptor kcd_comp_d;
	uint32_t            kcd_endalloced;
	struct kcdata_descriptor * (*kcd_alloc_callback) (struct kcdata_descriptor*, size_t);
};
struct kcdata_object {
	kcdata_descriptor_t ko_data;
	kcdata_obj_flags_t  ko_flags;
	ipc_port_t          ko_port;
	uint32_t            ko_alloc_size;
	os_refcnt_t         ko_refs;
};
struct kpc_config_remote {
	uint32_t classes;
	kpc_config_t *configv;
	uint64_t pmc_mask;
	bool secure;
};
struct kpc_running_remote {
	uint32_t        classes;                
	uint64_t        cfg_target_mask;        
	uint64_t        cfg_state_mask;         
};
struct kpc_get_counters_remote {
	uint32_t classes;
	uint32_t nb_counters;
	uint32_t buf_stride;
	uint64_t *buf;
};
struct ledger_info {
	char    li_name[LEDGER_NAME_MAX];
	int64_t li_id;
	int64_t li_entries;
};
struct ledger_template_info {
	char            lti_name[LEDGER_NAME_MAX];
	char            lti_group[LEDGER_NAME_MAX];
	char            lti_units[LEDGER_NAME_MAX];
};
struct ledger_entry {
	volatile uint32_t le_flags;

	uint16_t                 le_warn_percent;
	int16_t                  le_diag_threshold_scaled;  
	ledger_amount_t          le_limit;
	volatile ledger_amount_t le_credit __attribute__((aligned(8)));
	volatile ledger_amount_t le_debit  __attribute__((aligned(8)));
	union {
		struct {
			
			uint64_t le_refill_period;
			uint64_t le_last_refill;
		} le_refill;
		struct {
			ledger_amount_t le_lifetime_max; 
		} _le_max;
	} _le;
} __attribute__((aligned(8)));
struct ledger_entry_small {
	volatile uint32_t les_flags;
	volatile ledger_amount_t les_credit __attribute__((aligned(8)));
} __attribute__((aligned(8)));
struct ledger {
	uint64_t                  l_id;
	os_refcnt_t               l_refs;
	int32_t                   l_size;
	struct ledger_template *  l_template;
	struct ledger_entry_small l_entries[] __attribute__((aligned(8)));
};
struct ledger_entry_info {
	int64_t         lei_balance;
	int64_t         lei_credit;
	int64_t         lei_debit;
	uint64_t        lei_limit;
	uint64_t        lei_refill_period;      
	uint64_t        lei_last_refill;        
};
struct ledger_limit_args {
	char            lla_name[LEDGER_NAME_MAX];
	uint64_t        lla_limit;
	uint64_t        lla_refill_period;
};
struct cond_swi_var32 {
	union {
		uint32_t cond32_data;
		struct {
			uint32_t cond32_owner: SWI_COND_OWNER_BITS,
			    cond32_caller_bits: SWI_COND_CALLER_BITS;
		};
	};
} cond_swi_var32_s;
struct cond_swi_var64 {
	union {
		uint64_t cond64_data;
		struct {
			uint32_t cond64_owner: SWI_COND_OWNER_BITS,
			    cond64_caller_bits: SWI_COND_CALLER_BITS;
			uint32_t cond64_caller_extra;
		};
	};
} cond_swi_var64_s;
struct gate {
	uintptr_t         gt_data;                
	struct turnstile *gt_turnstile;           
	union {
		struct {
			uint32_t  gt_refs:16,             
			    gt_alloc:1,                   
			    gt_type:2,                    
			    gt_flags_pad:13;              
		};
		uint32_t  gt_flags;
	};
} gate_t;
struct lck_spinlock_to_info {
	void                   *lock;
	uintptr_t               owner_thread_cur;
	int                     owner_cpu;
	uint32_t                extra;
} *lck_spinlock_to_info_t;
struct lck_tktlock_pv_info {
	void                   *ltpi_lck;
	uint8_t                 ltpi_wt;
} *lck_tktlock_pv_info_t;
struct lck_attr_startup_spec {
	lck_attr_t              *lck_attr;
	uint32_t                lck_attr_set_flags;
	uint32_t                lck_attr_clear_flags;
};
struct lck_spin_startup_spec {
	lck_spin_t              *lck;
	lck_grp_t               *lck_grp;
	lck_attr_t              *lck_attr;
};
struct lck_ticket_startup_spec {
	lck_ticket_t            *lck;
	lck_grp_t               *lck_grp;
};
struct lck_mtx_mcs {
	struct lck_mtx_s       *lmm_ilk_current;

	struct lck_mtx_mcs     *lmm_ilk_next;
	unsigned long           lmm_ilk_ready;

	struct lck_mtx_mcs     *lmm_as_next;
	unsigned long long      lmm_as_prev;
} __attribute__((aligned(64))) * lck_mtx_mcs_t;
struct lck_spin_mcs {
	struct lck_spin_mcs    *lsm_next;
	const void             *lsm_lock;
	unsigned long           lsm_ready;
} *lck_spin_mcs_t;
struct lck_mcs {
	struct lck_mtx_mcs      mcs_mtx;
	volatile unsigned long  mcs_spin_rsv;
	struct lck_spin_mcs     mcs_spin[2];
} __attribute__((aligned(128))) * lck_mcs_t;
struct {
	lck_mcs_t               txn_mcs;
	lck_spin_mcs_t          txn_slot;
	lck_mcs_id_t            txn_mcs_id;
} lck_spin_txn_t;
struct _lck_attr_ {
	unsigned int    lck_attr_val;
} lck_attr_t;
struct lck_debug_state {
	uint32_t                lds_value;
	long                    lds_counts[LCK_DEBUG_MAX];
} lck_debug_state;
struct _lck_grp_stat_ {
	uint64_t lgs_count;
	uint32_t lgs_enablings;
	uint32_t lgs_probeid;
	uint64_t lgs_limit;
} lck_grp_stat_t;
struct _lck_grp_stats_ {
	lck_grp_stat_t          lgss_spin_held;
	lck_grp_stat_t          lgss_spin_miss;
	lck_grp_stat_t          lgss_spin_spin;

	lck_grp_stat_t          lgss_ticket_held;
	lck_grp_stat_t          lgss_ticket_miss;
	lck_grp_stat_t          lgss_ticket_spin;

	lck_grp_stat_t          lgss_mtx_held;
	lck_grp_stat_t          lgss_mtx_direct_wait;
	lck_grp_stat_t          lgss_mtx_miss;
	lck_grp_stat_t          lgss_mtx_wait;
} lck_grp_stats_t;
struct _lck_grp_ {
	os_ref_atomic_t         lck_grp_refcnt;
	uint32_t                lck_grp_attr_id;
	uint32_t                lck_grp_spincnt;
	uint32_t                lck_grp_ticketcnt;
	uint32_t                lck_grp_mtxcnt;
	uint32_t                lck_grp_rwcnt;
	char                    lck_grp_name[LCK_GRP_MAX_NAME];
	lck_grp_stats_t         lck_grp_stats;
};
struct _lck_grp_attr_ {
	lck_grp_options_t       grp_attr_val;
};
struct lck_grp_spec {
	lck_grp_t              *grp;
	char                    grp_name[LCK_GRP_MAX_NAME];
	lck_grp_options_t       grp_flags;
};
struct lck_mtx_startup_spec {
	lck_mtx_t               *lck;
	lck_grp_t               *lck_grp;
	lck_attr_t              *lck_attr;
};
struct lck_rw_s {
	uint32_t        lck_rw_unused : 24; 
	uint32_t        lck_rw_type   :  8; 
	uint32_t        lck_rw_padding;
	lck_rw_word_t   lck_rw;
	uint32_t        lck_rw_owner;       
} lck_rw_t;
struct lck_rw_startup_spec {
	lck_rw_t                *lck;
	lck_grp_t               *lck_grp;
	lck_attr_t              *lck_attr;
};
struct hslock {
	uintptr_t       lock_data __kernel_data_semantics;
};
struct {
	uint64_t                hwst_timeout;
} hw_spin_timeout_t;
struct {
	uint64_t                hwss_start;
	uint64_t                hwss_now;
	uint64_t                hwss_deadline;
} hw_spin_state_t;
struct hw_spin_policy {
	const char             *hwsp_name;
	union {
		const uint64_t *hwsp_timeout;
		const _Atomic uint64_t *hwsp_timeout_atomic;
	};
	uint16_t                hwsp_timeout_shift;
	uint16_t                hwsp_lock_offset;

	hw_spin_timeout_fn_t   *hwsp_op_timeout;
};
struct mach_msg_filter_callbacks {
	unsigned int version;
	const mach_msg_fetch_filter_policy_cbfunc_t fetch_filter_policy;

	const mach_msg_filter_alloc_service_port_sblabel_cbfunc_t alloc_service_port_sblabel;
	const mach_msg_filter_dealloc_service_port_sblabel_cbfunc_t dealloc_service_port_sblabel;
	const mach_msg_filter_derive_sblabel_from_service_port_cbfunc_t derive_sblabel_from_service_port;
	const mach_msg_filter_get_connection_port_filter_policy_cbfunc_t get_connection_port_filter_policy;
	const mach_msg_filter_retain_sblabel_cbfunc_t retain_sblabel;
};
struct mach_node_server_msg {
	mach_msg_header_t   header;
	uint32_t    identifier; 
	uint32_t    options;    
	uint32_t    node_id;    
} *mach_node_server_msg_t;
struct mach_node_server_register_msg {
	struct mach_node_server_msg node_header;
	uint8_t     datamodel;  
	uint8_t     byteorder;  
} *mach_node_server_register_msg_t;
struct mnl_node_info {
	mach_node_id_t  node_id;    
	uint8_t         datamodel;  
	uint8_t         byteorder;  
	uint32_t        proto_vers_min;
	uint32_t        proto_vers_max;
} __attribute__ ((aligned(8))) * mnl_node_info_t;
struct mnl_msg {
	uint8_t     sub;    
	uint8_t     cmd;    
	uint8_t     qos;    
	uint8_t     flags;  
	uint32_t    node_id;
	mnl_name_t  object; 
	uint32_t    options;
	uint32_t    size;   
}  __attribute__((__packed__)) * mnl_msg_t;
struct mpqueue_head {
	struct queue_entry      head;           
	struct priority_queue_deadline_min mpq_pqhead;
	uint64_t                earliest_soft_deadline;
	uint64_t                count;
	lck_ticket_t            lock_data;
};
struct mpsc_queue_chain {
} *mpsc_queue_chain_t;
struct mpsc_queue_head {
	struct mpsc_queue_chain mpqh_head;
} *mpsc_queue_head_t;
struct mpsc_daemon_queue {
	mpsc_daemon_queue_kind_t    mpd_kind;
	mpsc_daemon_queue_options_t mpd_options;
	mpsc_daemon_queue_state_t _Atomic mpd_state;
	mpsc_daemon_invoke_fn_t     mpd_invoke;
	union {
		mpsc_daemon_queue_t     mpd_target;
		struct thread          *mpd_thread;
		struct thread_call     *mpd_call;
	};
	struct mpsc_queue_head      mpd_queue;
	struct mpsc_queue_chain     mpd_chain;
};
struct mpsc_ring {
	char *mr_buffer;
	uint32_t *mr_writer_holds;

	union mpsc_ring_head_tail {
		struct {
			uint32_t mrht_head;
			uint32_t mrht_tail;
		};
		uint64_t mrht_head_tail;
	} mr_head_tail;

	uint32_t mr_capacity;
	uint8_t mr_writer_count;
};
struct {
	uint32_t mrc_commit_pos;
	uint32_t mrc_pos;
	uint32_t mrc_limit;
} mpsc_ring_cursor_t;
struct pager_crypt_info {
	int     (*page_decrypt)(const void *src_vaddr, void *dst_vaddr,
	    unsigned long long src_offset, void *crypt_ops);
	void    (*crypt_end)(void *crypt_ops);
	void    *crypt_ops;
	volatile int    crypt_refcnt;
};
struct crypt_file_data {
	char          *filename;
	cpu_type_t     cputype;
	cpu_subtype_t  cpusubtype;
	crypt_origin_t origin;
};
struct percpu_base {
	vm_address_t start;
	vm_address_t end;
	vm_offset_t  size;
} percpu_base;
struct pmsStat {
	uint64_t        stTime[2];                      
	uint32_t        stCnt[2];                       
} pmsStat;
struct pmsDef {
	uint64_t        pmsLimit;                       
	uint32_t        pmsStepID;                      
	uint32_t        pmsSetCmd;                      



	union sf {
		pmsSetFunc_t    pmsSetFunc;     
		uint32_t        pmsSetFuncInd;  
	} sf;

	uint32_t        pmsDown;                        
	uint32_t        pmsNext;                        
	uint32_t        pmsTDelay;                      
} pmsDef;
struct pmsCtl {
	pmsStat(*pmsStats)[pmsMaxStates];               
	pmsDef          *pmsDefs[pmsMaxStates]; 
} pmsCtl;
struct pmsd {
	uint32_t        pmsState;                       
	uint32_t        pmsCSetCmd;                     
	uint64_t        pmsPop;                         
	uint64_t        pmsStamp;                       
	uint64_t        pmsTime;                        
} pmsd;
struct {
	uint32_t        request;                        
	uint32_t        reqsize;                        
	void            *reqaddr;                       
} pmsctl_t;
struct {
	int16_t         qos_pri[THREAD_QOS_LAST];
	int16_t         qos_iotier[THREAD_QOS_LAST];
	uint32_t        qos_through_qos[THREAD_QOS_LAST];
	uint32_t        qos_latency_qos[THREAD_QOS_LAST];
} qos_policy_params_t;
struct priority_queue_entry {
	struct priority_queue_entry        *next;
	struct priority_queue_entry        *prev;
	long                                __key: PRIORITY_QUEUE_ENTRY_KEY_BITS;
	long                                child: PRIORITY_QUEUE_ENTRY_CHILD_BITS;
} *priority_queue_entry_t;
struct priority_queue_entry_deadline {
	struct priority_queue_entry_deadline *next;
	struct priority_queue_entry_deadline *prev;
	long                                  __key: PRIORITY_QUEUE_ENTRY_KEY_BITS;
	long                                  child: PRIORITY_QUEUE_ENTRY_CHILD_BITS;
	uint64_t                              deadline;
} *priority_queue_entry_deadline_t;
struct priority_queue_entry_sched {
	struct priority_queue_entry_sched  *next;
	struct priority_queue_entry_sched  *prev;
	long                                key: PRIORITY_QUEUE_ENTRY_KEY_BITS;
	long                                child: PRIORITY_QUEUE_ENTRY_CHILD_BITS;
} *priority_queue_entry_sched_t;
struct priority_queue_entry_stable {
	struct priority_queue_entry_stable *next;
	struct priority_queue_entry_stable *prev;
	long                                key: PRIORITY_QUEUE_ENTRY_KEY_BITS;
	long                                child: PRIORITY_QUEUE_ENTRY_CHILD_BITS;
	uint64_t                            stamp;
} *priority_queue_entry_stable_t;
struct priority_queue_min {
	struct priority_queue_entry *pq_root;
	priority_queue_compare_fn_t  pq_cmp_fn;
};
struct priority_queue_max {
	struct priority_queue_entry *pq_root;
	priority_queue_compare_fn_t  pq_cmp_fn;
};
struct priority_queue_deadline_min {
	struct priority_queue_entry_deadline *pq_root;
};
struct priority_queue_deadline_max {
	struct priority_queue_entry_deadline *pq_root;
};
struct priority_queue_sched_min {
	struct priority_queue_entry_sched *pq_root;
};
struct priority_queue_sched_max {
	struct priority_queue_entry_sched *pq_root;
};
struct priority_queue_sched_stable_min {
	struct priority_queue_entry_stable *pq_root;
};
struct priority_queue_sched_stable_max {
	struct priority_queue_entry_stable *pq_root;
};
struct processor_set {
	int                     pset_id;
	int                     online_processor_count;
	int                     cpu_set_low, cpu_set_hi;
	int                     cpu_set_count;
	int                     last_chosen;

	uint64_t                pset_load_last_update;
	cpumap_t                cpu_bitmask;
	cpumap_t                recommended_bitmask;
	cpumap_t                cpu_state_map[PROCESSOR_STATE_LEN];
	cpumap_t                realtime_map;
	cpumap_t                cpu_available_map;


	struct run_queue        pset_runq;      
	struct rt_queue         rt_runq;        
	uint64_t                stealable_rt_threads_earliest_deadline; 

	cpumap_t                pending_AST_URGENT_cpu_mask;
	cpumap_t                pending_AST_PREEMPT_cpu_mask;
	cpumap_t                pending_spill_cpu_mask;
	cpumap_t                rt_pending_spill_cpu_mask;

	struct ipc_port *       pset_self;              
	struct ipc_port *       pset_name_self; 

	processor_set_t         pset_list;              
	pset_node_t             node;
	uint32_t                pset_cluster_id;

	pset_cluster_type_t     pset_cluster_type;
	cluster_type_t          pset_type;

	cpumap_t                perfcontrol_cpu_preferred_bitmask;
	cpumap_t                perfcontrol_cpu_migration_bitmask;
	int                     cpu_preferred_last_chosen;
};
struct pset_node {
	processor_set_t         psets;                  

	pset_node_t             nodes;                  
	pset_node_t             node_list;              

	pset_cluster_type_t     pset_cluster_type;      

	pset_map_t              pset_map;               
	_Atomic pset_map_t      pset_idle_map;          
	_Atomic pset_map_t      pset_non_rt_map;        
	_Atomic pset_map_t      pset_recommended_map;   
};
struct processor {
	processor_state_t       state;                  
	bool                    is_recommended;
	bool                    current_is_bound;       
	bool                    current_is_eagerpreempt;
	bool                    pending_nonurgent_preemption; 
	struct thread          *active_thread;          
	struct thread          *idle_thread;            
	struct thread          *startup_thread;

	processor_set_t         processor_set;  

	int                     current_pri;            
	sfi_class_id_t          current_sfi_class;      
	perfcontrol_class_t     current_perfctl_class;  
	pset_cluster_type_t     current_recommended_pset_type;
	thread_urgency_t        current_urgency;        

	int                     starting_pri;           
	int                     cpu_id;                 

	uint64_t                quantum_end;            
	uint64_t                last_dispatch;          


	uint64_t                deadline;               
	bool                    first_timeslice;        

	bool                    must_idle;              
	bool                    next_idle_short;        


	struct run_queue        runq;                   


	struct ipc_port        *processor_self;         

	processor_t             processor_list;         

	uint64_t                timer_call_ttd;         
	processor_reason_t      last_startup_reason;
	processor_reason_t      last_shutdown_reason;
	processor_reason_t      last_recommend_reason;
	processor_reason_t      last_derecommend_reason;

	bool                    processor_instartup;     

	bool                    processor_booted;       

	bool                    shutdown_temporary;     
	bool                    processor_online;       

	bool                    processor_inshutdown;   
	processor_offline_state_t processor_offline_state;
};
struct queue_entry {
	struct queue_entry      *next;          
	struct queue_entry      *prev;          
};
struct recount_plan {
	const char *rpl_name;
	recount_topo_t rpl_topo;
} *recount_plan_t;
struct recount_track {
	uint32_t rt_pad;
	uint32_t rt_sync;

	struct recount_usage {
		struct recount_metrics {
			
			uint64_t rm_time_mach;
		} ru_metrics[RCT_LVL_COUNT];

	} rt_usage;
};
struct recount_times_mach {
	uint64_t rtm_user;
	uint64_t rtm_system;
};
struct recount_thread {
	struct recount_track *rth_lifetime;
	uint64_t rth_interrupt_duration_mach;
	recount_level_t rth_current_level;
};
struct recount_work_interval {
	struct recount_track *rwi_current_instance;
};
struct recount_task {
	struct recount_track *rtk_lifetime;
	struct recount_usage *rtk_terminated;
};
struct recount_coalition {
	struct recount_usage *rco_exited;
};
struct recount_snap {
	uint64_t rsn_time_mach;
};
struct recount_processor {
	struct recount_snap rpr_snap;
	struct recount_track rpr_active;
	uint64_t rpr_interrupt_duration_mach;
	uint64_t rpr_last_interrupt_enter_time_mach;
	uint64_t rpr_last_interrupt_leave_time_mach;
	uint64_t rpr_idle_time_mach;
	_Atomic uint64_t rpr_state_last_abs_time;
};
struct bt_params {
	double rate;
	uint64_t base_local_ts;
	uint64_t base_remote_ts;
};
struct {
	mach_vm_address_t location;
	unsigned short    length;
	unsigned short    recovery_offs;
	unsigned int      flags;
} task_restartable_range_t;
struct runq_stats {
	uint64_t                count_sum;
	uint64_t                last_change_timestamp;
};
struct {
	queue_head_t            pri_queue;                      
	uint64_t                pri_earliest_deadline;          
	int                     pri_count;                      
	uint32_t                pri_constraint;                 
} rt_queue_pri_t;
struct rt_queue {
	_Atomic uint64_t        earliest_deadline;              
	_Atomic int             count;                          
	_Atomic uint32_t        constraint;                     
	_Atomic int             ed_index;                       

	bitmap_t                bitmap[BITMAP_LEN(NRTQS)];

	rt_queue_pri_t          rt_queue_pri[NRTQS];

	struct runq_stats       runq_stats;
};
struct shift_data {
	int     shift1;
	int     shift2;
};
struct sched_update_scan_context {
	uint64_t        earliest_bg_make_runnable_time;
	uint64_t        earliest_normal_make_runnable_time;
	uint64_t        earliest_rt_make_runnable_time;
	uint64_t        sched_tick_last_abstime;
};
struct sched_statistics {
	uint32_t        csw_count;
	uint32_t        preempt_count;
	uint32_t        preempted_rt_count;
	uint32_t        preempted_by_rt_count;
	uint32_t        rt_sched_count;
	uint32_t        interrupt_count;
	uint32_t        ipi_count;
	uint32_t        timer_pop_count;
	uint32_t        idle_transitions;
	uint32_t        quantum_timer_expirations;
};
struct sched_dispatch_table {
	const char *sched_name;
	void    (*init)(void);                          
	void    (*timebase_init)(void);         
	void    (*processor_init)(processor_t processor);       
	void    (*pset_init)(processor_set_t pset);     

	void    (*maintenance_continuation)(void);      

	thread_t        (*choose_thread)(
		processor_t           processor,
		int                           priority,
		thread_t              prev_thread,
		ast_t reason);

	bool    (*steal_thread_enabled)(processor_set_t pset);

	thread_t        (*steal_thread)(
		processor_set_t         pset);

	int (*compute_timeshare_priority)(thread_t thread);

	pset_node_t (*choose_node)(
		thread_t                      thread);

	processor_t     (*choose_processor)(
		processor_set_t                pset,
		processor_t                    processor,
		thread_t                       thread);
	boolean_t (*processor_enqueue)(
		processor_t                    processor,
		thread_t                       thread,
		sched_options_t                options);

	void (*processor_queue_shutdown)(
		processor_t                    processor);

	boolean_t       (*processor_queue_remove)(
		processor_t             processor,
		thread_t                thread);

	boolean_t       (*processor_queue_empty)(processor_t            processor);

	boolean_t       (*priority_is_urgent)(int priority);

	ast_t           (*processor_csw_check)(processor_t processor);

	boolean_t       (*processor_queue_has_priority)(processor_t             processor,
	    int                             priority,
	    boolean_t               gte);

	uint32_t        (*initial_quantum_size)(thread_t thread);

	sched_mode_t    (*initial_thread_sched_mode)(task_t parent_task);

	boolean_t       (*can_update_priority)(thread_t thread);

	void            (*update_priority)(thread_t thread);

	void            (*lightweight_update_priority)(thread_t thread);

	void            (*quantum_expire)(thread_t thread);

	int                     (*processor_runq_count)(processor_t     processor);

	uint64_t    (*processor_runq_stats_count_sum)(processor_t   processor);

	boolean_t       (*processor_bound_count)(processor_t processor);

	void            (*thread_update_scan)(sched_update_scan_context_t scan_context);

	boolean_t   multiple_psets_enabled;

	boolean_t   avoid_processor_enabled;

	bool    (*thread_avoid_processor)(processor_t processor, thread_t thread, ast_t reason);

	bool    (*processor_balance)(processor_t processor, processor_set_t pset);
	rt_queue_t      (*rt_runq)(processor_set_t pset);
	void    (*rt_init)(processor_set_t pset);
	void    (*rt_queue_shutdown)(processor_t processor);
	void    (*rt_runq_scan)(sched_update_scan_context_t scan_context);
	int64_t (*rt_runq_count_sum)(void);
	thread_t (*rt_steal_thread)(processor_set_t pset, uint64_t earliest_deadline);

	uint32_t (*qos_max_parallelism)(int qos, uint64_t options);
	void    (*check_spill)(processor_set_t pset, thread_t thread);
	sched_ipi_type_t (*ipi_policy)(processor_t dst, thread_t thread, boolean_t dst_idle, sched_ipi_event_t event);
	bool    (*thread_should_yield)(processor_t processor, thread_t thread);

	uint32_t (*run_count_incr)(thread_t thread);
	uint32_t (*run_count_decr)(thread_t thread);

	void (*update_thread_bucket)(thread_t thread);

	void (*pset_made_schedulable)(processor_t processor, processor_set_t pset, boolean_t drop_lock);
	void (*cpu_init_completed)(void);
	bool (*thread_eligible_for_pset)(thread_t thread, processor_set_t pset);
};
struct usimple_lock_startup_spec {
	usimple_lock_t  lck;
	unsigned short  lck_init_arg;
};
struct {
	smr_seq_t               s_rd_seq;
	smr_seq_t               s_wr_seq;
} smr_clock_t;
struct smr {
	smr_clock_t             smr_clock;
	struct smr_pcpu        *smr_pcpu;
	unsigned long           smr_flags;
	unsigned long           smr_early;
	char                    smr_name[SMR_NAME_MAX];
} __attribute__((aligned(64)));
struct smr_tracker {
	smr_t                   smrt_domain;
	smr_seq_t               smrt_seq;
	struct smrq_link        smrt_link;
	struct smrq_slink       smrt_stack;
	uint32_t                smrt_ctid;
	int                     smrt_cpu;
} *smr_tracker_t;
struct {
	union {
		const char     *smrk_string;
		const void     *smrk_opaque;
		uint64_t        smrk_u64;
	};
	size_t                  smrk_len;
} smrh_key_t;
struct smrh_traits {
	unsigned long           link_offset;
	smr_t                   domain;
	uint32_t              (*key_hash)(smrh_key_t, uint32_t);
	bool                  (*key_equ)(smrh_key_t, smrh_key_t);
	uint32_t              (*obj_hash)(const struct smrq_slink *, uint32_t);
	bool                  (*obj_equ)(const struct smrq_slink *, smrh_key_t);
	bool                  (*obj_try_get)(void *);
};
struct smr_hash {
	uintptr_t               smrh_array;
	uint32_t                smrh_count;
	bool                    smrh_resizing;
	uint8_t                 smrh_unused1;
	uint16_t                smrh_unused2;
};
struct smr_hash_array {
	struct smrq_slist_head *smrh_array;
	uint16_t                smrh_order;
};
struct smr_hash_iterator {
	struct smr_hash        *smrh;
	struct smrq_slist_head *hd_next;
	struct smrq_slist_head *hd_last;
	__smrq_slink_t         *prev;
	struct smrq_slink      *link;
};
struct {
	uint8_t                 curidx;
	uint8_t                 curshift;
	uint8_t                 newidx;
	uint8_t                 newshift;
} smrsh_state_t;
struct smr_shash {
	hw_lck_ptr_t *_Atomic   smrsh_array[2];
	uint32_t _Atomic        smrsh_seed[2];
	smrsh_state_t _Atomic   smrsh_state;
	smrsh_rehash_t _Atomic  smrsh_rehashing;
	smrsh_policy_t          smrsh_policy;
	uint16_t                smrsh_min_shift : 5;
	uint16_t                __unused_bits : 11;
	scalable_counter_t      smrsh_count;
	struct thread_call     *smrsh_callout;
};
struct {
	hw_lck_ptr_t           *head;
	__smrq_slink_t         *prev;
} smr_shash_mut_cursor_t;
struct smr_node {
	struct smr_node        *smrn_next;
	smr_cb_t XNU_PTRAUTH_SIGNED_FUNCTION_PTR("ssmr_cb_t") smrn_cb;
};
struct smrq_slink {
	__smrq_slink_t          next;
};
struct smrq_link {
	__smrq_link_t           next;
	__smrq_link_t          *prev;
};
struct smrq_slist_head {
	__smrq_slink_t          first;
};
struct smrq_list_head {
	__smrq_link_t           first;
};
struct smrq_stailq_head {
	__smrq_slink_t          first;
	__smrq_slink_t         *last;
};
struct smrq_tailq_head {
	__smrq_link_t           first;
	__smrq_link_t          *last;
};
struct {
	uint32_t version;
	uint64_t boot_time;
	uuid_t kernel_uuid;
	uuid_t primary_kernelcache_uuid;
} __attribute__((packed)) socd_client_hdr_t;
struct {
	uint64_t timestamp;
	uint32_t debugid;
	socd_client_trace_arg_t arg1;
	socd_client_trace_arg_t arg2;
	socd_client_trace_arg_t arg3;
	socd_client_trace_arg_t arg4;
} __attribute ((packed)) socd_client_trace_entry_t;
struct machine_timeout_spec {
	void *ptr;
	uint64_t default_value;
	uint64_t unit_scale;
	char name[MACHINE_TIMEOUT_MAX_NAME_LEN + 1];
	bool (*skip_predicate)(struct machine_timeout_spec const *);
};
struct startup_entry {
	startup_subsystem_id_t subsystem;
	startup_rank_t         rank;
	void                 (*func)(const void *);
	const void            *arg;
};
struct startup_tunable_spec {
	const char *name;
	void       *var_addr;
	int         var_len;
	bool        var_is_bool;
	bool        var_is_str;
};
struct startup_tunable_dt_spec {
	const char *dt_base;
	const char *dt_name;
	bool        dt_chosen_override;
	const char *boot_arg_name;
	void       *var_addr;
	int         var_len;
	bool        var_is_bool;
};
struct startup_tunable_dt_source_spec {
	const char       *dt_base;
	const char       *dt_name;
	bool              dt_chosen_override;
	const char       *boot_arg_name;
	void             *var_addr;
	int               var_len;
	bool              var_is_bool;
	startup_source_t *source_addr;
};
struct event_hdr {
	struct event_hdr *next;
};
struct semaphore {
	queue_chain_t     task_link;  
	struct waitq      waitq;      
	task_t            owner;      
	ipc_port_t        port;       
	os_ref_atomic_t   ref_count;  
	int               count;      
} Semaphore;
struct {
	unsigned char           mach_trap_arg_count; 
	unsigned char           mach_trap_u32_words; 
	unsigned char           mach_trap_returns_port;
	unsigned char           __mach_trap_padding;
	kern_return_t         (*mach_trap_function)(void *);
} mach_trap_t;
struct _cpu_time_qos_stats {
	uint64_t cpu_time_qos_default;
	uint64_t cpu_time_qos_maintenance;
	uint64_t cpu_time_qos_background;
	uint64_t cpu_time_qos_utility;
	uint64_t cpu_time_qos_legacy;
	uint64_t cpu_time_qos_user_initiated;
	uint64_t cpu_time_qos_user_interactive;
};
struct task_writes_counters {
	uint64_t task_immediate_writes;
	uint64_t task_deferred_writes;
	uint64_t task_invalidated_writes;
	uint64_t task_metadata_writes;
};
struct task_pend_token {
	union {
		struct {
			uint32_t        tpt_update_sockets      :1,
			    tpt_update_timers       :1,
			    tpt_update_watchers     :1,
			    tpt_update_live_donor   :1,
			    tpt_update_coal_sfi     :1,
			    tpt_update_throttle     :1,
			    tpt_update_thread_sfi   :1,
			    tpt_force_recompute_pri :1,
			    tpt_update_tg_ui_flag   :1,
			    tpt_update_turnstile    :1,
			    tpt_update_tg_app_flag  :1,
			    tpt_update_game_mode    :1,
			    tpt_update_carplay_mode :1;
		};
		uint32_t tpt_value;
	};
};
struct task {
	decl_lck_mtx_data(, lock);      
	os_refcnt_t     ref_count;      


	bool            active;         
	bool            ipc_active;     
	bool            halting;        
	bool            message_app_suspended;  

	uint32_t        vtimers;
	uint32_t loadTag; 

	uint64_t        task_uniqueid;

	vm_map_t        XNU_PTRAUTH_SIGNED_PTR("task.map") map; 
	queue_chain_t   tasks;  
	struct task_watchports *watchports; 
	turnstile_inheritor_t returnwait_inheritor; 

	queue_head_t            threads;
	struct restartable_ranges *t_rr_ranges;

	processor_set_t         pset_hint;
	struct affinity_space   *affinity_space;

	int                     thread_count;
	uint32_t                active_thread_count;
	int                     suspend_count;  

	integer_t               user_stop_count;        
	integer_t               legacy_stop_count;      

	int16_t                 priority;               
	int16_t                 max_priority;           

	integer_t               importance;             


	uint64_t                total_runnable_time;

	struct recount_task     tk_recount;

	decl_lck_mtx_data(, itk_lock_data);
	struct ipc_port * XNU_PTRAUTH_SIGNED_PTR("task.itk_task_ports") itk_task_ports[TASK_SELF_PORT_COUNT];
	struct ipc_port * XNU_PTRAUTH_SIGNED_PTR("task.itk_self") itk_self;                     
	struct exception_action exc_actions[EXC_TYPES_COUNT];
	struct hardened_exception_action hardened_exception_action;
	struct ipc_port * XNU_PTRAUTH_SIGNED_PTR("task.itk_host") itk_host;                     
	struct ipc_port * XNU_PTRAUTH_SIGNED_PTR("task.itk_bootstrap") itk_bootstrap;           
	struct ipc_port * XNU_PTRAUTH_SIGNED_PTR("task.itk_debug_control") itk_debug_control;   
	struct ipc_port * XNU_PTRAUTH_SIGNED_PTR("task.itk_task_access") itk_task_access;       
	struct ipc_port * XNU_PTRAUTH_SIGNED_PTR("task.itk_resume") itk_resume;                 
	struct ipc_port * XNU_PTRAUTH_SIGNED_PTR("task.itk_registered") itk_registered[TASK_PORT_REGISTER_MAX];
	ipc_port_t * XNU_PTRAUTH_SIGNED_PTR("task.itk_dyld_notify") itk_dyld_notify; 
	struct ipc_space * XNU_PTRAUTH_SIGNED_PTR("task.itk_space") itk_space;

	ledger_t        ledger;
	queue_head_t    semaphore_list;         
	int             semaphores_owned;       

	unsigned int    priv_flags;                     

	MACHINE_TASK

	counter_t faults;             
	counter_t pageins;            
	counter_t cow_faults;         
	counter_t messages_sent;      
	counter_t messages_received;  
	counter_t pages_grabbed;      
	counter_t pages_grabbed_kern; 
	counter_t pages_grabbed_iopl; 
	counter_t pages_grabbed_upl;  
	uint32_t decompressions;      
	uint32_t syscalls_mach;       
	uint32_t syscalls_unix;       
	uint32_t c_switch;            
	uint32_t p_switch;            
	uint32_t ps_switch;           

	kcdata_descriptor_t             corpse_info;
	uint64_t                        crashed_thread_id;
	queue_chain_t                   corpse_tasks;
	struct label *                  crash_label;
	volatile uint32_t t_flags;                                      
	uint32_t t_procflags;                                            
	mach_vm_address_t       all_image_info_addr; 
	mach_vm_size_t          all_image_info_size; 
	bool pidsuspended; 
	bool frozen;       
	bool changing_freeze_state;        
	bool     is_large_corpse;
	uint16_t policy_ru_cpu          :4,
	    policy_ru_cpu_ext      :4,
	    applied_ru_cpu         :4,
	    applied_ru_cpu_ext     :4;
	uint8_t  rusage_cpu_flags;
	uint8_t  rusage_cpu_percentage;         
	uint8_t  rusage_cpu_perthr_percentage;  
	uint8_t                  t_returnwaitflags;


	struct vm_shared_region         *shared_region;

	uint64_t rusage_cpu_interval;           
	uint64_t rusage_cpu_perthr_interval;    
	uint64_t rusage_cpu_deadline;
	thread_call_t rusage_cpu_callt;

	struct bank_task *bank_context;  


	vm_extmod_statistics_data_t     extmod_statistics;

	struct task_requested_policy requested_policy;
	struct task_effective_policy effective_policy;

	struct task_pend_token pended_coalition_changes;

	uint32_t        low_mem_notified_warn           :1,     
	    low_mem_notified_critical       :1,                 
	    purged_memory_warn              :1,                 
	    purged_memory_critical          :1,                 
	    low_mem_privileged_listener     :1,                 
	    mem_notify_reserved             :27;                

	uint32_t memlimit_is_active                 :1, 
	    memlimit_is_fatal                   :1,     
	    memlimit_active_exc_resource        :1,     
	    memlimit_inactive_exc_resource      :1,     
	    memlimit_attrs_reserved             :28;     

	io_stat_info_t          task_io_stats;

	struct task_writes_counters task_writes_counters_internal;
	struct task_writes_counters task_writes_counters_external;

	struct _cpu_time_qos_stats      cpu_time_eqos_stats;
	struct _cpu_time_qos_stats      cpu_time_rqos_stats;

	uint32_t        task_timer_wakeups_bin_1;
	uint32_t        task_timer_wakeups_bin_2;
	uint64_t        task_gpu_ns;

	uint8_t         task_can_transfer_memory_ownership;
	uint8_t         task_objects_disowning;
	uint8_t         task_objects_disowned;
	int             task_volatile_objects;
	int             task_nonvolatile_objects;
	int             task_owned_objects;
	queue_head_t    task_objq;
	decl_lck_mtx_data(, task_objq_lock); 

	unsigned int    task_thread_limit:16;
	unsigned int    task_legacy_footprint:1;
	unsigned int    task_extra_footprint_limit:1;
	unsigned int    task_ios13extended_footprint_limit:1;
	unsigned int    task_region_footprint:1;
	unsigned int    task_region_info_flags:1;
	unsigned int    task_has_crossed_thread_limit:1;
	unsigned int    task_rr_in_flight:1; 
	coalition_t     coalition[COALITION_NUM_TYPES];
	queue_chain_t   task_coalition[COALITION_NUM_TYPES];
	uint64_t        dispatchqueue_offset;




	task_exc_guard_behavior_t task_exc_guard;
	mach_vm_address_t mach_header_vm_address;

	queue_head_t    io_user_clients;

	boolean_t       donates_own_pages; 
	uint32_t task_shared_region_slide;   
	uuid_t   task_shared_region_uuid;
	vmobject_list_output_t corpse_vmobject_list;
	uint64_t corpse_vmobject_list_size;


	uint64_t task_cs_auxiliary_info;

};
struct task_watchport_elem {
	task_t                          twe_task;
	ipc_port_t                      twe_port;     
	ipc_port_t XNU_PTRAUTH_SIGNED_PTR("twe_pdrequest") twe_pdrequest;
};
struct task_watchports {
	os_refcnt_t                     tw_refcount;           
	task_t                          tw_task;               
	thread_t                        tw_thread;             
	uint32_t                        tw_elem_array_count;   
	struct task_watchport_elem      tw_elem[];             
};
struct task_power_info_extra {
	uint64_t cycles;
	uint64_t instructions;
	uint64_t pcycles;
	uint64_t pinstructions;
	uint64_t user_ptime;
	uint64_t system_ptime;
	uint64_t runnable_time;
	uint64_t energy;
	uint64_t penergy;
	uint64_t secure_time;
	uint64_t secure_ptime;
};
struct _task_ledger_indices {
	int cpu_time;
	int tkm_private;
	int tkm_shared;
	int phys_mem;
	int wired_mem;
	int conclave_mem;
	int internal;
	int iokit_mapped;
	int external;
	int reusable;
	int alternate_accounting;
	int alternate_accounting_compressed;
	int page_table;
	int phys_footprint;
	int internal_compressed;
	int purgeable_volatile;
	int purgeable_nonvolatile;
	int purgeable_volatile_compressed;
	int purgeable_nonvolatile_compressed;
	int tagged_nofootprint;
	int tagged_footprint;
	int tagged_nofootprint_compressed;
	int tagged_footprint_compressed;
	int network_volatile;
	int network_nonvolatile;
	int network_volatile_compressed;
	int network_nonvolatile_compressed;
	int media_nofootprint;
	int media_footprint;
	int media_nofootprint_compressed;
	int media_footprint_compressed;
	int graphics_nofootprint;
	int graphics_footprint;
	int graphics_nofootprint_compressed;
	int graphics_footprint_compressed;
	int neural_nofootprint;
	int neural_footprint;
	int neural_nofootprint_compressed;
	int neural_footprint_compressed;
	int neural_nofootprint_total;
	int platform_idle_wakeups;
	int interrupt_wakeups;
	int cpu_time_billed_to_me;
	int cpu_time_billed_to_others;
	int physical_writes;
	int logical_writes;
	int logical_writes_to_external;
	int energy_billed_to_me;
	int energy_billed_to_others;
	int pages_grabbed;
	int pages_grabbed_kern;
	int pages_grabbed_iopl;
	int pages_grabbed_upl;
	int swapins;
};
struct proc_ident {
	uint64_t        p_uniqueid;
	pid_t           p_pid;
	int             p_idversion;
};
struct task_id_token {
	struct proc_ident ident;
	ipc_port_t        port;
	uint64_t          task_uniqueid; 
	os_refcnt_t       tidt_refs;
};
struct thread_ro {
	struct thread              *tro_owner;
	struct task                *tro_task;

	struct ipc_port            *tro_self_port;
	struct ipc_port            *tro_ports[THREAD_SELF_PORT_COUNT];  

	struct exception_action    *tro_exc_actions;
};
struct thread {

	union {
		queue_chain_t                   runq_links;             
		queue_chain_t                   wait_links;             
		struct mpsc_queue_chain         mpsc_links;             
		struct priority_queue_entry_sched wait_prioq_links;       
	};

	event64_t               wait_event;     
	struct { processor_t    runq; } __runq; 
	waitq_t                 waitq;          
	struct turnstile       *turnstile;      
	void                   *inheritor;      
	struct priority_queue_sched_max sched_inheritor_queue; 
	struct priority_queue_sched_max base_inheritor_queue; 



	decl_simple_lock_data(, sched_lock);     
	decl_simple_lock_data(, wake_lock);      
	uint16_t                options;        

	bool                    wake_active;    
	bool                    at_safe_point;  
	uint8_t                 sched_saved_run_weight;


	ast_t                   reason;         
	uint32_t                quantum_remaining;
	wait_result_t           wait_result;    
	thread_rr_state_t       t_rr_state;     
	thread_continue_t       continuation;   
	void                   *parameter;      

	vm_offset_t             kernel_stack;   
	vm_offset_t             reserved_stack; 

	struct machine_thread   machine;


	int                     state;


	sched_mode_t            sched_mode;     
	sched_mode_t            saved_mode;     

	sched_bucket_t          th_sched_bucket;

	sfi_class_id_t          sfi_class;      
	sfi_class_id_t          sfi_wait_class; 

	uint32_t                sched_flags;            














	int16_t                 sched_pri;              
	int16_t                 base_pri;               
	int16_t                 req_base_pri;           
	int16_t                 max_priority;           
	int16_t                 task_priority;          
	uint16_t                priority_floor_count;   
	int16_t                 suspend_count;          

	int                     iotier_override;        
	os_ref_atomic_t         ref_count;              

	uint32_t                rwlock_count;           
	struct smrq_slist_head  smr_stack;

	integer_t               importance;             

	integer_t               depress_timer_active;
	timer_call_t            depress_timer;

	struct {                                        
		uint32_t            period;
		uint32_t            computation;
		uint32_t            constraint;
		bool                preemptible;
		uint8_t             priority_offset;   
		uint64_t            deadline;
	}                       realtime;

	uint64_t                last_run_time;          
	uint64_t                last_made_runnable_time;        
	uint64_t                last_basepri_change_time;       
	uint64_t                same_pri_latency;
	uint64_t                workq_quantum_deadline;




	processor_t             bound_processor;        
	processor_t             last_processor;         
	processor_t             chosen_processor;       

	uint64_t                computation_metered;
	uint64_t                computation_epoch;
	uint64_t                computation_interrupt_epoch;
	uint64_t                safe_release;           

	void                  (*sched_call)(int type, thread_t thread);


	uint32_t                c_switch;               
	uint32_t                p_switch;               
	uint32_t                ps_switch;              

	uint64_t                sched_time_save;        
	uint64_t                vtimer_user_save;       
	uint64_t                vtimer_prof_save;
	uint64_t                vtimer_rlim_save;
	uint64_t                vtimer_qos_save;

	timer_data_t            runnable_timer;         

	struct recount_thread   th_recount;             


	queue_chain_t           affinity_threads;
	affinity_set_t          affinity_set;


	union {
		struct {
			
			mach_msg_recv_bufs_t    recv_bufs;      
			mach_msg_option64_t     option;         
			ipc_object_t            object;         

			
			mach_msg_return_t       state;          
			mach_port_seqno_t       seqno;          
			mach_msg_size_t         msize;          
			mach_msg_size_t         asize;          
			mach_port_name_t        receiver_name;  
			union {
				struct ipc_kmsg   *XNU_PTRAUTH_SIGNED_PTR("thread.ith_kmsg")  kmsg;  
			};
		} receive;
		struct {
			struct semaphore        *waitsemaphore;         
			struct semaphore        *signalsemaphore;       
			int                     options;                
			kern_return_t           result;                 
			mach_msg_continue_t continuation;
		} sema;
		struct {
			void                    *tls[THREAD_SAVE_IOKIT_TLS_COUNT];
		} iokit;
	} saved;

	union {
		
		struct thread_call_thread_state *thc_state;

		
		struct {
			int                             os_reason;
			exception_type_t                exception_type;
			mach_exception_code_t           code;
			mach_exception_subcode_t        subcode;
		} mach_exc_info;
	};

	int32_t                 user_stop_count;

	circle_queue_head_t     ith_messages;           
	mach_port_t             ith_kernel_reply_port;  

	bool                    th_vm_faults_disabled;

	bool                    recover;                


	queue_chain_t           threads;                

	queue_chain_t           task_threads;

	struct thread_ro       *t_tro;
	vm_map_t                map;
	thread_t                handoff_thread;

	timer_call_t            wait_timer;
	uint16_t                wait_timer_active; 
	bool                    wait_timer_armed; 

	uint32_t
	    active:1,           
	    ipc_active:1,       
	    started:1,          
	    static_param:1,     
	    inspection:1,       
	    policy_reset:1,     
	    suspend_parked:1,   
	    corpse_dup:1,       
	:0;

	os_atomic(ast_t)        ast;

	decl_lck_mtx_data(, mutex);

	struct ipc_port         *ith_special_reply_port;   

	uint16_t                t_dtrace_flags;         
	uint16_t                t_dtrace_inprobe;       
	uint32_t                t_dtrace_predcache;     
	int64_t                 t_dtrace_tracing;       
	int64_t                 t_dtrace_vtime;

	clock_sec_t             t_page_creation_time;
	uint32_t                t_page_creation_count;
	uint32_t                t_page_creation_throttled;
	int                     t_pagein_error;         

	mach_port_name_t        ith_voucher_name;
	ipc_voucher_t           ith_voucher;








	uint32_t                syscalls_unix;
	uint32_t                syscalls_mach;
	ledger_t                t_ledger;
	ledger_t                t_threadledger; 
	ledger_t                t_bankledger;                
	uint64_t                t_deduct_bank_ledger_time;   
	uint64_t                t_deduct_bank_ledger_energy; 

	uint64_t                thread_id;             
	uint32_t                ctid;                  
	uint32_t                ctsid;                 

	struct thread_requested_policy  requested_policy;
	struct thread_effective_policy  effective_policy;

	struct thread_qos_override {
		struct thread_qos_override      *override_next;
		uint32_t        override_contended_resource_count;
		int16_t         override_qos;
		int16_t         override_resource_type;
		user_addr_t     override_resource;
	} *overrides;

	uint32_t                kevent_overrides;
	uint8_t                 user_promotion_basepri;
	uint8_t                 kern_promotion_schedpri;
	_Atomic uint16_t        kevent_ast_bits;

	io_stat_info_t          thread_io_stats; 

	uint32_t                thread_callout_interrupt_wakeups;
	uint32_t                thread_callout_platform_idle_wakeups;
	uint32_t                thread_timer_wakeups_bin_1;
	uint32_t                thread_timer_wakeups_bin_2;
	thread_tag_t            thread_tag;

	uint16_t
	    callout_woken_from_icontext:1,
	    callout_woken_from_platform_idle:1,
	    callout_woke_thread:1,
	    mach_exc_fatal:1,
	    mach_exc_ktriage:1,
	    thread_bitfield_unused:11;

	uint32_t                 th_bound_cluster_id;


	struct work_interval            *th_work_interval;
	thread_work_interval_flags_t    th_work_interval_flags;

	turnstile_update_flags_t inheritor_flags; 
	block_hint_t            pending_block_hint;
	block_hint_t            block_hint;      
	uint32_t                decompressions;  
	int                     thread_region_page_shift; 
	                                                  
	                                                  

	struct knote            *ith_knote;         


};
struct _thread_ledger_indices {
	int cpu_time;
};
struct thread_pri_floor {
	thread_t thread;
} thread_pri_floor_t;
struct thread_call {
	uint64_t                                tc_soft_deadline;
	struct priority_queue_entry_deadline    tc_pqlink;
	queue_head_t                            *tc_queue;
	queue_chain_t                           tc_qlink;
	thread_call_index_t                     tc_index;
	thread_call_flags_t                     tc_flags;
	int32_t                                 tc_refs;
	uint64_t                                tc_ttd;
	uint64_t                                tc_pending_timestamp;
	thread_call_func_t                      tc_func;
	thread_call_param_t                     tc_param0;
	thread_call_param_t                     tc_param1;
	uint64_t                                tc_submit_count;
	uint64_t                                tc_finish_count;
};
struct thread_kernel_state {
	machine_thread_kernel_state  machine;       
	kern_allocation_name_t       allocation_name;
} __attribute__((aligned(16)));
struct lck_ticket_s {
	uint32_t                __lck_ticket_unused : 24;
	uint32_t                lck_ticket_type     :  8;
	uint32_t                lck_ticket_padding;
	hw_lck_ticket_t         tu;
	uint32_t                lck_ticket_owner;
} lck_ticket_t;
struct timer {
	uint64_t tstamp;
	uint64_t all_bits;
} TIMER_ALIGNMENT;
struct timer_call {
	uint64_t                                tc_soft_deadline;
	decl_simple_lock_data(, tc_lock);          
	struct priority_queue_entry_deadline    tc_pqlink;
	queue_head_t                            *tc_queue;
	queue_chain_t                           tc_qlink;
	timer_call_func_t                       tc_func;
	timer_call_param_t                      tc_param0;
	timer_call_param_t                      tc_param1;
	uint64_t                                tc_ttd; 
	uint64_t                                tc_entry_time;
	uint32_t                                tc_flags;
	bool                                    tc_async_dequeue;
} timer_call_data_t, *timer_call_t;
struct {
	uint32_t powergate_latency_abstime;

	uint32_t idle_entry_timer_processing_hdeadline_threshold_abstime;
	uint32_t interrupt_timer_coalescing_ilat_threshold_abstime;
	uint32_t timer_resort_threshold_abstime;

	int32_t timer_coalesce_rt_shift;
	int32_t timer_coalesce_bg_shift;
	int32_t timer_coalesce_kt_shift;
	int32_t timer_coalesce_fp_shift;
	int32_t timer_coalesce_ts_shift;

	uint64_t timer_coalesce_rt_abstime_max;
	uint64_t timer_coalesce_bg_abstime_max;
	uint64_t timer_coalesce_kt_abstime_max;
	uint64_t timer_coalesce_fp_abstime_max;
	uint64_t timer_coalesce_ts_abstime_max;

	uint32_t latency_qos_scale[NUM_LATENCY_QOS_TIERS];
	uint64_t latency_qos_abstime_max[NUM_LATENCY_QOS_TIERS];
	boolean_t latency_tier_rate_limited[NUM_LATENCY_QOS_TIERS];
} timer_coalescing_priority_params_t;
struct {
	uint32_t idle_entry_timer_processing_hdeadline_threshold_ns;
	uint32_t interrupt_timer_coalescing_ilat_threshold_ns;
	uint32_t timer_resort_threshold_ns;

	int32_t timer_coalesce_rt_shift;
	int32_t timer_coalesce_bg_shift;
	int32_t timer_coalesce_kt_shift;
	int32_t timer_coalesce_fp_shift;
	int32_t timer_coalesce_ts_shift;

	uint64_t timer_coalesce_rt_ns_max;
	uint64_t timer_coalesce_bg_ns_max;
	uint64_t timer_coalesce_kt_ns_max;
	uint64_t timer_coalesce_fp_ns_max;
	uint64_t timer_coalesce_ts_ns_max;

	uint32_t latency_qos_scale[NUM_LATENCY_QOS_TIERS];
	uint64_t latency_qos_ns_max[NUM_LATENCY_QOS_TIERS];
	boolean_t latency_tier_rate_limited[NUM_LATENCY_QOS_TIERS];
} timer_coalescing_priority_params_ns_t;
struct {
	uint8_t
	    telemetry_ca_event:2,

	    report_once_per_site:1;
} trap_telemetry_options_s;
struct {
	uint8_t
	    recoverable : 1,
	    enable_trap_telemetry : 1;
	trap_telemetry_options_s telemetry_options;
} brk_telemetry_options_s;
struct kernel_brk_descriptor {
	trap_telemetry_type_t    type;
	uint16_t                 base;
	uint16_t                 max;
	brk_telemetry_options_s  options;

	const char *(*handle_breakpoint)(void *states, uint16_t comment);
} *kernel_brk_descriptor_t;
struct trust_cache_entry1 {
	uint8_t cdhash[CS_CDHASH_LEN];
	uint8_t hash_type;
	uint8_t flags;
} __attribute__((__packed__));
struct trust_cache_module1 {
	uint32_t version;
	uuid_t uuid;
	uint32_t num_entries;
	struct trust_cache_entry1 entries[];
} __attribute__((__packed__));
struct turnstile_stats {
	uint64_t ts_priority_propagation;
	uint64_t ts_no_inheritor;
	uint64_t ts_thread_runnable;
	uint64_t ts_no_priority_change_required;
	uint64_t ts_above_ui_pri_change;
	uint64_t ts_no_turnstile;
};
struct turnstile {
	union {
		
		WAITQ_FLAGS(ts_waitq
		    , __ts_unused_bits: 7
		    , ts_compact_id: CTSID_BITS);
		struct waitq          ts_waitq;              
	};
	union {
		struct turnstile_list ts_free_turnstiles;    
		SLIST_ENTRY(turnstile) ts_free_elm;          
	};
	struct priority_queue_sched_max ts_inheritor_queue;  
	struct priority_queue_entry_sched ts_inheritor_links;    
	SLIST_ENTRY(turnstile)        ts_htable_link;        
	uintptr_t                     ts_proprietor;         
	os_ref_atomic_t               ts_refcount;           
	_Atomic uint32_t              ts_type_gencount;      
	uint32_t                      ts_prim_count;         
	turnstile_update_flags_t      ts_inheritor_flags;    
	uint8_t                       ts_priority;           

};
struct waitq_link_list_entry {
	struct waitq_link_list_entry *next;
} waitq_link_list_t;
struct waitq {
	WAITQ_HDR(waitq, waitq_eventmask:_EVENT_MASK_BITS);
} __attribute__((aligned(WQ_OPAQUE_ALIGN)));
struct waitq_set {
	WAITQ_HDR(wqset, wqset_index:_EVENT_MASK_BITS);
	circle_queue_head_t wqset_preposts;
};
struct select_set {
	WAITQ_HDR(selset, selset_conflict:1);
	uint64_t selset_id;
};
struct workload_config {
	uint32_t   wc_thread_group_flags;
	uint32_t   wc_flags;
	uint32_t   wc_create_flags;
	uint8_t    wc_class_offset;
	wi_class_t wc_class;
} workload_config_t;
struct kern_work_interval_args {
	uint64_t work_interval_id;
	uint64_t start;
	uint64_t finish;
	uint64_t deadline;
	uint64_t next_start;
	uint32_t notify_flags;
	uint32_t create_flags;
	uint16_t urgency;
};
struct kern_work_interval_create_args {
	uint64_t        wica_id;          
	mach_port_name_t wica_port;        
	uint32_t        wica_create_flags;
};
struct kern_work_interval_workload_id_args {
	uint32_t        wlida_flags;            
	uint32_t        wlida_wicreate_flags;   
	char *          wlida_name;             
	uint64_t        wlida_syscall_mask[2];  
};
struct kalloc_result {
	void         *addr __sized_by(size);
	vm_size_t     size;
};
struct zone_view {
	zone_t          zv_zone;
	zone_stats_t    zv_stats;
	const char     *zv_name __unsafe_indexable;
	zone_view_t     zv_next;
};
struct zone_basic_stats {
	uint64_t        zbs_avail;
	uint64_t        zbs_alloc;
	uint64_t        zbs_free;
	uint64_t        zbs_cached;
	uint64_t        zbs_alloc_fail;
};
struct zstack {
	vm_offset_t     z_head;
	uint32_t        z_count;
} zstack_t;
struct zone_cache_ops {
	void         *(*zc_op_alloc)(zone_id_t, zalloc_flags_t);
	void         *(*zc_op_mark_valid)(zone_id_t, void *);
	void         *(*zc_op_mark_invalid)(zone_id_t, void *);
	void          (*zc_op_free)(zone_id_t, void *);
} *zone_cache_ops_t;
struct zone_create_startup_spec {
	zone_t                 *z_var;
	const char             *z_name __unsafe_indexable;
	vm_size_t               z_size;
	zone_create_flags_t     z_flags;
	zone_id_t               z_zid;
	void                  (^z_setup)(zone_t);
};
struct zone_view_startup_spec {
	zone_view_t         zv_view;
	union {
		zone_kheap_id_t zv_heapid;
		zone_t         *zv_zone;
	};
	vm_size_t           zv_size;
};
struct zone_packed_virtual_address {
	uint32_t packed_address;
} zone_pva_t;
struct zone_stats {
	uint64_t            zs_mem_allocated;
	uint64_t            zs_mem_freed;
	uint64_t            zs_alloc_fail;
	uint32_t            zs_alloc_rr;     
	uint32_t _Atomic    zs_alloc_not_early;
};
struct zone_depot {
	uint32_t            zd_full;
	uint32_t            zd_empty;
	zone_magazine_t     zd_head;
	zone_magazine_t    *zd_tail;
};
struct zone_size_params {
	uint32_t            z_align_magic;  
	uint32_t            z_elem_size;    
};
struct zone_expand {
	struct zone_expand *ze_next;
	thread_t            ze_thread;
	bool                ze_pg_wait;
	bool                ze_vm_priv;
	bool                ze_clear_priv;
};
struct zone {

	struct zone        *z_self;
	zone_stats_t        z_stats;
	const char         *z_name;
	struct zone_view   *z_views;
	struct zone_expand *z_expander;

	uint64_t            z_quo_magic;
	uint32_t            z_align_magic;
	uint16_t            z_elem_size;
	uint16_t            z_elem_offs;
	uint16_t            z_chunk_pages;
	uint16_t            z_chunk_elems;

	uint32_t 
	    z_destroyed        :1,  
	    z_async_refilling  :1,  
	    z_depot_cleanup    :1,  
	    z_expanding_wait   :1,  
	    z_exhausted_wait   :1,  
	    z_exhausts         :1,  

	    z_percpu           :1,  
	    z_smr              :1,  
	    z_permanent        :1,  
	    z_nocaching        :1,  
	    collectable        :1,  
	    no_callout         :1,
	    z_destructible     :1,  

	    _reserved          :6,

	    z_pgz_tracked      :1,  
	    z_pgz_use_guards   :1,  
	    z_kasan_fakestacks :1,
	    z_kasan_quarantine :1,  
	    z_tags_sizeclass   :6,  
	    z_uses_tags        :1,
	    z_log_on           :1,  
	    z_tbi_tag          :1;  

	uint8_t             z_cacheline1[0] __attribute__((aligned(64)));

	struct zone_cache  *__zpercpu OS_PTRAUTH_SIGNED_PTR("zone.z_pcpu_cache") z_pcpu_cache;
	struct zone_depot   z_recirc;

	hw_lck_ticket_t     z_recirc_lock;
	uint32_t            z_recirc_full_min;
	uint32_t            z_recirc_full_wma;
	union {
		uint32_t    z_recirc_empty_min;
		uint32_t    z_elems_free_min;
	};
	union {
		uint32_t    z_recirc_empty_wma;
		uint32_t    z_elems_free_wma;
	};
	uint32_t            z_recirc_cont_cur;
	uint32_t            z_recirc_cont_wma;

	uint16_t            z_depot_size;
	uint16_t            z_depot_limit;

	uint8_t             z_cacheline2[0] __attribute__((aligned(64)));


	hw_lck_ticket_t     z_lock;

	uint32_t            z_wired_max;    
	uint32_t            z_wired_hwm;    
	uint32_t            z_wired_cur;    
	uint32_t            z_wired_empty;  
	uint32_t            z_va_cur;       

	zone_pva_t          z_pageq_empty;  
	zone_pva_t          z_pageq_partial;
	zone_pva_t          z_pageq_full;   
	zone_pva_t          z_pageq_va;     

	uint32_t            z_elems_free;   
	uint32_t            z_elems_avail;  
	uint32_t            z_elems_rsv;
	uint32_t            z_array_size_class;

	struct zone        *z_kt_next;

	uint8_t             z_cacheline3[0] __attribute__((aligned(64)));


} __attribute__((aligned((64))));
struct zone_security_flags {
	uint32_t
	    z_submap_idx       :8,  
	    z_kheap_id         :3,  
	    z_kalloc_type      :1,  
	    z_lifo             :1,  
	    z_pgz_use_guards   :1,  
	    z_submap_from_end  :1,  
	    z_noencrypt        :1,  
	    z_tag              :1,  
	    z_unused           :15;
	zone_id_t           z_sig_eq;
} zone_security_flags_t;
struct kheap_info {
	zone_id_t               kh_zstart;
	kalloc_heap_t           kh_views;
	kalloc_type_var_view_t  kt_views;
};
struct kp_ucallstack {
	uint32_t kpuc_flags;
	uint32_t kpuc_nframes;
	uint32_t kpuc_async_index;
	uint32_t kpuc_async_nframes;
	uintptr_t kpuc_frames[MAX_UCALLSTACK_FRAMES];
};
struct kp_kcallstack {
	uint32_t kpkc_flags;
	uint32_t kpkc_nframes;
	union {
		uintptr_t kpkc_word_frames[MAX_KCALLSTACK_FRAMES];
		uint64_t kpkc_frames[MAX_KCALLSTACK_FRAMES] __kernel_ptr_semantics;
	};
	uint32_t kpkc_exclaves_offset;
};
struct kperf_context {
	int cur_pid;
	thread_t cur_thread;
	task_t cur_task;
	uintptr_t *starting_fp;

	unsigned int trigger_type;
	unsigned int trigger_id;
};
struct meminfo {
	uint64_t phys_footprint;
	uint64_t purgeable_volatile;
	uint64_t purgeable_volatile_compressed;
};
struct kperf_usample_min {
	struct kperf_thread_dispatch th_dispatch;
};
struct kperf_usample {
	struct kperf_usample_min *usample_min;
	struct kp_ucallstack ucallstack;
	struct kperf_thread_info th_info;
};
struct kperf_sample {
	struct kperf_thread_info       th_info;
	struct kperf_thread_scheduling th_scheduling;
	struct kperf_thread_snapshot   th_snapshot;

	struct kperf_task_snapshot tk_snapshot;

	struct kp_kcallstack kcallstack;
	struct meminfo     meminfo;

	struct kperf_usample usample;


};
struct kperf_task_snapshot {
	uint64_t kptksn_flags;
	uint64_t kptksn_user_time_in_terminated_threads;
	uint64_t kptksn_system_time_in_terminated_threads;
	int kptksn_suspend_count;
	int kptksn_pageins;
};
struct kperf_thread_info {
	uint64_t kpthi_pid;
	uint64_t kpthi_tid;
	uint64_t kpthi_dq_addr;
	uint64_t kpthi_runmode;
};
struct kperf_thread_scheduling {
	uint64_t kpthsc_user_time;
	uint64_t kpthsc_system_time;
	uint64_t kpthsc_runnable_time;
	unsigned int kpthsc_state;
	uint16_t kpthsc_base_priority;
	uint16_t kpthsc_sched_priority;
	unsigned int kpthsc_effective_qos :3,
	    kpthsc_requested_qos :3,
	    kpthsc_requested_qos_override :3,
	    kpthsc_requested_qos_promote :3,
	    kpthsc_requested_qos_kevent_override :3,
	    kpthsc_requested_qos_sync_ipc_override :3,             
	    kpthsc_effective_latency_qos :3;
};
struct kperf_thread_snapshot {
	uint64_t kpthsn_last_made_runnable_time;
	int16_t kpthsn_suspend_count;
	uint8_t kpthsn_io_tier;
	uint8_t kpthsn_flags;
};
struct kperf_thread_dispatch {
	uint64_t kpthdi_dq_serialno;
	char kpthdi_dq_label[64];
};
struct _quad_ {
	unsigned int    val[2];         
} quad;
struct mach_timespec {
	unsigned int    tv_sec;                 
	clock_res_t     tv_nsec;                
};
struct coalition_resource_usage {
	uint64_t tasks_started;
	uint64_t tasks_exited;
	uint64_t time_nonempty;
	uint64_t cpu_time; 
	uint64_t interrupt_wakeups;
	uint64_t platform_idle_wakeups;
	uint64_t bytesread;
	uint64_t byteswritten;
	uint64_t gpu_time; 
	uint64_t cpu_time_billed_to_me; 
	uint64_t cpu_time_billed_to_others; 
	uint64_t energy; 
	uint64_t logical_immediate_writes;
	uint64_t logical_deferred_writes;
	uint64_t logical_invalidated_writes;
	uint64_t logical_metadata_writes;
	uint64_t logical_immediate_writes_to_external;
	uint64_t logical_deferred_writes_to_external;
	uint64_t logical_invalidated_writes_to_external;
	uint64_t logical_metadata_writes_to_external;
	uint64_t energy_billed_to_me; 
	uint64_t energy_billed_to_others; 
	uint64_t cpu_ptime; 
	uint64_t cpu_time_eqos_len;     
	uint64_t cpu_time_eqos[COALITION_NUM_THREAD_QOS_TYPES];
	uint64_t cpu_instructions;
	uint64_t cpu_cycles;
	uint64_t fs_metadata_writes;
	uint64_t pm_writes;
	uint64_t cpu_pinstructions;
	uint64_t cpu_pcycles;
	uint64_t conclave_mem;
	uint64_t ane_mach_time; 
	uint64_t ane_energy_nj; 
	uint64_t phys_footprint;        
	uint64_t gpu_energy_nj; 
	uint64_t gpu_energy_nj_billed_to_me; 
	uint64_t gpu_energy_nj_billed_to_others; 
};
struct coalinfo_debuginfo {
	uint64_t thread_group_id;
	uint32_t thread_group_recommendation;
	uint32_t thread_group_flags;
	uint32_t focal_task_count;
	uint32_t nonfocal_task_count;
	uint32_t game_task_count;
	uint32_t carplay_task_count;
};
struct procinfo_coalinfo {
	uint64_t coalition_id;
	uint32_t coalition_type;
	uint32_t coalition_tasks;
};
struct coalition_pend_token {
	uint32_t        cpt_update_timers      :1,
	    cpt_update_j_coal_tasks :1;
} *coalition_pend_token_t;
struct list_xattrs_result {
	uint64_t finderInfoOffset; 
	uint64_t resourceForkOffset; 
	uint64_t resourceForkLength; 
	uint64_t numOfXattrs;

	uint64_t dataLength;
	uint64_t namesLength;
	uint64_t rangesLength;
	uint8_t  data[LISTXATTR_RESULT_MAX_SIZE];
} listxattrs_result_t;
struct dyld_kernel_image_info {
	uuid_t uuid;
	fsobj_id_t fsobjid;
	fsid_t fsid;
	uint64_t load_addr;
};
struct dyld_kernel_process_info {
	struct dyld_kernel_image_info cache_image_info;
	uint64_t timestamp;         
	uint32_t imageCount;        
	uint32_t initialImageCount; 
	uint8_t dyldState;          
	boolean_t no_cache;         
	boolean_t private_cache;    
};
struct mwl_region {
	int                  mwlr_fd;      
	vm_prot_t            mwlr_protections;
	uint64_t             mwlr_file_offset;
	mach_vm_address_t    mwlr_address __kernel_data_semantics; 
	mach_vm_size_t       mwlr_size;    
};
struct mwl_info_hdr {
	uint32_t        mwli_version;            
	uint16_t        mwli_page_size;          
	uint16_t        mwli_pointer_format;     
	uint32_t        mwli_binds_offset;       
	uint32_t        mwli_binds_count;        
	uint32_t        mwli_chains_offset;      
	uint32_t        mwli_chains_size;        
	uint64_t        mwli_slide;              
	uint64_t        mwli_image_address;      
};
struct events_info {
	integer_t       faults;         
	integer_t       zero_fills;     
	integer_t       reactivations;  
	integer_t       pageins;        
	integer_t       cow_faults;     
	integer_t       messages_sent;  
	integer_t       messages_received; 
};
struct {
	void *ipcb;
	unsigned long scid;
	uint64_t usecnt;
} exclaves_ctx_t;
struct exclaves_resource_user {
	char                  r_name[MAXCONCLAVENAME];
	uint64_t              r_type;
	exclaves_id_t         r_id;
	mach_port_name_t      r_port;
} exclaves_resouce_user_t;
struct __Exclaves_L4_Packed {
	Exclaves_L4_Word_t mr[Exclaves_L4_IpcBuffer_Mrs];
	Exclaves_L4_Word_t scr[Exclaves_L4_IpcBuffer_Crs];
	Exclaves_L4_Word_t dcr[Exclaves_L4_IpcBuffer_Crs];
} Exclaves_L4_IpcBuffer_t;
struct host_basic_info_old {
	integer_t       max_cpus;       
	uint32_t        avail_cpus;     
	natural_t       memory_size;    
	cpu_type_t      cpu_type;       
	cpu_subtype_t   cpu_subtype;    
};
struct host_can_has_debugger_info {
	boolean_t       can_has_debugger;
};
struct host_basic_info {
	integer_t               max_cpus;               
	integer_t               avail_cpus;             
	natural_t               memory_size;            
	cpu_type_t              cpu_type;               
	cpu_subtype_t           cpu_subtype;            
	cpu_threadtype_t        cpu_threadtype;         
	integer_t               physical_cpu;           
	integer_t               physical_cpu_max;       
	integer_t               logical_cpu;            
	integer_t               logical_cpu_max;        
	uint64_t                max_mem;                
};
struct host_sched_info {
	integer_t       min_timeout;    
	integer_t       min_quantum;    
};
struct kernel_resource_sizes {
	natural_t       task;
	natural_t       thread;
	natural_t       port;
	natural_t       memory_region;
	natural_t       memory_object;
};
struct host_priority_info {
	integer_t       kernel_priority;
	integer_t       system_priority;
	integer_t       server_priority;
	integer_t       user_priority;
	integer_t       depress_priority;
	integer_t       idle_priority;
	integer_t       minimum_priority;
	integer_t       maximum_priority;
};
struct vm_compressor_q_lens {
	uint32_t qcc_segments_available;
	uint32_t qcc_segment_count;
	uint32_t qcc_age_count;
	uint32_t qcc_early_swappedin_count, qcc_regular_swappedin_count, qcc_late_swappedin_count;
	uint32_t qcc_early_swapout_count, qcc_regular_swapout_count, qcc_late_swapout_count;
	uint32_t qcc_swapio_count;
	uint32_t qcc_swappedout_count;
	uint32_t qcc_swappedout_sparse_count;
	uint32_t qcc_major_count;
	uint32_t qcc_filling_count;
	uint32_t qcc_empty_count;
	uint32_t qcc_bad_count;
	uint32_t qcc_minor_count;
};
struct host_load_info {
	integer_t       avenrun[3];     
	integer_t       mach_factor[3]; 
};
struct host_cpu_load_info {             
	natural_t       cpu_ticks[CPU_STATE_MAX]; 
};
struct host_preferred_user_arch {
	cpu_type_t      cpu_type;       
	cpu_subtype_t   cpu_subtype;    
};
struct _processor_statistics_np  {
	int32_t                 ps_cpuid;

	uint32_t                ps_csw_count;
	uint32_t                ps_preempt_count;
	uint32_t                ps_preempted_rt_count;
	uint32_t                ps_preempted_by_rt_count;

	uint32_t                ps_rt_sched_count;

	uint32_t                ps_interrupt_count;
	uint32_t                ps_ipi_count;
	uint32_t                ps_timer_pop_count;

	uint64_t                ps_runq_count_sum __attribute((aligned(8)));

	uint32_t                ps_idle_transitions;
	uint32_t                ps_quantum_timer_expirations;
};
struct host_debug_info_internal {
	uint64_t config_bank:1,   
	    config_atm:1,
	    config_csr:1,
	    config_coalitions:1,
	    config_unused:60;
};
struct kmod_reference {
	struct kmod_reference * next;
	struct kmod_info      * info;
} kmod_reference_t;
struct kmod_info {
	struct kmod_info  * next;
	int32_t             info_version;       
	uint32_t            id;
	char                name[KMOD_MAX_NAME];
	char                version[KMOD_MAX_NAME];
	int32_t             reference_count;    
	kmod_reference_t  * reference_list;     
	vm_address_t        address;            
	vm_size_t           size;               
	vm_size_t           hdr_size;           
	kmod_start_func_t * start;
	kmod_stop_func_t  * stop;
} kmod_info_t;
struct kmod_info_32_v1 {
	uint32_t            next_addr;
	int32_t             info_version;
	uint32_t            id;
	uint8_t             name[KMOD_MAX_NAME];
	uint8_t             version[KMOD_MAX_NAME];
	int32_t             reference_count;
	uint32_t            reference_list_addr;
	uint32_t            address;
	uint32_t            size;
	uint32_t            hdr_size;
	uint32_t            start_addr;
	uint32_t            stop_addr;
} kmod_info_32_v1_t;
struct kmod_info_64_v1 {
	uint64_t            next_addr;
	int32_t             info_version;
	uint32_t            id;
	uint8_t             name[KMOD_MAX_NAME];
	uint8_t             version[KMOD_MAX_NAME];
	int32_t             reference_count;
	uint64_t            reference_list_addr;
	uint64_t            address;
	uint64_t            size;
	uint64_t            hdr_size;
	uint64_t            start_addr;
	uint64_t            stop_addr;
} kmod_info_64_v1_t;
struct machine_info {
	integer_t       major_version;          
	integer_t       minor_version;          
	integer_t       max_cpus;                       
	uint32_t        memory_size;            
	uint64_t        max_mem;                        
	uint32_t        physical_cpu;           
	integer_t       physical_cpu_max;       
	uint32_t        logical_cpu;            
	integer_t       logical_cpu_max;        
};
struct mach_timebase_info {
	uint32_t        numer;
	uint32_t        denom;
};
struct mach_voucher_attr_recipe_data {
	mach_voucher_attr_key_t                 key;
	mach_voucher_attr_recipe_command_t      command;
	mach_voucher_name_t                     previous_voucher;
	mach_voucher_attr_content_size_t        content_size;
	uint8_t                                 content[];
} mach_voucher_attr_recipe_data_t;
struct memory_object {
	mo_ipc_object_bits_t                    mo_ikot; 
	os_ref_atomic_t                         mo_ref;
	const struct memory_object_pager_ops    *mo_pager_ops;
	memory_object_control_t                 mo_control;
} *memory_object_t;
struct memory_object_pager_ops {
	void (*memory_object_reference)(
		memory_object_t mem_obj);
	void (*memory_object_deallocate)(
		memory_object_t mem_obj);
	kern_return_t (*memory_object_init)(
		memory_object_t mem_obj,
		memory_object_control_t mem_control,
		memory_object_cluster_size_t size);
	kern_return_t (*memory_object_terminate)(
		memory_object_t mem_obj);
	kern_return_t (*memory_object_data_request)(
		memory_object_t mem_obj,
		memory_object_offset_t offset,
		memory_object_cluster_size_t length,
		vm_prot_t desired_access,
		memory_object_fault_info_t fault_info);
	kern_return_t (*memory_object_data_return)(
		memory_object_t mem_obj,
		memory_object_offset_t offset,
		memory_object_cluster_size_t size,
		memory_object_offset_t *resid_offset,
		int *io_error,
		boolean_t dirty,
		boolean_t kernel_copy,
		int upl_flags);
	kern_return_t (*memory_object_data_initialize)(
		memory_object_t mem_obj,
		memory_object_offset_t offset,
		memory_object_cluster_size_t size);
	void *__obsolete_memory_object_data_unlock;
	void *__obsolete_memory_object_synchronize;
	kern_return_t (*memory_object_map)(
		memory_object_t mem_obj,
		vm_prot_t prot);
	kern_return_t (*memory_object_last_unmap)(
		memory_object_t mem_obj);
	void *__obsolete_memory_object_data_reclaim;
	boolean_t (*memory_object_backing_object)(
		memory_object_t mem_obj,
		memory_object_offset_t mem_obj_offset,
		vm_object_t *backing_object,
		vm_object_offset_t *backing_offset);
	const char *memory_object_pager_name;
} * memory_object_pager_ops_t;
struct old_memory_object_behave_info {
	memory_object_copy_strategy_t   copy_strategy;
	boolean_t                       temporary;
	boolean_t                       invalidate;
};
struct old_memory_object_attr_info {                    
	boolean_t                       object_ready;
	boolean_t                       may_cache;
	memory_object_copy_strategy_t   copy_strategy;
};
struct memory_object_perf_info {
	memory_object_cluster_size_t    cluster_size;
	boolean_t                       may_cache;
};
struct memory_object_attr_info {
	memory_object_copy_strategy_t   copy_strategy;
	memory_object_cluster_size_t    cluster_size;
	boolean_t                       may_cache_object;
	boolean_t                       temporary;
};
struct memory_object_behave_info {
	memory_object_copy_strategy_t   copy_strategy;
	boolean_t                       temporary;
	boolean_t                       invalidate;
	boolean_t                       silent_overwrite;
	boolean_t                       advisory_pageout;
};
struct upl_page_info {
	ppnum_t         phys_addr;      
	unsigned int
	    free_when_done:1,    
	    absent:1,           
	    dirty:1,            
	    precious:1,         
	    device:1,           
	    speculative:1,      
	cs_validated:VMP_CS_BITS,     
	    cs_tainted:VMP_CS_BITS,   
	    cs_nx:VMP_CS_BITS,        

	    needed:1,           
	    mark:1,             
	reserved: 12,
	:0;                     
};
struct {
	natural_t                     pad1;
	mach_msg_size_t               pad2;
	unsigned int                  pad3 : 24;
	mach_msg_descriptor_type_t    type : 8;
} mach_msg_type_descriptor_t;
struct {
	union {
		mach_port_t __ipc_desc_sign("port") name;
		mach_port_t           kext_name;
		mach_port_t           u_name;
	};
	unsigned int                  pad2 : 16;
	mach_msg_type_name_t          disposition : 8;
	mach_msg_descriptor_type_t    type : 8;
	uint32_t                      pad_end;
} mach_msg_port_descriptor_t;
struct {
	mach_port_name_t              name;
	mach_msg_size_t               pad1;
	uint32_t                      pad2 : 16;
	mach_msg_type_name_t          disposition : 8;
	mach_msg_descriptor_type_t    type : 8;
} mach_msg_user_port_descriptor_t;
struct {
	uint32_t                      address;
	mach_msg_size_t               size;
	boolean_t                     deallocate: 8;
	mach_msg_copy_options_t       copy: 8;
	unsigned int                  pad1: 8;
	mach_msg_descriptor_type_t    type: 8;
} mach_msg_ool_descriptor32_t;
struct {
	uint64_t                      address;
	boolean_t                     deallocate: 8;
	mach_msg_copy_options_t       copy: 8;
	unsigned int                  pad1: 8;
	mach_msg_descriptor_type_t    type: 8;
	mach_msg_size_t               size;
} mach_msg_ool_descriptor64_t;
struct {
	union {
		void *__ipc_desc_sign("address") address;
		void                 *kext_address;
		user_addr_t           u_address;
	};
	boolean_t                     deallocate: 8;
	mach_msg_copy_options_t       copy: 8;
	unsigned int                  pad1: 8;
	mach_msg_descriptor_type_t    type: 8;
	mach_msg_size_t               size;
} mach_msg_ool_descriptor_t;
struct {
	uint32_t                      address;
	mach_msg_size_t               count;
	boolean_t                     deallocate: 8;
	mach_msg_copy_options_t       copy: 8;
	mach_msg_type_name_t          disposition : 8;
	mach_msg_descriptor_type_t    type : 8;
} mach_msg_ool_ports_descriptor32_t;
struct {
	uint64_t                      address;
	boolean_t                     deallocate: 8;
	mach_msg_copy_options_t       copy: 8;
	mach_msg_type_name_t          disposition : 8;
	mach_msg_descriptor_type_t    type : 8;
	mach_msg_size_t               count;
} mach_msg_ool_ports_descriptor64_t;
struct {
	union {
		void *__ipc_desc_sign("port_array") address;
		void                 *kext_address;
		user_addr_t           u_address;
	};
	boolean_t                     deallocate: 8;
	mach_msg_copy_options_t       copy: 8;
	mach_msg_type_name_t          disposition : 8;
	mach_msg_descriptor_type_t    type : 8;
	mach_msg_size_t               count;
} mach_msg_ool_ports_descriptor_t;
struct {
	uint32_t                      context;
	mach_port_name_t              name;
	mach_msg_guard_flags_t        flags : 16;
	mach_msg_type_name_t          disposition : 8;
	mach_msg_descriptor_type_t    type : 8;
} mach_msg_guarded_port_descriptor32_t;
struct {
	uint64_t                      context;
	mach_msg_guard_flags_t        flags : 16;
	mach_msg_type_name_t          disposition : 8;
	mach_msg_descriptor_type_t    type : 8;
	mach_port_name_t              name;
} mach_msg_guarded_port_descriptor64_t;
struct {
	union {
		mach_port_t __ipc_desc_sign("guarded_port") name;
		mach_port_t           kext_name;
		mach_port_context_t   u_context;
	};
	mach_msg_guard_flags_t        flags : 16;
	mach_msg_type_name_t          disposition : 8;
	mach_msg_descriptor_type_t    type : 8;
	union {
		uint32_t              pad_end;
		mach_port_name_t      u_name;
	};
} mach_msg_guarded_port_descriptor_t;
struct {
	mach_msg_size_t msgh_descriptor_count;
} mach_msg_body_t;
struct {
	mach_msg_bits_t               msgh_bits;
	mach_msg_size_t               msgh_size;
	mach_port_t                   msgh_remote_port;
	mach_port_t                   msgh_local_port;
	mach_port_name_t              msgh_voucher_port;
	mach_msg_id_t                 msgh_id;
} mach_msg_header_t;
struct {
	mach_vm_address_t               msgv_data;
	mach_vm_address_t               msgv_rcv_addr;
	mach_msg_size_t                 msgv_send_size;
	mach_msg_size_t                 msgv_rcv_size;
} mach_msg_vector_t;
struct {
	mach_msg_size_t                 msgdh_size;
	uint32_t                        msgdh_reserved; 
} mach_msg_aux_header_t;
struct {
	mach_msg_header_t             header;
	mach_msg_body_t               body;
} mach_msg_base_t;
struct {
	mach_msg_bits_t               msgh_bits;
	mach_msg_size_t               msgh_size;
	mach_port_name_t              msgh_remote_port;
	mach_port_name_t              msgh_local_port;
	mach_port_name_t              msgh_voucher_port;
	mach_msg_id_t                 msgh_id;
} mach_msg_user_header_t;
struct {
	mach_msg_user_header_t        header;
	mach_msg_body_t               body;
} mach_msg_user_base_t;
struct {
	mach_msg_header_t             msgb_header;
	mach_msg_size_t               msgb_dsc_count;
	mach_msg_kdescriptor_t        msgb_dsc_array[];
} mach_msg_kbase_t;
struct {
	mach_msg_trailer_type_t       msgh_trailer_type;
	mach_msg_trailer_size_t       msgh_trailer_size;
} mach_msg_trailer_t;
struct {
	mach_msg_trailer_type_t       msgh_trailer_type;
	mach_msg_trailer_size_t       msgh_trailer_size;
	mach_port_seqno_t             msgh_seqno;
} mach_msg_seqno_trailer_t;
struct {
	unsigned int                  val[2];
} security_token_t;
struct {
	mach_msg_trailer_type_t       msgh_trailer_type;
	mach_msg_trailer_size_t       msgh_trailer_size;
	mach_port_seqno_t             msgh_seqno;
	security_token_t              msgh_sender;
} mach_msg_security_trailer_t;
struct {
	unsigned int                  val[8];
} audit_token_t;
struct {
	mach_msg_trailer_type_t       msgh_trailer_type;
	mach_msg_trailer_size_t       msgh_trailer_size;
	mach_port_seqno_t             msgh_seqno;
	security_token_t              msgh_sender;
	audit_token_t                 msgh_audit;
} mach_msg_audit_trailer_t;
struct {
	mach_msg_trailer_type_t       msgh_trailer_type;
	mach_msg_trailer_size_t       msgh_trailer_size;
	mach_port_seqno_t             msgh_seqno;
	security_token_t              msgh_sender;
	audit_token_t                 msgh_audit;
	mach_port_context_t           msgh_context;
} mach_msg_context_trailer_t;
struct {
	mach_msg_trailer_type_t       msgh_trailer_type;
	mach_msg_trailer_size_t       msgh_trailer_size;
	mach_port_seqno_t             msgh_seqno;
	security_token_t              msgh_sender;
	audit_token_t                 msgh_audit;
	mach_port_context32_t         msgh_context;
} mach_msg_context_trailer32_t;
struct {
	mach_msg_trailer_type_t       msgh_trailer_type;
	mach_msg_trailer_size_t       msgh_trailer_size;
	mach_port_seqno_t             msgh_seqno;
	security_token_t              msgh_sender;
	audit_token_t                 msgh_audit;
	mach_port_context64_t         msgh_context;
} mach_msg_context_trailer64_t;
struct {
	mach_port_name_t sender;
} msg_labels_t;
struct {
	mach_msg_trailer_type_t       msgh_trailer_type;
	mach_msg_trailer_size_t       msgh_trailer_size;
	mach_port_seqno_t             msgh_seqno;
	security_token_t              msgh_sender;
	audit_token_t                 msgh_audit;
	mach_port_context_t           msgh_context;
	mach_msg_filter_id            msgh_ad;
	msg_labels_t                  msgh_labels;
} mach_msg_mac_trailer_t;
struct {
	mach_msg_trailer_type_t       msgh_trailer_type;
	mach_msg_trailer_size_t       msgh_trailer_size;
	mach_port_seqno_t             msgh_seqno;
	security_token_t              msgh_sender;
	audit_token_t                 msgh_audit;
	mach_port_context32_t         msgh_context;
	mach_msg_filter_id            msgh_ad;
	msg_labels_t                  msgh_labels;
} mach_msg_mac_trailer32_t;
struct {
	mach_msg_trailer_type_t       msgh_trailer_type;
	mach_msg_trailer_size_t       msgh_trailer_size;
	mach_port_seqno_t             msgh_seqno;
	security_token_t              msgh_sender;
	audit_token_t                 msgh_audit;
	mach_port_context64_t         msgh_context;
	mach_msg_filter_id            msgh_ad;
	msg_labels_t                  msgh_labels;
} mach_msg_mac_trailer64_t;
struct {
	mach_msg_header_t     header;
} mach_msg_empty_send_t;
struct {
	mach_msg_header_t     header;
	mach_msg_trailer_t    trailer;
} mach_msg_empty_rcv_t;
struct routine_descriptor {
	mig_impl_routine_t      impl_routine;   
	mig_stub_routine_t      stub_routine;   
	unsigned int            argc;                   
	unsigned int            descr_count;    
	routine_arg_descriptor_t
	    arg_descr;                                                  
	unsigned int            max_reply_msg;  
};
struct mig_subsystem {
	mig_server_routine_t server;            
	mach_msg_id_t            start;                 
	mach_msg_id_t            end;                   
	mach_msg_size_t          maxsize;               
	vm_address_t             reserved;              
	mig_routine_descriptor
	    routine[1];                                         
} *mig_subsystem_t;
struct kern_routine_descriptor {
	mig_impl_routine_t      impl_routine;      
	mig_stub_kern_routine_t kstub_routine;     
	unsigned int            argc;              
	unsigned int            descr_count;       
	unsigned int            reply_descr_count; 
	unsigned int            max_reply_msg;     
};
struct mig_kern_subsystem {
	mig_kern_server_routine_t     kserver;     
	mach_msg_id_t            start;            
	mach_msg_id_t            end;              
	mach_msg_size_t          maxsize;          
	vm_address_t             reserved;         
	mig_kern_routine_descriptor
	    kroutine[1];                           
} *mig_kern_subsystem_t;
struct mig_symtab {
	char                            *ms_routine_name;
	int                                     ms_routine_number;
	void                            (*ms_routine)(void);    
} mig_symtab_t;
struct {
	mach_msg_header_t       Head;
	NDR_record_t            NDR;
	kern_return_t           RetCode;
} mig_reply_error_t;
struct mk_timer_expire_msg {
	mach_msg_header_t       header;
	uint64_t                unused[3];
} mk_timer_expire_msg_t;
struct {
	unsigned char       mig_vers;
	unsigned char       if_vers;
	unsigned char       reserved1;
	unsigned char       mig_encoding;
	unsigned char       int_rep;
	unsigned char       char_rep;
	unsigned char       float_rep;
	unsigned char       reserved2;
} NDR_record_t;
struct {
	mach_msg_header_t   not_header;
	NDR_record_t        NDR;
	mach_port_name_t not_port;
	mach_msg_format_0_trailer_t trailer;
} mach_port_deleted_notification_t;
struct {
	mach_msg_header_t   not_header;
	NDR_record_t        NDR;
	mach_port_name_t not_port;
	mach_msg_format_0_trailer_t trailer;
} mach_send_possible_notification_t;
struct {
	mach_msg_header_t   not_header;
	mach_msg_body_t     not_body;
	mach_msg_port_descriptor_t not_port;
	mach_msg_format_0_trailer_t trailer;
} mach_port_destroyed_notification_t;
struct {
	mach_msg_header_t   not_header;
	NDR_record_t        NDR;
	mach_msg_type_number_t not_count;
	mach_msg_format_0_trailer_t trailer;
} mach_no_senders_notification_t;
struct {
	mach_msg_header_t   not_header;
	mach_msg_format_0_trailer_t trailer;
} mach_send_once_notification_t;
struct {
	mach_msg_header_t   not_header;
	NDR_record_t        NDR;
	mach_port_name_t not_port;
	mach_msg_format_0_trailer_t trailer;
} mach_dead_name_notification_t;
struct policy_timeshare_base {
	integer_t               base_priority;
};
struct policy_timeshare_limit {
	integer_t               max_priority;
};
struct policy_timeshare_info {
	integer_t               max_priority;
	integer_t               base_priority;
	integer_t               cur_priority;
	boolean_t               depressed;
	integer_t               depress_priority;
};
struct policy_rr_base {
	integer_t               base_priority;
	integer_t               quantum;
};
struct policy_rr_limit {
	integer_t               max_priority;
};
struct policy_rr_info {
	integer_t               max_priority;
	integer_t               base_priority;
	integer_t               quantum;
	boolean_t               depressed;
	integer_t               depress_priority;
};
struct policy_fifo_base {
	integer_t               base_priority;
};
struct policy_fifo_limit {
	integer_t               max_priority;
};
struct policy_fifo_info {
	integer_t               max_priority;
	integer_t               base_priority;
	boolean_t               depressed;
	integer_t               depress_priority;
};
struct policy_bases {
	policy_timeshare_base_data_t    ts;
	policy_rr_base_data_t           rr;
	policy_fifo_base_data_t         fifo;
};
struct policy_limits {
	policy_timeshare_limit_data_t   ts;
	policy_rr_limit_data_t          rr;
	policy_fifo_limit_data_t        fifo;
};
struct policy_infos {
	policy_timeshare_info_data_t    ts;
	policy_rr_info_data_t           rr;
	policy_fifo_info_data_t         fifo;
};
struct {
	mach_port_t __mach_port_array_auth port;
} mach_port_ool_t;
struct mach_port_status {
	mach_port_rights_t      mps_pset;       
	mach_port_seqno_t       mps_seqno;      
	mach_port_mscount_t     mps_mscount;    
	mach_port_msgcount_t    mps_qlimit;     
	mach_port_msgcount_t    mps_msgcount;   
	mach_port_rights_t      mps_sorights;   
	boolean_t               mps_srights;    
	boolean_t               mps_pdrequest;  
	boolean_t               mps_nsrequest;  
	natural_t               mps_flags;              
} mach_port_status_t;
struct mach_port_limits {
	mach_port_msgcount_t    mpl_qlimit;     
} mach_port_limits_t;
struct mach_port_info_ext {
	mach_port_status_t      mpie_status;
	mach_port_msgcount_t    mpie_boost_cnt;
	uint32_t                reserved[6];
} mach_port_info_ext_t;
struct mach_port_guard_info {
	uint64_t    mpgi_guard;     
} mach_port_guard_info_t;
struct mach_port_qos {
	unsigned int            name:1;         
	unsigned int            prealloc:1;     
	boolean_t               pad1:30;
	natural_t               len;
} mach_port_qos_t;
struct mach_service_port_info {
	char                    mspi_string_name[MACH_SERVICE_PORT_INFO_STRING_NAME_MAX_BUF_LEN]; 
	uint8_t                 mspi_domain_type;          
} mach_service_port_info_data_t;
struct mach_port_options {
	uint32_t                flags;          
	mach_port_limits_t      mpl;            
	union {
		uint64_t                   reserved[2];           
		mach_port_name_t           work_interval_port;    
		uint32_t                   service_port_info32;   
		uint64_t                   service_port_info64;   
		mach_port_name_t           service_port_name;     
	};
}mach_port_options_t;
struct processor_basic_info {
	cpu_type_t      cpu_type;       
	cpu_subtype_t   cpu_subtype;    
	boolean_t       running;        
	int             slot_num;       
	union {
		boolean_t       is_master;  
		boolean_t       is_main;    
	};
};
struct processor_cpu_load_info {             
	unsigned int    cpu_ticks[CPU_STATE_MAX]; 
};
struct processor_set_basic_info {
	int             processor_count;        
	int             default_policy;         
};
struct processor_set_load_info {
	int             task_count;             
	int             thread_count;           
	integer_t       load_average;           
	integer_t       mach_factor;            
};
struct rpc_routine_arg_descriptor {
	routine_arg_type        type;      
	routine_arg_size        size;      
	routine_arg_size        count;     
	routine_arg_offset      offset;    
};
struct rpc_routine_descriptor {
	mig_impl_routine_t      impl_routine;   
	mig_stub_routine_t      stub_routine;   
	unsigned int            argc;           
	unsigned int            descr_count;    
	                                        
	rpc_routine_arg_descriptor_t
	    arg_descr;                          
	                                        
	unsigned int            max_reply_msg;  
};
struct rpc_signature {
	struct rpc_routine_descriptor rd;
	struct rpc_routine_arg_descriptor rad[1];
};
struct rpc_subsystem {
	void            *reserved;      

	mach_msg_id_t   start;          
	mach_msg_id_t   end;            
	unsigned int    maxsize;        
	vm_address_t    base_addr;      

	struct rpc_routine_descriptor   
	    routine[1                   
	];

	struct rpc_routine_arg_descriptor
	    arg_descriptor[1               
	];                                 
};
struct shared_region_range_np {
	mach_vm_address_t       srr_address;
	mach_vm_size_t          srr_size;
};
struct shared_file_mapping_np {
	mach_vm_address_t       sfm_address;
	mach_vm_size_t          sfm_size;
	mach_vm_offset_t        sfm_file_offset;
	vm_prot_t               sfm_max_prot;
	vm_prot_t               sfm_init_prot;
};
struct shared_file_mapping_slide_np {
	mach_vm_address_t       sms_address __kernel_data_semantics;
	mach_vm_size_t          sms_size;
	mach_vm_offset_t        sms_file_offset __kernel_data_semantics;
	user_addr_t             sms_slide_size;
	user_addr_t             sms_slide_start;
	vm_prot_t               sms_max_prot;
	vm_prot_t               sms_init_prot;
} shared_file_mapping_slide_np_t;
struct {
	mach_vm_address_ut       sms_address_u;
	mach_vm_size_ut          sms_size_u;
	mach_vm_offset_ut        sms_file_offset_u;
	user_addr_ut             sms_slide_size_u;
	user_addr_ut             sms_slide_start_u;
	vm_prot_ut               sms_max_prot_u;
	vm_prot_ut               sms_init_prot_u;
});
struct shared_file_np {
	int                     sf_fd;             
	uint32_t                sf_mappings_count; 
	uint32_t                sf_slide;          
};
struct task_basic_info_32 {
	integer_t       suspend_count;  
	natural_t       virtual_size;   
	natural_t       resident_size;  
	time_value_t    user_time;      
	time_value_t    system_time;    
	policy_t        policy;         
};
struct task_basic_info_64 {
	integer_t       suspend_count;  
	natural_t       virtual_size;   
	natural_t       resident_size;  
	time_value_t    user_time;      
	time_value_t    system_time;    
	policy_t        policy;         
};
struct task_basic_info {
	integer_t       suspend_count;  
	vm_size_t       virtual_size;   
	vm_size_t       resident_size;  
	time_value_t    user_time;      
	time_value_t    system_time;    
	policy_t        policy;         
};
struct task_events_info {
	integer_t       faults;         
	integer_t       pageins;        
	integer_t       cow_faults;     
	integer_t       messages_sent;  
	integer_t       messages_received; 
	integer_t       syscalls_mach;  
	integer_t       syscalls_unix;  
	integer_t       csw;            
};
struct task_thread_times_info {
	time_value_t    user_time;      
	time_value_t    system_time;    
};
struct task_absolutetime_info {
	uint64_t                total_user;
	uint64_t                total_system;
	uint64_t                threads_user;   
	uint64_t                threads_system;
};
struct task_kernelmemory_info {
	uint64_t                total_palloc;   
	uint64_t                total_pfree;    
	uint64_t                total_salloc;   
	uint64_t                total_sfree;    
};
struct task_affinity_tag_info {
	integer_t               set_count;
	integer_t               min;
	integer_t               max;
	integer_t               task_count;
};
struct task_dyld_info {
	mach_vm_address_t       all_image_info_addr;
	mach_vm_size_t          all_image_info_size;
	integer_t               all_image_info_format;
};
struct task_basic_info_64_2 {
	integer_t       suspend_count;  
	mach_vm_size_t  virtual_size;   
	mach_vm_size_t  resident_size;  
	time_value_t    user_time;      
	time_value_t    system_time;    
	policy_t        policy;         
};
struct task_extmod_info {
	unsigned char   task_uuid[16];
	vm_extmod_statistics_data_t             extmod_statistics;
};
struct mach_task_basic_info {
	mach_vm_size_t  virtual_size;       
	mach_vm_size_t  resident_size;      
	mach_vm_size_t  resident_size_max;  
	time_value_t    user_time;          
	time_value_t    system_time;        
	policy_t        policy;             
	integer_t       suspend_count;      
};
struct task_power_info {
	uint64_t                total_user;
	uint64_t                total_system;
	uint64_t                task_interrupt_wakeups;
	uint64_t                task_platform_idle_wakeups;
	uint64_t                task_timer_wakeups_bin_1;
	uint64_t                task_timer_wakeups_bin_2;
};
struct task_vm_info {
	mach_vm_size_t  virtual_size;       
	integer_t       region_count;       
	integer_t       page_size;
	mach_vm_size_t  resident_size;      
	mach_vm_size_t  resident_size_peak; 

	mach_vm_size_t  device;
	mach_vm_size_t  device_peak;
	mach_vm_size_t  internal;
	mach_vm_size_t  internal_peak;
	mach_vm_size_t  external;
	mach_vm_size_t  external_peak;
	mach_vm_size_t  reusable;
	mach_vm_size_t  reusable_peak;
	mach_vm_size_t  purgeable_volatile_pmap;
	mach_vm_size_t  purgeable_volatile_resident;
	mach_vm_size_t  purgeable_volatile_virtual;
	mach_vm_size_t  compressed;
	mach_vm_size_t  compressed_peak;
	mach_vm_size_t  compressed_lifetime;

	mach_vm_size_t  phys_footprint;

	mach_vm_address_t       min_address;
	mach_vm_address_t       max_address;

	int64_t ledger_phys_footprint_peak;
	int64_t ledger_purgeable_nonvolatile;
	int64_t ledger_purgeable_novolatile_compressed;
	int64_t ledger_purgeable_volatile;
	int64_t ledger_purgeable_volatile_compressed;
	int64_t ledger_tag_network_nonvolatile;
	int64_t ledger_tag_network_nonvolatile_compressed;
	int64_t ledger_tag_network_volatile;
	int64_t ledger_tag_network_volatile_compressed;
	int64_t ledger_tag_media_footprint;
	int64_t ledger_tag_media_footprint_compressed;
	int64_t ledger_tag_media_nofootprint;
	int64_t ledger_tag_media_nofootprint_compressed;
	int64_t ledger_tag_graphics_footprint;
	int64_t ledger_tag_graphics_footprint_compressed;
	int64_t ledger_tag_graphics_nofootprint;
	int64_t ledger_tag_graphics_nofootprint_compressed;
	int64_t ledger_tag_neural_footprint;
	int64_t ledger_tag_neural_footprint_compressed;
	int64_t ledger_tag_neural_nofootprint;
	int64_t ledger_tag_neural_nofootprint_compressed;

	uint64_t limit_bytes_remaining;

	integer_t decompressions;

	int64_t ledger_swapins;

	int64_t ledger_tag_neural_nofootprint_total;
	int64_t ledger_tag_neural_nofootprint_peak;
};
struct task_trace_memory_info {
	uint64_t  user_memory_address;  
	uint64_t  buffer_size;                  
	uint64_t  mailbox_array_size;   
};
struct task_wait_state_info {
	uint64_t  total_wait_state_time;        
	uint64_t  total_wait_sfi_state_time;    
	uint32_t  _reserved[4];
};
struct {
	uint64_t                task_gpu_utilisation;
	uint64_t                task_gpu_stat_reserved0;
	uint64_t                task_gpu_stat_reserved1;
	uint64_t                task_gpu_stat_reserved2;
} gpu_energy_data;
struct task_power_info_v2 {
	task_power_info_data_t  cpu_energy;
	gpu_energy_data gpu_energy;
	uint64_t                task_energy;
	uint64_t                task_ptime;
	uint64_t                task_pset_switches;
};
struct pvm_account_info {
	uint64_t pvm_volatile_count; 
	uint64_t pvm_volatile_compressed_count; 
	uint64_t pvm_nonvolatile_count; 
	uint64_t pvm_nonvolatile_compressed_count; 
};
struct task_flags_info {
	uint32_t        flags;                          
};
struct task_debug_info_internal {
	integer_t suspend_count;
	uint64_t ipc_space_size;
};
struct task_suspend_stats_s {
	uint64_t tss_last_start; 
	uint64_t tss_last_end; 
	uint64_t tss_count; 
	uint64_t tss_duration; 
} *task_suspend_stats_t;
struct task_suspend_source_s {
	uint64_t tss_time; 
	uint64_t tss_tid; 
	int tss_pid; 
	char tss_procname[65]; 
	uint8_t tss_padding[3]; 
} *task_suspend_source_t;
struct task_inspect_basic_counts {
	uint64_t instructions;
	uint64_t cycles;
};
struct task_category_policy {
	task_role_t             role;
};
struct task_qos_policy {
	task_latency_qos_t task_latency_qos_tier;
	task_throughput_qos_t task_throughput_qos_tier;
};
struct task_requested_policy {
	uint64_t        trp_int_darwinbg        :1, 
	    trp_ext_darwinbg        :1,
	    trp_int_iotier          :2,             
	    trp_ext_iotier          :2,
	    trp_int_iopassive       :1,             
	    trp_ext_iopassive       :1,
	    trp_bg_iotier           :2,             
	    trp_terminated          :1,             
	    trp_base_latency_qos    :3,             
	    trp_base_through_qos    :3,             

	    trp_apptype             :3,             
	    trp_boosted             :1,             
	    trp_role                :5,             
	    trp_over_latency_qos    :3,             
	    trp_over_through_qos    :3,             
	    trp_sfi_managed         :1,             
	    trp_qos_clamp           :3,             

	    trp_sup_active          :1,             
	    trp_sup_lowpri_cpu      :1,             
	    trp_sup_timer           :3,             
	    trp_sup_disk            :1,             
	    trp_sup_throughput      :3,             
	    trp_sup_cpu             :1,             
	    trp_sup_bg_sockets      :1,             

	    trp_reserved            :17;
};
struct task_effective_policy {
	uint64_t        tep_darwinbg            :1, 
	    tep_lowpri_cpu          :1,             
	    tep_io_tier             :2,             
	    tep_io_passive          :1,             
	    tep_all_sockets_bg      :1,             
	    tep_new_sockets_bg      :1,             
	    tep_bg_iotier           :2,             
	    tep_terminated          :1,             
	    tep_qos_ui_is_urgent    :1,             
	    tep_latency_qos         :3,             
	    tep_through_qos         :3,             

	    tep_tal_engaged         :1,             
	    tep_watchers_bg         :1,             
	    tep_sup_active          :1,             
	    tep_role                :4,             
	    tep_suppressed_cpu      :1,             
	    tep_sfi_managed         :1,             
	    tep_live_donor          :1,             
	    tep_qos_clamp           :3,             
	    tep_qos_ceiling         :3,             
	    tep_adaptive_bg         :1,             
	    tep_coalition_bg        :1,             

	    tep_reserved            :29;
};
struct task_suppression_policy {
	integer_t active;
	integer_t lowpri_cpu; 
	integer_t timer_throttle;
	integer_t disk_throttle;
	integer_t cpu_limit;
	integer_t suspend;
	integer_t throughput_qos;
	integer_t suppressed_cpu; 
	integer_t background_sockets;
	integer_t reserved[7];
};
struct task_policy_state {
	uint64_t requested;
	uint64_t effective;
	uint64_t pending;
	uint32_t imp_assertcnt;
	uint32_t imp_externcnt;
	uint64_t flags;
	uint64_t imp_transitions;
	uint64_t tps_requested_policy;
	uint64_t tps_effective_policy;
};
struct thread_basic_info {
	time_value_t    user_time;      
	time_value_t    system_time;    
	integer_t       cpu_usage;      
	policy_t        policy;         
	integer_t       run_state;      
	integer_t       flags;          
	integer_t       suspend_count;  
	integer_t       sleep_time;     
};
struct thread_identifier_info {
	uint64_t        thread_id;      
	uint64_t        thread_handle;  
	uint64_t        dispatch_qaddr; 
};
struct thread_extended_info {           
	uint64_t                pth_user_time;          
	uint64_t                pth_system_time;        
	int32_t                 pth_cpu_usage;          
	int32_t                 pth_policy;                     
	int32_t                 pth_run_state;          
	int32_t                 pth_flags;              
	int32_t                 pth_sleep_time;         
	int32_t                 pth_curpri;                     
	int32_t                 pth_priority;           
	int32_t                 pth_maxpriority;        
	char                    pth_name[MAXTHREADNAMESIZE];    
};
struct thread_debug_info_internal {
	uint64_t page_creation_count;
};
struct io_stat_entry {
	uint64_t        count;
	uint64_t        size;
};
struct io_stat_info {
	struct io_stat_entry    disk_reads;
	struct io_stat_entry    io_priority[IO_NUM_PRIORITIES];
	struct io_stat_entry    paging;
	struct io_stat_entry    metadata;
	struct io_stat_entry    total_io;
};
struct thread_standard_policy {
	natural_t               no_data;
};
struct thread_extended_policy {
	boolean_t               timeshare;
};
struct thread_time_constraint_policy {
	uint32_t                period;
	uint32_t                computation;
	uint32_t                constraint;
	boolean_t               preemptible;
};
struct thread_precedence_policy {
	integer_t               importance;
};
struct thread_affinity_policy {
	integer_t       affinity_tag;
};
struct thread_background_policy {
	integer_t       priority;
};
struct thread_latency_qos_policy {
	thread_latency_qos_t thread_latency_qos_tier;
};
struct thread_throughput_qos_policy {
	thread_throughput_qos_t thread_throughput_qos_tier;
};
struct thread_policy_state {
	integer_t requested;
	integer_t effective;
	integer_t pending;
	integer_t flags;
	uint64_t thps_requested_policy;
	uint64_t thps_effective_policy;
	uint32_t thps_user_promotions;
	uint32_t thps_user_promotion_basepri;
	uint32_t thps_ipc_overrides;
	uint32_t reserved32;
	uint64_t reserved[2];
};
struct thread_qos_policy {
	integer_t qos_tier;
	integer_t tier_importance;
};
struct thread_time_constraint_with_priority_policy {
	uint32_t                period;
	uint32_t                computation;
	uint32_t                constraint;
	boolean_t               preemptible;
	uint32_t                priority;
};
struct thread_requested_qos_policy {
	integer_t  thrq_base_qos;
	integer_t  thrq_qos_relprio;
	integer_t  thrq_qos_override;
	integer_t  thrq_qos_promote;
	integer_t  thrq_qos_kevent_override;
	integer_t  thrq_qos_workq_override;
	integer_t  thrq_qos_wlsvc_override;
};
struct thread_requested_policy {
	uint64_t        thrp_int_darwinbg       :1,     
	    thrp_ext_darwinbg       :1,
	    thrp_int_iotier         :2,                 
	    thrp_ext_iotier         :2,
	    thrp_int_iopassive      :1,                 
	    thrp_ext_iopassive      :1,
	    thrp_latency_qos        :3,                 
	    thrp_through_qos        :3,                 

	    thrp_pidbind_bg         :1,                 
	    thrp_qos                :3,                 
	    thrp_qos_relprio        :4,                 
	    thrp_qos_override       :3,                 
	    thrp_qos_promote        :3,                 
	    thrp_qos_kevent_override:3,                 
	    thrp_terminated         :1,                 
	    thrp_qos_workq_override :3,                 
	    thrp_qos_wlsvc_override :3,                 
	    thrp_iotier_kevent_override :2,             
	    thrp_wi_driven          :1,                 

	    thrp_reserved           :23;
};
struct thread_effective_policy {
	uint64_t        thep_darwinbg           :1,     
	    thep_io_tier            :2,                 
	    thep_io_passive         :1,                 
	    thep_all_sockets_bg     :1,                 
	    thep_new_sockets_bg     :1,                 
	    thep_terminated         :1,                 
	    thep_qos_ui_is_urgent   :1,                 
	    thep_latency_qos        :3,                 
	    thep_through_qos        :3,                 

	    thep_qos                :3,                 
	    thep_qos_relprio        :4,                 
	    thep_qos_promote        :3,                 
	    thep_promote_above_task :1,                 
	    thep_wi_driven          :1,                 

	    thep_reserved           :38;
};
struct time_value {
	integer_t seconds;
	integer_t microseconds;
};
struct vm_packing_params {
	vm_offset_t vmpp_base;
	uint8_t     vmpp_bits;
	uint8_t     vmpp_shift;
	bool        vmpp_base_relative;
} vm_packing_params_t;
struct mach_vm_reclaim_indices_s {
	_Atomic mach_vm_reclaim_id_t head;
	_Atomic mach_vm_reclaim_id_t tail;
	_Atomic mach_vm_reclaim_id_t busy;
} *mach_vm_reclaim_indices_t;
struct mach_vm_reclaim_entry_s {
	mach_vm_address_t address;
	uint32_t size;
	mach_vm_reclaim_action_t behavior;
	uint8_t _unused[3];
} *mach_vm_reclaim_entry_t;
struct mach_vm_reclaim_ring_s {
	mach_vm_size_t va_in_buffer;
	mach_vm_size_t last_accounting_given_to_kernel;
	mach_vm_reclaim_count_t len;
	mach_vm_reclaim_count_t max_len;
	struct mach_vm_reclaim_indices_s indices;
	struct mach_vm_reclaim_entry_s entries[] __counted_by(len);
};
struct vm_region_basic_info_64 {
	vm_prot_t               protection;
	vm_prot_t               max_protection;
	vm_inherit_t            inheritance;
	boolean_t               shared;
	boolean_t               reserved;
	memory_object_offset_t  offset;
	vm_behavior_t           behavior;
	unsigned short          user_wired_count;
};
struct vm_region_basic_info {
	vm_prot_t               protection;
	vm_prot_t               max_protection;
	vm_inherit_t            inheritance;
	boolean_t               shared;
	boolean_t               reserved;
	uint32_t                offset; 
	vm_behavior_t           behavior;
	unsigned short          user_wired_count;
};
struct vm_region_extended_info__legacy {
	vm_prot_t               protection;
	unsigned int            user_tag;
	unsigned int            pages_resident;
	unsigned int            pages_shared_now_private;
	unsigned int            pages_swapped_out;
	unsigned int            pages_dirtied;
	unsigned int            ref_count;
	unsigned short          shadow_depth;
	unsigned char           external_pager;
	unsigned char           share_mode;
};
struct vm_region_extended_info {
	vm_prot_t               protection;
	unsigned int            user_tag;
	unsigned int            pages_resident;
	unsigned int            pages_shared_now_private;
	unsigned int            pages_swapped_out;
	unsigned int            pages_dirtied;
	unsigned int            ref_count;
	unsigned short          shadow_depth;
	unsigned char           external_pager;
	unsigned char           share_mode;
	unsigned int            pages_reusable;
};
struct vm_region_top_info {
	unsigned int            obj_id;
	unsigned int            ref_count;
	unsigned int            private_pages_resident;
	unsigned int            shared_pages_resident;
	unsigned char           share_mode;
};
struct vm_region_submap_info {
	vm_prot_t               protection;     
	vm_prot_t               max_protection; 
	vm_inherit_t            inheritance;
	uint32_t                offset;         
	unsigned int            user_tag;       
	unsigned int            pages_resident; 
	unsigned int            pages_shared_now_private; 
	unsigned int            pages_swapped_out; 
	unsigned int            pages_dirtied;   
	unsigned int            ref_count;       
	unsigned short          shadow_depth;   
	unsigned char           external_pager;  
	unsigned char           share_mode;     
	boolean_t               is_submap;      
	vm_behavior_t           behavior;       
	vm32_object_id_t        object_id;      
	unsigned short          user_wired_count;
};
struct vm_region_submap_info_64 {
	vm_prot_t               protection;     
	vm_prot_t               max_protection; 
	vm_inherit_t            inheritance;
	memory_object_offset_t  offset;         
	unsigned int            user_tag;       
	unsigned int            pages_resident; 
	unsigned int            pages_shared_now_private; 
	unsigned int            pages_swapped_out; 
	unsigned int            pages_dirtied;   
	unsigned int            ref_count;       
	unsigned short          shadow_depth;   
	unsigned char           external_pager;  
	unsigned char           share_mode;     
	boolean_t               is_submap;      
	vm_behavior_t           behavior;       
	vm32_object_id_t        object_id;      
	unsigned short          user_wired_count;
	unsigned int            pages_reusable;
	vm_object_id_t          object_id_full;
};
struct vm_region_submap_short_info_64 {
	vm_prot_t               protection;     
	vm_prot_t               max_protection; 
	vm_inherit_t            inheritance;
	memory_object_offset_t  offset;         
	unsigned int            user_tag;       
	unsigned int            ref_count;       
	unsigned short          shadow_depth;   
	unsigned char           external_pager;  
	unsigned char           share_mode;     
	boolean_t               is_submap;      
	vm_behavior_t           behavior;       
	vm32_object_id_t        object_id;      
	unsigned short          user_wired_count;
};
struct mach_vm_read_entry {
	mach_vm_address_t address;
	mach_vm_size_t size;
};
struct vm_read_entry {
	vm_address_t    address;
	vm_size_t       size;
};
struct vm_page_info_basic {
	int                     disposition;
	int                     ref_count;
	vm_object_id_t          object_id;
	memory_object_offset_t  offset;
	int                     depth;
	int                     __pad; 
};
struct vm_statistics {
	natural_t       free_count;             
	natural_t       active_count;           
	natural_t       inactive_count;         
	natural_t       wire_count;             
	natural_t       zero_fill_count;        
	natural_t       reactivations;          
	natural_t       pageins;                
	natural_t       pageouts;               
	natural_t       faults;                 
	natural_t       cow_faults;             
	natural_t       lookups;                
	natural_t       hits;                   

	natural_t       purgeable_count;        
	natural_t       purges;                 

	natural_t       speculative_count;      
};
struct vm_statistics64 {
	natural_t       free_count;             
	natural_t       active_count;           
	natural_t       inactive_count;         
	natural_t       wire_count;             
	uint64_t        zero_fill_count;        
	uint64_t        reactivations;          
	uint64_t        pageins;                
	uint64_t        pageouts;               
	uint64_t        faults;                 
	uint64_t        cow_faults;             
	uint64_t        lookups;                
	uint64_t        hits;                   
	uint64_t        purges;                 
	natural_t       purgeable_count;        
	natural_t       speculative_count;      

	uint64_t        decompressions;         
	uint64_t        compressions;           
	uint64_t        swapins;                
	uint64_t        swapouts;               
	natural_t       compressor_page_count;  
	natural_t       throttled_count;        
	natural_t       external_page_count;    
	natural_t       internal_page_count;    
	uint64_t        total_uncompressed_pages_in_compressor; 
} __attribute__((aligned(8)));
struct vm_extmod_statistics {
	int64_t task_for_pid_count;                     
	int64_t task_for_pid_caller_count;      
	int64_t thread_creation_count;          
	int64_t thread_creation_caller_count;   
	int64_t thread_set_state_count;         
	int64_t thread_set_state_caller_count;  
} __attribute__((aligned(8)));
struct vm_purgeable_stat {
	uint64_t        count;
	uint64_t        size;
}vm_purgeable_stat_t;
struct vm_purgeable_info {
	vm_purgeable_stat_t fifo_data[8];
	vm_purgeable_stat_t obsolete_data;
	vm_purgeable_stat_t lifo_data[8];
};
struct {
	unsigned int
	    vmnekf_ledger_tag:3,
	    vmnekf_ledger_no_footprint:1,
	__vmnekf_unused:28;
} vm_named_entry_kernel_flags_t;
struct mach_vm_range {
	mach_vm_offset_t        min_address;
	mach_vm_offset_t        max_address;
} *mach_vm_range_t;
struct {
	mach_vm_range_flags_t   flags: 48;
	mach_vm_range_tag_t     range_tag  : 8;
	uint8_t                 vm_tag : 8;
	struct mach_vm_range    range;
} mach_vm_range_recipe_v1_t;
struct {
	uint64_t rtfabstime; 
	uint64_t rtfduration; 
	uint64_t rtfaddr; 
	uint64_t rtfpc; 
	uint64_t rtftid; 
	uint64_t rtfupid; 
	uint64_t rtftype; 
} vm_rtfault_record_t;
struct vm_allocation_total {
	vm_tag_t tag;
	uint64_t total;
};
struct vm_allocation_zone_total {
	vm_size_t vazt_total;
	vm_size_t vazt_peak;
};
struct vm_allocation_site {
	uint64_t  total;
	uint64_t  mapped;
	int16_t   refcount;
	vm_tag_t  tag;
	uint16_t  flags;
	uint16_t  subtotalscount;
	struct vm_allocation_total subtotals[0];
};
struct {
	mach_vm_offset_ut min_address_u;
	mach_vm_offset_ut max_address_u;
});
struct {
	mach_vm_range_flags_t flags: 48;
	mach_vm_range_tag_t   range_tag: 8;
	uint8_t               vm_tag: 8;
	mach_vm_range_ut      range_u;
});
struct static_if_key {
	short                   sik_enable_count;
	short                   sik_init_value;
	unsigned                sik_entries_count;
	static_if_entry_t       sik_entries_head;
} *static_if_key_t;
struct static_if_key_true {
	struct static_if_key    key;
};
struct static_if_key_false {
	struct static_if_key    key;
};
struct hash_info_bucket {
	natural_t       hib_count;      
} hash_info_bucket_t;
struct ipc_info_space {
	natural_t iis_genno_mask;       
	natural_t iis_table_size;       
	natural_t iis_table_next;       
	natural_t iis_tree_size;        
	natural_t iis_tree_small;       
	natural_t iis_tree_hash;        
} ipc_info_space_t;
struct ipc_info_space_basic {
	natural_t iisb_genno_mask;      
	natural_t iisb_table_size;      
	natural_t iisb_table_next;      
	natural_t iisb_table_inuse;     
	natural_t iisb_reserved[2];     
} ipc_info_space_basic_t;
struct ipc_info_name {
	mach_port_name_t iin_name;              
 integer_t iin_collision;   
	mach_port_type_t iin_type;      
	mach_port_urefs_t iin_urefs;    
	natural_t iin_object;           
	natural_t iin_next;             
	natural_t iin_hash;             
} ipc_info_name_t;
struct ipc_info_tree_name {
	ipc_info_name_t iitn_name;
	mach_port_name_t iitn_lchild;   
	mach_port_name_t iitn_rchild;   
} ipc_info_tree_name_t;
struct ipc_info_port {
	natural_t iip_port_object;      
	natural_t iip_receiver_object;  
} ipc_info_port_t;
struct lockgroup_info {
	char            lockgroup_name[LOCKGROUP_MAX_NAME];
	uint64_t        lockgroup_attr;
	uint64_t        lock_spin_cnt;
	uint64_t        lock_spin_util_cnt;
	uint64_t        lock_spin_held_cnt;
	uint64_t        lock_spin_miss_cnt;
	uint64_t        lock_spin_held_max;
	uint64_t        lock_spin_held_cum;
	uint64_t        lock_mtx_cnt;
	uint64_t        lock_mtx_util_cnt;
	uint64_t        lock_mtx_held_cnt;
	uint64_t        lock_mtx_miss_cnt;
	uint64_t        lock_mtx_wait_cnt;
	uint64_t        lock_mtx_held_max;
	uint64_t        lock_mtx_held_cum;
	uint64_t        lock_mtx_wait_max;
	uint64_t        lock_mtx_wait_cum;
	uint64_t        lock_rw_cnt;
	uint64_t        lock_rw_util_cnt;
	uint64_t        lock_rw_held_cnt;
	uint64_t        lock_rw_miss_cnt;
	uint64_t        lock_rw_wait_cnt;
	uint64_t        lock_rw_held_max;
	uint64_t        lock_rw_held_cum;
	uint64_t        lock_rw_wait_max;
	uint64_t        lock_rw_wait_cum;
} lockgroup_info_t;
struct mach_core_details {
	uint64_t gzip_offset;
	uint64_t gzip_length;
	char core_name[MACH_CORE_FILEHEADER_NAMELEN];
};
struct mach_core_fileheader {
	uint64_t signature; 
	uint64_t log_offset;
	uint64_t log_length;
	uint64_t num_files;
	struct mach_core_details files[MACH_CORE_FILEHEADER_MAXFILES];
};
struct mach_core_details_v2 {
	uint64_t flags;  
	uint64_t offset;
	uint64_t length;
	char core_name[MACH_CORE_FILEHEADER_NAMELEN];
};
struct mach_core_fileheader_base {
	uint64_t signature; 
	uint32_t version;
};
struct mach_core_fileheader_v2 {
	uint64_t signature;       
	uint32_t version;         
	uint64_t flags;           
	uint64_t pub_key_offset;  
	uint16_t pub_key_length;  
	uint64_t log_offset;
	uint64_t log_length;
	uint64_t num_files;
	struct mach_core_details_v2 files[];
};
struct mach_vm_info_region {
	mach_vm_offset_t vir_start;     
	mach_vm_offset_t vir_end;       
	mach_vm_offset_t vir_object;    
	memory_object_offset_t vir_offset;      
	boolean_t vir_needs_copy;       
	vm_prot_t vir_protection;       
	vm_prot_t vir_max_protection;   
	vm_inherit_t vir_inheritance;   
	natural_t vir_wired_count;      
	natural_t vir_user_wired_count; 
} mach_vm_info_region_t;
struct vm_info_region_64 {
	natural_t vir_start;            
	natural_t vir_end;              
	natural_t vir_object;           
	memory_object_offset_t vir_offset;      
	boolean_t vir_needs_copy;       
	vm_prot_t vir_protection;       
	vm_prot_t vir_max_protection;   
	vm_inherit_t vir_inheritance;   
	natural_t vir_wired_count;      
	natural_t vir_user_wired_count; 
} vm_info_region_64_t;
struct vm_info_region {
	natural_t vir_start;            
	natural_t vir_end;              
	natural_t vir_object;           
	natural_t vir_offset;           
	boolean_t vir_needs_copy;       
	vm_prot_t vir_protection;       
	vm_prot_t vir_max_protection;   
	vm_inherit_t vir_inheritance;   
	natural_t vir_wired_count;      
	natural_t vir_user_wired_count; 
} vm_info_region_t;
struct vm_info_object {
	natural_t vio_object;           
	natural_t vio_size;             
	unsigned int vio_ref_count;     
	unsigned int vio_resident_page_count; 
	unsigned int vio_absent_count;  
	natural_t vio_copy;             
	natural_t vio_shadow;           
	natural_t vio_shadow_offset;    
	natural_t vio_paging_offset;    
	memory_object_copy_strategy_t vio_copy_strategy;
	vm_offset_t vio_last_alloc;     
	unsigned int vio_paging_in_progress;
	boolean_t vio_pager_created;
	boolean_t vio_pager_initialized;
	boolean_t vio_pager_ready;
	boolean_t vio_can_persist;
	boolean_t vio_internal;
	boolean_t vio_temporary;
	boolean_t vio_alive;
	boolean_t vio_purgable;
	boolean_t vio_purgable_volatile;
} vm_info_object_t;
struct zone_name {
	char            zn_name[ZONE_NAME_MAX_LEN];
} zone_name_t;
struct zone_info {
	integer_t       zi_count;       
	vm_size_t       zi_cur_size;    
	vm_size_t       zi_max_size;    
	vm_size_t       zi_elem_size;   
	vm_size_t       zi_alloc_size;  
	integer_t       zi_pageable;    
	integer_t       zi_sleepable;   
	integer_t       zi_exhaustible; 
	integer_t       zi_collectable; 
} zone_info_t;
struct mach_zone_name {
	char            mzn_name[ZONE_NAME_MAX_LEN];
} mach_zone_name_t;
struct mach_zone_info_data {
	uint64_t        mzi_count;      
	uint64_t        mzi_cur_size;   
	uint64_t        mzi_max_size;   
	uint64_t        mzi_elem_size;  
	uint64_t        mzi_alloc_size; 
	uint64_t        mzi_sum_size;   
	uint64_t        mzi_exhaustible;        
	uint64_t        mzi_collectable;        
} mach_zone_info_t;
struct task_zone_info_data {
	uint64_t        tzi_count;      
	uint64_t        tzi_cur_size;   
	uint64_t        tzi_max_size;   
	uint64_t        tzi_elem_size;  
	uint64_t        tzi_alloc_size; 
	uint64_t        tzi_sum_size;   
	uint64_t        tzi_exhaustible;        
	uint64_t        tzi_collectable;        
	uint64_t        tzi_caller_acct;        
	uint64_t        tzi_task_alloc; 
	uint64_t        tzi_task_free;  
} task_zone_info_t;
struct mach_memory_info {
	uint64_t flags;
	uint64_t site;
	uint64_t size;
	uint64_t free;
	uint64_t largest;
	uint64_t collectable_bytes;
	uint64_t mapped;
	uint64_t peak;
	uint16_t tag;
	uint16_t zone;
	uint16_t _resvA[2];
	uint64_t _resv[3];
	char     name[MACH_MEMORY_INFO_NAME_MAX_LEN];
} mach_memory_info_t;
struct zone_btrecord {
	uint32_t    ref_count;                                  
	uint32_t        operation_type;                         
	uint64_t        bt[MAX_ZTRACE_DEPTH];           
} zone_btrecord_t;
struct entropy_health_stats {
	uint32_t reset_count;

	uint32_t failure_count;

	uint32_t max_observation_count;
} entropy_health_stats_t;
struct bool_gen {
	unsigned int seed[RANDOM_BOOL_GEN_SEED_COUNT];
	unsigned int state;
	decl_simple_lock_data(, lock);
};
struct { uint32_t offset; uint32_t word; } lz4_hash_entry_t;
struct {
	union {
		
		struct {
			upl_page_info_array_t upl_info;
			unsigned int upl_size;
		} upl;
		
		vm_page_t page_slist;
		
		void *pageq; 
	};
	unified_page_list_type_t type;
} unified_page_list_t;
struct {
	const unified_page_list_t *list;
	union {
		
		unsigned int upl_index;
		
		vm_page_t pageq_pos;
	};
} unified_page_list_iterator_t;
struct pfc {
	long    pfc_cpus;
	long    pfc_invalid_global;
};
struct {
	uint64_t lz4_compressions;
	uint64_t lz4_compression_failures;
	uint64_t lz4_compressed_bytes;
	uint64_t lz4_wk_compression_delta;
	uint64_t lz4_wk_compression_negative_delta;
	uint64_t lz4_post_wk_compressions;

	uint64_t wk_compressions;
	uint64_t wk_cabstime;
	uint64_t wk_sv_compressions;
	uint64_t wk_mzv_compressions;
	uint64_t wk_compression_failures;
	uint64_t wk_compressed_bytes_total;
	uint64_t wk_compressions_exclusive;
	uint64_t wk_compressed_bytes_exclusive;

	uint64_t wkh_compressions;
	uint64_t wkh_cabstime;
	uint64_t wks_compressions;
	uint64_t wks_cabstime;
	uint64_t wks_compressed_bytes;
	uint64_t wks_compression_failures;
	uint64_t wks_sv_compressions;

	uint64_t lz4_decompressions;
	uint64_t lz4_decompressed_bytes;
	uint64_t uc_decompressions;

	uint64_t wk_decompressions;
	uint64_t wk_dabstime;

	uint64_t wkh_decompressions;
	uint64_t wkh_dabstime;

	uint64_t wks_decompressions;
	uint64_t wks_dabstime;

	uint64_t wk_decompressed_bytes;
	uint64_t wk_sv_decompressions;
} compressor_stats_t;
struct {
	uint32_t lz4_selection_max;
	int32_t wkdm_reeval_threshold;
	int32_t lz4_threshold;
	uint32_t lz4_max_failure_skips;
	uint32_t lz4_max_failure_run_length;
	uint32_t lz4_max_preselects;
	uint32_t lz4_run_preselection_threshold;
	uint32_t lz4_run_continue_bytes;
	uint32_t lz4_profitable_bytes;
} compressor_tuneables_t;
struct swapout_io_completion {
	int          swp_io_busy;
	int          swp_io_done;
	int          swp_io_error;

	uint32_t     swp_c_size;
	c_segment_t  swp_c_seg;

	struct swapfile *swp_swf;
	uint64_t        swp_f_offset;

	struct upl_io_completion swp_upl_ctx;
};
struct c_slot_info {
	uint16_t       csi_size;
	uint16_t       csi_unused;
} __attribute__((packed));
struct c_segment_info {
	uint32_t       csi_mysegno;
	uint32_t       csi_creation_ts;
	uint32_t       csi_swappedin_ts;
	int32_t        csi_bytes_unused;
	int32_t        csi_bytes_used;
	uint32_t       csi_populated_offset;

	uint32_t       csi_state: 4,
	    csi_swappedin: 1,
	    csi_on_minor_compact_q: 1,
	    csi_has_donated_pages: 1,
	    csi_reserved: 25;
	int            csi_slot_var_array_len;
	uint32_t       csi_decompressions_since_swapin;
	uint16_t       csi_slots_used;
	uint16_t       csi_slots_len;  
	struct c_slot_info  csi_slots[0];
} __attribute__((packed));
struct vm_map_info_hdr {
	int vmi_nentries;
} __attribute__((packed));
struct vm_map_entry_info {
	vm_map_offset_t         vmei_start;          
	vm_map_offset_t         vmei_end;            
	unsigned long long
	 vmei_alias:12,   
	 vmei_offset:(64 - 12); 
	uint32_t vmei_is_sub_map: 1,
	    vmei_is_compressor_pager: 1,
	    vmei_protection: 3;
	uint32_t vmei_slot_mapping_count;
	int slot_mappings[0];
} __attribute__((packed));
struct c_slot {
	uint64_t        c_offset:C_SEG_OFFSET_BITS __kernel_ptr_semantics;
	uint64_t        c_size:C_SLOT_C_SIZE_BITS;
	uint64_t        c_packed_ptr:C_SLOT_PACKED_PTR_BITS __kernel_ptr_semantics; 

	unsigned int    c_hash_data;
	unsigned int    c_hash_compressed_data;
} __attribute__((packed, aligned(4)));
struct c_segment {
	lck_mtx_t       c_lock;
	queue_chain_t   c_age_list;  
	queue_chain_t   c_list;      


	uint32_t        c_mysegno;  

	uint32_t        c_creation_ts;  
	uint64_t        c_generation_id;  

	int32_t         c_bytes_used;
	int32_t         c_bytes_unused;
	uint32_t        c_slots_used;

	uint16_t        c_firstemptyslot;  
	uint16_t        c_nextslot;        
	uint32_t        c_nextoffset;      
	uint32_t        c_populated_offset; 

	union {
		int32_t *c_buffer;
		uint64_t c_swap_handle;  
	} c_store;

	uint32_t        c_was_minor_compacted;
	uint32_t        c_was_major_compacted;
	uint32_t        c_was_major_donor;
	unsigned int    cseg_hash;
	unsigned int    cseg_swap_size;

	thread_t        c_busy_for_thread;
	uint32_t        c_agedin_ts;  
	uint32_t        c_swappedin_ts;
	bool            c_swappedin;
	uint32_t        c_decompressions_since_swapin;
	uint32_t        c_busy:1,
	    c_busy_swapping:1,
	    c_wanted:1,
	    c_on_minorcompact_q:1,              

	    c_state:4,                          
	    c_overage_swap:1,
	    c_has_donated_pages:1,

	int             c_slot_var_array_len;  
	struct  c_slot  *c_slot_var_array;     
	struct  c_slot  c_slot_fixed_array[0];
};
struct  c_slot_mapping {
};
struct vm_compressor_kdp_state {
	char           *kc_scratch_bufs;
	char           *kc_decompressed_pages;
	addr64_t       *kc_decompressed_pages_paddr;
	ppnum_t        *kc_decompressed_pages_ppnum;
	char           *kc_panic_scratch_buf;
	char           *kc_panic_decompressed_page;
	addr64_t        kc_panic_decompressed_page_paddr;
	ppnum_t         kc_panic_decompressed_page_ppnum;
};
struct {
	kern_return_t           kmr_return;
	union {
		vm_address_t    kmr_address;
		vm_size_t       kmr_size;
		void           *kmr_ptr;
		vm_map_t        kmr_submap;
	};
} kmem_return_t;
struct {
	uint16_t                kmg_tag;
	uint16_t                kmg_type_hash;
	uint32_t                kmg_atomic : 1;
	uint32_t                kmg_submap : 1;
	uint32_t                kmg_context : 30;
} kmem_guard_t;
struct kmem_range_startup_spec {
	const char             *kc_name;
	struct mach_vm_range   *kc_range;
	vm_map_size_t           kc_size;
	vm_map_size_t           (^kc_calculate_sz)(void);
	kmem_claims_flags_t     kc_flags;
};
struct vm_map_store {
	RB_ENTRY(vm_map_store) entry;
};
struct vm_map_links {
	struct vm_map_entry     *prev;          
	struct vm_map_entry     *next;          
	vm_map_offset_t         start;          
	vm_map_offset_t         end;            
};
struct vm_map_header {
	struct vm_map_links     links;          
	int                     nentries;       
	uint16_t                page_shift;     
	uint16_t                entries_pageable : 1;   
	uint16_t                __padding : 15;
	struct rb_head          rb_head_store;
};
struct vm_named_entry {
	decl_lck_mtx_data(, Lock);              
	union {
		vm_map_t        map;            
		vm_map_copy_t   copy;           
	} backing;
	vm_object_offset_t      offset;         
	vm_object_size_t        size;           
	vm_object_offset_t      data_offset;    
	unsigned int                            
	 access:8,               
	 protection:4,           
	 is_object:1,            
	 internal:1,             
	 is_sub_map:1,           
	 is_copy:1,              
	 is_fully_owned:1;       
};
struct vm_map_entry {
	struct vm_map_links     links;                      

	struct vm_map_store     store;

	union {
		vm_offset_t     vme_object_value;
		struct {
			vm_offset_t vme_atomic:1;           
			vm_offset_t is_sub_map:1;           
			vm_offset_t vme_submap:VME_SUBMAP_BITS;
		};
		struct {
			uint32_t    vme_ctx_atomic : 1;
			uint32_t    vme_ctx_is_sub_map : 1;
			uint32_t    vme_context : 30;

			
			union {
				vm_page_object_t vme_object_or_delta;
				btref_t vme_tag_btref;
			};
		};
	};

	unsigned long long
	 vme_alias:VME_ALIAS_BITS,   
	 vme_offset:VME_OFFSET_BITS, 

	 is_shared:1,                
	__unused1:1,
	in_transition:1,             
	 needs_wakeup:1,             
	 behavior:2,                 
	 needs_copy:1,               


	 max_protection:4,           
	 inheritance:2,              

	 use_pmap:1,
	 no_cache:1,                 
	 vme_permanent:1,            
	 superpage_size:1,           
	 map_aligned:1,              
	 zero_wired_pages:1,
	 used_for_jit:1,
	 csm_associated:1,       

	 iokit_acct:1,
	 vme_resilient_codesign:1,
	 vme_resilient_media:1,
	 vme_xnu_user_debug:1,
	 vme_no_copy_on_read:1,
	 translated_allow_execute:1, 
	 vme_kernel_object:1;        

	unsigned short          wired_count;                
	unsigned short          user_wired_count;           

};
struct vm_map_user_range {
	vm_map_address_t        vmur_min_address __kernel_data_semantics;

	vm_map_address_t        vmur_max_address : 56 __kernel_data_semantics;
	vm_map_range_id_t       vmur_range_id : 8;
} *vm_map_user_range_t;
struct _vm_map {
	lck_rw_t                lock;           
	struct vm_map_header    hdr;            
	pmap_t                  XNU_PTRAUTH_SIGNED_PTR("_vm_map.pmap") pmap;           
	vm_map_size_t           size;           
	uint64_t                size_limit;     
	uint64_t                data_limit;     
	vm_map_size_t           user_wire_limit;
	vm_map_size_t           user_wire_size; 

	os_ref_atomic_t         map_refcnt;       


	union {
		
		vm_map_offset_t         vmu1_highest_entry_end;
		
		vm_map_offset_t         vmu1_lowest_unnestable_start;
	} vmu1;
	vm_map_entry_t          hint;           
	union {
		struct vm_map_links* vmmap_hole_hint;   
		struct vm_map_corpse_footprint_header *vmmap_corpse_footprint;
	} vmmap_u_1;
	union {
		vm_map_entry_t          _first_free;    
		struct vm_map_links*    _holes;         
	} f_s;                                      


	unsigned int
	 wait_for_space:1,         
	 wiring_required:1,        
	 no_zero_fill:1,           
	 mapped_in_other_pmaps:1,  
	 switch_protect:1,         
	 disable_vmentry_reuse:1,  
	 map_disallow_data_exec:1, 
	 holelistenabled:1,
	 is_nested_map:1,
	 map_disallow_new_exec:1,  
	 jit_entry_exists:1,
	 has_corpse_footprint:1,
	 terminated:1,
	 is_alien:1,               
	 cs_enforcement:1,         
	 cs_debugged:1,            
	 reserved_regions:1,       
	 single_jit:1,             
	 never_faults:1,           
	 uses_user_ranges:1,       
	 tpro_enforcement:1,       
	 corpse_source:1,          
	 res0:1,
	pad:9;
	unsigned int            timestamp;          
	task_t owning_task;
};
struct vm_map_version {
	unsigned int    main_timestamp;
} vm_map_version_t;
struct vm_map_copy {
	uint16_t                type;
	bool                    is_kernel_range;
	bool                    is_user_range;
	vm_map_range_id_t       orig_range;
	vm_object_offset_t      offset;
	vm_map_size_t           size;
	union {
		struct vm_map_header                  hdr;    
		void *XNU_PTRAUTH_SIGNED_PTR("vm_map_copy.kdata") kdata;  
	} c_u;
};
struct vm_reserved_region {
	const char             *vmrr_name;
	vm_map_offset_t         vmrr_addr;
	vm_map_size_t           vmrr_size;
};
struct {
	vm_map_t map;
	task_t task;
} vm_map_switch_context_t;
struct vm_object_fault_info {
	int             interruptible;
	uint32_t        user_tag;
	vm_size_t       cluster_size;
	vm_behavior_t   behavior;
	vm_object_offset_t lo_offset;
	vm_object_offset_t hi_offset;
	unsigned int
	 no_cache:1,
	 stealth:1,
	 io_sync:1,
	 cs_bypass:1,
	 csm_associated:1,
	 mark_zf_absent:1,
	 batch_pmap_op:1,
	 resilient_media:1,
	 no_copy_on_read:1,
	 fi_xnu_user_debug:1,
	 fi_used_for_tpro:1,
	 fi_change_wiring:1,
	 fi_no_sleep:1,
	__vm_object_fault_info_unused_bits:19;
	int             pmap_options;
};
struct vm_object {
	vm_page_queue_head_t    memq;           
	lck_rw_t                Lock;           

	union {
		vm_object_size_t  vou_size;     
		int               vou_cache_pages_to_scan;      
	} vo_un1;

	struct vm_page          *memq_hint;
	os_ref_atomic_t         ref_count;        
	unsigned int            resident_page_count;
	unsigned int            wired_page_count; 
	unsigned int            reusable_page_count;

	struct vm_object        *vo_copy;       
	uint32_t                vo_copy_version;
	uint32_t                vo_inherit_copy_none:1,
	    __vo_unused_padding:31;
	struct vm_object        *shadow;        
	memory_object_t         pager;          

	union {
		vm_object_offset_t vou_shadow_offset;   
		clock_sec_t     vou_cache_ts;   
		task_t          vou_owner;      
	} vo_un2;

	vm_object_offset_t      paging_offset;  
	memory_object_control_t pager_control;  

	memory_object_copy_strategy_t
	    copy_strategy;                      

	uint16_t                paging_in_progress;
	uint16_t                vo_size_delta;
	uint32_t                activity_in_progress;


	unsigned int
	 all_wanted:7,     
	 pager_created:1,        
	 pager_initialized:1,    
	 pager_ready:1,          

	 pager_trusted:1,        
	 can_persist:1,          
	 internal:1,             
	 private:1,              
	 pageout:1,              
	 alive:1,                

	 purgable:2,             
	 purgeable_only_by_kernel:1,
	 purgeable_when_ripe:1,         
	 shadowed:1,             
	 true_share:1,
	 terminating:1,
	 named:1,                
	 shadow_severed:1,
	 phys_contiguous:1,
	 nophyscache:1,
	 for_realtime:1,
	 no_pager_reason:3,

	queue_chain_t           cached_list;    
	vm_object_offset_t      last_alloc;     
	vm_offset_t             cow_hint;       
	                                        
	int                     sequential;     

	uint32_t                pages_created;
	uint32_t                pages_used;
	unsigned        int
	    wimg_bits:8,                
	    code_signed:1,              
	    transposed:1,               
	    mapping_in_progress:1,      
	    phantom_isssd:1,
	    volatile_empty:1,
	    volatile_fault:1,
	    all_reusable:1,
	    blocked_access:1,
	    set_cache_attr:1,
	    object_is_shared_cache:1,
	    purgeable_queue_type:2,
	    purgeable_queue_group:3,
	    io_tracking:1,
	    no_tag_update:1,            
	vo_ledger_tag:3,
	    vo_no_footprint:1;


	uint8_t                 scan_collisions;
	uint8_t                 __object4_unused_bits[1];
	vm_tag_t                wire_tag;



	queue_chain_t           objq;      
	queue_chain_t           task_objq; 


};
struct vm_page_packed_queue_entry {
	vm_page_packed_t        next;          
	vm_page_packed_t        prev;          
};
struct vm_page {
	union {
		vm_page_queue_chain_t vmp_q_pageq;           
		struct vm_page        *vmp_q_snext;
	} vmp_q_un;

	vm_page_queue_chain_t         vmp_listq;           

	vm_page_queue_chain_t         vmp_specialq;     
	vm_object_offset_t            vmp_offset;          

	vm_page_object_t              vmp_object;          

	unsigned int vmp_wire_count:16,      
	    vmp_q_state:4,                   
	    vmp_on_specialq:2,
	    vmp_canonical:1,                 
	    vmp_gobbled:1,                   
	    vmp_laundry:1,                   
	    vmp_no_cache:1,                  
	                                     
	    vmp_reference:1,                 
	    vmp_lopage:1,
	    vmp_realtime:1,                  

	vm_page_packed_t vmp_next_m;            

	unsigned int    vmp_busy:1,           
	    vmp_wanted:1,                     
	    vmp_tabled:1,                     
	    vmp_hashed:1,                     
	__vmp_unused : 1,
	vmp_clustered:1,                      
	    vmp_pmapped:1,                    
	                                      
	    vmp_xpmapped:1,                   
	                                      
	    vmp_wpmapped:1,                   
	    vmp_free_when_done:1,             
	    vmp_absent:1,                     
	    vmp_error:1,                      
	    vmp_dirty:1,                      
	    vmp_cleaning:1,                   
	    vmp_precious:1,                   
	    vmp_overwriting:1,                
	                                      
	    vmp_restart:1,                    
	                                      
	    vmp_unusual:1,                    
	    vmp_cs_validated:VMP_CS_BITS,     
	    vmp_cs_tainted:VMP_CS_BITS,       
	    vmp_cs_nx:VMP_CS_BITS,            
	    vmp_reusable:1,
	    vmp_written_by_kernel:1;          

};
struct vm_speculative_age_q {
	vm_page_queue_head_t    age_q;
	mach_timespec_t age_ts;
} VM_PAGE_PACKED_ALIGNED;
struct vm_locks_array {
	char    pad  __attribute__ ((aligned(64)));
	lck_mtx_t       vm_page_queue_lock2 __attribute__ ((aligned(64)));
	lck_mtx_t       vm_page_queue_free_lock2 __attribute__ ((aligned(64)));
	char    pad2  __attribute__ ((aligned(64)));
} vm_locks_array_t;
struct vpl {
	vm_page_queue_head_t    vpl_queue;
	unsigned int    vpl_count;
	unsigned int    vpl_internal_count;
	unsigned int    vpl_external_count;
	lck_spin_t      vpl_lock;
};
struct vm_page_stats_reusable {
	SInt32          reusable_count;
	uint64_t        reusable;
	uint64_t        reused;
	uint64_t        reused_wire;
	uint64_t        reused_remove;
	uint64_t        all_reusable_calls;
	uint64_t        partial_reusable_calls;
	uint64_t        all_reuse_calls;
	uint64_t        partial_reuse_calls;
	uint64_t        reusable_pages_success;
	uint64_t        reusable_pages_failure;
	uint64_t        reusable_pages_shared;
	uint64_t        reuse_pages_success;
	uint64_t        reuse_pages_failure;
	uint64_t        can_reuse_success;
	uint64_t        can_reuse_failure;
	uint64_t        reusable_reclaimed;
	uint64_t        reusable_nonwritable;
	uint64_t        reusable_shared;
	uint64_t        free_shared;
};
struct  vm_config {
	boolean_t       compressor_is_present;          
	boolean_t       compressor_is_active;           
	boolean_t       swap_is_present;                
	boolean_t       swap_is_active;                 
	boolean_t       freezer_swap_is_active;         
};
struct vm_pageout_queue {
	vm_page_queue_head_t pgo_pending;  
	unsigned int    pgo_laundry;       
	unsigned int    pgo_maxlaundry;

	uint32_t
	    pgo_busy:1,        
	    pgo_throttled:1,   
	    pgo_lowpriority:1, 
	    pgo_draining:1,
	    pgo_inited:1,
	    pgo_unused_bits:26;
};
struct _vector_upl_iostates {
	upl_offset_t offset;
	upl_size_t   size;
};
struct _vector_upl {
	upl_size_t              size;
	uint32_t                num_upls;
	uint32_t                invalid_upls;
	uint32_t                max_upls;
	vm_map_t                submap;
	vm_offset_t             submap_dst_addr;
	vm_object_offset_t      offset;
	upl_page_info_array_t   pagelist;
	struct {
		upl_t                   elem;
		vector_upl_iostates_t   iostate;
	} upls[];
};
struct upl_io_completion {
	void     *io_context;
	void     (*io_done)(void *, int);

	int      io_error;
};
struct upl {
	decl_lck_mtx_data(, Lock);      
	int             ref_count;
	int             ext_ref_count;
	int             flags;
	ctid_t          map_addr_owner; 
	vm_object_offset_t u_offset;
	upl_size_t      u_size;       
	upl_size_t      u_mapped_size;       
	vm_offset_t     kaddr;      
	vm_object_t     map_object;
	vector_upl_t    vector_upl;
	upl_t           associated_upl;
	struct upl_io_completion *upl_iodone;
	ppnum_t         highest_page;

	bitmap_t       *lite_list;
	struct upl_page_info page_list[];
};
struct vm_pageout_state {
	boolean_t vm_pressure_thread_running;
	boolean_t vm_pressure_changed;
	boolean_t vm_restricted_to_single_processor;
	int vm_compressor_thread_count;

	unsigned int vm_page_speculative_q_age_ms;
	unsigned int vm_page_speculative_percentage;
	unsigned int vm_page_speculative_target;

	unsigned int vm_pageout_swap_wait;
	unsigned int vm_pageout_idle_wait;      
	unsigned int vm_pageout_empty_wait;     
	unsigned int vm_pageout_burst_wait;     
	unsigned int vm_pageout_deadlock_wait;  
	unsigned int vm_pageout_deadlock_relief;
	unsigned int vm_pageout_burst_inactive_throttle;

	unsigned int vm_pageout_inactive;
	unsigned int vm_pageout_inactive_used;  
	unsigned int vm_pageout_inactive_clean; 

	uint32_t vm_page_filecache_min;
	uint32_t vm_page_filecache_min_divisor;
	uint32_t vm_page_xpmapped_min;
	uint32_t vm_page_xpmapped_min_divisor;
	uint64_t vm_pageout_considered_page_last;

	int vm_page_free_count_init;

	unsigned int vm_memory_pressure;

	int memorystatus_purge_on_critical;
	int memorystatus_purge_on_warning;
	int memorystatus_purge_on_urgent;

	thread_t vm_pageout_early_swapout_iothread;
};
struct vm_pageout_vminfo {
	unsigned long vm_pageout_considered_page;
	unsigned long vm_pageout_considered_bq_internal;
	unsigned long vm_pageout_considered_bq_external;
	unsigned long vm_pageout_skipped_external;
	unsigned long vm_pageout_skipped_internal;

	unsigned long vm_pageout_pages_evicted;
	unsigned long vm_pageout_pages_purged;
	unsigned long vm_pageout_freed_cleaned;
	unsigned long vm_pageout_freed_speculative;
	unsigned long vm_pageout_freed_external;
	unsigned long vm_pageout_freed_internal;
	unsigned long vm_pageout_inactive_dirty_internal;
	unsigned long vm_pageout_inactive_dirty_external;
	unsigned long vm_pageout_inactive_referenced;
	unsigned long vm_pageout_reactivation_limit_exceeded;
	unsigned long vm_pageout_inactive_force_reclaim;
	unsigned long vm_pageout_inactive_nolock;
	unsigned long vm_pageout_filecache_min_reactivated;
	unsigned long vm_pageout_scan_inactive_throttled_internal;
	unsigned long vm_pageout_scan_inactive_throttled_external;

	uint64_t      vm_pageout_compressions;
	uint64_t      vm_compressor_pages_grabbed;
	unsigned long vm_compressor_failed;

	unsigned long vm_page_pages_freed;

	unsigned long vm_phantom_cache_found_ghost;
	unsigned long vm_phantom_cache_added_ghost;

	unsigned long vm_pageout_protected_sharedcache;
	unsigned long vm_pageout_forcereclaimed_sharedcache;
	unsigned long vm_pageout_protected_realtime;
	unsigned long vm_pageout_forcereclaimed_realtime;

};
struct pgo_iothread_state {
	struct vm_pageout_queue *q;
	void                    *current_early_swapout_chead;
	void                    *current_regular_swapout_chead;
	void                    *current_late_swapout_chead;
	char                    *scratch_buf;
	int                     id;
	thread_t                pgo_iothread; 
	sched_cond_atomic_t     pgo_wakeup;
};
struct vm_compressor_swapper_stats {
	uint64_t unripe_under_30s;
	uint64_t unripe_under_60s;
	uint64_t unripe_under_300s;
	uint64_t reclaim_swapins;
	uint64_t defrag_swapins;
	uint64_t compressor_swap_threshold_exceeded;
	uint64_t external_q_throttled;
	uint64_t free_count_below_reserve;
	uint64_t thrashing_detected;
	uint64_t fragmentation_detected;
};
struct vm_page_queue_free_head {
	vm_page_queue_head_t    qhead;
} VM_PAGE_PACKED_ALIGNED;
struct {
	uint8_t vmpr_regular;
	uint8_t vmpr_lopage;
} vmp_free_list_result_t;
struct page_worker_token {
	thread_pri_floor_t pwt_floor_token;
	bool pwt_did_register_inheritor;
} page_worker_token_t;
struct vm_page_delayed_work {
	vm_page_t       dw_m;
	int             dw_mask;
};
struct vm_page_delayed_work_ctx {
	struct vm_page_delayed_work dwp[DEFAULT_DELAYED_WORK_LIMIT];
	thread_t                    delayed_owner;
};
struct  vm_ghost {
	uint64_t        g_next_index:VM_GHOST_INDEX_BITS,
	    g_pages_held:VM_GHOST_PAGES_PER_ENTRY,
	    g_obj_offset:VM_GHOST_OFFSET_BITS;
	uint32_t        g_obj_id;
} __attribute__((packed));
struct trim_list {
	uint64_t        tl_offset;
	uint64_t        tl_length;
	struct trim_list *tl_next;
};
struct vm_counters {
	unsigned int    do_collapse_compressor;
	unsigned int    do_collapse_compressor_pages;
	unsigned int    do_collapse_terminate;
	unsigned int    do_collapse_terminate_failure;
	unsigned int    should_cow_but_wired;
	unsigned int    create_upl_extra_cow;
	unsigned int    create_upl_extra_cow_pages;
	unsigned int    create_upl_lookup_failure_write;
	unsigned int    create_upl_lookup_failure_copy;
};
struct purgeable_q {
	token_idx_t token_q_head;    
	token_idx_t token_q_tail;    
	token_idx_t token_q_unripe;  
	int32_t new_pages;
	queue_head_t objq[NUM_VOLATILE_GROUPS];
	enum purgeable_q_type type;
};
struct {
	kern_return_t compat_kr;
	bool should_rewrite;
	bool should_telemeter;
} vm_sanitize_compat_rewrite_t;
struct vm_sanitize_caller {
	vm_sanitize_caller_id_t              vmsc_caller_id;
	const char                          *vmsc_caller_name;
	vm_sanitize_method_t                 vmsc_telemetry_id;
	enum vm_sanitize_subsys_error_codes  vmsc_ktriage_id;

	vm_sanitize_err_compat_addr_size_fn    err_compat_addr_size;
	vm_sanitize_err_compat_cur_and_max_prots_fn err_compat_prot_cur_max;
} *vm_sanitize_caller_t;
struct _sr_file_mappings {
	int                     fd;
	uint32_t                mappings_count;
	struct shared_file_mapping_slide_np *mappings;
	uint32_t                slide;
	struct fileproc         *fp;
	struct vnode            *vp;
	memory_object_size_t    file_size;
	memory_object_control_t file_control;
};
struct vm_shared_region_slide_info_entry_v1 {
	uint32_t        version;
	uint32_t        toc_offset;     
	uint32_t        toc_count;      
	uint32_t        entry_offset;
	uint32_t        entry_count;
	uint32_t        entries_size;
};
struct slide_info_entry_toc {
	uint8_t entry[NUM_SLIDING_BITMAPS_PER_PAGE];
};
struct vm_shared_region_slide_info_entry_v2 {
	uint32_t        version;
	uint32_t        page_size;
	uint32_t        page_starts_offset;
	uint32_t        page_starts_count;
	uint32_t        page_extras_offset;
	uint32_t        page_extras_count;
	uint64_t        delta_mask;             
	uint64_t        value_add;
};
struct vm_shared_region_slide_info_entry_v3 {
	uint32_t        version;                        
	uint32_t        page_size;                      
	uint32_t        page_starts_count;
	uint64_t        value_add;
	uint16_t        page_starts[] ;
};
struct vm_shared_region_slide_info_entry_v4 {
	uint32_t    version;        
	uint32_t    page_size;      
	uint32_t    page_starts_offset;
	uint32_t    page_starts_count;
	uint32_t    page_extras_offset;
	uint32_t    page_extras_count;
	uint64_t    delta_mask;    
	uint64_t    value_add;     
};
struct vm_shared_region_slide_info_entry_v5 {
	uint32_t    version;        
	uint32_t    page_size;      
	uint32_t    page_starts_count;
	uint64_t    value_add;
	uint16_t    page_starts[] ;
};
struct vm_shared_region_slide_info {
	uint32_t                si_slide;           
	bool                    si_slid;
	mach_vm_address_t       si_slid_address __kernel_data_semantics;
	mach_vm_offset_t        si_start __kernel_data_semantics; 
	mach_vm_offset_t        si_end __kernel_data_semantics;
	vm_object_t             si_slide_object;    
	mach_vm_size_t          si_slide_info_size; 
	vm_shared_region_slide_info_entry_t si_slide_info_entry; 
} *vm_shared_region_slide_info_t;
struct vm_shared_region {
	uint32_t                sr_ref_count;
	uint32_t                sr_slide;
	queue_chain_t           sr_q;
	void                    *sr_root_dir;
	cpu_type_t              sr_cpu_type;
	cpu_subtype_t           sr_cpu_subtype;
	ipc_port_t              sr_mem_entry;
	mach_vm_offset_t        sr_first_mapping;
	mach_vm_offset_t        sr_base_address;
	mach_vm_size_t          sr_size;
	mach_vm_offset_t        sr_pmap_nesting_start;
	mach_vm_size_t          sr_pmap_nesting_size;
	thread_call_t           sr_timer_call;
	uuid_t                  sr_uuid;

	thread_t                sr_mapping_in_progress; 
	thread_t                sr_slide_in_progress;
	bool                    sr_64bit;
	bool                    sr_persists;
	bool                    sr_uuid_copied;
	bool                    sr_stale;              
	bool                    sr_driverkit;


	uint32_t                sr_rsr_version;

	uint64_t                sr_install_time; 
	uint32_t                sr_id; 
	uint32_t                sr_images_count;
	struct dyld_uuid_info_64 *sr_images;
};
struct lowglo {
	unsigned char   lgVerCode[8];           
	uint64_t        lgZero;                 
	uint64_t        lgStext;                
	uint64_t        lgLayoutMajorVersion;   
	uint64_t        lgLayoutMinorVersion;   
	uint64_t        lgRsv028;               
	uint64_t        lgVersion;              
	uint64_t        lgCompressorBufferAddr; 
	uint64_t        lgCompressorSizeAddr;   
	uint64_t        lgRsv038[278];          
	uint64_t        lgKmodptr;              
	uint64_t        lgTransOff;             
	uint64_t        lgReadIO;               
	uint64_t        lgDevSlot1;             
	uint64_t        lgDevSlot2;             
	uint64_t        lgOSVersion;            
	uint64_t        lgRebootFlag;           
	uint64_t        lgManualPktAddr;        
	uint64_t        lgKdpJtagCoredumpAddr;  

	uint64_t        lgRsv940[216];          
} lowglo;
struct processor_cpu_stat {
	uint32_t irq_ex_cnt;
	uint32_t ipi_cnt;
	uint32_t timer_cnt;
	uint32_t undef_ex_cnt;
	uint32_t unaligned_cnt;
	uint32_t vfp_cnt;
	uint32_t vfp_shortv_cnt;
	uint32_t data_ex_cnt;
	uint32_t instr_ex_cnt;
};
struct processor_cpu_stat64 {
	uint64_t irq_ex_cnt;
	uint64_t ipi_cnt;
	uint64_t timer_cnt;
	uint64_t undef_ex_cnt;
	uint64_t unaligned_cnt;
	uint64_t vfp_cnt;
	uint64_t vfp_shortv_cnt;
	uint64_t data_ex_cnt;
	uint64_t instr_ex_cnt;
	uint64_t pmi_cnt;
} __attribute__((packed, aligned(4)));
struct arm_state_hdr {
	uint32_t flavor;
	uint32_t count;
};
struct arm_unified_thread_state {
	arm_state_hdr_t ash;
	union {
		arm_thread_state32_t ts_32;
		arm_thread_state64_t ts_64;
	} uts;
};
struct arm_saved_state32 {
	uint32_t r[13];     
	uint32_t sp;        
	uint32_t lr;        
	uint32_t pc;        
	uint32_t cpsr;      
	uint32_t far;       
	uint32_t esr;       
	uint32_t exception; 
};
struct arm_saved_state32_tagged {
	uint32_t                 tag;
	struct arm_saved_state32 state;
};
struct arm_saved_state64 {
	uint64_t x[29];     
	uint64_t fp;        
	uint64_t lr;        
	uint64_t sp;        
	uint64_t pc;        
	uint32_t cpsr;      
	uint32_t reserved;  
	uint64_t far;       
	uint64_t esr;       
};
struct arm_saved_state64_tagged {
	uint32_t                 tag;
	struct arm_saved_state64 state;
};
struct arm_saved_state {
	arm_state_hdr_t ash;
	union {
		struct arm_saved_state32 ss_32;
		struct arm_saved_state64 ss_64;
	} uss;
} __attribute__((aligned(16)));
struct arm_kernel_saved_state {
	uint64_t x[10];     
	uint64_t fp;        
	uint64_t lr;        
	uint64_t sp;        
	uint8_t pc_was_in_userspace;
	uint8_t ssbs;
	uint8_t dit;
	uint8_t uao;
} __attribute__((aligned(16)));
struct arm_debug_aggregate_state {
	arm_state_hdr_t dsh;
	union {
		arm_debug_state32_t ds32;
		arm_debug_state64_t ds64;
	} uds;
	os_refcnt_t     ref;
} __attribute__((aligned(16)));
struct arm_neon_saved_state32 {
	union {
		uint128_t q[16];
		uint64_t  d[32];
		uint32_t  s[32];
	} v;
	uint32_t fpsr;
	uint32_t fpcr;
};
struct arm_neon_saved_state64 {
	union {
		uint128_t  q[32];
		uint64x2_t d[32];
		uint32x4_t s[32];
	} v;
	uint32_t fpsr;
	uint32_t fpcr;
};
struct arm_neon_saved_state {
	arm_state_hdr_t nsh;
	union {
		struct arm_neon_saved_state32 ns_32;
		struct arm_neon_saved_state64 ns_64;
	} uns;
};
struct arm_kernel_neon_saved_state {
	uint64_t d[8];
	uint32_t fpcr;
};
struct arm_context {
	struct arm_saved_state ss;
	struct arm_neon_saved_state ns;
};
struct arm_kernel_context {
	struct arm_kernel_saved_state ss;
	struct arm_kernel_neon_saved_state ns;
};
struct { int __val[2]; } bit64_t;
struct { unsigned int __val[2]; } u_bit64_t;
struct { int __val[2]; } bit64_t;
struct { unsigned int __val[2]; } u_bit64_t;
struct timespec {
	unsigned long tv_sec;
	long tv_nsec;
};
struct _kdp_jtag_coredump_t {
	uint64_t signature;
	uint64_t version;
	uint64_t kernel_map_start;
	uint64_t kernel_map_end;
	uint64_t kernel_pmap_pml4;
	uint64_t pmap_memory_regions;
	uint64_t pmap_memory_region_count;
	uint64_t pmap_memory_region_t_size;
	uint64_t physmap_base;
} kdp_jtag_coredump_t;
struct vmx_specs {
	boolean_t       initialized;    
	boolean_t       vmx_present;    
	boolean_t       vmx_on;                 
	uint32_t        vmcs_id;                
	uint32_t        cr0_fixed_0;    
	uint32_t        cr0_fixed_1;    

	uint32_t        cr4_fixed_0;    
	uint32_t        cr4_fixed_1;    
} vmx_specs_t;
struct vmx_cpu {
	vmx_specs_t     specs;          
	void            *vmxon_region;  
} vmx_cpu_t;
struct arm_physrange {
	uint64_t        start_phys;     
	uint64_t        end_phys;       
} arm_physrange_t;
struct pv_entry {
	struct pv_entry *pve_next;

	pt_entry_t *pve_ptep[PTE_PER_PVE];
} pv_entry_t;
struct {
	pv_entry_t *list;
	uint32_t count;
} pv_free_list_t;
struct pmap_cpu_data {
	unsigned int cpu_number;
	bool copywindow_strong_sync[CPUWINDOWS_MAX];
	bool inflight_disconnect;
	pv_free_list_t pv_free;
	pv_entry_t *pv_free_spill_marker;
};
struct {
	uintptr_t pvh;
	thread_pri_floor_t pri_token;
	unsigned int pai;
} locked_pvh_t;
struct pmap {
	tt_entry_t *tte;

	pmap_paddr_t ttep;


	vm_map_address_t min;

	vm_map_address_t max;


	ledger_t ledger;

	decl_lck_rw_data(, rwlock);

	queue_chain_t pmaps;

	struct pmap      *nested_pmap;
	vm_map_address_t nested_region_addr;
	vm_map_offset_t  nested_region_size;
	vm_map_offset_t  nested_region_true_start;
	vm_map_offset_t  nested_region_true_end;
	bitmap_t         *nested_region_unnested_table_bitmap;

	os_ref_atomic_t ref_count;

	uint32_t nested_no_bounds_refcnt;

	union {
		
		uint16_t asid;

		
		uint16_t vmid;
	};


	bool reserved0;

	bool pmap_vm_map_cs_enforced;

	bool reserved1;
	unsigned int reserved2;
	unsigned int reserved3;



	bool nx_enabled;

	bool is_64bit;

	bool nested_has_no_bounds_ref;

	bool nested_bounds_set;


	bool reserved6;

	uint8_t type;

	uint32_t reserved7[4];
	void *reserved8;
	uint8_t reserved9;
};
struct pmap_cpu_data_array_entry {
	pmap_cpu_data_t cpu_data;
} __attribute__((aligned(MAX_L2_CLINE_BYTES)));
struct {
	unsigned short wiredcnt;
} ptd_info_t;
struct pt_desc {
	union {
		struct pmap *pmap;
	};


	vm_offset_t va;

	ptd_info_t *ptd_info;
} pt_desc_t;
struct {
	uint64_t local_seq;

	uint64_t next_seq;

	uint64_t remote_seq[MAX_CPUS];



	uint8_t flags;
} pmap_retype_epoch_t;
struct {
	sptm_pte_t *sptm_prev_ptes;

	void *sptm_iommu_scratch;

	sptm_disjoint_op_t sptm_ops[SPTM_MAPPING_LIMIT];

	union {
		
		sptm_pte_t sptm_templates[SPTM_MAPPING_LIMIT];

		
		sptm_paddr_t sptm_paddrs[SPTM_MAPPING_LIMIT];
	};

	pmap_paddr_t sptm_ops_pa;

	pmap_paddr_t sptm_templates_pa;

	pmap_paddr_t sptm_paddrs_pa;

	pt_desc_t *sptm_ptds[SPTM_MAPPING_LIMIT];

	ptd_info_t *sptm_ptd_info[SPTM_MAPPING_LIMIT];

	uint8_t sptm_acct_flags[SPTM_MAPPING_LIMIT];

	pmap_retype_epoch_t retype_epoch;

	sptm_guest_dispatch_t sptm_guest_dispatch;

	pmap_paddr_t sptm_guest_dispatch_paddr;

	uint16_t sptm_cpu_id;

	uint64_t sptm_trace_buffer_read_index;

	uint64_t sptm_trace_prev_state;
} __attribute__((aligned(PMAP_SPTM_PCPU_ALIGN))) pmap_sptm_percpu_data_t;
struct pmap_io_range {
	uint64_t addr;

	uint64_t len;





	uint32_t wimg;

	uint32_t signature;
} pmap_io_range_t;
struct pmap_io_filter_entry {
	uint32_t signature;

	uint16_t offset;

	uint16_t length;
} pmap_io_filter_entry_t;
struct page_table_level_info {
	const uint64_t size;
	const uint64_t offmask;
	const uint64_t shift;
	const uint64_t index_mask;
	const uint64_t valid_mask;
	const uint64_t type_mask;
	const uint64_t type_block;
};
struct page_table_ops {
	bool (*alloc_id)(pmap_t pmap);
	void (*free_id)(pmap_t pmap);
	void (*flush_tlb_region_async)(vm_offset_t va, size_t length, pmap_t pmap, bool last_level_only);
	void (*flush_tlb_async)(pmap_t pmap);
	pt_entry_t (*wimg_to_pte)(unsigned int wimg, pmap_paddr_t pa);
};
struct page_table_attr {
	const struct page_table_level_info * const pta_level_info;

	const struct page_table_ops * const pta_ops;

	const uintptr_t ap_ro;
	const uintptr_t ap_rw;
	const uintptr_t ap_rona;
	const uintptr_t ap_rwna;
	const uintptr_t ap_xn;
	const uintptr_t ap_x;

	const unsigned int pta_root_level;

	const unsigned int pta_commpage_level;

	const unsigned int pta_max_level;


	const uint64_t pta_tcr_value;

	const uint64_t pta_page_size;

	const uint64_t pta_page_shift;

	const uint8_t geometry_id;
};
struct pv_entry {
	struct pv_entry *pve_next;

	pt_entry_t *pve_ptep[PTE_PER_PVE];
} pv_entry_t;
struct {
	pv_entry_t *list;
	uint32_t count;
} pv_free_list_t;
struct pmap_cpu_data {
	pmap_t cpu_nested_pmap;
	const struct page_table_attr *cpu_nested_pmap_attr;
	vm_map_address_t cpu_nested_region_addr;
	vm_map_offset_t cpu_nested_region_size;
	unsigned int cpu_number;
	bool copywindow_strong_sync[CPUWINDOWS_MAX];
	bool inflight_disconnect;
	pv_free_list_t pv_free;
	pv_entry_t *pv_free_spill_marker;

};
struct pmap {
	tt_entry_t *tte;

	pmap_paddr_t ttep;


	vm_map_address_t min;

	vm_map_address_t max;


	ledger_t ledger;

	decl_lck_rw_data(, rwlock);

	queue_chain_t pmaps;

	tt_entry_t *tt_entry_free;

	struct pmap      *nested_pmap;
	vm_map_address_t nested_region_addr;
	vm_map_offset_t  nested_region_size;
	vm_map_offset_t  nested_region_true_start;
	vm_map_offset_t  nested_region_true_end;
	unsigned int     *nested_region_unnested_table_bitmap;
	unsigned int     nested_region_unnested_table_bitmap_size;


	void *          reserved0;
	void *          reserved1;
	uint8_t         reserved12;
	uint64_t        reserved2;
	uint64_t        reserved3;

	_Atomic int32_t ref_count;


	uint32_t nested_no_bounds_refcnt;

	uint16_t hw_asid;

	uint8_t sw_asid;


	bool reserved4;

	bool pmap_vm_map_cs_enforced;

	bool reserved5;
	unsigned int reserved6;
	unsigned int reserved7;

	bool reserved8;
	bool reserved9;



	bool nx_enabled;

	bool is_64bit;

	enum : uint8_t {
		
		NESTED_NO_BOUNDS_REF_NONE = 0,
		
		NESTED_NO_BOUNDS_REF_SUBORD,
		
		NESTED_NO_BOUNDS_REF_AFTER,
		
		NESTED_NO_BOUNDS_REF_BEFORE_AND_AFTER,
	} nested_no_bounds_ref_state;

	bool nested_bounds_set;


	bool reserved13;

	uint8_t type;
};
struct pmap_cpu_data_array_entry {
	pmap_cpu_data_t cpu_data;
} __attribute__((aligned(MAX_L2_CLINE_BYTES)));
struct {

	unsigned short refcnt;

	unsigned short wiredcnt;
} ptd_info_t;
struct pt_desc {
	queue_chain_t pt_page;

	union {
		struct pmap *pmap;
	};


	vm_offset_t va[PT_INDEX_MAX];

	ptd_info_t *ptd_info;
} pt_desc_t;
struct pmap_io_range {
	uint64_t addr;

	uint64_t len;





	uint32_t wimg;

	uint32_t signature;
} pmap_io_range_t;
struct pmap_io_filter_entry {
	uint32_t signature;

	uint16_t offset;

	uint16_t length;
} pmap_io_filter_entry_t;
struct page_table_level_info {
	const uint64_t size;
	const uint64_t offmask;
	const uint64_t shift;
	const uint64_t index_mask;
	const uint64_t valid_mask;
	const uint64_t type_mask;
	const uint64_t type_block;
};
struct page_table_ops {
	bool (*alloc_id)(pmap_t pmap);
	void (*free_id)(pmap_t pmap);
	void (*flush_tlb_region_async)(vm_offset_t va, size_t length, pmap_t pmap, bool last_level_only, bool strong);
	void (*flush_tlb_async)(pmap_t pmap);
	pt_entry_t (*wimg_to_pte)(unsigned int wimg, pmap_paddr_t pa);
};
struct page_table_attr {
	const struct page_table_level_info * const pta_level_info;

	const struct page_table_ops * const pta_ops;

	const uintptr_t ap_ro;
	const uintptr_t ap_rw;
	const uintptr_t ap_rona;
	const uintptr_t ap_rwna;
	const uintptr_t ap_xn;
	const uintptr_t ap_x;

	const unsigned int pta_root_level;

	const unsigned int pta_commpage_level;

	const unsigned int pta_max_level;


	const uint64_t pta_tcr_value;

	const uint64_t pta_page_size;

	const uint64_t pta_pagezero_size;

	const uint64_t pta_page_shift;
};
struct error_sparse_map {
	unsigned                start;
	unsigned                end;
};
struct error_subsystem {
	const char                      *subsys_name;
	int                             max_code;
	const char * const              *codes;
	const struct error_sparse_map   *map_table;
	int                             map_count;
};
struct error_system {
	int                             max_sub;
	const char                      *bad_sub;
	const struct error_subsystem    *subsystem;
	const struct error_sparse_map   *map_table;
	int                             map_count;
};
struct _libkernel_functions {
	unsigned long version;
	void* (*LIBKERNEL_FUNCTION_PTRAUTH(dlsym))(void*, const char*);
	void* (*LIBKERNEL_FUNCTION_PTRAUTH(malloc))(size_t);
	void(*LIBKERNEL_FUNCTION_PTRAUTH(free))(void*);
	void* (*LIBKERNEL_FUNCTION_PTRAUTH(realloc))(void*, size_t);
	void(*LIBKERNEL_FUNCTION_PTRAUTH(_pthread_exit_if_canceled))(int);

	void *reserved1;
	void *reserved2;
	void *reserved3;
	void *reserved4;
	void *reserved5;

	void(*LIBKERNEL_FUNCTION_PTRAUTH(pthread_clear_qos_tsd))(mach_port_t);

	int(*LIBKERNEL_FUNCTION_PTRAUTH(pthread_current_stack_contains_np))(const void *, size_t);

	void* (*LIBKERNEL_FUNCTION_PTRAUTH(malloc_type_malloc))(size_t, malloc_type_id_t);
	void(*LIBKERNEL_FUNCTION_PTRAUTH(malloc_type_free))(void *, malloc_type_id_t);
	void* (*LIBKERNEL_FUNCTION_PTRAUTH(malloc_type_realloc))(void *, size_t, malloc_type_id_t);

} *_libkernel_functions_t;
struct _libkernel_string_functions {
	unsigned long version;
	void (*bzero)(void *s, size_t n);
	void * (*memchr)(const void *s, int c, size_t n);
	int (*memcmp)(const void *s1, const void *s2, size_t n);
	void * (*memmove)(void *dst, const void *src, size_t n);
	void * (*memccpy)(void *__restrict dst, const void *__restrict src, int c, size_t n);
	void * (*memset)(void *b, int c, size_t len);
	char * (*strchr)(const char *s, int c);
	int (*strcmp)(const char *s1, const char *s2);
	char * (*strcpy)(char * restrict dst, const char * restrict src);
	size_t (*strlcat)(char * restrict dst, const char * restrict src, size_t maxlen);
	size_t (*strlcpy)(char * restrict dst, const char * restrict src, size_t maxlen);
	size_t (*strlen)(const char *str);
	int (*strncmp)(const char *s1, const char *s2, size_t n);
	char * (*strncpy)(char * restrict dst, const char * restrict src, size_t maxlen);
	size_t (*strnlen)(const char *s, size_t maxlen);
	char * (*strstr)(const char *s, const char *find);
} *_libkernel_string_functions_t;
struct _libkernel_voucher_functions {
	unsigned long version;
	boolean_t (*voucher_mach_msg_set)(mach_msg_header_t*);
	void (*voucher_mach_msg_clear)(mach_msg_header_t*);
	voucher_mach_msg_state_t (*voucher_mach_msg_adopt)(mach_msg_header_t*);
	void (*voucher_mach_msg_revert)(voucher_mach_msg_state_t);


	mach_msg_size_t (*voucher_mach_msg_fill_aux)(mach_msg_aux_header_t*, mach_msg_size_t);

} *_libkernel_voucher_functions_t;
struct _libkernel_late_init_config {
	unsigned long version;

	bool enable_system_version_compat;

	bool enable_ios_version_compat;

	bool enable_posix_spawn_filtering;
} *_libkernel_late_init_config_t;
struct _libkernel_init_after_boot_tasks_config {
	unsigned long version;

	bool enable_posix_spawn_filtering;
} *_libkernel_init_after_boot_tasks_config_t;
struct error_subsystem {
	const char              *subsys_name;
	int                     max_code;
	const char * const      *codes;
};
struct error_system {
	int                             max_sub;
	const char                      *bad_sub;
	const struct error_subsystem    *subsystem;
};
struct _mach_right_recv {
	mach_port_t mrr_name;
} mach_right_recv_t;
struct _mach_right_send {
	mach_port_t mrs_name;
} mach_right_send_t;
struct _mach_right_send_once {
	mach_port_t mrso_name;
} mach_right_send_once_t;
struct port_obj_tentry {
	void *pos_value;
	int pos_type;
};
struct  {
	long    code;
	long    thread;
	long    a1;
	long    a2;
	long    a3;
	long    a4;
	long    a5;
	long    a6;
} log_rec_t;
struct {
	int     datagram_pkts_sent;
	int     datagram_pkts_rcvd;
	int     srr_requests_sent;
	int     srr_bcasts_sent;
	int     srr_requests_rcvd;
	int     srr_bcasts_rcvd;
	int     srr_replies_sent;
	int     srr_replies_rcvd;
	int     srr_retries_sent;
	int     srr_retries_rcvd;
	int     srr_cfailures_sent;
	int     srr_cfailures_rcvd;
	int     deltat_dpkts_sent;
	int     deltat_acks_rcvd;
	int     deltat_dpkts_rcvd;
	int     deltat_acks_sent;
	int     deltat_oldpkts_rcvd;
	int     deltat_oospkts_rcvd;
	int     deltat_retries_sent;
	int     deltat_retries_rcvd;
	int     deltat_cfailures_sent;
	int     deltat_cfailures_rcvd;
	int     deltat_aborts_sent;
	int     deltat_aborts_rcvd;
	int     vmtp_requests_sent;
	int     vmtp_requests_rcvd;
	int     vmtp_replies_sent;
	int     vmtp_replies_rcvd;
	int     ipc_in_messages;
	int     ipc_out_messages;
	int     ipc_unblocks_sent;
	int     ipc_unblocks_rcvd;
	int     pc_requests_sent;
	int     pc_requests_rcvd;
	int     pc_replies_rcvd;
	int     pc_startups_rcvd;
	int     nn_requests_sent;
	int     nn_requests_rcvd;
	int     nn_replies_rcvd;
	int     po_ro_hints_sent;
	int     po_ro_hints_rcvd;
	int     po_token_requests_sent;
	int     po_token_requests_rcvd;
	int     po_token_replies_rcvd;
	int     po_xfer_requests_sent;
	int     po_xfer_requests_rcvd;
	int     po_xfer_replies_rcvd;
	int     po_deaths_sent;
	int     po_deaths_rcvd;
	int     ps_requests_sent;
	int     ps_requests_rcvd;
	int     ps_replies_rcvd;
	int     ps_auth_requests_sent;
	int     ps_auth_requests_rcvd;
	int     ps_auth_replies_rcvd;
	int     mallocs_or_vm_allocates;
	int     mem_allocs;
	int     mem_deallocs;
	int     mem_allocobjs;
	int     mem_deallocobjs;
	int     pkts_encrypted;
	int     pkts_decrypted;
	int     vmtp_segs_encrypted;
	int     vmtp_segs_decrypted;
	int     tcp_requests_sent;
	int     tcp_replies_sent;
	int     tcp_requests_rcvd;
	int     tcp_replies_rcvd;
	int     tcp_send;
	int     tcp_recv;
	int     tcp_connect;
	int     tcp_accept;
	int     tcp_close;
} stat_t;
struct {
	int     print_level;
	int     ipc_in;
	int     ipc_out;
	int     tracing;
	int     vmtp;
	int     netname;
	int     deltat;
	int     tcp;
	int     mem;
} debug_t;
struct {
	int     srr_max_tries;
	int     srr_retry_sec;
	int     srr_retry_usec;
	int     deltat_max_tries;
	int     deltat_retry_sec;
	int     deltat_retry_usec;
	int     deltat_msg_life;
	int     pc_checkup_interval;
	int     crypt_algorithm;
	int     transport_default;
	int     conf_network;
	int     conf_netport;
	int     timer_quantum;
	int     tcp_conn_steady;
	int     tcp_conn_opening;
	int     tcp_conn_max;
	int     compat;
	int     syslog;
	int     old_nmmonitor;
} param_t;
struct {
	u_int   port_id;
	u_int   alive;
	u_int   nport_id_high;
	u_int   nport_id_low;
	u_int   nport_receiver;
	u_int   nport_owner;
	u_int   messages_sent;
	u_int   messages_rcvd;
	u_int   send_rights_sent;
	u_int   send_rights_rcvd_sender;
	u_int   send_rights_rcvd_recown;
	u_int   rcv_rights_xferd;
	u_int   own_rights_xferd;
	u_int   all_rights_xferd;
	u_int   tokens_sent;
	u_int   tokens_requested;
	u_int   xfer_hints_sent;
	u_int   xfer_hints_rcvd;
} port_stat_t, *port_stat_ptr_t;
struct firehose_chunk_s {
	union {
		uint8_t fc_start[FIREHOSE_CHUNK_SIZE];
		struct {
			firehose_chunk_pos_u fc_pos;
			uint64_t fc_timestamp;
			uint8_t  fc_data[FIREHOSE_CHUNK_SIZE - 8 - 8];
		};
	};
} *firehose_chunk_t;
struct firehose_chunk_range_s {
	uint16_t fcr_offset; 
	uint16_t fcr_length;
} *firehose_chunk_range_t;
struct firehose_push_reply_s {
	uint64_t fpr_mem_flushed_pos;
	uint64_t fpr_io_flushed_pos;
} firehose_push_reply_t;
struct firehose_buffer_map_info_s {
	mach_vm_address_t fbmi_addr;
	mach_vm_size_t fbmi_size;
} firehose_buffer_map_info_t;
struct firehose_trace_uuid_info_s {
	uuid_t ftui_uuid;      
	uint64_t ftui_address; 
	uint64_t ftui_size;    
	char ftui_path[];      
} *firehose_trace_uuid_info_t;
struct firehose_tracepoint_s {
	firehose_tracepoint_id_u ft_id;
	uint64_t ft_thread;
	union {
		struct {
			uint64_t ft_timestamp_delta : 48;
			uint64_t ft_length : 16;
		};
		uint64_t ft_stamp_and_length;
		os_atomic(uint64_t) ft_atomic_stamp_and_length;
	};
	uint8_t ft_data[];
} *firehose_tracepoint_t;
struct firehose_loss_payload_s {
	uint64_t start_stamp; 
	uint64_t end_stamp;
	uint32_t count;
} firehose_loss_payload_s, *firehose_loss_payload_t;
struct kxld_array {
	struct kxld_array_head pools;
	size_t itemsize;        
	size_t pool_capacity;   
	u_int pool_maxitems;    
	u_int nitems;           
	u_int maxitems;         
	u_int npools;           
};
struct kxld_array_pool {
	STAILQ_ENTRY(kxld_array_pool) entries;
	u_char *buffer;         
	u_int nitems;           
};
struct kxld_dict {
	KXLDArray buckets;      
	KXLDArray resize_buckets; 
	kxld_dict_hash hash;    
	kxld_dict_cmp cmp;      
	u_int num_entries;      
	u_int resize_threshold; 
};
struct kxld_dict_iterator {
	u_int idx;
	const KXLDDict *dict;
};
struct kxld_relocator {
	RelocHasPair reloc_has_pair;
	RelocGetPairType reloc_get_pair_type;
	RelocHasGot reloc_has_got;
	ProcessReloc process_reloc;
	const struct kxld_symtab *symtab;
	const struct kxld_array *sectarray;
	const struct kxld_dict *vtables;
	const struct kxld_vtable *current_vtable;
	u_char *file;
	u_int function_align; 
	boolean_t is_32_bit;
	boolean_t swap;
	boolean_t may_scatter;
};
struct kxld_reloc {
	u_int address;
	u_int pair_address;
	u_int target;
	u_int pair_target;
	u_int target_type:3;
	u_int pair_target_type:3;
	u_int reloc_type:4;
	u_int length:2;
	u_int pcrel:1;
};
struct kxld_sect {
	char sectname[16];          
	char segname[16];           
	u_char *data;               
	KXLDArray relocs;           
	kxld_addr_t base_addr;      
	kxld_addr_t link_addr;      
	kxld_size_t size;           
	u_int sectnum;              
	u_int flags;                
	u_int align;                
	u_int reserved1;            
	u_int reserved2;            
	boolean_t allocated;        
};
struct kxld_seg {
	char segname[16];
	kxld_addr_t base_addr;
	kxld_addr_t link_addr;
	kxld_size_t vmsize;
	kxld_size_t fileoff;
	KXLDArray sects;
	u_int flags;
	vm_prot_t maxprot;
	vm_prot_t initprot;
};
struct kxld_splitinfolc {
	uint32_t    cmdsize;
	uint32_t    dataoff;
	uint32_t    datasize;
	boolean_t   has_splitinfolc;
};
struct kxld_srcversion {
	uint64_t    version;
	boolean_t   has_srcversion;
};
struct kxld_sym {
	char *name;                   
	char *alias;                  
	kxld_addr_t base_addr;        
	kxld_addr_t link_addr;        
	kxld_addr_t got_addr;         
	uint16_t desc;
	uint8_t type;
	uint8_t sectnum;              
	uint8_t relocated_sectnum;
	u_int is_absolute:1,          
	    is_section:1,             
	    is_undefined:1,           
	    is_indirect:1,            
	    is_common:1,              
	    is_external:1,            
	    is_stab:1,                
	    is_weak:1,                
	    is_resolved:1,            
	                              
	    is_obsolete:1,            
	    is_replaced:1,            
	    is_got:1,                 
	    is_cxx:1,                 
	    is_pure_virtual:1,        
	    is_class_vtable:1,        
	    is_meta_vtable:1,         
	    is_padslot:1,             
	    is_metaclass:1,           
	    is_super_metaclass_pointer:1, 
	    is_thumb:1;               
};
struct kxld_symtab_iterator {
	const KXLDSymtab *symtab;
	u_int idx;
	KXLDSymPredicateTest test;
	boolean_t negate;
};
struct kxld_section_name {
	char segname[16];
	char sectname[16];
};
struct kxld_uuid {
	u_char uuid[16];
	boolean_t has_uuid;
};
struct kxld_versionmin {
	enum kxld_versionmin_platforms platform;
	uint32_t version;
	boolean_t has_versionmin;
};
struct kxld_vtable {
	u_char *vtable;
	const char *name;
	KXLDArray entries;
	boolean_t is_patched;
};
struct kxld_vtable_patched_entry {
	char *name;
	kxld_addr_t addr;
};
struct kxld_vtable_unpatched_entry {
	const struct kxld_sym *sym;
	struct kxld_reloc *reloc;
};
struct {
	int quot;
	int rem;
} div_t;
struct {
	long quot;
	long rem;
} ldiv_t;
struct {
	long long quot;
	long long rem;
} lldiv_t;
struct Block_descriptor_1 {
	uintptr_t reserved;
	uintptr_t size;
};
struct Block_descriptor_2 {
	BlockCopyFunction copy;
	BlockDisposeFunction dispose;
};
struct Block_descriptor_3 {
	const char *signature;
	const char *layout; 
};
struct Block_descriptor_small {
	uint32_t size;

	int32_t signature;
	int32_t layout;

	int32_t copy;
	int32_t dispose;
};
struct Block_layout {
	void *isa;
	volatile int32_t flags; 
	int32_t reserved;
	BlockInvokeFunction invoke;
	struct Block_descriptor_1 *descriptor;
};
struct Block_byref {
	void *isa;
	struct Block_byref *forwarding;
	volatile int32_t flags; 
	uint32_t size;
};
struct Block_byref_2 {
	BlockByrefKeepFunction byref_keep;
	BlockByrefDestroyFunction byref_destroy;
};
struct Block_byref_3 {
	const char *layout;
};
struct subs_entry_t {
	const char * substring;
	char         substitute;
} subs_entry_t;
struct splitKextLinkInfo {
	u_char *        kextExecutable; 
	size_t          kextSize;       
	u_char *        linkedKext;     
	size_t          linkedKextSize; 
	uint64_t        vmaddr_TEXT;    
	uint64_t        vmaddr_TEXT_EXEC;
	uint64_t        vmaddr_DATA;    
	uint64_t        vmaddr_DATA_CONST;
	uint64_t        vmaddr_LINKEDIT;
	uint64_t        vmaddr_LLVM_COV;
	uint32_t        kaslr_offsets_count;
	uint32_t *      kaslr_offsets;  
} splitKextLinkInfo;
struct kxld_dependency {
	u_char      * kext;
	u_long        kext_size;
	char        * kext_name;
	u_char      * interface;
	u_long        interface_size;
	char        * interface_name;
	boolean_t     is_direct_dependency;
} KXLDDependency;
struct mkext_basic_header {
	MKEXT_HEADER_CORE
} mkext_basic_header;
struct mkext2_file_entry {
	uint32_t  compressed_size;
	uint32_t  full_size;    
	uint8_t   data[0];      
} mkext2_file_entry;
struct mkext2_header {
	MKEXT_HEADER_CORE
	uint32_t plist_offset;
	uint32_t plist_compressed_size;
	uint32_t plist_full_size;
} mkext2_header;
struct mkext_file {
	uint32_t offset;     
	uint32_t compsize;   
	uint32_t realsize;   
	uint32_t modifiedsecs; 
} mkext_file;
struct mkext_kext {
	mkext_file plist;    
	mkext_file module;   
} mkext_kext;
struct mkext_header {
	MKEXT_HEADER_CORE
	mkext_kext kext[1]; 
} mkext_header;
struct _loaded_kext_summary {
	char        name[KMOD_MAX_NAME];
	uuid_t      uuid;
	uint64_t    address;
	uint64_t    size;
	uint64_t    version;
	uint32_t    loadTag;
	uint32_t    flags;
	uint64_t    reference_list;
	uint64_t    text_exec_address;
	size_t      text_exec_size;
} OSKextLoadedKextSummary;
struct _loaded_kext_summary_header {
	uint32_t version;
	uint32_t entry_size;
	uint32_t numSummaries;
	uint32_t reserved; 
	OSKextLoadedKextSummary summaries[0];
} OSKextLoadedKextSummaryHeader;
struct z_stream_s {
	Bytef    *next_in;
	uInt     avail_in;
	uLong    total_in;

	Bytef    *next_out;
	uInt     avail_out;
	uLong    total_out;

	char     *msg;  
	struct internal_state FAR *state; 

	alloc_func zalloc; 
	free_func  zfree;
	voidpf     opaque;

	int     data_type;
	uLong   adler;  
	uLong   reserved;
} z_stream;
struct gz_header_s {
	int     text;   
	uLong   time;   
	int     xflags; 
	int     os;     
	Bytef   *extra; 
	uInt    extra_len;
	uInt    extra_max;
	Bytef   *name;  
	uInt    name_max;
	Bytef   *comment;
	uInt    comm_max;
	int     hcrc;   
	int     done;   
} gz_header;
struct { unsigned long __opaque_zero; } os_atomic_dependency_t;
struct os_log_fmt_hdr_s {
	os_log_fmt_hdr_flags_t hdr_flags;
	uint8_t hdr_cmd_cnt;
	uint8_t hdr_data[];
} *os_log_fmt_hdr_t;
struct os_log_fmt_cmd_s {
	os_log_fmt_cmd_flags_t cmd_flags : 4;
	os_log_fmt_cmd_type_t cmd_type : 4;
	uint8_t cmd_size;
	uint8_t cmd_data[];
} *os_log_fmt_cmd_t;
struct os_log_fmt_range_s {
	uint16_t offset;
	uint16_t length : 15;
	uint16_t truncated : 1;
} *os_log_fmt_range_t;
struct os_log_context_s {
	logmem_t                    *ctx_logmem;
	uint8_t                     *ctx_buffer;
	size_t                      ctx_buffer_sz;
	os_log_fmt_hdr_t            ctx_hdr;
	char                        *ctx_pubdata[OS_LOG_MAX_PUB_ARGS];
	uint16_t                    ctx_content_off; 
	uint16_t                    ctx_content_sz; 
	uint16_t                    ctx_pubdata_sz;
	uint16_t                    ctx_pubdata_cnt;
	uint8_t                     ctx_truncated : 1;
	uint8_t                     ctx_allocated : 1;
} *os_log_context_t;
struct {
	firehose_tracepoint_id_u    lp_ftid;
	uint64_t                    lp_timestamp;
	uint16_t                    lp_pub_data_size;
	uint16_t                    lp_data_size;
	firehose_stream_t           lp_stream;
} log_payload_s, *log_payload_t;
struct logmem_s {
	lck_spin_t  lm_lock;
	uint8_t     *lm_mem;
	uint8_t     *lm_mem_map;
	size_t      lm_mem_size;
	size_t      lm_cap_order;
	size_t      lm_min_order;
	size_t      lm_max_order;
	uint32_t    lm_cnt_allocations;
	uint32_t    lm_cnt_failed_size;
	uint32_t    lm_cnt_failed_full;
	uint32_t    lm_cnt_failed_lmoff;
	uint32_t    lm_cnt_free;
} logmem_t;
struct os_refcnt {
	os_ref_atomic_t ref_count;
};
struct ct_data_s {
    union {
        ush  freq;       
        ush  code;       
    } fc;
    union {
        ush  dad;        
        ush  len;        
    } dl;
} FAR ct_data;
struct tree_desc_s {
    ct_data *dyn_tree;           
    int     max_code;            
    static_tree_desc *stat_desc; 
} FAR tree_desc;
struct internal_state {
    z_streamp strm;      
    z_input_func zinput;
    z_output_func zoutput;
    int   status;        
    Bytef *pending_buf;  
    ulg   pending_buf_size; 
    Bytef *pending_out;  
    uInt   pending;      
    int   wrap;          
    gz_headerp  gzhead;  
    uInt   gzindex;      
    Byte  method;        
    int   last_flush;    

                

    uInt  w_size;        
    uInt  w_bits;        
    uInt  w_mask;        

    Bytef *window;
    

    ulg window_size;
    

    Posf *prev;
    

    Posf *head; 

    uInt  ins_h;          
    uInt  hash_size;      
    uInt  hash_bits;      
    uInt  hash_mask;      

    uInt  hash_shift;
    

    long block_start;
    

    uInt match_length;           
    IPos prev_match;             
    int match_available;         
    uInt strstart;               
    uInt match_start;            
    uInt lookahead;              

    uInt prev_length;
    

    uInt max_chain_length;
    

    uInt max_lazy_match;
    
#   define max_insert_length  max_lazy_match
    

    int level;    
    int strategy; 

    uInt good_match;
    

    int nice_match; 

                
    
    struct ct_data_s dyn_ltree[HEAP_SIZE];   
    struct ct_data_s dyn_dtree[2*D_CODES+1]; 
    struct ct_data_s bl_tree[2*BL_CODES+1];  

    struct tree_desc_s l_desc;               
    struct tree_desc_s d_desc;               
    struct tree_desc_s bl_desc;              

    ush bl_count[MAX_BITS+1];
    

    int heap[2*L_CODES+1];      
    int heap_len;               
    int heap_max;               
    

    uch depth[2*L_CODES+1];
    

    uchf *l_buf;          

    uInt  lit_bufsize;
    

    uInt last_lit;      

    ushf *d_buf;
    

    ulg opt_len;        
    ulg static_len;     
    uInt matches;       
    int last_eob_len;   


    ush bi_buf;
    
    int bi_valid;
    

} FAR deflate_state;
struct inflate_state {
    inflate_mode mode;          
    int last;                   
    int wrap;                   
    int havedict;               
    int flags;                  
    unsigned dmax;              
    unsigned long check;        
    unsigned long total;        
    gz_headerp head;            
        
    unsigned wbits;             
    unsigned wsize;             
    unsigned whave;             
    unsigned write;             
    unsigned char FAR *window;  
        
    unsigned long hold;         
    unsigned bits;              
        
    unsigned length;            
    unsigned offset;            
        
    unsigned extra;             
        
    code const FAR *lencode;    
    code const FAR *distcode;   
    unsigned lenbits;           
    unsigned distbits;          
        
    unsigned ncode;             
    unsigned nlen;              
    unsigned ndist;             
    unsigned have;              
    code FAR *next;             
    unsigned short lens[320];   
    unsigned short work[288];   
    code codes[ENOUGH];         
};
struct {
    unsigned char op;           
    unsigned char bits;         
    unsigned short val;         
} code;
struct _OSEntitlementsInterface {
	uint32_t version;
	OSEntitlements_adjustContextWithMonitor adjustContextWithMonitor;
	OSEntitlements_adjustContextWithoutMonitor adjustContextWithoutMonitor;
	OSEntitlements_queryEntitlementBoolean queryEntitlementBoolean;
	OSEntitlements_queryEntitlementBooleanWithProc queryEntitlementBooleanWithProc;
	OSEntitlements_queryEntitlementString queryEntitlementString;
	OSEntitlements_queryEntitlementStringWithProc queryEntitlementStringWithProc;
	OSEntitlements_copyEntitlementAsOSObject copyEntitlementAsOSObject;
	OSEntitlements_copyEntitlementAsOSObjectWithProc copyEntitlementAsOSObjectWithProc;
} OSEntitlementsInterface_t;
struct _TrustCacheInterface {
	uint32_t version;
	loadModule_t loadModule;
	load_t load;
	query_t query;
	getCapabilities_t getCapabilities;
	queryGetTCType_t queryGetTCType;
	queryGetCapabilities_t queryGetCapabilities;
	queryGetHashType_t queryGetHashType;
	queryGetFlags_t queryGetFlags;
	queryGetConstraintCategory_t queryGetConstraintCategory;

	constructInvalid_t constructInvalid;
	checkRuntimeForUUID_t checkRuntimeForUUID;
	extractModule_t extractModule;
	getModule_t getModule;
	getUUID_t getUUID;
} TrustCacheInterface_t;
struct _amfi {
	amfi_OSEntitlements_invalidate OSEntitlements_invalidate;
	amfi_OSEntitlements_asDict OSEntitlements_asdict;
	amfi_OSEntitlements_query OSEntitlements_query;
	amfi_OSEntitlements_get_transmuted_blob OSEntitlements_get_transmuted;
	amfi_OSEntitlements_get_xml_blob OSEntitlements_get_xml;
	coreentitlements_t CoreEntitlements;
	amfi_get_legacy_profile_exemptions get_legacy_profile_exemptions;
	amfi_get_udid get_udid;
	amfi_query_context_to_object query_context_to_object;

	TrustCacheInterface_t TrustCache;

	OSEntitlementsInterface_t OSEntitlements;

} amfi_t;
struct _apple_encrypted_archive {
	apple_encrypted_archive_get_state_size   aea_get_state_size;
	apple_encrypted_archive_initialize_state aea_initialize_state;
	apple_encrypted_archive_open             aea_open;
	apple_encrypted_archive_write            aea_write;
	apple_encrypted_archive_close            aea_close;
} apple_encrypted_archive_t;
struct _OSUnalignedU16 {
	volatile uint16_t __val;
} __attribute__((__packed__));
struct _OSUnalignedU32 {
	volatile uint32_t __val;
} __attribute__((__packed__));
struct _OSUnalignedU64 {
	volatile uint64_t __val;
} __attribute__((__packed__));
struct list_head {
	struct list_head *prev;
	struct list_head *next;
};
struct OSKextGrabPgoStruct {
	bool metadata;
	uint64_t *pSize;
	char *pBuffer;
	uint64_t bufferSize;
	int err;
	struct list_head list_head;
};
struct OSKextAccount {
	vm_allocation_site_t site;

	uint32_t             loadTag;
	OSKext             * kext;
};
struct OSKextActiveAccount {
	uintptr_t       address;
	uintptr_t       address_end;
	OSKextAccount * account;
};
struct intrusive_osobject_retainer {
	static void
	retain(OSMetaClassBase const& obj)
	{
		obj.retain();
	}
	static void
	release(OSMetaClassBase const& obj)
	{
		obj.release();
	}
};
struct intrusive_tagged_osobject_retainer {
	static void
	retain(OSMetaClassBase const& obj)
	{
		obj.taggedRetain(OSTypeID(Tag));
	}
	static void
	release(OSMetaClassBase const& obj)
	{
		obj.taggedRelease(OSTypeID(Tag));
	}
};
struct object {
	struct object   *next;
	struct object   *free;
	struct object   *elements;
	OSObject        *object;
	OSSymbol        *key;                   
	int             size;
	void            *data;                  
	char            *string;                
	int             string_alloc_length;
	long long       number;                 
	int             idref;
} object_t;
struct parser_state {
	const char      *parseBuffer;           
	int             parseBufferIndex;       
	int             lineNumber;             
	object_t        *objects;               
	object_t        *freeObjects;           
	OSDictionary    *tags;                  
	OSString        **errorString;          
	OSObject        *parsedObject;          
	int             parsedObjectCount;
	int             retrievedObjectCount;
} parser_state_t;
struct{
	uint8_t*       dst_ptr;
	size_t         dst_size;
	const uint8_t* src_ptr;
	size_t         src_size;

	void*          state;
} compression_stream_t;
struct{
	compression_stream_init_proc                compression_stream_init;
	compression_stream_reinit_proc              compression_stream_reinit;
	compression_stream_destroy_proc             compression_stream_destroy;
	compression_stream_process_proc             compression_stream_process;
	compression_stream_identify_algorithm_proc  compression_stream_identify_algorithm;

	compression_encode_scratch_buffer_size_proc compression_encode_scratch_buffer_size;
	compression_encode_buffer_proc              compression_encode_buffer;
	compression_decode_scratch_buffer_size_proc compression_decode_scratch_buffer_size;
	compression_decode_buffer_proc              compression_decode_buffer;
} compression_ki_t;
struct _ca_event {
	struct mpsc_queue_chain link;
	const char *format_str;
	void *data;
};
struct _coretrust {
	coretrust_CTEvaluateAMFICodeSignatureCMS_t CTEvaluateAMFICodeSignatureCMS;
	coretrust_CTEvaluateAMFICodeSignatureCMSPubKey_t CTEvaluateAMFICodeSignatureCMSPubKey;
	coretrust_CTEvaluateProvisioningProfile_t CTEvaluateProvisioningProfile;
	coretrust_CTParseKey_t CTParseKey;
	coretrust_CTParseAmfiCMS_t CTParseAmfiCMS;
	coretrust_CTVerifyAmfiCMS_t CTVerifyAmfiCMS;
	coretrust_CTVerifyAmfiCertificateChain_t CTVerifyAmfiCertificateChain;
} coretrust_t;
struct{
	cccbc_ctx_decl(AES_CBC_CTX_MAX_SIZE, ctx);
} aes_decrypt_ctx;
struct{
	cccbc_ctx_decl(AES_CBC_CTX_MAX_SIZE, ctx);
} aes_encrypt_ctx;
struct{
	aes_decrypt_ctx decrypt;
	aes_encrypt_ctx encrypt;
} aes_ctx;
struct {
	ccxts_ctx_decl(AES_XTS_CTX_MAX_SIZE, enc);
	ccxts_ctx_decl(AES_XTS_CTX_MAX_SIZE, dec);
} symmetric_xts;
struct{
	ccecb_ctx_decl(DES_ECB_CTX_MAX_SIZE, enc);
	ccecb_ctx_decl(DES_ECB_CTX_MAX_SIZE, dec);
} des_ecb_key_schedule;
struct{
	ccecb_ctx_decl(DES3_ECB_CTX_MAX_SIZE, enc);
	ccecb_ctx_decl(DES3_ECB_CTX_MAX_SIZE, dec);
} des3_ecb_key_schedule;
struct {
	u_int32_t state[4];     
	u_int32_t count[2];     
	unsigned char buffer[64];       
} MD5_CTX;
struct ccchacha20poly1305_fns {
	const struct ccchacha20poly1305_info *(*info)(void);
	int (*init)(const struct ccchacha20poly1305_info *info, ccchacha20poly1305_ctx *ctx, const uint8_t *key);
	int (*reset)(const struct ccchacha20poly1305_info *info, ccchacha20poly1305_ctx *ctx);
	int (*setnonce)(const struct ccchacha20poly1305_info *info, ccchacha20poly1305_ctx *ctx, const uint8_t *nonce);
	int (*incnonce)(const struct ccchacha20poly1305_info *info, ccchacha20poly1305_ctx *ctx, uint8_t *nonce);
	int (*aad)(const struct ccchacha20poly1305_info *info, ccchacha20poly1305_ctx *ctx, size_t nbytes, const void *aad);
	int (*encrypt)(const struct ccchacha20poly1305_info *info, ccchacha20poly1305_ctx *ctx, size_t nbytes, const void *ptext, void *ctext);
	int (*finalize)(const struct ccchacha20poly1305_info *info, ccchacha20poly1305_ctx *ctx, uint8_t *tag);
	int (*decrypt)(const struct ccchacha20poly1305_info *info, ccchacha20poly1305_ctx *ctx, size_t nbytes, const void *ctext, void *ptext);
	int (*verify)(const struct ccchacha20poly1305_info *info, ccchacha20poly1305_ctx *ctx, const uint8_t *tag);
} *ccchacha20poly1305_fns_t;
struct crypto_functions {
	ccdigest_init_fn_t ccdigest_init_fn;
	ccdigest_update_fn_t ccdigest_update_fn;
	ccdigest_final_fn_t ccdigest_final_fn;
	ccdigest_fn_t ccdigest_fn;
	const struct ccdigest_info * ccmd5_di;
	const struct ccdigest_info * ccsha1_di;
	const struct ccdigest_info * ccsha256_di;
	const struct ccdigest_info * ccsha384_di;
	const struct ccdigest_info * ccsha512_di;

	cchmac_init_fn_t cchmac_init_fn;
	cchmac_update_fn_t cchmac_update_fn;
	cchmac_final_fn_t cchmac_final_fn;
	cchmac_fn_t cchmac_fn;

	const struct ccmode_ecb *ccaes_ecb_encrypt;
	const struct ccmode_ecb *ccaes_ecb_decrypt;
	const struct ccmode_cbc *ccaes_cbc_encrypt;
	const struct ccmode_cbc *ccaes_cbc_decrypt;
	const struct ccmode_ctr *ccaes_ctr_crypt;
	const struct ccmode_xts *ccaes_xts_encrypt;
	const struct ccmode_xts *ccaes_xts_decrypt;
	const struct ccmode_gcm *ccaes_gcm_encrypt;
	const struct ccmode_gcm *ccaes_gcm_decrypt;

	ccgcm_init_with_iv_fn_t ccgcm_init_with_iv_fn;
	ccgcm_inc_iv_fn_t ccgcm_inc_iv_fn;

	ccchacha20poly1305_fns_t ccchacha20poly1305_fns;

	const struct ccmode_ecb *ccdes_ecb_encrypt;
	const struct ccmode_ecb *ccdes_ecb_decrypt;
	const struct ccmode_cbc *ccdes_cbc_encrypt;
	const struct ccmode_cbc *ccdes_cbc_decrypt;
	const struct ccmode_ecb *cctdes_ecb_encrypt;
	const struct ccmode_ecb *cctdes_ecb_decrypt;
	const struct ccmode_cbc *cctdes_cbc_encrypt;
	const struct ccmode_cbc *cctdes_cbc_decrypt;
	ccdes_key_is_weak_fn_t ccdes_key_is_weak_fn;
	ccdes_key_set_odd_parity_fn_t ccdes_key_set_odd_parity_fn;
	ccpad_cts3_crypt_fn_t ccpad_cts3_encrypt_fn;
	ccpad_cts3_crypt_fn_t ccpad_cts3_decrypt_fn;

	ccrng_fn_t ccrng_fn;

	ccrsa_make_pub_fn_t        ccrsa_make_pub_fn;
	ccrsa_verify_pkcs1v15_fn_t ccrsa_verify_pkcs1v15_fn;

	crypto_random_generate_fn_t random_generate_fn;
	crypto_random_uniform_fn_t random_uniform_fn;
	crypto_random_kmem_ctx_size_fn_t random_kmem_ctx_size_fn;
	crypto_random_kmem_init_fn_t random_kmem_init_fn;

	crypto_digest_ctx_size_fn_t digest_ctx_size_fn;
	crypto_digest_init_fn_t digest_init_fn;
	crypto_digest_update_fn_t digest_update_fn;
	crypto_digest_final_fn_t digest_final_fn;
	crypto_digest_fn_t digest_fn;

	crypto_hmac_ctx_size_fn_t hmac_ctx_size_fn;
	crypto_hmac_init_fn_t hmac_init_fn;
	crypto_hmac_update_fn_t hmac_update_fn;
	crypto_hmac_final_generate_fn_t hmac_final_generate_fn;
	crypto_hmac_final_verify_fn_t hmac_final_verify_fn;
	crypto_hmac_generate_fn_t hmac_generate_fn;
	crypto_hmac_verify_fn_t hmac_verify_fn;
} *crypto_functions_t;
struct{
	ccrsa_pub_ctx_decl(ccn_sizeof(RSA_MAX_KEY_BITSIZE), key);
} rsa_pub_ctx;
struct sha1_ctxt {
	union {
		u_int8_t        b8[20];
		u_int32_t       b32[5]; 
	} h;
	union {
		u_int8_t        b8[8];
		u_int32_t       b32[2];
		u_int64_t       b64[1]; 
	} c;
	union {
		u_int8_t        b8[64];
		u_int32_t       b32[16]; 
	} m;
	u_int8_t        count;          
} SHA1_CTX;
struct {
	ccdigest_ctx_decl(CCSHA256_STATE_SIZE, CCSHA256_BLOCK_SIZE, ctx);
} SHA256_CTX;
struct SHA512_CTX {
	ccdigest_ctx_decl(CCSHA512_STATE_SIZE, CCSHA512_BLOCK_SIZE, ctx);
} SHA512_CTX;
struct _image4_dlxk_interface {
	image4_struct_version_t dlxk_version;
	image4_xnu_dlxk_fld_decl(coprocessor_host);
	image4_xnu_dlxk_fld_decl(coprocessor_ap);
	image4_xnu_dlxk_fld_decl(coprocessor_ap_local);
	image4_xnu_dlxk_fld_decl(coprocessor_cryptex1);
	image4_xnu_dlxk_fld_decl(coprocessor_sep);
	image4_xnu_dlxk_fld_decl(coprocessor_x86);
	image4_xnu_dlxk_fld_decl(environment_init);
	image4_xnu_dlxk_fld_decl(environment_new);
	image4_xnu_dlxk_fld_decl(environment_set_secure_boot);
	image4_xnu_dlxk_fld_decl(environment_set_callbacks);
	image4_xnu_dlxk_fld_decl(environment_copy_nonce_digest);
	image4_xnu_dlxk_fld_decl(environment_roll_nonce);
	image4_xnu_dlxk_fld_decl(environment_generate_nonce_proposal);
	image4_xnu_dlxk_fld_decl(environment_commit_nonce_proposal);
	image4_xnu_dlxk_fld_decl(environment_get_nonce_handle);
	image4_xnu_dlxk_fld_decl(environment_destroy);
	image4_xnu_dlxk_fld_decl(trust_init);
	image4_xnu_dlxk_fld_decl(trust_new);
	image4_xnu_dlxk_fld_decl(trust_set_payload);
	image4_xnu_dlxk_fld_decl(trust_set_booter);
	image4_xnu_dlxk_fld_decl(trust_record_property_bool);
	image4_xnu_dlxk_fld_decl(trust_record_property_integer);
	image4_xnu_dlxk_fld_decl(trust_record_property_data);
	image4_xnu_dlxk_fld_decl(trust_evaluate);
	image4_xnu_dlxk_fld_decl(trust_destroy);
	image4_xnu_dlxk_fld_decl(trust_evaluation_exec);
	image4_xnu_dlxk_fld_decl(trust_evaluation_preflight);
	image4_xnu_dlxk_fld_decl(trust_evaluation_sign);
	image4_xnu_dlxk_fld_decl(trust_evaluation_boot);
	image4_xnu_dlxk_fld_decl(cs_trap_resolve_handler);
	image4_xnu_dlxk_fld_decl(cs_trap_vector_size);
	image4_xnu_dlxk_fld_decl(trust_evaluation_normalize);
	image4_xnu_dlxk_fld_decl(environment_identify);
	image4_xnu_dlxk_fld_decl(environment_get_digest_info);
	image4_xnu_dlxk_fld_decl(environment_flash);
	image4_xnu_dlxk_fld_decl(coprocessor_resolve_from_manifest);
	image4_xnu_dlxk_fld_decl(coprocessor_bootpc);
	image4_xnu_dlxk_fld_decl(coprocessor_vma2);
	image4_xnu_dlxk_fld_decl(coprocessor_vma3);
} image4_dlxk_interface_t;
struct _img4_interface {
	const uint32_t i4if_version;
	img4_retired_t i4if_init;
	img4_retired_t i4if_set_nonce;
	img4_retired_t i4if_get_trusted_payload;
	img4_retired_t i4if_get_trusted_external_payload;
	img4_retired_t i4if_destroy;
	img4_retired_t i4if_payload_init;
	img4_retired_t i4if_payload_destroy;
	img4_retired_t i4if_environment_platform;
	img4_retired_t i4if_environment_reserved;
	img4_retired_t i4if_environment_trust_cache;
	struct {
		img4_retired_t set_nonce_domain;
		img4_nonce_domain_copy_nonce_t nonce_domain_copy_nonce;
		img4_nonce_domain_roll_nonce_t nonce_domain_roll_nonce;
		const img4_nonce_domain_t *nonce_domain_trust_cache;
	} i4if_v1;
	struct {
		img4_retired_t payload_init_with_vnode_4xnu;
	} i4if_v2;
	struct {
		const img4_nonce_domain_t *nonce_domain_pdi;
		const img4_nonce_domain_t *nonce_domain_cryptex;
	} i4if_v3;
	struct {
		img4_retired_t environment_init_identity;
	} i4if_v4;
	struct {
		img4_retired_t environment_t2;
		img4_retired_t environment_init_from_identity;
		img4_retired_t identity_init_from_environment;
	} i4if_v5;
	struct {
		img4_retired_t environment_x86;
	} i4if_v6;
	struct {
		const img4_chip_t *chip_ap_sha1;
		const img4_chip_t *chip_ap_sha2_384;
		const img4_chip_t *chip_ap_hybrid;
		const img4_chip_t *chip_ap_reduced;
		const img4_chip_t *chip_ap_software_ff00;
		const img4_chip_t *chip_ap_software_ff01;
		const img4_chip_t *chip_x86;
		const img4_chip_t *chip_x86_software_8012;
		img4_chip_init_from_buff_t chip_init_from_buff;
		img4_chip_select_personalized_ap_t chip_select_personalized_ap;
		img4_chip_select_effective_ap_t chip_select_effective_ap;
		img4_chip_instantiate_t chip_instantiate;
		img4_chip_custom_t chip_custom;
		img4_firmware_new_t firmware_new;
		img4_firmware_new_from_vnode_4xnu_t firmware_new_from_vnode_4xnu;
		img4_firmware_init_from_buff_t firmware_init_from_buff;
		img4_firmware_init_t firmware_init;
		img4_firmware_attach_manifest_t firmware_attach_manifest;
		img4_firmware_execute_t firmware_execute;
		img4_firmware_destroy_t firmware_destroy;
		img4_image_get_bytes_t image_get_bytes;
		img4_image_get_property_bool_t image_get_property_bool;
		img4_image_get_property_uint32_t image_get_property_uint32;
		img4_image_get_property_uint64_t image_get_property_uint64;
		img4_image_get_property_data_t image_get_property_data;
		const img4_object_spec_t *firmware_spec;
		const img4_object_spec_t *chip_spec;
		const img4_runtime_t *runtime_default;
		const img4_runtime_t *runtime_pmap_cs;
		img4_buff_dealloc_t buff_dealloc;
	} i4if_v7;
	struct {
		const img4_chip_t *chip_ap_permissive;
		const img4_chip_t *chip_ap_hybrid_medium;
		const img4_chip_t *chip_ap_hybrid_relaxed;
	} i4if_v8;
	struct {
		img4_firmware_evaluate_t firmware_evaluate;
	} i4if_v9;
	struct {
		img4_firmware_select_chip_t firmware_select_chip;
	} i4if_v10;
	struct {
		
		
		
		
		
		
		
		const img4_chip_t *chip_ap_datacenter_development;
		const img4_chip_t *chip_ap_intransigent;
		const img4_chip_t *chip_ap_category;
		const img4_chip_t *chip_ap_ddi;
		const img4_chip_t *chip_ap_developer_disk_image;
		const img4_chip_t *chip_ap_software_ff06;
		const img4_chip_t *chip_ap_supplemental;
		const img4_runtime_object_spec_t *runtime_object_spec_supplemental_root;
		img4_runtime_find_object_spec_t runtime_find_object_spec;
		img4_runtime_execute_object_t runtime_execute_object;
		img4_runtime_copy_object_t runtime_copy_object;
	} i4if_v11;
	struct {
		const img4_nonce_domain_t *nonce_domain_ddi;
		const img4_nonce_domain_t *nonce_domain_ephemeral_cryptex;
		const img4_chip_t *chip_ap_category_ff02;
		const img4_chip_t *chip_ap_category_ff03;
		const img4_chip_t *chip_ap_category_ff04_f0;
		const img4_chip_t *chip_ap_category_ff04_f1;
		const img4_chip_t *chip_ap_category_ff04_f2;
		const img4_chip_t *chip_ap_category_ff04_f3;
		img4_chip_select_personalized_ap_t chip_select_categorized_ap;
	} i4if_v12;
	struct {
		const img4_chip_t *chip_ap_vma2;
		const img4_chip_t *chip_ap_vma2_clone;
		const img4_object_spec_t *pmap_data_spec;
	} i4if_v13;
	struct {
		img4_nonce_domain_preroll_nonce_t nonce_domain_preroll_nonce;
	} i4if_v14;
	struct {
		img4_get_manifest_t get_manifest;
		img4_get_payload_t get_payload;
	} i4if_v15;
	struct {
		img4_chip_select_personalized_ap_t chip_select_personalized_sep;
		const img4_nonce_domain_t *nonce_domain_cryptex1_boot;
		const img4_nonce_domain_t *nonce_domain_cryptex1_asset;
	} i4if_v16;
	struct {
		img4_chip_select_personalized_ap_t chip_select_cryptex1_boot;
		img4_chip_select_personalized_ap_t chip_select_cryptex1_preboot;
		const img4_chip_t *chip_cryptex1_boot;
		const img4_chip_t *chip_cryptex1_boot_reduced;
		const img4_chip_t *chip_cryptex1_boot_x86;
		const img4_chip_t *chip_cryptex1_boot_vma2;
		const img4_chip_t *chip_cryptex1_preboot;
		const img4_chip_t *chip_cryptex1_preboot_reduced;
		const img4_chip_t *chip_cryptex1_preboot_x86;
		const img4_chip_t *chip_cryptex1_preboot_vma2;
		const img4_chip_t *chip_cryptex1_asset;
	} i4if_v17;
	struct {
		const img4_nonce_domain_t *nonce_domain_cryptex1_snuf_stub;
		const img4_chip_t *chip_cryptex1_asset_x86;
		const img4_chip_t *chip_cryptex1_boot_proposal;
		const img4_chip_t *chip_cryptex1_boot_reduced_proposal;
		const img4_chip_t *chip_cryptex1_boot_vma2_proposal;
		const img4_chip_t *chip_cryptex1_boot_vma2_clone_proposal;
		img4_chip_get_cryptex1_boot_t chip_get_cryptex1_boot;
		img4_chip_get_cryptex1_boot_t chip_get_cryptex1_boot_proposal;
		img4_image_get_property_bool_t image_get_entitlement_bool;
		img4_image_get_property_uint32_t image_get_entitlement_uint32;
		img4_image_get_property_uint64_t image_get_entitlement_uint64;
		img4_image_get_property_data_t image_get_entitlement_data;
		const img4_runtime_object_spec_t *runtime_object_spec_local_policy;
		const img4_chip_t *chip_ap_local_blessed;
	} i4if_v18;
	struct {
		img4_nonce_domain_peek_nonce_t nonce_domain_peek_nonce;
		const img4_chip_t *chip_cryptex1_boot_relaxed_x86;
		const img4_chip_t *chip_cryptex1_preboot_relaxed_x86;
		const img4_chip_t *chip_cryptex1_boot_static_x86;
		const img4_chip_t *chip_cryptex1_preboot_static_x86;
	} i4if_v19;
	struct {
		img4_nonce_domain_get_from_handle_t nonce_domain_get_from_handle;
		const img4_chip_t *chip_cryptex1_generic;
		const img4_chip_t *chip_cryptex1_generic_supplemental;
		const img4_chip_t *chip_cryptex1_generic_x86;
	} i4if_v20;
} img4_interface_t;
struct {
	uint32_t    base_bucket_width;
	uint32_t    scale_flag;       
	uint32_t    segment_idx;      
	uint32_t    segment_bucket_count;
} __attribute((packed)) IOHistogramSegmentConfig;
struct {
	uint64_t    samples;
	uint64_t    mean;
	uint64_t    variance;
	uint64_t    reserved;
} __attribute((packed)) IONormDistReportValues;
struct {
	int64_t    simple_value;
	uint64_t    reserved1;
	uint64_t    reserved2;
	uint64_t    reserved3;
} __attribute((packed)) IOSimpleReportValues;
struct {
	int64_t    simple_values[IOR_VALUES_PER_ELEMENT];
} __attribute((packed)) IOSimpleArrayReportValues;
struct {
	uint64_t    state_id;       
	uint64_t    intransitions;  
	uint64_t    upticks;        
	uint64_t    last_intransition;
} __attribute((packed)) IOStateReportValues;
struct {
	uint64_t    bucket_hits;
	int64_t     bucket_min;
	int64_t     bucket_max;
	int64_t     bucket_sum;
} __attribute((packed)) IOHistogramReportValues;
struct {
	uint8_t     report_format;  
	uint8_t     reserved;       
	uint16_t    categories;     
	uint16_t    nelements;      

	int16_t     element_idx;    
	                            
} __attribute((packed)) IOReportChannelType;
struct {
	uint64_t                channel_id;
	IOReportChannelType     channel_type;
} IOReportChannel;
struct {
	uint32_t                nchannels;
	IOReportChannel         channels[];
} IOReportChannelList;
struct {
	uint64_t                provider_id;
	IOReportChannel         channel;
} IOReportInterest;
struct {
	uint32_t                ninterests;
	IOReportInterest        interests[];
} IOReportInterestList;
struct {
	uint64_t                v[IOR_VALUES_PER_ELEMENT];
} __attribute((packed)) IOReportElementValues;
struct {
	uint64_t                provider_id;
	uint64_t                channel_id;
	IOReportChannelType     channel_type;
	uint64_t                timestamp;
	IOReportElementValues   values;
} __attribute((packed)) IOReportElement;
struct IORPCMessageMach {
	mach_msg_header_t          msgh;
	mach_msg_body_t            msgh_body;
	mach_msg_port_descriptor_t objects[0];
};
struct IORPCMessage {
	uint64_t         msgid;
	uint64_t         flags;
	uint64_t         objectRefs;
	OSObjectRef      objects[0];
};
struct IORPCMessageErrorReturnContent {
	IORPCMessage  hdr;
	kern_return_t result;
	uint32_t      pad;
};
struct IORPCMessageErrorReturn {
	IORPCMessageMach mach;
	IORPCMessageErrorReturnContent content;
};
struct IORPC {
	IORPCMessageMach * message;
	IORPCMessageMach * reply;
	uint32_t           sendSize;
	uint32_t           replySize;
	IORPCMessage     * kernelContent;
};
struct OSClassDescription {
	uint32_t    descriptionSize;

	char        name[96];
	char        superName[96];

	uint32_t    methodOptionsSize;
	uint32_t    methodOptionsOffset;
	uint32_t    metaMethodOptionsSize;
	uint32_t    metaMethodOptionsOffset;
	uint32_t    queueNamesSize;
	uint32_t    queueNamesOffset;
	uint32_t    methodNamesSize;
	uint32_t    methodNamesOffset;
	uint32_t    metaMethodNamesSize;
	uint32_t    metaMethodNamesOffset;

	uint64_t    flags;

	uint64_t    resv1[8];

	uint64_t    methodOptions[0];
	uint64_t    metaMethodOptions[0];

	char        dispatchNames[0];
	char        methodNames[0];
	char        metaMethodNames[0];
};
struct{
	IOPhysicalAddress   address;
	IOByteCount         length;
} IOPhysicalRange;
struct{
	IOVirtualAddress    address;
	IOByteCount         length;
} IOVirtualRange;
struct {
	int value;
	const char *name;
} IONamedValue;
struct queue_entry {
	struct queue_entry      *next;          
	struct queue_entry      *prev;          
};
struct aks_raw_key_t {
	uint32_t  keybytecount;
	uint8_t   keybytes[AKS_MAX_KEY_SIZE];
};
struct aks_volume_key_t {
	uint32_t      algorithm;
	aks_raw_key_t key;
};
struct _notifyMsg {
	mach_msg_header_t h;
};
struct _IODataQueueEntry {
	UInt32  size;
	UInt8   data[4];
} IODataQueueEntry;
struct _IODataQueueMemory {
	UInt32            queueSize;
	volatile UInt32   head;
	volatile UInt32   tail;
	IODataQueueEntry  queue[1];
} IODataQueueMemory;
struct _IODataQueueAppendix {
	UInt32            version;
	mach_msg_header_t msgh;
} IODataQueueAppendix;
struct IONVRAMDescriptor {
	unsigned int format:4;
	unsigned int marker:1;
	unsigned int bridgeCount:3;
	unsigned int busNum:2;
	unsigned int bridgeDevices:6 * 5;
	unsigned int functionNum:3;
	unsigned int deviceNum:5;
} __attribute__((aligned(2), packed));
struct IOHibernateHibSegment {
	uint32_t    iBootMemoryRegion;
	uint32_t    physPage;
	uint32_t    pageCount;
	uint32_t    protection;
};
struct IOHibernateHibSegInfo {
	struct IOHibernateHibSegment    segments[NUM_HIBSEGINFO_SEGMENTS];
	uint8_t                         hmac[HIBERNATE_HMAC_SIZE];
};
struct IOPolledFileExtent {
	uint64_t    start;
	uint64_t    length;
};
struct {
	IOHibernateHibSegment hib_segments[NUM_HIBSEGINFO_SEGMENTS];

	uint64_t dram_base;
	uint64_t dram_size;

	uint64_t dt_start_paddr;

	uint64_t dt_size;

	uint64_t sptm_entry_phys;

	uint32_t sptm_phys_page;
	uint32_t sptm_page_count;

	uint64_t sptm_ro_start_phys;
	uint64_t xnu_ro_start_phys;
	uint64_t txm_ro_start_phys;
	uint64_t sptm_ro_start_virt;
	uint64_t xnu_ro_start_virt;
	uint64_t txm_ro_start_virt;

	uint64_t sptm_rm_start_phys;
	uint64_t sptm_rm_end_phys;
	uint64_t sptm_le_end_phys;

	uint64_t consistent_debug_page_phys;

	uint64_t early_debug_consistent_debug_page;
	uint64_t global_debug_consistent_debug_page;

	uint64_t sptm_slide;

	uint64_t ctrr_a_begin;
	uint64_t ctrr_a_end;
	uint64_t ctrr_c_begin;
	uint64_t ctrr_c_end;
	uint64_t ctrr_d_begin;
	uint64_t ctrr_d_end;

	uint64_t hibtext_stack_top;

} hib_protected_metadata_t;
struct hib_exclave_iv {
	uint8_t iv[CCGCM_IV_NBYTES];
	uint8_t tag[CCGCM_BLOCK_NBYTES];
};
struct IOHibernateImageHeader {
	uint64_t    imageSize;
	uint64_t    image1Size;

	uint32_t    restore1CodePhysPage;
	uint32_t    reserved1;
	uint64_t    restore1CodeVirt;
	uint32_t    restore1PageCount;
	uint32_t    restore1CodeOffset;
	uint32_t    restore1StackOffset;

	uint32_t    pageCount;
	uint32_t    bitmapSize;

	uint32_t    restore1Sum;
	uint32_t    image1Sum;
	uint32_t    image2Sum;

	uint32_t    actualRestore1Sum;
	uint32_t    actualImage1Sum;
	uint32_t    actualImage2Sum;

	uint32_t    actualUncompressedPages;
	uint32_t    conflictCount;
	uint32_t    nextFree;

	uint32_t    signature;
	uint32_t    processorFlags;

	uint32_t    runtimePages;
	uint32_t    runtimePageCount;
	uint64_t    runtimeVirtualPages __attribute__ ((packed));

	uint32_t    performanceDataStart;
	uint32_t    performanceDataSize;

	uint64_t    encryptStart __attribute__ ((packed));
	uint64_t    machineSignature __attribute__ ((packed));

	uint32_t    previewSize;
	uint32_t    previewPageListSize;

	uint32_t    diag[4];

	uint32_t    handoffPages;
	uint32_t    handoffPageCount;

	uint32_t    systemTableOffset;

	uint32_t    debugFlags;
	uint32_t    options;
	uint64_t    sleepTime __attribute__ ((packed));
	uint32_t    compression;

	uint8_t     bridgeBootSessionUUID[16];

	uint64_t    lastHibAbsTime __attribute__ ((packed));
	union {
		uint64_t    lastHibContTime;
		uint64_t    hwClockOffset;
	} __attribute__ ((packed));
	uint64_t    kernVirtSlide __attribute__ ((packed));

	uint32_t    reserved[45];

	uint64_t    kernelSlide __attribute__ ((packed));      

	uint32_t    booterTime0;
	uint32_t    booterTime1;
	uint32_t    booterTime2;

	uint32_t    booterStart;
	uint32_t    smcStart;
	uint32_t    connectDisplayTime;
	uint32_t    splashTime;
	uint32_t    booterTime;
	uint32_t    trampolineTime;

	uint64_t    encryptEnd __attribute__ ((packed));
	uint64_t    deviceBase __attribute__ ((packed));
	uint32_t    deviceBlockSize;


	uint32_t    segmentsFileOffset;

	uint32_t    imageHeaderHMACSize;
	uint8_t     imageHeaderHMAC[HIBERNATE_HMAC_SIZE];

	uint8_t     handoffHMAC[HIBERNATE_HMAC_SIZE];

	uint8_t     image1PagesHMAC[HIBERNATE_HMAC_SIZE];
	uint8_t     image2PagesHMAC[HIBERNATE_HMAC_SIZE];

	IOHibernateHibSegInfo hibSegInfo;

	uint8_t     rorgnHMAC[HIBERNATE_HMAC_SIZE];
	uint8_t     rorgnSHA256[HIBERNATE_SHA256_SIZE];

	hib_protected_metadata_t protected_metadata;

	uint8_t     protected_metadata_hmac[HIBERNATE_HMAC_SIZE];

	uint8_t     sptm_rorgn_hmac[HIBERNATE_HMAC_SIZE];

	uint8_t     xnu_rorgn_hmac[HIBERNATE_HMAC_SIZE];

	uint8_t     hib_segs_hmac[HIBERNATE_HMAC_SIZE];

	struct hib_exclave_iv exclave_iv;

	uint32_t            fileExtentMapSize;
	IOPolledFileExtent  fileExtentMap[2];
};
struct hibernate_bitmap_t {
	uint32_t    first_page;
	uint32_t    last_page;
	uint32_t    bitmapwords;
	uint32_t    bitmap[0];
};
struct hibernate_page_list_t {
	uint32_t              list_size;
	uint32_t              page_count;
	uint32_t              bank_count;
	hibernate_bitmap_t    bank_bitmap[0];
};
struct IOHibernateHandoff {
	uint32_t type;
	uint32_t bytecount;
	uint8_t  data[];
};
struct hibernate_graphics_t {
	uint64_t physicalAddress; 
	int32_t  gfxStatus;     
	uint32_t rowBytes;              
	uint32_t width;                 
	uint32_t height;                
	uint32_t depth;                 

	uint8_t progressSaveUnder[kIOHibernateProgressCount][kIOHibernateProgressSaveUnderSize];
};
struct hibernate_preview_t {
	uint32_t  imageCount;   
	uint32_t  width;        
	uint32_t  height;       
	uint32_t  depth;        
	uint64_t  lockTime;     
	uint32_t  reservedG[7]; 
	uint32_t  reservedK[8]; 
};
struct hibernate_statistics_t {
	uint64_t image1Size;
	uint64_t imageSize;
	uint32_t image1Pages;
	uint32_t imagePages;
	uint32_t booterStart;
	uint32_t smcStart;
	uint32_t booterDuration;
	uint32_t booterConnectDisplayDuration;
	uint32_t booterSplashDuration;
	uint32_t booterDuration0;
	uint32_t booterDuration1;
	uint32_t booterDuration2;
	uint32_t trampolineDuration;
	uint32_t kernelImageReadDuration;

	uint32_t graphicsReadyTime;
	uint32_t wakeNotificationTime;
	uint32_t lockScreenReadyTime;
	uint32_t hidReadyTime;

	uint32_t wakeCapability;
	uint32_t hibCount;
	uint32_t resvA[14];
};
struct hibernate_scratch {
	uint8_t  *curPage;
	size_t    curPagePos;
	uint64_t  curPos;
	uint64_t  totalLength;
	ppnum_t  headPage;
	hibernate_page_list_t *map;
	uint32_t *nextFree;
};
struct IOInterruptAccountingData {
	OSObject * owner; 
	queue_chain_t chain;
	int interruptIndex;

	bool enablePrimaryTimestamp;
	volatile uint64_t primaryTimestamp __attribute__((aligned(8)));

	volatile uint64_t interruptStatistics[IA_NUM_INTERRUPT_ACCOUNTING_STATISTICS] __attribute__((aligned(8)));
};
struct IOInterruptVector {
	volatile char               interruptActive;
	volatile char               interruptDisabledSoft;
	volatile char               interruptDisabledHard;
	volatile char               interruptRegistered;
	IOLock *                    interruptLock;
	IOService *                 nub;
	int                         source;
	void *                      target;
	IOInterruptHandler          handler;
	void *                      refCon;
	IOSharedInterruptController *sharedController;
};
struct {
	uint32_t    base_bucket_width;
	uint32_t    scale_flag;       
	uint32_t    segment_idx;      
	uint32_t    segment_bucket_count;
} __attribute((packed)) IOHistogramSegmentConfig;
struct {
	uint64_t    samples;
	uint64_t    mean;
	uint64_t    variance;
	uint64_t    reserved;
} __attribute((packed)) IONormDistReportValues;
struct IOKitDiagnosticsParameters {
	size_t    size;
	uint64_t  value;
	uint32_t  options;
	uint32_t  tag;
	uint32_t  zsize;
	uint32_t  reserved[8];
};
struct IOTrackingCallSiteInfo {
	uint32_t          count;
	pid_t             addressPID;
	mach_vm_address_t address;
	mach_vm_size_t    size[2];
	pid_t             btPID;
	mach_vm_address_t bt[2][kIOTrackingCallSiteBTs];
};
struct _IOUCProcessToken {
	void *  token;
	UInt32  pid;
} IOUCProcessToken;
struct IODMAMapSpecification {
	uint64_t    alignment;
	IOService * device;
	uint32_t    options;
	uint8_t     numAddressBits;
	uint8_t     resvA[3];
	uint32_t    resvB[4];
};
struct IODMAMapPageList {
	uint32_t                pageOffset;
	uint32_t                pageListCount;
	const upl_page_info_t * pageList;
};
struct IOMDDMACharacteristics {
	UInt64 fLength;
	UInt32 fSGCount;
	UInt32 fPages;
	UInt32 fPageAlign;
	ppnum_t fHighestPage;
	IODirection fDirection;
	UInt8 fIsPrepared;
};
struct IOMDDMAMapArgs {
	IOMapper            * fMapper;
	IODMACommand        * fCommand;
	IODMAMapSpecification fMapSpec;
	uint64_t              fOffset;
	uint64_t              fLength;
	uint64_t              fAlloc;
	uint64_t              fAllocLength;
};
struct IOMDDMAWalkSegmentArgs {
	UInt64 fOffset;                 
	UInt64 fIOVMAddr, fLength;
	UInt8 fMapped;                  
	UInt64 fMappedBase;             
};
struct IOPolledFileIOVars {
	IOPolledFilePollers              *  pollers;
	struct kern_direct_file_io_ref_t *  fileRef;
	OSData *                            fileExtents;
	uint64_t                            block0;
	uint32_t                         blockSize;
	uint64_t                            maxiobytes;
	uint32_t                         bufferLimit;
	uint8_t *                           buffer;
	uint32_t                         bufferSize;
	uint32_t                         bufferOffset;
	uint32_t                         bufferHalf;
	uint64_t                         extentRemaining;
	uint32_t                         lastRead;
	uint64_t                         readEnd;
	uint32_t                            flags;
	uint64_t                            fileSizeMin;
	uint64_t                            fileSizeMax;
	uint64_t                            fileSize;
	uint64_t                            position;
	uint64_t                            extentPosition;
	uint64_t                            encryptStart;
	uint64_t                            encryptEnd;
	uint64_t                            cryptBytes;
	AbsoluteTime                        cryptTime;
	IOPolledFileExtent *                extentMap;
	IOPolledFileExtent *                currentExtent;
	bool                                allocated;
};
struct IOPolledFileCryptVars {
	uint8_t aes_iv[AES_BLOCK_SIZE];
	aes_ctx ctx;
};
struct {
	uint16_t        curr_state;
	uint64_t        update_ts;
	IOReportElement elem[]; 
} IOStateReportInfo;
struct {
	int             bucketWidth;
	IOReportElement elem[]; 
} IOHistReportInfo;
struct {
	int64_t    simple_value;
	uint64_t    reserved1;
	uint64_t    reserved2;
	uint64_t    reserved3;
} __attribute((packed)) IOSimpleReportValues;
struct {
	int64_t    simple_values[IOR_VALUES_PER_ELEMENT];
} __attribute((packed)) IOSimpleArrayReportValues;
struct {
	uint64_t    state_id;       
	uint64_t    intransitions;  
	uint64_t    upticks;        
	uint64_t    last_intransition;
} __attribute((packed)) IOStateReportValues;
struct {
	uint64_t    bucket_hits;
	int64_t     bucket_min;
	int64_t     bucket_max;
	int64_t     bucket_sum;
} __attribute((packed)) IOHistogramReportValues;
struct {
	uint8_t     report_format;  
	uint8_t     reserved;       
	uint16_t    categories;     
	uint16_t    nelements;      

	int16_t     element_idx;    
	                            
} __attribute((packed)) IOReportChannelType;
struct {
	uint64_t                channel_id;
	IOReportChannelType     channel_type;
} IOReportChannel;
struct {
	uint32_t                nchannels;
	IOReportChannel         channels[];
} IOReportChannelList;
struct {
	uint64_t                provider_id;
	IOReportChannel         channel;
} IOReportInterest;
struct {
	uint32_t                ninterests;
	IOReportInterest        interests[];
} IOReportInterestList;
struct {
	uint64_t                v[IOR_VALUES_PER_ELEMENT];
} __attribute((packed)) IOReportElementValues;
struct {
	uint64_t                provider_id;
	uint64_t                channel_id;
	IOReportChannelType     channel_type;
	uint64_t                timestamp;
	IOReportElementValues   values;
} __attribute((packed)) IOReportElement;
struct IORPCMessageMach {
	mach_msg_header_t          msgh;
	mach_msg_body_t            msgh_body;
	mach_msg_port_descriptor_t objects[0];
};
struct IORPCMessage {
	uint64_t         msgid;
	uint64_t         flags;
	uint64_t         objectRefs;
	OSObjectRef      objects[0];
};
struct IORPCMessageErrorReturnContent {
	IORPCMessage  hdr;
	kern_return_t result;
	uint32_t      pad;
};
struct IORPCMessageErrorReturn {
	IORPCMessageMach mach;
	IORPCMessageErrorReturnContent content;
};
struct IORPC {
	IORPCMessageMach * message;
	IORPCMessageMach * reply;
	uint32_t           sendSize;
	uint32_t           replySize;
	IORPCMessage     * kernelContent;
};
struct OSClassDescription {
	uint32_t    descriptionSize;

	char        name[96];
	char        superName[96];

	uint32_t    methodOptionsSize;
	uint32_t    methodOptionsOffset;
	uint32_t    metaMethodOptionsSize;
	uint32_t    metaMethodOptionsOffset;
	uint32_t    queueNamesSize;
	uint32_t    queueNamesOffset;
	uint32_t    methodNamesSize;
	uint32_t    methodNamesOffset;
	uint32_t    metaMethodNamesSize;
	uint32_t    metaMethodNamesOffset;

	uint64_t    flags;

	uint64_t    resv1[8];

	uint64_t    methodOptions[0];
	uint64_t    metaMethodOptions[0];

	char        dispatchNames[0];
	char        methodNames[0];
	char        metaMethodNames[0];
};
struct IOPMDriverCallEntry {
	queue_chain_t   link;
	thread_t        thread;
	IOService *     target;
	const void  *callMethod;
};
struct IOStatisticsInterruptEventSources {
	uint32_t created;
	uint32_t produced;
	uint32_t checksForWork;
} IOStatisticsInterruptEventSources;
struct IOStatisticsTimerEventSources {
	uint32_t created;
	uint32_t openGateCalls;
	uint32_t closeGateCalls;
	uint64_t timeOnGate;
	uint32_t timeouts;
	uint32_t checksForWork;
} IOStatisticsTimerEventSources;
struct IOStatisticsDerivedEventSources {
	uint32_t created;
	uint32_t openGateCalls;
	uint32_t closeGateCalls;
	uint64_t timeOnGate;
} IOStatisticsDerivedEventSources;
struct IOStatisticsCommandGates {
	uint32_t created;
	uint32_t openGateCalls;
	uint32_t closeGateCalls;
	uint64_t timeOnGate;
	uint32_t actionCalls;
} IOStatisticsCommandGates;
struct IOStatisticsCommandQueues {
	uint32_t created;
	uint32_t actionCalls;
} IOStatisticsCommandQueues;
struct IOStatisticsUserClients {
	uint32_t created;
	uint32_t clientCalls;
} IOStatisticsUserClients;
struct IOStatisticsHeader {
	uint32_t sig; 
	uint32_t ver; 

	uint32_t seq; 

	uint32_t globalStatsOffset;
	uint32_t kextStatsOffset;
	uint32_t memoryStatsOffset;
	uint32_t classStatsOffset;
	uint32_t counterStatsOffset;
	uint32_t kextIdentifiersOffset;
	uint32_t classNamesOffset;

} IOStatisticsHeader;
struct IOStatisticsGlobal {
	uint32_t kextCount;
	uint32_t classCount;
	uint32_t workloops;
} IOStatisticsGlobal;
struct IOStatisticsKext {
	uint32_t loadTag;
	uint32_t loadSize;
	uint32_t wiredSize;
	uint32_t classes; 
	uint32_t classIndexes[]; 
} IOStatisticsKext;
struct IOStatisticsMemory {
	uint32_t allocatedSize;
	uint32_t freedSize;
	uint32_t allocatedAlignedSize;
	uint32_t freedAlignedSize;
	uint32_t allocatedContiguousSize;
	uint32_t freedContiguousSize;
	uint32_t allocatedPageableSize;
	uint32_t freedPageableSize;
} IOStatisticsMemory;
struct IOStatisticsClass {
	uint32_t classID;
	uint32_t superClassID;
	uint32_t classSize;
} IOStatisticsClass;
struct IOStatisticsCounter {
	uint32_t classID;
	uint32_t classInstanceCount;
	struct IOStatisticsUserClients userClientStatistics;
	struct IOStatisticsInterruptEventSources interruptEventSourceStatistics;
	struct IOStatisticsInterruptEventSources filterInterruptEventSourceStatistics;
	struct IOStatisticsTimerEventSources timerEventSourceStatistics;
	struct IOStatisticsCommandGates commandGateStatistics;
	struct IOStatisticsCommandQueues commandQueueStatistics;
	struct IOStatisticsDerivedEventSources derivedEventSourceStatistics;
} IOStatisticsCounter;
struct IOStatisticsKextIdentifier {
	char identifier[kIOStatisticsDriverNameLength];
} IOStatisticsKextIdentifier;
struct IOStatisticsClassName {
	char name[kIOStatisticsClassNameLength];
} IOStatisticsClassName;
struct IOStatisticsWorkLoop {
	uint32_t attachedEventSources;
	uint64_t timeOnGate;
	uint32_t kextLoadTag;
	uint32_t dependentKexts;
	uint32_t dependentKextLoadTags[];
} IOStatisticsWorkLoop;
struct IOStatisticsWorkLoopHeader {
	uint32_t sig; 
	uint32_t ver; 
	uint32_t seq; 
	uint32_t workloopCount;
	struct IOStatisticsWorkLoop workLoopStats;
} IOStatisticsWorkLoopHeader;
struct IOStatisticsUserClientCall {
	char processName[kIOStatisticsProcessNameLength];
	int32_t pid;
	uint32_t calls;
} IOStatisticsUserClientCall;
struct IOStatisticsUserClientHeader {
	uint32_t sig; 
	uint32_t ver; 
	uint32_t seq; 
	uint32_t processes;
	struct IOStatisticsUserClientCall userClientCalls[];
} IOStatisticsUserClientHeader;
struct{
	IOPhysicalAddress   address;
	IOByteCount         length;
} IOPhysicalRange;
struct{
	IOVirtualAddress    address;
	IOByteCount         length;
} IOVirtualRange;
struct {
	int value;
	const char *name;
} IONamedValue;
struct IOExternalMethod {
	IOService *         object;
	IOMethod            func;
	IOOptionBits        flags;
	IOByteCount         count0;
	IOByteCount         count1;
};
struct IOExternalAsyncMethod {
	IOService *         object;
	IOAsyncMethod       func;
	IOOptionBits        flags;
	IOByteCount         count0;
	IOByteCount         count1;
};
struct IOExternalTrap {
	IOService *         object;
	IOTrap              func;
};
struct IOExternalMethodArguments {
	uint32_t            version;

	uint32_t            selector;

	mach_port_t           asyncWakePort;
	io_user_reference_t * asyncReference;
	uint32_t              asyncReferenceCount;

	const uint64_t *    scalarInput;
	uint32_t            scalarInputCount;

	const void *        structureInput;
	uint32_t            structureInputSize;

	IOMemoryDescriptor * structureInputDescriptor;

	uint64_t *          scalarOutput;
	uint32_t            scalarOutputCount;

	void *              structureOutput;
	uint32_t            structureOutputSize;

	IOMemoryDescriptor * structureOutputDescriptor;
	uint32_t             structureOutputDescriptorSize;

	uint32_t            __reservedA;

	OSObject **         structureVariableOutputData;

	uint32_t            __reserved[30];
};
struct IOExternalMethodDispatch {
	IOExternalMethodAction function;
	uint32_t               checkScalarInputCount;
	uint32_t               checkStructureInputSize;
	uint32_t               checkScalarOutputCount;
	uint32_t               checkStructureOutputSize;
};
struct IOExternalMethodDispatch2022 {
	IOExternalMethodAction function;
	uint32_t               checkScalarInputCount;
	uint32_t               checkStructureInputSize;
	uint32_t               checkScalarOutputCount;
	uint32_t               checkStructureOutputSize;
	uint8_t                allowAsync;
	const char*            checkEntitlement;
};
struct io_filter_callbacks {
	const io_filter_resolver_t      io_filter_resolver;
	const io_filter_applier_t       io_filter_applier;
	const io_filter_release_t       io_filter_release;
};
struct OSObjectUserVars {
	IOUserServer     * userServer;
	OSBoundedArrayRef<IODispatchQueue *> queueArray;
	OSUserMetaClass  * userMeta;
	OSArray          * openProviders;
	IOService        * controllingDriver;
	unsigned long      willPowerState;
	bool               willTerminate;
	bool               didTerminate;
	bool               serverDied;
	bool               started;
	bool               stopped;
	bool               userServerPM;
	bool               willPower;
	bool               powerState;
	bool               resetPowerOnWake;
	bool               deferredRegisterService;
	uint32_t           powerOverride;
	IOLock           * uvarsLock;
};
struct OSNotificationHeader64 {
	mach_msg_size_t     size;       
	natural_t           type;
	OSAsyncReference64  reference;

};
struct IOServiceInterestContent64 {
	natural_t           messageType;
	io_user_reference_t messageArgument[1];
};
struct IOAsyncCompletionContent {
	IOReturn result;
};
struct IOMemoryDescriptorMapAllocRef {
	vm_map_t          map;
	mach_vm_address_t mapped;
	mach_vm_size_t    size;
	vm_prot_t         prot;
	vm_tag_t          tag;
	IOOptionBits      options;
};
struct IODMACommandMapSegment {
	uint64_t fDMAOffset;       
	uint64_t fMapOffset;       
	uint64_t fPageOffset;      
};
struct IODMACommandInternal {
	IOMDDMAWalkSegmentState      fState;
	IOMDDMACharacteristics       fMDSummary;

	UInt64 fPreparedOffset;
	UInt64 fPreparedLength;

	UInt32 fSourceAlignMask;

	UInt8  fCursor;
	UInt8  fCheckAddressing;
	UInt8  fIterateOnly;
	UInt8  fMisaligned;
	UInt8  fPrepared;
	UInt8  fDoubleBuffer;
	UInt8  fNewMD;
	UInt8  fLocalMapperAllocValid;
	UInt8  fIOVMAddrValid;
	UInt8  fForceDoubleBuffer;
	UInt8  fSetActiveNoMapper;

	vm_page_t fCopyPageAlloc;
	vm_page_t fCopyNext;
	vm_page_t fNextRemapPage;

	ppnum_t  fCopyPageCount;

	uint64_t  fLocalMapperAlloc;
	uint64_t  fLocalMapperAllocLength;

	OSPtr<IOBufferMemoryDescriptor> fCopyMD;

	IOService * fDevice;
	IOLock * fDextLock;

	IOReturn fStatus;
	UInt64   fActualByteCount;
	AbsoluteTime    fTimeStamp;

	IODMACommandMapSegment * fMapSegments;
	uint32_t                 fMapSegmentsCount;
	uint64_t fLocalMapperAllocBase;
	uint64_t fOffset2Index;
	uint64_t fNextOffset;
	uint64_t fIndex;
};
struct IOMemoryDescriptorDevicePager {
	void *                       devicePager;
	unsigned int             pagerContig:1;
	unsigned int             unused:31;
	IOMemoryDescriptor * memory;
};
struct IOMemoryDescriptorReserved {
	IOMemoryDescriptorDevicePager dp;
	uint64_t                      descriptorID;
	uint64_t                      preparationID;
	uint64_t                      kernReserved[4];
	vm_tag_t                      kernelTag;
	vm_tag_t                      userTag;
	task_t                        creator;
	OSObject                    * contextObject;
};
struct pmioctlVaribleInfo {
	uint32_t            varID;      
	uint8_t             varName[PMVARNAMELEN + 1];
	pmioctlVarType_t    varType;    
	uint64_t            varInitValue;
	uint64_t            varCurValue;
} pmioctlVariableInfo_t;
struct IOPMActions {
	void *                          target;
	IOPMActionPowerChangeStart      actionPowerChangeStart;
	IOPMActionPowerChangeDone       actionPowerChangeDone;
	IOPMActionPowerChangeOverride   actionPowerChangeOverride;
	IOPMActionActivityTickle        actionActivityTickle;
	IOPMActionUpdatePowerClient     actionUpdatePowerClient;
	uint32_t                        darkWakePowerState;
	uint16_t                        flags;
	uint16_t                        state;
};
struct IOPMPSEntry {
	IOPMPowerFlags      capabilityFlags;
	IOPMPowerFlags      outputPowerFlags;
	IOPMPowerFlags      inputPowerFlags;
	unsigned long       staticPower;
	uint32_t            settleUpTime;
	uint32_t            settleDownTime;
	IOPMPowerStateIndex stateOrder;
	IOPMPowerStateIndex stateOrderToIndex;
};
struct DriverCallParam {
	OSObject *  Target;
	IOReturn    Result;
};
struct IOPMInterestContext {
	OSArray *               responseArray;
	OSArray *               notifyClients;
	uint16_t                serialNumber;
	uint8_t                 isPreChange;
	uint8_t                 enableTracing;
	uint32_t                maxTimeRequested;
	uint32_t                messageType;
	uint32_t                notifyType;
	uint32_t                skippedInDark;
	uint32_t                notSkippedInDark;
	IOService *             us;
	IOPMPowerStateIndex     stateNumber;
	IOPMPowerFlags          stateFlags;
	IOPMPowerChangeFlags    changeFlags;
	IOPMMessageFilter       messageFilter;
};
struct _IOServiceNotifierInvocation {
	IOThread            thread;
	queue_chain_t       link;
};
struct _IODataQueueEntry {
	uint32_t  size;
	uint8_t   data[0];
} IODataQueueEntry;
struct _IODataQueueMemory {
	volatile uint32_t   head;
	volatile uint32_t   tail;
	volatile uint8_t    needServicedCallback;
	volatile uint8_t    _resv[119];
	IODataQueueEntry  queue[0];
} IODataQueueMemory;
struct IODataQueueDispatchSource_IVars {
	IODataQueueMemory         * dataQueue;
	IODataQueueDispatchSource * source;

	IOMemoryDescriptor        * memory;
	OSAction                  * dataAvailableAction;
	OSAction                  * dataServicedAction;
	uint64_t                    options;
	uint32_t                    queueByteCount;

};
struct object {
	struct object   *next;
	struct object   *free;
	struct object   *elements;
	OSObject        *object;
	OSSymbol        *key;                   
	int             size;
	void            *data;                  
	char            *string;                
	int             string_alloc_length;
	long long       number;                 
	int             idref;
} object_t;
struct parser_state {
	const char      *parseBuffer;           
	int             parseBufferIndex;       
	int             lineNumber;             
	object_t        *objects;               
	object_t        *freeObjects;           
	OSDictionary    *tags;                  
	OSString        **errorString;          
	OSObject        *parsedObject;          
	int             parsedObjectCount;
	int             retrievedObjectCount;
} parser_state_t;
struct IOPMCalendarStruct {
	UInt32      year;
	UInt8       month;
	UInt8       day;
	UInt8       hour;
	UInt8       minute;
	UInt8       second;
	UInt8       selector;
};
struct IOPowerStateChangeNotification {
	void *        powerRef;
	unsigned long    returnValue;
	unsigned long    stateNumber;
	IOPMPowerFlags    stateFlags;
};
struct IOPMSystemCapabilityChangeParameters {
	uint32_t    notifyRef;
	uint32_t    maxWaitForReply;
	uint32_t    changeFlags;
	uint32_t    __reserved1;
	uint32_t    fromCapabilities;
	uint32_t    toCapabilities;
	uint32_t    __reserved2[4];
};
struct IOPMPowerState {
	unsigned long       version;
	IOPMPowerFlags      capabilityFlags;
	IOPMPowerFlags      outputPowerCharacter;
	IOPMPowerFlags      inputPowerRequirement;
	unsigned long       staticPower;
	unsigned long       stateOrder;
	unsigned long       powerToAttain;
	unsigned long       timeToAttain;
	unsigned long       settleUpTime;
	unsigned long       timeToLower;
	unsigned long       settleDownTime;
	unsigned long       powerDomainBudget;
};
struct PMStatsBounds{
    uint64_t start;
    uint64_t stop;
};
struct {

    struct PMStatsBounds    hibWrite;
    struct PMStatsBounds    hibRead;






} PMStatsStruct;
struct {
   uint32_t signature;
   uint32_t alloc_size;
   uint32_t          crc;             
   uint32_t          spindump_offset; 
   uint32_t          spindump_size;
   uint8_t           is_osx_watchdog;

   
   char             UUID[44];
   char             spindump_status[24];   
   char             PMStatusCode[32];
   char             reason[32];
} swd_hdr;
struct {
	boolean_t user_writable;        
	boolean_t kernel_writable;      
	boolean_t iodir_in;             
	boolean_t iodir_out;            
	boolean_t purgeable;            
	boolean_t inhibitCache;         
	boolean_t physcontig;           
	boolean_t puredata;             
	boolean_t threadSafe;           
	boolean_t memtag;               
} IOSKMemoryBufferSpec;
struct {
	boolean_t noRedirect;
} IOSKRegionSpec;
struct{
	cccbc_ctx_decl(AES_CBC_CTX_MAX_SIZE, ctx);
} aes_decrypt_ctx;
struct{
	cccbc_ctx_decl(AES_CBC_CTX_MAX_SIZE, ctx);
} aes_encrypt_ctx;
struct{
	aes_decrypt_ctx decrypt;
	aes_encrypt_ctx encrypt;
} aes_ctx;
struct {
	u_int32_t state[4];     
	u_int32_t count[2];     
	unsigned char buffer[64];       
} MD5_CTX;
struct sha1_ctxt {
	union {
		u_int8_t        b8[20];
		u_int32_t       b32[5]; 
	} h;
	union {
		u_int8_t        b8[8];
		u_int32_t       b32[2];
		u_int64_t       b64[1]; 
	} c;
	union {
		u_int8_t        b8[64];
		u_int32_t       b32[16]; 
	} m;
	u_int8_t        count;          
} SHA1_CTX;
struct {
	ccdigest_ctx_decl(CCSHA256_STATE_SIZE, CCSHA256_BLOCK_SIZE, ctx);
} SHA256_CTX;
struct SHA512_CTX {
	ccdigest_ctx_decl(CCSHA512_STATE_SIZE, CCSHA512_BLOCK_SIZE, ctx);
} SHA512_CTX;
struct acpi_table_header {
	ACPI_TABLE_HEADER_DEF
} ACPI_TABLE_HEADER;
struct acpi_generic_address {
	UINT8                   AddressSpaceId;     
	UINT8                   RegisterBitWidth;   
	UINT8                   RegisterBitOffset;  
	UINT8                   AccessWidth;        
	UINT64                  Address;            
} ACPI_GENERIC_ADDRESS;
struct rsdp_descriptor {
	char                    Signature[8];       
	UINT8                   Checksum;           
	char                    OemId[6];           
	UINT8                   Revision;           
	UINT32                  RsdtPhysicalAddress;
	UINT32                  Length;             
	UINT64                  XsdtPhysicalAddress;
	UINT8                   ExtendedChecksum;   
	UINT8                   Reserved[3];        
} RSDP_DESCRIPTOR;
struct rsdt_descriptor {
	ACPI_TABLE_HEADER_DEF
	UINT32                  TableOffsetEntry[1];
} RSDT_DESCRIPTOR;
struct xsdt_descriptor {
	ACPI_TABLE_HEADER_DEF
	UINT64                  TableOffsetEntry[1];
} XSDT_DESCRIPTOR;
struct facs_descriptor {
	char                    Signature[4];       
	UINT32                  Length;             
	UINT32                  HardwareSignature;  
	UINT32                  FirmwareWakingVector;
	UINT32                  GlobalLock;         


	UINT8                   S4Bios_f        : 1;
	UINT8                                   : 7;
	UINT8                   Reserved1[3];       

	UINT64                  XFirmwareWakingVector;
	UINT8                   Version;            
	UINT8                   Reserved[31];       
} FACS_DESCRIPTOR;
struct acpi_common_facs {
	UINT32                  *GlobalLock;
	UINT64                  *FirmwareWakingVector;
	UINT8                   VectorWidth;
} ACPI_COMMON_FACS;
struct fadt_descriptor {
	ACPI_FADT_COMMON


	UINT8                   WbInvd      : 1;
	UINT8                   WbInvdFlush : 1;
	UINT8                   ProcC1      : 1;
	UINT8                   Plvl2Up     : 1;
	UINT8                   PwrButton   : 1;
	UINT8                   SleepButton : 1;
	UINT8                   FixedRTC    : 1;
	UINT8                   Rtcs4       : 1;
	UINT8                   TmrValExt   : 1;
	UINT8                   DockCap     : 1;
	UINT8                   ResetRegSup : 1;
	UINT8                   SealedCase  : 1;
	UINT8                   Headless    : 1;
	UINT8                   CpuSwSleep  : 1;

	UINT8                   PciExpWak                           : 1;
	UINT8                   UsePlatformClock                    : 1;
	UINT8                   S4RtcStsValid                       : 1;
	UINT8                   RemotePowerOnCapable                : 1;
	UINT8                   ForceApicClusterModel               : 1;
	UINT8                   ForceApicPhysicalDestinationMode    : 1;
	UINT8                                                       : 4;
	UINT8                   Reserved3;                           

	ACPI_GENERIC_ADDRESS    ResetRegister;  
	UINT8                   ResetValue;     
	UINT8                   Reserved4[3];   
	UINT64                  XFirmwareCtrl;  
	UINT64                  XDsdt;          
	ACPI_GENERIC_ADDRESS    XPm1aEvtBlk;    
	ACPI_GENERIC_ADDRESS    XPm1bEvtBlk;    
	ACPI_GENERIC_ADDRESS    XPm1aCntBlk;    
	ACPI_GENERIC_ADDRESS    XPm1bCntBlk;    
	ACPI_GENERIC_ADDRESS    XPm2CntBlk;     
	ACPI_GENERIC_ADDRESS    XPmTmrBlk;      
	ACPI_GENERIC_ADDRESS    XGpe0Blk;       
	ACPI_GENERIC_ADDRESS    XGpe1Blk;       
} FADT_DESCRIPTOR;
struct fadt_descriptor_rev2_minus {
	ACPI_FADT_COMMON
	UINT32                  Flags;
	ACPI_GENERIC_ADDRESS    ResetRegister;  
	UINT8                   ResetValue;     
	UINT8                   Reserved7[3];   
} FADT_DESCRIPTOR_REV2_MINUS;
struct fadt_descriptor_rev1 {
	ACPI_FADT_COMMON
	UINT32                  Flags;
} FADT_DESCRIPTOR_REV1;
struct acpi_table_support {
	char                    *Name;
	char                    *Signature;
	void                    **GlobalPtr;
	UINT8                   SigLength;
	UINT8                   Flags;
} ACPI_TABLE_SUPPORT;
struct acpi_table_asf {
	ACPI_TABLE_HEADER_DEF
} ACPI_TABLE_ASF;
struct acpi_asf_header {
	ACPI_ASF_HEADER_DEF
} ACPI_ASF_HEADER;
struct acpi_asf_info {
	ACPI_ASF_HEADER_DEF
	UINT8                   MinResetValue;
	UINT8                   MinPollInterval;
	UINT16                  SystemId;
	UINT32                  MfgId;
	UINT8                   Flags;
	UINT8                   Reserved2[3];
} ACPI_ASF_INFO;
struct acpi_asf_alert {
	ACPI_ASF_HEADER_DEF
	UINT8                   AssertMask;
	UINT8                   DeassertMask;
	UINT8                   Alerts;
	UINT8                   DataLength;
	UINT8                   Array[1];
} ACPI_ASF_ALERT;
struct acpi_asf_remote {
	ACPI_ASF_HEADER_DEF
	UINT8                   Controls;
	UINT8                   DataLength;
	UINT16                  Reserved2;
	UINT8                   Array[1];
} ACPI_ASF_REMOTE;
struct acpi_asf_rmcp {
	ACPI_ASF_HEADER_DEF
	UINT8                   Capabilities[7];
	UINT8                   CompletionCode;
	UINT32                  EnterpriseId;
	UINT8                   Command;
	UINT16                  Parameter;
	UINT16                  BootOptions;
	UINT16                  OemParameters;
} ACPI_ASF_RMCP;
struct acpi_asf_address {
	ACPI_ASF_HEADER_DEF
	UINT8                   EpromAddress;
	UINT8                   Devices;
	UINT8                   SmbusAddresses[1];
} ACPI_ASF_ADDRESS;
struct acpi_table_boot {
	ACPI_TABLE_HEADER_DEF
	UINT8                   CmosIndex;      
	UINT8                   Reserved[3];
} ACPI_TABLE_BOOT;
struct acpi_table_cpep {
	ACPI_TABLE_HEADER_DEF
	UINT64                  Reserved;
} ACPI_TABLE_CPEP;
struct acpi_cpep_polling {
	UINT8                   Type;
	UINT8                   Length;
	UINT8                   ProcessorId;    
	UINT8                   ProcessorEid;   
	UINT32                  PollingInterval;
} ACPI_CPEP_POLLING;
struct acpi_table_dbgp {
	ACPI_TABLE_HEADER_DEF
	UINT8                   InterfaceType;  
	UINT8                   Reserved[3];
	ACPI_GENERIC_ADDRESS    DebugPort;
} ACPI_TABLE_DBGP;
struct ec_boot_resources {
	ACPI_TABLE_HEADER_DEF
	ACPI_GENERIC_ADDRESS    EcControl;      
	ACPI_GENERIC_ADDRESS    EcData;         
	UINT32                  Uid;            
	UINT8                   GpeBit;         
	UINT8                   EcId[1];        
} EC_BOOT_RESOURCES;
struct acpi_hpet_table {
	ACPI_TABLE_HEADER_DEF
	UINT32                  HardwareId;     
	ACPI_GENERIC_ADDRESS    BaseAddress;    
	UINT8                   HpetNumber;     
	UINT16                  ClockTick;      
	UINT8                   Attributes;
} HPET_TABLE;
struct multiple_apic_table {
	ACPI_TABLE_HEADER_DEF
	UINT32                  LocalApicAddress;


	UINT8                   PCATCompat      : 1;
	UINT8                                   : 7;
	UINT8                   Reserved1[3];       
} MULTIPLE_APIC_TABLE;
struct apic_header {
	APIC_HEADER_DEF
} APIC_HEADER;
struct madt_processor_apic {
	APIC_HEADER_DEF
	UINT8                   ProcessorId;    
	UINT8                   LocalApicId;    
	ACPI_MADT_LFLAGS
} MADT_PROCESSOR_APIC;
struct madt_io_apic {
	APIC_HEADER_DEF
	UINT8                   IoApicId;       
	UINT8                   Reserved;       
	UINT32                  Address;        
	UINT32                  Interrupt;      
} MADT_IO_APIC;
struct madt_interrupt_override {
	APIC_HEADER_DEF
	UINT8                   Bus;            
	UINT8                   Source;         
	UINT32                  Interrupt;      
	ACPI_MADT_IFLAGS
} MADT_INTERRUPT_OVERRIDE;
struct madt_nmi_source {
	APIC_HEADER_DEF
	ACPI_MADT_IFLAGS
	UINT32                  Interrupt;      
} MADT_NMI_SOURCE;
struct madt_local_apic_nmi {
	APIC_HEADER_DEF
	UINT8                   ProcessorId;    
	ACPI_MADT_IFLAGS
	UINT8                   Lint;               
} MADT_LOCAL_APIC_NMI;
struct madt_address_override {
	APIC_HEADER_DEF
	UINT16                  Reserved;       
	UINT64                  Address;        
} MADT_ADDRESS_OVERRIDE;
struct madt_io_sapic {
	APIC_HEADER_DEF
	UINT8                   IoSapicId;      
	UINT8                   Reserved;       
	UINT32                  InterruptBase;  
	UINT64                  Address;        
} MADT_IO_SAPIC;
struct madt_local_sapic {
	APIC_HEADER_DEF
	UINT8                   ProcessorId;    
	UINT8                   LocalSapicId;   
	UINT8                   LocalSapicEid;  
	UINT8                   Reserved[3];    
	ACPI_MADT_LFLAGS
	UINT32                  ProcessorUID;           
	char                    ProcessorUIDString[1];
} MADT_LOCAL_SAPIC;
struct madt_interrupt_source {
	APIC_HEADER_DEF
	ACPI_MADT_IFLAGS
	UINT8                   InterruptType;  
	UINT8                   ProcessorId;    
	UINT8                   ProcessorEid;   
	UINT8                   IoSapicVector;  
	UINT32                  Interrupt;      
	UINT32                  Flags;          
} MADT_INTERRUPT_SOURCE;
struct acpi_table_mcfg {
	ACPI_TABLE_HEADER_DEF
	UINT8                   Reserved[8];
} ACPI_TABLE_MCFG;
struct acpi_mcfg_allocation {
	UINT64                  BaseAddress;    
	UINT16                  PciSegment;     
	UINT8                   StartBusNumber; 
	UINT8                   EndBusNumber;   
	UINT32                  Reserved;
} ACPI_MCFG_ALLOCATION;
struct smart_battery_table {
	ACPI_TABLE_HEADER_DEF
	UINT32                  WarningLevel;
	UINT32                  LowLevel;
	UINT32                  CriticalLevel;
} SMART_BATTERY_TABLE;
struct system_locality_info {
	ACPI_TABLE_HEADER_DEF
	UINT64                  LocalityCount;
	UINT8                   Entry[1][1];
} SYSTEM_LOCALITY_INFO;
struct acpi_table_spcr {
	ACPI_TABLE_HEADER_DEF
	UINT8                   InterfaceType;  
	UINT8                   Reserved[3];
	ACPI_GENERIC_ADDRESS    SerialPort;
	UINT8                   InterruptType;
	UINT8                   PcInterrupt;
	UINT32                  Interrupt;
	UINT8                   BaudRate;
	UINT8                   Parity;
	UINT8                   StopBits;
	UINT8                   FlowControl;
	UINT8                   TerminalType;
	UINT8                   Reserved2;
	UINT16                  PciDeviceId;
	UINT16                  PciVendorId;
	UINT8                   PciBus;
	UINT8                   PciDevice;
	UINT8                   PciFunction;
	UINT32                  PciFlags;
	UINT8                   PciSegment;
	UINT32                  Reserved3;
} ACPI_TABLE_SPCR;
struct acpi_table_spmi {
	ACPI_TABLE_HEADER_DEF
	UINT8                   Reserved;
	UINT8                   InterfaceType;
	UINT16                  SpecRevision;   
	UINT8                   InterruptType;
	UINT8                   GpeNumber;      
	UINT8                   Reserved2;
	UINT8                   PciDeviceFlag;
	UINT32                  Interrupt;
	ACPI_GENERIC_ADDRESS    IpmiRegister;
	UINT8                   PciSegment;
	UINT8                   PciBus;
	UINT8                   PciDevice;
	UINT8                   PciFunction;
} ACPI_TABLE_SPMI;
struct system_resource_affinity {
	ACPI_TABLE_HEADER_DEF
	UINT32                  Reserved1;      
	UINT64                  Reserved2;      
} SYSTEM_RESOURCE_AFFINITY;
struct static_resource_alloc {
	SRAT_SUBTABLE_HEADER
	UINT8                   ProximityDomainLo;
	UINT8                   ApicId;


	UINT8                   Enabled         :1;
	UINT8                                   :7;
	UINT8                   Reserved3[3];   

	UINT8                   LocalSapicEid;
	UINT8                   ProximityDomainHi[3];
	UINT32                  Reserved4;      
} STATIC_RESOURCE_ALLOC;
struct memory_affinity {
	SRAT_SUBTABLE_HEADER
	UINT32                  ProximityDomain;
	UINT16                  Reserved3;
	UINT64                  BaseAddress;
	UINT64                  AddressLength;
	UINT32                  Reserved4;


	UINT8                   Enabled         :1;
	UINT8                   HotPluggable    :1;
	UINT8                   NonVolatile     :1;
	UINT8                                   :5;
	UINT8                   Reserved5[3];   

	UINT64                  Reserved6;      
} MEMORY_AFFINITY;
struct acpi_table_tcpa {
	ACPI_TABLE_HEADER_DEF
	UINT16                  Reserved;
	UINT32                  MaxLogLength;   
	UINT64                  LogAddress;     
} ACPI_TABLE_TCPA;
struct acpi_table_wdrt {
	ACPI_TABLE_HEADER_DEF
	UINT32                  HeaderLength;   
	UINT8                   PciSegment;     
	UINT8                   PciBus;         
	UINT8                   PciDevice;      
	UINT8                   PciFunction;    
	UINT32                  TimerPeriod;    
	UINT32                  MaxCount;       
	UINT32                  MinCount;       
	UINT8                   Flags;
	UINT8                   Reserved[3];
	UINT32                  Entries;        
} ACPI_TABLE_WDRT;
struct cc_iovec {
    const void *base;
    size_t nbytes;
} cc_iovec_t;
struct {
	uint32_t state[16];
	uint8_t	buffer[CCCHACHA20_BLOCK_NBYTES];
	size_t leftover;
} ccchacha20_ctx;
struct {
	uint32_t r0, r1, r2, r3, r4;
	uint32_t s1, s2, s3, s4;
	uint32_t h0, h1, h2, h3, h4;
	uint8_t	buf[16];
	size_t buf_used;
	uint8_t	key[16];
} ccpoly1305_ctx;
struct {
	ccchacha20_ctx chacha20_ctx;
	ccpoly1305_ctx poly1305_ctx;
	uint64_t aad_nbytes;
	uint64_t text_nbytes;
    uint8_t state;
} ccchacha20poly1305_ctx;
struct ccchacha20poly1305_info {

};
struct cccmac_ctx {
    uint8_t k1[CMAC_BLOCKSIZE];
    uint8_t k2[CMAC_BLOCKSIZE];
    uint8_t block[CMAC_BLOCKSIZE];
    size_t  block_nbytes; 
    size_t  cumulated_nbytes;  
    const struct ccmode_cbc *cbc;
    uint8_t ctx[1];
} CC_ALIGNED(8);
struct ccder_blob {
    uint8_t *cc_ended_by(der_end) der;
    uint8_t *der_end;
} ccder_blob;
struct ccder_read_blob {
    const uint8_t *cc_ended_by(der_end) der;
    const uint8_t *der_end;
} ccder_read_blob;
struct ccdigest_ctx {
    uint8_t state[1];
} CC_ALIGNED(8);
struct ccdigest_state {
    uint8_t state[1];
} CC_ALIGNED(8);
struct ccdigest_info {
    size_t output_size;
    size_t state_size;
    size_t block_size;
    size_t oid_size;
    const unsigned char *oid;
    const void *initial_state;
    void(* CC_SPTR(ccdigest_info, compress))(ccdigest_state_t state, size_t nblocks,
                    const void *data);
    void(* CC_SPTR(ccdigest_info, final))(const struct ccdigest_info *di, ccdigest_ctx_t ctx,
                 unsigned char *digest);
    cc_impl_t impl;
};
struct ccdrbg_nistctr_custom {
    const struct ccmode_ctr *ctr_info;
    size_t keylen;
    int strictFIPS;
    const ccdrbg_df_ctx_t *df_ctx;
};
struct ccdrbg_nisthmac_custom {
    const struct ccdigest_info *di;
    int strictFIPS;
};
struct ccdrbg_df_ctx {
    int (*derive_keys)(const ccdrbg_df_ctx_t *ctx,
                       size_t inputs_count,
                       const cc_iovec_t *inputs,
                       size_t keys_nbytes,
                       void *keys);
};
struct ccdrbg_df_bc_ctx {
    ccdrbg_df_ctx_t df_ctx;
    const struct ccmode_cbc *cbc_info;
    size_t key_nbytes;

    
    cc_ctx_decl_field(cccbc_ctx, CCCBC_MAX_CTX_SIZE, cbc_ctx);
};
struct ccdrbg_info {
    
    size_t size;

    
    int (*CC_SPTR(ccdrbg_info, init))(const struct ccdrbg_info *info, struct ccdrbg_state *drbg,
                size_t entropyLength, const void* entropy,
                size_t nonceLength, const void* nonce,
                size_t psLength, const void* ps);

    
    int (*CC_SPTR(ccdrbg_info, reseed))(struct ccdrbg_state *drbg,
                  size_t entropylen, const void *entropy,
                  size_t inlen, const void *in);

    
    int (*CC_SPTR(ccdrbg_info, generate))(struct ccdrbg_state *drbg,
                    size_t outlen, void *out,
                    size_t inlen, const void *in);

    
    void (*CC_SPTR(ccdrbg_info, done))(struct ccdrbg_state *drbg);

    
    const void *custom;

    
    bool (*CC_SPTR(ccdrbg_info, must_reseed))(const struct ccdrbg_state *drbg);
};
struct ccentropy_info {
    
    
    
    
    
    ccentropy_get_seed_fn_t get_seed;

    
    
    
    
    
    ccentropy_add_entropy_fn_t add_entropy;
} ccentropy_info_t;
struct ccentropy_ctx {
    
    const ccentropy_info_t *info;
};
struct ccentropy_rng_ctx {
    ccentropy_ctx_t entropy_ctx;
    struct ccrng_state *rng_ctx;
    size_t seed_max_nbytes;
} ccentropy_rng_ctx_t;
struct ccentropy_digest_ctx {
    ccentropy_ctx_t entropy_ctx;
    const struct ccdigest_info *digest_info;
    ccdigest_ctx_decl(MAX_DIGEST_STATE_SIZE,
                      MAX_DIGEST_BLOCK_SIZE,
                      digest_ctx);
    uint32_t entropy_mbits_per_sample;
    uint32_t entropy_mbits;
} ccentropy_digest_ctx_t;
struct cchmac_ctx {
    uint8_t b[1];
} CC_ALIGNED(8);
struct cckprng_ctx {
    
    ccrng_schedule_atomic_flag_ctx_t schedule_ctx;

    ccentropy_rng_ctx_t entropy_ctx;

    cc_lock_ctx_t lock_ctx;

    struct ccdrbg_info drbg_info;
    uint8_t drbg_state[CCKPRNG_DRBG_STATE_MAX_SIZE];

    ccdrbg_df_bc_ctx_t drbg_df_ctx;

    uint8_t cache[CCKPRNG_CACHED_BUF_SIZE];

    ccrng_crypto_ctx_t rng_ctx;

    struct ccrng_fortuna_ctx fortuna_ctx;
};
struct cckprng_funcs {
    void (*CC_SPTR(cckprng_funcs, init))(struct cckprng_ctx *ctx,
                                         size_t seed_nbytes,
                                         const void *seed,
                                         size_t nonce_nbytes,
                                         const void *nonce,
                                         cckprng_getentropy getentropy,
                                         void *getentropy_arg);
    void (*CC_SPTR(cckprng_funcs, initgen))(struct cckprng_ctx *ctx, unsigned gen_idx);
    void (*CC_SPTR(cckprng_funcs, reseed))(struct cckprng_ctx *ctx, size_t nbytes, const void *seed);
    void (*CC_SPTR(cckprng_funcs, refresh))(struct cckprng_ctx *ctx);
    void (*CC_SPTR(cckprng_funcs, generate))(struct cckprng_ctx *ctx, unsigned gen_idx, size_t nbytes, void *out);
    void (*CC_SPTR(cckprng_funcs, init_with_getentropy))(struct cckprng_ctx *ctx,
                                                         unsigned max_ngens,
                                                         size_t seed_nbytes,
                                                         const void *seed,
                                                         size_t nonce_nbytes,
                                                         const void *nonce,
                                                         cckprng_getentropy getentropy,
                                                         void *getentropy_arg);
};
struct ccmode_ecb {
    size_t size; 
    size_t block_size;
    int (*CC_SPTR(ccmode_ecb, init))(const struct ccmode_ecb *ecb, ccecb_ctx *ctx, size_t key_nbytes, const void *key);
    int (*CC_SPTR(ccmode_ecb, ecb))(const ccecb_ctx *ctx, size_t nblocks, const void *in, void *out);
    void (*CC_SPTR(ccmode_ecb, roundkey))(const ccecb_ctx *ctx, unsigned r, void *key);
    cc_impl_t impl;
};
struct ccmode_cbc {
    size_t size; 
    size_t block_size;
    int (*CC_SPTR(ccmode_cbc, init))(const struct ccmode_cbc *cbc, cccbc_ctx *ctx, size_t key_len, const void *key);
    
    int (*CC_SPTR(ccmode_cbc, cbc))(const cccbc_ctx *ctx, cccbc_iv *iv, size_t nblocks, const void *in, void *out);
    const void *custom;
};
struct ccmode_cfb {
    size_t size; 
    size_t block_size;
    int (*CC_SPTR(ccmode_cfb,
                  init))(const struct ccmode_cfb *cfb, cccfb_ctx *ctx, size_t key_len, const void *key, const void *iv);
    int (*CC_SPTR(ccmode_cfb, cfb))(cccfb_ctx *ctx, size_t nbytes, const void *in, void *out);
    const void *custom;
};
struct ccmode_cfb8 {
    size_t size; 
    size_t block_size;
    int (*CC_SPTR(ccmode_cfb8,
                  init))(const struct ccmode_cfb8 *cfb8, cccfb8_ctx *ctx, size_t key_len, const void *key, const void *iv);
    int (*CC_SPTR(ccmode_cfb8, cfb8))(cccfb8_ctx *ctx, size_t nbytes, const void *in, void *out);
    const void *custom;
};
struct ccmode_ctr {
    size_t size;           
    size_t block_size;     
    size_t ecb_block_size; 
    int (*CC_SPTR(ccmode_ctr,
                  init))(const struct ccmode_ctr *mode, ccctr_ctx *ctx, size_t key_len, const void *key, const void *iv);
    int (*CC_SPTR(ccmode_ctr, setctr))(const struct ccmode_ctr *mode, ccctr_ctx *ctx, const void *ctr);
    int (*CC_SPTR(ccmode_ctr, ctr))(ccctr_ctx *ctx, size_t nbytes, const void *in, void *out);
    const void *custom;
};
struct ccmode_ofb {
    size_t size; 
    size_t block_size;
    int (*CC_SPTR(ccmode_ofb,
                  init))(const struct ccmode_ofb *ofb, ccofb_ctx *ctx, size_t key_len, const void *key, const void *iv);
    int (*CC_SPTR(ccmode_ofb, ofb))(ccofb_ctx *ctx, size_t nbytes, const void *in, void *out);
    const void *custom;
};
struct ccmode_xts {
    size_t size;       
    size_t tweak_size; 
    size_t block_size;

    
    int (*CC_SPTR(ccmode_xts, init))(const struct ccmode_xts *xts,
                                     ccxts_ctx *ctx,
                                     size_t key_nbytes,
                                     const void *data_key,
                                     const void *tweak_key);

    void (*CC_SPTR(ccmode_xts, key_sched))(const struct ccmode_xts *xts,
                                           ccxts_ctx *ctx,
                                           size_t key_nbytes,
                                           const void *data_key,
                                           const void *tweak_key);

    
    int (*CC_SPTR(ccmode_xts, set_tweak))(const ccxts_ctx *ctx, ccxts_tweak *tweak, const void *iv);

    
    void *(*CC_SPTR(ccmode_xts, xts))(const ccxts_ctx *ctx, ccxts_tweak *tweak, size_t nblocks, const void *in, void *out);

    const void *custom;
    const void *custom1;
    cc_impl_t impl;
};
struct ccmode_gcm {
    size_t size; 
    int encdec;  
    size_t block_size;
    int (*CC_SPTR(ccmode_gcm, init))(const struct ccmode_gcm *gcm, ccgcm_ctx *ctx, size_t key_nbytes, const void *key);
    int (*CC_SPTR(ccmode_gcm, set_iv))(ccgcm_ctx *ctx, size_t iv_nbytes, const void *iv);
    int (*CC_SPTR(ccmode_gcm, gmac))(ccgcm_ctx *ctx, size_t nbytes, const void *in); 
    int (*CC_SPTR(ccmode_gcm, gcm))(ccgcm_ctx *ctx, size_t nbytes, const void *in, void *out);
    int (*CC_SPTR(ccmode_gcm, finalize))(ccgcm_ctx *key, size_t tag_nbytes, void *tag);
    int (*CC_SPTR(ccmode_gcm, reset))(ccgcm_ctx *ctx);
    const void *custom;
};
struct ccmode_ccm {
    size_t size;       
    size_t nonce_size; 
    size_t block_size;
    int (*CC_SPTR(ccmode_ccm, init))(const struct ccmode_ccm *ccm, ccccm_ctx *ctx, size_t key_len, const void *key);
    int (*CC_SPTR(ccmode_ccm, set_iv))(ccccm_ctx *ctx,
                                       ccccm_nonce *nonce_ctx,
                                       size_t nonce_len,
                                       const void *nonce,
                                       size_t mac_size,
                                       size_t auth_len,
                                       size_t data_len);
    int (*CC_SPTR(ccmode_ccm, cbcmac))(ccccm_ctx *ctx,
                                       ccccm_nonce *nonce_ctx,
                                       size_t nbytes,
                                       const void *in); 
    int (*CC_SPTR(ccmode_ccm, ccm))(ccccm_ctx *ctx, ccccm_nonce *nonce_ctx, size_t nbytes, const void *in, void *out);
    int (*CC_SPTR(ccmode_ccm, finalize))(ccccm_ctx *key, ccccm_nonce *nonce_ctx, void *mac);
    int (*CC_SPTR(ccmode_ccm, reset))(ccccm_ctx *key, ccccm_nonce *nonce_ctx);
    const void *custom;
    bool enc_mode;
};
struct _ccmode_ccm_nonce {
    unsigned char A_i[16]; 
    unsigned char B_i[16]; 
    unsigned char MAC[16]; 
    unsigned char buf[16]; 

    uint32_t mode;    
    uint32_t buflen;  
    uint32_t b_i_len; 

    size_t nonce_size;
    size_t mac_size;
};
struct ccmode_omac {
    size_t size; 
    size_t block_size;
    int (*CC_SPTR(ccmode_omac,
                  init))(const struct ccmode_omac *omac, ccomac_ctx *ctx, size_t tweak_len, size_t key_len, const void *key);
    int (*CC_SPTR(ccmode_omac, omac))(ccomac_ctx *ctx, size_t nblocks, const void *tweak, const void *in, void *out);
    const void *custom;
};
struct ccmode_siv {
    size_t size;        
    size_t block_size;
    int (*CC_SPTR(ccmode_siv, init))(const struct ccmode_siv *siv, ccsiv_ctx *ctx,
                 size_t key_len, const uint8_t *key);
    int (*CC_SPTR(ccmode_siv, set_nonce))(ccsiv_ctx *ctx,  size_t nbytes, const uint8_t *in);  
    int (*CC_SPTR(ccmode_siv, auth))(ccsiv_ctx *ctx,  size_t nbytes, const uint8_t *in);  
    int (*CC_SPTR(ccmode_siv, crypt))(ccsiv_ctx *ctx, size_t nbytes, const uint8_t *in, uint8_t *out);
    int (*CC_SPTR(ccmode_siv, reset))(ccsiv_ctx *ctx);
    const struct ccmode_cbc *cbc;
    const struct ccmode_ctr *ctr;
};
struct ccmode_siv_hmac {
    size_t size; 
    size_t block_size;
    
    int (*CC_SPTR(ccmode_siv_hmac, init))(const struct ccmode_siv_hmac *sivhmac,
                ccsiv_hmac_ctx *ctx,
                size_t key_len,
                const uint8_t *key,
                const size_t tag_size);
    int (*CC_SPTR(ccmode_siv_hmac, set_nonce))(ccsiv_hmac_ctx *ctx, size_t nbytes, const uint8_t *in);
    int (*CC_SPTR(ccmode_siv_hmac, auth))(ccsiv_hmac_ctx *ctx, size_t nbytes, const uint8_t *in);
    int (*CC_SPTR(ccmode_siv_hmac, crypt))(ccsiv_hmac_ctx *ctx, size_t nbytes, const uint8_t *in, uint8_t *out);
    int (*CC_SPTR(ccmode_siv_hmac, reset))(ccsiv_hmac_ctx *ctx);
    const struct ccdigest_info *hmac_digest; 
    const struct ccmode_ctr *ctr;
};
struct ccrng_state {
    CCRNG_STATE_COMMON
};
struct ccrng_crypto_ctx {
    CCRNG_STATE_COMMON

    ccentropy_ctx_t *entropy_ctx;
    ccrng_schedule_ctx_t *schedule_ctx;
    cc_lock_ctx_t *lock_ctx;

    const struct ccdrbg_info *drbg_info;
    struct ccdrbg_state *drbg_ctx;

    size_t generate_chunk_nbytes;
    size_t seed_nbytes;

    size_t cache_nbytes;
    uint8_t *cache;
    size_t cache_pos;
} ccrng_crypto_ctx_t;
struct ccrng_fortuna_pool_ctx {
    uint8_t data[CCRNG_FORTUNA_POOL_NBYTES];

    
    uint64_t nsamples;

    
    uint64_t ndrains;

    
    uint64_t nsamples_max;
};
struct ccrng_fortuna_sched_ctx {
    
    uint64_t reseed_sched;

    
    unsigned pool_idx;
};
struct ccrng_fortuna_ctx {
    CCRNG_STATE_COMMON

    
    uint8_t key[CCRNG_FORTUNA_KEY_NBYTES];

    
    uint8_t ctr[16];

    
    struct ccrng_fortuna_sched_ctx sched;

    
    cc_lock_ctx_t lock;

    
    struct ccrng_fortuna_pool_ctx pools[CCRNG_FORTUNA_NPOOLS];

    
    CC_SPTR(ccrng_fortuna_ctx, ccrng_fortuna_getentropy) getentropy;

    
    void *getentropy_arg;

    
    
    
    
    
    
    bool seeded;

    
    uint64_t nreseeds;

    
    uint64_t schedreseed_nsamples_max;

    
    uint64_t addentropy_nsamples_max;
};
struct ccrng_schedule_info {
    ccrng_schedule_action_t (*read)(ccrng_schedule_ctx_t *ctx);
    void (*notify_reseed)(ccrng_schedule_ctx_t *ctx);
} ccrng_schedule_info_t;
struct ccrng_schedule_ctx {
    const ccrng_schedule_info_t *info;
    bool must_reseed;
};
struct ccrng_schedule_atomic_flag_ctx {
    ccrng_schedule_ctx_t schedule_ctx;
    _Atomic ccrng_schedule_action_t flag;
} ccrng_schedule_atomic_flag_ctx_t;
struct ccrng_schedule_constant_ctx {
    ccrng_schedule_ctx_t schedule_ctx;
    ccrng_schedule_action_t action;
} ccrng_schedule_constant_ctx_t;
struct ccrng_schedule_timer_ctx {
    ccrng_schedule_ctx_t schedule_ctx;
    uint64_t (*get_time)(void);
    uint64_t reseed_interval;
    uint64_t last_reseed_time;
} ccrng_schedule_timer_ctx_t;
struct ccrng_schedule_tree_ctx {
    ccrng_schedule_ctx_t schedule_ctx;
    ccrng_schedule_ctx_t *left;
    ccrng_schedule_ctx_t *right;
} ccrng_schedule_tree_ctx_t;
struct ccrng_schedule_drbg_ctx {
    ccrng_schedule_ctx_t schedule_ctx;
    const struct ccdrbg_info *drbg_info;
    struct ccdrbg_state *drbg_ctx;
} ccrng_schedule_drbg_ctx_t;
struct ccrsa_full_ctx {
    __CCZP_ELEMENTS_DEFINITIONS(pb_)
} CC_ALIGNED(CCN_UNIT_SIZE);
struct ccrsa_pub_ctx {
    __CCZP_ELEMENTS_DEFINITIONS(pb_)
} CC_ALIGNED(CCN_UNIT_SIZE);
struct cczp {
    __CCZP_ELEMENTS_DEFINITIONS()
} CC_ALIGNED(CCN_UNIT_SIZE);
struct {
    uint64_t version;
    typeof(&CEAcquireUnmanagedContext) AcquireUnmanagedContext;
    typeof(&CEValidate) Validate;
    typeof(&CEContextQuery) ContextQuery;
    typeof(&CEConjureContextFromDER) ConjureContextFromDER;
    
    typeof(&der_vm_context_create) der_vm_context_create;
    typeof(&der_vm_execute) der_vm_execute;
    typeof(&der_vm_iterate) der_vm_iterate;
    typeof(&der_vm_context_is_valid) der_vm_context_is_valid;
    typeof(&der_vm_CEType_from_context) der_vm_CEType_from_context;
    typeof(&der_vm_integer_from_context) der_vm_integer_from_context;
    typeof(&der_vm_string_from_context) der_vm_string_from_context;
    typeof(&der_vm_bool_from_context) der_vm_bool_from_context;
    
    typeof(kCENoError) kNoError;
    typeof(kCEAPIMisuse) kAPIMisuse;
    typeof(kCEInvalidArgument) kInvalidArgument;
    typeof(kCEAllocationFailed) kAllocationFailed;
    typeof(kCEMalformedEntitlements) kMalformedEntitlements;
    typeof(kCEQueryCannotBeSatisfied) kQueryCannotBeSatisfied;

    typeof(&CEGetErrorString) GetErrorString;
    
    typeof(&der_vm_buffer_from_context) der_vm_buffer_from_context;
    typeof(&CEContextIsSubset) CEContextIsSubset;
    
} coreentitlements_t;
struct der_vm_context {
    CERuntime_t runtime;
    ccder_tag dictionary_tag;
    bool sorted;
    bool valid;
    union {
        
        ccder_read_blob ccstate;
        
        
        struct {
            const uint8_t *__ended_by(der_end) der_start;
            const uint8_t *der_end;
        } state;
    };
} der_vm_context_t;
struct {
    der_vm_context_t original;
    der_vm_context_t active;
    CEType_t parent_type;
    CEType_t active_type;
    void* user_data;
} der_vm_iteration_context;
struct {
    CEVersion_t version;
    const uint8_t *__ended_by(blob_end) blob;
    const uint8_t * blob_end;
} CEValidationResult;
struct {
    bool allow_data_elements;
} CEValidationOptions;
struct CEQueryOperation {
    CEQueryOpOpcode_t opcode;
    union {
        CEBuffer dynamicParameter;
        CEStaticBuffer stringParameter;
        int64_t numericParameter;
    } parameters;
} CEQueryOperation_t;
struct CEPrepareOptions {
    
    bool materialize;
    
    bool failOnOversizedParameters;
} CEPrepareOptions_t;
struct CEQueryContext {
    der_vm_context_t der_context;
    bool managed;
};
struct CEAccelerationElement {
    uint32_t key_offset;
    uint32_t key_length;
} CEAccelerationElement_t;
struct CEAccelerationContext {
    CEAccelerationElement_t * __counted_by(index_count) index;
    size_t index_count;
};
struct {
    const uint8_t *__counted_by(length) data;
    size_t length;
} CEBuffer;
struct {
    uint8_t data[CE_MAX_KEY_SIZE];
    size_t length;
} CEStaticBuffer;
struct CERuntime {
    const uint64_t                  version;
    const CERuntimeMalloc           alloc;
    const CERuntimeFree             free;
    const CERuntimeLog              log;
    const CERuntimeAbort            abort;
    const CERuntimeInternalStatus   internalStatus;
    const CERuntimeAllocIndex       allocIndex;
    const CERuntimeFreeIndex        freeIndex;
} ;
struct CESerializedElement {
    CESerializedElementType_t type;
    union {
        int64_t value;
    } data;
    size_t length;
    bool pair;
} CESerializedElement_t;
struct x509_octet_string {
    const CT_uint8_t * __counted_by(length) data;
    CT_size_t length;
} CTAsn1Item;
struct baa_identity {
    CT_uint32_t chipId;
    CT_uint64_t ecid;
    CT_bool productionStatus;
    CT_bool securityMode;
    CT_uint8_t securityDomain;
    CTAsn1Item img4;
} CTBAAIdentity;
struct _image4_environment_callbacks {
	image4_struct_version_t nvcb_version;
	image4_environment_query_boot_nonce_t _Nullable nvcb_query_boot_nonce;
	image4_environment_query_nonce_digest_t _Nullable nvcb_query_nonce_digest;
	image4_environment_identifier_bool_t _Nullable nvcb_identifier_bool;
	image4_environment_identifier_integer_t _Nullable nvcb_identifier_integer;
	image4_environment_identifier_data_t _Nullable nvcb_identifier_data;
} image4_environment_callbacks_t;
struct _image4_environment_storage {
	uint8_t __opaque[256];
};
struct _image4_trust_storage {
	uint8_t __opaque[2048];
} image4_trust_storage_t;
struct _img4_chip_instance {
	img4_struct_version_t chid_version;
	const img4_chip_t *chid_chip_family;
	img4_chip_instance_omit_t chid_omit;
	uint32_t chid_cepo;
	uint32_t chid_bord;
	uint32_t chid_chip;
	uint32_t chid_sdom;
	uint64_t chid_ecid;
	bool chid_cpro;
	bool chid_csec;
	bool chid_epro;
	bool chid_esec;
	bool chid_iuou;
	bool chid_rsch;
	bool chid_euou;
	uint32_t chid_esdm;
	bool chid_fpgt;
	img4_dgst_t chid_udid;
	uint32_t chid_fchp;
	uint32_t chid_type;
	uint32_t chid_styp;
	uint32_t chid_clas;
} img4_chip_instance_t;
struct _img4_dgst {
	img4_struct_version_t i4d_version;
	size_t i4d_len;
	uint8_t i4d_bytes[IMG4_DGST_MAX_LEN];
} img4_dgst_t;
struct _img4_cstr {
	size_t i4cs_len;
	char i4cs_cstr[64];
} img4_cstr_t;
struct _img4_firmware_execution_context {
	img4_struct_version_t i4fex_version;
	img4_firmware_authenticated_execute_t i4fex_execute;
	void *i4fex_context;
} img4_firmware_execution_context_t;
struct _img4_nonce {
	img4_struct_version_t i4n_version;
	uint8_t i4n_nonce[IMG4_NONCE_MAX_LENGTH];
	uint32_t i4n_length;
} img4_nonce_t;
struct _img4_buff {
	img4_struct_version_t i4b_version;
	uint8_t *__counted_by(i4b_len) i4b_bytes;
	size_t i4b_len;
	img4_runtime_dealloc_t _Nullable i4b_dealloc;
} IMG4_API_AVAILABLE_20200508;
struct _img4_runtime {
	img4_struct_version_t i4rt_version;
	const char *i4rt_name;
	img4_runtime_init_t _Nullable i4rt_init;
	img4_runtime_alloc_t i4rt_alloc;
	img4_runtime_dealloc_t i4rt_dealloc;
	img4_runtime_log_t i4rt_log;
	img4_runtime_log_handle_t i4rt_log_handle;
	img4_runtime_get_identifier_bool_t i4rt_get_identifier_bool;
	img4_runtime_get_identifier_uint32_t i4rt_get_identifier_uint32;
	img4_runtime_get_identifier_uint64_t i4rt_get_identifier_uint64;
	img4_runtime_get_identifier_digest_t i4rt_get_identifier_digest;
	void *_Nullable i4rt_context;
	img4_runtime_get_identifier_cstr_t i4rt_get_identifier_cstr;
	img4_runtime_execute_object_t i4rt_execute_object;
	img4_runtime_copy_object_t i4rt_copy_object;
	img4_runtime_alloc_type_t i4rt_alloc_type;
	img4_runtime_dealloc_type_t i4rt_dealloc_type;
	img4_runtime_set_nonce_t i4rt_set_nonce;
	img4_runtime_roll_nonce_t i4rt_roll_nonce;
	img4_runtime_copy_nonce_t i4rt_copy_nonce;
} IMG4_API_AVAILABLE_20200508;
struct fat_header {
	uint32_t	magic;		
	uint32_t	nfat_arch;	
};
struct fat_arch {
	cpu_type_t	cputype;	
	cpu_subtype_t	cpusubtype;	
	uint32_t	offset;		
	uint32_t	size;		
	uint32_t	align;		
};
struct mach_header {
	uint32_t	magic;		
	cpu_type_t	cputype;	
	cpu_subtype_t	cpusubtype;	
	uint32_t	filetype;	
	uint32_t	ncmds;		
	uint32_t	sizeofcmds;	
	uint32_t	flags;		
};
struct mach_header_64 {
	uint32_t	magic;		
	cpu_type_t	cputype;	
	cpu_subtype_t	cpusubtype;	
	uint32_t	filetype;	
	uint32_t	ncmds;		
	uint32_t	sizeofcmds;	
	uint32_t	flags;		
	uint32_t	reserved;	
};
struct load_command {
	uint32_t cmd;		
	uint32_t cmdsize;	
};
struct segment_command { 
	uint32_t	cmd;		
	uint32_t	cmdsize;	
	char		segname[16];	
	uint32_t	vmaddr;		
	uint32_t	vmsize;		
	uint32_t	fileoff;	
	uint32_t	filesize;	
	vm_prot_t	maxprot;	
	vm_prot_t	initprot;	
	uint32_t	nsects;		
	uint32_t	flags;		
};
struct segment_command_64 { 
	uint32_t	cmd;		
	uint32_t	cmdsize;	
	char		segname[16];	
	uint64_t	vmaddr;		
	uint64_t	vmsize;		
	uint64_t	fileoff;	
	uint64_t	filesize;	
	vm_prot_t	maxprot;	
	vm_prot_t	initprot;	
	uint32_t	nsects;		
	uint32_t	flags;		
};
struct section { 
	char		sectname[16];	
	char		segname[16];	
	uint32_t	addr;		
	uint32_t	size;		
	uint32_t	offset;		
	uint32_t	align;		
	uint32_t	reloff;		
	uint32_t	nreloc;		
	uint32_t	flags;		
	uint32_t	reserved1;	
	uint32_t	reserved2;	
};
struct section_64 { 
	char		sectname[16];	
	char		segname[16];	
	uint64_t	addr;		
	uint64_t	size;		
	uint32_t	offset;		
	uint32_t	align;		
	uint32_t	reloff;		
	uint32_t	nreloc;		
	uint32_t	flags;		
	uint32_t	reserved1;	
	uint32_t	reserved2;	
	uint32_t	reserved3;	
};
struct fvmlib {
	union lc_str	name;		
	uint32_t	minor_version;	
	uint32_t	header_addr;	
};
struct fvmlib_command {
	uint32_t	cmd;		
	uint32_t	cmdsize;	
	struct fvmlib	fvmlib;		
};
struct dylib {
    union lc_str  name;			
    uint32_t timestamp;			
    uint32_t current_version;		
    uint32_t compatibility_version;	
};
struct dylib_command {
	uint32_t	cmd;		
	uint32_t	cmdsize;	
	struct dylib	dylib;		
};
struct sub_framework_command {
	uint32_t	cmd;		
	uint32_t	cmdsize;	
	union lc_str 	umbrella;	
};
struct sub_client_command {
	uint32_t	cmd;		
	uint32_t	cmdsize;	
	union lc_str 	client;		
};
struct sub_umbrella_command {
	uint32_t	cmd;		
	uint32_t	cmdsize;	
	union lc_str 	sub_umbrella;	
};
struct sub_library_command {
	uint32_t	cmd;		
	uint32_t	cmdsize;	
	union lc_str 	sub_library;	
};
struct prebound_dylib_command {
	uint32_t	cmd;		
	uint32_t	cmdsize;	
	union lc_str	name;		
	uint32_t	nmodules;	
	union lc_str	linked_modules;	
};
struct dylinker_command {
	uint32_t	cmd;		
	uint32_t	cmdsize;	
	union lc_str    name;		
};
struct thread_command {
	uint32_t	cmd;		
	uint32_t	cmdsize;	
};
struct routines_command { 
	uint32_t	cmd;		
	uint32_t	cmdsize;	
	uint32_t	init_address;	
	uint32_t	init_module;	
				        
	uint32_t	reserved1;
	uint32_t	reserved2;
	uint32_t	reserved3;
	uint32_t	reserved4;
	uint32_t	reserved5;
	uint32_t	reserved6;
};
struct routines_command_64 { 
	uint32_t	cmd;		
	uint32_t	cmdsize;	
	uint64_t	init_address;	
	uint64_t	init_module;	
					
	uint64_t	reserved1;
	uint64_t	reserved2;
	uint64_t	reserved3;
	uint64_t	reserved4;
	uint64_t	reserved5;
	uint64_t	reserved6;
};
struct symtab_command {
	uint32_t	cmd;		
	uint32_t	cmdsize;	
	uint32_t	symoff;		
	uint32_t	nsyms;		
	uint32_t	stroff;		
	uint32_t	strsize;	
};
struct dysymtab_command {
    uint32_t cmd;	
    uint32_t cmdsize;	

    
    uint32_t ilocalsym;	
    uint32_t nlocalsym;	

    uint32_t iextdefsym;
    uint32_t nextdefsym;

    uint32_t iundefsym;	
    uint32_t nundefsym;	

    
    uint32_t tocoff;	
    uint32_t ntoc;	

    
    uint32_t modtaboff;	
    uint32_t nmodtab;	

    
    uint32_t extrefsymoff;	
    uint32_t nextrefsyms;	

    
    uint32_t indirectsymoff; 
    uint32_t nindirectsyms;  

    
    uint32_t extreloff;	
    uint32_t nextrel;	

    
    uint32_t locreloff;	
    uint32_t nlocrel;	

};
struct dylib_table_of_contents {
    uint32_t symbol_index;	
    uint32_t module_index;	
};
struct dylib_module {
    uint32_t module_name;	

    uint32_t iextdefsym;	
    uint32_t nextdefsym;	
    uint32_t irefsym;		
    uint32_t nrefsym;		
    uint32_t ilocalsym;		
    uint32_t nlocalsym;		

    uint32_t iextrel;		
    uint32_t nextrel;		

    uint32_t iinit_iterm;	
    uint32_t ninit_nterm;	

    uint32_t			
	objc_module_info_addr;  
    uint32_t			
	objc_module_info_size;	
};
struct dylib_module_64 {
    uint32_t module_name;	

    uint32_t iextdefsym;	
    uint32_t nextdefsym;	
    uint32_t irefsym;		
    uint32_t nrefsym;		
    uint32_t ilocalsym;		
    uint32_t nlocalsym;		

    uint32_t iextrel;		
    uint32_t nextrel;		

    uint32_t iinit_iterm;	
    uint32_t ninit_nterm;      

    uint32_t			
        objc_module_info_size;	
    uint64_t			
        objc_module_info_addr;	
};
struct dylib_reference {
    uint32_t isym:24,		
    		  flags:8;	
};
struct twolevel_hints_command {
    uint32_t cmd;	
    uint32_t cmdsize;	
    uint32_t offset;	
    uint32_t nhints;	
};
struct twolevel_hint {
    uint32_t 
	isub_image:8,	
	itoc:24;	
};
struct prebind_cksum_command {
    uint32_t cmd;	
    uint32_t cmdsize;	
    uint32_t cksum;	
};
struct uuid_command {
    uint32_t	cmd;		
    uint32_t	cmdsize;	
    uint8_t	uuid[16];	
};
struct rpath_command {
    uint32_t	 cmd;		
    uint32_t	 cmdsize;	
    union lc_str path;		
};
struct linkedit_data_command {
    uint32_t	cmd;		
    uint32_t	cmdsize;	
    uint32_t	dataoff;	
    uint32_t	datasize;	
};
struct fileset_entry_command {
    uint32_t        cmd;        
    uint32_t        cmdsize;    
    uint64_t        vmaddr;     
    uint64_t        fileoff;    
    union lc_str    entry_id;   
    uint32_t        reserved;   
};
struct encryption_info_command {
   uint32_t	cmd;		
   uint32_t	cmdsize;	
   uint32_t	cryptoff;	
   uint32_t	cryptsize;	
   uint32_t	cryptid;	
};
struct encryption_info_command_64 {
   uint32_t	cmd;		
   uint32_t	cmdsize;	
   uint32_t	cryptoff;	
   uint32_t	cryptsize;	
   uint32_t	cryptid;	
   uint32_t	pad;		
};
struct version_min_command {
    uint32_t	cmd;		
    uint32_t	cmdsize;	
    uint32_t	version;	
    uint32_t	sdk;		
};
struct build_version_command {
    uint32_t	cmd;		
    uint32_t	cmdsize;	
                                
    uint32_t	platform;	
    uint32_t	minos;		
    uint32_t	sdk;		
    uint32_t	ntools;		
};
struct build_tool_version {
    uint32_t	tool;		
    uint32_t	version;	
};
struct dyld_info_command {
   uint32_t   cmd;		
   uint32_t   cmdsize;		

    
    uint32_t   rebase_off;	
    uint32_t   rebase_size;	
    
    
    uint32_t   bind_off;	
    uint32_t   bind_size;	
        
    
    uint32_t   weak_bind_off;	
    uint32_t   weak_bind_size;  
    
    
    uint32_t   lazy_bind_off;	
    uint32_t   lazy_bind_size;  
    
    
    uint32_t   export_off;	
    uint32_t   export_size;	
};
struct linker_option_command {
    uint32_t  cmd;	
    uint32_t  cmdsize;
    uint32_t  count;	
    
};
struct symseg_command {
	uint32_t	cmd;		
	uint32_t	cmdsize;	
	uint32_t	offset;		
	uint32_t	size;		
};
struct ident_command {
	uint32_t cmd;		
	uint32_t cmdsize;	
};
struct fvmfile_command {
	uint32_t cmd;			
	uint32_t cmdsize;		
	union lc_str	name;		
	uint32_t	header_addr;	
};
struct entry_point_command {
    uint32_t  cmd;	
    uint32_t  cmdsize;	
    uint64_t  entryoff;	
    uint64_t  stacksize;
};
struct source_version_command {
    uint32_t  cmd;	
    uint32_t  cmdsize;	
    uint64_t  version;	
};
struct data_in_code_entry {
    uint32_t	offset;  
    uint16_t	length;  
    uint16_t	kind;    
};
struct note_command {
    uint32_t	cmd;		
    uint32_t	cmdsize;	
    char	data_owner[16];	
    uint64_t	offset;		
    uint64_t	size;		
};
struct nlist {
	union {
		uint32_t n_strx;	
	} n_un;
	uint8_t n_type;		
	uint8_t n_sect;		
	int16_t n_desc;		
	uint32_t n_value;	
};
struct nlist_64 {
    union {
        uint32_t  n_strx; 
    } n_un;
    uint8_t n_type;        
    uint8_t n_sect;        
    uint16_t n_desc;       
    uint64_t n_value;      
};
struct relocation_info {
   int32_t	r_address;	
   uint32_t     r_symbolnum:24,	
		r_pcrel:1, 	
		r_length:2,	
		r_extern:1,	
		r_type:4;	
};
struct scattered_relocation_info {
};
struct __darwin_pthread_handler_rec {
	void (*__routine)(void *);	
	void *__arg;			
	struct __darwin_pthread_handler_rec *__next;
};
struct _opaque_pthread_attr_t {
	long __sig;
	char __opaque[__PTHREAD_ATTR_SIZE__];
};
struct _opaque_pthread_cond_t {
	long __sig;
	char __opaque[__PTHREAD_COND_SIZE__];
};
struct _opaque_pthread_condattr_t {
	long __sig;
	char __opaque[__PTHREAD_CONDATTR_SIZE__];
};
struct _opaque_pthread_mutex_t {
	long __sig;
	char __opaque[__PTHREAD_MUTEX_SIZE__];
};
struct _opaque_pthread_mutexattr_t {
	long __sig;
	char __opaque[__PTHREAD_MUTEXATTR_SIZE__];
};
struct _opaque_pthread_once_t {
	long __sig;
	char __opaque[__PTHREAD_ONCE_SIZE__];
};
struct _opaque_pthread_rwlock_t {
	long __sig;
	char __opaque[__PTHREAD_RWLOCK_SIZE__];
};
struct _opaque_pthread_rwlockattr_t {
	long __sig;
	char __opaque[__PTHREAD_RWLOCKATTR_SIZE__];
};
struct _opaque_pthread_t {
	long __sig;
	struct __darwin_pthread_handler_rec  *__cleanup_stack;
	char __opaque[__PTHREAD_SIZE__];
};
struct _cr0 {
    unsigned int	pe	:1,
    			mp	:1,
			em	:1,
			ts	:1,
				:1,
			ne	:1,
				:10,
			wp	:1,
				:1,
			am	:1,
				:10,
			nw	:1,
			cd	:1,
			pg	:1;
} cr0_t;
struct code_desc {
    unsigned short	limit00;
    unsigned short	base00;
    unsigned char	base16;
    unsigned char	type	:5,
			dpl	:2,
			present	:1;
    unsigned char	limit16	:4,
				:1,
                        Lflag   :1,
			opsz	:1,
			granular:1;
    unsigned char	base24;
} code_desc_t;
struct data_desc {
    unsigned short	limit00;
    unsigned short	base00;
    unsigned char	base16;
    unsigned char	type	:5,
			dpl	:2,
			present	:1;
    unsigned char	limit16	:4,
				:2,
			stksz	:1,
			granular:1;
    unsigned char	base24;
} data_desc_t;
struct ldt_desc {
    unsigned short	limit00;
    unsigned short	base00;
    unsigned char	base16;
    unsigned char	type	:5,
				:2,
			present	:1;
    unsigned char	limit16	:4,
				:3,
			granular:1;
    unsigned char	base24;
} ldt_desc_t;
struct call_gate {
    unsigned short	offset00;
    sel_t		seg;
    unsigned int	argcnt	:5,
    				:3,
			type	:5,
			dpl	:2,
			present	:1,
			offset16:16;
} call_gate_t;
struct trap_gate {
    unsigned short	offset00;
    sel_t		seg;
    unsigned int		:8,
    			type	:5,
			dpl	:2,
			present	:1,
			offset16:16;
} trap_gate_t;
struct intr_gate {
    unsigned short	offset00;
    sel_t		seg;
    unsigned int		:8,
    			type	:5,
			dpl	:2,
			present	:1,
			offset16:16;
} intr_gate_t;
struct sel {
    unsigned short	rpl	:2,
			ti	:1,
			index	:13;
} sel_t;
struct tss {
    sel_t		oldtss;
    unsigned int		:0;
    unsigned int	esp0;
    sel_t		ss0;
    unsigned int		:0;
    unsigned int	esp1;
    sel_t		ss1;
    unsigned int		:0;
    unsigned int	esp2;
    sel_t		ss2;
    unsigned int		:0;
    unsigned int	cr3;
    unsigned int	eip;
    unsigned int	eflags;
    unsigned int	eax;
    unsigned int	ecx;
    unsigned int	edx;
    unsigned int	ebx;
    unsigned int	esp;
    unsigned int	ebp;
    unsigned int	esi;
    unsigned int	edi;
    sel_t		es;
    unsigned int		:0;
    sel_t		cs;
    unsigned int		:0;
    sel_t		ss;
    unsigned int		:0;
    sel_t		ds;
    unsigned int		:0;
    sel_t		fs;
    unsigned int		:0;
    sel_t		gs;
    unsigned int		:0;
    sel_t		ldt;
    unsigned int		:0;
    unsigned int	t	:1,
    				:15,
			io_bmap	:16;
} tss_t;
struct tss_desc {
    unsigned short	limit00;
    unsigned short	base00;
    unsigned char	base16;
    unsigned char	type	:5,
			dpl	:2,
			present	:1;
    unsigned char	limit16	:4,
				:3,
			granular:1;
    unsigned char	base24;
} tss_desc_t;
struct task_gate {
    unsigned short		:16;
    sel_t		tss;
    unsigned int		:8,
    			type	:5,
			dpl	:2,
			present	:1,
				:0;
} task_gate_t;
struct fasttrap_machtp {
	fasttrap_instr_t        ftmt_instr;     

	uint8_t                 ftmt_fntype;    
	uint8_t                 ftmt_thumb;

	uint8_t                 ftmt_type;
	uint8_t                 ftmt_installed:1;
	uint8_t                 ftmt_retired:1;
} fasttrap_machtp_t;
struct au_tid {
	dev_t           port;
	u_int32_t       machine;
};
struct au_tid_addr {
	dev_t           at_port;
	u_int32_t       at_type;
	u_int32_t       at_addr[4];
};
struct au_mask {
	unsigned int    am_success;     
	unsigned int    am_failure;     
};
struct auditinfo {
	au_id_t         ai_auid;        
	au_mask_t       ai_mask;        
	au_tid_t        ai_termid;      
	au_asid_t       ai_asid;        
};
struct auditinfo_addr {
	au_id_t         ai_auid;        
	au_mask_t       ai_mask;        
	au_tid_addr_t   ai_termid;      
	au_asid_t       ai_asid;        
	au_asflgs_t     ai_flags;       
};
struct auditpinfo {
	pid_t           ap_pid;         
	au_id_t         ap_auid;        
	au_mask_t       ap_mask;        
	au_tid_t        ap_termid;      
	au_asid_t       ap_asid;        
};
struct auditpinfo_addr {
	pid_t           ap_pid;         
	au_id_t         ap_auid;        
	au_mask_t       ap_mask;        
	au_tid_addr_t   ap_termid;      
	au_asid_t       ap_asid;        
	au_asflgs_t     ap_flags;       
};
struct au_session {
	auditinfo_addr_t        *as_aia_p;      
	au_mask_t                as_mask;       
};
struct au_expire_after {
	time_t age;             
	size_t size;    
	unsigned char op_type; 
};
struct au_qctrl {
	int     aq_hiwater;     
	                        

	int     aq_lowater;     
	                        

	int     aq_bufsz;       
	int     aq_delay;       
	int     aq_minfree;     
};
struct audit_stat {
	unsigned int    as_version;
	unsigned int    as_numevent;
	int             as_generated;
	int             as_nonattrib;
	int             as_kernel;
	int             as_audit;
	int             as_auditctl;
	int             as_enqueue;
	int             as_written;
	int             as_wblocked;
	int             as_rblocked;
	int             as_dropped;
	int             as_totalsize;
	unsigned int    as_memused;
};
struct audit_fstat {
	u_int64_t       af_filesz;
	u_int64_t       af_currsz;
};
struct au_evclass_map {
	au_event_t      ec_number;
	au_class_t      ec_class;
};
struct au_token {
	u_char                  *t_data;
	size_t                   len;
	TAILQ_ENTRY(au_token)    tokens;
};
struct au_record {
	char                     used;          
	int                      desc;          
	TAILQ_HEAD(, au_token)   token_q;       
	u_char                  *data;
	size_t                   len;
	LIST_ENTRY(au_record)    au_rec_q;
};
struct km_drawrect {
	unsigned short x;       
	unsigned short y;
	unsigned short width;   
	unsigned short height;
	union {
		void *bits;     
		int   fill;     
	} data;
};
struct d86opnd {
	char            d86_opnd[OPLEN];        
	char            d86_prefix[PFIXLEN];    
	uint_t          d86_mode;               
	uint_t          d86_value_size;         
	uint64_t        d86_value;              
} d86opnd_t;
struct dis86 {
	uint_t          d86_mode;
	uint_t          d86_error;
	uint_t          d86_len;                
	int             d86_rmindex;            
	uint_t          d86_memsize;            
	char            d86_bytes[16];          
	char            d86_mnem[OPLEN];
	uint_t          d86_numopnds;
	uint_t          d86_rex_prefix;         
	char            *d86_seg_prefix;        
	uint_t          d86_opnd_size;
	uint_t          d86_addr_size;
	uint_t          d86_got_modrm;
	uint_t          d86_vsib;               
	struct d86opnd  d86_opnd[4];            
	int             (*d86_check_func)(void *);
	int             (*d86_get_byte)(void *);
	void            *d86_data;
} dis86_t;
struct chunklist_hdr {
	uint32_t cl_magic;
	uint32_t cl_header_size;
	uint8_t  cl_file_ver;
	uint8_t  cl_chunk_method;
	uint8_t  cl_sig_method;
	uint8_t  __unused1;
	uint64_t cl_chunk_count;
	uint64_t cl_chunk_offset;
	uint64_t cl_sig_offset;
} __attribute__((packed));
struct chunklist_chunk {
	uint32_t chunk_size;
	uint8_t  chunk_sha256[SHA256_DIGEST_LENGTH];
} __attribute__((packed));
struct chunklist_pubkey {
	const boolean_t is_production;
	const uint8_t key[CHUNKLIST_PUBKEY_LEN];
};
struct jetsam_state_s {
	bool                            inited; 
	bool                            limit_to_low_bands; 
	int                             index; 
	thread_t                        thread; 
	int                             jld_idle_kills; 
	uint32_t                        errors; 
	bool                            sort_flag; 
	bool                            corpse_list_purged; 
	bool                            post_snapshot; 
	uint64_t                        memory_reclaimed; 
	uint32_t                        hwm_kills; 
	sched_cond_atomic_t             jt_wakeup_cond; 
} *jetsam_state_t;
struct memorystatus_system_health {
	bool msh_compressor_exhausted;
	bool msh_swap_exhausted;
	bool msh_swap_low_on_space;
	bool msh_zone_map_is_exhausted;
} memorystatus_system_health_t;
struct _load_result {
	user_addr_t             mach_header;
	user_addr_t             entry_point;

	user_addr_t             user_stack;
	mach_vm_size_t          user_stack_size;

	user_addr_t             user_stack_alloc;
	mach_vm_size_t          user_stack_alloc_size;

	mach_vm_address_t       all_image_info_addr;
	mach_vm_size_t          all_image_info_size;

	int                     thread_count;
	unsigned int
	    unixproc                : 1,
	    needs_dynlinker         : 1,
	    dynlinker               : 1,
	    validentry              : 1,
	    has_pagezero            : 1,
	    using_lcmain            : 1,
	    legacy_footprint        : 1,
	is_64bit_addr           : 1,
	    is_64bit_data           : 1,
	    custom_stack            : 1,
	    is_rosetta              : 1;
	unsigned int            csflags;
	unsigned char           uuid[16];
	mach_vm_address_t       min_vm_addr;
	mach_vm_address_t       max_vm_addr;
	mach_vm_address_t       ro_vm_start;
	mach_vm_address_t       ro_vm_end;
	unsigned int            platform_binary;

	HR_flags_t              hardened_runtime_binary;
	off_t                   cs_end_offset;
	void                    *threadstate;
	size_t                  threadstate_sz;
	uint32_t                ip_platform;
	uint32_t                lr_min_sdk;
	uint32_t                lr_sdk;
	user_addr_t             dynlinker_mach_header;
	user_addr_t             dynlinker_max_vm_addr;
	mach_vm_address_t       dynlinker_ro_vm_start;
	mach_vm_address_t       dynlinker_ro_vm_end;
	int                     dynlinker_fd;
	struct fileproc*        dynlinker_fp;
} load_result_t;
struct soflow_hash_entry {
	LIST_ENTRY(soflow_hash_entry)       soflow_entry_link;
	TAILQ_ENTRY(soflow_hash_entry)      soflow_entry_list_link;
	os_refcnt_t                         soflow_ref_count;
	struct soflow_db                    *soflow_db;
	uint16_t                            soflow_outifindex;
	in_port_t                           soflow_fport;
	in_port_t                           soflow_lport;
	sa_family_t                         soflow_family;
	uint32_t                            soflow_flowhash;
	uint64_t                            soflow_lastused;
	uint32_t                            soflow_faddr6_ifscope;
	uint32_t                            soflow_laddr6_ifscope;
	union {
		
		struct in_addr_4in6             addr46;
		struct in6_addr                 addr6;
	} soflow_faddr;
	union {
		
		struct in_addr_4in6             addr46;
		struct in6_addr                 addr6;
	} soflow_laddr;
	uint8_t                             soflow_outgoing: 1;
	uint8_t                             soflow_laddr_updated: 1;
	uint8_t                             soflow_lport_updated: 1;
	uint8_t                             soflow_gc: 1;
	uint8_t                             soflow_feat_gc: 1;
	uint8_t                             soflow_debug: 1;
	uint8_t                             soflow_reserved:2;

	uint64_t                            soflow_rxpackets;
	uint64_t                            soflow_rxbytes;
	uint64_t                            soflow_txpackets;
	uint64_t                            soflow_txbytes;

	uint64_t                            soflow_feat_ctxt_id;
	void                                *soflow_feat_ctxt;
	uint32_t                            soflow_filter_control_unit;
	int32_t                             soflow_policies_gencount;

	struct timeval                      soflow_timestamp;
};
struct soflow_db {
	os_refcnt_t                         soflow_db_ref_count;
	struct socket                       *soflow_db_so;
	uint32_t                            soflow_db_count;
	struct soflow_hash_head             * __counted_by(SOFLOW_HASH_SIZE) soflow_db_hashbase;
	u_long                              soflow_db_hashmask;
	struct soflow_hash_entry            *soflow_db_only_entry;

	uint8_t                             soflow_db_debug:1;
	uint8_t                             soflow_db_reserved:7;
	uint64_t                            soflow_db_flags;
};
struct ptmx_ioctl {
	struct tty      *pt_tty;        
	int             pt_flags;
	struct selinfo  pt_selr;
	struct selinfo  pt_selw;
	u_char          pt_send;
	u_char          pt_ucntl;
	void            *pt_devhandle;  
};
struct tty_dev_t {
	int primary;     
	int replica;     
	unsigned int    fix_7828447:1,
	    fix_7070978:1,
	    mac_notify:1,
	    open_reset:1,
	    _reserved:28;
	int _pad;

	struct tty_dev_t *next;

	struct ptmx_ioctl *(*open)(int minor, int flags);
	int (*free)(int minor, int flags);
	int (*name)(int minor, char *buffer, size_t size);
	void (*revoke)(int minor, struct tty *tp);
};
struct consdev {
	char    *cn_name;       
	int     (*cn_probe)(void);      
	int     (*cn_init)(void);       
	int     (*cn_getc)(void);       
	int     (*cn_putc)(void);       
	struct  tty *cn_tp;     
	dev_t   cn_dev;         
	short   cn_pri;         
};
struct exec_info {
	char    path[MAXPATHLEN];
	int     ac;
	int     ec;
	char    **av;
	char    **ev;
};
struct net_bloom_filter {
	uint32_t b_table_num_bits;
	uint32_t b_table[__counted_by(net_bloom_howmany(b_table_num_bits, kNetBloomFilterBitsPerTableElement))];
};
struct bpf_d {
	struct bpf_d    *bd_next;       
	caddr_t BPF_BIDI_INDEXABLE bd_sbuf; 
	caddr_t BPF_BIDI_INDEXABLE bd_hbuf; 
	caddr_t BPF_BIDI_INDEXABLE bd_fbuf; 
	uint32_t        bd_slen;        
	uint32_t        bd_hlen;        
	uint32_t        bd_scnt;        
	uint32_t        bd_hcnt;        

	uint32_t        bd_bufsize;     
	bool            bd_hbuf_read;   
	bool            bd_hbuf_write;  
	bool            bd_headdrop;    

	uint32_t        bd_write_size_max;      

	uint32_t        bd_rtout;       
	struct bpf_if   *bd_bif;        
	struct bpf_insn *__counted_by(bd_filter_len) bd_filter; 
	uint32_t        bd_filter_len;  
	uint64_t        bd_rcount;      
	uint64_t        bd_dcount;      
	uint64_t        bd_fcount;      

	uint64_t        bd_wcount;      
	uint64_t        bd_wdcount;     

	uint8_t         bd_promisc;     
	uint8_t         bd_state;       
	uint8_t         bd_immediate;   
	uint32_t        bd_dev_minor;   
	int             bd_async;       
	int             bd_sig;         
	pid_t           bd_sigio;

	struct selinfo  bd_sel;         

	int             bd_hdrcmplt;    
	u_int           bd_direction;   
	int             bd_oflags;      
	thread_call_t   bd_thread_call; 
	int             bd_traffic_class; 
	int             bd_flags;       
	int             bd_tstamp;      

	int             bd_refcnt;
	void            *bd_ref_lr[BPF_REF_HIST];
	void            *bd_unref_lr[BPF_REF_HIST];
	int             bd_next_ref_lr;
	int             bd_next_unref_lr;

	struct proc     *bd_opened_by;
	uuid_t          bd_uuid;
	pid_t           bd_pid;

	uint8_t         bd_prev_slen;
	caddr_t BPF_BIDI_INDEXABLE bd_prev_sbuf;
	caddr_t BPF_BIDI_INDEXABLE bd_prev_fbuf;

	struct bpf_comp_stats bd_bcs;
};
struct bpf_if {
	struct bpf_if *bif_next;        
	struct bpf_d *bif_dlist;        
	uint32_t bif_dlt;                  
	uint32_t bif_hdrlen;               
	uint32_t bif_exthdrlen;            
	uint32_t bif_comphdrlen;        
	struct ifnet *bif_ifp;          
	bpf_send_func   bif_send;
	bpf_tap_func    bif_tap;
};
struct bstp_cb_ops {
	bstp_state_cb_t bcb_state;
	bstp_rtage_cb_t bcb_rtage;
};
struct bstp_cbpdu {
	uint8_t         cbu_dsap;               
	uint8_t         cbu_ssap;               
	uint8_t         cbu_ctl;                
	uint16_t        cbu_protoid;            
	uint8_t         cbu_protover;           
	uint8_t         cbu_bpdutype;           
	uint8_t         cbu_flags;              

	uint16_t        cbu_rootpri;            
	uint8_t         cbu_rootaddr[6];        

	uint32_t        cbu_rootpathcost;       

	uint16_t        cbu_bridgepri;          
	uint8_t         cbu_bridgeaddr[6];      

	uint16_t        cbu_portid;             
	uint16_t        cbu_messageage;         
	uint16_t        cbu_maxage;             
	uint16_t        cbu_hellotime;          
	uint16_t        cbu_forwarddelay;       
	uint8_t         cbu_versionlen;         
} __attribute__((__packed__));
struct bstp_tbpdu {
	uint8_t         tbu_dsap;               
	uint8_t         tbu_ssap;               
	uint8_t         tbu_ctl;                
	uint16_t        tbu_protoid;            
	uint8_t         tbu_protover;           
	uint8_t         tbu_bpdutype;           
} __attribute__((__packed__));
struct bstp_task {
	TAILQ_ENTRY(bstp_task)  bt_next;
	int                                             bt_count;
	bstp_task_func_t                *bt_func;
	void                                    *bt_context;
};
struct bstp_timer {
	int             active;
	int             latched;
	int             value;
};
struct bstp_pri_vector {
	uint64_t                pv_root_id;
	uint32_t                pv_cost;
	uint64_t                pv_dbridge_id;
	uint16_t                pv_dport_id;
	uint16_t                pv_port_id;
};
struct bstp_config_unit {
	struct bstp_pri_vector  cu_pv;
	uint16_t        cu_message_age;
	uint16_t        cu_max_age;
	uint16_t        cu_forward_delay;
	uint16_t        cu_hello_time;
	uint8_t         cu_message_type;
	uint8_t         cu_topology_change_ack;
	uint8_t         cu_topology_change;
	uint8_t         cu_proposal;
	uint8_t         cu_agree;
	uint8_t         cu_learning;
	uint8_t         cu_forwarding;
	uint8_t         cu_role;
};
struct bstp_tcn_unit {
	uint8_t         tu_message_type;
};
struct bstp_port {
	LIST_ENTRY(bstp_port)   bp_next;
	struct ifnet            *bp_ifp;        
	struct bstp_state       *bp_bs;
	uint8_t                 bp_active;
	uint8_t                 bp_protover;
	uint32_t                bp_flags;
	uint32_t                bp_path_cost;
	uint16_t                bp_port_msg_age;
	uint16_t                bp_port_max_age;
	uint16_t                bp_port_fdelay;
	uint16_t                bp_port_htime;
	uint16_t                bp_desg_msg_age;
	uint16_t                bp_desg_max_age;
	uint16_t                bp_desg_fdelay;
	uint16_t                bp_desg_htime;
	struct bstp_timer       bp_edge_delay_timer;
	struct bstp_timer       bp_forward_delay_timer;
	struct bstp_timer       bp_hello_timer;
	struct bstp_timer       bp_message_age_timer;
	struct bstp_timer       bp_migrate_delay_timer;
	struct bstp_timer       bp_recent_backup_timer;
	struct bstp_timer       bp_recent_root_timer;
	struct bstp_timer       bp_tc_timer;
	struct bstp_config_unit bp_msg_cu;
	struct bstp_pri_vector  bp_desg_pv;
	struct bstp_pri_vector  bp_port_pv;
	uint16_t                bp_port_id;
	uint8_t                 bp_state;
	uint8_t                 bp_tcstate;
	uint8_t                 bp_role;
	uint8_t                 bp_infois;
	uint8_t                 bp_tc_ack;
	uint8_t                 bp_tc_prop;
	uint8_t                 bp_fdbflush;
	uint8_t                 bp_priority;
	uint8_t                 bp_ptp_link;
	uint8_t                 bp_agree;
	uint8_t                 bp_agreed;
	uint8_t                 bp_sync;
	uint8_t                 bp_synced;
	uint8_t                 bp_proposing;
	uint8_t                 bp_proposed;
	uint8_t                 bp_operedge;
	uint8_t                 bp_reroot;
	uint8_t                 bp_rcvdtc;
	uint8_t                 bp_rcvdtca;
	uint8_t                 bp_rcvdtcn;
	uint32_t                bp_forward_transitions;
	uint8_t                 bp_txcount;
	struct bstp_task        bp_statetask;
	struct bstp_task        bp_rtagetask;
	uint32_t                bp_if_link_state;       
};
struct bstp_state {
	LIST_ENTRY(bstp_state)  bs_list;
	uint8_t                 bs_running;
	lck_mtx_t               bs_mtx;
	struct bstp_pri_vector  bs_bridge_pv;
	struct bstp_pri_vector  bs_root_pv;
	struct bstp_port        *bs_root_port;
	uint8_t                 bs_protover;
	uint16_t                bs_migration_delay;
	uint16_t                bs_edge_delay;
	uint16_t                bs_bridge_max_age;
	uint16_t                bs_bridge_fdelay;
	uint16_t                bs_bridge_htime;
	uint16_t                bs_root_msg_age;
	uint16_t                bs_root_max_age;
	uint16_t                bs_root_fdelay;
	uint16_t                bs_root_htime;
	uint16_t                bs_hold_time;
	uint16_t                bs_bridge_priority;
	uint8_t                 bs_txholdcount;
	uint8_t                 bs_allsynced;
	struct bstp_timer       bs_link_timer;
	struct timeval          bs_last_tc_time;
	LIST_HEAD(, bstp_port)  bs_bplist;
	bstp_state_cb_t         bs_state_cb;
	bstp_rtage_cb_t         bs_rtage_cb;
};
struct cfil_opt_sock_info {
	cfil_sock_id_t  cfs_sock_id;
	int                             cfs_sock_family;        
	int                             cfs_sock_type;          
	int                             cfs_sock_protocol;      
	union sockaddr_in_4_6   cfs_local;
	union sockaddr_in_4_6   cfs_remote;
	pid_t                   cfs_pid;
	pid_t                   cfs_e_pid;
	pid_t                   cfs_r_pid;
	uuid_t                  cfs_uuid;
	uuid_t                  cfs_e_uuid;
	uuid_t                  cfs_r_uuid;
};
struct cfil_crypto_state {
	const struct ccdigest_info *digest_info;
	cfil_crypto_key key;
} *cfil_crypto_state_t;
struct cfil_crypto_data {
	uuid_t flow_id;
	u_int64_t sock_id;
	u_int32_t direction;
	union sockaddr_in_4_6 remote;
	union sockaddr_in_4_6 local;
	u_int32_t socketProtocol;
	pid_t pid;
	pid_t effective_pid;
	pid_t responsible_pid;
	uuid_t uuid;
	uuid_t effective_uuid;
	uuid_t responsible_uuid;
	u_int64_t byte_count_in;
	u_int64_t byte_count_out;
} *cfil_crypto_data_t;
struct cfil_msg_hdr {
	uint32_t        cfm_len;        
	uint32_t        cfm_version;
	uint32_t        cfm_type;
	uint32_t        cfm_op;
	cfil_sock_id_t  cfm_sock_id;
};
struct cfil_msg_sock_attached {
	struct cfil_msg_hdr     cfs_msghdr;
	int                     cfs_sock_family;        
	int                     cfs_sock_type;          
	int                     cfs_sock_protocol;      
	int                     cfs_unused;             
	pid_t                   cfs_pid;
	pid_t                   cfs_e_pid;
	pid_t                   cfs_r_pid;
	uuid_t                  cfs_uuid;
	uuid_t                  cfs_e_uuid;
	uuid_t                  cfs_r_uuid;
	union sockaddr_in_4_6   cfs_src;
	union sockaddr_in_4_6   cfs_dst;
	int                     cfs_conn_dir;
	unsigned int            cfs_audit_token[8];             
	unsigned int            cfs_real_audit_token[8];        
	cfil_crypto_signature   cfs_signature;
	uint32_t                cfs_signature_length;
	char                    cfs_remote_domain_name[CFS_MAX_DOMAIN_NAME_LENGTH];
};
struct cfil_msg_data_event {
	struct cfil_msg_hdr     cfd_msghdr;
	union sockaddr_in_4_6   cfc_src;
	union sockaddr_in_4_6   cfc_dst;
	uint64_t                cfd_start_offset;
	uint64_t                cfd_end_offset;
	cfil_crypto_signature   cfd_signature;
	uint32_t                cfd_signature_length;
	uint32_t                cfd_flags;
	pid_t                   cfd_delegated_pid;
	unsigned int            cfd_delegated_audit_token[8];
};
struct cfil_msg_sock_closed {
	struct cfil_msg_hdr     cfc_msghdr;
	struct timeval64        cfc_first_event;
	uint32_t                cfc_op_list_ctr;
	uint32_t                cfc_op_time[CFI_MAX_TIME_LOG_ENTRY];    
	unsigned char           cfc_op_list[CFI_MAX_TIME_LOG_ENTRY];
	uint64_t                cfc_byte_inbound_count;
	uint64_t                cfc_byte_outbound_count;
	union sockaddr_in_4_6   cfc_laddr;
	cfil_crypto_signature   cfc_signature;
	uint32_t                cfc_signature_length;
} __attribute__((aligned(8)));
struct cfil_msg_sock_stats {
	cfil_sock_id_t          cfs_sock_id;
	uint64_t                cfs_byte_inbound_count;
	uint64_t                cfs_byte_outbound_count;
	union sockaddr_in_4_6   cfs_laddr;
} __attribute__((aligned(8)));
struct cfil_msg_stats_report {
	struct cfil_msg_hdr        cfr_msghdr;
	uint32_t                   cfr_count;
	struct cfil_msg_sock_stats cfr_stats[];
} __attribute__((aligned(8)));
struct cfil_msg_action {
	struct cfil_msg_hdr     cfa_msghdr;
	uint64_t                cfa_in_pass_offset;
	uint64_t                cfa_in_peek_offset;
	uint64_t                cfa_out_pass_offset;
	uint64_t                cfa_out_peek_offset;
	uint32_t                cfa_stats_frequency; 
};
struct cfil_msg_bless_client {
	struct cfil_msg_hdr     cfb_msghdr;
	uuid_t cfb_client_uuid;
};
struct cfil_msg_set_crypto_key {
	struct cfil_msg_hdr     cfb_msghdr;
	cfil_crypto_key         crypto_key;
};
struct cfil_filter_stat {
	uint32_t        cfs_len;
	uint32_t        cfs_filter_id;
	uint32_t        cfs_flags;
	uint32_t        cfs_sock_count;
	uint32_t        cfs_necp_control_unit;
};
struct cfil_entry_stat {
	uint32_t                ces_len;
	uint32_t                ces_filter_id;
	uint32_t                ces_flags;
	uint32_t                ces_necp_control_unit;
	struct timeval64        ces_last_event;
	struct timeval64        ces_last_action;
	struct cfe_buf_stat {
		uint64_t        cbs_pending_first;
		uint64_t        cbs_pending_last;
		uint64_t        cbs_ctl_first;
		uint64_t        cbs_ctl_last;
		uint64_t        cbs_pass_offset;
		uint64_t        cbs_peek_offset;
		uint64_t        cbs_peeked;
	} ces_snd, ces_rcv;
};
struct cfil_sock_stat {
	uint32_t        cfs_len;
	int             cfs_sock_family;
	int             cfs_sock_type;
	int             cfs_sock_protocol;
	cfil_sock_id_t  cfs_sock_id;
	uint64_t        cfs_flags;
	pid_t           cfs_pid;
	pid_t           cfs_e_pid;
	uuid_t          cfs_uuid;
	uuid_t          cfs_e_uuid;
	struct cfi_buf_stat {
		uint64_t        cbs_pending_first;
		uint64_t        cbs_pending_last;
		uint64_t        cbs_pass_offset;
		uint64_t        cbs_inject_q_len;
	} cfs_snd, cfs_rcv;
	struct cfil_entry_stat  ces_entries[CFIL_MAX_FILTER_COUNT];
};
struct cfil_stats {
	int32_t cfs_ctl_connect_ok;
	int32_t cfs_ctl_connect_fail;
	int32_t cfs_ctl_disconnect_ok;
	int32_t cfs_ctl_disconnect_fail;
	int32_t cfs_ctl_send_ok;
	int32_t cfs_ctl_send_bad;
	int32_t cfs_ctl_rcvd_ok;
	int32_t cfs_ctl_rcvd_bad;
	int32_t cfs_ctl_rcvd_flow_lift;
	int32_t cfs_ctl_action_data_update;
	int32_t cfs_ctl_action_drop;
	int32_t cfs_ctl_action_bad_op;
	int32_t cfs_ctl_action_bad_len;

	int32_t cfs_sock_id_not_found;

	int32_t cfs_cfi_alloc_ok;
	int32_t cfs_cfi_alloc_fail;

	int32_t cfs_sock_userspace_only;
	int32_t cfs_sock_attach_in_vain;
	int32_t cfs_sock_attach_already;
	int32_t cfs_sock_attach_no_mem;
	int32_t cfs_sock_attach_failed;
	int32_t cfs_sock_attached;
	int32_t cfs_sock_detached;

	int32_t cfs_attach_event_ok;
	int32_t cfs_attach_event_flow_control;
	int32_t cfs_attach_event_fail;

	int32_t cfs_closed_event_ok;
	int32_t cfs_closed_event_flow_control;
	int32_t cfs_closed_event_fail;

	int32_t cfs_data_event_ok;
	int32_t cfs_data_event_flow_control;
	int32_t cfs_data_event_fail;

	int32_t cfs_stats_event_ok;
	int32_t cfs_stats_event_flow_control;
	int32_t cfs_stats_event_fail;

	int32_t cfs_disconnect_in_event_ok;
	int32_t cfs_disconnect_out_event_ok;
	int32_t cfs_disconnect_event_flow_control;
	int32_t cfs_disconnect_event_fail;

	int32_t cfs_ctl_q_not_started;

	int32_t cfs_close_wait;
	int32_t cfs_close_wait_timeout;

	int32_t cfs_flush_in_drop;
	int32_t cfs_flush_out_drop;
	int32_t cfs_flush_in_close;
	int32_t cfs_flush_out_close;
	int32_t cfs_flush_in_free;
	int32_t cfs_flush_out_free;

	int32_t cfs_inject_q_nomem;
	int32_t cfs_inject_q_nobufs;
	int32_t cfs_inject_q_detached;
	int32_t cfs_inject_q_in_fail;
	int32_t cfs_inject_q_out_fail;

	int32_t cfs_inject_q_in_retry;
	int32_t cfs_inject_q_out_retry;

	int32_t cfs_data_in_control;
	int32_t cfs_data_in_oob;
	int32_t cfs_data_out_control;
	int32_t cfs_data_out_oob;

	int64_t cfs_ctl_q_in_enqueued __attribute__((aligned(8)));
	int64_t cfs_ctl_q_out_enqueued __attribute__((aligned(8)));
	int64_t cfs_ctl_q_in_peeked __attribute__((aligned(8)));
	int64_t cfs_ctl_q_out_peeked __attribute__((aligned(8)));

	int64_t cfs_pending_q_in_enqueued __attribute__((aligned(8)));
	int64_t cfs_pending_q_out_enqueued __attribute__((aligned(8)));

	int64_t cfs_inject_q_in_enqueued __attribute__((aligned(8)));
	int64_t cfs_inject_q_out_enqueued __attribute__((aligned(8)));
	int64_t cfs_inject_q_in_passed __attribute__((aligned(8)));
	int64_t cfs_inject_q_out_passed __attribute__((aligned(8)));
};
struct dlil_threading_info {
	decl_lck_mtx_data(, dlth_lock);
	class_queue_t   dlth_pkts;      
	struct ifnet    *dlth_ifp;      
	struct ifnet_stat_increment_param dlth_stats; 
	uint32_t       dlth_flags;      
	uint32_t       dlth_wtot;       

	errno_t (*dlth_strategy)(struct dlil_threading_info *,
	    struct ifnet *, struct mbuf *, struct mbuf *,
	    const struct ifnet_stat_increment_param *, boolean_t,
	    struct thread *);

	boolean_t       dlth_affinity;          
	uint32_t        dlth_affinity_tag;      
	struct thread   *dlth_thread;           
	struct thread   *dlth_driver_thread;    
	struct thread   *dlth_poller_thread;    

	lck_grp_t       *dlth_lock_grp; 
	char            dlth_name_storage[DLIL_THREADNAME_LEN]; 
	const char * __null_terminated dlth_name;
	uint32_t        dlth_trim_cnt;          
	uint32_t        dlth_trim_pkts_dropped; 
};
struct dlil_main_threading_info {
	struct dlil_threading_info      inp;
	class_queue_t                   lo_rcvq_pkts; 
};
struct dl_if_lladdr_std {
	struct ifaddr   ifa;
	u_int8_t        addr_sdl_bytes[DLIL_SDLMAXLEN];
	u_int8_t        mask_sdl_bytes[DLIL_SDLMAXLEN];
};
struct dl_if_lladdr_xtra_space {
	struct ifaddr   ifa;
	u_int8_t        addr_sdl_bytes[SOCK_MAXADDRLEN];
	u_int8_t        mask_sdl_bytes[SOCK_MAXADDRLEN];
};
struct dlil_ifnet {
	struct ifnet    dl_if;                  
	decl_lck_mtx_data(, dl_if_lock);
	TAILQ_ENTRY(dlil_ifnet) dl_if_link;     
	u_int32_t dl_if_flags;                  
	u_int32_t dl_if_refcnt;                 
	void (*dl_if_trace)(struct dlil_ifnet *, int); 
	void    *dl_if_uniqueid __sized_by_or_null(dl_if_uniqueid_len);                
	size_t  dl_if_uniqueid_len;             
	char    dl_if_namestorage[IFNAMSIZ];    
	char    dl_if_xnamestorage[IFXNAMSIZ];  
	struct dl_if_lladdr_std dl_if_lladdr;   
	u_int8_t dl_if_descstorage[IF_DESCSIZE]; 
	u_int8_t dl_if_permanent_ether[ETHER_ADDR_LEN]; 
	u_int8_t dl_if_permanent_ether_is_set;
	u_int8_t dl_if_unused;
	struct dlil_threading_info dl_if_inpstorage; 
	ctrace_t        dl_if_attach;           
	ctrace_t        dl_if_detach;           
};
struct dlil_ifnet_dbg {
	struct dlil_ifnet       dldbg_dlif;             
	u_int16_t               dldbg_if_refhold_cnt;   
	u_int16_t               dldbg_if_refrele_cnt;   
	ctrace_t                dldbg_if_refhold[IF_REF_TRACE_HIST_SIZE];
	ctrace_t                dldbg_if_refrele[IF_REF_TRACE_HIST_SIZE];
};
struct ifnet_filter {
	TAILQ_ENTRY(ifnet_filter)       filt_next;
	u_int32_t                       filt_skip;
	u_int32_t                       filt_flags;
	ifnet_t                         filt_ifp;
	const char                      *filt_name;
	void                            *filt_cookie;
	protocol_family_t               filt_protocol;
	iff_input_func                  filt_input;
	iff_output_func                 filt_output;
	iff_event_func                  filt_event;
	iff_ioctl_func                  filt_ioctl;
	iff_detached_func               filt_detached;
};
struct droptap_header {
	struct pktap_header     dth_pktap_hdr;
	uint32_t                dth_dropreason;
	uint8_t                 dth_dropfunc_size;
	uint16_t                dth_dropline;
	char                    dth_dropfunc[DROPTAP_DROPFUNC_MAXLEN];
};
struct  ether_header {
	u_char  ether_dhost[ETHER_ADDR_LEN];
	u_char  ether_shost[ETHER_ADDR_LEN];
	u_short ether_type;
} ether_header_t;
struct  ether_addr {
	u_char octet[ETHER_ADDR_LEN];
} ether_addr_t;
struct  firewire_header {
	u_char  firewire_dhost[FIREWIRE_EUI64_LEN];
	u_char  firewire_shost[FIREWIRE_EUI64_LEN];
	u_short firewire_type;          
};
struct  firewire_eui64 {
	u_char octet[FIREWIRE_EUI64_LEN];
};
struct firewire_address {
	u_char      eui64[FIREWIRE_EUI64_LEN];
	u_char      maxRec;
	u_char      spd;
	u_int16_t   unicastFifoHi;
	u_int32_t   unicastFifoLo;
};
struct flowadv {
	int32_t         code;           
};
struct flowadv_fcentry {
	STAILQ_ENTRY(flowadv_fcentry) fce_link;
	u_int32_t        fce_flowsrc_type;       
	u_int32_t        fce_flowid;
	u_int32_t        fce_ce_cnt;
	u_int32_t        fce_pkts_since_last_report;
	fce_event_type_t fce_event_type;
};
struct  arphdr {
	u_short ar_hrd;         
	u_short ar_pro;         
	u_char  ar_hln;         
	u_char  ar_pln;         
	u_short ar_op;          

};
struct arpreq {
	struct  sockaddr arp_pa;                
	struct  sockaddr arp_ha;                
	int     arp_flags;                      
};
struct arpstat {
	uint32_t txrequests;    
	uint32_t txreplies;     
	uint32_t txannounces;   
	uint32_t rxrequests;    
	uint32_t rxreplies;     
	uint32_t received;      

	uint32_t txconflicts;   
	uint32_t invalidreqs;   
	uint32_t reqnobufs;     
	uint32_t dropped;       
	uint32_t purged;        
	uint32_t timeouts;      
	                        
	uint32_t dupips;        

	uint32_t inuse;         
	uint32_t txurequests;   
	uint32_t held;          
};
struct if_bond_partner_state {
	lacp_system                 ibps_system;
	lacp_system_priority        ibps_system_priority;
	lacp_key                    ibps_key;
	lacp_port                   ibps_port;
	lacp_port_priority          ibps_port_priority;
	lacp_actor_partner_state    ibps_state;
	u_char                      ibps_reserved1;
};
struct if_bond_status {
	char                        ibs_if_name[IFNAMSIZ];
	lacp_port_priority          ibs_port_priority;
	lacp_actor_partner_state    ibs_state;
	u_char                      ibs_selected_state;
	struct if_bond_partner_state ibs_partner_state;
	u_int32_t                   ibs_reserved[8];
};
struct if_bond_status_req {
	int         ibsr_version;
	int         ibsr_total; 
	int         ibsr_count; 
	union {                 
		void *          ibsru_buffer;
		u_int64_t       ibsru_buffer64;
	} ibsr_ibsru;
	lacp_key    ibsr_key;   
	u_int8_t    ibsr_mode;  
	u_int8_t    ibsr_reserved0;
	u_int32_t   ibsr_reserved[3];
};
struct if_bond_req {
	u_int32_t   ibr_op;                     
	union {
		char    ibru_if_name[IFNAMSIZ]; 
		struct if_bond_status_req ibru_status; 
		int     ibru_int_val;
	} ibr_ibru;
};
struct ifbreq {
	char            ifbr_ifsname[IFNAMSIZ]; 
	uint32_t        ifbr_ifsflags;          
	uint32_t        ifbr_stpflags;          
	uint32_t        ifbr_path_cost;         
	uint8_t         ifbr_portno;            
	uint8_t         ifbr_priority;          
	uint8_t         ifbr_proto;             
	uint8_t         ifbr_role;              
	uint8_t         ifbr_state;             
	uint32_t        ifbr_addrcnt;           
	uint32_t        ifbr_addrmax;           
	uint32_t        ifbr_addrexceeded;      
	uint8_t         pad[32];
};
struct ifbrparam {
	union {
		uint32_t ifbrpu_int32;
		uint16_t ifbrpu_int16;
		uint8_t ifbrpu_int8;
	} ifbrp_ifbrpu;
};
struct ifbpstpreq {
	uint8_t         ifbp_portno;            
	uint32_t        ifbp_fwd_trans;         
	uint32_t        ifbp_design_cost;       
	uint32_t        ifbp_design_port;       
	uint64_t        ifbp_design_bridge;     
	uint64_t        ifbp_design_root;       
};
struct ifbrhostfilter {
	uint32_t        ifbrhf_flags;           
	char            ifbrhf_ifsname[IFNAMSIZ];       
	uint8_t         ifbrhf_hwsrca[ETHER_ADDR_LEN];
	uint32_t        ifbrhf_ipsrc;
};
struct bridge_hostfilter_stats {
	uint64_t        brhf_bad_ether_type;
	uint64_t        brhf_bad_ether_srchw_addr;

	uint64_t        brhf_ether_too_small;
	uint64_t        brhf_ether_pullup_failed;

	uint64_t        brhf_arp_ok;
	uint64_t        brhf_arp_too_small;
	uint64_t        brhf_arp_pullup_failed;
	uint64_t        brhf_arp_bad_hw_type;
	uint64_t        brhf_arp_bad_pro_type;
	uint64_t        brhf_arp_bad_hw_len;
	uint64_t        brhf_arp_bad_pro_len;
	uint64_t        brhf_arp_bad_op;
	uint64_t        brhf_arp_bad_sha;
	uint64_t        brhf_arp_bad_spa;

	uint64_t        brhf_ip_ok;
	uint64_t        brhf_ip_too_small;
	uint64_t        brhf_ip_pullup_failed;
	uint64_t        brhf_ip_bad_srcaddr;
	uint64_t        brhf_ip_bad_proto;

	uint64_t        brhf_dhcp_too_small;
	uint64_t        brhf_dhcp_bad_op;
	uint64_t        brhf_dhcp_bad_htype;
	uint64_t        brhf_dhcp_bad_hlen;
	uint64_t        brhf_dhcp_bad_chaddr;
	uint64_t        brhf_dhcp_bad_ciaddr;
};
struct ifbrmne {
	char            ifbmne_ifname[IFNAMSIZ]; 
	uint64_t        ifbmne_expire;           
	uint8_t         ifbmne_mac[ETHER_ADDR_LEN];
	uint8_t         ifbmne_reserved;
	uint8_t         ifbmne_af;              
	union ifbrip    ifbmne_ip;
};
struct bripstats {
	uint64_t        bips_ip;
	uint64_t        bips_ip6;
	uint64_t        bips_udp;
	uint64_t        bips_tcp;

	uint64_t        bips_bad_ip;
	uint64_t        bips_bad_ip6;
	uint64_t        bips_bad_udp;
	uint64_t        bips_bad_tcp;
};
struct brcsumstats {
	uint64_t        brcs_ip_checksum;
	uint64_t        brcs_udp_checksum;
	uint64_t        brcs_tcp_checksum;
};
struct ifbrmstats {
	struct bripstats        brms_in_ip;
	struct bripstats        brms_out_ip;

	struct brcsumstats      brms_in_computed_cksum;

	struct brcsumstats      brms_out_cksum_good;
	struct brcsumstats      brms_out_cksum_good_hw;

	struct brcsumstats      brms_out_cksum_bad;
	struct brcsumstats      brms_out_cksum_bad_hw;
};
struct sockaddr_dl {
	u_char  sdl_len;        
	u_char  sdl_family;     
	u_short sdl_index;      
	u_char  sdl_type;       
	u_char  sdl_nlen;       
	u_char  sdl_alen;       
	u_char  sdl_slen;       
	char    sdl_data[12];
};
struct if_fake_media {
	int32_t         iffm_current;
	uint32_t        iffm_count;
	uint32_t        iffm_reserved[3];
	int32_t         iffm_list[IF_FAKE_MEDIA_LIST_MAX];
};
struct if_fake_request {
	uint64_t        iffr_reserved[4];
	union {
		char    iffru_buf[128];         
		struct if_fake_media    iffru_media;
		char    iffru_peer_name[IFNAMSIZ]; 
		
		uint32_t        iffru_dequeue_stall;
	} iffr_u;
};
struct gif_softc {
	ifnet_t                 gif_if;    
	struct sockaddr *gif_psrc; 
	struct sockaddr *gif_pdst; 
	protocol_family_t gif_proto; 
	union {
		struct route  gifscr_ro;    
		struct route_in6 gifscr_ro6; 
	} gifsc_gifscr;
	int             gif_flags;
	int             gif_called;
	const struct encaptab *encap_cookie4;
	const struct encaptab *encap_cookie6;
	TAILQ_ENTRY(gif_softc) gif_link; 
	bpf_tap_mode    tap_mode;
	bpf_packet_func tap_callback;
	char    gif_ifname[IFNAMSIZ];
	decl_lck_mtx_data(, gif_lock);  
};
struct ipsec_stats_param {
	u_int64_t       utsp_packets;
	u_int64_t       utsp_bytes;
	u_int64_t       utsp_errors;
};
struct llc {
	u_int8_t llc_dsap;
	u_int8_t llc_ssap;
	union {
		struct {
			u_int8_t control;
			u_int8_t format_id;
			u_int8_t class_id;
			u_int8_t window_x2;
		} type_u;
		struct {
			u_int8_t num_snd_x2;
			u_int8_t num_rcv_x2;
		} type_i;
		struct {
			u_int8_t control;
			u_int8_t num_rcv_x2;
		} type_s;
		struct {
			u_int8_t control;
			
			u_int8_t frmr_rej_pdu0;
			u_int8_t frmr_rej_pdu1;
			u_int8_t frmr_control;
			u_int8_t frmr_control_ext;
			u_int8_t frmr_cause;
		} type_frmr;
		struct {
			u_int8_t  control;
			u_int8_t  org_code[3];
			u_int16_t ether_type;
		} type_snap __attribute__((__packed__));
		struct {
			u_int8_t control;
			u_int8_t control_ext;
		} type_raw;
	} llc_un;
} __attribute__((__packed__));
struct frmrinfo {
	u_int8_t frmr_rej_pdu0;
	u_int8_t frmr_rej_pdu1;
	u_int8_t frmr_control;
	u_int8_t frmr_control_ext;
	u_int8_t frmr_cause;
} __attribute__((__packed__));
struct if_llreach_info {
	u_int32_t               lri_refcnt;     
	u_int32_t               lri_ifindex;    
	u_int64_t               lri_expire;     
	u_int32_t               lri_probes;     
	u_int16_t               lri_reserved;   
	u_int16_t               lri_proto;      
	u_int8_t                lri_addr[IF_LLREACHINFO_ADDRLEN]; 
	int32_t                 lri_rssi;       
	int32_t                 lri_lqm;        
	int32_t                 lri_npm;        
	u_int8_t                lri_reserved2[IF_LLREACHINFO_RESERVED2];
};
struct if_llreach {
	decl_lck_mtx_data(, lr_lock);
	RB_ENTRY(if_llreach)    lr_link;        
	struct ifnet            *lr_ifp;        
	u_int32_t               lr_refcnt;      
	u_int32_t               lr_reqcnt;      
	u_int32_t               lr_debug;       
	u_int32_t               lr_probes;      
	u_int64_t               lr_basecal;     
	u_int64_t               lr_baseup;      
	u_int64_t               lr_lastrcvd;    
	u_int32_t               lr_basereachable; 
	u_int32_t               lr_reachable;   
	struct lr_key_s {
		u_int16_t       proto;          
		u_int8_t        addr[IF_LLREACH_MAXLEN]; 
	} lr_key;
	int32_t                 lr_rssi;        
	int32_t                 lr_lqm;         
	int32_t                 lr_npm;         
};
struct ifmedia_description {
	int     ifmt_word;              
	const char *ifmt_string;        
};
struct ifmibdata {
	char                    ifmd_name[IFNAMSIZ]; 
	unsigned int            ifmd_pcount;    
	unsigned int            ifmd_flags;     
	unsigned int            ifmd_snd_len;   
	unsigned int            ifmd_snd_maxlen; 
	unsigned int            ifmd_snd_drops; 
	unsigned int            ifmd_filler[4]; 
	struct if_data64        ifmd_data; 
};
struct ifs_iso_8802_3 {
	u_int32_t       dot3StatsAlignmentErrors;
	u_int32_t       dot3StatsFCSErrors;
	u_int32_t       dot3StatsSingleCollisionFrames;
	u_int32_t       dot3StatsMultipleCollisionFrames;
	u_int32_t       dot3StatsSQETestErrors;
	u_int32_t       dot3StatsDeferredTransmissions;
	u_int32_t       dot3StatsLateCollisions;
	u_int32_t       dot3StatsExcessiveCollisions;
	u_int32_t       dot3StatsInternalMacTransmitErrors;
	u_int32_t       dot3StatsCarrierSenseErrors;
	u_int32_t       dot3StatsFrameTooLongs;
	u_int32_t       dot3StatsInternalMacReceiveErrors;
	u_int32_t       dot3StatsEtherChipSet;
	u_int32_t       dot3StatsMissedFrames;

	u_int32_t       dot3StatsCollFrequencies[16]; 

	u_int32_t       dot3Compliance;
};
struct ifmibdata_supplemental {
	struct if_traffic_class ifmd_traffic_class;
	struct if_data_extended ifmd_data_extended;
	struct if_packet_stats  ifmd_packet_stats;
	struct if_rxpoll_stats  ifmd_rxpoll_stats;
	struct if_netif_stats   ifmd_netif_stats;
};
struct xnpigen {
	uint32_t        xng_len; 
	uint32_t        xng_gen; 
	uint32_t        xng_npi_count; 
	uint32_t        xng_npi_size; 
	uuid_t          xng_wakeuuid; 
};
struct net_port_info {
	uint16_t                npi_if_index;
	uint16_t                npi_flags; 
	struct timeval32        npi_timestamp; 
	uuid_t                  npi_flow_uuid;
	in_port_t               npi_local_port; 
	in_port_t               npi_foreign_port; 
	union in_addr_4_6       npi_local_addr_;
	union in_addr_4_6       npi_foreign_addr_;
	pid_t                   npi_owner_pid;
	pid_t                   npi_effective_pid;
	char                    npi_owner_pname[MAXCOMLEN + 1];
	char                    npi_effective_pname[MAXCOMLEN + 1];
	uuid_t                  npi_owner_uuid;
	uuid_t                  npi_effective_uuid;
};
struct npi_if_info {
	uint32_t            npi_if_family; 
	uint32_t            npi_if_subfamily; 
	uint32_t            npi_if_functional_type; 
};
struct net_port_info_wake_event {
	uuid_t              wake_uuid;
	struct timeval32    wake_pkt_timestamp; 
	uint16_t            wake_pkt_if_index; 
	in_port_t           wake_pkt_port; 
	uint16_t            wake_pkt_flags; 
	pid_t               wake_pkt_owner_pid;
	pid_t               wake_pkt_effective_pid;
	char                wake_pkt_owner_pname[MAXCOMLEN + 1];
	char                wake_pkt_effective_pname[MAXCOMLEN + 1];
	uuid_t              wake_pkt_owner_uuid;
	uuid_t              wake_pkt_effective_uuid;
	in_port_t           wake_pkt_foreign_port; 
	union in_addr_4_6   wake_pkt_local_addr_;
	union in_addr_4_6   wake_pkt_foreign_addr_;
	char                wake_pkt_ifname[IFNAMSIZ]; 

	uint32_t            wake_pkt_total_len; 
	uint32_t            wake_pkt_data_len; 
	uint16_t            wake_pkt_control_flags; 

	struct npi_if_info  wake_pkt_if_info;  

	char                wake_pkt_phy_ifname[IFNAMSIZ]; 
	struct npi_if_info  wake_pkt_phy_if_info; 
};
struct net_port_info_una_wake_event {
	uuid_t              una_wake_uuid;
	struct timeval32    una_wake_pkt_timestamp; 
	uint16_t            una_wake_pkt_if_index; 
	uint16_t            una_wake_pkt_flags; 
	uint16_t            _una_wake_pkt_reserved; 
	uint16_t            una_wake_ptk_len; 
	uint8_t             una_wake_pkt[NPI_MAX_UNA_WAKE_PKT_LEN]; 
	in_port_t           una_wake_pkt_local_port; 
	in_port_t           una_wake_pkt_foreign_port; 
	union in_addr_4_6   una_wake_pkt_local_addr_;
	union in_addr_4_6   una_wake_pkt_foreign_addr_;
	char                una_wake_pkt_ifname[IFNAMSIZ]; 

	uint32_t            una_wake_pkt_total_len; 
	uint32_t            una_wake_pkt_data_len; 
	uint16_t            una_wake_pkt_control_flags; 
	uint16_t            una_wake_pkt_proto; 

	struct npi_if_info  una_wake_pkt_if_info; 

	char                una_wake_pkt_phy_ifname[IFNAMSIZ]; 
	struct npi_if_info  una_wake_pkt_phy_if_info; 
};
struct if_ports_used_stats {
	IF_PORTS_USED_STATS_LIST
};
struct npioctl {
	int         protocol;   
	enum NPmode mode;
};
struct ppp_option_data {
	u_char  *ptr;
	u_int   length;
	int     transmit;
};
struct ifpppstatsreq {
	char ifr_name[IFNAMSIZ];
	struct ppp_stats stats;
};
struct ifpppcstatsreq {
	char ifr_name[IFNAMSIZ];
	struct ppp_comp_stats stats;
};
struct if_redirect_create_params {
	uint16_t ircp_type;
	uint16_t ircp_len;
	uint32_t ircp_ftype;
};
struct if_redirect_request {
	uint64_t ifrr_reserved[4];
	union {
		char ifrru_buf[128];                
		char ifrru_delegate_name[IFNAMSIZ]; 
	} ifrr_u;
};
struct utun_stats_param {
	u_int64_t       utsp_packets;
	u_int64_t       utsp_bytes;
	u_int64_t       utsp_errors;
};
struct if_cellular_status_v1 {
	u_int32_t valid_bitmask;     

	u_int32_t link_quality_metric;
	u_int32_t ul_effective_bandwidth; 
	u_int32_t ul_max_bandwidth; 
	u_int32_t ul_min_latency; 
	u_int32_t ul_effective_latency; 
	u_int32_t ul_max_latency; 
	u_int32_t ul_retxt_level; 
	u_int32_t ul_bytes_lost; 
	u_int32_t ul_min_queue_size; 
	u_int32_t ul_avg_queue_size; 
	u_int32_t ul_max_queue_size; 
	u_int32_t dl_effective_bandwidth; 
	u_int32_t dl_max_bandwidth; 
	u_int32_t config_inactivity_time; 
	u_int32_t config_backoff_time; 
	u_int16_t mss_recommended;
	u_int16_t reserved_1;
	u_int32_t reserved_2;
	u_int64_t reserved_3;
	u_int64_t reserved_4;
	u_int64_t reserved_5;
	u_int64_t reserved_6;
} __attribute__((packed));
struct if_cellular_status {
	union {
		struct if_cellular_status_v1 if_status_v1;
	} if_cell_u;
};
struct if_wifi_status_v1 {
	u_int32_t valid_bitmask;
	u_int32_t link_quality_metric; 
	u_int32_t ul_effective_bandwidth; 
	u_int32_t ul_max_bandwidth; 
	u_int32_t ul_min_latency; 
	u_int32_t ul_effective_latency; 
	u_int32_t ul_max_latency; 
	u_int32_t ul_retxt_level; 
	u_int32_t ul_bytes_lost; 
	u_int32_t ul_error_rate; 
	u_int32_t dl_effective_bandwidth; 
	u_int32_t dl_max_bandwidth; 
	u_int32_t dl_min_latency; 
	u_int32_t dl_effective_latency; 
	u_int32_t dl_max_latency; 
	u_int32_t dl_error_rate; 
	u_int32_t config_frequency; 
	u_int32_t config_multicast_rate; 
	u_int32_t scan_count; 
	u_int32_t scan_duration; 
	u_int64_t reserved_1;
	u_int64_t reserved_2;
	u_int64_t reserved_3;
	u_int64_t reserved_4;
} __attribute__((packed));
struct if_wifi_status {
	union {
		struct if_wifi_status_v1 if_status_v1;
	} if_wifi_u;
};
struct if_link_status {
	u_int32_t       ifsr_version;   
	u_int32_t       ifsr_len;       
	union {
		struct if_cellular_status ifsr_cell;
		struct if_wifi_status ifsr_wifi;
	} ifsr_u;
};
struct ifnet_interface_advisory_header {
	enum ifnet_interface_advisory_version         version;
	enum ifnet_interface_advisory_direction       direction;
	enum ifnet_interface_advisory_interface_type  interface_type;
	ifnet_interface_advisory_notification_type_t  notification_type;
};
struct ifnet_interface_advisory_capacity {
	enum ifnet_interface_advisory_rate_trend  rate_trend_suggestion;
	uint64_t    timestamp;
	uint64_t    max_bandwidth;
	uint64_t    total_byte_count;
	uint64_t    average_throughput;
	uint32_t    flushable_queue_size;
	uint32_t    non_flushable_queue_size;
	uint32_t    average_delay;
};
struct ifnet_interface_advisory_wifi_context {
	enum ifnet_interface_advisory_wifi_freq_band  frequency_band;
	uint8_t     intermittent_state;
	uint16_t    estimated_intermittent_period;
	uint16_t    single_outage_period;
	uint8_t     bt_coex;
	uint8_t     quality_score_delay;
	uint8_t     quality_score_loss;
	uint8_t     quality_score_channel;
	uint8_t     radio_coex;
	uint16_t    wlan_duty_cycle;
	uint32_t    wifi_observed_tx_bitrate[IF_INTERFACE_ADVISORY_WIFI_TX_QUEUE_COUNT];
};
struct ifnet_interface_advisory_cell_context {
	uint8_t     radio_access_technology;
	int16_t     reference_signal_level;
	int16_t     signal_level;
	int8_t      signal_quality;
	uint8_t     uplink_bler;
	uint8_t     downlink_bler;
	uint8_t     bandwidth_limitation_indication;
	uint8_t     cdrx_state;
	uint16_t    cdrx_cycle;
	uint16_t    estimated_outage_period;
	uint8_t     outage_state;
	uint8_t     __pad;
};
struct ifnet_interface_advisory {
	union {
		struct { 
			
			uint8_t     version;
			
			uint8_t     direction;
			
			uint16_t    _reserved;
			
			int32_t     rate_trend_suggestion;
			
			uint64_t    timestamp;
			
			uint64_t    max_bandwidth;
			
			uint64_t    total_byte_count;
			
			uint64_t    average_throughput;
			
			uint32_t    flushable_queue_size;
			
			uint32_t    non_flushable_queue_size;
			
			uint32_t    average_delay;
			
			uint8_t    frequency_band;
			
			uint8_t     intermittent_state;
			
			uint16_t    estimated_intermittent_period;
			
			uint16_t    single_outage_period;

			
			uint8_t     bt_coex;
			
			uint8_t     quality_score_delay;
			
			uint8_t     quality_score_loss;
			
			uint8_t     quality_score_channel;
		};

		struct { 
			struct ifnet_interface_advisory_header    header;
			struct ifnet_interface_advisory_capacity  capacity;
			union {
				struct ifnet_interface_advisory_wifi_context    wifi_context;
				struct ifnet_interface_advisory_cell_context    cell_context;
			};
		};
	};
} __attribute__((aligned(sizeof(uint64_t))));
struct ifnet_traffic_descriptor_common {
	uint8_t     itd_type;
	uint8_t     _reserved;
	uint16_t    itd_len; 
	uint32_t    itd_flags;
};
struct ifnet_ip_addr {
	union {
		uint8_t  addr8[16];
		uint16_t addr16[8];
		uint32_t addr32[4];
	};
};
struct ifnet_traffic_descriptor_inet {
	struct ifnet_traffic_descriptor_common inet_common;
	uint8_t     inet_mask;
	uint8_t     inet_ipver; 
	uint8_t     inet_proto; 
	uint8_t     _reserved;
	struct ifnet_ip_addr inet_laddr;
	struct ifnet_ip_addr inet_raddr;
	uint16_t    inet_lport;
	uint16_t    inet_rport;
};
struct ifnet_traffic_rule_action {
	uint8_t     ra_type;
	uint8_t     _reserved;
	uint16_t    ra_len;
};
struct ifnet_traffic_rule_action_steer {
	struct ifnet_traffic_rule_action ras_common;
	uint64_t    ras_qset_id;
};
struct ether_vlan_encap_header {
	u_int16_t evle_tag;
	u_int16_t evle_proto;
};
struct  ether_vlan_header {
	u_char  evl_dhost[ETHER_ADDR_LEN];
	u_char  evl_shost[ETHER_ADDR_LEN];
	u_int16_t evl_encap_proto;
	u_int16_t evl_tag;
	u_int16_t evl_proto;
};
struct  vlanreq {
	char    vlr_parent[IFNAMSIZ];
	u_short vlr_tag;
};
struct so_nke {
	unsigned int nke_handle;
	unsigned int nke_where;
	int nke_flags; 
	u_int32_t reserved[4];  
};
struct ifnet_demux_desc {
	u_int32_t       type;
	void            *__sized_by(datalen) data;
	u_int32_t       datalen;
};
struct ifnet_stat_increment_param {
	u_int32_t                               packets_in;
	u_int32_t                               bytes_in;
	u_int32_t                               errors_in;

	u_int32_t                               packets_out;
	u_int32_t                               bytes_out;
	u_int32_t                               errors_out;

	u_int32_t                               collisions;
	u_int32_t                               dropped;
};
struct ifnet_init_params {
	const void *__sized_by(uniqueid_len) uniqueid;  
	u_int32_t               uniqueid_len;           

	const char              *name;                  
	u_int32_t               unit;                   
	ifnet_family_t          family;                 
	u_int32_t               type;                   
	ifnet_output_func       output;                 
	ifnet_demux_func        demux;                  
	ifnet_add_proto_func    add_proto;              
	ifnet_del_proto_func    del_proto;              
	ifnet_check_multi       check_multi;            
	ifnet_framer_func       framer;                 
	void                    *softc;                 
	ifnet_ioctl_func        ioctl;                  
	ifnet_set_bpf_tap       set_bpf_tap;            
	ifnet_detached_func     detach;                 
	ifnet_event_func        event;                  
	const void *__sized_by(broadcast_len) broadcast_addr; 
	u_int32_t               broadcast_len;          
};
struct ifnet_model_params {
	ifnet_model_t           model;
	u_int32_t               reserved[3];
};
struct ifnet_log_params {
	ifnet_log_level_t       level;
	ifnet_log_flags_t       flags;
	ifnet_log_category_t    category;
	ifnet_log_subcategory_t subcategory;
};
struct ifnet_notify_address_params {
	sa_family_t             address_family;
	u_int32_t               reserved[3];
};
struct ifnet_init_eparams {
	u_int32_t               ver;                    
	u_int32_t               len;                    
	u_int32_t               flags;                  

	const void *__sized_by(uniqueid_len) uniqueid;  
	u_int32_t               uniqueid_len;           

	const char              *name;                  
	u_int32_t               unit;                   
	ifnet_family_t          family;                 
	u_int32_t               type;                   
	u_int32_t               sndq_maxlen;            
	ifnet_output_func       output;                 
	ifnet_pre_enqueue_func  pre_enqueue;            
	ifnet_start_func        start;                  
	ifnet_ctl_func          output_ctl;             
	u_int32_t               output_sched_model;     
	u_int32_t               output_target_qdelay;   
	u_int64_t               output_bw;              
	u_int64_t               output_bw_max;          
	u_int64_t               output_lt;              
	u_int64_t               output_lt_max;          
	u_int16_t               start_delay_qlen;       
	u_int16_t               start_delay_timeout;    
	u_int32_t               _reserved[3];           
	ifnet_input_poll_func   input_poll;             
	ifnet_ctl_func          input_ctl;              
	u_int32_t               rcvq_maxlen;            
	u_int32_t               __reserved;             
	u_int64_t               input_bw;               
	u_int64_t               input_bw_max;           
	u_int64_t               input_lt;               
	u_int64_t               input_lt_max;           
	u_int64_t               ___reserved[2];         
	ifnet_demux_func        demux;                  
	ifnet_add_proto_func    add_proto;              
	ifnet_del_proto_func    del_proto;              
	ifnet_check_multi       check_multi;            
	ifnet_framer_func       framer;                 
	void                    *softc;                 
	ifnet_ioctl_func        ioctl;                  
	ifnet_set_bpf_tap       set_bpf_tap;            
	ifnet_detached_func     detach;                 
	ifnet_event_func        event;                  
	const void *__sized_by(broadcast_len) broadcast_addr; 
	u_int32_t               broadcast_len;          
	ifnet_framer_extended_func framer_extended;     
	ifnet_subfamily_t       subfamily;              
	u_int16_t               tx_headroom;            
	u_int16_t               tx_trailer;             
	u_int32_t               rx_mit_ival;            
};
struct ifnet_stats_param {
	u_int64_t       packets_in;
	u_int64_t       bytes_in;
	u_int64_t       multicasts_in;
	u_int64_t       errors_in;

	u_int64_t       packets_out;
	u_int64_t       bytes_out;
	u_int64_t       multicasts_out;
	u_int64_t       errors_out;

	u_int64_t       collisions;
	u_int64_t       dropped;
	u_int64_t       no_protocol;
};
struct ifnet_attach_proto_param {
	struct ifnet_demux_desc         *__counted_by(demux_count) demux_array; 
	u_int32_t                       demux_count;    

	proto_media_input               input;          
	proto_media_preout              pre_output;     
	proto_media_event               event;          
	proto_media_ioctl               ioctl;          
	proto_media_detached            detached;       
	proto_media_resolve_multi       resolve;        
	proto_media_send_arp            send_arp;       
};
struct ifnet_attach_proto_param_v2 {
	struct ifnet_demux_desc         *__counted_by(demux_count) demux_array;   
	u_int32_t                       demux_count;    

	proto_media_input_v2            input;          
	proto_media_preout              pre_output;     
	proto_media_event               event;          
	proto_media_ioctl               ioctl;          
	proto_media_detached            detached;       
	proto_media_resolve_multi       resolve;        
	proto_media_send_arp            send_arp;       
};
struct ifnet_poll_params {
	u_int32_t       flags;
	u_int32_t       packets_limit;
	u_int32_t       packets_lowat;
	u_int32_t       packets_hiwat;
	u_int32_t       bytes_lowat;
	u_int32_t       bytes_hiwat;
	u_int64_t       interval_time;
	u_int64_t       reserved[4];
};
struct ifnet_llreach_info {
	u_int32_t iflri_refcnt;
	u_int32_t iflri_probes;
	u_int64_t iflri_snd_expire;
	u_int64_t iflri_rcv_expire;
	u_int64_t iflri_curtime;
	u_int32_t iflri_netproto;
	u_int8_t  iflri_addr[IFNET_LLREACHINFO_ADDRLEN];
	int32_t   iflri_rssi;
	int32_t   iflri_lqm;
	int32_t   iflri_npm;
};
struct ifnet_clone_params {
	const char                      *ifc_name;
	ifnet_clone_create_func         ifc_create;
	ifnet_clone_destroy_func        ifc_destroy;
};
struct ifnet_keepalive_offload_frame {
	u_int8_t data[IFNET_KEEPALIVE_OFFLOAD_FRAME_DATA_SIZE]; 
	u_int8_t type;  
	u_int8_t length; 
	u_int16_t interval; 
	u_int8_t ether_type; 
	u_int8_t keep_cnt; 
	u_int16_t keep_retry; 
	u_int8_t reply_length; 
	u_int8_t addr_length; 
	u_int8_t flags;
	u_int8_t reserved[1];
	u_int8_t reply_data[IFNET_KEEPALIVE_OFFLOAD_FRAME_DATA_SIZE]; 
	u_int8_t local_addr[IFNET_KEEPALIVE_OFFLOAD_MAX_ADDR_SIZE]; 
	u_int8_t remote_addr[IFNET_KEEPALIVE_OFFLOAD_MAX_ADDR_SIZE]; 
	u_int16_t local_port; 
	u_int16_t remote_port; 
	u_int32_t local_seq; 
	u_int32_t remote_seq; 
};
struct {
	int32_t buf_interface; 
	int32_t buf_sndbuf; 
} ifnet_buffer_status_t;
struct iff_filter {
	void                    *iff_cookie;
	const char              *iff_name;
	protocol_family_t       iff_protocol;
	iff_input_func          iff_input;
	iff_output_func         iff_output;
	iff_event_func          iff_event;
	iff_ioctl_func          iff_ioctl;
	iff_detached_func       iff_detached;
};
struct {
	u_char      system_id[6];
} lacp_system, *lacp_system_ref;
struct lacp_actor_partner_tlv_s {
	u_char      lap_tlv_type;       
	u_char      lap_length;         
	u_char      lap_system_priority[2];
	u_char      lap_system[6];
	u_char      lap_key[2];
	u_char      lap_port_priority[2];
	u_char      lap_port[2];
	u_char      lap_state;
	u_char      lap_reserved[3];
} lacp_actor_partner_tlv, *lacp_actor_partner_tlv_ref;
struct lacp_collector_tlv_s {
	u_char      lac_tlv_type;       
	u_char      lac_length;         
	u_char      lac_max_delay[2];
	u_char      lac_reserved[12];
} lacp_collector_tlv, *lacp_collector_tlv_ref;
struct lacpdu_s {
	u_char              la_subtype;
	u_char              la_version;
	u_char              la_actor_tlv[LACPDU_ACTOR_TLV_LENGTH];
	u_char              la_partner_tlv[LACPDU_PARTNER_TLV_LENGTH];
	u_char              la_collector_tlv[LACPDU_COLLECTOR_TLV_LENGTH];
	u_char              la_terminator_type;
	u_char              la_terminator_length;
	u_char              la_reserved[50];
} lacpdu, *lacpdu_ref;
struct la_marker_pdu_s {
	u_char              lm_subtype;         
	u_char              lm_version;         
	u_char              lm_marker_tlv_type; 
	u_char              lm_marker_tlv_length;
	u_char              lm_requestor_port[2];
	u_char              lm_requestor_system[6];
	u_char              lm_requestor_transaction_id[4];
	u_char              lm_pad[2];
	u_char              lm_terminator_type; 
	u_char              lm_terminator_length;
	u_char              lm_reserved[90];
} la_marker_pdu, *la_marker_pdu_ref,
la_marker_response_pdu, * la_marker_response_pdu_ref;
struct {
	mbuf_t          head;
	mbuf_t          tail;
	uint32_t        bytes;
	uint32_t        count;
} mblist, * mblist_t;
struct multicast_entry {
	SLIST_ENTRY(multicast_entry)    mc_entries;
	ifmultiaddr_t                   mc_ifma;
};
struct nat464_addr {
	union {
		struct in_addr          _v4addr;
		struct in6_addr         _v6addr;
		uint8_t         _addr8[16];
		uint16_t                _addr16[8];
		uint32_t                _addr32[4];
	} nat464a;                  
};
struct sockaddr_ndrv {
	unsigned char snd_len;
	unsigned char snd_family;
	unsigned char snd_name[IFNAMSIZ]; 
};
struct ndrv_demux_desc {
	u_int16_t   type;
	u_int16_t   length;
	union{
		u_int16_t       ether_type;
		u_int8_t        sap[3];
		u_int8_t        snap[5];
		u_int8_t        other[28];
	} data;
};
struct ndrv_protocol_desc_kernel {
	u_int32_t                           version;
	u_int32_t                           protocol_family;
	u_int32_t                           demux_count;
	struct ndrv_demux_desc              *__counted_by(demux_count) demux_list;
};
struct ndrv_protocol_desc64 {
	u_int32_t                           version;
	u_int32_t                           protocol_family;
	u_int32_t                           demux_count;
	user64_addr_t                       demux_list __attribute__((aligned(8)));
};
struct ndrv_protocol_desc32 {
	u_int32_t                           version;
	u_int32_t                           protocol_family;
	u_int32_t                           demux_count;
	user32_addr_t                       demux_list;
};
struct ndrv_multiaddr {
	struct ndrv_multiaddr      *next;
	ifmultiaddr_t               ifma;
	struct sockaddr            *addr;
};
struct ndrv_cb {
	TAILQ_ENTRY(ndrv_cb)    nd_next;
	struct socket *nd_socket;       
	u_int32_t nd_signature; 
	struct sockaddr_ndrv *nd_faddr;
	struct sockaddr_ndrv *nd_laddr;
	struct sockproto nd_proto;      
	int nd_descrcnt;                
	TAILQ_HEAD(dlist, dlil_demux_desc) nd_dlist; 
	u_int32_t nd_dlist_cnt; 
	struct ifnet *nd_if; 
	u_int32_t nd_proto_family;
	u_int32_t nd_family;
	struct ndrv_multiaddr* nd_multiaddrs;
	short nd_unit;
};
struct necp_packet_header {
	u_int8_t            packet_type;
	u_int8_t                flags;
	u_int32_t           message_id;
};
struct {
	uid_t               uid;
	uuid_t              effective_uuid;
	uid_t               persona_id;
} necp_application_id_t;
struct necp_domain_trie_request {
	uint32_t id;
	uint32_t total_mem_size;
	uint32_t nodes_mem_size;
	uint32_t maps_mem_size;
	uint32_t bytes_mem_size;
	uint32_t nodes_count;
	uint32_t maps_count;
	uint32_t bytes_count;
	uint32_t partial_match_terminator;
	uint32_t flags;
	uint8_t  data[__counted_by(total_mem_size)];
} necp_domain_trie_request_t;
struct necp_policy_condition_tc_range {
	u_int32_t start_tc;
	u_int32_t end_tc;
} __attribute__((__packed__));
struct necp_policy_condition_addr {
	u_int8_t                prefix;
	union {
		struct sockaddr                 sa;
		struct sockaddr_in              sin;
		struct sockaddr_in6             sin6;
	} address __attribute__((__packed__));
} __attribute__((__packed__));
struct necp_policy_condition_addr_range {
	union {
		struct sockaddr                 sa;
		struct sockaddr_in              sin;
		struct sockaddr_in6             sin6;
	} start_address __attribute__((__packed__));
	union {
		struct sockaddr                 sa;
		struct sockaddr_in              sin;
		struct sockaddr_in6             sin6;
	} end_address __attribute__((__packed__));
} __attribute__((__packed__));
struct necp_policy_condition_agent_type {
	char agent_domain[32];
	char agent_type[32];
} __attribute__((__packed__));
struct necp_policy_condition_sdk_version {
	uint32_t platform; 
	uint32_t min_version; 
	uint32_t version; 
} __attribute__((__packed__));
struct necp_aggregate_result {
	necp_kernel_policy_result                       routing_result;
	necp_kernel_policy_routing_result_parameter     routing_result_parameter;
	necp_kernel_policy_filter                       filter_control_unit;
	u_int32_t                                       flow_divert_aggregate_unit;
	necp_kernel_policy_result                       service_action;
	uuid_t                                                          service_uuid;
	u_int32_t                                                       service_flags;
	u_int32_t                                                       service_data;
	u_int                                                           routed_interface_index;
	u_int32_t                                                       policy_id;
	u_int32_t                                                       skip_policy_id;
	uuid_t                                                          netagents[NECP_MAX_NETAGENTS];
	u_int32_t                                                       netagent_use_flags[NECP_MAX_NETAGENTS];
	struct ipv6_prefix                                              nat64_prefixes[NAT64_MAX_NUM_PREFIXES];
	u_int8_t                                                        mss_recommended;
};
struct necp_stat_counts {
	u_int64_t       necp_stat_rxpackets             __attribute__((aligned(8)));
	u_int64_t       necp_stat_rxbytes               __attribute__((aligned(8)));
	u_int64_t       necp_stat_txpackets             __attribute__((aligned(8)));
	u_int64_t       necp_stat_txbytes               __attribute__((aligned(8)));

	u_int32_t       necp_stat_rxduplicatebytes;
	u_int32_t       necp_stat_rxoutoforderbytes;
	u_int32_t       necp_stat_txretransmit;

	u_int32_t       necp_stat_connectattempts;
	u_int32_t       necp_stat_connectsuccesses;

	u_int32_t       necp_stat_min_rtt;
	u_int32_t       necp_stat_avg_rtt;
	u_int32_t       necp_stat_var_rtt;

	u_int32_t       necp_stat_route_flags;
};
struct necp_basic_metadata {
	u_int32_t       rcvbufsize;
	u_int32_t       rcvbufused;
};
struct necp_connection_probe_status {
	unsigned int    probe_activated : 1;
	unsigned int    write_probe_failed : 1;
	unsigned int    read_probe_failed : 1;
	unsigned int    conn_probe_failed : 1;
};
struct necp_extra_tcp_metadata {
	struct necp_connection_probe_status probestatus;

	u_int32_t       sndbufsize;
	u_int32_t       sndbufused;
	u_int32_t       txunacked;
	u_int32_t       txwindow;
	u_int32_t       txcwindow;
	u_int32_t       flags;                  
	u_int32_t       flags1;                 
	u_int32_t       traffic_mgt_flags;
	u_int32_t       cc_alg_index;
	u_int32_t       state;
};
struct necp_stats_hdr {
	u_int32_t                                       necp_stats_type __attribute__((aligned(8)));
	u_int32_t                                       necp_stats_ver;
	u_int64_t                                       __necp_stats_reserved; 
};
struct necp_tcp_stats {
	struct necp_stats_hdr                   necp_tcp_hdr;
	struct necp_stat_counts                 necp_tcp_counts;
	struct necp_basic_metadata              necp_tcp_basic;
	struct necp_extra_tcp_metadata  necp_tcp_extra;
};
struct necp_udp_stats {
	struct necp_stats_hdr           necp_udp_hdr;
	struct necp_stat_counts         necp_udp_counts;
	struct necp_basic_metadata      necp_udp_basic;
};
struct necp_extra_quic_metadata {
	u_int32_t       sndbufsize;
	u_int32_t       sndbufused;
	u_int32_t       txunacked;
	u_int32_t       txwindow;
	u_int32_t       txcwindow;
	u_int32_t       traffic_mgt_flags;
	u_int32_t       cc_alg_index;
	u_int32_t       state;
	u_int8_t        ssr_token[QUIC_STATELESS_RESET_TOKEN_SIZE];
	struct necp_connection_probe_status probestatus;
};
struct necp_quic_stats {
	struct necp_udp_stats           necp_quic_udp_stats;
	struct necp_extra_quic_metadata necp_quic_extra;
};
struct necp_all_stats {
	union {
		struct necp_tcp_stats   tcp_stats;
		struct necp_udp_stats   udp_stats;
		struct necp_quic_stats  quic_stats;
	} all_stats_u;
} necp_all_stats;
struct necp_stats_bufreq {
	u_int32_t                                       necp_stats_bufreq_id __attribute__((aligned(8)));
	u_int32_t                                       necp_stats_bufreq_type;         
	u_int32_t                                       necp_stats_bufreq_ver;          
	u_int32_t                                       necp_stats_bufreq_size;
	union {
		void                                    *necp_stats_bufreq_addr;
		mach_vm_address_t               necp_stats_bufreq_uaddr;
	};
};
struct necp_tcp_ecn_cache {
	u_int8_t                necp_tcp_ecn_heuristics_success:1;
	u_int8_t                necp_tcp_ecn_heuristics_loss:1;
	u_int8_t                necp_tcp_ecn_heuristics_drop_rst:1;
	u_int8_t                necp_tcp_ecn_heuristics_drop_rxmt:1;
	u_int8_t                necp_tcp_ecn_heuristics_aggressive:1;
	u_int8_t                necp_tcp_ecn_heuristics_syn_rst:1;
} necp_tcp_ecn_cache;
struct necp_tcp_tfo_cache {
	u_int8_t                necp_tcp_tfo_cookie[NECP_TFO_COOKIE_LEN_MAX];
	u_int8_t                necp_tcp_tfo_cookie_len;
	u_int8_t                necp_tcp_tfo_heuristics_success:1; 
	u_int8_t                necp_tcp_tfo_heuristics_loss:1; 
	u_int8_t                necp_tcp_tfo_heuristics_middlebox:1; 
	u_int8_t                necp_tcp_tfo_heuristics_success_req:1; 
	u_int8_t                necp_tcp_tfo_heuristics_loss_req:1; 
	u_int8_t                necp_tcp_tfo_heuristics_rst_data:1; 
	u_int8_t                necp_tcp_tfo_heuristics_rst_req:1; 
} necp_tcp_tfo_cache;
struct necp_cache_buffer {
	u_int8_t                necp_cache_buf_type;    
	u_int8_t                necp_cache_buf_ver;     
	u_int32_t               necp_cache_buf_size;
	mach_vm_address_t       necp_cache_buf_addr;
} necp_cache_buffer;
struct necp_interface_signature {
	u_int8_t signature[IFNET_SIGNATURELEN];
	u_int8_t signature_len;
};
struct necp_interface_details {
	char name[IFXNAMSIZ];
	u_int32_t index;
	u_int32_t generation;
	u_int32_t functional_type;
	u_int32_t delegate_index;
	u_int32_t flags; 
	u_int32_t mtu;
	struct necp_interface_signature ipv4_signature;
	struct necp_interface_signature ipv6_signature;
	u_int32_t ipv4_netmask;
	u_int32_t ipv4_broadcast;
	u_int32_t tso_max_segment_size_v4;
	u_int32_t tso_max_segment_size_v6;
	u_int32_t hwcsum_flags;
	u_int8_t  radio_type;
	u_int8_t  radio_channel;
};
struct necp_client_parameter_netagent_type {
	char netagent_domain[32];
	char netagent_type[32];
};
struct necp_client_result_netagent {
	u_int32_t generation;
	uuid_t netagent_uuid;
};
struct necp_client_result_interface {
	u_int32_t generation;
	u_int32_t index;
};
struct necp_client_result_estimated_throughput {
	u_int8_t up;
	u_int8_t down;
};
struct necp_client_result_agent_error {
	u_int32_t code;
	u_int8_t domain;
};
struct necp_client_interface_option {
	u_int32_t interface_index;
	u_int32_t interface_generation;
	uuid_t nexus_agent;
};
struct necp_client_endpoint {
	union {
		struct sockaddr sa;
		struct sockaddr_in sin;
		struct sockaddr_in6 sin6;
		struct {
			u_int8_t endpoint_length;
			u_int8_t endpoint_family; 
			u_int16_t endpoint_port;
			u_int32_t endpoint_type; 
			char endpoint_data[0]; 
		} endpoint;
	} u;
};
struct necp_client_group {
	u_int32_t group_type;
	uuid_t group_id;
};
struct necp_client_list {
	u_int32_t client_count;
	uuid_t clients[0];
};
struct kev_necp_policies_changed_data {
	u_int32_t               changed_count;  
};
struct necp_client_flow_stats {
	u_int32_t stats_type; 
	u_int32_t stats_version; 
	u_int32_t stats_size;
	mach_vm_address_t stats_addr;
};
struct necp_client_add_flow {
	uuid_t agent_uuid;
	uuid_t registration_id;
	u_int16_t flags; 
	u_int16_t stats_request_count;
	struct necp_client_flow_stats stats_requests[0];
} __attribute__((__packed__));
struct necp_agent_use_parameters {
	uuid_t agent_uuid;
	uint64_t out_use_count;
};
struct necp_client_group_action {
	uuid_t agent_uuid;
	u_int16_t group_member_count;
	struct necp_client_endpoint group_members[0];
} __attribute__((__packed__));
struct necp_client_flow_protoctl_event {
	uint32_t        protoctl_event_code;
	uint32_t        protoctl_event_val;
	uint32_t        protoctl_event_tcp_seq_num;
};
struct necp_client_observer_update {
	u_int32_t update_type;  
	u_int8_t tlv_buffer[0]; 
};
struct necp_client_signature {
	u_int8_t signed_tag[32];
} __attribute__((__packed__));
struct necp_client_signable {
	uuid_t client_id; 
	u_int32_t sign_type;
	u_int8_t signable_data[0];
} __attribute__((__packed__));
struct necp_client_resolver_answer {
	uuid_t client_id;
	u_int32_t sign_type;
	union sockaddr_in_4_6 address_answer; 
	u_int32_t hostname_length;
	char hostname[0];
} __attribute__((__packed__));
struct necp_client_host_resolver_answer {
	struct necp_client_signable header;
	u_int32_t metadata_hash; 
	union sockaddr_in_4_6 address_answer; 
	u_int32_t hostname_length;
	char hostname[0];
} __attribute__((__packed__));
struct necp_client_browse_result {
	struct necp_client_signable header;
	u_int32_t metadata_hash; 
	u_int16_t service_length;
	char service[0];
} __attribute__((__packed__));
struct necp_client_service_resolver_answer {
	struct necp_client_signable header;
	u_int32_t metadata_hash; 
	u_int16_t service_length;
	u_int16_t port;
	u_int16_t hostname_length;
	char service[0];
	char hostname[0];
} __attribute__((__packed__));
struct necp_client_validatable {
	struct necp_client_signature signature;
	struct necp_client_signable signable;
} __attribute__((__packed__));
struct necp_client_signed_client_id_uuid {
	uuid_t client_id;
	u_int32_t signature_length;
	u_int8_t signature_data[NECP_CLIENT_ACTION_SIGN_TAG_LENGTH];
} __attribute__((__packed__));
struct necp_drop_dest_entry {
	u_int32_t                           level;          
	u_int32_t                           order;          
	struct necp_policy_condition_addr   cond_addr;
};
struct necp_drop_dest_policy {
	u_int32_t entry_count;
	struct necp_drop_dest_entry entries[MAX_NECP_DROP_DEST_LEVEL_ADDRS];
};
struct necp_demux_pattern {
	uint16_t offset;
	uint16_t len;
	uint8_t mask[NECP_DEMUX_MAX_LEN];
	uint8_t value[NECP_DEMUX_MAX_LEN];
};
struct necp_all_kstats {
	struct necp_all_stats           necp_stats_comm;        
	struct necp_all_stats           *necp_stats_ustats;     
};
struct necp_tlv_header {
	u_int8_t type;
	u_int32_t length;
} __attribute__((__packed__));
struct {
	u_int32_t identifier;
	u_int32_t data;
} necp_kernel_policy_service;
struct necp_kernel_socket_policy {
	LIST_ENTRY(necp_kernel_socket_policy)   chain;
	necp_kernel_policy_id           id;
	necp_policy_order                       order;
	u_int32_t                                       session_order;
	int                                                     session_pid;

	u_int64_t                                       condition_mask;
	u_int64_t                                       condition_negated_mask;
	u_int32_t                                       cond_client_flags;
	necp_kernel_policy_id           cond_policy_id;
	u_int32_t                                       cond_app_id;                                    
	u_int32_t                                       cond_real_app_id;                               
	char                                            *cond_custom_entitlement __null_terminated;     
	u_int32_t                                       cond_account_id;                                
	char                                            *cond_domain __null_terminated;                 
	u_int8_t                                        cond_domain_dot_count;                  
	u_int32_t                                       cond_domain_filter;
	pid_t                                           cond_pid;
	uid_t                                           cond_uid;
	uid_t                                           cond_real_uid;
	ifnet_t                                         cond_bound_interface;                   
	struct necp_policy_condition_tc_range cond_traffic_class;       
	u_int16_t                                       cond_protocol;                                  
	union necp_sockaddr_union       cond_local_start;                               
	union necp_sockaddr_union       cond_local_end;                                 
	u_int8_t                                        cond_local_prefix;                              
	union necp_sockaddr_union       cond_remote_start;                              
	union necp_sockaddr_union       cond_remote_end;                                
	u_int8_t                                        cond_remote_prefix;                             
	struct necp_policy_condition_agent_type cond_agent_type;
	struct necp_policy_condition_sdk_version cond_sdk_version;
	char                                            *cond_signing_identifier __null_terminated;   
	char                                            *cond_url __null_terminated;
	u_int16_t                                       cond_packet_filter_tags;
	u_int16_t                                       cond_scheme_port;
	int32_t                                         cond_pid_version;
	u_int32_t                                       cond_bound_interface_flags;
	u_int32_t                                       cond_bound_interface_eflags;
	u_int32_t                                       cond_bound_interface_xflags;
	u_int8_t                                        cond_local_networks_flags;

	necp_kernel_policy_result       result;
	necp_kernel_policy_result_parameter     result_parameter;
};
struct necp_kernel_ip_output_policy {
	LIST_ENTRY(necp_kernel_ip_output_policy)        chain;
	necp_kernel_policy_id           id;
	necp_policy_order                       suborder;
	necp_policy_order                       order;
	u_int32_t                                       session_order;
	int                                                     session_pid;

	u_int64_t                                       condition_mask;
	u_int64_t                                       condition_negated_mask;
	necp_kernel_policy_id           cond_policy_id;
	ifnet_t                                         cond_bound_interface;                   
	u_int16_t                                       cond_protocol;                                  
	union necp_sockaddr_union       cond_local_start;                               
	union necp_sockaddr_union       cond_local_end;                                 
	u_int8_t                                        cond_local_prefix;                              
	union necp_sockaddr_union       cond_remote_start;                              
	union necp_sockaddr_union       cond_remote_end;                                
	u_int8_t                                        cond_remote_prefix;                             
	u_int32_t                                       cond_last_interface_index;
	u_int16_t                       cond_packet_filter_tags;
	u_int16_t                       cond_scheme_port;
	u_int32_t                                       cond_bound_interface_flags;
	u_int32_t                                       cond_bound_interface_eflags;
	u_int32_t                                       cond_bound_interface_xflags;
	u_int8_t                                        cond_local_networks_flags;

	necp_kernel_policy_result       result;
	necp_kernel_policy_result_parameter     result_parameter;
};
struct necp_session_policy {
	LIST_ENTRY(necp_session_policy) chain;
	bool                            applied;                        
	bool                            pending_deletion;       
	bool                            pending_update;         
	necp_policy_id          local_id;
	necp_policy_order       order;
	u_int32_t                       result_size;
	u_int8_t                        *result __sized_by(result_size);
	u_int32_t                       conditions_size;
	u_int8_t                        *conditions __sized_by(conditions_size); 
	u_int32_t                       route_rules_size;
	u_int8_t                        *route_rules __sized_by(route_rules_size); 

	uuid_t                          applied_app_uuid;
	uuid_t                          applied_real_app_uuid;
	u_int32_t                       applied_account_size;
	char                            *applied_account __sized_by(applied_account_size);

	uuid_t                          applied_result_uuid;

	u_int32_t                       applied_route_rules_id;

	necp_kernel_policy_id   kernel_socket_policies[MAX_KERNEL_SOCKET_POLICIES];
	necp_kernel_policy_id   kernel_ip_output_policies[MAX_KERNEL_IP_OUTPUT_POLICIES];
};
struct necp_aggregate_socket_result {
	necp_kernel_policy_result                       result;
	necp_kernel_policy_result_parameter     result_parameter;
	necp_kernel_policy_filter                       filter_control_unit;
	u_int32_t                                       flow_divert_aggregate_unit;
	u_int32_t                                                       route_rule_id;
	int32_t                                         qos_marking_gencount;
};
struct necp_inpcb_result {
	u_int32_t                                       app_id;
	necp_kernel_policy_id                           policy_id;
	necp_kernel_policy_id                           skip_policy_id;
	int32_t                                         policy_gencount;
	u_int32_t                                       flowhash;
	u_int32_t                                       network_denied_notifies;
	struct necp_aggregate_socket_result             results;
};
struct necp_client_nexus_parameters {
	pid_t pid;
	pid_t epid;
	uuid_t euuid;
	union necp_sockaddr_union local_addr;
	union necp_sockaddr_union remote_addr;
	u_int8_t ip_protocol;
	u_int8_t transport_protocol;
	u_int16_t ethertype;
	u_int32_t traffic_class;
	necp_policy_id policy_id;
	necp_policy_id skip_policy_id;
	unsigned is_listener:1;
	unsigned is_interpose:1;
	unsigned is_custom_ether:1;
	unsigned allow_qos_marking:1;
	unsigned override_address_selection:1;
	unsigned use_stable_address:1; 
	unsigned no_wake_from_sleep:1;
	unsigned is_demuxable_parent:1;
	unsigned reuse_port:1;

	uuid_t parent_flow_uuid;
	struct necp_demux_pattern demux_patterns[NECP_MAX_DEMUX_PATTERNS];
	uint8_t demux_pattern_count;
};
struct necp_client_group_members {
	size_t group_members_length;
	u_int8_t *group_members __sized_by(group_members_length);
};
struct necp_client_error_parameters {
	int32_t error;
	bool force_report;
};
struct necp_client_agent_parameters {
	union {
		struct necp_client_nexus_parameters nexus_request;
		u_int8_t close_token[QUIC_STATELESS_RESET_TOKEN_SIZE];
		struct necp_client_group_members group_members;
		struct necp_client_error_parameters error;
	} u;
};
struct necp_client_add_flow_default {
	uuid_t agent_uuid;
	uuid_t registration_id;
	u_int16_t flags; 
	u_int16_t stats_request_count;
	struct necp_client_flow_stats stats_requests[1];
} __attribute__((__packed__));
struct netsrc_req {
	unsigned int nrq_ver;
	unsigned int nrq_ifscope;
	union {
		union sockaddr_in_4_6 nrq_dst;
		union sockaddr_in_4_6 _usa;
	};
};
struct netsrc_repv1 {
	union {
		union sockaddr_in_4_6 nrp_src;
		union sockaddr_in_4_6 _usa;
	};
	uint16_t nrp_flags;
	uint16_t nrp_label;
	uint16_t nrp_precedence;
	uint16_t nrp_dstlabel;
	uint16_t nrp_dstprecedence;
	uint16_t nrp_unused;    
};
struct netsrc_repv2 {
	union {
		union sockaddr_in_4_6 nrp_src;
		union sockaddr_in_4_6 _usa;
	};
	uint32_t nrp_min_rtt;
	uint32_t nrp_connection_attempts;
	uint32_t nrp_connection_successes;
	uint32_t nrp_flags;
	uint16_t nrp_label;
	uint16_t nrp_precedence;
	uint16_t nrp_dstlabel;
	uint16_t nrp_dstprecedence;
	uint16_t nrp_ifindex;
	uint16_t nrp_unused; 
};
struct netagent_message_header {
	u_int8_t                message_type;
	u_int8_t                message_flags;
	u_int32_t               message_id;
	u_int32_t               message_error;
	u_int32_t               message_payload_length;
};
struct netagent_session_message_header {
	u_int8_t                message_type;
	u_int8_t                message_flags;
	u_int32_t               message_id;
	u_int32_t               message_error;
	uuid_t                  message_agent_id;
	u_int32_t               message_payload_length;
};
struct netagent_trigger_message {
	u_int32_t               trigger_flags;
	pid_t                   trigger_pid;
	uuid_t                  trigger_proc_uuid;
};
struct netagent_client_message {
	uuid_t                  client_id;
};
struct netagent_client_error_message {
	uuid_t                  client_id;
	int32_t                 error_code;
};
struct netagent_client_group_message {
	uuid_t                  client_id;
	u_int8_t                group_members[0];
};
struct netagent_assign_nexus_message {
	uuid_t                  assign_client_id;
	u_int8_t                assign_necp_results[0];
};
struct netagent_session_assign_nexus_message {
	uuid_t                  agent_id;
	uuid_t                  assign_client_id;
	u_int8_t                assign_necp_results[0];
};
struct netagent_nexus {
	u_int32_t       frame_type;
	u_int32_t       endpoint_assignment_type;
	u_int32_t       endpoint_request_types[NETAGENT_NEXUS_MAX_REQUEST_TYPES];
	u_int32_t       endpoint_resolution_type_pairs[NETAGENT_NEXUS_MAX_RESOLUTION_TYPE_PAIRS * 2];
	u_int32_t       nexus_max_buf_size;
	u_int32_t       reserved;
	u_int32_t       nexus_flags;
};
struct kev_netagent_data {
	uuid_t          netagent_uuid;
};
struct netagent {
	uuid_t          netagent_uuid;
	char            netagent_domain[NETAGENT_DOMAINSIZE];
	char            netagent_type[NETAGENT_TYPESIZE];
	char            netagent_desc[NETAGENT_DESCSIZE];
	u_int32_t       netagent_flags;
	u_int32_t       netagent_data_size;
	u_int8_t        netagent_data[0];
};
struct netagent_req {
	uuid_t          netagent_uuid;
	char            netagent_domain[NETAGENT_DOMAINSIZE];
	char            netagent_type[NETAGENT_TYPESIZE];
	char            netagent_desc[NETAGENT_DESCSIZE];
	u_int32_t       netagent_flags;
	u_int32_t       netagent_data_size;
	u_int8_t        *netagent_data;
};
struct netagentlist_req {
	u_int32_t       data_size;
	u_int8_t        *data;
};
struct netagent_req32 {
	uuid_t          netagent_uuid;
	char            netagent_domain[NETAGENT_DOMAINSIZE];
	char            netagent_type[NETAGENT_TYPESIZE];
	char            netagent_desc[NETAGENT_DESCSIZE];
	u_int32_t       netagent_flags;
	u_int32_t       netagent_data_size;
	user32_addr_t   netagent_data;
};
struct netagent_req64 {
	uuid_t          netagent_uuid;
	char            netagent_domain[NETAGENT_DOMAINSIZE];
	char            netagent_type[NETAGENT_TYPESIZE];
	char            netagent_desc[NETAGENT_DESCSIZE];
	u_int32_t       netagent_flags;
	u_int32_t       netagent_data_size;
	user64_addr_t   netagent_data __attribute__((aligned(8)));
};
struct netagentlist_req32 {
	u_int32_t       data_size;
	user32_addr_t   data;
};
struct netagentlist_req64 {
	u_int32_t       data_size;
	user64_addr_t   data __attribute__((aligned(8)));
};
struct netagent_nexus_agent {
	struct netagent                         agent;
	struct netagent_nexus           nexus_data;
};
struct net_api_stats {
	int64_t nas_iflt_attach_count;  
	int64_t nas_iflt_attach_os_count;
	int64_t nas_iflt_attach_total;  
	int64_t nas_iflt_attach_os_total;

	int64_t nas_ipf_add_count;      
	int64_t nas_ipf_add_os_count;
	int64_t nas_ipf_add_total;      
	int64_t nas_ipf_add_os_total;

	int64_t nas_sfltr_register_count;       
	int64_t nas_sfltr_register_os_count;
	int64_t nas_sfltr_register_total;       
	int64_t nas_sfltr_register_os_total;

	int64_t nas_socket_alloc_total;
	int64_t nas_socket_in_kernel_total;
	int64_t nas_socket_in_kernel_os_total;
	int64_t nas_socket_necp_clientuuid_total;

	int64_t nas_socket_domain_local_total;
	int64_t nas_socket_domain_route_total;
	int64_t nas_socket_domain_inet_total;
	int64_t nas_socket_domain_inet6_total;
	int64_t nas_socket_domain_system_total;
	int64_t nas_socket_domain_multipath_total;
	int64_t nas_socket_domain_key_total;
	int64_t nas_socket_domain_ndrv_total;
	int64_t nas_socket_domain_other_total;

	int64_t nas_socket_inet_stream_total;
	int64_t nas_socket_inet_dgram_total;
	int64_t nas_socket_inet_dgram_connected;
	int64_t nas_socket_inet_dgram_dns;      
	int64_t nas_socket_inet_dgram_no_data;  

	int64_t nas_socket_inet6_stream_total;
	int64_t nas_socket_inet6_dgram_total;
	int64_t nas_socket_inet6_dgram_connected;
	int64_t nas_socket_inet6_dgram_dns;     
	int64_t nas_socket_inet6_dgram_no_data; 

	int64_t nas_socket_mcast_join_total;
	int64_t nas_socket_mcast_join_os_total;

	int64_t nas_sock_inet6_stream_exthdr_in;
	int64_t nas_sock_inet6_stream_exthdr_out;
	int64_t nas_sock_inet6_dgram_exthdr_in;
	int64_t nas_sock_inet6_dgram_exthdr_out;

	int64_t nas_nx_flow_inet_stream_total;
	int64_t nas_nx_flow_inet_dgram_total;

	int64_t nas_nx_flow_inet6_stream_total;
	int64_t nas_nx_flow_inet6_dgram_total;

	int64_t nas_ifnet_alloc_count;
	int64_t nas_ifnet_alloc_total;
	int64_t nas_ifnet_alloc_os_count;
	int64_t nas_ifnet_alloc_os_total;

	int64_t nas_pf_addrule_total;
	int64_t nas_pf_addrule_os;

	int64_t nas_vmnet_total;
};
struct net_perf {
	uint64_t np_total_pkts; 
	uint64_t np_total_usecs;        
	uint64_t np_hist1;              
	uint64_t np_hist2;              
	uint64_t np_hist3;              
	uint64_t np_hist4;              
	uint64_t np_hist5;              
	uint8_t np_hist_bars[NET_PERF_BARS];
} net_perf_t;
struct net_str_id_entry {
	SLIST_ENTRY(net_str_id_entry) nsi_next;
	uint32_t nsi_flags;
	uint32_t nsi_id;
	uint32_t nsi_length;
	char nsi_string[__counted_by(nsi_length)];
};
struct nstat_counts {
	u_int64_t       nstat_rxpackets __attribute__((aligned(sizeof(u_int64_t))));
	u_int64_t       nstat_rxbytes   __attribute__((aligned(sizeof(u_int64_t))));
	u_int64_t       nstat_txpackets __attribute__((aligned(sizeof(u_int64_t))));
	u_int64_t       nstat_txbytes   __attribute__((aligned(sizeof(u_int64_t))));

	u_int64_t       nstat_cell_rxbytes      __attribute__((aligned(sizeof(u_int64_t))));
	u_int64_t       nstat_cell_txbytes      __attribute__((aligned(sizeof(u_int64_t))));
	u_int64_t       nstat_wifi_rxbytes      __attribute__((aligned(sizeof(u_int64_t))));
	u_int64_t       nstat_wifi_txbytes      __attribute__((aligned(sizeof(u_int64_t))));
	u_int64_t       nstat_wired_rxbytes     __attribute__((aligned(sizeof(u_int64_t))));
	u_int64_t       nstat_wired_txbytes     __attribute__((aligned(sizeof(u_int64_t))));

	u_int32_t       nstat_rxduplicatebytes;
	u_int32_t       nstat_rxoutoforderbytes;
	u_int32_t       nstat_txretransmit;

	u_int32_t       nstat_connectattempts;
	u_int32_t       nstat_connectsuccesses;

	u_int32_t       nstat_min_rtt;
	u_int32_t       nstat_avg_rtt;
	u_int32_t       nstat_var_rtt;
} nstat_counts;
struct nstat_sysinfo_keyval {
	u_int32_t       nstat_sysinfo_key;
	u_int32_t       nstat_sysinfo_flags;
	union {
		int64_t nstat_sysinfo_scalar;
		double  nstat_sysinfo_distribution;
		u_int8_t nstat_sysinfo_string[NSTAT_SYSINFO_KEYVAL_STRING_MAXSIZE];
	} u;
	u_int32_t       nstat_sysinfo_valsize;
	u_int8_t        reserved[4];
}  nstat_sysinfo_keyval;
struct nstat_sysinfo_counts {
	u_int32_t       nstat_sysinfo_len;
	u_int32_t       pad;
	nstat_sysinfo_keyval        nstat_sysinfo_keyvals[];
}  nstat_sysinfo_counts;
struct nstat_route_add_param {
	union{
		struct sockaddr_in      v4;
		struct sockaddr_in6     v6;
	} dst;
	union{
		struct sockaddr_in      v4;
		struct sockaddr_in6     v6;
	} mask;
	u_int32_t       ifindex;
} nstat_route_add_param;
struct nstat_tcp_add_param {
	union{
		struct sockaddr_in      v4;
		struct sockaddr_in6     v6;
	} local;
	union{
		struct sockaddr_in      v4;
		struct sockaddr_in6     v6;
	} remote;
} nstat_tcp_add_param;
struct nstat_interface_counts {
	u_int64_t       nstat_rxpackets;
	u_int64_t       nstat_rxbytes;
	u_int64_t       nstat_txpackets;
	u_int64_t       nstat_txbytes;
} nstat_interface_counts;
struct nstat_domain_info {
	char            domain_name[NSTAT_MAX_DOMAIN_NAME_LENGTH];
	char            domain_owner[NSTAT_MAX_DOMAIN_OWNER_LENGTH];
	char            domain_tracker_ctxt[NSTAT_MAX_DOMAIN_TRACKER_CONTEXT];
	char            domain_attributed_bundle_id[NSTAT_MAX_DOMAIN_ATTR_BUNDLE_ID];
	union{
		struct sockaddr_in      v4;
		struct sockaddr_in6     v6;
	} remote;
	bool            is_tracker;
	bool            is_non_app_initiated;
	bool            is_silent;
	uint8_t         reserved[1];
} nstat_domain_info __attribute__((aligned(sizeof(u_int64_t))));
struct nstat_tcp_descriptor {
	u_int64_t       upid __attribute__((aligned(sizeof(u_int64_t))));
	u_int64_t       eupid __attribute__((aligned(sizeof(u_int64_t))));
	u_int64_t       start_timestamp __attribute__((aligned(sizeof(u_int64_t))));
	u_int64_t       timestamp __attribute__((aligned(sizeof(u_int64_t))));

	u_int64_t       rx_transfer_size __attribute__((aligned(sizeof(u_int64_t))));
	u_int64_t       tx_transfer_size __attribute__((aligned(sizeof(u_int64_t))));

	activity_bitmap_t activity_bitmap;

	u_int32_t       ifindex;
	u_int32_t       state;

	u_int32_t       sndbufsize;
	u_int32_t       sndbufused;
	u_int32_t       rcvbufsize;
	u_int32_t       rcvbufused;
	u_int32_t       txunacked;
	u_int32_t       txwindow;
	u_int32_t       txcwindow;
	u_int32_t       traffic_class;
	u_int32_t       traffic_mgt_flags;

	u_int32_t       pid;
	u_int32_t       epid;

	union{
		struct sockaddr_in      v4;
		struct sockaddr_in6     v6;
	} local;

	union{
		struct sockaddr_in      v4;
		struct sockaddr_in6     v6;
	} remote;

	char            cc_algo[16];
	char            pname[64];

	uuid_t          uuid;
	uuid_t          euuid;
	uuid_t          vuuid;
	uuid_t          fuuid;
	uid_t           persona_id;
	uid_t           uid;
	union {
		struct tcp_conn_status connstatus;
		
		uint8_t                                 __pad_connstatus[4];
	};
	uint32_t        ifnet_properties        __attribute__((aligned(4)));
	uint8_t         fallback_mode;
	uint8_t         reserved[3];
} nstat_tcp_descriptor;
struct nstat_udp_descriptor {
	u_int64_t       upid __attribute__((aligned(sizeof(u_int64_t))));
	u_int64_t       eupid __attribute__((aligned(sizeof(u_int64_t))));
	u_int64_t       start_timestamp __attribute__((aligned(sizeof(u_int64_t))));
	u_int64_t       timestamp __attribute__((aligned(sizeof(u_int64_t))));

	activity_bitmap_t activity_bitmap;

	union{
		struct sockaddr_in      v4;
		struct sockaddr_in6     v6;
	} local;

	union{
		struct sockaddr_in      v4;
		struct sockaddr_in6     v6;
	} remote;

	u_int32_t       ifindex;

	u_int32_t       rcvbufsize;
	u_int32_t       rcvbufused;
	u_int32_t       traffic_class;

	u_int32_t       pid;
	char            pname[64];
	u_int32_t       epid;

	uuid_t          uuid;
	uuid_t          euuid;
	uuid_t          vuuid;
	uuid_t          fuuid;
	uid_t           persona_id;
	uid_t           uid;
	uint32_t        ifnet_properties;
	uint8_t         fallback_mode;
	uint8_t         reserved[3];
} nstat_udp_descriptor;
struct nstat_connection_descriptor {
	u_int64_t       start_timestamp __attribute__((aligned(sizeof(u_int64_t))));
	u_int64_t       timestamp;
	u_int64_t       upid;
	u_int64_t       eupid;

	u_int32_t       pid;
	u_int32_t       epid;
	u_int32_t       ifnet_properties;
	char            pname[64];
	uuid_t          uuid;   
	uuid_t          euuid;  
	uuid_t          cuuid;  
	uuid_t          puuid;  
	uuid_t          fuuid;  
	uid_t           persona_id;
	uid_t           uid;
	uint8_t         reserved[4];
} nstat_connection_descriptor;
struct nstat_route_descriptor {
	u_int64_t       id __attribute__((aligned(sizeof(u_int64_t))));
	u_int64_t       parent_id __attribute__((aligned(sizeof(u_int64_t))));
	u_int64_t       gateway_id __attribute__((aligned(sizeof(u_int64_t))));

	union{
		struct sockaddr_in      v4;
		struct sockaddr_in6     v6;
		struct sockaddr         sa;
	} dst;

	union{
		struct sockaddr_in      v4;
		struct sockaddr_in6     v6;
		struct sockaddr         sa;
	} mask;

	union{
		struct sockaddr_in      v4;
		struct sockaddr_in6     v6;
		struct sockaddr         sa;
	} gateway;

	u_int32_t       ifindex;
	u_int32_t       flags;

	u_int8_t        reserved[4];
} nstat_route_descriptor;
struct nstat_ifnet_add_param {
	u_int64_t       threshold __attribute__((aligned(sizeof(u_int64_t))));
	u_int32_t       ifindex;

	u_int8_t        reserved[4];
} nstat_ifnet_add_param;
struct nstat_ifnet_desc_cellular_status {
	u_int32_t valid_bitmask; 
	u_int32_t link_quality_metric;
	u_int32_t ul_effective_bandwidth; 
	u_int32_t ul_max_bandwidth; 
	u_int32_t ul_min_latency; 
	u_int32_t ul_effective_latency; 
	u_int32_t ul_max_latency; 
	u_int32_t ul_retxt_level; 

	u_int32_t ul_bytes_lost; 
	u_int32_t ul_min_queue_size; 
	u_int32_t ul_avg_queue_size; 
	u_int32_t ul_max_queue_size; 
	u_int32_t dl_effective_bandwidth; 
	u_int32_t dl_max_bandwidth; 
	u_int32_t config_inactivity_time; 
	u_int32_t config_backoff_time; 
	u_int16_t mss_recommended; 
	u_int8_t        reserved[2];
} nstat_ifnet_desc_cellular_status;
struct nstat_ifnet_desc_wifi_status {
	u_int32_t valid_bitmask;
	u_int32_t link_quality_metric; 
	u_int32_t ul_effective_bandwidth; 
	u_int32_t ul_max_bandwidth; 
	u_int32_t ul_min_latency; 
	u_int32_t ul_effective_latency; 
	u_int32_t ul_max_latency; 
	u_int32_t ul_retxt_level; 

	u_int32_t ul_bytes_lost; 
	u_int32_t ul_error_rate; 
	u_int32_t dl_effective_bandwidth; 
	u_int32_t dl_max_bandwidth; 
	u_int32_t dl_min_latency; 
	u_int32_t dl_effective_latency; 
	u_int32_t dl_max_latency; 
	u_int32_t dl_error_rate; 
	u_int32_t config_frequency; 
	u_int32_t config_multicast_rate; 
	u_int32_t scan_count; 
	u_int32_t scan_duration; 
} nstat_ifnet_desc_wifi_status;
struct nstat_ifnet_desc_link_status {
	u_int32_t       link_status_type;
	union {
		nstat_ifnet_desc_cellular_status        cellular;
		nstat_ifnet_desc_wifi_status            wifi;
	} u;
} nstat_ifnet_desc_link_status;
struct nstat_ifnet_descriptor {
	u_int64_t                       threshold __attribute__((aligned(sizeof(u_int64_t))));
	u_int32_t                       ifindex;
	nstat_ifnet_desc_link_status    link_status;
	unsigned int            type;
	char                            description[IF_DESCSIZE];
	char                            name[IFNAMSIZ + 1];
	u_int8_t                        reserved[3];
} nstat_ifnet_descriptor;
struct nstat_sysinfo_descriptor {
	u_int32_t       flags;
} nstat_sysinfo_descriptor;
struct nstat_sysinfo_add_param {
	u_int32_t       flags;
} nstat_sysinfo_add_param;
struct nstat_msg_hdr {
	u_int64_t       context __attribute__((aligned(sizeof(u_int64_t))));
	u_int32_t       type;
	u_int16_t       length;
	u_int16_t       flags;
} nstat_msg_hdr;
struct nstat_msg_error {
	nstat_msg_hdr   hdr;
	u_int32_t               error;  
	u_int8_t                reserved[4];
} nstat_msg_error;
struct nstat_msg_add_src {
	NSTAT_ADD_SRC_FIELDS;
	u_int8_t        param[];
} nstat_msg_add_src_req;
struct nstat_msg_add_src_header {
	NSTAT_ADD_SRC_FIELDS;
} nstat_msg_add_src_header;
struct nstat_msg_add_src_convenient {
	nstat_msg_add_src_header        hdr;
	union {
		nstat_route_add_param   route;
		nstat_tcp_add_param     tcp;
		nstat_udp_add_param     udp;
		nstat_ifnet_add_param   ifnet;
		nstat_sysinfo_add_param sysinfo;
	};
} nstat_msg_add_src_convenient;
struct nstat_msg_add_all_srcs {
	nstat_msg_hdr           hdr;
	u_int64_t               filter __attribute__((aligned(sizeof(u_int64_t))));
	nstat_event_flags_t     events __attribute__((aligned(sizeof(u_int64_t))));
	nstat_provider_id_t     provider;
	pid_t                   target_pid;
	uuid_t                  target_uuid;
} nstat_msg_add_all_srcs;
struct nstat_msg_src_added {
	nstat_msg_hdr           hdr;
	nstat_src_ref_t         srcref __attribute__((aligned(sizeof(u_int64_t))));
	nstat_provider_id_t     provider;
	u_int8_t                reserved[4];
} nstat_msg_src_added;
struct nstat_msg_rem_src {
	nstat_msg_hdr           hdr;
	nstat_src_ref_t         srcref __attribute__((aligned(sizeof(u_int64_t))));
} nstat_msg_rem_src_req;
struct nstat_msg_get_src_description {
	nstat_msg_hdr           hdr;
	nstat_src_ref_t         srcref __attribute__((aligned(sizeof(u_int64_t))));
} nstat_msg_get_src_description;
struct nstat_msg_set_filter {
	nstat_msg_hdr           hdr;
	nstat_src_ref_t         srcref __attribute__((aligned(sizeof(u_int64_t))));
	u_int32_t               filter;
	u_int8_t                reserved[4];
} nstat_msg_set_filter;
struct nstat_msg_src_description {
	NSTAT_SRC_DESCRIPTION_FIELDS;
	u_int8_t        data[];
} nstat_msg_src_description;
struct nstat_msg_src_description_header {
	NSTAT_SRC_DESCRIPTION_FIELDS;
} nstat_msg_src_description_header;
struct nstat_msg_src_description_convenient {
	nstat_msg_src_description_header    hdr;
	union {
		nstat_tcp_descriptor            tcp;
		nstat_udp_descriptor            udp;
		nstat_route_descriptor          route;
		nstat_ifnet_descriptor          ifnet;
		nstat_sysinfo_descriptor        sysinfo;
		nstat_quic_descriptor           quic;
	};
} nstat_msg_src_description_convenient;
struct nstat_msg_query_src {
	nstat_msg_hdr           hdr;
	nstat_src_ref_t         srcref __attribute__((aligned(sizeof(u_int64_t))));
} nstat_msg_query_src_req;
struct nstat_msg_src_counts {
	nstat_msg_hdr           hdr;
	nstat_src_ref_t         srcref __attribute__((aligned(sizeof(u_int64_t))));
	nstat_event_flags_t     event_flags __attribute__((aligned(sizeof(u_int64_t))));
	nstat_counts            counts;
} nstat_msg_src_counts;
struct nstat_msg_src_update {
	NSTAT_SRC_UPDATE_FIELDS;
	u_int8_t        data[];
} nstat_msg_src_update;
struct nstat_msg_src_update_hdr {
	NSTAT_SRC_UPDATE_FIELDS;
} nstat_msg_src_update_hdr;
struct nstat_msg_src_update_tcp {
	NSTAT_SRC_UPDATE_FIELDS;
	nstat_tcp_descriptor            tcp_desc;
} nstat_msg_src_update_tcp;
struct nstat_msg_src_update_udp {
	NSTAT_SRC_UPDATE_FIELDS;
	nstat_udp_descriptor            udp_desc;
} nstat_msg_src_update_udp;
struct nstat_msg_src_update_quic {
	NSTAT_SRC_UPDATE_FIELDS;
	nstat_quic_descriptor           quic_desc;
} nstat_msg_src_update_quic;
struct nstat_msg_src_update_conn {
	NSTAT_SRC_UPDATE_FIELDS;
	nstat_connection_descriptor     conn_desc;
} nstat_msg_src_update_conn;
struct nstat_msg_src_update_convenient {
	nstat_msg_src_update_hdr                hdr;
	union {
		nstat_tcp_descriptor            tcp;
		nstat_udp_descriptor            udp;
		nstat_route_descriptor          route;
		nstat_ifnet_descriptor          ifnet;
		nstat_sysinfo_descriptor        sysinfo;
		nstat_quic_descriptor           quic;
		nstat_connection_descriptor     conn;
	};
} nstat_msg_src_update_convenient;
struct nstat_msg_src_extended_item_hdr {
	u_int32_t       type;
	u_int32_t       length;
} nstat_msg_src_extended_item_hdr __attribute__((aligned(sizeof(u_int64_t))));
struct nstat_msg_src_extended_item {
	nstat_msg_src_extended_item_hdr         hdr;
	u_int8_t                                data[];
} nstat_msg_src_extended_item;
struct nstat_msg_src_extended_tcp_update {
	NSTAT_SRC_UPDATE_FIELDS;
	nstat_tcp_descriptor                    tcp;
	nstat_msg_src_extended_item_hdr         extension_hdr;
	u_int8_t                                data[];
} nstat_msg_src_extended_tcp_update;
struct nstat_msg_src_extended_udp_update {
	NSTAT_SRC_UPDATE_FIELDS;
	nstat_udp_descriptor                    udp;
	nstat_msg_src_extended_item_hdr         extension_hdr;
	u_int8_t                                data[];
} nstat_msg_src_extended_udp_update;
struct nstat_msg_src_extended_quic_update {
	NSTAT_SRC_UPDATE_FIELDS;
	nstat_quic_descriptor                   quic;
	nstat_msg_src_extended_item_hdr         extension_hdr;
	u_int8_t                                data[];
} nstat_msg_src_extended_quic_update;
struct nstat_msg_src_extended_conn_update {
	NSTAT_SRC_UPDATE_FIELDS;
	nstat_connection_descriptor             conn;
	nstat_msg_src_extended_item_hdr         extension_hdr;
	u_int8_t                                data[];
} nstat_msg_src_extended_conn_update;
struct nstat_msg_src_tcp_update_domain_extension {
	nstat_msg_src_update_hdr                hdr;
	nstat_tcp_descriptor                    tcp;
	nstat_msg_src_extended_item_hdr         extension_hdr;
	nstat_domain_info                       domain_info;
} nstat_msg_src_tcp_update_domain_extension;
struct nstat_msg_src_udp_update_domain_extension {
	nstat_msg_src_update_hdr                hdr;
	nstat_udp_descriptor                    udp;
	nstat_msg_src_extended_item_hdr         extension_hdr;
	nstat_domain_info                       domain_info;
} nstat_msg_src_udp_update_domain_extension;
struct nstat_msg_src_quic_update_domain_extension {
	nstat_msg_src_update_hdr                hdr;
	nstat_quic_descriptor                   quic;
	nstat_msg_src_extended_item_hdr         extension_hdr;
	nstat_domain_info                       domain_info;
} nstat_msg_src_quic_update_domain_extension;
struct nstat_msg_src_update_domain_extension_convenient {
	nstat_msg_src_tcp_update_domain_extension       tcp;
	nstat_msg_src_udp_update_domain_extension       udp;
	nstat_msg_src_quic_update_domain_extension      quic;
} nstat_msg_src_update_domain_extension_convenient;
struct nstat_msg_src_removed {
	nstat_msg_hdr           hdr;
	nstat_src_ref_t         srcref __attribute__((aligned(sizeof(u_int64_t))));
} nstat_msg_src_removed;
struct nstat_msg_sysinfo_counts {
	nstat_msg_hdr           hdr;
	nstat_src_ref_t         srcref __attribute__((aligned(sizeof(u_int64_t))));
	nstat_sysinfo_counts    counts;
}  nstat_msg_sysinfo_counts;
struct nstat_stats {
	u_int32_t nstat_successmsgfailures;
	u_int32_t nstat_sendcountfailures;
	u_int32_t nstat_sysinfofailures;
	u_int32_t nstat_srcupatefailures;
	u_int32_t nstat_descriptionfailures;
	u_int32_t nstat_msgremovedfailures;
	u_int32_t nstat_srcaddedfailures;
	u_int32_t nstat_msgerrorfailures;
	u_int32_t nstat_copy_descriptor_failures;
	u_int32_t nstat_provider_counts_failures;
	u_int32_t nstat_control_send_description_failures;
	u_int32_t nstat_control_send_goodbye_failures;
	u_int32_t nstat_flush_accumulated_msgs_failures;
	u_int32_t nstat_accumulate_msg_failures;
	u_int32_t nstat_control_cleanup_source_failures;
	u_int32_t nstat_handle_msg_failures;
};
struct nstat_progress_indicators {
	u_int32_t       np_numflows;            
	u_int32_t       np_conn_probe_fails;    
	u_int32_t       np_read_probe_fails;    
	u_int32_t       np_write_probe_fails;   
	u_int32_t       np_recentflows;         
	u_int32_t       np_recentflows_unacked; 
	u_int64_t       np_recentflows_rxbytes; 
	u_int64_t       np_recentflows_txbytes; 
	u_int64_t       np_recentflows_rxooo;   
	u_int64_t       np_recentflows_rxdup;   
	u_int64_t       np_recentflows_retx;    
	u_int64_t       np_reserved1;           
	u_int64_t       np_reserved2;           
	u_int64_t       np_reserved3;           
	u_int64_t       np_reserved4;           
};
struct nstat_progress_req {
	u_int64_t       np_ifindex;                 
	u_int64_t       np_recentflow_maxduration;  
	u_int64_t       np_filter_flags;            
	u_int64_t       np_transport_protocol_mask; 
};
struct nstat_sysinfo_tcp_stats {
	u_int32_t       ipv4_avgrtt;    
	u_int32_t       ipv6_avgrtt;    
	u_int32_t       send_plr;       
	u_int32_t       recv_plr;       
	u_int32_t       send_tlrto_rate; 
	u_int32_t       send_reorder_rate; 
	u_int32_t       connection_attempts; 
	u_int32_t       connection_accepts; 
	u_int32_t       ecn_client_enabled; 
	u_int32_t       ecn_server_enabled; 
	u_int32_t       ecn_client_setup; 
	u_int32_t       ecn_server_setup; 
	u_int32_t       ecn_client_success; 
	u_int32_t       ecn_server_success; 
	u_int32_t       ecn_not_supported; 
	u_int32_t       ecn_lost_syn;   
	u_int32_t       ecn_lost_synack; 
	u_int32_t       ecn_recv_ce;    
	u_int32_t       ecn_recv_ece;   
	u_int32_t       ecn_sent_ece;   
	u_int32_t       ecn_conn_recv_ce; 
	u_int32_t       ecn_conn_recv_ece; 
	u_int32_t       ecn_conn_plnoce; 
	u_int32_t       ecn_conn_pl_ce; 
	u_int32_t       ecn_conn_nopl_ce; 
	u_int32_t       ecn_fallback_synloss; 
	u_int32_t       ecn_fallback_reorder; 
	u_int32_t       ecn_fallback_ce; 
	u_int32_t       tfo_syn_data_rcv;       
	u_int32_t       tfo_cookie_req_rcv;
	u_int32_t       tfo_cookie_sent;        
	u_int32_t       tfo_cookie_invalid;
	u_int32_t       tfo_cookie_req; 
	u_int32_t       tfo_cookie_rcv; 
	u_int32_t       tfo_syn_data_sent;      
	u_int32_t       tfo_syn_data_acked;
	u_int32_t       tfo_syn_loss;   
	u_int32_t       tfo_blackhole;  
	u_int32_t       tfo_cookie_wrong;       
	u_int32_t       tfo_no_cookie_rcv;      
	u_int32_t       tfo_heuristics_disable; 
	u_int32_t       tfo_sndblackhole;       
	u_int32_t       mptcp_handover_attempt; 
	u_int32_t       mptcp_interactive_attempt;      
	u_int32_t       mptcp_aggregate_attempt;        
	u_int32_t       mptcp_fp_handover_attempt; 
	u_int32_t       mptcp_fp_interactive_attempt;
	u_int32_t       mptcp_fp_aggregate_attempt;
	u_int32_t       mptcp_heuristic_fallback;       
	u_int32_t       mptcp_fp_heuristic_fallback;    
	u_int32_t       mptcp_handover_success_wifi;    
	u_int32_t       mptcp_handover_success_cell;    
	u_int32_t       mptcp_interactive_success;              
	u_int32_t       mptcp_aggregate_success;                
	u_int32_t       mptcp_fp_handover_success_wifi; 
	u_int32_t       mptcp_fp_handover_success_cell;
	u_int32_t       mptcp_fp_interactive_success;
	u_int32_t       mptcp_fp_aggregate_success;
	u_int32_t       mptcp_handover_cell_from_wifi;  
	u_int32_t       mptcp_handover_wifi_from_cell;  
	u_int32_t       mptcp_interactive_cell_from_wifi;       
	u_int32_t       mptcp_back_to_wifi;     
	u_int64_t       mptcp_handover_cell_bytes;              
	u_int64_t       mptcp_interactive_cell_bytes;   
	u_int64_t       mptcp_aggregate_cell_bytes;
	u_int64_t       mptcp_handover_all_bytes;               
	u_int64_t       mptcp_interactive_all_bytes;
	u_int64_t       mptcp_aggregate_all_bytes;
	u_int32_t       mptcp_wifi_proxy;               
	u_int32_t       mptcp_cell_proxy;               
	u_int32_t       mptcp_triggered_cell;           
	u_int32_t       _padding;
} nstat_sysinfo_tcp_stats;
struct nstat_sysinfo_lim_stats {
	u_int8_t                ifnet_signature[NSTAT_SYSINFO_KEYVAL_STRING_MAXSIZE];
	u_int32_t               ifnet_siglen;
	u_int32_t               ifnet_type;
	struct if_lim_perf_stat lim_stat;
} nstat_sysinfo_lim_stats;
struct nstat_sysinfo_net_api_stats {
	u_int32_t               report_interval;
	u_int32_t               _padding;
	struct net_api_stats    net_api_stats;
} nstat_sysinfo_net_api_stats;
struct nstat_sysinfo_data {
	uint32_t                flags;
	uint32_t                unsent_data_cnt; 
	union {
		nstat_sysinfo_tcp_stats tcp_stats;
		nstat_sysinfo_lim_stats lim_stats;
		nstat_sysinfo_net_api_stats net_api_stats;
	} u;
} nstat_sysinfo_data;
struct nwk_wq_entry {
	void(*XNU_PTRAUTH_SIGNED_FUNCTION_PTR("nkw_wq_entry.func") func)(struct nwk_wq_entry *);
	TAILQ_ENTRY(nwk_wq_entry) nwk_wq_link;
};
struct sadb_msg {
	u_int8_t sadb_msg_version;
	u_int8_t sadb_msg_type;
	u_int8_t sadb_msg_errno;
	u_int8_t sadb_msg_satype;
	u_int16_t sadb_msg_len;
	u_int16_t sadb_msg_reserved;
	u_int32_t sadb_msg_seq;
	u_int32_t sadb_msg_pid;
};
struct sadb_ext {
	u_int16_t sadb_ext_len;
	u_int16_t sadb_ext_type;
};
struct sadb_sa {
	u_int16_t sadb_sa_len;
	u_int16_t sadb_sa_exttype;
	u_int32_t sadb_sa_spi;
	u_int8_t sadb_sa_replay;
	u_int8_t sadb_sa_state;
	u_int8_t sadb_sa_auth;
	u_int8_t sadb_sa_encrypt;
	u_int32_t sadb_sa_flags;
};
struct sadb_sa_2 {
	struct sadb_sa  sa;
	u_int16_t               sadb_sa_natt_port;
	union {
		u_int16_t               sadb_reserved0;
		u_int16_t               sadb_sa_natt_interval;
	};

	u_int16_t               sadb_sa_natt_offload_interval;
	u_int16_t               sadb_sa_natt_src_port;
};
struct sadb_lifetime {
	u_int16_t sadb_lifetime_len;
	u_int16_t sadb_lifetime_exttype;
	u_int32_t sadb_lifetime_allocations;
	u_int64_t sadb_lifetime_bytes;
	u_int64_t sadb_lifetime_addtime;
	u_int64_t sadb_lifetime_usetime;
};
struct sadb_address {
	u_int16_t sadb_address_len;
	u_int16_t sadb_address_exttype;
	u_int8_t sadb_address_proto;
	u_int8_t sadb_address_prefixlen;
	u_int16_t sadb_address_reserved;
};
struct sadb_key {
	u_int16_t sadb_key_len;
	u_int16_t sadb_key_exttype;
	u_int16_t sadb_key_bits;
	u_int16_t sadb_key_reserved;
};
struct sadb_ident {
	u_int16_t sadb_ident_len;
	u_int16_t sadb_ident_exttype;
	u_int16_t sadb_ident_type;
	u_int16_t sadb_ident_reserved;
	u_int64_t sadb_ident_id;
};
struct sadb_sens {
	u_int16_t sadb_sens_len;
	u_int16_t sadb_sens_exttype;
	u_int32_t sadb_sens_dpd;
	u_int8_t sadb_sens_sens_level;
	u_int8_t sadb_sens_sens_len;
	u_int8_t sadb_sens_integ_level;
	u_int8_t sadb_sens_integ_len;
	u_int32_t sadb_sens_reserved;
};
struct sadb_prop {
	u_int16_t sadb_prop_len;
	u_int16_t sadb_prop_exttype;
	u_int8_t sadb_prop_replay;
	u_int8_t sadb_prop_reserved[3];
};
struct sadb_comb {
	u_int8_t sadb_comb_auth;
	u_int8_t sadb_comb_encrypt;
	u_int16_t sadb_comb_flags;
	u_int16_t sadb_comb_auth_minbits;
	u_int16_t sadb_comb_auth_maxbits;
	u_int16_t sadb_comb_encrypt_minbits;
	u_int16_t sadb_comb_encrypt_maxbits;
	u_int32_t sadb_comb_reserved;
	u_int32_t sadb_comb_soft_allocations;
	u_int32_t sadb_comb_hard_allocations;
	u_int64_t sadb_comb_soft_bytes;
	u_int64_t sadb_comb_hard_bytes;
	u_int64_t sadb_comb_soft_addtime;
	u_int64_t sadb_comb_hard_addtime;
	u_int64_t sadb_comb_soft_usetime;
	u_int64_t sadb_comb_hard_usetime;
};
struct sadb_supported {
	u_int16_t sadb_supported_len;
	u_int16_t sadb_supported_exttype;
	u_int32_t sadb_supported_reserved;
};
struct sadb_alg {
	u_int8_t sadb_alg_id;
	u_int8_t sadb_alg_ivlen;
	u_int16_t sadb_alg_minbits;
	u_int16_t sadb_alg_maxbits;
	u_int16_t sadb_alg_reserved;
};
struct sadb_spirange {
	u_int16_t sadb_spirange_len;
	u_int16_t sadb_spirange_exttype;
	u_int32_t sadb_spirange_min;
	u_int32_t sadb_spirange_max;
	u_int32_t sadb_spirange_reserved;
};
struct sadb_x_kmprivate {
	u_int16_t sadb_x_kmprivate_len;
	u_int16_t sadb_x_kmprivate_exttype;
	u_int32_t sadb_x_kmprivate_reserved;
};
struct sadb_x_sa2 {
	u_int16_t sadb_x_sa2_len;
	u_int16_t sadb_x_sa2_exttype;
	u_int8_t sadb_x_sa2_mode;
	union {
		u_int8_t sadb_x_sa2_reserved1;
		u_int8_t sadb_x_sa2_alwaysexpire;
	};
	union {
		u_int16_t sadb_x_sa2_reserved2;
		u_int16_t sadb_x_sa2_flags;
	};
	u_int32_t sadb_x_sa2_sequence;
	u_int32_t sadb_x_sa2_reqid;
};
struct sadb_x_policy {
	u_int16_t sadb_x_policy_len;
	u_int16_t sadb_x_policy_exttype;
	u_int16_t sadb_x_policy_type;   
	u_int8_t sadb_x_policy_dir;     
	u_int8_t sadb_x_policy_reserved;
	u_int32_t sadb_x_policy_id;
	u_int32_t sadb_x_policy_reserved2;
};
struct sadb_x_ipsecif {
	u_int16_t sadb_x_ipsecif_len;
	u_int16_t sadb_x_ipsecif_exttype;
	char sadb_x_ipsecif_internal_if[IFXNAMSIZ]; 
	char sadb_x_ipsecif_outgoing_if[IFXNAMSIZ]; 
	char sadb_x_ipsecif_ipsec_if[IFXNAMSIZ];  
	u_int16_t sadb_x_ipsecif_init_disabled; 
	u_int16_t reserved;
};
struct sadb_x_ipsecrequest {
	u_int16_t sadb_x_ipsecrequest_len; 
	u_int16_t sadb_x_ipsecrequest_proto; 
	u_int8_t sadb_x_ipsecrequest_mode; 
	u_int8_t sadb_x_ipsecrequest_level; 
	u_int16_t sadb_x_ipsecrequest_reqid; 

};
struct sadb_session_id {
	u_int16_t            sadb_session_id_len;
	u_int16_t            sadb_session_id_exttype;
	u_int64_t            sadb_session_id_v[2];
} __attribute__ ((aligned(8)));
struct sastat {
	u_int32_t            spi;               
	u_int32_t            created;           
	struct sadb_lifetime lft_c;             
};
struct sadb_sastat {
	u_int16_t            sadb_sastat_len;
	u_int16_t            sadb_sastat_exttype;
	u_int32_t            sadb_sastat_dir;
	u_int32_t            sadb_sastat_reserved;
	u_int32_t            sadb_sastat_list_len;
} __attribute__ ((aligned(8)));
struct pbuf_memory {
	uint8_t *__sized_by(pm_buffer_len) pm_buffer;     
	u_int pm_buffer_len;    
	u_int pm_offset;        
	u_int pm_len;           
	uint32_t pm_csum_flags;
	uint32_t pm_csum_data;
	uint8_t pm_proto;
	uint8_t pm_flowsrc;
	uint32_t pm_flowid;
	uint32_t pm_flow_gencnt;
	uint32_t pm_flags;
	struct pf_mtag pm_pftag;
	struct pf_fragment_tag  pm_pf_fragtag;
	int (*pm_action)(struct pbuf_memory *, enum pbuf_action);
	void *pm_action_cookie;
};
struct pbuf {
	enum pbuf_type  pb_type;
	union {
		struct mbuf *pbu_mbuf;
		struct pbuf_memory pbu_memory;
	} pb_u;

	void            *__sized_by(pb_contig_len) pb_data;
	uint32_t        pb_packet_len;
	uint32_t        pb_contig_len;
	uint32_t        *pb_csum_flags;
	uint32_t        *pb_csum_data;    
	uint8_t         *pb_proto;
	uint8_t         *pb_flowsrc;
	uint32_t        *pb_flowid;
	uint32_t        *pb_flow_gencnt;
	uint32_t        *pb_flags;
	struct pf_mtag  *pb_pftag;
	struct pf_fragment_tag  *pb_pf_fragtag;
	struct ifnet    *pb_ifp;
	struct pbuf     *pb_next;
} pbuf_t;
struct pktap_filter {
	uint32_t        filter_op;
	uint32_t        filter_param;
	union {
		uint32_t        _filter_if_type;
		char            _filter_if_name[PKTAP_IFXNAMESIZE];
	} param_;
};
struct pktap_header {
	uint32_t                pth_length;                     
	uint32_t                pth_type_next;                  
	uint32_t                pth_dlt;                        
	char                    pth_ifname[PKTAP_IFXNAMESIZE];  
	uint32_t                pth_flags;                      
	uint32_t                pth_protocol_family;
	uint32_t                pth_frame_pre_length;
	uint32_t                pth_frame_post_length;
	pid_t                   pth_pid;                        
	char                    pth_comm[MAXCOMLEN + 1];          
	uint8_t                 pth_ipproto;
	uint16_t                pth_trace_tag;
	uint32_t                pth_svc;                        
	uint16_t                pth_iftype;
	uint16_t                pth_ifunit;
	pid_t                   pth_epid;               
	char                    pth_ecomm[MAXCOMLEN + 1]; 
	uint8_t                 pth_pad2;
	uint16_t                pth_pad3;
	uint32_t                pth_flowid;
	uint32_t                pth_comp_gencnt;
	struct timeval32        pth_tstamp;
	uuid_t                  pth_uuid;
	uuid_t                  pth_euuid;
};
struct pktap_v2_hdr {
	uint8_t                 pth_length;                     
	uint8_t                 pth_uuid_offset;                
	uint8_t                 pth_e_uuid_offset;              
	uint8_t                 pth_ifname_offset;              
	uint8_t                 pth_comm_offset;                
	uint8_t                 pth_e_comm_offset;              
	uint16_t                pth_dlt;                        
	uint16_t                pth_frame_pre_length;
	uint16_t                pth_frame_post_length;
	uint16_t                pth_iftype;
	uint16_t                pth_ipproto;
	uint32_t                pth_protocol_family;
	uint32_t                pth_svc;                        
	uint32_t                pth_flowid;
	pid_t                   pth_pid;                        
	pid_t                   pth_e_pid;                      
	uint32_t                pth_flags;                      
};
struct pktap_v2_hdr_space {
	struct pktap_v2_hdr pth_hdr;
	uint8_t pth_uuid[sizeof(uuid_t)];
	uint8_t pth_e_uuid[sizeof(uuid_t)];
	uint8_t pth_ifname[PKTAP_IFXNAMESIZE];
	uint8_t pth_comm[PKTAP_MAX_COMM_SIZE];
	uint8_t pth_e_comm[PKTAP_MAX_COMM_SIZE];
};
struct pktap_buffer_v2_hdr_extra {
	struct pktap_v2_hdr_space hdr_space;
	union pktap_header_extra extra;
};
struct pktap_header_buffer {
	struct pktap_header             pkth;
	union pktap_header_extra        extra;
};
struct pppstat  {
	unsigned int ppp_ibytes; 
	unsigned int ppp_ipackets; 
	unsigned int ppp_ierrors; 
	unsigned int ppp_obytes; 
	unsigned int ppp_opackets; 
	unsigned int ppp_oerrors; 
};
struct vjstat {
	unsigned int vjs_packets; 
	unsigned int vjs_compressed; 
	unsigned int vjs_searches; 
	unsigned int vjs_misses; 
	unsigned int vjs_uncompressedin; 
	unsigned int vjs_compressedin; 
	unsigned int vjs_errorin; 
	unsigned int vjs_tossed; 
};
struct ppp_stats {
	struct pppstat p;       
	struct vjstat vj;       
};
struct compstat {
	unsigned int unc_bytes; 
	unsigned int unc_packets; 
	unsigned int comp_bytes; 
	unsigned int comp_packets; 
	unsigned int inc_bytes; 
	unsigned int inc_packets; 
	unsigned int ratio;     
};
struct ppp_comp_stats {
	struct compstat c;      
	struct compstat d;      
};
struct ppp_idle {
	time_t xmit_idle;       
	time_t recv_idle;       
};
struct rawcb {
	LIST_ENTRY(rawcb) list;
	struct  socket *rcb_socket;     
	struct  sockaddr *rcb_faddr;    
	struct  sockaddr *rcb_laddr;    
	struct  sockproto rcb_proto;    
	uint32_t        reserved[4];            
};
struct rt_metrics {
	u_int32_t       rmx_locks;      
	u_int32_t       rmx_mtu;        
	u_int32_t       rmx_hopcount;   
	int32_t         rmx_expire;     
	u_int32_t       rmx_recvpipe;   
	u_int32_t       rmx_sendpipe;   
	u_int32_t       rmx_ssthresh;   
	u_int32_t       rmx_rtt;        
	u_int32_t       rmx_rttvar;     
	u_int32_t       rmx_pksent;     
	u_int32_t       rmx_filler[4];  
};
struct rtstat {
	short   rts_badredirect;        
	short   rts_dynamic;            
	short   rts_newgateway;         
	short   rts_unreach;            
	short   rts_wildcard;           
	short   rts_badrtgwroute;       
};
struct rt_msghdr {
	u_short rtm_msglen;     
	u_char  rtm_version;    
	u_char  rtm_type;       
	u_short rtm_index;      
	int     rtm_flags;      
	int     rtm_addrs;      
	pid_t   rtm_pid;        
	int     rtm_seq;        
	int     rtm_errno;      
	int     rtm_use;        
	u_int32_t rtm_inits;    
	struct rt_metrics rtm_rmx; 
};
struct rt_msghdr2 {
	u_short rtm_msglen;     
	u_char  rtm_version;    
	u_char  rtm_type;       
	u_short rtm_index;      
	int     rtm_flags;      
	int     rtm_addrs;      
	int32_t rtm_refcnt;     
	int     rtm_parentflags; 
	int     rtm_reserved;   
	int     rtm_use;        
	u_int32_t rtm_inits;    
	struct rt_metrics rtm_rmx; 
};
struct rt_msghdr_prelude {
	u_short rtm_msglen;     
};
struct rt_addrinfo {
	int     rti_addrs;
	struct  sockaddr *rti_info[RTAX_MAX];
};
struct route_old {
	void            *ro_rt;
	uint32_t        ro_flags;
	struct sockaddr ro_dst;
};
struct route {
	struct rtentry        *ro_rt;
	struct ifaddr         *ro_srcia;
	uint32_t              ro_flags;       
	struct sockaddr       ro_dst;
};
struct rtentry {
	struct  radix_node rt_nodes[2]; 
	decl_lck_mtx_data(, rt_lock);   
	uint32_t rt_refcnt;             
	uint32_t rt_flags;              
	uint32_t rt_genid;              
	struct sockaddr *rt_gateway;    
	struct ifnet *rt_ifp;           
	struct ifaddr *rt_ifa;          
	struct sockaddr *rt_genmask;    
	void *rt_llinfo;                
	void (*rt_llinfo_get_ri)        
	(struct rtentry *, struct rt_reach_info *);
	void (*rt_llinfo_get_iflri)     
	(struct rtentry *, struct ifnet_llreach_info *);
	void (*rt_llinfo_purge)(struct rtentry *); 
	void (*rt_llinfo_free)(void *); 
	void (*rt_llinfo_refresh) (struct rtentry *); 
	struct rt_metrics rt_rmx;       
	struct rtentry *rt_gwroute;     
	struct rtentry *rt_parent;      
	struct nstat_counts *rt_stats;  
	void (*rt_if_ref_fn)(struct ifnet *, int); 

	uint32_t *rt_tree_genid;        
	uint64_t rt_expire;             
	uint64_t base_calendartime;     
	uint64_t base_uptime;           
	u_int32_t rtt_hist[NRTT_HIST];  
	u_int32_t rtt_min;              
	u_int32_t rtt_expire_ts;        
	u_int8_t rtt_index;             
	struct eventhandler_lists_ctxt rt_evhdlr_ctxt;
};
struct kev_netevent_apnfallbk_data {
	pid_t           epid;           
	uuid_t          euuid;          
};
struct rt_reach_info {
	u_int32_t       ri_refcnt;      
	u_int32_t       ri_probes;      
	u_int64_t       ri_snd_expire;  
	u_int64_t       ri_rcv_expire;  
	int32_t         ri_rssi;        
	int32_t         ri_lqm;         
	int32_t         ri_npm;         
};
struct rt_addrinfo_ext {
	struct rt_addrinfo rtix_info;                    
	struct sockaddr    rtix_tiny_addr[RTAX_MAX];     
	uint8_t            rtix_next_tiny;               
};
struct rt_msghdr_common {
	u_short rtm_msglen;     
	u_char  rtm_version;    
	u_char  rtm_type;       
	u_short rtm_index;      
	int     rtm_flags;      
	int     rtm_addrs;      
	pid_t   rtm_pid;        
	int     rtm_seq;        
	int     rtm_errno;      
	int     rtm_use;        
};
struct rt_msghdr_ext {
	u_short rtm_msglen;     
	u_char  rtm_version;    
	u_char  rtm_type;       
	u_int32_t rtm_index;    
	u_int32_t rtm_flags;    
	u_int32_t rtm_reserved; 
	u_int32_t rtm_addrs;    
	pid_t   rtm_pid;        
	int     rtm_seq;        
	int     rtm_errno;      
	u_int32_t rtm_use;      
	u_int32_t rtm_inits;    
	struct rt_metrics rtm_rmx;      
	struct rt_reach_info rtm_ri;    
};
struct rtstat_64 {
	uint64_t        rts_badredirect;        
	uint64_t        rts_dynamic;            
	uint64_t        rts_newgateway;         
	uint64_t        rts_unreach;            
	uint64_t        rts_wildcard;           
	uint64_t        rts_badrtgwroute;       
};
struct ctrace {
	void    *th;                            
	void    *pc[CTRACE_STACK_SIZE];         
} ctrace_t;
struct route_event {
	struct rtentry *rt;
	struct rtentry *gwrt;
	union {
		union sockaddr_in_4_6 _rtev_ipaddr;
		char _rtev_addr_bytes[DLIL_SDLMAXLEN];
	} rt_addr;
	uint32_t route_event_code;
	eventhandler_tag evtag;
};
struct net_trie_node {
	uint16_t start;
	uint16_t length:15;
	uint16_t is_leaf:1;
	uint16_t child_map;
	uint16_t metadata;
	uint16_t metadata_length;
};
struct net_trie {
	uint64_t magic;
	uint64_t version;
	struct net_trie_node *nodes     __counted_by(nodes_count);
	uint16_t *child_maps            __counted_by(CHILD_MAP_SIZE * child_maps_count);
	uint8_t *bytes                  __counted_by(bytes_count);
	void *memory                    __sized_by(trie_memory_size);
	uint16_t nodes_count;
	uint16_t child_maps_count;
	uint16_t bytes_count;
	uint16_t nodes_free_next;
	uint16_t child_maps_free_next;
	uint16_t bytes_free_next;
	uint16_t root;
	size_t trie_memory_size;
	size_t nodes_mem_size;
	size_t child_maps_mem_size;
	size_t bytes_mem_size;
};
struct bootp {
	u_char  bp_op;          
	u_char  bp_htype;       
	u_char  bp_hlen;        
	u_char  bp_hops;        
	u_int32_t bp_xid;       
	u_short bp_secs;        
	u_short bp_unused;
	iaddr_t bp_ciaddr;      
	iaddr_t bp_yiaddr;      
	iaddr_t bp_siaddr;      
	iaddr_t bp_giaddr;      
	u_char  bp_chaddr[16];  
	u_char  bp_sname[64];   
	u_char  bp_file[128];   
	u_char  bp_vend[64];    
};
struct vend {
	u_char  v_magic[4];     
	u_int32_t v_flags;      
	u_char  v_unused[56];   
};
struct nextvend {
	u_char nv_magic[4];     
	u_char nv_version;      
	unsigned short  :0;
	union {
		u_char NV0[58];
		struct {
			u_char NV1_opcode;      
			u_char NV1_xid; 
			u_char NV1_text[NVMAXTEXT];     
			u_char NV1_null;        
		} NV1;
	} nv_U;
};
struct bootp_packet {
	struct ip bp_ip;
	struct udphdr bp_udp;
	struct bootp bp_bootp;
};
struct dhcp {
	u_char              dp_op;      
	u_char              dp_htype;   
	u_char              dp_hlen;    
	u_char              dp_hops;    
	u_int32_t           dp_xid;     
	u_int16_t           dp_secs;    
	u_int16_t           dp_flags;   
	struct in_addr      dp_ciaddr;  
	struct in_addr      dp_yiaddr;  
	struct in_addr      dp_siaddr;  
	struct in_addr      dp_giaddr;  
	u_char              dp_chaddr[16];
	u_char              dp_sname[64];
	u_char              dp_file[128];
	u_char              dp_options[0];
};
struct dhcp_packet {
	struct ip           ip;
	struct udphdr       udp;
	struct dhcp         dhcp;
};
struct {
	const void * *      array;
	uint32_t            size;
	uint32_t            count;
} ptrlist_t;
struct flow_divert_trie_node {
	uint16_t                        start;
	uint16_t                        length;
	uint16_t                        child_map;
};
struct flow_divert_pcb {
	decl_lck_mtx_data(, mtx);
	socket_t                        so;
	RB_ENTRY(flow_divert_pcb)       rb_link;
	uint32_t                        hash;
	mbuf_t                          connect_token;
	uint32_t                        flags;
	uint32_t                        send_window;
	struct flow_divert_group        *group;
	uint32_t                        control_group_unit;
	uint32_t                        aggregate_unit;
	uint32_t                        policy_control_unit;
	int32_t                         ref_count;
	uint64_t                        bytes_written_by_app;
	uint64_t                        bytes_sent;
	uint64_t                        bytes_received;
	uint8_t                         log_level;
	SLIST_ENTRY(flow_divert_pcb)    tmp_list_entry;
	mbuf_t                          connect_packet;
	uint8_t                         *app_data __counted_by(app_data_length);
	size_t                          app_data_length;
	union sockaddr_in_4_6           local_endpoint;
	struct sockaddr                 *original_remote_endpoint;
	struct ifnet                    *original_last_outifp6;
	struct ifnet                    *original_last_outifp;
	uint8_t                         original_vflag;
	bool                            plugin_locked; 
};
struct flow_divert_trie {
	struct flow_divert_trie_node    *nodes      __counted_by(nodes_count);
	uint16_t                        *child_maps __sized_by(child_maps_size);
	uint8_t                         *bytes      __counted_by(bytes_count);
	void                            *memory     __sized_by(memory_size);
	uint16_t                        nodes_count;
	uint16_t                        child_maps_count;
	uint16_t                        bytes_count;
	uint16_t                        nodes_free_next;
	uint16_t                        child_maps_free_next;
	uint16_t                        bytes_free_next;
	uint16_t                        root;
	size_t                          memory_size;
	size_t                          child_maps_size;
};
struct flow_divert_group {
	decl_lck_rw_data(, lck);
	TAILQ_ENTRY(flow_divert_group)  chain;
	struct fd_pcb_tree              pcb_tree;
	uint32_t                        ctl_unit;
	uint8_t                         atomic_bits;
	MBUFQ_HEAD(send_queue_head)     send_queue;
	uint8_t                         *token_key __counted_by(token_key_size);
	size_t                          token_key_size;
	uint32_t                        flags;
	struct flow_divert_trie         signing_id_trie;
	int32_t                         ref_count;
	pid_t                           in_process_pid;
	int32_t                         order;
};
struct flow_divert_packet_header {
	uint8_t             packet_type;
	uint32_t            conn_id;
};
struct flow_divert_flow_state {
	uint32_t conn_id;
	uint64_t bytes_written_by_app;
	uint64_t bytes_sent;
	uint64_t bytes_received;
	uint32_t send_window;
	uint32_t send_buffer_bytes;
};
struct icmp6_hdr {
	u_int8_t        icmp6_type;     
	u_int8_t        icmp6_code;     
	u_int16_t       icmp6_cksum;    
	union {
		u_int32_t       icmp6_un_data32[1]; 
		u_int16_t       icmp6_un_data16[2]; 
		u_int8_t        icmp6_un_data8[4];  
	} icmp6_dataun;
} __attribute__((__packed__));
struct mld_hdr {
	struct icmp6_hdr        mld_icmp6_hdr;
	struct in6_addr         mld_addr; 
} __attribute__((__packed__));
struct nd_router_solicit {      
	struct icmp6_hdr        nd_rs_hdr;
}__attribute__((__packed__));
struct nd_router_advert {       
	struct icmp6_hdr        nd_ra_hdr;
	u_int32_t               nd_ra_reachable;        
	u_int32_t               nd_ra_retransmit;       
} __attribute__((__packed__));
struct nd_neighbor_solicit {    
	struct icmp6_hdr        nd_ns_hdr;
	struct in6_addr         nd_ns_target;   
}__attribute__((__packed__));
struct nd_neighbor_advert {     
	struct icmp6_hdr        nd_na_hdr;
	struct in6_addr         nd_na_target;   
}__attribute__((__packed__));
struct nd_redirect {            
	struct icmp6_hdr        nd_rd_hdr;
	struct in6_addr         nd_rd_target;   
	struct in6_addr         nd_rd_dst;      
}__attribute__((__packed__));
struct nd_opt_hdr {             
	u_int8_t        nd_opt_type;
	u_int8_t        nd_opt_len;
}__attribute__((__packed__));
struct nd_opt_prefix_info {     
	u_int8_t        nd_opt_pi_type;
	u_int8_t        nd_opt_pi_len;
	u_int8_t        nd_opt_pi_prefix_len;
	u_int8_t        nd_opt_pi_flags_reserved;
	u_int32_t       nd_opt_pi_valid_time;
	u_int32_t       nd_opt_pi_preferred_time;
	u_int32_t       nd_opt_pi_reserved2;
	struct in6_addr nd_opt_pi_prefix;
}__attribute__((__packed__));
struct nd_opt_nonce {           
	u_int8_t        nd_opt_nonce_type;
	u_int8_t        nd_opt_nonce_len;
	u_int8_t        nd_opt_nonce[ND_OPT_NONCE_LEN];
} __attribute__((__packed__));
struct nd_opt_rd_hdr {          
	u_int8_t        nd_opt_rh_type;
	u_int8_t        nd_opt_rh_len;
	u_int16_t       nd_opt_rh_reserved1;
	u_int32_t       nd_opt_rh_reserved2;
} __attribute__((__packed__));
struct nd_opt_mtu {             
	u_int8_t        nd_opt_mtu_type;
	u_int8_t        nd_opt_mtu_len;
	u_int16_t       nd_opt_mtu_reserved;
	u_int32_t       nd_opt_mtu_mtu;
}__attribute__((__packed__));
struct nd_opt_route_info {      
	u_int8_t        nd_opt_rti_type;
	u_int8_t        nd_opt_rti_len;
	u_int8_t        nd_opt_rti_prefixlen;
	u_int8_t        nd_opt_rti_flags;
	u_int32_t       nd_opt_rti_lifetime;
}__attribute__((__packed__));
struct nd_opt_rdnss {   
	u_int8_t            nd_opt_rdnss_type;
	u_int8_t            nd_opt_rdnss_len;
	u_int16_t           nd_opt_rdnss_reserved;
	u_int32_t           nd_opt_rdnss_lifetime;
	struct in6_addr     nd_opt_rdnss_addr[1];
} __attribute__((__packed__));
struct nd_opt_dnssl {   
	u_int8_t            nd_opt_dnssl_type;
	u_int8_t            nd_opt_dnssl_len;
	u_int16_t           nd_opt_dnssl_reserved;
	u_int32_t           nd_opt_dnssl_lifetime;
	u_int8_t            nd_opt_dnssl_domains[8];
} __attribute__((__packed__));
struct nd_opt_pref64 {   
	u_int8_t            nd_opt_pref64_type;
	u_int8_t            nd_opt_pref64_len;
	u_int16_t           nd_opt_pref64_scaled_lifetime_plc;
	u_int32_t           nd_opt_pref64_prefix[3];
} __attribute__((__packed__));
struct nd_opt_pvd {
	u_int8_t        nd_opt_pvd_type;
	u_int8_t        nd_opt_pvd_len;
	u_int8_t        nd_opt_flags_delay[2];
	u_int16_t       nd_opt_pvd_seq;
	u_int8_t        nd_opt_pvd_id[1];
} __attribute__((__packed__));
struct icmp6_namelookup {
	struct icmp6_hdr        icmp6_nl_hdr;
	u_int8_t        icmp6_nl_nonce[8];
	int32_t         icmp6_nl_ttl;
}__attribute__((__packed__));
struct icmp6_nodeinfo {
	struct icmp6_hdr icmp6_ni_hdr;
	u_int8_t icmp6_ni_nonce[8];
}__attribute__((__packed__));
struct ni_reply_fqdn {
	u_int32_t ni_fqdn_ttl;  
	u_int8_t ni_fqdn_namelen; 
	u_int8_t ni_fqdn_name[3]; 
}__attribute__((__packed__));
struct icmp6_router_renum {     
	struct icmp6_hdr        rr_hdr;
	u_int8_t        rr_segnum;
	u_int8_t        rr_flags;
	u_int16_t       rr_maxdelay;
	u_int32_t       rr_reserved;
} __attribute__((__packed__));
struct rr_pco_match {           
	u_int8_t        rpm_code;
	u_int8_t        rpm_len;
	u_int8_t        rpm_ordinal;
	u_int8_t        rpm_matchlen;
	u_int8_t        rpm_minlen;
	u_int8_t        rpm_maxlen;
	u_int16_t       rpm_reserved;
	struct  in6_addr        rpm_prefix;
} __attribute__((__packed__));
struct rr_pco_use {             
	u_int8_t        rpu_uselen;
	u_int8_t        rpu_keeplen;
	u_int8_t        rpu_ramask;
	u_int8_t        rpu_raflags;
	u_int32_t       rpu_vltime;
	u_int32_t       rpu_pltime;
	u_int32_t       rpu_flags;
	struct  in6_addr rpu_prefix;
} __attribute__((__packed__));
struct rr_result {              
	u_int16_t       rrr_flags;
	u_int8_t        rrr_ordinal;
	u_int8_t        rrr_matchedlen;
	u_int32_t       rrr_ifid;
	struct  in6_addr rrr_prefix;
} __attribute__((__packed__));
struct icmp6_filter {
	u_int32_t icmp6_filt[8];
};
struct icmp6errstat {
	u_quad_t icp6errs_dst_unreach_noroute;
	u_quad_t icp6errs_dst_unreach_admin;
	u_quad_t icp6errs_dst_unreach_beyondscope;
	u_quad_t icp6errs_dst_unreach_addr;
	u_quad_t icp6errs_dst_unreach_noport;
	u_quad_t icp6errs_packet_too_big;
	u_quad_t icp6errs_time_exceed_transit;
	u_quad_t icp6errs_time_exceed_reassembly;
	u_quad_t icp6errs_paramprob_header;
	u_quad_t icp6errs_paramprob_nextheader;
	u_quad_t icp6errs_paramprob_option;
	u_quad_t icp6errs_redirect; 
	u_quad_t icp6errs_unknown;
};
struct icmp6stat {

	u_quad_t icp6s_error;           
	u_quad_t icp6s_canterror;       
	u_quad_t icp6s_toofreq;         
	u_quad_t icp6s_outhist[256];

	u_quad_t icp6s_badcode;         
	u_quad_t icp6s_tooshort;        
	u_quad_t icp6s_checksum;        
	u_quad_t icp6s_badlen;          
	u_quad_t icp6s_reflect;         
	u_quad_t icp6s_inhist[256];
	u_quad_t icp6s_nd_toomanyopt;   
	struct icmp6errstat icp6s_outerrhist;
	u_quad_t icp6s_pmtuchg;         
	u_quad_t icp6s_nd_badopt;       
	u_quad_t icp6s_badns;           
	u_quad_t icp6s_badna;           
	u_quad_t icp6s_badrs;           
	u_quad_t icp6s_badra;           
	u_quad_t icp6s_badredirect;     
	u_quad_t icp6s_rfc6980_drop;    
	u_quad_t icp6s_badpkttoobig;    
};
struct  icmpstat {

	u_int32_t       icps_error;     
	u_int32_t       icps_oldshort;  
	u_int32_t       icps_oldicmp;   
	u_int32_t       icps_outhist[ICMP_MAXTYPE + 1];

	u_int32_t       icps_badcode;   
	u_int32_t       icps_tooshort;  
	u_int32_t       icps_checksum;  
	u_int32_t       icps_badlen;    
	u_int32_t       icps_reflect;   
	u_int32_t       icps_inhist[ICMP_MAXTYPE + 1];
	u_int32_t       icps_bmcastecho;
	u_int32_t       icps_bmcasttstamp; 
};
struct  ether_arp {
	struct  arphdr ea_hdr;  
	u_char  arp_sha[ETHER_ADDR_LEN];        
	u_char  arp_spa[4];     
	u_char  arp_tha[ETHER_ADDR_LEN];        
	u_char  arp_tpa[4];     
};
struct sockaddr_inarp {
	u_char  sin_len;
	u_char  sin_family;
	u_short sin_port;
	struct  in_addr sin_addr;
	struct  in_addr sin_srcaddr;
	u_short sin_tos;
	u_short sin_other;
};
struct tun_softc {
	u_short tun_flags;              


	struct  ifnet tun_if;           
	int     tun_pgrp;               
	struct  selinfo tun_rsel;       
	struct  selinfo tun_wsel;       
};
struct igmp {
	u_char          igmp_type;      
	u_char          igmp_code;      
	u_short         igmp_cksum;     
	struct in_addr  igmp_group;     
};
struct igmpv3 {
	u_char          igmp_type;      
	u_char          igmp_code;      
	u_short         igmp_cksum;     
	struct in_addr  igmp_group;     
	                                
	u_char          igmp_misc;      
	u_char          igmp_qqi;       
	u_short         igmp_numsrc;    
	 
};
struct igmp_grouprec {
	u_char          ig_type;        
	u_char          ig_datalen;     
	u_short         ig_numsrc;      
	struct in_addr  ig_group;       
	 
};
struct igmp_report {
	u_char          ir_type;        
	u_char          ir_rsv1;        
	u_short         ir_cksum;       
	u_short         ir_rsv2;        
	u_short         ir_numgrps;     
		
};
struct igmpstat_v3 {
	uint32_t igps_version;          
	uint32_t igps_len;              
	uint64_t igps_rcv_total;        
	uint64_t igps_rcv_tooshort;     
	uint64_t igps_rcv_badttl;       
	uint64_t igps_rcv_badsum;       
	uint64_t igps_rcv_v1v2_queries; 
	uint64_t igps_rcv_v3_queries;   
	uint64_t igps_rcv_badqueries;   
	uint64_t igps_rcv_gen_queries;  
	uint64_t igps_rcv_group_queries;
	uint64_t igps_rcv_gsr_queries;  
	uint64_t igps_drop_gsr_queries; 
	uint64_t igps_rcv_reports;      
	uint64_t igps_rcv_badreports;   
	uint64_t igps_rcv_ourreports;   
	uint64_t igps_rcv_nora;         
	uint64_t igps_snd_reports;      
	uint64_t __igps_pad[4];
} __attribute__((aligned(8)));
struct igmpstat {
	u_int   igps_rcv_total;         
	u_int   igps_rcv_tooshort;      
	u_int   igps_rcv_badsum;        
	u_int   igps_rcv_queries;       
	u_int   igps_rcv_badqueries;    
	u_int   igps_rcv_reports;       
	u_int   igps_rcv_badreports;    
	u_int   igps_rcv_ourreports;    
	u_int   igps_snd_reports;       
};
struct in_addr {
	in_addr_t s_addr;
};
struct sockaddr_in {
	__uint8_t       sin_len;
	sa_family_t     sin_family;
	in_port_t       sin_port;
	struct  in_addr sin_addr;
	char            sin_zero[8];
};
struct in_addr_4in6 {
	u_int32_t       ia46_pad32[3];
	struct  in_addr ia46_addr4;
};
struct inp_stat {
	u_int64_t       rxpackets;
	u_int64_t       rxbytes;
	u_int64_t       txpackets;
	u_int64_t       txbytes;
};
struct inp_necp_attributes {
	char *inp_domain __null_terminated;
	char *inp_account __null_terminated;
	char *inp_domain_owner __null_terminated;
	char *inp_tracker_domain __null_terminated;
	char *inp_domain_context __null_terminated;
};
struct inpcb {
	decl_lck_mtx_data(, inpcb_mtx); 
	LIST_ENTRY(inpcb) inp_hash;     
	LIST_ENTRY(inpcb) inp_list;     
	void    *inp_ppcb;              
	struct inpcbinfo *inp_pcbinfo;  
	struct socket *inp_socket;      
	LIST_ENTRY(inpcb) inp_portlist; 
	RB_ENTRY(inpcb) infc_link;      
	struct inpcbport *inp_phd;      
	inp_gen_t inp_gencnt;           
	int     inp_hash_element;       
	int     inp_wantcnt;            
	int     inp_state;              
	u_short inp_fport;              
	u_short inp_lport;              
	uint32_t inp_flags;            
	uint32_t inp_flags2;           
	uint32_t inp_log_flags;
	uint32_t inp_flow;             
	uint32_t inp_lifscope;          
	uint32_t inp_fifscope;          

	uint32_t inp_sndingprog_waiters;
	u_char  inp_sndinprog_cnt;      
	u_char  inp_vflag;              

	u_char inp_ip_ttl;              
	u_char inp_ip_p;                

	struct ifnet *inp_boundifp;     
	struct ifnet *inp_last_outifp;  
	uint32_t inp_flowhash;         

	union {
		
		struct in_addr_4in6 inp46_foreign;
		struct in6_addr inp6_foreign;
	} inp_dependfaddr;
	union {
		
		struct in_addr_4in6 inp46_local;
		struct in6_addr inp6_local;
	} inp_dependladdr;
	union {
		
		struct route inp4_route;
		struct route_in6 inp6_route;
	} inp_dependroute;
	struct {
		
		u_char inp4_ip_tos;
		
		struct mbuf *inp4_options;
		
		struct ip_moptions *inp4_moptions;
	} inp_depend4;
	struct {
		
		struct mbuf *inp6_options;
		
		struct  ip6_pktopts *inp6_outputopts;
		
		struct  ip6_moptions *inp6_moptions;
		
		struct  icmp6_filter *inp6_icmp6filt;
		
		int     inp6_cksum;
		short   inp6_hops;
	} inp_depend6;

	uint64_t       inp_fadv_total_time;
	uint64_t       inp_fadv_start_time;
	uint64_t       inp_fadv_cnt;

	caddr_t inp_saved_ppcb;         
	struct inp_necp_attributes inp_necp_attributes;
	struct necp_inpcb_result inp_policyresult;
	uuid_t necp_client_uuid;

	uint32_t inp_bind_in_progress_waiters;
	thread_t inp_bind_in_progress_last_waiter_thread;

	thread_t inp_bind_in_progress_thread;

	necp_client_flow_cb necp_cb;
	size_t inp_resolver_signature_length;
	uint8_t *inp_resolver_signature __sized_by(inp_resolver_signature_length);
	u_char *__sized_by(inp_keepalive_datalen) inp_keepalive_data;     
	uint8_t inp_keepalive_datalen; 
	uint8_t inp_keepalive_type;    
	uint16_t inp_keepalive_interval; 
	uint32_t inp_nstat_refcnt __attribute__((aligned(4)));
	struct inp_stat *inp_stat;
	struct inp_stat *inp_cstat;     
	struct inp_stat *inp_wstat;     
	struct inp_stat *inp_Wstat;     
	struct inp_stat *inp_btstat;    
	uint8_t inp_stat_store[sizeof(struct inp_stat) + sizeof(u_int64_t)];
	uint8_t inp_cstat_store[sizeof(struct inp_stat) + sizeof(u_int64_t)];
	uint8_t inp_wstat_store[sizeof(struct inp_stat) + sizeof(u_int64_t)];
	uint8_t inp_Wstat_store[sizeof(struct inp_stat) + sizeof(u_int64_t)];
	uint8_t inp_btstat_store[sizeof(struct inp_stat) + sizeof(u_int64_t)];
	activity_bitmap_t inp_nw_activity;
	uint64_t inp_start_timestamp;
	uint64_t inp_connect_timestamp;

	char inp_last_proc_name[MAXCOMLEN + 1];
	char inp_e_proc_name[MAXCOMLEN + 1];
};
struct _inpcb_list_entry {
	u_int32_t   le_next;
	u_int32_t   le_prev;
};
struct inpcb_compat {
	_INPCB_LIST_ENTRY(inpcb) inp_hash;      
	struct in_addr reserved1;               
	struct in_addr reserved2;               
	u_short inp_fport;                      
	u_short inp_lport;                      
	_INPCB_LIST_ENTRY(inpcb) inp_list;      
	_INPCB_PTR(caddr_t) inp_ppcb;           
	_INPCB_PTR(struct inpcbinfo *) inp_pcbinfo;     
	_INPCB_PTR(void *) inp_socket;  
	u_char nat_owner;               
	u_int32_t nat_cookie;           
	_INPCB_LIST_ENTRY(inpcb) inp_portlist;  
	_INPCB_PTR(struct inpcbport *) inp_phd; 
	inp_gen_t inp_gencnt;           
	int inp_flags;                  
	u_int32_t inp_flow;

	u_char inp_vflag;

	u_char inp_ip_ttl;              
	u_char inp_ip_p;                
	union {
		
		struct in_addr_4in6 inp46_foreign;
		struct in6_addr inp6_foreign;
	} inp_dependfaddr;
	union {
		
		struct in_addr_4in6 inp46_local;
		struct in6_addr inp6_local;
	} inp_dependladdr;
	union {
		
		u_char inp4_route[20];
		u_char inp6_route[32];
	} inp_dependroute;
	struct {
		
		u_char inp4_ip_tos;
		
		_INPCB_PTR(struct mbuf *) inp4_options;
		
		_INPCB_PTR(struct ip_moptions *) inp4_moptions;
	} inp_depend4;

	struct {
		
		_INPCB_PTR(struct mbuf *) inp6_options;
		u_int8_t inp6_hlim;
		u_int8_t unused_uint8_1;
		ushort unused_uint16_1;
		
		_INPCB_PTR(struct ip6_pktopts *) inp6_outputopts;
		
		_INPCB_PTR(struct ip6_moptions *) inp6_moptions;
		
		_INPCB_PTR(struct icmp6_filter *) inp6_icmp6filt;
		
		int     inp6_cksum;
		u_short inp6_ifindex;
		short   inp6_hops;
	} inp_depend6;

	int hash_element;               
	_INPCB_PTR(caddr_t) inp_saved_ppcb; 
	_INPCB_PTR(struct inpcbpolicy *) inp_sp;
	u_int32_t       reserved[3];    
};
struct  xinpcb {
	u_int32_t       xi_len;         
	struct  inpcb_compat xi_inp;
	struct  xsocket xi_socket;
	u_quad_t        xi_alignment_hack;
};
struct xinpcb_list_entry {
	u_int64_t   le_next;
	u_int64_t   le_prev;
};
struct  xinpcb_n {
	u_int32_t       xi_len;         
	u_int32_t       xi_kind;        
	u_int64_t       xi_inpp;
	u_short         inp_fport;      
	u_short         inp_lport;      
	u_int64_t       inp_ppcb;       
	inp_gen_t       inp_gencnt;     
	int             inp_flags;      
	u_int32_t       inp_flow;
	u_char          inp_vflag;
	u_char          inp_ip_ttl;     
	u_char          inp_ip_p;       
	union {                         
		struct in_addr_4in6     inp46_foreign;
		struct in6_addr         inp6_foreign;
	} inp_dependfaddr;
	union {                         
		struct in_addr_4in6     inp46_local;
		struct in6_addr         inp6_local;
	} inp_dependladdr;
	struct {
		u_char  inp4_ip_tos;    
	} inp_depend4;
	struct {
		u_int8_t inp6_hlim;
		int     inp6_cksum;
		u_short inp6_ifindex;
		short   inp6_hops;
	} inp_depend6;
	u_int32_t               inp_flowhash;
	u_int32_t       inp_flags2;
};
struct  xinpgen {
	u_int32_t       xig_len;        
	u_int           xig_count;      
	inp_gen_t       xig_gen;        
	so_gen_t        xig_sogen;      
};
struct inpcbport {
	LIST_ENTRY(inpcbport) phd_hash;
	struct inpcbhead phd_pcblist;
	u_short phd_port;
};
struct intimercount {
	u_int32_t intimer_lazy; 
	u_int32_t intimer_fast; 
	u_int32_t intimer_nodelay; 
};
struct inpcbinfo {
	TAILQ_ENTRY(inpcbinfo)  ipi_entry;
	inpcb_timer_func_t      ipi_gc;
	inpcb_timer_func_t      ipi_timer;
	struct intimercount     ipi_gc_req;
	struct intimercount     ipi_timer_req;

	lck_rw_t                ipi_lock;

	struct inpcbhead        *ipi_listhead;
	uint32_t                ipi_count;

	uint32_t                ipi_twcount;

	uint64_t                ipi_gencnt;

	uint16_t                ipi_lastport;
	uint16_t                ipi_lastlow;
	uint16_t                ipi_lasthi;

	kalloc_type_view_t       ipi_zone;

	struct inpcbhead        *__counted_by(ipi_hashbase_count) ipi_hashbase;
	size_t                  ipi_hashbase_count;
	u_long                  ipi_hashmask;

	struct inpcbporthead    *__counted_by(ipi_porthashbase_count) ipi_porthashbase;
	size_t                  ipi_porthashbase_count;
	u_long                  ipi_porthashmask;

	lck_attr_t              ipi_lock_attr;
	lck_grp_t               *ipi_lock_grp;

	u_int32_t               ipi_flags;
};
struct sockaddr_inifscope {
	__uint8_t       sin_len;
	sa_family_t     sin_family;
	in_port_t       sin_port;
	struct  in_addr sin_addr;
	union {
		char    sin_zero[8];
		struct {
			__uint32_t      ifscope;
		} _in_index;
	} un;
};
struct activity_bitmap {
	uint64_t        start;          
	uint64_t        bitmap[2];      
} activity_bitmap_t;
struct so_tcdbg {
	u_int32_t       so_tcdbg_cmd;
	int32_t         so_tcdbg_tclass;
	int32_t         so_tcdbg_netsvctype;
	uint8_t         so_tcdbg_ecn_val;  
	u_int32_t       so_tcdbg_count;
	pid_t           so_tcdbg_pid;
	u_int32_t       so_tcbbg_qos_mode;
	char            so_tcdbg_pname[(2 * MAXCOMLEN) + 1];
};
struct net_qos_param {
	u_int64_t nq_transfer_size;     
	u_int32_t nq_use_expensive:1,   
	    nq_uplink:1,                
	    nq_use_constrained:1;       
	u_int32_t nq_unused;            
};
struct in_ifaddr {
	struct ifaddr ia_ifa;           
	u_int32_t ia_net;               
	u_int32_t ia_netmask;           
	u_int32_t ia_subnet;            
	u_int32_t ia_subnetmask;        
	struct in_addr ia_netbroadcast; 
	TAILQ_ENTRY(in_ifaddr) ia_link; 
	struct sockaddr_in ia_addr;     
	struct sockaddr_in ia_dstaddr;  
	struct sockaddr_in ia_sockmask; 
	TAILQ_ENTRY(in_ifaddr) ia_hash; 
};
struct in_aliasreq {
	char ifra_name[IFNAMSIZ];       
	struct sockaddr_in ifra_addr;
	struct sockaddr_in ifra_broadaddr;
	struct sockaddr_in ifra_mask;
};
struct kev_in_data {
	struct net_event_data link_data;
	struct in_addr ia_addr;         
	u_int32_t ia_net;               
	u_int32_t ia_netmask;           
	u_int32_t ia_subnet;            
	u_int32_t ia_subnetmask;        
	struct in_addr ia_netbroadcast; 
	struct in_addr ia_dstaddr;
};
struct kev_in_collision {
	struct net_event_data link_data; 
	struct in_addr ia_ipaddr;       
	u_char hw_len;                  
	u_char hw_addr[__counted_by(hw_len)];
};
struct kev_in_arpfailure {
	struct net_event_data link_data; 
};
struct kev_in_arpalive {
	struct net_event_data link_data; 
};
struct kev_socket_event_data {
	union sockaddr_in_4_6 kev_sockname;
	union sockaddr_in_4_6 kev_peername;
};
struct kev_socket_closed {
	struct kev_socket_event_data ev_data;
};
struct router_info {
	struct ifnet *rti_ifp;
	int    rti_type; 
	int    rti_time; 
	SLIST_ENTRY(router_info) rti_list;
};
struct ip_msource {
	RB_ENTRY(ip_msource)    ims_link;       
	in_addr_t               ims_haddr;      
	struct ims_st {
		uint16_t        ex;             
		uint16_t        in;             
	}                       ims_st[2];      
	uint8_t                 ims_stp;        
};
struct in_msource {
	RB_ENTRY(ip_msource)    ims_link;       
	in_addr_t               ims_haddr;      
	uint8_t                 imsl_st[2];     
};
struct in_mfilter {
	struct ip_msource_tree  imf_sources; 
	u_long                  imf_nsrc;    
	uint8_t                 imf_st[2];   
};
struct in_multi {
	decl_lck_mtx_data(, inm_lock);
	u_int32_t inm_refcount;         
	u_int32_t inm_reqcnt;           
	u_int32_t inm_debug;            
	LIST_ENTRY(in_multi) inm_link;  
	struct  in_addr inm_addr;       
	struct  ifnet *inm_ifp;         
	struct  ifmultiaddr *inm_ifma;  
	u_int   inm_timer;              
	u_int   inm_state;              
	bool    inm_in_nrele;           

	struct igmp_ifinfo      *inm_igi;       
	SLIST_ENTRY(in_multi)    inm_dtle;      
	SLIST_ENTRY(in_multi)    inm_nrele;     
	u_int32_t                inm_nrelecnt;  
	struct ip_msource_tree   inm_srcs;      
	u_long                   inm_nsrc;      

	struct ifqueue           inm_scq;       
	struct timeval           inm_lastgsrtv; 
	uint16_t                 inm_sctimer;   
	uint16_t                 inm_scrv;      

	struct inm_st {
		uint16_t        iss_fmode;      
		uint16_t        iss_asm;        
		uint16_t        iss_ex;         
		uint16_t        iss_in;         
		uint16_t        iss_rec;        
	}                       inm_st[2];      

	void (*inm_trace)               
	(struct in_multi *, int);
};
struct in_multistep {
	struct in_multi *i_inm;
};
struct in_ifextra {
	uint32_t                netsig_len;
	u_int8_t                netsig[IFNET_SIGNATURELEN];
};
struct ip {
	u_char  ip_tos;                 
	u_short ip_len;                 
	u_short ip_id;                  
	u_short ip_off;                 
	u_char  ip_ttl;                 
	u_char  ip_p;                   
	u_short ip_sum;                 
	struct  in_addr ip_src, ip_dst;  
};
struct  ip_timestamp {
	u_char  ipt_code;               
	u_char  ipt_len;                
	u_char  ipt_ptr;                
	u_int   ipt_flg:4,              
	    ipt_oflw:4;                 
	u_int   ipt_oflw:4,             
	    ipt_flg:4;                  
	union ipt_timestamp {
		n_long  ipt_time[1];
		struct  ipt_ta {
			struct in_addr ipt_addr;
			n_long ipt_time;
		} ipt_ta[1];
	} ipt_timestamp;
};
struct ip6_hdr {
	union {
		struct ip6_hdrctl {
			u_int32_t ip6_un1_flow; 
			u_int16_t ip6_un1_plen; 
			u_int8_t  ip6_un1_nxt;  
			u_int8_t  ip6_un1_hlim; 
		} ip6_un1;
		u_int8_t ip6_un2_vfc;   
	} ip6_ctlun;
	struct in6_addr ip6_src;        
	struct in6_addr ip6_dst;        
} __attribute__((__packed__));
struct  ip6_ext {
	u_int8_t ip6e_nxt;
	u_int8_t ip6e_len;
} __attribute__((__packed__));
struct ip6_hbh {
	u_int8_t ip6h_nxt;      
	u_int8_t ip6h_len;      
} __attribute__((__packed__));
struct ip6_dest {
	u_int8_t ip6d_nxt;      
	u_int8_t ip6d_len;      
} __attribute__((__packed__));
struct ip6_opt {
	u_int8_t ip6o_type;
	u_int8_t ip6o_len;
} __attribute__((__packed__));
struct ip6_opt_jumbo {
	u_int8_t ip6oj_type;
	u_int8_t ip6oj_len;
	u_int8_t ip6oj_jumbo_len[4];
} __attribute__((__packed__));
struct ip6_opt_nsap {
	u_int8_t ip6on_type;
	u_int8_t ip6on_len;
	u_int8_t ip6on_src_nsap_len;
	u_int8_t ip6on_dst_nsap_len;
}__attribute__((__packed__));
struct ip6_opt_tunnel {
	u_int8_t ip6ot_type;
	u_int8_t ip6ot_len;
	u_int8_t ip6ot_encap_limit;
}__attribute__((__packed__));
struct ip6_opt_router {
	u_int8_t ip6or_type;
	u_int8_t ip6or_len;
	u_int8_t ip6or_value[2];
}__attribute__((__packed__));
struct ip6_rthdr {
	u_int8_t  ip6r_nxt;     
	u_int8_t  ip6r_len;     
	u_int8_t  ip6r_type;    
	u_int8_t  ip6r_segleft; 
} __attribute__((__packed__));
struct ip6_rthdr0 {
	u_int8_t  ip6r0_nxt;            
	u_int8_t  ip6r0_len;            
	u_int8_t  ip6r0_type;           
	u_int8_t  ip6r0_segleft;        
	u_int32_t  ip6r0_reserved;      
} __attribute__((__packed__));
struct ip6_frag {
	u_int8_t  ip6f_nxt;             
	u_int8_t  ip6f_reserved;        
	u_int16_t ip6f_offlg;           
	u_int32_t ip6f_ident;           
} __attribute__((__packed__));
struct dn_heap_entry {
	dn_key key;      
	size_t obj_size; 
	void * object  __sized_by_or_null(obj_size);   
};
struct dn_heap {
	int size;              
	int elements;          
	int offset;            
	struct dn_heap_entry *__counted_by_or_null(size) p; 
};
struct dn_pkt_tag {
	void                *dn_pf_rule;        
	int                 dn_dir;             
	dn_key              dn_output_time;     
	struct ifnet        *dn_ifp;            
	union {
		struct sockaddr_in      _dn_dst;
		struct sockaddr_in6     _dn_dst6;
	}                   dn_dst_;
	union {
		struct route            _dn_ro; 
		struct route_in6        _dn_ro6;
	}               dn_ro_;
	struct route_in6    dn_ro6_pmtu;        
	struct ifnet        *dn_origifp;        
	u_int32_t           dn_mtu;             
	u_int32_t           dn_unfragpartlen;   
	struct ip6_exthdrs  dn_exthdrs;         
	int                 dn_flags;           
	union {
		struct ip_out_args      _dn_ipoa;
		struct ip6_out_args     _dn_ip6oa;
	}                   dn_ipoa_;
};
struct dn_flow_queue {
	struct dn_flow_queue *next;
	struct ip_flow_id id;

	struct mbuf *head, *tail; 
	u_int len;
	u_int len_bytes;
	u_int32_t numbytes;             

	u_int64_t tot_pkts;     
	u_int64_t tot_bytes;
	u_int32_t drops;

	int hash_slot;          

	int avg;                
	int count;              
	int random;             
	u_int64_t q_time;       

	struct dn_flow_set *fs; 
	int heap_pos;           
	dn_key sched_time;      

	dn_key S, F;            
};
struct dn_flow_set {
	SLIST_ENTRY(dn_flow_set)    next;

	u_short fs_nr;          
	u_short flags_fs;

	struct dn_pipe *pipe;   
	u_short parent_nr;      

	int weight;             
	int qsize;              
	int plr;                

	struct ip_flow_id flow_mask;

	int rq_size;            
	int rq_elements;        
	struct dn_flow_queue **__counted_by_or_null(rq_size + 1) rq; 

	u_int32_t last_expired; 
	int backlogged;         

	int w_q;                
	int max_th;             
	int min_th;             
	int max_p;              
	u_int c_1;              
	u_int c_2;              
	u_int c_3;              
	u_int c_4;              
	u_int * __counted_by_or_null(lookup_depth) w_q_lookup;     
	u_int lookup_depth;     
	int lookup_step;        
	int lookup_weight;      
	int avg_pkt_size;       
	int max_pkt_size;       
};
struct dn_pipe {                
	SLIST_ENTRY(dn_pipe)        next;

	int pipe_nr;            
	int bandwidth;          
	int delay;              

	struct      mbuf *head, *tail;  

	struct dn_heap scheduler_heap; 
	struct dn_heap not_eligible_heap; 
	struct dn_heap idle_heap; 

	dn_key V;               
	int sum;                
	int numbytes;           

	dn_key sched_time;      

	char if_name[IFNAMSIZ];
	struct ifnet *ifp;
	int ready; 

	struct dn_flow_set fs; 
};
struct dn_heap_32 {
	int size;
	int elements;
	int offset; 
	user32_addr_t p; 
};
struct dn_flow_queue_32 {
	user32_addr_t next;
	struct ip_flow_id id;

	user32_addr_t head, tail; 
	u_int len;
	u_int len_bytes;
	u_int32_t numbytes;     

	u_int64_t tot_pkts;     
	u_int64_t tot_bytes;
	u_int32_t drops;

	int hash_slot;                  

	int avg;                
	int count;              
	int random;             
	u_int32_t q_time;       

	user32_addr_t fs; 
	int heap_pos;           
	dn_key sched_time;      

	dn_key S, F;            
};
struct dn_flow_set_32 {
	user32_addr_t       next;

	u_short fs_nr;                  
	u_short flags_fs;

	user32_addr_t pipe;     
	u_short parent_nr;      

	int weight;             
	int qsize;              
	int plr;                

	struct ip_flow_id flow_mask;

	int rq_size;            
	int rq_elements; 
	user32_addr_t rq; 

	u_int32_t last_expired; 
	int backlogged;                 

	int w_q;                
	int max_th;             
	int min_th;             
	int max_p;              
	u_int c_1;              
	u_int c_2;              
	u_int c_3;              
	u_int c_4;              
	user32_addr_t w_q_lookup; 
	u_int lookup_depth;     
	int lookup_step;        
	int lookup_weight;      
	int avg_pkt_size;       
	int max_pkt_size;       
};
struct dn_pipe_32 {             
	user32_addr_t       next;

	int pipe_nr;            
	int bandwidth;          
	int delay;              

	user32_addr_t head, tail; 

	struct dn_heap_32 scheduler_heap; 
	struct dn_heap_32 not_eligible_heap; 
	struct dn_heap_32 idle_heap; 

	dn_key V;               
	int sum;                
	int numbytes;           

	dn_key sched_time; 

	char if_name[IFNAMSIZ];
	user32_addr_t ifp;
	int ready;              

	struct dn_flow_set_32 fs; 
};
struct dn_heap_64 {
	int size;
	int elements;
	int offset; 
	user64_addr_t p; 
};
struct dn_flow_queue_64 {
	user64_addr_t next;
	struct ip_flow_id id;

	user64_addr_t head, tail; 
	u_int len;
	u_int len_bytes;
	u_int32_t numbytes;             

	u_int64_t tot_pkts;             
	u_int64_t tot_bytes;
	u_int32_t drops;

	int hash_slot;                          

	int avg;                
	int count;              
	int random;             
	u_int32_t q_time;       

	user64_addr_t fs;               
	int heap_pos;                           
	dn_key sched_time;              

	dn_key S, F;                            
};
struct dn_flow_set_64 {
	user64_addr_t next;             

	u_short fs_nr;          
	u_short flags_fs;

	user64_addr_t pipe;     
	u_short parent_nr;      

	int weight;             
	int qsize;              
	int plr;                

	struct ip_flow_id flow_mask;

	int rq_size;            
	int rq_elements; 
	user64_addr_t rq; 

	u_int32_t last_expired; 
	int backlogged;                 

	int w_q;                
	int max_th;             
	int min_th;             
	int max_p;              
	u_int c_1;              
	u_int c_2;              
	u_int c_3;              
	u_int c_4;              
	user64_addr_t w_q_lookup; 
	u_int lookup_depth;     
	int lookup_step;        
	int lookup_weight;      
	int avg_pkt_size;       
	int max_pkt_size;       
};
struct dn_pipe_64 {             
	user64_addr_t       next;

	int pipe_nr;            
	int bandwidth;          
	int delay;              

	user64_addr_t head, tail; 

	struct dn_heap_64 scheduler_heap;       
	struct dn_heap_64 not_eligible_heap;    
	struct dn_heap_64 idle_heap;                    

	dn_key V;               
	int sum;                
	int numbytes;           

	dn_key sched_time; 

	char if_name[IFNAMSIZ];
	user64_addr_t ifp;
	int ready; 

	struct dn_flow_set_64 fs; 
};
struct dn_pipe_mini_config {
	uint32_t bandwidth;
	uint32_t delay;
	uint32_t plr;
};
struct dn_rule_mini_config {
	uint32_t dir;
	uint32_t af;
	uint32_t proto;
	uint32_t src_port;
	uint32_t dst_port;
	char ifname[IFXNAMSIZ];
};
struct dummynet_event {
	uint32_t dn_event_code;
	union {
		struct dn_pipe_mini_config _dnev_pipe_config;
		struct dn_rule_mini_config _dnev_rule_config;
	} dn_event;
};
struct encaptab {
	LIST_ENTRY(encaptab) chain;
	int af;
	int proto;                      
	struct sockaddr_storage src;    
	struct sockaddr_storage srcmask;
	struct sockaddr_storage dst;    
	struct sockaddr_storage dstmask;
	int (*func)(const struct mbuf *, int, int, void *);
	const struct protosw *psw;      
	void *arg;                      
};
struct ip_flow_id {
	u_int32_t       dst_ip;
	u_int32_t       src_ip;
	u_int16_t       dst_port;
	u_int16_t       src_port;
	u_int8_t        proto;
	u_int8_t        flags;  
	u_int8_t        addr_type; 
	struct in6_addr dst_ip6;        
	struct in6_addr src_ip6;
	u_int32_t       flow_id6;
	u_int32_t       frag_id6;
};
struct ip_fw_args {
	struct mbuf             *fwa_m;         
	struct ifnet            *fwa_oif;       
	struct pf_rule          *fwa_pf_rule;   
	struct ether_header     *fwa_eh;        
	int                     fwa_flags;      
	int                     fwa_oflags;     
	union {
		struct ip_out_args  *_fwa_ipoa;     
		struct ip6_out_args *_fwa_ip6oa;    
	} fwa_ipoa_;
	union {
		struct route        *_fwa_ro;       
		struct route_in6    *_fwa_ro6;      
	} fwa_ro_;
	union {
		struct sockaddr_in  *_fwa_dst;      
		struct sockaddr_in6 *_fwa_dst6;     
	} fwa_dst_;
	struct route_in6        *fwa_ro6_pmtu;  
	struct ifnet            *fwa_origifp;   
	u_int32_t               fwa_mtu;        
	u_int32_t               fwa_unfragpartlen;  
	struct ip6_exthdrs      *fwa_exthdrs;   
	struct ip_flow_id       fwa_id;         
	u_int32_t               fwa_cookie;
};
struct ip_fw_in_args {
	struct pf_rule          *fwai_pf_rule;  
};
struct icmp_ra_addr {
	u_int32_t ira_addr;
	u_int32_t ira_preference;
};
struct icmp {
	u_char  icmp_type;              
	u_char  icmp_code;              
	u_short icmp_cksum;             
	union {
		u_char ih_pptr;                 
		struct in_addr ih_gwaddr;       
		struct ih_idseq {
			n_short icd_id;
			n_short icd_seq;
		} ih_idseq;
		int ih_void;

		
		struct ih_pmtu {
			n_short ipm_void;
			n_short ipm_nextmtu;
		} ih_pmtu;

		struct ih_rtradv {
			u_char irt_num_addrs;
			u_char irt_wpa;
			u_int16_t irt_lifetime;
		} ih_rtradv;
	} icmp_hun;
	union {
		struct id_ts {
			n_time its_otime;
			n_time its_rtime;
			n_time its_ttime;
		} id_ts;
		struct id_ip  {
			struct ip idi_ip;
			
		} id_ip;
		struct icmp_ra_addr id_radv;
		u_int32_t id_mask;
		char    id_data[1];
	} icmp_dun;
};
struct ipovly {
	u_char  ih_x1[9];               
	u_char  ih_pr;                  
	u_short ih_len;                 
	struct  in_addr ih_src;         
	struct  in_addr ih_dst;         
};
struct ipq {
	TAILQ_ENTRY(ipq) ipq_list;      
	struct mbuf *ipq_frags;         
	u_char  ipq_ttl;                
	u_char  ipq_p;                  
	u_short ipq_id;                 
	struct  in_addr ipq_src, ipq_dst;
	u_int32_t       ipq_nfrags;     
	uint32_t ipq_csum_flags;        
	uint32_t ipq_csum;              
};
struct ipoption {
	struct  in_addr ipopt_dst;      
	char    ipopt_list[MAX_IPOPTLEN];       
};
struct ip_moptions {
	decl_lck_mtx_data(, imo_lock);
	uint32_t imo_refcnt;            
	uint32_t imo_debug;             
	struct  ifnet *imo_multicast_ifp; 
	u_char  imo_multicast_ttl;      
	u_char  imo_multicast_loop;     
	u_short imo_num_memberships;    
	u_short imo_max_memberships;    
	u_short imo_max_filters;        
	struct  in_multi **__counted_by(imo_max_memberships) imo_membership;
	struct  in_mfilter *__counted_by(imo_max_filters) imo_mfilters;
	u_int32_t imo_multicast_vif;    
	struct  in_addr imo_multicast_addr; 
	void (*imo_trace)               
	(struct ip_moptions *, int);
};
struct ip_fwd_tag {
	struct sockaddr_in *next_hop;   
};
struct  ipstat {
	u_int32_t ips_total;            
	u_int32_t ips_badsum;           
	u_int32_t ips_tooshort;         
	u_int32_t ips_toosmall;         
	u_int32_t ips_badhlen;          
	u_int32_t ips_badlen;           
	u_int32_t ips_fragments;        
	u_int32_t ips_fragdropped;      
	u_int32_t ips_fragtimeout;      
	u_int32_t ips_forward;          
	u_int32_t ips_fastforward;      
	u_int32_t ips_cantforward;      
	u_int32_t ips_redirectsent;     
	u_int32_t ips_noproto;          
	u_int32_t ips_delivered;        
	u_int32_t ips_localout;         
	u_int32_t ips_odropped;         
	u_int32_t ips_reassembled;      
	u_int32_t ips_fragmented;       
	u_int32_t ips_ofragments;       
	u_int32_t ips_cantfrag;         
	u_int32_t ips_badoptions;       
	u_int32_t ips_noroute;          
	u_int32_t ips_badvers;          
	u_int32_t ips_rawout;           
	u_int32_t ips_toolong;          
	u_int32_t ips_notmember;        
	u_int32_t ips_nogif;            
	u_int32_t ips_badaddr;          
	u_int32_t ips_pktdropcntrl;     
	u_int32_t ips_rcv_swcsum;       
	u_int32_t ips_rcv_swcsum_bytes; 
	u_int32_t ips_snd_swcsum;       
	u_int32_t ips_snd_swcsum_bytes; 
	u_int32_t ips_adj;              
	u_int32_t ips_adj_hwcsum_clr;   
	u_int32_t ips_rxc_collisions;   
	u_int32_t ips_rxc_chained;      
	u_int32_t ips_rxc_notchain;     
	u_int32_t ips_rxc_chainsz_gt2;  
	u_int32_t ips_rxc_chainsz_gt4;  
	u_int32_t ips_rxc_notlist;      
	u_int32_t ips_raw_sappend_fail; 
	u_int32_t ips_necp_policy_drop; 
	u_int32_t ips_rcv_if_weak_match; 
	u_int32_t ips_rcv_if_no_match;  
	u_int32_t ips_input_ipf_drop;   
	u_int32_t ips_input_no_proto;   
	u_int32_t ips_src_addr_not_avail; 
};
struct ip_linklocal_stat {
	u_int32_t       iplls_in_total;
	u_int32_t       iplls_in_badttl;
	u_int32_t       iplls_out_total;
	u_int32_t       iplls_out_badttl;
};
struct ip_out_args {
	unsigned int    ipoa_boundif;   
	struct flowadv  ipoa_flowadv;   
	u_int32_t       ipoa_flags;     
	int             ipoa_sotc;      
	int             ipoa_netsvctype; 
	int32_t         qos_marking_gencount;
};
struct isakmp {
	cookie_t i_ck;          
	cookie_t r_ck;          
	uint8_t np;             
	uint8_t vers;
	uint8_t etype;          
	uint8_t flags;          
	msgid_t msgid;
	uint32_t len;           
};
struct isakmp_gen {
	uint8_t  np;       
	uint8_t  critical; 
	uint16_t len;      
};
struct ipf_pktopts {
	u_int32_t                       ippo_flags;
	ifnet_t                         ippo_mcast_ifnet;
	int                             ippo_mcast_loop;
	u_int8_t                        ippo_mcast_ttl;
};
struct ipf_filter {
	void            *cookie;
	const char      *name;
	ipf_input_func  ipf_input;
	ipf_output_func ipf_output;
	ipf_detach_func ipf_detach;
};
struct ipfilter {
	TAILQ_ENTRY(ipfilter)   ipf_link;
	struct ipf_filter       ipf_filter;
	struct ipfilter_list    *ipf_head;
	TAILQ_ENTRY(ipfilter)   ipf_tbr;
	uint32_t                ipf_flags;
};
struct mptcp_mpcapable_opt_common {
	uint8_t        mmco_kind;
	uint8_t        mmco_len;
	uint8_t        mmco_version:4,
	    mmco_subtype:4;
	uint8_t        mmco_flags;
} __attribute__((__packed__));
struct mptcp_mpcapable_opt_rsp {
	struct mptcp_mpcapable_opt_common mmc_common;
	mptcp_key_t mmc_localkey;
} __attribute__((__packed__));
struct mptcp_mpcapable_opt_rsp1 {
	struct mptcp_mpcapable_opt_common mmc_common;
	mptcp_key_t mmc_localkey;
	mptcp_key_t mmc_remotekey;
} __attribute__((__packed__));
struct mptcp_mpcapable_opt_rsp2 {
	struct mptcp_mpcapable_opt_rsp1 mmc_rsp1;
	uint16_t data_len;
	uint16_t csum;
} __attribute__((__packed__));
struct mptcp_mpjoin_opt_req {
	uint8_t        mmjo_kind;
	uint8_t        mmjo_len;
	uint8_t        mmjo_subtype_bkp;
	uint8_t        mmjo_addr_id;
	uint32_t       mmjo_peer_token;
	uint32_t       mmjo_rand;
} __attribute__((__packed__));
struct mptcp_mpjoin_opt_rsp {
	uint8_t        mmjo_kind;
	uint8_t        mmjo_len;
	uint8_t        mmjo_subtype_bkp;
	uint8_t        mmjo_addr_id;
	uint64_t       mmjo_mac; 
	uint32_t       mmjo_rand;
} __attribute__((__packed__));
struct mptcp_mpjoin_opt_rsp2 {
	uint8_t        mmjo_kind;
	uint8_t        mmjo_len;
	uint8_t        mmjo_reserved1:4,
	    mmjo_subtype:4;
	uint8_t        mmjo_reserved2;
	uint8_t        mmjo_mac[HMAC_TRUNCATED_ACK]; 
} __attribute__((__packed__));
struct mptcp_remaddr_opt {
	uint8_t        mr_kind;
	uint8_t        mr_len;
	uint8_t        mr_rest:4,
	    mr_subtype:4;
	uint8_t        mr_addr_id;
} __attribute__((__packed__));
struct mptcp_dss_copt {
	uint8_t        mdss_kind;
	uint8_t        mdss_len;
	uint8_t        mdss_reserved1:4,
	    mdss_subtype:4;
	uint8_t        mdss_flags;
}__attribute__((__packed__));
struct mptcp_dsn_opt {
	struct mptcp_dss_copt   mdss_copt;
	uint32_t       mdss_dsn;               
	uint32_t       mdss_subflow_seqn;      
	uint16_t       mdss_data_len;          
			
}__attribute__((__packed__));
struct mptcp_dsn64_opt {
	struct mptcp_dss_copt   mdss_copt;
	uint64_t       mdss_dsn;               
	uint32_t       mdss_subflow_seqn;      
	uint16_t       mdss_data_len;          
			
}__attribute__((__packed__));
struct mptcp_data_ack_opt {
	struct mptcp_dss_copt   mdss_copt;
	uint32_t               mdss_ack;
}__attribute__((__packed__));
struct mptcp_data_ack64_opt {
	struct mptcp_dss_copt   mdss_copt;
	uint64_t               mdss_ack;
}__attribute__((__packed__));
struct mptcp_dss_ack_opt {
	struct mptcp_dss_copt   mdss_copt;
	uint32_t       mdss_ack;               
	uint32_t       mdss_dsn;               
	uint32_t       mdss_subflow_seqn;      
	uint16_t       mdss_data_len;          
			
}__attribute__((__packed__));
struct mptcp_dss64_ack64_opt {
	struct mptcp_dss_copt   mdss_copt;
	uint64_t       mdss_ack;               
	uint64_t       mdss_dsn;               
	uint32_t       mdss_subflow_seqn;      
	uint16_t       mdss_data_len;          
			
}__attribute__((__packed__));
struct mptcp_dss32_ack64_opt {
	struct mptcp_dss_copt   mdss_copt;
	uint64_t       mdss_ack;               
	uint32_t       mdss_dsn;               
	uint32_t       mdss_subflow_seqn;      
	uint16_t       mdss_data_len;          
			
}__attribute__((__packed__));
struct mptcp_dss64_ack32_opt {
	struct mptcp_dss_copt   mdss_copt;
	uint32_t       mdss_ack;               
	uint64_t       mdss_dsn;               
	uint32_t       mdss_subflow_seqn;      
	uint16_t       mdss_data_len;          
			
}__attribute__((__packed__));
struct mptcp_fastclose_opt {
	uint8_t        mfast_kind;
	uint8_t        mfast_len;
	uint8_t        mfast_reserved:4,
	    mfast_subtype:4;
	uint8_t        mfast_reserved1;
	uint64_t       mfast_key;              
}__attribute__((__packed__));
struct mptcp_mpfail_opt {
	uint8_t        mfail_kind;
	uint8_t        mfail_len;
	uint8_t        mfail_reserved:4,
	    mfail_subtype:4;
	uint8_t        mfail_reserved1:8;
	uint64_t       mfail_dsn;
}__attribute__((__packed__));
struct mptcp_add_addr_opt {
	uint8_t         maddr_kind;
	uint8_t         maddr_len;
	uint8_t         maddr_flags:4,
	    maddr_subtype:4;
	uint8_t         maddr_addrid;
	union {
		struct {
			struct in_addr maddr_addrv4;
			uint32_t maddr_pad[3];
		};

		struct {
			struct in6_addr maddr_addrv6;
		};
	} maddr_u;
}__attribute__((__packed__));
struct mptcp_add_addr_hmac_msg_v4 {
	uint8_t         maddr_addrid;
	struct in_addr maddr_addr;
	uint16_t maddr_port;
}__attribute__((__packed__));
struct mptcp_add_addr_hmac_msg_v6 {
	uint8_t         maddr_addrid;
	struct in6_addr maddr_addr;
	uint16_t maddr_port;
}__attribute__((__packed__));
struct mptcp_mpprio_addr_opt {
	uint8_t        mpprio_kind;
	uint8_t        mpprio_len;
	uint8_t        mpprio_flags:4,
	    mpprio_subtype:4;
	uint8_t        mpprio_addrid;
}__attribute__((__packed__));
struct mpt_itf_info {
	uint32_t ifindex;
	uint32_t has_v4_conn:1,
	    has_v6_conn:1,
	    has_nat64_conn:1,
	    no_mptcp_support:1;
};
struct mptses {
	struct mppcb    *mpte_mppcb;            
	struct mptcb    *mpte_mptcb;            
	TAILQ_HEAD(, mptopt) mpte_sopts;        
	TAILQ_HEAD(, mptsub) mpte_subflows;     
	uint16_t        mpte_numflows;          
	uint16_t        mpte_nummpcapflows;     
	sae_associd_t   mpte_associd;           
	sae_connid_t    mpte_connid_last;       

	uint64_t        mpte_time_target;
	thread_call_t   mpte_time_thread;
	thread_call_t   mpte_stop_urgency;

	uint32_t        mpte_last_cellicon_set;
	uint32_t        mpte_cellicon_increments;

	union {
		
		struct sockaddr _mpte_src;
		struct sockaddr_in _mpte_src_v4;
		struct sockaddr_in6 _mpte_src_v6;
	} mpte_u_src;
	union {
		
		struct sockaddr _mpte_dst;
		struct sockaddr_in _mpte_dst_v4;
		struct sockaddr_in6 _mpte_dst_v6;
	} mpte_u_dst;

	struct sockaddr_in      mpte_sub_dst_v4;
	struct sockaddr_in6     mpte_sub_dst_v6;
	uint8_t         sub_dst_addr_id_v4;
	uint8_t         sub_dst_addr_id_v6;

	uint16_t        mpte_alternate_port;    

	int mpte_epid;
	uuid_t mpte_euuid;

	struct mptsub   *mpte_active_sub;       
	uint16_t mpte_flags;                    
	uint8_t mpte_svctype;                   
	uint8_t mpte_lost_aid;                  
	uint8_t mpte_addrid_last;               

	uint32_t        mpte_itfinfo_size;
	struct mpt_itf_info     _mpte_itfinfo[MPTE_ITFINFO_SIZE];
	struct mpt_itf_info     *mpte_itfinfo __counted_by(mpte_itfinfo_size);

	struct mbuf             *mpte_reinjectq;

	uint32_t        mpte_subflow_switches;  
	uint32_t        mpte_used_cell:1,
	    mpte_used_wifi:1,
	    mpte_initial_cell:1,
	    mpte_triggered_cell,
	    mpte_handshake_success:1,
	    mpte_last_added_addr_is_v4:1;

	struct mptcp_itf_stats  mpte_itfstats[MPTCP_ITFSTATS_SIZE];
	uint64_t                mpte_init_txbytes __attribute__((aligned(8)));
	uint64_t                mpte_init_rxbytes __attribute__((aligned(8)));
};
struct mptopt {
	TAILQ_ENTRY(mptopt)     mpo_entry;      
	uint32_t                mpo_flags;      
	int                     mpo_level;      
	int                     mpo_name;       
	int                     mpo_intval;     
};
struct mptsub {
	TAILQ_ENTRY(mptsub)   mpts_entry;     
	uint32_t              mpts_refcnt;    
	uint32_t              mpts_flags;     
	uint32_t              mpts_evctl;     
	sae_connid_t          mpts_connid;    
	int                   mpts_oldintval; 
	struct mptses         *mpts_mpte;     
	struct socket         *mpts_socket;   
	struct sockaddr       *mpts_src;      

	union {
		
		struct sockaddr         _mpts_dst;
		struct sockaddr_in      _mpts_dst_v4;
		struct sockaddr_in6     _mpts_dst_v6;
	} mpts_u_dst;
	u_int32_t               mpts_rel_seq;   
	u_int32_t               mpts_iss;       
	u_int32_t               mpts_ifscope;   
	uint32_t                mpts_probesoon; 
	uint32_t                mpts_probecnt;  
	uint32_t                mpts_maxseg;    
};
struct mptcp_subf_auth_entry {
	LIST_ENTRY(mptcp_subf_auth_entry) msae_next;
	u_int32_t       msae_laddr_rand;        
	u_int32_t       msae_raddr_rand;        
	mptcp_addr_id   msae_laddr_id;          
	mptcp_addr_id   msae_raddr_id;          
};
struct mptcb {
	struct mptses  *mpt_mpte;               
	mptcp_state_t   mpt_state;              
	uint32_t        mpt_flags;              
	uint8_t         mpt_version;            
	u_short         mpt_softerror;          
	mptcp_key_t     mpt_localkey;           
	mptcp_key_t     mpt_remotekey;          
	mptcp_token_t   mpt_localtoken;         
	mptcp_token_t   mpt_remotetoken;        

	int             mpt_rxtshift;           
	uint64_t        mpt_rxtstart;           
	uint64_t        mpt_rtseq;              
	uint64_t        mpt_timewait;           
	uint32_t        mpt_timer_vals;         
	uint64_t        mpt_snduna;             
	uint64_t        mpt_sndnxt;             
	uint64_t        mpt_sndmax;             
	uint64_t        mpt_local_idsn;         
	uint32_t        mpt_sndwnd;
	uint64_t        mpt_sndwl1;
	uint64_t        mpt_sndwl2;
	uint64_t        mpt_rcvnxt;             
	uint64_t        mpt_remote_idsn;        
	uint64_t        mpt_rcvadv;
	uint32_t        mpt_rcvwnd;
	LIST_HEAD(, mptcp_subf_auth_entry) mpt_subauth_list; 
	uint64_t        mpt_dsn_at_csum_fail;   
	uint32_t        mpt_ssn_at_csum_fail;   
	int32_t         mpt_gc_ticks;           

	uint32_t        mpt_notsent_lowat;      

	struct tsegqe_head      mpt_segq;
	uint32_t        mpt_reassqlen;          
};
struct mpp_mtp {
	struct mppcb            mpp;            
	struct mptses           mpp_ses;        
	struct mptcb            mtcb;           
};
struct mptcp_flow {
	uint64_t                flow_len;
	uint64_t                flow_tcpci_offset;
	uint32_t                flow_flags;
	sae_connid_t            flow_cid;
	struct sockaddr_storage flow_src;
	struct sockaddr_storage flow_dst;
	uint32_t                flow_relseq;    
	int32_t                 flow_soerror;   
	uint32_t                flow_probecnt;  
	conninfo_tcp_t          flow_ci;        
} mptcp_flow_t;
struct conninfo_mptcp {
	uint64_t        mptcpci_len;
	uint64_t        mptcpci_flow_offset;    
	uint64_t        mptcpci_nflows;         
	uint32_t        mptcpci_state;          
	uint32_t        mptcpci_mpte_flags;     
	uint32_t        mptcpci_flags;          
	uint32_t        mptcpci_ltoken;         
	uint32_t        mptcpci_rtoken;         
	uint32_t        mptcpci_notsent_lowat;  

	uint64_t        mptcpci_snduna;         
	uint64_t        mptcpci_sndnxt;         
	uint64_t        mptcpci_sndmax;         
	uint64_t        mptcpci_lidsn;          
	uint32_t        mptcpci_sndwnd;         

	uint64_t        mptcpci_rcvnxt;         
	uint64_t        mptcpci_rcvatmark;      
	uint64_t        mptcpci_ridsn;          
	uint32_t        mptcpci_rcvwnd;         

	uint8_t         mptcpci_mpte_addrid;    

	mptcp_flow_t    mptcpci_flows[1];
} conninfo_mptcp_t;
struct symptoms_advisory {
	union {
		uint32_t        sa_nwk_status_int;
		struct {
			union {
				uint16_t        sa_nwk_status;
				struct {
					uint8_t sa_wifi_status;
					uint8_t sa_cell_status;
				};
			};
			uint16_t        sa_unused;
		};
	};
} symptoms_advisory_t;
struct mptcp_symptoms_answer {
	struct symptoms_advisory advisory;
	uuid_t  uuid;
	int32_t rssi;
};
struct mptcp_symptoms_ask_uuid {
	uint32_t        cmd;
	uuid_t          uuid;
	uint32_t        priority;
};
struct kev_mptcp_data {
	int value;
};
struct mppcb {
	TAILQ_ENTRY(mppcb)      mpp_entry;      
	decl_lck_mtx_data(, mpp_lock);          
	struct mppcbinfo        *mpp_pcbinfo;   
	struct mptses           *mpp_pcbe;      
	struct socket           *mpp_socket;    
	uint32_t                mpp_flags;      
	mppcb_state_t           mpp_state;      
	int32_t                 mpp_inside;     

	uuid_t necp_client_uuid;
	struct inp_necp_attributes inp_necp_attributes;
	void (*necp_cb)(void *, int, uint32_t, uint32_t, bool *);
};
struct mppcbinfo {
	TAILQ_ENTRY(mppcbinfo)  mppi_entry;     
	TAILQ_HEAD(, mppcb)     mppi_pcbs;      
	uint32_t                mppi_count;     
	lck_attr_t              mppi_lock_attr; 
	struct mppcb         *(*mppi_alloc)(void);
	void                  (*mppi_free)(struct mppcb *);
	lck_grp_t              *mppi_lock_grp;  
	decl_lck_mtx_data(, mppi_lock);         
	uint32_t (*mppi_gc)(struct mppcbinfo *); 
	uint32_t (*mppi_timer)(struct mppcbinfo *); 
};
struct tcpiphdr {
	struct  ipovly ti_i;            
	struct  tcphdr ti_t;            
};
struct tcp_cc_debug_state {
	u_int64_t ccd_tsns;
	char ccd_srcaddr[INET6_ADDRSTRLEN];
	uint16_t ccd_srcport;
	char ccd_destaddr[INET6_ADDRSTRLEN];
	uint16_t ccd_destport;
	uint32_t ccd_snd_cwnd;
	uint32_t ccd_snd_wnd;
	uint32_t ccd_snd_ssthresh;
	uint32_t ccd_pipeack;
	uint32_t ccd_rttcur;
	uint32_t ccd_rxtcur;
	uint32_t ccd_srtt;
	uint32_t ccd_event;
	uint32_t ccd_sndcc;
	uint32_t ccd_sndhiwat;
	uint32_t ccd_bytes_acked;
	u_int8_t ccd_cc_index;
	u_int8_t ccd_unused_1__;
	u_int16_t ccd_unused_2__;
	union {
		struct {
			uint32_t ccd_last_max;
			uint32_t ccd_tcp_win;
			uint32_t ccd_target_win;
			uint32_t ccd_avg_lastmax;
			uint32_t ccd_mean_deviation;
		} cubic_state;
		struct {
			u_int32_t led_base_rtt;
		} ledbat_state;
	} u;
};
struct tcp_cc_algo {
	char name[TCP_CA_NAME_MAX];
	_Atomic uint32_t num_sockets;
	uint32_t flags;

	int (*init) (struct tcpcb *tp);

	int (*cleanup) (struct tcpcb *tp);

	void (*cwnd_init) (struct tcpcb *tp);

	void (*congestion_avd) (struct tcpcb *tp, struct tcphdr *th);

	void (*ack_rcvd) (struct tcpcb *tp, struct tcphdr *th);

	void (*pre_fr) (struct tcpcb *tp);

	void (*post_fr) (struct tcpcb *tp, struct tcphdr *th);

	void (*after_idle) (struct tcpcb *tp);

	void (*after_timeout) (struct tcpcb *tp);

	int (*delay_ack)(struct tcpcb *tp, struct tcphdr *th);

	void (*process_ecn) (struct tcpcb *tp, struct tcphdr *th, uint32_t new_bytes_marked, uint32_t packets_marked, uint32_t packets_acked);

	void (*set_bytes_acked) (struct tcpcb *tp, uint32_t acked);

	void (*switch_to)(struct tcpcb *tp);
} __attribute__((aligned(4)));
struct tcp_rcv_cc_algo {
	char name[TCP_CA_NAME_MAX];
	_Atomic uint32_t num_sockets;
	uint32_t flags;

	void (*init) (struct tcpcb *tp);

	void (*cleanup) (struct tcpcb *tp);

	void (*rwnd_init) (struct tcpcb *tp);

	void (*data_rcvd) (struct tcpcb *tp, struct tcphdr *th,
	    struct tcpopt *to, uint32_t segment_len);

	uint32_t (*get_rlwin) (struct tcpcb *tp);

	void (*after_idle) (struct tcpcb *tp);

	void (*switch_to) (struct tcpcb *tp);
} __attribute__((aligned(4)));
struct tcptimerentry {
	LIST_ENTRY(tcptimerentry) le;   
	uint32_t timer_start;   
	uint16_t index;         
	uint16_t mode;          
	uint32_t runtime;       
};
struct tcptimerlist {
	struct timerlisthead lhead;     
	lck_mtx_t mtx;          
	lck_grp_t *mtx_grp;     
	thread_call_t call;     
	uint32_t runtime;       
	uint32_t schedtime;     
	uint32_t entries;       
	uint32_t maxentries;    

	boolean_t running;      
	boolean_t scheduled;    
	uint32_t mode;          
	uint32_t pref_mode;     
	uint32_t pref_offset;   
	uint32_t idleruns;      
	struct tcptimerentry *next_te;  
	u_int16_t probe_if_index; 
};
struct tcp_globals {};
struct tseg_qent {
	LIST_ENTRY(tseg_qent) tqe_q;
	int     tqe_len;                
	struct  tcphdr *tqe_th;         
	struct  mbuf    *tqe_m;         
};
struct sackblk {
	tcp_seq start;          
	tcp_seq end;            
};
struct sackhole {
	tcp_seq start;          
	tcp_seq end;            
	tcp_seq rxmit;          
	u_int32_t rxmit_start;  
	TAILQ_ENTRY(sackhole) scblink;  
};
struct sackhint {
	struct sackhole *nexthole;
	int     sack_bytes_rexmit;
	int sack_bytes_acked;
};
struct tcp_rxt_seg {
	tcp_seq rx_start;
	tcp_seq rx_end;
	u_int16_t rx_count;
	u_int16_t rx_flags;
	SLIST_ENTRY(tcp_rxt_seg) rx_link;
};
struct tcp_seg_sent {
	tcp_seq start_seq;
	tcp_seq end_seq;        
	uint32_t xmit_ts;
	uint8_t flags;
	uint8_t pad[3];

	TAILQ_ENTRY(tcp_seg_sent) tx_link; 
	RB_ENTRY(tcp_seg_sent)    seg_link; 
	TAILQ_ENTRY(tcp_seg_sent) ack_link; 
	TAILQ_ENTRY(tcp_seg_sent) free_link; 
};
struct tcp_seg_pool {
	TAILQ_HEAD(, tcp_seg_sent) free_segs;
	uint32_t free_segs_count;
	char pad[4];
} *tcp_seg_pool_t;
struct tcp_notify_ack_marker {
	tcp_seq notify_snd_una; 
	tcp_notify_ack_id_t notify_id;
	SLIST_ENTRY(tcp_notify_ack_marker) notify_next;
};
struct tcptemp {
	u_char  tt_ipgen[40]; 
	struct  tcphdr tt_t;
};
struct bwmeas {
	tcp_seq bw_start;       
	uint32_t bw_ts;         
	uint32_t bw_size;       
	uint32_t bw_minsizepkts; 
	uint32_t bw_maxsizepkts; 
	uint32_t bw_minsize;    
	uint32_t bw_maxsize;    
	uint32_t bw_sndbw;      
	uint32_t bw_sndbw_max;  
	uint32_t bw_rcvbw_max;  
};
struct mpt_dsn_map {
	uint64_t                mpt_dsn;        
	uint32_t                mpt_sseq;       
	uint16_t                mpt_len;        
	uint16_t                mpt_csum;       
	uint8_t                 mpt_dfin;       
};
struct tcp_ccstate {
	union {
		struct tcp_cubic_state {
			u_int32_t tc_last_max;  
			u_int32_t tc_epoch_start; 
			u_int32_t tc_origin_point; 
			u_int32_t tc_tcp_win; 
			u_int32_t tc_tcp_bytes_acked; 
			u_int32_t tc_avg_lastmax; 
			u_int32_t tc_mean_deviation; 
			float     tc_epoch_period; 
		} _cubic_state_;
		struct tcp_prague_state {
			uint16_t num_cong_events_loss;
			uint16_t num_cong_events_ce;
			uint32_t packets_acked;   
			uint32_t packets_marked;  
			uint32_t ce_counter;      
			uint32_t bytes_acked;     
			uint32_t snd_nxt_alpha;   
			uint32_t snd_nxt_cwr;     
			uint8_t ever_saw_ce:1,       
			    in_loss:1,                       
			    reduced_due_to_ce:1,             
			    unused:5;
			uint8_t pad[3];
			uint64_t scaled_alpha;    
			uint64_t alpha_ai;        
			
			struct tcp_cubic_state cubic_state;
		} _prague_state_;
		struct tcp_ledbat_state {
			uint32_t num_slowdown_events;
			uint32_t slowdown_ts;
			uint32_t slowdown_begin;
			uint32_t md_bytes_acked;
		} _ledbat_state_;
	} __u__;
};
struct tcp_rledbat_state {
	uint32_t num_slowdown_events;  
	uint32_t slowdown_ts;          
	uint32_t slowdown_begin;       
	uint32_t reduction_end;        
	uint32_t rcvd_bytes;           
	uint32_t md_rcvd_bytes;        
	uint32_t win;                  
	uint32_t ssthresh;             
	uint32_t drained_bytes;        
	uint32_t win_ws;               
};
struct accecn {
	uint32_t        t_rcv_ce_packets;                  
	uint32_t        t_snd_ce_packets;                  
	uint32_t        t_delta_ce_packets;                
	uint8_t         accecn_processed:1,                
	    unused:7;

	uint64_t        t_rcv_ect1_bytes;                  
	uint64_t        t_rcv_ect0_bytes;                  
	uint64_t        t_rcv_ce_bytes;                    
	uint64_t        t_snd_ect1_bytes;                  
	uint64_t        t_snd_ect0_bytes;                  
	uint64_t        t_snd_ce_bytes;                    
};
struct pacer {
	uint64_t rate;
	uint32_t tso_burst_size; 
	uint32_t current_size; 
	uint64_t packet_tx_time;
};
struct tcpcb {
	struct tsegqe_head t_segq;
	uint32_t t_dupacks;             
	int      t_state;               
	uint32_t t_timer[TCPT_NTIMERS]; 
	struct tcptimerentry tentry;    

	struct  inpcb *t_inpcb;         
	uint32_t        t_flags;

	tcp_seq snd_una;                
	tcp_seq snd_max;                
	tcp_seq snd_nxt;                
	tcp_seq snd_up;                 

	tcp_seq snd_wl1;                
	tcp_seq snd_wl2;                
	tcp_seq iss;                    
	tcp_seq irs;                    

	tcp_seq rcv_nxt;                
	tcp_seq rcv_adv;                
	uint32_t        rcv_wnd;        
	uint32_t        t_last_recwin;
	tcp_seq rcv_up;                 

	uint32_t        snd_wnd;        
	uint32_t        snd_cwnd;       
	uint32_t        snd_ssthresh;   
	tcp_seq snd_recover;            

	uint32_t        t_maxopd;       
	uint32_t        t_rcvtime;      
	uint32_t        t_sndtime;      
	uint32_t        t_starttime;    
	int     t_rtttime;              
	tcp_seq t_rtseq;                

	uint32_t rfbuf_ts;              
	uint32_t rfbuf_cnt;             
	uint32_t rfbuf_space;           

	int            t_rxtcur;        
	unsigned int   t_maxseg;        
	int            t_srtt;          
	int            t_rttvar;        

	uint64_t t_accsleep_ms;         
	uint32_t t_reassqlen;           
	uint32_t t_reassq_mbcnt;        
	uint16_t t_rxtshift;            
	uint32_t t_rttmin;              
	uint32_t t_rttbest;             
	uint32_t t_rttcur;              
	uint32_t t_rttupdated;          
	uint32_t t_rxt_conndroptime;    
	uint32_t t_rxtstart;            
	uint32_t max_sndwnd;            

	int     t_softerror;            

	char    t_oobflags;             
	char    t_iobc;                 

	u_int8_t        snd_scale;      
	u_int8_t        rcv_scale;      
	u_int8_t        request_r_scale; 
	u_int8_t        requested_s_scale;
	u_int8_t        tcp_cc_index;   
	u_int8_t        t_adaptive_rtimo;       
	u_int8_t        t_adaptive_wtimo;       
	u_int8_t        t_stretchack_delayed;   


	u_int16_t       t_early_rexmt_count; 
	u_int32_t       t_early_rexmt_win; 

	u_int32_t       ts_recent;      

	u_int32_t       ts_recent_age;  
	tcp_seq last_ack_sent;

	uint32_t        t_bytes_acked;  
	uint32_t        total_ect_packets_marked; 
	uint32_t        total_ect_packets_acked;  

	int             t_lastchain;    
	uint16_t        t_unacksegs;    
	uint16_t        t_unacksegs_ce; 

	uint16_t        t_forced_acks;  
	uint8_t         t_rexmtthresh;  
	uint8_t         t_rtimo_probes; 
	uint32_t        t_persist_timeout; 
	uint32_t        t_persist_stop;    
	uint32_t        t_notsent_lowat;   


	u_int32_t       rcv_unackwin;   
	u_int32_t       rcv_by_unackwin; 
	u_int32_t       rcv_by_unackhalfwin;
	u_int32_t       rcv_nostrack_ts; 
	u_int32_t       rcv_nostrack_pkts; 
	u_int16_t       rcv_waitforss;  


	u_int32_t       ecn_flags;

	u_int32_t       t_ecn_recv_ce;  
	u_int32_t       t_ecn_recv_cwr; 
	uint32_t        t_client_accecn_state;    
	uint32_t        t_server_accecn_state;    
	uint64_t        t_ecn_capable_packets_sent;     
	uint64_t        t_ecn_capable_packets_acked;    
	uint64_t        t_ecn_capable_packets_marked;   
	uint64_t        t_ecn_capable_packets_lost;     

	uint32_t        t_last_ack_tsecr;       
	uint16_t        t_prev_ace_flags;   
	uint8_t         t_prev_ip_ecn;      

	struct accecn   t_aecn;         

	struct pacer    t_pacer;        


	u_int32_t       snd_cwnd_prev;  
	u_int32_t       snd_ssthresh_prev; 
	tcp_seq snd_recover_prev;       
	int     t_srtt_prev;            
	int     t_rttvar_prev;          
	u_int32_t       t_badrexmt_time; 


	u_int32_t       t_reorderwin; 


	int16_t snd_numholes;           
	TAILQ_HEAD(sackhole_head, sackhole) snd_holes;
	tcp_seq snd_fack;               
	int     rcv_numsacks;           
	struct sackblk sackblks[MAX_SACK_BLKS]; 
	struct sackhint sackhint;       

	struct mbuf     *t_pktlist_head; 
	struct mbuf     *t_pktlist_tail; 
	u_int32_t       t_pktlist_sentlen; 

	u_int32_t       t_keepidle;     
	u_int32_t       t_keepinit;     
	u_int32_t       t_keepintvl;    
	u_int32_t       t_keepcnt;      

	u_int32_t       tso_max_segment_size;   
	u_int16_t       t_pmtud_lastseg_size;   
	u_int32_t       t_pmtud_saved_maxopd;   
	u_int32_t       t_pmtud_start_ts;       

	struct{
		u_int32_t       rxduplicatebytes;
		u_int32_t       rxoutoforderbytes;
		u_int32_t       txretransmitbytes;
		u_int16_t       synrxtshift;
		u_int16_t       rxmitsyns;
		u_int16_t       unused_pad_to_8;
		u_int32_t       rxmitpkts;
		uint32_t        delayed_acks_sent;
		uint32_t        acks_delayed;
	} t_stat;
	u_int8_t        t_syn_sent;
	u_int8_t        t_syn_rcvd;
	u_int8_t        t_notify_ack_count;
	u_int8_t        t_ecn_recv_ce_pkt; 
	u_int32_t       t_cached_maxopd; 

	uint32_t        bg_ssthresh;            
	uint32_t        t_flagsext;             

	struct bwmeas   *t_bwmeas;              
	tcp_seq         t_idleat;               
	uint8_t         t_fin_sent;
	uint8_t         t_fin_rcvd;
	uint8_t         t_rst_sent;
	uint8_t         t_rst_rcvd;
	TAILQ_ENTRY(tcpcb) t_twentry;           
	struct tcp_ccstate      *t_ccstate;     
	struct tcp_ccstate      _t_ccstate;     

	tcp_seq         t_tlphighrxt;           
	tcp_seq         t_tlphightrxt_persist;  
	uint32_t        t_tlpstart;             

	tcp_seq         t_dsack_lseq;           
	tcp_seq         t_dsack_rseq;           

	SLIST_HEAD(tcp_rxt_seghead, tcp_rxt_seg) t_rxt_segments;
	uint32_t        t_rxt_seg_count;
	uint32_t        t_rxt_seg_drop;
	tcp_seq         t_dsack_lastuna;        

	u_int32_t       t_pipeack_sample[TCP_PIPEACK_SAMPLE_COUNT];     
	tcp_seq         t_pipeack_lastuna; 
	u_int32_t       t_pipeack;
	u_int32_t       t_lossflightsize;


	u_int8_t                t_tfo_flags;
	u_int16_t               t_tfo_stats;

	u_int8_t                t_tfo_probes; 

	u_int8_t                t_tfo_probe_state;

	u_int32_t       t_rcvoopack;            
	u_int32_t       t_pawsdrop;             
	u_int32_t       t_sack_recovery_episode; 
	uint32_t        t_rack_recovery_episode; 
	uint32_t        t_rack_reo_timeout_recovery_episode; 
	u_int32_t       t_reordered_pkts;       
	u_int32_t       t_dsack_sent;           
	u_int32_t       t_dsack_recvd;          
	SLIST_HEAD(, tcp_notify_ack_marker) t_notify_ack; 
	u_int32_t       t_recv_throttle_ts;     
	u_int32_t       t_rxt_minimum_timeout;  
	uint32_t        t_challengeack_last;    
	uint32_t        t_challengeack_count;   

	u_int32_t       t_connect_time;         

	uint64_t        t_rcvwnd_limited_total_time;
	uint64_t        t_rcvwnd_limited_start_time;


	uint32_t        t_comp_rxmt_gencnt; 

	uint32_t        t_comp_ack_gencnt; 
	uint32_t        t_comp_ack_lastinc; 

	uint32_t        t_ts_offset; 

	uint32_t curr_rtt_hist[NCURR_RTT_HIST];  
	uint32_t curr_rtt_min;                   
	uint32_t curr_rtt_index;                 

	tcp_seq rcv_high;                   
	uint32_t tsv_high;                  
	struct tcp_rledbat_state t_rlstate; 

	uint32_t rcv_srtt;                  
	uint32_t rcv_rtt_est_ts;            
	uint32_t rcv_rtt_est_seq;           

	TAILQ_HEAD(tcp_seg_sent_head, tcp_seg_sent) t_segs_sent; 
	struct tcp_seg_sent_tree_head t_segs_sent_tree; 
	TAILQ_HEAD(tcp_seg_acked_head, tcp_seg_sent) t_segs_acked; 
	struct tcp_seg_pool seg_pool;

# define TCP_RACK_RECOVERY_PERSIST_MAX (16)
	struct tcp_rack {
		uint32_t        xmit_ts;
		uint32_t        end_seq;
		uint32_t        rtt; 
		tcp_seq         dsack_round_end;
		uint32_t        reo_wnd;
		uint8_t         reo_wnd_multi;
		uint8_t         reo_wnd_persist:5,
		    advanced:1,
		    dsack_round_seen:1,
		    segs_retransmitted:1;
	} rack;

	uint32_t bytes_lost;
	uint32_t bytes_retransmitted;
	uint32_t bytes_sacked;

	uuid_t          t_fsw_uuid;
	uuid_t          t_flow_uuid;
};
struct tcpopt {
	uint32_t        to_flags;   
	uint32_t        to_tsval;
	uint32_t        to_tsecr;
	uint16_t        to_mss;
	uint8_t         to_requested_s_scale;
	uint8_t         to_nsacks;                                                              
	u_char          *to_sacks __sized_by(to_sacks_size);        
	uint32_t                to_sacks_size;                                                          
	u_char          *to_tfo  __sized_by(to_tfo_size);                       
	uint32_t                to_tfo_size;                                                            
	uint8_t         to_num_accecn;                                                          
	uint8_t         *to_accecn __sized_by(to_accecn_size);      
	uint32_t                to_accecn_size;                                                         
	uint8_t         to_accecn_order;                                                        
};
struct otcpcb {
	u_int32_t t_segq;
	int     t_dupacks;              
	u_int32_t unused;               

	int     t_timer[TCPT_NTIMERS_EXT];      

	_TCPCB_PTR(struct inpcb *) t_inpcb;     
	int     t_state;                
	u_int   t_flags;

	int     t_force;                

	tcp_seq snd_una;                
	tcp_seq snd_max;                
	tcp_seq snd_nxt;                
	tcp_seq snd_up;                 

	tcp_seq snd_wl1;                
	tcp_seq snd_wl2;                
	tcp_seq iss;                    
	tcp_seq irs;                    

	tcp_seq rcv_nxt;                
	tcp_seq rcv_adv;                
	u_int32_t rcv_wnd;              
	tcp_seq rcv_up;                 

	u_int32_t snd_wnd;              
	u_int32_t snd_cwnd;             
	u_int32_t snd_ssthresh;         
	u_int   t_maxopd;               

	u_int32_t t_rcvtime;            
	u_int32_t t_starttime;          
	int     t_rtttime;              
	tcp_seq t_rtseq;                

	int     t_rxtcur;               
	u_int   t_maxseg;               
	int     t_srtt;                 
	int     t_rttvar;               

	int     t_rxtshift;             
	u_int   t_rttmin;               
	u_int32_t t_rttupdated;         
	u_int32_t max_sndwnd;           

	int     t_softerror;            

	char    t_oobflags;             
	char    t_iobc;                 

	u_char  snd_scale;              
	u_char  rcv_scale;              
	u_char  request_r_scale;        
	u_char  requested_s_scale;
	u_int32_t ts_recent;            

	u_int32_t ts_recent_age;        
	tcp_seq last_ack_sent;

	tcp_cc  cc_send;                
	tcp_cc  cc_recv;                
	tcp_seq snd_recover;            

	u_int32_t snd_cwnd_prev;        
	u_int32_t snd_ssthresh_prev;    
	u_int32_t t_badrxtwin;          
};
struct  tcpstat {
	u_int32_t       tcps_connattempt;       
	u_int32_t       tcps_accepts;           
	u_int32_t       tcps_connects;          
	u_int32_t       tcps_drops;             
	u_int32_t       tcps_conndrops;         
	u_int32_t       tcps_closed;            
	u_int32_t       tcps_segstimed;         
	u_int32_t       tcps_rttupdated;        
	u_int32_t       tcps_delack;            
	u_int32_t       tcps_timeoutdrop;       
	u_int32_t       tcps_rexmttimeo;        
	u_int32_t       tcps_persisttimeo;      
	u_int32_t       tcps_keeptimeo;         
	u_int32_t       tcps_keepprobe;         
	u_int32_t       tcps_keepdrops;         

	u_int32_t       tcps_sndtotal;          
	u_int32_t       tcps_sndpack;           
	u_int32_t       tcps_sndbyte;           
	u_int32_t       tcps_sndrexmitpack;     
	u_int32_t       tcps_sndrexmitbyte;     
	u_int32_t       tcps_sndacks;           
	u_int32_t       tcps_sndprobe;          
	u_int32_t       tcps_sndurg;            
	u_int32_t       tcps_sndwinup;          
	u_int32_t       tcps_sndctrl;           

	u_int32_t       tcps_rcvtotal;          
	u_int32_t       tcps_rcvpack;           
	u_int32_t       tcps_rcvbyte;           
	u_int32_t       tcps_rcvbadsum;         
	u_int32_t       tcps_rcvbadoff;         
	u_int32_t       tcps_rcvmemdrop;        
	u_int32_t       tcps_rcvshort;          
	u_int32_t       tcps_rcvduppack;        
	u_int32_t       tcps_rcvdupbyte;        
	u_int32_t       tcps_rcvpartduppack;    
	u_int32_t       tcps_rcvpartdupbyte;    
	u_int32_t       tcps_rcvoopack;         
	u_int32_t       tcps_rcvoobyte;         
	u_int32_t       tcps_rcvpackafterwin;   
	u_int32_t       tcps_rcvbyteafterwin;   
	u_int32_t       tcps_rcvafterclose;     
	u_int32_t       tcps_rcvwinprobe;       
	u_int32_t       tcps_rcvdupack;         
	u_int32_t       tcps_rcvacktoomuch;     
	u_int32_t       tcps_rcvackpack;        
	u_int32_t       tcps_rcvackbyte;        
	u_int32_t       tcps_rcvwinupd;         
	u_int32_t       tcps_pawsdrop;          
	u_int32_t       tcps_predack;           
	u_int32_t       tcps_preddat;           
	u_int32_t       tcps_pcbcachemiss;
	u_int32_t       tcps_cachedrtt;         
	u_int32_t       tcps_cachedrttvar;      
	u_int32_t       tcps_cachedssthresh;    
	u_int32_t       tcps_usedrtt;           
	u_int32_t       tcps_usedrttvar;        
	u_int32_t       tcps_usedssthresh;      
	u_int32_t       tcps_persistdrop;       
	u_int32_t       tcps_badsyn;            
	u_int32_t       tcps_mturesent;         
	u_int32_t       tcps_listendrop;        
	u_int32_t       tcps_synchallenge;      
	u_int32_t       tcps_rstchallenge;      

	u_int32_t       tcps_minmssdrops;       

	u_int32_t       tcps_sndrexmitbad;      
	u_int32_t       tcps_badrst;            

	u_int32_t       tcps_sc_added;          
	u_int32_t       tcps_sc_retransmitted;  
	u_int32_t       tcps_sc_dupsyn;         
	u_int32_t       tcps_sc_dropped;        
	u_int32_t       tcps_sc_completed;      
	u_int32_t       tcps_sc_bucketoverflow; 
	u_int32_t       tcps_sc_cacheoverflow;  
	u_int32_t       tcps_sc_reset;          
	u_int32_t       tcps_sc_stale;          
	u_int32_t       tcps_sc_aborted;        
	u_int32_t       tcps_sc_badack;         
	u_int32_t       tcps_sc_unreach;        
	u_int32_t       tcps_sc_zonefail;       
	u_int32_t       tcps_sc_sendcookie;     
	u_int32_t       tcps_sc_recvcookie;     

	u_int32_t       tcps_hc_added;          
	u_int32_t       tcps_hc_bucketoverflow; 

	u_int32_t       tcps_sack_recovery_episode; 
	u_int32_t       tcps_sack_rexmits;          
	u_int32_t       tcps_sack_rexmit_bytes;     
	u_int32_t       tcps_sack_rcv_blocks;       
	u_int32_t       tcps_sack_send_blocks;      
	u_int32_t       tcps_sack_sboverflow;       

	u_int32_t       tcps_rack_recovery_episode; 
	u_int32_t       tcps_rack_reordering_timeout_recovery_episode; 
	u_int32_t       tcps_rack_rexmits;          

	u_int32_t       tcps_bg_rcvtotal;       
	u_int32_t       tcps_rxtfindrop;        
	u_int32_t       tcps_fcholdpacket;      

	u_int32_t       tcps_limited_txt;       
	u_int32_t       tcps_early_rexmt;       
	u_int32_t       tcps_sack_ackadv;       

	u_int32_t       tcps_rcv_swcsum;        
	u_int32_t       tcps_rcv_swcsum_bytes;  
	u_int32_t       tcps_rcv6_swcsum;       
	u_int32_t       tcps_rcv6_swcsum_bytes; 
	u_int32_t       tcps_snd_swcsum;        
	u_int32_t       tcps_snd_swcsum_bytes;  
	u_int32_t       tcps_snd6_swcsum;       
	u_int32_t       tcps_snd6_swcsum_bytes; 
	u_int32_t       tcps_unused_1;
	u_int32_t       tcps_unused_2;
	u_int32_t       tcps_unused_3;

	u_int32_t       tcps_invalid_mpcap;     
	u_int32_t       tcps_invalid_joins;     
	u_int32_t       tcps_mpcap_fallback;    
	u_int32_t       tcps_join_fallback;     
	u_int32_t       tcps_estab_fallback;    
	u_int32_t       tcps_invalid_opt;       
	u_int32_t       tcps_mp_outofwin;       
	u_int32_t       tcps_mp_reducedwin;     
	u_int32_t       tcps_mp_badcsum;        
	u_int32_t       tcps_mp_oodata;         
	u_int32_t       tcps_mp_switches;       
	u_int32_t       tcps_mp_rcvtotal;       
	u_int32_t       tcps_mp_rcvbytes;       
	u_int32_t       tcps_mp_sndpacks;       
	u_int32_t       tcps_mp_sndbytes;       
	u_int32_t       tcps_join_rxmts;        
	u_int32_t       tcps_tailloss_rto;      
	u_int32_t       tcps_reordered_pkts;    
	u_int32_t       tcps_recovered_pkts;    
	u_int32_t       tcps_pto;               
	u_int32_t       tcps_rto_after_pto;     
	u_int32_t       tcps_tlp_recovery;      
	u_int32_t       tcps_tlp_recoverlastpkt; 
	u_int32_t       tcps_ecn_client_success; 
	u_int32_t       tcps_ecn_recv_ece;      
	u_int32_t       tcps_ecn_sent_ece;      
	u_int32_t       tcps_detect_reordering; 
	u_int32_t       tcps_delay_recovery;    
	u_int32_t       tcps_avoid_rxmt;        
	u_int32_t       tcps_unnecessary_rxmt;  
	u_int32_t       tcps_nostretchack;      
	u_int32_t       tcps_rescue_rxmt;       
	u_int32_t       tcps_pto_in_recovery;   
	u_int32_t       tcps_pmtudbh_reverted;  

	u_int32_t       tcps_dsack_disable;     
	u_int32_t       tcps_dsack_ackloss;     
	u_int32_t       tcps_dsack_badrexmt;    
	u_int32_t       tcps_dsack_sent;        
	u_int32_t       tcps_dsack_recvd;       
	u_int32_t       tcps_dsack_recvd_old;   

	u_int32_t       tcps_mp_sel_symtomsd;   
	u_int32_t       tcps_mp_sel_rtt;        
	u_int32_t       tcps_mp_sel_rto;        
	u_int32_t       tcps_mp_sel_peer;       
	u_int32_t       tcps_mp_num_probes;     
	u_int32_t       tcps_mp_verdowngrade;   
	u_int32_t       tcps_drop_after_sleep;  
	u_int32_t       tcps_probe_if;          
	u_int32_t       tcps_probe_if_conflict; 

	u_int32_t       tcps_ecn_client_setup;    
	u_int32_t       tcps_ecn_server_setup;    
	u_int32_t       tcps_ecn_server_success;  
	u_int32_t       tcps_ecn_ace_syn_not_ect; 
	u_int32_t       tcps_ecn_ace_syn_ect1;    
	u_int32_t       tcps_ecn_ace_syn_ect0;    
	u_int32_t       tcps_ecn_ace_syn_ce;      
	u_int32_t       tcps_ecn_lost_synack;   
	u_int32_t       tcps_ecn_lost_syn;      
	u_int32_t       tcps_ecn_not_supported; 
	u_int32_t       tcps_ecn_recv_ce;       
	u_int32_t       tcps_ecn_ace_recv_ce;   
	u_int32_t       tcps_ecn_conn_recv_ce;  
	u_int32_t       tcps_ecn_conn_recv_ece; 
	u_int32_t       tcps_ecn_conn_plnoce;   
	u_int32_t       tcps_ecn_conn_pl_ce;    
	u_int32_t       tcps_ecn_conn_nopl_ce;  
	u_int32_t       tcps_ecn_fallback_synloss; 
	u_int32_t       tcps_ecn_fallback_reorder; 
	u_int32_t       tcps_ecn_fallback_ce;   

	u_int32_t       tcps_tfo_syn_data_rcv;  
	u_int32_t       tcps_tfo_cookie_req_rcv;
	u_int32_t       tcps_tfo_cookie_sent;   
	u_int32_t       tcps_tfo_cookie_invalid;
	u_int32_t       tcps_tfo_cookie_req;    
	u_int32_t       tcps_tfo_cookie_rcv;    
	u_int32_t       tcps_tfo_syn_data_sent; 
	u_int32_t       tcps_tfo_syn_data_acked;
	u_int32_t       tcps_tfo_syn_loss;      
	u_int32_t       tcps_tfo_blackhole;     
	u_int32_t       tcps_tfo_cookie_wrong;  
	u_int32_t       tcps_tfo_no_cookie_rcv; 
	u_int32_t       tcps_tfo_heuristics_disable; 
	u_int32_t       tcps_tfo_sndblackhole;  
	u_int32_t       tcps_mss_to_default;    
	u_int32_t       tcps_mss_to_medium;     
	u_int32_t       tcps_mss_to_low;        
	u_int32_t       tcps_ecn_fallback_droprst; 
	u_int32_t       tcps_ecn_fallback_droprxmt; 
	u_int32_t       tcps_ecn_fallback_synrst; 

	u_int32_t       tcps_mptcp_rcvmemdrop;  
	u_int32_t       tcps_mptcp_rcvduppack;  
	u_int32_t       tcps_mptcp_rcvpackafterwin; 

	u_int32_t       tcps_timer_drift_le_1_ms;       
	u_int32_t       tcps_timer_drift_le_10_ms;      
	u_int32_t       tcps_timer_drift_le_20_ms;      
	u_int32_t       tcps_timer_drift_le_50_ms;      
	u_int32_t       tcps_timer_drift_le_100_ms;     
	u_int32_t       tcps_timer_drift_le_200_ms;     
	u_int32_t       tcps_timer_drift_le_500_ms;     
	u_int32_t       tcps_timer_drift_le_1000_ms;    
	u_int32_t       tcps_timer_drift_gt_1000_ms;    

	u_int32_t       tcps_mptcp_handover_attempt;    
	u_int32_t       tcps_mptcp_interactive_attempt; 
	u_int32_t       tcps_mptcp_aggregate_attempt;   
	u_int32_t       tcps_mptcp_fp_handover_attempt; 
	u_int32_t       tcps_mptcp_fp_interactive_attempt;
	u_int32_t       tcps_mptcp_fp_aggregate_attempt;
	u_int32_t       tcps_mptcp_heuristic_fallback;  
	u_int32_t       tcps_mptcp_fp_heuristic_fallback;       
	u_int32_t       tcps_mptcp_handover_success_wifi;       
	u_int32_t       tcps_mptcp_handover_success_cell;       
	u_int32_t       tcps_mptcp_interactive_success;         
	u_int32_t       tcps_mptcp_aggregate_success;           
	u_int32_t       tcps_mptcp_fp_handover_success_wifi;    
	u_int32_t       tcps_mptcp_fp_handover_success_cell;
	u_int32_t       tcps_mptcp_fp_interactive_success;
	u_int32_t       tcps_mptcp_fp_aggregate_success;
	u_int32_t       tcps_mptcp_handover_cell_from_wifi;     
	u_int32_t       tcps_mptcp_handover_wifi_from_cell;     
	u_int32_t       tcps_mptcp_interactive_cell_from_wifi;  
	u_int64_t       tcps_mptcp_handover_cell_bytes;         
	u_int64_t       tcps_mptcp_interactive_cell_bytes;      
	u_int64_t       tcps_mptcp_aggregate_cell_bytes;
	u_int64_t       tcps_mptcp_handover_all_bytes;          
	u_int64_t       tcps_mptcp_interactive_all_bytes;
	u_int64_t       tcps_mptcp_aggregate_all_bytes;
	u_int32_t       tcps_mptcp_back_to_wifi;        
	u_int32_t       tcps_mptcp_wifi_proxy;          
	u_int32_t       tcps_mptcp_cell_proxy;          

	u_int32_t       tcps_ka_offload_drops;  

	u_int32_t       tcps_mptcp_triggered_cell;      

	u_int32_t       tcps_fin_timeout_drops;
};
struct tcpstat_local {
	u_int64_t badformat;
	u_int64_t unspecv6;
	u_int64_t synfin;
	u_int64_t badformatipsec;
	u_int64_t noconnnolist;
	u_int64_t noconnlist;
	u_int64_t listbadsyn;
	u_int64_t icmp6unreach;
	u_int64_t deprecate6;
	u_int64_t ooopacket;
	u_int64_t rstinsynrcv;
	u_int64_t dospacket;
	u_int64_t cleanup;
	u_int64_t synwindow;
	u_int64_t linkheur_stealthdrop;
	u_int64_t linkheur_noackpri;
	u_int64_t linkheur_comprxmt;
	u_int64_t linkheur_synrxmt;
	u_int64_t linkheur_rxmtfloor;
};
struct  xtcpcb {
	u_int32_t       xt_len;
	struct  inpcb_compat    xt_inp;
	struct  otcpcb  xt_tp;
	struct  xsocket xt_socket;
	u_quad_t        xt_alignment_hack;
};
struct  xtcpcb_n {
	u_int32_t               xt_len;
	u_int32_t                       xt_kind;                

	u_int64_t t_segq;
	int     t_dupacks;              

	int t_timer[TCPT_NTIMERS_EXT];  

	int     t_state;                
	u_int   t_flags;

	int     t_force;                

	tcp_seq snd_una;                
	tcp_seq snd_max;                
	tcp_seq snd_nxt;                
	tcp_seq snd_up;                 

	tcp_seq snd_wl1;                
	tcp_seq snd_wl2;                
	tcp_seq iss;                    
	tcp_seq irs;                    

	tcp_seq rcv_nxt;                
	tcp_seq rcv_adv;                
	u_int32_t rcv_wnd;              
	tcp_seq rcv_up;                 

	u_int32_t snd_wnd;              
	u_int32_t snd_cwnd;             
	u_int32_t snd_ssthresh;         
	u_int   t_maxopd;               

	u_int32_t t_rcvtime;            
	u_int32_t t_starttime;          
	int     t_rtttime;              
	tcp_seq t_rtseq;                

	int     t_rxtcur;               
	u_int   t_maxseg;               
	int     t_srtt;                 
	int     t_rttvar;               

	int     t_rxtshift;             
	u_int   t_rttmin;               
	u_int32_t t_rttupdated;         
	u_int32_t max_sndwnd;           

	int     t_softerror;            
	char    t_oobflags;             
	char    t_iobc;                 
	u_char  snd_scale;              
	u_char  rcv_scale;              
	u_char  request_r_scale;        
	u_char  requested_s_scale;
	u_int32_t ts_recent;            

	u_int32_t ts_recent_age;        
	tcp_seq last_ack_sent;
	tcp_cc  cc_send;                
	tcp_cc  cc_recv;                
	tcp_seq snd_recover;            
	u_int32_t snd_cwnd_prev;        
	u_int32_t snd_ssthresh_prev;    
};
struct tcpprobereq {
	u_int64_t       ifindex;                
	u_int64_t       enable;                 
	u_int64_t       filter_flags;           
	u_int32_t       reserved;               
	u_int32_t       reserved2;              
};
struct tcp_respond_args {
	unsigned int ifscope;
	unsigned int nocell:1,
	    noexpensive:1,
	    awdl_unrestricted:1,
	    intcoproc_allowed:1,
	    keep_alive:1,
	    noconstrained:1,
	    management_allowed:1,
	    ultra_constrained_allowed:1;
};
struct udphdr {
	u_short uh_sport;               
	u_short uh_dport;               
	u_short uh_ulen;                
	u_short uh_sum;                 
};
struct udp_keepalive_offload {
	u_char ka_data[UDP_KEEPALIVE_OFFLOAD_DATA_SIZE];
	u_int16_t ka_interval;          
	u_int8_t ka_data_len;           
	u_int8_t ka_type;               
};
struct  udpiphdr {
	struct  ipovly ui_i;            
	struct  udphdr ui_u;            
};
struct  udpstat {
	u_int32_t udps_ipackets;        
	u_int32_t udps_hdrops;          
	u_int32_t udps_badsum;          
	u_int32_t udps_badlen;          
	u_int32_t udps_noport;          
	u_int32_t udps_noportbcast;     
	u_int32_t udps_fullsock;        
	u_int32_t udpps_pcbcachemiss;   
	u_int32_t udpps_pcbhashmiss;    
	u_int32_t udps_opackets;        
	u_int32_t udps_fastout;         
	u_int32_t udps_nosum;           
	u_int32_t udps_noportmcast;     
	u_int32_t udps_filtermcast;     
	u_int32_t udps_rcv_swcsum;        
	u_int32_t udps_rcv_swcsum_bytes;  
	u_int32_t udps_rcv6_swcsum;       
	u_int32_t udps_rcv6_swcsum_bytes; 
	u_int32_t udps_snd_swcsum;        
	u_int32_t udps_snd_swcsum_bytes;  
	u_int32_t udps_snd6_swcsum;       
	u_int32_t udps_snd6_swcsum_bytes; 
};
struct udpstat_local {
	u_int64_t       port_unreach;
	u_int64_t       faithprefix;    
	u_int64_t       port0;
	u_int64_t       badlength;
	u_int64_t       badchksum;
	u_int64_t       badmcast;
	u_int64_t       cleanup;
	u_int64_t       badipsec;
	u_int64_t       linkheur_stealthdrop;
};
struct ah {
	u_int8_t        ah_nxt;         
	u_int8_t        ah_len;         
	u_int16_t       ah_reserve;     
	u_int32_t       ah_spi;         
		
};
struct newah {
	u_int8_t        ah_nxt;         
	u_int8_t        ah_len;         
	u_int16_t       ah_reserve;     
	u_int32_t       ah_spi;         
	u_int32_t       ah_seq;         
		
};
struct ah_algorithm_state {
	const struct ccdigest_info *digest;
	cchmac_ctx_decl(CCSHA512_STATE_SIZE, CCSHA512_BLOCK_SIZE, hmac_ctx);
};
struct ah_algorithm {
	int (*sumsiz)(struct secasvar *);
	int (*mature)(struct secasvar *);
	u_int16_t keymin;     
	u_int16_t keymax;     
	const char *name;
	int (*init)(struct ah_algorithm_state *, struct secasvar *);
	void (*update)(struct ah_algorithm_state *, caddr_t, size_t);
	void (*result)(struct ah_algorithm_state *, caddr_t, size_t);
	const struct ccdigest_info *(*digest)(void);
	size_t (*schedlen)(const struct ah_algorithm *);
	int (*schedule)(const struct ah_algorithm *, struct secasvar *);
};
struct esp {
	u_int32_t       esp_spi;        
		
			
			
				
				
				
		
};
struct newesp {
	u_int32_t       esp_spi;        
	u_int32_t       esp_seq;        
			
			
				
				
				
		
};
struct esptail {
	u_int8_t        esp_padlen;     
	u_int8_t        esp_nxt;        
		
};
struct esp_algorithm {
	uint32_t padbound;        
	int ivlenval;           
	int (*mature)(struct secasvar *);
	u_int16_t keymin;     
	u_int16_t keymax;     
	size_t (*schedlen)(const struct esp_algorithm *);
	const char *name;
	int (*ivlen)(const struct esp_algorithm *, struct secasvar *);
	int (*decrypt)(struct mbuf *, size_t,
	    struct secasvar *, const struct esp_algorithm *, int);
	int (*encrypt)(struct mbuf *, size_t, size_t,
	    struct secasvar *, const struct esp_algorithm *, int);
	int (*schedule)(const struct esp_algorithm *, struct secasvar *);
	int (*blockdecrypt)(const struct esp_algorithm *,
	    struct secasvar *, u_int8_t *, u_int8_t *);
	int (*blockencrypt)(const struct esp_algorithm *,
	    struct secasvar *, u_int8_t *, u_int8_t *);
	size_t icvlen;
	int (*finalizedecrypt)(struct secasvar *, u_int8_t *, size_t);
	int (*finalizeencrypt)(struct secasvar *, u_int8_t *, size_t);
	int (*encrypt_pkt)(struct secasvar *, uint8_t *, size_t,
	    struct newesp *, uint8_t *, size_t, uint8_t *, size_t);
	int (*decrypt_pkt)(struct secasvar *, uint8_t *, size_t,
	    struct newesp *, uint8_t *, size_t, uint8_t *, size_t);
};
struct in6_addr {
	union {
		__uint8_t   __u6_addr8[16];
		__uint16_t  __u6_addr16[8];
		__uint32_t  __u6_addr32[4];
	} __u6_addr;                    
} in6_addr_t;
struct sockaddr_in6 {
	__uint8_t       sin6_len;       
	sa_family_t     sin6_family;    
	in_port_t       sin6_port;      
	__uint32_t      sin6_flowinfo;  
	struct in6_addr sin6_addr;      
	__uint32_t      sin6_scope_id;  
};
struct route_in6_old {
	void            *ro_rt;
	uint32_t        ro_flags;
	struct sockaddr_in6 ro_dst;
};
struct route_in6 {
	struct rtentry  *ro_rt;

	struct ifaddr   *ro_srcia;
	uint32_t        ro_flags;       
	struct sockaddr_in6 ro_dst;
};
struct in6_addrlifetime {
	time_t ia6t_expire;     
	time_t ia6t_preferred;  
	u_int32_t ia6t_vltime;  
	u_int32_t ia6t_pltime;  
};
struct in6_addrlifetime_32 {
	u_int32_t ia6t_expire;
	u_int32_t ia6t_preferred;
	u_int32_t ia6t_vltime;
	u_int32_t ia6t_pltime;
};
struct in6_addrlifetime_64 {
	u_int64_t ia6t_expire;
	u_int64_t ia6t_preferred;
	u_int32_t ia6t_vltime;
	u_int32_t ia6t_pltime;
};
struct in6_addrlifetime_i {
	u_int64_t ia6ti_expire;         
	u_int64_t ia6ti_preferred;      
	u_int32_t ia6ti_vltime;         
	u_int32_t ia6ti_pltime;         
	u_int64_t ia6ti_base_calendartime; 
	u_int64_t ia6ti_base_uptime;    
};
struct in6_ifaddr {
	struct ifaddr ia_ifa;           
	struct sockaddr_in6 ia_addr;    
	struct sockaddr_in6 ia_net;     
	struct sockaddr_in6 ia_dstaddr; 
	struct sockaddr_in6 ia_prefixmask; 
	u_int32_t ia_plen;              
	TAILQ_ENTRY(in6_ifaddr) ia6_link;     
	TAILQ_ENTRY(in6_ifaddr) ia6_hash; 
	int ia6_flags;

	uint8_t   ia6_cga_collision_count;

	struct in6_addrlifetime_i ia6_lifetime;
	u_int64_t ia6_createtime;
	u_int64_t ia6_updatetime;

	struct nd_prefix *ia6_ndpr;

	LIST_HEAD(, in6_multi_mship) ia6_memberships;
};
struct in6_addrpolicy {
	struct sockaddr_in6 addr; 
	struct sockaddr_in6 addrmask; 
	int preced;             
	int label;              
	u_quad_t use;           
};
struct in6_ifstat {
	u_quad_t ifs6_in_receive;       
	u_quad_t ifs6_in_hdrerr;        
	u_quad_t ifs6_in_toobig;        
	u_quad_t ifs6_in_noroute;       
	u_quad_t ifs6_in_addrerr;       
	u_quad_t ifs6_in_protounknown;  
	                                
	u_quad_t ifs6_in_truncated;     
	u_quad_t ifs6_in_discard;       
	                                
	u_quad_t ifs6_in_deliver;       
	                                
	u_quad_t ifs6_out_forward;      
	                                
	u_quad_t ifs6_out_request;      
	                                
	u_quad_t ifs6_out_discard;      
	u_quad_t ifs6_out_fragok;       
	u_quad_t ifs6_out_fragfail;     
	u_quad_t ifs6_out_fragcreat;    
	                                
	u_quad_t ifs6_reass_reqd;       
	                                
	u_quad_t ifs6_reass_ok;         
	                                
	                                
	u_quad_t ifs6_atmfrag_rcvd;     
	u_quad_t ifs6_reass_fail;       
	                                
	                                
	u_quad_t ifs6_in_mcast;         
	u_quad_t ifs6_out_mcast;        

	u_quad_t ifs6_cantfoward_icmp6; 
	u_quad_t ifs6_addr_expiry_cnt;  
	u_quad_t ifs6_pfx_expiry_cnt;   
	u_quad_t ifs6_defrtr_expiry_cnt;        
};
struct icmp6_ifstat {
	u_quad_t ifs6_in_msg;
	u_quad_t ifs6_in_error;
	u_quad_t ifs6_in_dstunreach;
	u_quad_t ifs6_in_adminprohib;
	u_quad_t ifs6_in_timeexceed;
	u_quad_t ifs6_in_paramprob;
	u_quad_t ifs6_in_pkttoobig;
	u_quad_t ifs6_in_echo;
	u_quad_t ifs6_in_echoreply;
	u_quad_t ifs6_in_routersolicit;
	u_quad_t ifs6_in_routeradvert;
	u_quad_t ifs6_in_neighborsolicit;
	u_quad_t ifs6_in_neighboradvert;
	u_quad_t ifs6_in_redirect;
	u_quad_t ifs6_in_mldquery;
	u_quad_t ifs6_in_mldreport;
	u_quad_t ifs6_in_mlddone;

	u_quad_t ifs6_out_msg;
	u_quad_t ifs6_out_error;
	u_quad_t ifs6_out_dstunreach;
	u_quad_t ifs6_out_adminprohib;
	u_quad_t ifs6_out_timeexceed;
	u_quad_t ifs6_out_paramprob;
	u_quad_t ifs6_out_pkttoobig;
	u_quad_t ifs6_out_echo;
	u_quad_t ifs6_out_echoreply;
	u_quad_t ifs6_out_routersolicit;
	u_quad_t ifs6_out_routeradvert;
	u_quad_t ifs6_out_neighborsolicit;
	u_quad_t ifs6_out_neighboradvert;
	u_quad_t ifs6_out_redirect;
	u_quad_t ifs6_out_mldquery;
	u_quad_t ifs6_out_mldreport;
	u_quad_t ifs6_out_mlddone;
};
struct in6_ifreq {
	char    ifr_name[IFNAMSIZ];
	union {
		struct  sockaddr_in6 ifru_addr;
		struct  sockaddr_in6 ifru_dstaddr;
		int     ifru_flags;
		int     ifru_flags6;
		int     ifru_metric;
		int     ifru_intval;
		caddr_t ifru_data;
		struct in6_addrlifetime ifru_lifetime;
		struct in6_ifstat ifru_stat;
		struct icmp6_ifstat ifru_icmp6stat;
		u_int32_t ifru_scope_id[SCOPE6_ID_MAX];
	} ifr_ifru;
};
struct in6_aliasreq {
	char    ifra_name[IFNAMSIZ];
	struct  sockaddr_in6 ifra_addr;
	struct  sockaddr_in6 ifra_dstaddr;
	struct  sockaddr_in6 ifra_prefixmask;
	int     ifra_flags;
	struct in6_addrlifetime ifra_lifetime;
};
struct in6_cga_modifier {
	u_int8_t octets[IN6_CGA_MODIFIER_LENGTH];
};
struct in6_cga_prepare {
	struct in6_cga_modifier cga_modifier;
	u_int8_t cga_security_level;
	u_int8_t reserved_A[15];
};
struct in6_cga_nodecfg {
	struct iovec cga_privkey;
	struct iovec cga_pubkey;
	struct in6_cga_prepare cga_prepare;
};
struct in6_cgareq {
	char cgar_name[IFNAMSIZ];
	int cgar_flags;
	struct in6_cga_prepare cgar_cgaprep;
	struct in6_addrlifetime cgar_lifetime;
	uint8_t cgar_collision_count;
};
struct in6_cgareq_32 {
	char cgar_name[IFNAMSIZ];
	int cgar_flags;
	struct in6_cga_prepare cgar_cgaprep;
	struct in6_addrlifetime_32 cgar_lifetime;
	uint8_t cgar_collision_count;
};
struct in6_cgareq_64 {
	char cgar_name[IFNAMSIZ];
	int cgar_flags;
	struct in6_cga_prepare cgar_cgaprep;
	struct in6_addrlifetime_64 cgar_lifetime;
	uint8_t cgar_collision_count;
};
struct in6_aliasreq_32 {
	char    ifra_name[IFNAMSIZ];
	struct  sockaddr_in6 ifra_addr;
	struct  sockaddr_in6 ifra_dstaddr;
	struct  sockaddr_in6 ifra_prefixmask;
	int     ifra_flags;
	struct in6_addrlifetime_32 ifra_lifetime;
};
struct in6_aliasreq_64 {
	char    ifra_name[IFNAMSIZ];
	struct  sockaddr_in6 ifra_addr;
	struct  sockaddr_in6 ifra_dstaddr;
	struct  sockaddr_in6 ifra_prefixmask;
	int     ifra_flags;
	struct in6_addrlifetime_64 ifra_lifetime;
};
struct in6_prflags {
	struct prf_ra {
		u_char onlink : 1;
		u_char autonomous : 1;
		u_char reserved : 6;
	} prf_ra;
	u_char prf_reserved1;
	u_short prf_reserved2;
	struct prf_rr {
		u_char decrvalid : 1;
		u_char decrprefd : 1;
		u_char reserved : 6;
	} prf_rr;
	u_char prf_reserved3;
	u_short prf_reserved4;
};
struct  in6_prefixreq {
	char    ipr_name[IFNAMSIZ];
	u_char  ipr_origin;
	u_char  ipr_plen;
	u_int32_t ipr_vltime;
	u_int32_t ipr_pltime;
	struct in6_prflags ipr_flags;
	struct  sockaddr_in6 ipr_prefix;
};
struct in6_rrenumreq {
	char    irr_name[IFNAMSIZ];
	u_char  irr_origin;
	u_char  irr_m_len;      
	u_char  irr_m_minlen;   
	u_char  irr_m_maxlen;   
	u_char  irr_u_uselen;   
	u_char  irr_u_keeplen;  
	struct irr_raflagmask {
		u_char onlink : 1;
		u_char autonomous : 1;
		u_char reserved : 6;
	} irr_raflagmask;
	u_int32_t irr_vltime;
	u_int32_t irr_pltime;
	struct in6_prflags irr_flags;
	struct  sockaddr_in6 irr_matchprefix;
	struct  sockaddr_in6 irr_useprefix;
};
struct kev_in6_addrlifetime {
	u_int32_t ia6t_expire;
	u_int32_t ia6t_preferred;
	u_int32_t ia6t_vltime;
	u_int32_t ia6t_pltime;
};
struct kev_in6_data {
	struct net_event_data link_data;
	struct sockaddr_in6 ia_addr;    
	struct sockaddr_in6 ia_net;     
	struct sockaddr_in6 ia_dstaddr; 
	struct sockaddr_in6 ia_prefixmask; 
	u_int32_t ia_plen;              
	u_int32_t ia6_flags;            
	struct kev_in6_addrlifetime ia_lifetime; 
	uint8_t ia_mac[ETHER_ADDR_LEN];
};
struct ip6_msource {
	RB_ENTRY(ip6_msource)   im6s_link;      
	struct in6_addr         im6s_addr;
	struct im6s_st {
		uint16_t        ex;             
		uint16_t        in;             
	}                       im6s_st[2];     
	uint8_t                 im6s_stp;       
};
struct in6_msource {
	RB_ENTRY(ip6_msource)   im6s_link;      
	struct in6_addr         im6s_addr;      
	uint8_t                 im6sl_st[2];    
};
struct in6_mfilter {
	struct ip6_msource_tree im6f_sources; 
	u_long                  im6f_nsrc;    
	uint8_t                 im6f_st[2];   
};
struct in6_multi_mship {
	struct  in6_multi *i6mm_maddr;  
	LIST_ENTRY(in6_multi_mship) i6mm_chain;  
};
struct in6_ifextra {
	struct scope6_id        scope6_id;
	struct in6_ifstat       in6_ifstat;
	struct icmp6_ifstat     icmp6_ifstat;
	struct nd_ifinfo        nd_ifinfo;
	uint32_t                netsig_len;
	u_int8_t                netsig[IFNET_SIGNATURELEN];
	struct ipv6_prefix      nat64_prefixes[NAT64_MAX_NUM_PREFIXES];
};
struct in6_multi {
	decl_lck_mtx_data(, in6m_lock);
	u_int32_t in6m_refcount;        
	u_int32_t in6m_reqcnt;          
	u_int32_t in6m_debug;           
	LIST_ENTRY(in6_multi) in6m_entry; 
	struct  in6_addr in6m_addr;     
	uint32_t ifscope;               
	struct  ifnet *in6m_ifp;        
	struct  ifmultiaddr *in6m_ifma; 
	u_int   in6m_state;             
	u_int   in6m_timer;             
	bool    in6m_in_nrele;          

	struct mld_ifinfo       *in6m_mli;      
	SLIST_ENTRY(in6_multi)   in6m_dtle;     
	SLIST_ENTRY(in6_multi)   in6m_nrele;    
	u_int32_t                in6m_nrelecnt; 
	struct ip6_msource_tree  in6m_srcs;     
	u_long                   in6m_nsrc;     

	struct ifqueue           in6m_scq;  
	struct timeval           in6m_lastgsrtv;        
	uint16_t                 in6m_sctimer;  
	uint16_t                 in6m_scrv;     

	struct in6m_st {
		uint16_t        iss_fmode;      
		uint16_t        iss_asm;        
		uint16_t        iss_ex;         
		uint16_t        iss_in;         
		uint16_t        iss_rec;        
	}                       in6m_st[2];     

	void (*in6m_trace)              
	(struct in6_multi *, int);
};
struct in6_multistep {
	struct in6_ifaddr *i_ia;
	struct in6_multi *i_in6m;
};
struct ip6ctlparam {
	struct mbuf *ip6c_m;            
	struct icmp6_hdr *ip6c_icmp6;   
	struct ip6_hdr *ip6c_ip6;       
	int ip6c_off;                   
	struct sockaddr_in6 *ip6c_src;  
	struct sockaddr_in6 *ip6c_dst;  
	struct in6_addr *ip6c_finaldst; 
	void *ip6c_cmdarg;              
	u_int8_t ip6c_nxt;              
};
struct ip6protosw {
	TAILQ_ENTRY(ip6protosw) pr_entry; 
	struct  domain *pr_domain;      
	struct protosw *pr_protosw;     
	u_int16_t pr_type;              
	u_int16_t pr_protocol;          
	u_int32_t pr_flags;             
	int     (*pr_input)             
	(struct mbuf **, int *, int);
	int     (*pr_output)            
	(struct mbuf *m, struct socket *so,
	struct sockaddr_in6 *, struct mbuf *);
	void    (*pr_ctlinput)          
	(int, struct sockaddr *, void *, struct ifnet *);
	int     (*pr_ctloutput)         
	(struct socket *, struct sockopt *);
	struct  pr_usrreqs *pr_usrreqs; 
	void    (*pr_init)              
	(struct ip6protosw *, struct domain *);
	void    (*pr_drain)(void);      
	int     (*pr_sysctl)(void);     
	int     (*pr_lock)              
	(struct socket *so, int refcnt, void *debug);
	int     (*pr_unlock)            
	(struct socket *so, int refcnt, void *debug);
	lck_mtx_t *(*pr_getlock)        
	(struct socket *so, int flags);
	TAILQ_HEAD(, socket_filter) pr_filter_head;
	struct protosw_old *pr_old;

	void    (*pr_update_last_owner) 
	(struct socket *so, struct proc *p, struct proc *ep);

	void    (*pr_copy_last_owner) 
	(struct socket *so, struct socket *head);
};
struct  ip6q {
	struct ip6asfrag *ip6q_down;
	struct ip6asfrag *ip6q_up;
	u_int32_t       ip6q_ident;
	u_int8_t        ip6q_nxt;
	u_int8_t        ip6q_ecn;
	u_int8_t        ip6q_ttl;
	struct in6_addr ip6q_src, ip6q_dst;
	struct ip6q     *ip6q_next;
	struct ip6q     *ip6q_prev;
	int             ip6q_unfrglen;  
	int             ip6q_nfrag;     
	uint32_t        ip6q_csum_flags; 
	uint32_t        ip6q_csum;      
	uint32_t        ip6q_flags;
	uint32_t        ip6q_dst_ifscope, ip6q_src_ifscope;
};
struct  ip6_moptions {
	decl_lck_mtx_data(, im6o_lock);
	uint32_t im6o_refcnt;           
	uint32_t im6o_debug;            
	struct  ifnet *im6o_multicast_ifp; 
	u_char  im6o_multicast_hlim;    
	u_char  im6o_multicast_loop;    
	u_short im6o_num_memberships;   
	u_short im6o_max_memberships;   
	u_short im6o_max_filters;       
	struct  in6_multi **__counted_by(im6o_max_memberships) im6o_membership;
	struct  in6_mfilter *__counted_by(im6o_max_filters) im6o_mfilters;
	void (*im6o_trace)              
	(struct ip6_moptions *, int);
};
struct ip6_exthdrs {
	struct mbuf *ip6e_ip6;
	struct mbuf *ip6e_hbh;
	struct mbuf *ip6e_dest1;
	struct mbuf *ip6e_rthdr;
	struct mbuf *ip6e_dest2;
	boolean_t merged;
};
struct  ip6po_rhinfo {
	struct  ip6_rthdr *ip6po_rhi_rthdr; 
	struct  route_in6 ip6po_rhi_route; 
};
struct  ip6po_nhinfo {
	struct  sockaddr *ip6po_nhi_nexthop;
	struct  route_in6 ip6po_nhi_route; 
};
struct  ip6_pktopts {
	struct  mbuf *ip6po_m;  
	int     ip6po_hlim;     

	struct  in6_pktinfo *ip6po_pktinfo;

	struct  ip6po_nhinfo ip6po_nhinfo;

	struct  ip6_hbh *ip6po_hbh; 

	struct  ip6_dest *ip6po_dest1;

	struct  ip6po_rhinfo ip6po_rhinfo;

	struct  ip6_dest *ip6po_dest2;

	int     ip6po_tclass;   

	int     ip6po_minmtu;  

	int     ip6po_prefer_tempaddr;


	int ip6po_flags;
};
struct  ip6stat {
	u_quad_t ip6s_total;            
	u_quad_t ip6s_tooshort;         
	u_quad_t ip6s_toosmall;         
	u_quad_t ip6s_fragments;        
	u_quad_t ip6s_fragdropped;      
	u_quad_t ip6s_fragtimeout;      
	u_quad_t ip6s_fragoverflow;     
	u_quad_t ip6s_forward;          
	u_quad_t ip6s_cantforward;      
	u_quad_t ip6s_redirectsent;     
	u_quad_t ip6s_delivered;        
	u_quad_t ip6s_localout;         
	u_quad_t ip6s_odropped;         
	u_quad_t ip6s_reassembled;      
	u_quad_t ip6s_atmfrag_rcvd;     
	u_quad_t ip6s_fragmented;       
	u_quad_t ip6s_ofragments;       
	u_quad_t ip6s_cantfrag;         
	u_quad_t ip6s_badoptions;       
	u_quad_t ip6s_noroute;          
	u_quad_t ip6s_badvers;          
	u_quad_t ip6s_rawout;           
	u_quad_t ip6s_badscope;         
	u_quad_t ip6s_notmember;        
	u_quad_t ip6s_nxthist[256];     
	u_quad_t ip6s_m1;               
	u_quad_t ip6s_m2m[32];          
	u_quad_t ip6s_mext1;            
	u_quad_t ip6s_mext2m;           
	u_quad_t ip6s_exthdrtoolong;    
	u_quad_t ip6s_nogif;            
	u_quad_t ip6s_toomanyhdr;       

	u_quad_t ip6s_sources_none;
	u_quad_t ip6s_sources_sameif[SCOPE6_ID_MAX];
	u_quad_t ip6s_sources_otherif[SCOPE6_ID_MAX];
	u_quad_t ip6s_sources_samescope[SCOPE6_ID_MAX];
	u_quad_t ip6s_sources_otherscope[SCOPE6_ID_MAX];
	u_quad_t ip6s_sources_deprecated[SCOPE6_ID_MAX];

	u_quad_t ip6s_forward_cachehit;
	u_quad_t ip6s_forward_cachemiss;

	u_quad_t ip6s_sources_rule[IP6S_SRCRULE_COUNT];

	u_quad_t ip6s_sources_skip_expensive_secondary_if;

	u_quad_t ip6s_pktdropcntrl;

	u_quad_t ip6s_adj;
	u_quad_t ip6s_adj_hwcsum_clr;

	u_quad_t ip6s_dad_collide;

	u_quad_t ip6s_dad_loopcount;

	u_quad_t ip6s_necp_policy_drop;

	u_quad_t ip6s_clat464_in_tooshort_drop;
	u_quad_t ip6s_clat464_in_nov6addr_drop;
	u_quad_t ip6s_clat464_in_nov4addr_drop;
	u_quad_t ip6s_clat464_in_v4synthfail_drop;
	u_quad_t ip6s_clat464_in_64transfail_drop;
	u_quad_t ip6s_clat464_in_64proto_transfail_drop;
	u_quad_t ip6s_clat464_in_64frag_transfail_drop;
	u_quad_t ip6s_clat464_in_invalpbuf_drop;
	u_quad_t ip6s_clat464_in_success;
	u_quad_t ip6s_clat464_in_drop;
	u_quad_t ip6s_clat464_in_v4_drop;

	u_quad_t ip6s_clat464_out_nov6addr_drop;
	u_quad_t ip6s_clat464_out_v6synthfail_drop;
	u_quad_t ip6s_clat464_out_46transfail_drop;
	u_quad_t ip6s_clat464_out_46proto_transfail_drop;
	u_quad_t ip6s_clat464_out_46frag_transfail_drop;
	u_quad_t ip6s_clat464_out_invalpbuf_drop;
	u_quad_t ip6s_clat464_out_success;
	u_quad_t ip6s_clat464_out_drop;

	u_quad_t ip6s_clat464_v6addr_conffail;
	u_quad_t ip6s_clat464_plat64_pfx_setfail;
	u_quad_t ip6s_clat464_plat64_pfx_getfail;

	u_quad_t ip6s_overlap_frag_drop;

	u_quad_t ip6s_rcv_if_weak_match;
	u_quad_t ip6s_rcv_if_no_match;
};
struct ip6aux {
	u_int32_t ip6a_flags;


	u_char ip6a_ehsrc[ETHER_ADDR_LEN];
};
struct ip6_out_args {
	unsigned int    ip6oa_boundif;  
	struct flowadv  ip6oa_flowadv;  
	u_int32_t       ip6oa_flags;    
	int             ip6oa_sotc;             
	int             ip6oa_netsvctype;
	int32_t         qos_marking_gencount;
};
struct ipcomp {
	u_int8_t comp_nxt;      
	u_int8_t comp_flags;    
	u_int16_t comp_cpi;     
};
struct secpolicyaddrrange {
	struct sockaddr_storage start;  
	struct sockaddr_storage end;    
};
struct secpolicyindex {
	u_int8_t dir;                   
	struct sockaddr_storage src;    
	struct sockaddr_storage dst;    
	u_int8_t prefs;                 
	u_int8_t prefd;                 
	u_int8_t ul_proto;             
	ifnet_t internal_if; 
	struct secpolicyaddrrange src_range;    
	struct secpolicyaddrrange dst_range;    
};
struct secpolicy {
	LIST_ENTRY(secpolicy) chain;

	int refcnt;                     
	struct secpolicyindex spidx;    
	u_int32_t id;                   
	u_int state;                    

	u_int policy;           
	struct ipsecrequest *req;

	ifnet_t ipsec_if; 
	ifnet_t outgoing_if; 

	char disabled; 

	u_int64_t created;      
	u_int64_t lastused;     
	u_int64_t lifetime;     
	u_int64_t validtime;    
};
struct ipsecrequest {
	struct ipsecrequest *next;
	struct secasindex saidx;
	                        
	u_int level;            

	struct secpolicy *sp;   
};
struct inpcbpolicy {
	struct secpolicy *sp_in;
	struct secpolicy *sp_out;
	int priv;                       
};
struct secspacq {
	LIST_ENTRY(secspacq) chain;

	struct secpolicyindex spidx;

	u_int64_t created;      
	int count;              
};
struct ipsecstat {
	u_quad_t in_success __attribute__ ((aligned(8)));  
	u_quad_t in_polvio __attribute__ ((aligned(8)));
	u_quad_t in_nosa __attribute__ ((aligned(8)));      
	u_quad_t in_inval __attribute__ ((aligned(8)));     
	u_quad_t in_nomem __attribute__ ((aligned(8)));     
	u_quad_t in_badspi __attribute__ ((aligned(8)));    
	u_quad_t in_ahreplay __attribute__ ((aligned(8)));  
	u_quad_t in_espreplay __attribute__ ((aligned(8)));  
	u_quad_t in_ahauthsucc __attribute__ ((aligned(8)));  
	u_quad_t in_ahauthfail __attribute__ ((aligned(8)));  
	u_quad_t in_espauthsucc __attribute__ ((aligned(8)));  
	u_quad_t in_espauthfail __attribute__ ((aligned(8)));  
	u_quad_t in_esphist[256] __attribute__ ((aligned(8)));
	u_quad_t in_ahhist[256] __attribute__ ((aligned(8)));
	u_quad_t in_comphist[256] __attribute__ ((aligned(8)));
	u_quad_t out_success __attribute__ ((aligned(8)));  
	u_quad_t out_polvio __attribute__ ((aligned(8)));
	u_quad_t out_nosa __attribute__ ((aligned(8)));     
	u_quad_t out_inval __attribute__ ((aligned(8)));    
	u_quad_t out_nomem __attribute__ ((aligned(8)));     
	u_quad_t out_noroute __attribute__ ((aligned(8)));  
	u_quad_t out_esphist[256] __attribute__ ((aligned(8)));
	u_quad_t out_ahhist[256] __attribute__ ((aligned(8)));
	u_quad_t out_comphist[256] __attribute__ ((aligned(8)));
};
struct ipsec_wake_pkt_info {
	u_int8_t wake_pkt[IPSEC_MAX_WAKE_PKT_LEN];
	uuid_string_t wake_uuid;
	u_int32_t wake_pkt_spi;
	u_int32_t wake_pkt_seq;
	u_int16_t wake_pkt_len;
};
struct ipsec_wake_pkt_event_data {
	uuid_string_t wake_uuid;
};
struct ipsec_output_state {
	int tunneled;
	struct mbuf *m;
	struct route_in6 ro;
	struct sockaddr *dst;
	u_int outgoing_if;
	u_int32_t dscp_mapping;
};
struct ipsec_history {
	int ih_proto;
	u_int32_t ih_spi;
};
struct mldv2_query {
	struct icmp6_hdr        mld_icmp6_hdr;  
	struct in6_addr         mld_addr;       
	uint8_t         mld_misc;       
	uint8_t         mld_qqi;        
	uint16_t        mld_numsrc;     
} __attribute__((__packed__));
struct mldv2_report {
	struct icmp6_hdr        mld_icmp6_hdr;
} __attribute__((__packed__));
struct mldv2_record {
	uint8_t                 mr_type;        
	uint8_t                 mr_datalen;     
	uint16_t                mr_numsrc;      
	struct in6_addr         mr_addr;        
} __attribute__((__packed__));
struct  llinfo_nd6 {
	struct  llinfo_nd6 *ln_next;
	struct  llinfo_nd6 *ln_prev;
	struct  rtentry *ln_rt;
	struct ifnet *ln_exclifp; 
	struct  mbuf *ln_hold;  
	uint32_t ln_asked;      
	short   ln_state;       
	short   ln_router;      
	u_int32_t ln_flags;     
	u_int64_t ln_expire;    
	u_int64_t ln_lastused;  
	struct  if_llreach *ln_llreach; 
};
struct {
		u_int32_t linkmtu;      
		u_int32_t maxmtu;       
		u_int32_t basereachable; 
		u_int32_t reachable;    
		u_int32_t retrans;      
		u_int32_t flags;        
		int recalctm;           
		u_int8_t chlim;         
		
		u_int8_t receivedra;
		
		u_int8_t collision_count;
	} ndi;
struct {
		struct nd_opt_hdr *zero;
		struct nd_opt_hdr *src_lladdr;
		struct nd_opt_hdr *tgt_lladdr;
		struct nd_opt_prefix_info *pi_beg; 
		struct nd_opt_rd_hdr *rh;
		struct nd_opt_mtu *mtu;
		struct nd_opt_hdr *__res6;
		struct nd_opt_hdr *__res7;
		struct nd_opt_hdr *__res8;
		struct nd_opt_hdr *__res9;
		struct nd_opt_hdr *__res10;
		struct nd_opt_hdr *__res11;
		struct nd_opt_hdr *__res12;
		struct nd_opt_hdr *__res13;
		struct nd_opt_nonce *nonce;
		struct nd_opt_hdr *__res15;
		struct nd_opt_hdr *__res16;
		struct nd_opt_hdr *__res17;
		struct nd_opt_hdr *__res18;
		struct nd_opt_hdr *__res19;
		struct nd_opt_hdr *__res20;
		struct nd_opt_hdr *__res21;
		struct nd_opt_hdr *__res22;
		struct nd_opt_hdr *__res23;
		struct nd_opt_route_info *rti_beg;
		struct nd_opt_hdr *__res25;
		struct nd_opt_hdr *__ended_by(last) search; 
		struct nd_opt_hdr *last;                    
		uint8_t done;
		uint8_t initialized;
		struct nd_opt_prefix_info *pi_end; 
		struct nd_opt_route_info *rti_end; 
	} nd_opt_each;
struct nd_ifinfo {
	decl_lck_mtx_data(, lock);
	boolean_t initialized;          
	u_int32_t linkmtu;              
	u_int32_t maxmtu;               
	u_int32_t basereachable;        
	u_int32_t reachable;            
	u_int32_t retrans;              
	u_int32_t flags;                
	int recalctm;                   
	u_int8_t chlim;                 
	u_int8_t _pad[3];
	u_int8_t randomseed0[8]; 
	u_int8_t randomseed1[8]; 
	u_int8_t randomid[8];   
	int32_t nprefixes;
	int32_t ndefrouters;
	boolean_t cga_initialized;
	struct in6_cga_modifier local_cga_modifier;
	uint8_t cga_collision_count;
};
struct rip6stat {
	u_quad_t rip6s_ipackets;        
	u_quad_t rip6s_isum;            
	u_quad_t rip6s_badsum;          
	u_quad_t rip6s_nosock;          
	u_quad_t rip6s_nosockmcast;     
	u_quad_t rip6s_fullsock;        

	u_quad_t rip6s_opackets;        
};
struct scope6_id {
	u_int32_t s6id_list[SCOPE6_ID_MAX];
};
struct secasindex {
	struct sockaddr_storage src;    
	struct sockaddr_storage dst;    
	u_int16_t proto;                
	u_int8_t mode;                  
	u_int32_t reqid;                
	                                
	u_int ipsec_ifindex;
};
struct secashead {
	LIST_ENTRY(secashead) chain;

	struct secasindex saidx;

	ifnet_t ipsec_if;
	u_int outgoing_if;
	u_int8_t dir;                   
	u_int8_t state;                 
	LIST_HEAD(_satree, secasvar) savtree[SADB_SASTATE_MAX + 1];

	struct route_in6 sa_route;              

	uint16_t flags;
	u_int32_t use_count;
};
struct secasvar {
	LIST_ENTRY(secasvar) chain;
	LIST_ENTRY(secasvar) spihash;
	int refcnt;                     
	u_int8_t state;                 

	u_int8_t alg_auth;              
	u_int8_t alg_enc;               
	u_int32_t spi;                  
	u_int32_t flags;                
	u_int16_t flags2;               

	struct sadb_key *__sized_by(key_auth_len) key_auth;     
	struct sadb_key *__sized_by(key_enc_len) key_enc;       
	caddr_t __sized_by(ivlen) iv;                           
	void *__sized_by(schedlen_auth) sched_auth;             
	void *__sized_by(schedlen_enc) sched_enc;               
	uint32_t key_auth_len;
	uint32_t key_enc_len;
	size_t schedlen_auth;
	size_t schedlen_enc;
	u_int ivlen;                                            

	struct secreplay *replay[MAX_REPLAY_WINDOWS]; 

	u_int64_t created;              

	struct sadb_lifetime *lft_c;    
	struct sadb_lifetime *lft_h;    
	struct sadb_lifetime *lft_s;    

	struct socket *so; 

	u_int32_t seq;                  
	pid_t pid;                      

	struct secashead *sah;          

	u_int64_t       natt_last_activity;
	u_int16_t       remote_ike_port;
	u_int16_t       natt_encapsulated_src_port;     
	u_int16_t       natt_interval; 
	u_int16_t       natt_offload_interval; 
	uint32_t        flowid;

	u_int8_t        always_expire; 
};
struct secreplay {
	u_int8_t wsize;                          
	u_int32_t count;                         
	u_int32_t seq;                           
	u_int32_t lastseq;                       
	caddr_t __sized_by(wsize) bitmap;        
	int overflow;                            
};
struct secreg {
	LIST_ENTRY(secreg) chain;

	struct socket *so;
};
struct secacq {
	LIST_ENTRY(secacq) chain;

	struct secasindex saidx;

	u_int32_t seq;          
	u_int64_t created;      
	int count;              
};
struct key_cb {
	int key_count;
	int any_count;
};
struct pfkeystat {
	u_quad_t out_total;             
	u_quad_t out_bytes;             
	u_quad_t out_msgtype[256];      
	u_quad_t out_invlen;            
	u_quad_t out_invver;            
	u_quad_t out_invmsgtype;        
	u_quad_t out_tooshort;          
	u_quad_t out_nomem;             
	u_quad_t out_dupext;            
	u_quad_t out_invexttype;        
	u_quad_t out_invsatype;         
	u_quad_t out_invaddr;           
	u_quad_t in_total;              
	u_quad_t in_bytes;              
	u_quad_t in_msgtype[256];       
	u_quad_t in_msgtarget[3];       
	u_quad_t in_nomem;              
	u_quad_t sockerr;               
};
struct keycb {
	struct rawcb kp_raw;    
	int kp_promisc;         
	int kp_registered;      
};
struct nfs_gss_svc_ctx {
	lck_mtx_t               gss_svc_mtx;
	LIST_ENTRY(nfs_gss_svc_ctx)     gss_svc_entries;
	uint32_t                gss_svc_handle;         
	uint32_t                gss_svc_refcnt;         
	uint32_t                gss_svc_proc;           
	uid_t                   gss_svc_uid;            
	gid_t                   gss_svc_gids[NGROUPS];  
	uint32_t                gss_svc_ngroups;        
	uint64_t                gss_svc_incarnation;    
	uint32_t                gss_svc_seqmax;         
	uint32_t                gss_svc_seqwin;         
	uint32_t                *gss_svc_seqbits;       
	gssd_cred               gss_svc_cred_handle;    
	gssd_ctx                gss_svc_context;        
	gss_ctx_id_t            gss_svc_ctx_id;         
	u_char                  *gss_svc_token;         
	uint32_t                gss_svc_tokenlen;       
	uint32_t                gss_svc_major;          
	uint32_t                gss_svc_minor;          
};
struct workq_threadreq_extended_param_s {
	struct work_interval *trp_work_interval;
};
struct workq_threadreq_s {
	union {
		struct priority_queue_entry_sched tr_entry;
		STAILQ_ENTRY(workq_threadreq_s) tr_link;
		struct {
			thread_t tr_thread;
			
			struct work_interval *tr_work_interval;
		};
	};
	uint16_t           tr_count;
	workq_tr_flags_t   tr_flags;
	workq_tr_state_t   tr_state;
	thread_qos_t       tr_qos;                 

	kq_index_t         tr_kq_override_index;   
	kq_index_t         tr_kq_qos_index;        
} workq_threadreq_s, *workq_threadreq_t;
struct workqueue {
	thread_call_t   wq_delayed_call;
	thread_call_t   wq_immediate_call;
	thread_call_t   wq_death_call;

	union {
		struct turnstile *wq_turnstile;
		struct mpsc_queue_chain wq_destroy_link;
	};

	lck_ticket_t    wq_lock;

	uint64_t        wq_thread_call_last_run;
	struct os_refcnt wq_refcnt;
	workq_state_flags_t _Atomic wq_flags;
	uint32_t        wq_fulfilled;
	uint32_t        wq_creations;
	uint32_t        wq_timer_interval;
	uint32_t        wq_event_manager_priority;
	uint32_t        wq_reqcount;  
	uint16_t        wq_thdying_count;
	uint16_t        wq_threads_scheduled;
	uint16_t        wq_constrained_threads_scheduled;
	uint16_t        wq_nthreads;
	uint16_t        wq_thidlecount;
	uint16_t        wq_thscheduled_count[WORKQ_NUM_BUCKETS]; 

	workq_threadreq_t wq_event_manager_threadreq;

	_Atomic wq_thactive_t wq_thactive;
	_Atomic uint64_t wq_lastblocked_ts[WORKQ_NUM_QOS_BUCKETS];

	struct proc    *wq_proc;
	struct uthread *wq_creator;
	turnstile_inheritor_t wq_inheritor;
	thread_t wq_turnstile_updater; 
	struct workq_uthread_head wq_thrunlist;
	struct workq_uthread_head wq_thnewlist;
	struct workq_uthread_head wq_thidlelist;

	struct priority_queue_sched_max wq_overcommit_queue;
	struct priority_queue_sched_max wq_constrained_queue;
	struct priority_queue_sched_max wq_special_queue;

	uint8_t wq_cooperative_queue_scheduled_count[WORKQ_NUM_QOS_BUCKETS];
	uint16_t wq_cooperative_queue_best_req_qos: 3, 
	    wq_cooperative_queue_has_limited_max_size:1, 
	    wq_exceeded_active_constrained_thread_limit:1,
	    unused:11;
	struct workq_threadreq_tailq wq_cooperative_queue[WORKQ_NUM_QOS_BUCKETS];
};
struct workq_dispatch_config {
	uint32_t wdc_version;
	uint32_t wdc_flags;
	uint64_t wdc_queue_serialno_offs;
	uint64_t wdc_queue_label_offs;
} __attribute__((packed, aligned(4)));
struct {
	uint32_t        cres_pkt_alloc_failures;
	uint32_t        __cres_reserved[1];
} channel_ring_error_stats, *channel_ring_error_stats_t;
struct {
	uint64_t        crsu_total_slots_transferred;
	uint64_t        crsu_total_bytes_transferred;
	uint64_t        crsu_number_of_syncs;
	uint32_t        crsu_min_slots_transferred;
	uint32_t        crsu_max_slots_transferred;
	uint32_t        crsu_slots_per_sync;
	uint32_t        crsu_slots_per_sync_ma;
	uint64_t        crsu_bytes_per_sync;
	uint64_t        crsu_bytes_per_sync_ma;
	uint32_t        __crsu_reserved[2];
} channel_ring_user_stats, *channel_ring_user_stats_t;
struct {
	uint64_t        crs_total_slots_transferred;
	uint64_t        crs_total_bytes_transferred;
	uint64_t        crs_number_of_transfers;
	uint32_t        crs_min_slots_transferred;
	uint32_t        crs_max_slots_transferred;
	uint32_t        crs_slots_per_second;
	uint32_t        crs_slots_per_second_ma;
	uint64_t        crs_bytes_per_second;
	uint64_t        crs_bytes_per_second_ma;
	uint32_t        __crs_reserved[2];
} channel_ring_stats, *channel_ring_stats_t;
struct netif_qstats {
	uint64_t        nq_total_pkts;  
	uint64_t        nq_total_bytes; 
	uint64_t        nq_num_xfers;   
	uint32_t        nq_min_pkts;    
	uint32_t        nq_max_pkts;    
	uint32_t        nq_pkts_ps;     
	uint32_t        nq_pkts_ps_ma;  
	uint64_t        nq_bytes_ps;    
	uint64_t        nq_bytes_ps_ma; 
};
struct netif_qstats_info {
	uint64_t                            nqi_qset_id;
	uint16_t                            nqi_queue_flag;
	uint16_t                            nqi_queue_idx;
	packet_svc_class_t                  nqi_svc;
	struct netif_qstats                 nqi_stats;
};
struct {
	uuid_t          npi_prov_uuid;          
	struct nxprov_params npi_prov_params;   
	uint32_t        npi_instance_uuids_count;
	uint32_t        __npi_align_reserved;
	uuid_t          npi_instance_uuids[0];  
} nexus_provider_info, *nexus_provider_info_t;
struct {
	ring_id_t               ncre_ring_id;
	uint32_t                __ncre_align_reserved;
	channel_ring_stats              ncre_stats;
	channel_ring_user_stats         ncre_user_stats;
	channel_ring_error_stats        ncre_error_stats;
} nexus_channel_ring_entry, *nexus_channel_ring_entry_t;
struct {
	uuid_t          nce_uuid;       
	uint32_t        nce_flags;      
	pid_t           nce_pid;        
	int             nce_fd;         
	nexus_port_t    nce_port;       
	uint32_t        nce_tx_rings;   
	uint32_t        nce_rx_rings;   
	uint32_t        __nce_align_reserved;
	uint32_t        nce_ring_count; 
	nexus_channel_ring_entry nce_ring_entries[__counted_by(nce_ring_count)]; 
} nexus_channel_entry, *nexus_channel_entry_t;
struct {
	uuid_t          nci_instance_uuid;      
	uint32_t        nci_channel_entries_count;
	uint32_t        __nci_align_reserved;
	nexus_channel_entry     nci_channel_entries[__counted_by(nci_channel_entries_count)]; 
} nexus_channel_info, *nexus_channel_info_t;
struct __nx_stats_fsw {
	struct ip_stats                 nxs_ipstat;
	struct ip6_stats                nxs_ip6stat;
	struct tcp_stats                nxs_tcpstat;
	struct udp_stats                nxs_udpstat;
	struct quic_stats               nxs_quicstat;
};
struct __nx_stats_channel_errors {
	channel_ring_error_stats_t      nxs_cres;
};
struct __kern_nexus_adv_metadata {
	uint16_t                 knam_version;
	uint16_t                 __reserved;
	nexus_advisory_type_t    knam_type;
};
struct __kern_netif_intf_advisory {
	uint32_t                           cksum;
	uint32_t                           _reserved;
	struct ifnet_interface_advisory    adv;
} __attribute__((aligned(sizeof(uint64_t))));
struct netif_nexus_advisory {
	uint64_t nna_version;
	union {
		struct __kern_netif_intf_advisory __kern_intf_adv;
		uint8_t __nna_intf_adv[NX_INTF_ADV_SIZE];
	};
} __attribute__((aligned(sizeof(uint64_t))));
struct sk_nexusadv {
	uint64_t nxadv_ver;             
	uint64_t nxadv_fg_sendts;       
	uint64_t nxadv_rt_sendts;       
	union {
		struct __kern_netif_intf_advisory _nxadv_intf_adv;
		uint8_t _nxadv_reserved[NX_INTF_ADV_SIZE];
	};
} __attribute__((aligned(sizeof(uint64_t))));
struct sk_stats_flow_track {
	uint64_t        sft_bytes;      
	uint64_t        sft_packets;    
	uint64_t        sft_spackets;   
	sk_stats_flow_track_state_t sft_state;  
	uint32_t        sft_rtt;        
	uint32_t        sft_seq;        
	uint16_t        sft_max_win;    
	uint8_t         sft_wscale;     
};
struct sk_stats_flow {
	uuid_t          sf_nx_uuid;             
	uuid_t          sf_uuid;                
	char            sf_if_name[IFNAMSIZ];   
	uint32_t        sf_if_index;            
	uint32_t        sf_bucket_idx;          

	pid_t           sf_pid;                 
	pid_t           sf_epid;                
	char            sf_proc_name[32];       
	char            sf_eproc_name[32];      

	uint32_t        sf_flags;               
	nexus_port_t    sf_nx_port;             

	uint8_t         sf_protocol;            
	packet_svc_class_t sf_svc_class;        
	flowadv_idx_t   sf_adv_idx;             
	struct flow_key sf_key __attribute__((__aligned__(16)));

	volatile struct sk_stats_flow_track sf_ltrack; 
	volatile struct sk_stats_flow_track sf_rtrack; 

	activity_bitmap_t sf_activity;          
};
struct flow_stats {
	struct sk_stats_flow    fs_stats;

	os_refcnt_t             fs_refcnt;
};
struct sk_stats_flow_owner {
	uuid_t          sfo_nx_uuid;            
	char            sfo_if_name[IFNAMSIZ];  
	uint32_t        sfo_bucket_idx;         

	char            sfo_name[32];           
	pid_t           sfo_pid;                

	nexus_port_t    sfo_nx_port;            
	boolean_t       sfo_nx_port_pid_bound;  
	boolean_t       sfo_nx_port_destroyed;  
} __attribute__((aligned(64)));
struct sk_stats_flow_route {
	uuid_t          sfr_nx_uuid;            
	uuid_t          sfr_uuid;               
	char            sfr_if_name[IFNAMSIZ];  

	uint32_t        sfr_bucket_idx;         
	uint32_t        sfr_id_bucket_idx;      

	uint32_t        sfr_flags;              
	uint32_t        sfr_usecnt;             
	int64_t         sfr_expire;             

	union sockaddr_in_4_6 sfr_laddr;        
	union sockaddr_in_4_6 sfr_faddr;        
	union sockaddr_in_4_6 sfr_gaddr;        

	uint8_t         sfr_ether_dhost[ETHER_ADDR_LEN]
	__attribute__((aligned(64)));
};
struct sk_stats_net_if {
	uuid_t          sns_nx_uuid;            
	char            sns_if_name[IFNAMSIZ];  

	struct netif_stats      sns_nifs;       
} __attribute__((aligned(64)));
struct sk_stats_flow_switch {
	uuid_t          sfs_nx_uuid;            
	char            sfs_if_name[IFNAMSIZ];  

	struct fsw_stats        sfs_fsws;       
} __attribute__((aligned(64)));
struct sk_stats_userstack {
	uuid_t                  sus_nx_uuid;    
	char            sus_if_name[IFNAMSIZ];  
	pid_t                   sus_owner_pid;  

	struct ip_stats         sus_ip;         
	struct ip6_stats        sus_ip6;        
	struct tcp_stats        sus_tcp;        
	struct udp_stats        sus_udp;        
	struct quic_stats       sus_quic;       
} __attribute__((aligned(64)));
struct sk_stats_flow_adv_ent {
	uuid_t          sfae_flow_id;           
	uint32_t        sfae_flags;             
};
struct sk_stats_flow_adv {
	uuid_t          sfa_nx_uuid;            
	char            sfa_if_name[IFNAMSIZ];  
	pid_t           sfa_owner_pid;          

	uint32_t        sfa_entries_count;      
	struct sk_stats_flow_adv_ent    sfa_entries[__counted_by(sfa_entries_count)]; 
};
struct netns_ctl_dump_header {
	union {
		uint32_t        ncdh_addr[4];
		struct in_addr  ncdh_inaddr;
		struct in6_addr ncdh_in6addr;
	};
	uint8_t         ncdh_addr_len;
	uint8_t         ncdh_proto;
	uint32_t        ncdh_n_records;
} __attribute__((aligned(32)));
struct netns_ctl_dump_record {
	in_port_t ncdr_port;
	in_port_t ncdr_port_end;
	uint32_t  ncdr_skywalk_refs;
	uint32_t  ncdr_bsd_refs;
	uint32_t  ncdr_pf_refs;
	uint32_t  ncdr_listener_refs;
} __attribute__((aligned(32)));
struct sk_stats_protons_token {
	uint8_t                 spt_protocol;
	uint32_t                spt_refcnt;
	pid_t                   spt_pid;
	pid_t                   spt_epid;
};
struct sk_stats_flowidns_header {
	uint64_t sfh_nallocs;
	uint64_t sfh_nreleases;
	uint64_t sfh_ncollisions;
	uint32_t sfh_domain;
	uint32_t sfh_nrecords;
} __attribute__((aligned(32)));
struct sk_stats_flowidns_record {
	union {
		uint32_t        _addr[4];
		struct in_addr  _v4;
		struct in6_addr _v6;
	} sfr_laddr;
	union {
		uint32_t        _addr[4];
		struct in_addr  _v4;
		struct in6_addr _v6;
	} sfr_raddr;
	union {
		struct {
			uint16_t _lport;
			uint16_t _rport;
		} sfr_ports;
		uint32_t sfr_spi;
		uint32_t sfr_protoid;
	};
	uint32_t sfr_flowid;
	uint8_t  sfr_ipproto;
	uint8_t  sfr_af;
} __attribute__((aligned(32)));
struct sk_stats_region {
	char            sreg_name[64];          
	uuid_t          sreg_uuid;              
	sk_stats_region_id_t sreg_id;           
	uint32_t        sreg_mode;              

	uint64_t        sreg_r_seg_size;        
	uint64_t        sreg_c_seg_size;        
	uint64_t        sreg_seg_cnt;           
	uint64_t        sreg_seg_objs;          
	uint64_t        sreg_r_obj_size;        
	uint64_t        sreg_r_obj_cnt;         
	uint64_t        sreg_c_obj_size;        
	uint64_t        sreg_c_obj_cnt;         
	uint64_t        sreg_align;             
	uint64_t        sreg_max_frags;         

	uint64_t        sreg_meminuse;          
	uint64_t        sreg_w_meminuse;        
	uint64_t        sreg_memtotal;          
	uint64_t        sreg_seginuse;          
	uint64_t        sreg_rescale;           
	uint64_t        sreg_hash_size;         
	uint64_t        sreg_alloc;             
	uint64_t        sreg_free;              
};
struct sk_stats_arena {
	char                    sar_name[64];
	sk_stats_arena_type_t   sar_type;
	uint64_t                sar_mapsize;
	uuid_t                  sar_regions_uuid[SREG_MAX];
	pid_t                   sar_mapped_pids[SK_STATS_ARENA_MAPPED_PID_MAX];
};
struct sk_stats_cache {
	char            sca_name[64];           
	uuid_t          sca_uuid;               
	uuid_t          sca_ruuid;              
	uint32_t        sca_mode;               
	uint64_t        sca_bufsize;            
	uint64_t        sca_objsize;            
	uint64_t        sca_chunksize;          
	uint64_t        sca_slabsize;           
	uint64_t        sca_bufalign;           
	uint64_t        sca_objalign;           

	uint64_t        sca_cpu_mag_size;       
	uint64_t        sca_cpu_mag_resize;     
	uint64_t        sca_cpu_mag_purge;      
	uint64_t        sca_cpu_mag_reap;       
	uint64_t        sca_depot_full;         
	uint64_t        sca_depot_empty;        
	uint64_t        sca_depot_ws_zero;      
	uint64_t        sca_depot_contention_factor; 

	uint64_t        sca_cpu_rounds;         
	uint64_t        sca_cpu_prounds;

	uint64_t        sca_sl_create;          
	uint64_t        sca_sl_destroy;         
	uint64_t        sca_sl_alloc;           
	uint64_t        sca_sl_free;            
	uint64_t        sca_sl_alloc_fail;      
	uint64_t        sca_sl_partial;         
	uint64_t        sca_sl_empty;           
	uint64_t        sca_sl_bufinuse;        
	uint64_t        sca_sl_rescale;         
	uint64_t        sca_sl_hash_size;       
};
struct skmem_sysctl {
	uint32_t        version;
	struct {
		SKMEM_SYSCTL_TCP_LIST
	} tcp;
	struct {
		struct {
			SKMEM_SYSCTL_KERN_IPC_LIST
		} ipc;
	} kern;
} skmem_sysctl;
struct acct {
	char      ac_comm[10];  
	comp_t    ac_utime;     
	comp_t    ac_stime;     
	comp_t    ac_etime;     
	u_int32_t ac_btime;     
	uid_t     ac_uid;       
	gid_t     ac_gid;       
	u_int16_t ac_mem;       
	comp_t    ac_io;        
	dev_t     ac_tty;       

	u_int8_t  ac_flag;      
};
struct user_aiocb {
	int             aio_fildes;             
	off_t           aio_offset; 
	user_addr_t     aio_buf;                
	user_size_t     aio_nbytes;             
	int             aio_reqprio;    
	struct user_sigevent aio_sigevent;      
	int             aio_lio_opcode;         
};
struct user64_aiocb {
	int             aio_fildes;             
	user64_off_t            aio_offset; 
	user64_addr_t   aio_buf;                
	user64_size_t   aio_nbytes;             
	int             aio_reqprio;    
	struct user64_sigevent aio_sigevent;    
	int             aio_lio_opcode;         
};
struct user32_aiocb {
	int             aio_fildes;             
	user32_off_t            aio_offset;             
	user32_addr_t   aio_buf;                
	user32_size_t   aio_nbytes;             
	int             aio_reqprio;            
	struct user32_sigevent  aio_sigevent;           
	int             aio_lio_opcode;         
};
struct proc_taskinfo_internal {
	uint64_t                pti_virtual_size;   
	uint64_t                pti_resident_size;  
	uint64_t                pti_total_user;         
	uint64_t                pti_total_system;
	uint64_t                pti_threads_user;       
	uint64_t                pti_threads_system;
	int32_t                 pti_policy;             
	int32_t                 pti_faults;             
	int32_t                 pti_pageins;    
	int32_t                 pti_cow_faults; 
	int32_t                 pti_messages_sent;      
	int32_t                 pti_messages_received; 
	int32_t                 pti_syscalls_mach;  
	int32_t                 pti_syscalls_unix;  
	int32_t                 pti_csw;            
	int32_t                 pti_threadnum;          
	int32_t                 pti_numrunning;         
	int32_t                 pti_priority;           
};
struct proc_threadinfo_internal {
	uint64_t                pth_user_time;      
	uint64_t                pth_system_time;    
	int32_t                 pth_cpu_usage;      
	int32_t                 pth_policy;             
	int32_t                 pth_run_state;      
	int32_t                 pth_flags;          
	int32_t                 pth_sleep_time;     
	int32_t                 pth_curpri;             
	int32_t                 pth_priority;           
	int32_t                 pth_maxpriority;                
	char                    pth_name[MAXTHREADNAMESIZE];            
};
struct proc_threadschedinfo_internal {
	uint64_t               int_time_ns;         
};
struct proc_regioninfo_internal {
	uint32_t                pri_protection;
	uint32_t                pri_max_protection;
	uint32_t                pri_inheritance;
	uint32_t                pri_flags;              
	uint64_t                pri_offset;
	uint32_t                pri_behavior;
	uint32_t                pri_user_wired_count;
	uint32_t                pri_user_tag;
	uint32_t                pri_pages_resident;
	uint32_t                pri_pages_shared_now_private;
	uint32_t                pri_pages_swapped_out;
	uint32_t                pri_pages_dirtied;
	uint32_t                pri_ref_count;
	uint32_t                pri_shadow_depth;
	uint32_t                pri_share_mode;
	uint32_t                pri_private_pages_resident;
	uint32_t                pri_shared_pages_resident;
	uint32_t                pri_obj_id;
	uint32_t                pri_depth;
	uint64_t                pri_address;
	uint64_t                pri_size;
};
struct bufattr {
	uint64_t ba_flags;      
	void *ba_verify_ctx;
};
struct buf {
	LIST_ENTRY(buf) b_hash;         
	LIST_ENTRY(buf) b_vnbufs;       
	TAILQ_ENTRY(buf) b_freelist;    
	int     b_timestamp;            
	struct timeval b_timestamp_tv; 
	int     b_whichq;               
	volatile uint32_t       b_flags;        
	volatile uint32_t       b_lflags;       
	int     b_error;                
	int     b_bufsize;              
	int     b_bcount;               
	int     b_resid;                
	dev_t   b_dev;                  
	uintptr_t       b_datap;        
	daddr64_t       b_lblkno;       
	daddr64_t       b_blkno;        
	void    (*b_iodone)(buf_t, void *);     
	vnode_t b_vp;                   
	kauth_cred_t b_rcred;           
	kauth_cred_t b_wcred;           
	void *  b_upl;                  
	buf_t   b_real_bp;              
	TAILQ_ENTRY(buf)        b_act;  
	void *  b_drvdata;              
	void *  b_fsprivate;            
	void *  b_transaction;          
	int     b_dirtyoff;             
	int     b_dirtyend;             
	int     b_validoff;             
	int     b_validend;             

	uint32_t b_redundancy_flags;

	proc_t  b_proc;                 
	struct bufattr b_attr;
	off_t   b_lblksize;           
	vnode_t b_vnop_vp;            
};
struct bufstats {
	long    bufs_incore;            
	long    bufs_busyincore;        
	long    bufs_vmhits;            
	long    bufs_miss;                      
	long    bufs_sleeps;            
	long    bufs_eblk;                      
	uint32_t    bufs_iobufmax;          
	uint32_t    bufs_iobufinuse;        
	long    bufs_iobufsleeps;       
	long    bufs_iobufinuse_vdev;   
};
struct _cs_profile_register_t {
	uuid_t uuid;

	const void *sig_data;
	size_t sig_size;

	const void *data;
	size_t size;
} cs_profile_register_t;
struct commpage_timeofday_data {
	uint64_t        TimeStamp_tick;
	uint64_t        TimeStamp_sec;
	uint64_t        TimeStamp_frac;
	uint64_t        Ticks_scale;
	uint64_t        Ticks_per_sec;
} new_commpage_timeofday_data_t;
struct bdevsw {
	open_close_fcn_t        *d_open;
	open_close_fcn_t        *d_close;
	strategy_fcn_t          *d_strategy;
	ioctl_fcn_t             *d_ioctl;
	dump_fcn_t              *d_dump;
	psize_fcn_t             *d_psize;
	int                     d_type;
};
struct cdevsw {
	open_close_fcn_t        *d_open;
	open_close_fcn_t        *d_close;
	read_write_fcn_t        *d_read;
	read_write_fcn_t        *d_write;
	ioctl_fcn_t             *d_ioctl;
	stop_fcn_t              *d_stop;
	reset_fcn_t             *d_reset;
	struct  tty             **d_ttys;
	select_fcn_t            *d_select;
	mmap_fcn_t              *d_mmap;
	strategy_fcn_t          *d_strategy;
	rsvd_fcn_t              *d_reserved_1;
	rsvd_fcn_t              *d_reserved_2;
	int                     d_type;
};
struct linesw {
	l_open_t        *l_open;
	l_close_t       *l_close;
	l_read_t        *l_read;
	l_write_t       *l_write;
	l_ioctl_t       *l_ioctl;
	l_rint_t        *l_rint;
	l_start_t       *l_start;
	l_modem_t       *l_modem;
};
struct swdevt {
	dev_t   sw_dev;
	int     sw_flags;
	int     sw_nblks;
	struct  vnode *sw_vp;
};
struct fcpx {
	aes_encrypt_ctx         *cpx_iv_aes_ctx_ptr;
	cpx_flags_t             cpx_flags;
	uint16_t                cpx_max_key_len;
	uint16_t                cpx_key_len;
	uint8_t                 cpx_cached_key[VFS_CP_MAX_CACHEBUFLEN];
} fcpx_t;
struct cp_key {
	uint8_t len;
	void *key;
} cp_key_t;
struct {
	void     *key;
	unsigned key_len;
	void     *iv_key;
	unsigned iv_key_len;
	uint32_t flags;
} cp_raw_key_s;
struct {
	void     *key;
	unsigned key_len;
	cp_key_class_t dp_class;
} cp_wrapped_key_s;
struct {
	union {
		ino64_t                 inode;
		cp_crypto_id_t  crypto_id;
	};
	uint32_t                        volume;
	pid_t                           pid;
	uid_t                           uid;
	cp_key_revision_t       key_revision;
} cp_cred_s;
struct {
	void *buf;
	user_ssize_t size;
} decmpfs_vector;
struct decmpfs_cnode {
	uint8_t cmp_state;
	uint8_t cmp_minimal_xattr;   
	uint32_t cmp_type;
	uint32_t lockcount;
	void    *lockowner;          
	uint64_t uncompressed_size __attribute__((aligned(8)));
	uint64_t nchildren __attribute__((aligned(8))); 
	uint64_t total_size __attribute__((aligned(8)));
	uint64_t decompression_flags;
	lck_rw_t compressed_data_lock;
};
struct {
	int                                   decmpfs_registration;
	decmpfs_validate_compressed_file_func validate;
	decmpfs_adjust_fetch_region_func      adjust_fetch;
	decmpfs_fetch_uncompressed_data_func  fetch;
	decmpfs_free_compressed_data_func     free_data;
	decmpfs_get_decompression_flags_func  get_flags;
} decmpfs_registration;
struct{
	uint64_t               offset;
	uint64_t               length;
} dk_extent_t;
struct{
	char                   path[128];
} dk_firmware_path_t;
struct{
	uint64_t               blockCount;
	uint32_t               blockSize;

	uint8_t                reserved0096[4];    
} dk_format_capacity_t;
struct{
	dk_format_capacity_t * capacities;
	uint32_t               capacitiesCount;    

	uint8_t                reserved0096[4];    
} dk_format_capacities_t;
struct{
	uint64_t               offset;
	uint64_t               length;

	uint32_t               options;

	uint8_t                reserved0160[4];    
} dk_synchronize_t;
struct{
	dk_extent_t *          extents;
	uint32_t               extentsCount;

	uint32_t               options;

} dk_unmap_t;
struct{
	uint64_t           flags;
	uint64_t           hotfile_size;           
	uint64_t           hibernate_minsize;
	uint64_t           swapfile_pinning;

	uint64_t           padding[4];
} dk_corestorage_info_t;
struct{
	uint64_t           offset;
	uint64_t           length;
	uint8_t            provisionType;
	uint8_t            reserved[7];
} dk_provision_extent_t;
struct{
	uint64_t                offset;         
	uint64_t                length;         
	uint64_t                options;        
	uint32_t                reserved;       
	uint32_t                extentsCount;   
	dk_provision_extent_t * extents;        
} dk_provision_status_t;
struct{
	uint64_t               options;        
	uint64_t               reserved;       
	uint64_t               description_size;
	char *                 description;
} dk_error_description_t;
struct{
	uint64_t               offset;
	uint64_t               length;

	uint8_t                reserved0128[12];   

	dev_t                  dev;
} dk_physical_extent_t;
struct{
	dk_extent_t *          extents;
	uint32_t               extentsCount;

	uint8_t                tier;

	uint8_t                reserved0104[3];    
} dk_set_tier_t;
struct{
	boolean_t mi_mdev; 
	boolean_t mi_phys; 
	uint32_t mi_base; 
	uint64_t mi_size; 
} dk_memdev_info_t;
struct _dk_cs_pin {
	dk_extent_t     cp_extent;
	int64_t         cp_flags;
} _dk_cs_pin_t;
struct _dk_cs_map {
	dk_extent_t     cm_extent;
	uint64_t        cm_bytes_mapped;
} _dk_cs_map_t;
struct _dk_cs_unmap {
	dk_extent_t                  *extents;
	uint32_t                     extentsCount;
	uint32_t                     options;
} _dk_cs_unmap_t;
struct dk_apfs_wbc_range {
	dev_t dev;              
	uint32_t count;         
	dk_extent_t extents[2]; 
} dk_apfs_wbc_range_t;
struct doc_tombstone {
	struct vnode     *t_lastop_parent;
	struct vnode     *t_lastop_item;
	uint32_t                  t_lastop_parent_vid;
	uint32_t                  t_lastop_item_vid;
	uint64_t          t_lastop_fileid;
	uint64_t          t_lastop_document_id;
	unsigned char     t_lastop_filename[NAME_MAX + 1];
};
struct domain_old {
	int     dom_family;             
	const char *dom_name;
	void    (*dom_init)(void);      
	int     (*dom_externalize)      
	(struct mbuf *);
	void    (*dom_dispose)          
	(struct mbuf *);
	struct  protosw_old *dom_protosw; 
	struct  domain_old *dom_next;
	int     (*dom_rtattach)         
	(void **, int);
	int     dom_rtoffset;           
	int     dom_maxrtkey;           
	int     dom_protohdrlen;        
	int     dom_refs;               
	lck_mtx_t *dom_mtx;             
	uint32_t dom_flags;
	uint32_t reserved[2];
};
struct domain {
	int     dom_family;             
	uint32_t dom_flags;             
	uint32_t dom_refs;              
	lck_mtx_t *dom_mtx;             
	decl_lck_mtx_data(, dom_mtx_s);
	TAILQ_ENTRY(domain) dom_entry;  
	TAILQ_HEAD(, protosw) dom_protosw; 
	void    (*dom_init)             
	(struct domain *);
	int     (*dom_externalize)      
	(struct mbuf *);
	void    (*dom_dispose)          
	(struct mbuf *);
	int     (*dom_rtattach)         
	(void **, int);
	int     dom_rtoffset;           
	int     dom_maxrtkey;           
	int     dom_protohdrlen;        
	const char *dom_name;
	struct domain_old *dom_old;     
};
struct dtrace_diftype {
        uint8_t dtdt_kind;              
        uint8_t dtdt_ckind;             
        uint8_t dtdt_flags;             
        uint8_t dtdt_pad;               
        uint32_t dtdt_size;             
} dtrace_diftype_t;
struct dtrace_difv {
        uint32_t dtdv_name;             
        uint32_t dtdv_id;               
        uint8_t dtdv_kind;              
        uint8_t dtdv_scope;             
        uint16_t dtdv_flags;            
        dtrace_diftype_t dtdv_type;     
} dtrace_difv_t;
struct dof_hdr {
        uint8_t dofh_ident[DOF_ID_SIZE]; 
        uint32_t dofh_flags;            
        uint32_t dofh_hdrsize;          
        uint32_t dofh_secsize;          
        uint32_t dofh_secnum;           
        uint64_t dofh_secoff;           
        uint64_t dofh_loadsz;           
        uint64_t dofh_filesz;           
        uint64_t dofh_pad;              
} dof_hdr_t;
struct dof_sec {
        uint32_t dofs_type;     
        uint32_t dofs_align;    
        uint32_t dofs_flags;    
        uint32_t dofs_entsize;  
        uint64_t dofs_offset;   
        uint64_t dofs_size;     
} dof_sec_t;
struct dof_ecbdesc {
        dof_secidx_t dofe_probes;       
        dof_secidx_t dofe_pred;         
        dof_secidx_t dofe_actions;      
        uint32_t dofe_pad;              
        uint64_t dofe_uarg;             
} dof_ecbdesc_t;
struct dof_probedesc {
        dof_secidx_t dofp_strtab;       
        dof_stridx_t dofp_provider;     
        dof_stridx_t dofp_mod;          
        dof_stridx_t dofp_func;         
        dof_stridx_t dofp_name;         
        uint32_t dofp_id;               
} dof_probedesc_t;
struct dof_actdesc {
        dof_secidx_t dofa_difo;         
        dof_secidx_t dofa_strtab;       
        uint32_t dofa_kind;             
        uint32_t dofa_ntuple;           
        uint64_t dofa_arg;              
        uint64_t dofa_uarg;             
} dof_actdesc_t;
struct dof_difohdr {
        dtrace_diftype_t dofd_rtype;    
        dof_secidx_t dofd_links[1];     
} dof_difohdr_t;
struct dof_relohdr {
        dof_secidx_t dofr_strtab;       
        dof_secidx_t dofr_relsec;       
        dof_secidx_t dofr_tgtsec;       
} dof_relohdr_t;
struct dof_relodesc {
        dof_stridx_t dofr_name;         
        uint32_t dofr_type;             
        uint64_t dofr_offset;           
        uint64_t dofr_data;             
} dof_relodesc_t;
struct dof_optdesc {
        uint32_t dofo_option;           
        dof_secidx_t dofo_strtab;       
        uint64_t dofo_value;            
} dof_optdesc_t;
struct dof_provider {
	dof_secidx_t dofpv_strtab;	
	dof_secidx_t dofpv_probes;	
	dof_secidx_t dofpv_prargs;	
	dof_secidx_t dofpv_proffs;	
	dof_stridx_t dofpv_name;	
	dof_attr_t dofpv_provattr;	
	dof_attr_t dofpv_modattr;	
	dof_attr_t dofpv_funcattr;	
	dof_attr_t dofpv_nameattr;	
	dof_attr_t dofpv_argsattr;	
	dof_secidx_t dofpv_prenoffs;	
} dof_provider_t;
struct dof_probe {
	uint64_t dofpr_addr;		
	dof_stridx_t dofpr_func;	
	dof_stridx_t dofpr_name;	
	dof_stridx_t dofpr_nargv;	
	dof_stridx_t dofpr_xargv;	
	uint32_t dofpr_argidx;		
	uint32_t dofpr_offidx;		
	uint8_t dofpr_nargc;		
	uint8_t dofpr_xargc;		
	uint16_t dofpr_noffs;		
	uint32_t dofpr_enoffidx;	
	uint16_t dofpr_nenoffs;		
	uint16_t dofpr_pad1;		
	uint32_t dofpr_pad2;		
} dof_probe_t;
struct dof_xlator {
        dof_secidx_t dofxl_members;     
        dof_secidx_t dofxl_strtab;      
        dof_stridx_t dofxl_argv;        
        uint32_t dofxl_argc;            
        dof_stridx_t dofxl_type;        
        dof_attr_t dofxl_attr;          
} dof_xlator_t;
struct dof_xlmember {
        dof_secidx_t dofxm_difo;        
        dof_stridx_t dofxm_name;        
        dtrace_diftype_t dofxm_type;    
} dof_xlmember_t;
struct dof_xlref {
        dof_secidx_t dofxr_xlator;      
        uint32_t dofxr_member;          
        uint32_t dofxr_argn;            
} dof_xlref_t;
struct dtrace_difo {
        dif_instr_t *dtdo_buf;          
        uint64_t *dtdo_inttab;          
        char *dtdo_strtab;              
        dtrace_difv_t *dtdo_vartab;     
        uint_t dtdo_len;                
        uint_t dtdo_intlen;             
        uint_t dtdo_strlen;             
        uint_t dtdo_varlen;             
        dtrace_diftype_t dtdo_rtype;    
        uint_t dtdo_refcnt;             
        uint_t dtdo_destructive;        
        dof_relodesc_t *dtdo_kreltab;   
        dof_relodesc_t *dtdo_ureltab;   
        struct dt_node **dtdo_xlmtab;   
        uint_t dtdo_krelen;             
        uint_t dtdo_urelen;             
        uint_t dtdo_xlmlen;             
} dtrace_difo_t;
struct dtrace_probedesc {
        dtrace_id_t dtpd_id;                    
        char dtpd_provider[DTRACE_PROVNAMELEN]; 
        char dtpd_mod[DTRACE_MODNAMELEN];       
        char dtpd_func[DTRACE_FUNCNAMELEN];     
        char dtpd_name[DTRACE_NAMELEN];         
} dtrace_probedesc_t;
struct dtrace_repldesc {
        dtrace_probedesc_t dtrpd_match;         
        dtrace_probedesc_t dtrpd_create;        
} dtrace_repldesc_t;
struct dtrace_preddesc {
        dtrace_difo_t *dtpdd_difo;              
        struct dtrace_predicate *dtpdd_predicate; 
} dtrace_preddesc_t;
struct dtrace_actdesc {
        dtrace_difo_t *dtad_difo;               
        struct dtrace_actdesc *dtad_next;       
        dtrace_actkind_t dtad_kind;             
        uint32_t dtad_ntuple;                   
        uint64_t dtad_arg;                      
        uint64_t dtad_uarg;                     
        int dtad_refcnt;                        
} dtrace_actdesc_t;
struct dtrace_ecbdesc {
        dtrace_actdesc_t *dted_action;          
        dtrace_preddesc_t dted_pred;            
        dtrace_probedesc_t dted_probe;          
        uint64_t dted_uarg;                     
        int dted_refcnt;                        
        uint64_t dted_probegen;                 
} dtrace_ecbdesc_t;
struct dtrace_recdesc {
        dtrace_actkind_t dtrd_action;           
        uint32_t dtrd_size;                     
        uint32_t dtrd_offset;                   
        uint16_t dtrd_alignment;                
        uint16_t dtrd_format;                   
        uint64_t dtrd_arg;                      
        uint64_t dtrd_uarg;                     
} dtrace_recdesc_t;
struct dtrace_eprobedesc {
        dtrace_epid_t dtepd_epid;               
        dtrace_id_t dtepd_probeid;              
        uint64_t dtepd_uarg;                    
        uint32_t dtepd_size;                    
        int dtepd_nrecs;                        
        dtrace_recdesc_t dtepd_rec[1];          
} dtrace_eprobedesc_t;
struct dtrace_aggdesc {
	DTRACE_PTR(char, dtagd_name);		
	dtrace_aggvarid_t dtagd_varid;		
	int dtagd_flags;			
	dtrace_aggid_t dtagd_id;		
	dtrace_epid_t dtagd_epid;		
	uint32_t dtagd_size;			
	int dtagd_nrecs;			
	uint32_t dtagd_pad;			
	dtrace_recdesc_t dtagd_rec[1];		
} dtrace_aggdesc_t;
struct dtrace_fmtdesc {
        DTRACE_PTR(char, dtfd_string);          
        int dtfd_length;                        
        uint16_t dtfd_format;                   
} dtrace_fmtdesc_t;
struct dtrace_bufdesc {
        uint64_t dtbd_size;                     
        uint32_t dtbd_cpu;                      
        uint32_t dtbd_errors;                   
        uint64_t dtbd_drops;                    
        DTRACE_PTR(char, dtbd_data);            
        uint64_t dtbd_oldest;                   
	uint64_t dtbd_timestamp;		
} dtrace_bufdesc_t;
struct dtrace_rechdr {
	dtrace_epid_t dtrh_epid;		
	uint32_t dtrh_timestamp_hi;		
	uint32_t dtrh_timestamp_lo;		
} dtrace_rechdr_t;
struct dtrace_status {
        uint64_t dtst_dyndrops;                 
        uint64_t dtst_dyndrops_rinsing;         
        uint64_t dtst_dyndrops_dirty;           
        uint64_t dtst_specdrops;                
        uint64_t dtst_specdrops_busy;           
        uint64_t dtst_specdrops_unavail;        
        uint64_t dtst_errors;                   
        uint64_t dtst_filled;                   
        uint64_t dtst_stkstroverflows;          
        uint64_t dtst_dblerrors;                
        char dtst_killed;                       
        char dtst_exiting;                      
        char dtst_pad[6];                       
} dtrace_status_t;
struct dtrace_conf {
        uint_t dtc_difversion;                  
        uint_t dtc_difintregs;                  
        uint_t dtc_diftupregs;                  
        uint_t dtc_ctfmodel;                    
        uint_t dtc_pad[8];                      
} dtrace_conf_t;
struct dtrace_argdesc {
        dtrace_id_t dtargd_id;                  
        int dtargd_ndx;                         
        int dtargd_mapping;                     
        char dtargd_native[DTRACE_ARGTYPELEN];  
        char dtargd_xlate[DTRACE_ARGTYPELEN];   
} dtrace_argdesc_t;
struct dtrace_ppriv {
	uint32_t dtpp_flags;			
	uid_t dtpp_uid;				
	zoneid_t dtpp_zoneid;			
} dtrace_ppriv_t;
struct dtrace_attribute {
        dtrace_stability_t dtat_name;           
        dtrace_stability_t dtat_data;           
        dtrace_class_t dtat_class;              
} dtrace_attribute_t;
struct dtrace_pattr {
        dtrace_attribute_t dtpa_provider;       
        dtrace_attribute_t dtpa_mod;            
        dtrace_attribute_t dtpa_func;           
        dtrace_attribute_t dtpa_name;           
        dtrace_attribute_t dtpa_args;           
} dtrace_pattr_t;
struct dtrace_providerdesc {
        char dtvd_name[DTRACE_PROVNAMELEN];     
        dtrace_pattr_t dtvd_attr;               
        dtrace_ppriv_t dtvd_priv;               
} dtrace_providerdesc_t;
struct dof_helper {
        char dofhp_mod[DTRACE_MODNAMELEN];      
        uint64_t dofhp_addr;                    
        uint64_t dofhp_dof;                     
} dof_helper_t;
struct dof_ioctl_data {
	uint64_t dofiod_count;
	dof_helper_t dofiod_helpers[1];
} dof_ioctl_data_t;
struct dtrace_probe {
	dtrace_id_t dtpr_id;			
	dtrace_ecb_t *dtpr_ecb;			
	dtrace_ecb_t *dtpr_ecb_last;		
	void *dtpr_arg;				
	dtrace_cacheid_t dtpr_predcache;	
	int dtpr_aframes;			
	dtrace_provider_t *dtpr_provider;	
	char *dtpr_mod;				
	char *dtpr_func;			
	char *dtpr_name;			
	dtrace_probe_t *dtpr_nextprov;		
	dtrace_probe_t *dtpr_prevprov;		
	dtrace_probe_t *dtpr_nextmod;		
	dtrace_probe_t *dtpr_prevmod;		
	dtrace_probe_t *dtpr_nextfunc;		
	dtrace_probe_t *dtpr_prevfunc;		
	dtrace_probe_t *dtpr_nextname;		
	dtrace_probe_t *dtpr_prevname;		
	dtrace_genid_t dtpr_gen;		
};
struct dtrace_probekey {
	const char *dtpk_prov;			
	dtrace_probekey_f *dtpk_pmatch;		
	const char *dtpk_mod;			
	dtrace_probekey_f *dtpk_mmatch;		
	const char *dtpk_func;			
	dtrace_probekey_f *dtpk_fmatch;		
	const char *dtpk_name;			
	dtrace_probekey_f *dtpk_nmatch;		
	dtrace_id_t dtpk_id;			
} dtrace_probekey_t;
struct dtrace_hashbucket {
	struct dtrace_hashbucket *dthb_next;	
	void *dthb_chain;			
	int dthb_len;				
} dtrace_hashbucket_t;
struct dtrace_hash {
	dtrace_hashbucket_t **dth_tab;	
	int dth_size;			
	int dth_mask;			
	int dth_nbuckets;		
	uintptr_t dth_nextoffs;		
	uintptr_t dth_prevoffs;		
	dtrace_strkey_f *dth_getstr;	
	uintptr_t dth_stroffs;		
} dtrace_hash_t;
struct dtrace_ecb {
	dtrace_epid_t dte_epid;			
	uint32_t dte_alignment;			
	size_t dte_needed;			
	size_t dte_size;			
	dtrace_predicate_t *dte_predicate;	
	dtrace_action_t *dte_action;		
	dtrace_ecb_t *dte_next;			
	dtrace_state_t *dte_state;		
	uint32_t dte_cond;			
	dtrace_probe_t *dte_probe;		
	dtrace_action_t *dte_action_last;	
	uint64_t dte_uarg;			
};
struct dtrace_predicate {
	dtrace_difo_t *dtp_difo;		
	dtrace_cacheid_t dtp_cacheid;		
	int dtp_refcnt;				
};
struct dtrace_action {
	dtrace_actkind_t dta_kind;		
	uint16_t dta_intuple;			
	uint32_t dta_refcnt;			
	dtrace_difo_t *dta_difo;		
	dtrace_recdesc_t dta_rec;		
	dtrace_action_t *dta_prev;		
	dtrace_action_t *dta_next;		
};
struct dtrace_aggregation {
	dtrace_action_t dtag_action;		
	dtrace_aggid_t dtag_id;			
	dtrace_ecb_t *dtag_ecb;			
	dtrace_action_t *dtag_first;		
	uint32_t dtag_base;			
	uint8_t dtag_hasarg;			
	uint64_t dtag_initial;			
	void (*dtag_aggregate)(uint64_t *, uint64_t, uint64_t);
} dtrace_aggregation_t;
struct dtrace_buffer {
	uint64_t dtb_offset;			
	uint64_t dtb_cur_limit;			
	uint64_t dtb_limit;			
	uint64_t dtb_size;			
	uint32_t dtb_flags;			
	uint32_t dtb_drops;			
	caddr_t dtb_tomax;			
	caddr_t dtb_xamot;			
	uint32_t dtb_xamot_flags;		
	uint32_t dtb_xamot_drops;		
	uint64_t dtb_xamot_offset;		
	uint32_t dtb_errors;			
	uint32_t dtb_xamot_errors;		
	uint64_t dtb_pad1;
	uint64_t dtb_switched;			
	uint64_t dtb_interval;			
	uint64_t dtb_pad2[4];			
} dtrace_buffer_t;
struct dtrace_aggkey {
	uint32_t dtak_hashval;			
	uint32_t dtak_action:4;			
	uint32_t dtak_size:28;			
	caddr_t dtak_data;			
	struct dtrace_aggkey *dtak_next;	
} dtrace_aggkey_t;
struct dtrace_aggbuffer {
	uintptr_t dtagb_hashsize;		
	uintptr_t dtagb_free;			
	dtrace_aggkey_t **dtagb_hash;		
} dtrace_aggbuffer_t;
struct dtrace_speculation {
	dtrace_speculation_state_t dtsp_state;	
	int dtsp_cleaning;			
	dtrace_buffer_t *dtsp_buffer;		
} dtrace_speculation_t;
struct dtrace_key {
	uint64_t dttk_value;			
	uint64_t dttk_size;			
} dtrace_key_t;
struct dtrace_tuple {
	uint32_t dtt_nkeys;			
	uint32_t dtt_pad;			
	dtrace_key_t dtt_key[1];		
} dtrace_tuple_t;
struct dtrace_dynvar {
	uint64_t dtdv_hashval;			
	struct dtrace_dynvar *dtdv_next;	
	void *dtdv_data;			
	dtrace_tuple_t dtdv_tuple;		
} dtrace_dynvar_t;
struct dtrace_dynhash {
	dtrace_dynvar_t *dtdh_chain;		
	uintptr_t dtdh_lock;			
} dtrace_dynhash_t;
struct dtrace_dstate_percpu {
	dtrace_dynvar_t *dtdsc_free;		
	dtrace_dynvar_t *dtdsc_dirty;		
	dtrace_dynvar_t *dtdsc_rinsing;		
	dtrace_dynvar_t *dtdsc_clean;		
	uint64_t dtdsc_drops;			
	uint64_t dtdsc_dirty_drops;		
	uint64_t dtdsc_rinsing_drops;		
} dtrace_dstate_percpu_t;
struct dtrace_dstate {
	void *dtds_base;			
	size_t dtds_size;			
	size_t dtds_hashsize;			
	size_t dtds_chunksize;			
	dtrace_dynhash_t *dtds_hash;		
	dtrace_dstate_state_t dtds_state;	
	dtrace_dstate_percpu_t *__zpercpu dtds_percpu;	
} dtrace_dstate_t;
struct dtrace_statvar {
	uint64_t dtsv_data;			
	size_t dtsv_size;			
	int dtsv_refcnt;			
	dtrace_difv_t dtsv_var;			
} dtrace_statvar_t;
struct dtrace_vstate {
	dtrace_state_t *dtvs_state;		
	dtrace_statvar_t **dtvs_globals;	
	int dtvs_nglobals;			
	dtrace_difv_t *dtvs_tlocals;		
	int dtvs_ntlocals;			
	dtrace_statvar_t **dtvs_locals;		
	int dtvs_nlocals;			
	dtrace_dstate_t dtvs_dynvars;		
} dtrace_vstate_t;
struct dtrace_mstate {
	uintptr_t dtms_scratch_base;		
	uintptr_t dtms_scratch_ptr;		
	size_t dtms_scratch_size;		
	uint32_t dtms_present;			
	uint64_t dtms_arg[5];			
	dtrace_epid_t dtms_epid;		
	uint64_t dtms_timestamp;		
	hrtime_t dtms_walltimestamp;		
	uint64_t dtms_machtimestamp;		
	uint64_t dtms_machctimestamp;		
	int dtms_stackdepth;			
	int dtms_ustackdepth;			
	struct dtrace_probe *dtms_probe;	
	uintptr_t dtms_caller;			
	uint64_t dtms_ucaller;			
	int dtms_ipl;				
	int dtms_fltoffs;			
	uintptr_t dtms_strtok;			
	uintptr_t dtms_strtok_limit;		
	uint32_t dtms_access;			
	dtrace_difo_t *dtms_difo;		
} dtrace_mstate_t;
struct dtrace_helper_action {
	int dtha_generation;			
	int dtha_nactions;			
	dtrace_difo_t *dtha_predicate;		
	dtrace_difo_t **dtha_actions;		
	struct dtrace_helper_action *dtha_next;	
} dtrace_helper_action_t;
struct dtrace_helper_provider {
	int dthp_generation;			
	uint32_t dthp_ref;			
	dof_helper_t dthp_prov;			
} dtrace_helper_provider_t;
struct dtrace_helpers {
	dtrace_helper_action_t **dthps_actions;	
	dtrace_vstate_t dthps_vstate;		
	dtrace_helper_provider_t **dthps_provs;	
	uint_t dthps_nprovs;			
	uint_t dthps_maxprovs;			
	int dthps_generation;			
	pid_t dthps_pid;			
	int dthps_deferred;			
	struct dtrace_helpers *dthps_next;	
	struct dtrace_helpers *dthps_prev;	
} dtrace_helpers_t;
struct dtrace_helptrace {
	dtrace_helper_action_t	*dtht_helper;	
	int dtht_where;				
	int dtht_nlocals;			
	int dtht_fault;				
	int dtht_fltoffs;			
	uint64_t dtht_illval;			
	uint64_t dtht_locals[1];		
} dtrace_helptrace_t;
struct dtrace_cred {
	cred_t			*dcr_cred;
	uint8_t			dcr_destructive;
	uint8_t			dcr_visible;
	uint16_t		dcr_action;
} dtrace_cred_t;
struct dtrace_format {
	uint64_t dtf_refcount;
	char dtf_str[];
} dtrace_format_t;
struct dtrace_state {
	dev_t dts_dev;				
	int dts_necbs;				
	dtrace_ecb_t **dts_ecbs;		
	dtrace_epid_t dts_epid;			
	size_t dts_needed;			
	struct dtrace_state *dts_anon;		
	dtrace_activity_t dts_activity;		
	dtrace_vstate_t dts_vstate;		
	dtrace_buffer_t *dts_buffer;		
	dtrace_buffer_t *dts_aggbuffer;		
	dtrace_speculation_t *dts_speculations;	
	int dts_nspeculations;			
	int dts_naggregations;			
	dtrace_aggregation_t **dts_aggregations; 
	vmem_t *dts_aggid_arena;		
	uint64_t dts_errors;			
	uint32_t dts_speculations_busy;		
	uint32_t dts_speculations_unavail;	
	uint32_t dts_stkstroverflows;		
	uint32_t dts_dblerrors;			
	uint32_t dts_reserve;			
	hrtime_t dts_laststatus;		
	cyclic_id_t dts_cleaner;		
	cyclic_id_t dts_deadman;		
	hrtime_t dts_alive;			
	char dts_speculates;			
	char dts_destructive;			
	int dts_nformats;			
	dtrace_format_t **dts_formats;		
	dtrace_optval_t dts_options[DTRACEOPT_MAX]; 
	dtrace_cred_t dts_cred;			
	size_t dts_nretained;			
	uint64_t dts_arg_error_illval;
	uint32_t dts_buf_over_limit;		
	uint64_t **dts_rstate;			
};
struct dtrace_provider {
	dtrace_pattr_t dtpv_attr;		
	dtrace_ppriv_t dtpv_priv;		
	dtrace_pops_t dtpv_pops;		
	char *dtpv_name;			
	void *dtpv_arg;				
	uint_t dtpv_defunct;			
	struct dtrace_provider *dtpv_next;	
	uint64_t dtpv_probe_count;		
	uint64_t dtpv_ecb_count;		
};
struct dtrace_meta {
	dtrace_mops_t dtm_mops;			
	char *dtm_name;				
	void *dtm_arg;				
	uint64_t dtm_count;			
};
struct dtrace_enabling {
	dtrace_ecbdesc_t **dten_desc;		
	int dten_ndesc;				
	int dten_maxdesc;			
	dtrace_vstate_t *dten_vstate;		
	dtrace_genid_t dten_probegen;		
	dtrace_ecbdesc_t *dten_current;		
	int dten_error;				
	int dten_primed;			
	struct dtrace_enabling *dten_prev;	
	struct dtrace_enabling *dten_next;	
} dtrace_enabling_t;
struct dtrace_anon {
	dtrace_state_t *dta_state;		
	dtrace_enabling_t *dta_enabling;	
	processorid_t dta_beganon;		
} dtrace_anon_t;
struct dtrace_string {
	dtrace_string_t *dtst_next;
	dtrace_string_t *dtst_prev;
	uint32_t dtst_refcount;
	char dtst_str[];
} dtrace_string_t;
struct dtrace_match_cond {
	int (*dmc_func)(dtrace_probedesc_t*, void*);
	void *dmc_data;
} dtrace_match_cond_t;
struct dtrace_toxrange {
	uintptr_t	dtt_base;		
	uintptr_t	dtt_limit;		
} dtrace_toxrange_t;
struct dtrace_ptss_page_entry {
	struct dtrace_ptss_page_entry*  next;
	user_addr_t                     addr;
	user_addr_t                     write_addr;
};
struct dtrace_ptss_page {
	struct dtrace_ptss_page*       next;
	struct dtrace_ptss_page_entry  entries[DTRACE_PTSS_ENTRIES_PER_PAGE];
};
struct eventreq {
	int      er_type;
	int      er_handle;
	void    *er_data;
	int      er_rcnt;
	int      er_wcnt;
	int      er_ecnt;
	int      er_eventbits;
};
struct kevent {
	uintptr_t       ident;  
	int16_t         filter; 
	uint16_t        flags;  
	uint32_t        fflags; 
	intptr_t        data;   
	void            *udata; 
};
struct kevent64_s {
	uint64_t        ident;          
	int16_t         filter;         
	uint16_t        flags;          
	uint32_t        fflags;         
	int64_t         data;           
	uint64_t        udata;          
	uint64_t        ext[2];         
};
struct eventhandler_lists_ctxt {
	TAILQ_HEAD(, eventhandler_list)  eventhandler_lists;
	int eventhandler_lists_initted;
	decl_lck_mtx_data(, eventhandler_mutex);
};
struct eventhandler_entry_arg {
	uuid_t ee_fm_uuid;      
	uuid_t ee_fr_uuid;      
};
struct eventhandler_entry {
	TAILQ_ENTRY(eventhandler_entry) ee_link;
	int                             ee_priority;
	struct eventhandler_entry_arg   ee_arg;
};
struct eventhandler_list {
	char                            el_name[EVENTHANDLER_MAX_NAME];
	int                             el_flags;
	u_int                           el_runcount;
	decl_lck_mtx_data(, el_lock);
	TAILQ_ENTRY(eventhandler_list)  el_link;
	TAILQ_HEAD(, eventhandler_entry) el_entries;
};
struct knote_lock_ctx {
	struct knote               *knlc_knote;
	thread_t                    knlc_thread;
	uintptr_t                   knlc_waiters;
	LIST_ENTRY(knote_lock_ctx)  knlc_link;
};
struct kqueue {
	lck_spin_t          kq_lock;      
	kq_state_t          kq_state;     
	uint16_t            kq_level;     
	uint32_t            kq_count;     
	struct proc        *kq_p;         
	struct knote_locks  kq_knlocks;   
};
struct kqfile {
	struct kqueue       kqf_kqueue;     
	struct kqtailq      kqf_queue;      
	struct kqtailq      kqf_suppressed; 
	struct selinfo      kqf_sel;        
};
struct kqworkq {
	struct kqueue       kqwq_kqueue;
	struct kqtailq      kqwq_queue[KQWQ_NBUCKETS];       
	struct kqtailq      kqwq_suppressed[KQWQ_NBUCKETS];  
	workq_threadreq_s   kqwq_request[KQWQ_NBUCKETS];     
};
struct kqworkloop {
	struct kqueue       kqwl_kqueue;                  
	struct kqtailq      kqwl_queue[KQWL_NBUCKETS];    
	struct kqtailq      kqwl_suppressed;              
	workq_threadreq_s   kqwl_request;                 

	lck_spin_t          kqwl_statelock;               
	thread_t            kqwl_owner;                   
	os_ref_atomic_t     kqwl_retains;                 
	thread_qos_t        kqwl_wakeup_qos;              
	_Atomic uint8_t     kqwl_iotier_override;         



	struct turnstile   *kqwl_turnstile;               
	kqueue_id_t         kqwl_dynamicid;               
	uint64_t            kqwl_params;                  
	LIST_ENTRY(kqworkloop) kqwl_hashlink;             
};
struct user64_kevent {
	uint64_t        ident;  
	int16_t         filter; 
	uint16_t        flags;  
	uint32_t        fflags; 
	int64_t         data;   
	user_addr_t     udata;  
};
struct user32_kevent {
	uint32_t        ident;  
	int16_t         filter; 
	uint16_t        flags;  
	uint32_t        fflags; 
	int32_t         data;   
	user32_addr_t   udata;  
};
struct kevent_qos_s {
	uint64_t        ident;          
	int16_t         filter;         
	uint16_t        flags;          
	int32_t         qos;            
	uint64_t        udata;          
	uint32_t        fflags;         
	uint32_t        xflags;         
	int64_t         data;           
	uint64_t        ext[4];         
};
struct knote {
	TAILQ_ENTRY(knote)       kn_tqe;            
	SLIST_ENTRY(knote)       kn_link;           
	SLIST_ENTRY(knote)       kn_selnext;        

	kn_status_t              kn_status : 12;
	uintptr_t
	    kn_qos_index:4,                         
	    kn_qos_override:3,                      
	    kn_is_fd:1,                             
	    kn_vnode_kqok:1,
	    kn_vnode_use_ofst:1;
	uintptr_t                   kn_kq_packed : KNOTE_KQ_PACKED_BITS;

	union {
		uintptr_t           kn_hook; 
		uint32_t            kn_hook32;
	};

	union {
		struct fileproc    *XNU_PTRAUTH_SIGNED_PTR("knote.fp") kn_fp;
		struct proc        *XNU_PTRAUTH_SIGNED_PTR("knote.proc") kn_proc;
		struct ipc_port    *XNU_PTRAUTH_SIGNED_PTR("knote.ipc_port") kn_ipc_port;
		struct ipc_pset    *XNU_PTRAUTH_SIGNED_PTR("knote.ipc_pset") kn_ipc_pset;
		struct thread_call *XNU_PTRAUTH_SIGNED_PTR("knote.thcall") kn_thcall;
		struct thread      *XNU_PTRAUTH_SIGNED_PTR("knote.thread") kn_thread;
	};

	struct kevent_internal_s {
		uint64_t    kei_ident;      
		uint16_t    kei_flags;      
		int32_t     kei_qos;        
		uint64_t    kei_udata;      
		uint32_t    kei_fflags;     
		uint32_t    kei_sfflags;    
		int64_t     kei_sdata;      
		uint64_t    kei_ext[4];     
	} kn_kevent;

};
struct kevent_ctx_s {
	uint64_t         kec_data_avail;    
	union {
		user_addr_t    kec_data_out;      
		struct pollfd *kec_poll_fds;      
	};
	user_size_t      kec_data_size;     
	user_size_t      kec_data_resid;    
	uint64_t         kec_deadline;      
	struct fileproc *kec_fp;            
	int              kec_fd;            

	int              kec_process_nevents;       
	int              kec_process_noutputs;      
	unsigned int     kec_process_flags;         
	user_addr_t      kec_process_eventlist;     
};
struct filterops {
	bool    f_isfd;               
	bool    f_adjusts_qos;    
	bool    f_extended_codes; 

	int     (*f_attach)(struct knote *kn, struct kevent_qos_s *kev);
	void    (*f_detach)(struct knote *kn);
	int     (*f_event)(struct knote *kn, long hint);
	int     (*f_touch)(struct knote *kn, struct kevent_qos_s *kev);
	int     (*f_process)(struct knote *kn, struct kevent_qos_s *kev);

	bool    (*f_allow_drop)(struct knote *kn, struct kevent_qos_s *kev);
	void    (*f_post_register_wait)(struct uthread *uth, struct knote *kn,
	    struct _kevent_register *ss_kr);
	void    (*f_sanitized_copyout)(struct knote *kn, struct kevent_qos_s *kev);
};
struct fasttrap_probe_spec {
	pid_t				ftps_pid;
	fasttrap_provider_type_t	ftps_provider_type;
	fasttrap_probe_type_t		ftps_probe_type;
	uint32_t			ftps_arch_subinfo;	
	char				ftps_func[DTRACE_FUNCNAMELEN];
	char				ftps_mod[DTRACE_MODNAMELEN];

	uint64_t			ftps_pc;
	uint64_t			ftps_size;
	uint64_t			ftps_noffs;
	uint64_t			ftps_offs[1];
} fasttrap_probe_spec_t;
struct fasttrap_instr_query {
	uint64_t		ftiq_pc;
	pid_t			ftiq_pid;
	fasttrap_instr_t	ftiq_instr;
} fasttrap_instr_query_t;
struct fasttrap_proc {
	pid_t ftpc_pid;				
	uint64_t ftpc_acount;			
	uint64_t ftpc_rcount;			
	lck_mtx_t ftpc_mtx;			
	struct fasttrap_proc *ftpc_next;	
} fasttrap_proc_t;
struct fasttrap_provider {
	pid_t ftp_pid;				
	fasttrap_provider_type_t ftp_provider_type;	
	char ftp_name[DTRACE_PROVNAMELEN];	
	dtrace_provider_id_t ftp_provid;	
	uint_t ftp_marked;			
	uint_t ftp_retired;			
	lck_mtx_t ftp_mtx;			
	lck_mtx_t ftp_cmtx;			
	uint64_t ftp_pcount;			
	uint64_t ftp_rcount;			
	uint64_t ftp_ccount;			
	uint64_t ftp_mcount;			
	fasttrap_proc_t *ftp_proc;		
	struct fasttrap_provider *ftp_next;	
} fasttrap_provider_t;
struct fasttrap_id {
	fasttrap_probe_t *fti_probe;		
	fasttrap_id_t *fti_next;		
	fasttrap_probe_type_t fti_ptype;	
};
struct fasttrap_id_tp {
	fasttrap_id_t fit_id;
	fasttrap_tracepoint_t *fit_tp;
} fasttrap_id_tp_t;
struct fasttrap_probe {
	dtrace_id_t ftp_id;			
	pid_t ftp_pid;				
	fasttrap_provider_t *ftp_prov;		
	user_addr_t ftp_faddr;			
	size_t ftp_fsize;			
	uint64_t ftp_gen;			
	uint64_t ftp_ntps;			
	uint8_t *ftp_argmap;			
	uint8_t ftp_nargs;			
	uint8_t ftp_enabled;			
	uint8_t ftp_triggered;
	char *ftp_xtypes;			
	char *ftp_ntypes;			
	fasttrap_id_tp_t ftp_tps[1];		
};
struct fasttrap_tracepoint {
	fasttrap_proc_t *ftt_proc;		
	user_addr_t ftt_pc;			
	pid_t ftt_pid;				
	fasttrap_machtp_t ftt_mtp;		
	fasttrap_id_t *ftt_ids;			
	fasttrap_id_t *ftt_retids;		
	fasttrap_tracepoint_t *ftt_next;	
};
struct fasttrap_bucket {
	lck_mtx_t ftb_mtx;			
	void *ftb_data;				

	uint8_t ftb_pad[64 - sizeof (lck_mtx_t) - sizeof (void *)];
} fasttrap_bucket_t;
struct fasttrap_hash {
	ulong_t fth_nent;			
	ulong_t fth_mask;			
	fasttrap_bucket_t *fth_table;		
} fasttrap_hash_t;
struct fbt_probe {
	struct fbt_probe *fbtp_hashnext;
	machine_inst_t	*fbtp_patchpoint;
	int8_t			fbtp_rval;
	machine_inst_t	fbtp_patchval;
	machine_inst_t	fbtp_savedval;
        machine_inst_t  fbtp_currentval;
	uintptr_t		fbtp_roffset;
	dtrace_id_t		fbtp_id;
	char			fbtp_name[MAX_FBTP_NAME_CHARS];
	struct modctl	*fbtp_ctl;
	int		fbtp_loadcnt;
	struct fbt_probe *fbtp_next;
} fbt_probe_t;
struct flock {
	off_t   l_start;        
	off_t   l_len;          
	pid_t   l_pid;          
	short   l_type;         
	short   l_whence;       
};
struct flocktimeout {
	struct flock    fl;             
	struct timespec timeout;        
};
struct filedesc {
	lck_mtx_t           fd_lock;        
	uint8_t             fd_fpdrainwait; 
	filedesc_flags_t    fd_flags;       
	u_short             fd_cmask;       
	int                 fd_nfiles;      
	int                 fd_afterlast;   
	int                 fd_freefile;    

	int                 fd_knlistsize;  
	int                 unused_padding;
	struct fileproc   **XNU_PTRAUTH_SIGNED_PTR("filedesc.fd_ofiles") fd_ofiles; 
	char               *fd_ofileflags;  

	struct  klist      *fd_knlist;      

	struct  kqworkq    *fd_wqkqueue;    
	struct  vnode      *fd_cdir;        
	struct  vnode      *fd_rdir;        
	lck_rw_t            fd_dirs_lock;   

	lck_mtx_t           fd_kqhashlock;  
	u_long              fd_kqhashmask;  
	struct  kqwllist   *fd_kqhash;      

	lck_mtx_t           fd_knhashlock;  
	u_long              fd_knhashmask;  
	struct  klist      *fd_knhash;      
};
struct fdt_iterator {
	int              fdti_fd;
	struct fileproc *fdti_fp;
};
struct fileproc_guard {
	struct select_set *fpg_wset;
	guardid_t         fpg_guard;
};
struct fileproc {
	os_refcnt_t      fp_iocount;
	_Atomic fileproc_vflags_t fp_vflags;
	fileproc_flags_t fp_flags;
	uint16_t         fp_guard_attrs;
	struct fileglob *XNU_PTRAUTH_SIGNED_PTR("fileproc.fp_glob") fp_glob;
	union {
		struct select_set     *fp_wset;   
		struct fileproc_guard *XNU_PTRAUTH_SIGNED_PTR("fileproc.fp_guard") fp_guard;  
	};
};
struct fileops {
	file_type_t     fo_type;        
	int (*fo_read)      (struct fileproc *fp, struct uio *uio,
	    int flags, vfs_context_t ctx);
	int (*fo_write)     (struct fileproc *fp, struct uio *uio,
	    int flags, vfs_context_t ctx);
	int (*fo_ioctl)(struct fileproc *fp, u_long com,
	    caddr_t data, vfs_context_t ctx);
	int (*fo_select)    (struct fileproc *fp, int which,
	    void *wql, vfs_context_t ctx);
	int (*fo_close)     (struct fileglob *fg, vfs_context_t ctx);
	int (*fo_kqfilter)  (struct fileproc *fp, struct knote *, struct kevent_qos_s *);
	int (*fo_drain)     (struct fileproc *fp, vfs_context_t ctx);
};
struct fileglob {
	LIST_ENTRY(fileglob) f_msglist;     
	uint32_t             fg_flag;       
	os_ref_atomic_t      fg_count;      
	uint32_t             fg_msgcount;   
	int32_t              fg_lflags;     
	kauth_cred_t         XNU_PTRAUTH_SIGNED_PTR("fileglob.fg_cred") fg_cred;        
	const struct fileops *XNU_PTRAUTH_SIGNED_PTR("fileglob.fg_ops") fg_ops;
	off_t                fg_offset;
	uintptr_t            fg_data;       
	struct fd_vn_data   *XNU_PTRAUTH_SIGNED_PTR("fileglob.fg_vn_data") fg_vn_data;  
	lck_mtx_t            fg_lock;
};
struct user64_namespace_handler_info {
	user64_addr_t  token;
	user64_addr_t  flags;
	user64_addr_t  fdptr;
} user64_namespace_handler_info;
struct user32_namespace_handler_info {
	user32_addr_t  token;
	user32_addr_t  flags;
	user32_addr_t  fdptr;
} user32_namespace_handler_info;
struct namespace_handler_info {
	user_addr_t  token;
	user_addr_t  flags;
	user_addr_t  fdptr;
} namespace_handler_info;
struct user64_namespace_handler_info_ext {
	user64_addr_t  token;
	user64_addr_t  flags;
	user64_addr_t  fdptr;
	user64_addr_t  infoptr;
} user64_namespace_handler_info_ext;
struct user32_namespace_handler_info_ext {
	user32_addr_t  token;
	user32_addr_t  flags;
	user32_addr_t  fdptr;
	user32_addr_t  infoptr;
} user32_namespace_handler_info_ext;
struct namespace_handler_info_ext {
	user_addr_t  token;
	user_addr_t  flags;
	user_addr_t  fdptr;
	user_addr_t  infoptr;
} namespace_handler_info_ext;
struct user64_namespace_handler_data {
	user64_addr_t token;
	user64_addr_t flags;
	user64_addr_t fdptr;
	user64_addr_t infoptr;
	user64_addr_t objid;
	user64_addr_t reserved1;
	user64_addr_t reserved2;
	user64_addr_t reserved3;
} user64_namespace_handler_data;
struct user32_namespace_handler_data {
	user32_addr_t token;
	user32_addr_t flags;
	user32_addr_t fdptr;
	user32_addr_t infoptr;
	user32_addr_t objid;
	user32_addr_t reserved1;
	user32_addr_t reserved2;
	user32_addr_t reserved3;
} user32_namespace_handler_data;
struct namespace_handler_data {
	user_addr_t token;
	user_addr_t flags;
	user_addr_t fdptr;
	user_addr_t infoptr;
	user_addr_t objid;
	user_addr_t reserved1;
	user_addr_t reserved2;
	user_addr_t reserved3;
} namespace_handler_data;
struct user64_package_ext_info {
	user64_addr_t strings;
	uint32_t      num_entries;
	uint32_t      max_width;
} user64_package_ext_info;
struct user32_package_ext_info {
	user32_addr_t strings;
	uint32_t      num_entries;
	uint32_t      max_width;
} user32_package_ext_info;
struct package_ext_info {
	const char *strings;
	uint32_t    num_entries;
	uint32_t    max_width;
} package_ext_info;
struct disk_conditioner_info {
	int enabled;
	uint64_t access_time_usec; 
	uint64_t read_throughput_mbps; 
	uint64_t write_throughput_mbps; 
	int is_ssd; 

	uint32_t ioqueue_depth;
	uint32_t maxreadcnt;
	uint32_t maxwritecnt;
	uint32_t segreadcnt;
	uint32_t segwritecnt;
} disk_conditioner_info;
struct fsioc_cas_bsdflags {
	uint32_t expected_flags;        
	uint32_t new_flags;             
	uint32_t actual_flags;          
};
struct fsioc_graft_fs {
	uint32_t graft_version;
	uint32_t graft_type;
	uint32_t graft_4cc;
	uint64_t graft_flags;
	uint64_t dir_ino;

	void *authentic_manifest;
	size_t authentic_manifest_size;
	void *user_manifest;
	size_t user_manifest_size;
	void *payload;
	size_t payload_size;
} fsioc_graft_fs_t;
struct fsioc_ungraft_fs {
	uint64_t ungraft_flags;
} fsioc_ungraft_fs_t;
struct fsioc_auth_fs {
	vnode_t authvp;
	uint64_t flags;
} fsioc_auth_fs_t;
struct fsioc_exclave_fs_register {
	uint32_t fs_tag;
} fsioc_exclave_fs_register_t;
struct {
	uint32_t fs_tag;       
	fsid_t fsid;           
	uint64_t base_dir;     
	uint64_t graft_file;   
} exclave_fs_base_dir_t;
struct {
	uint32_t count;       
	                      
	                      
	exclave_fs_base_dir_t *base_dirs; 
} exclave_fs_get_base_dirs_t;
struct {
	uint64_t        gi_graft_file;            
	uint64_t        gi_graft_dir;             
	uint64_t        gi_inum_base;             
	uint64_t        gi_inum_len:56;           
	uint64_t        gi_graft_lut_reduction:8; 
	uint64_t        gi_graft_flags;           
} fsioc_graft_info_t;
struct {
	uint16_t        ggi_count;       
	                                 
	                                 
	uint16_t        ggi_graft_index; 
	                                 
	uint8_t         ggi_is_in_graft; 
	uint8_t         ggi_padding[3];  
	user64_addr_t   ggi_buffer;      
} fsioc_get_graft_info_t;
struct generic_firmlink {
	uint8_t array[FIRMLINK_STRUCT_LEN];
} generic_firmlink_t;
struct fsevent_clone_args {
	int8_t  *event_list;
	int32_t  num_events;
	int32_t  event_queue_depth;
	int32_t *fd;
} fsevent_clone_args;
struct fsevent_dev_filter_args {
	uint32_t  num_devices;
	dev_t    *devices;
} fsevent_dev_filter_args;
struct fse_info {
	ino64_t    ino;
	dev_t      dev;
	int32_t    mode;
	uid_t      uid;
	uint32_t   document_id;
	uint64_t   nlink;
} fse_info;
struct gmonhdr {
	uint32_t lpc;           
	uint32_t hpc;           
	uint32_t ncnt;          
	int32_t version;        
	int32_t profrate;       
	int32_t spare[3];       
};
struct gmonhdr_64 {
	uint64_t lpc;           
	uint64_t hpc;           
	uint32_t ncnt;          
	int32_t version;        
	int32_t profrate;       
	int32_t spare[3];       
};
struct tostruct {
	uint32_t        selfpc;
	int32_t         count;
	uint16_t        link;
	uint16_t        order;
};
struct tostruct_64 {
	uint64_t        selfpc;
	int32_t         count;
	uint16_t        link;
	uint16_t        order;
};
struct rawarc {
	uint32_t        raw_frompc;
	uint32_t        raw_selfpc;
	int32_t         raw_count;
};
struct rawarc_64 {
	uint64_t        raw_frompc;
	uint64_t        raw_selfpc;
	int32_t         raw_count;
};
struct gmonparam {
	int             state;
	u_short         *kcount;
	u_long          kcountsize;
	u_short         *froms;
	u_long          fromssize;
	tostruct_t      *tos;
	u_long          tossize;
	long            tolimit;
	u_long          lowpc;
	u_long          highpc;
	u_long          textsize;
	u_long          hashfraction;
};
struct gmon_data {
	uint32_t type; 
	uint32_t size; 
} gmon_data_t;
struct rawarc_order {
	uint32_t    raw_frompc;
	uint32_t    raw_selfpc;
	uint32_t    raw_count;
	uint32_t    raw_order;
};
struct rawarc_order_64 {
	uint64_t    raw_frompc;
	uint64_t    raw_selfpc;
	uint32_t    raw_count;
	uint32_t    raw_order;
};
struct image_params {
	user_addr_t     ip_user_fname;          
	user_addr_t     ip_user_argv;           
	user_addr_t     ip_user_envv;           
	int             ip_seg;                 
	struct vnode    *ip_vp;                 
	struct vnode_attr       *ip_vattr;      
	struct vnode_attr       *ip_origvattr;  
	cpu_type_t      ip_origcputype;         
	cpu_subtype_t   ip_origcpusubtype;      
	char            *ip_vdata;              
	int             ip_flags;               
	int             ip_argc;                
	int             ip_envc;                
	int             ip_applec;              

	char            *ip_startargv;          
	char            *ip_endargv;    
	char            *ip_endenvv;    

	char            *ip_strings;            
	char            *ip_strendp;            

	char            *ip_subsystem_root_path;        

	int             ip_argspace;    
	int             ip_strspace;            

	user_size_t     ip_arch_offset;         
	user_size_t     ip_arch_size;           
	char            ip_interp_buffer[IMG_SHSIZE];   
	int             ip_interp_sugid_fd;             

	struct vfs_context      *ip_vfs_context;        
	struct nameidata *ip_ndp;               
	thread_t        ip_new_thread;          

	struct label    *ip_execlabelp;         
	struct label    *ip_scriptlabelp;       
	struct vnode    *ip_scriptvp;           
	unsigned int    ip_csflags;             
	int             ip_mac_return;          
	void            *ip_px_sa;              
	void            *ip_px_sfa;             
	void            *ip_px_spa;             
	vm_map_t        ip_free_map;            
	struct ip_px_smpx_s {
		void        *array;
		void        *data;
		uint64_t    datalen;
	}               ip_px_smpx;             
	void            *ip_px_persona;         
	void            *ip_px_pcred_info;      
	void            *ip_cs_error;           
	char            *ip_inherited_shared_region_id;  

	uint64_t ip_dyld_fsid;
	uint64_t ip_dyld_fsobjid;
	uint64_t ip_inherited_jop_pid;
	unsigned int    ip_simulator_binary;    
};
struct imgsrc_info {
	uint32_t        ii_height;      
	uint32_t        ii_flags;       
	dev_t           ii_dev;         
	char            ii_reserved[24];
} *imgsrc_info_t;
struct mnt_imgsrc_args {
	uint32_t        mi_height;      
	uint32_t        mi_flags;       
	const char*     mi_devpath;     
};
struct user64_mnt_imgsrc_args {
	uint32_t        mi_height;
	uint32_t        mi_flags;
	user64_addr_t   mi_devpath;
};
struct user32_mnt_imgsrc_args {
	uint32_t        mi_height;
	uint32_t        mi_flags;
	user32_addr_t   mi_devpath;
};
struct ttysize {
	unsigned short  ts_lines;
	unsigned short  ts_cols;
	unsigned short  ts_xxx;
	unsigned short  ts_yyy;
};
struct tchars {
	char    t_intrc;        
	char    t_quitc;        
	char    t_startc;       
	char    t_stopc;        
	char    t_eofc;         
	char    t_brkc;         
};
struct ltchars {
	char    t_suspc;        
	char    t_dsuspc;       
	char    t_rprntc;       
	char    t_flushc;       
	char    t_werasc;       
	char    t_lnextc;       
};
struct sgttyb {
	char    sg_ispeed;              
	char    sg_ospeed;              
	char    sg_erase;               
	char    sg_kill;                
	short   sg_flags;               
};
struct ipc_perm {
	uid_t           uid;            
	gid_t           gid;            
	uid_t           cuid;           
	gid_t           cgid;           
	mode_t          mode;           
	unsigned short  _seq;           
	key_t           _key;           
};
struct IPCS_command {
	int             ipcs_magic;     
	int             ipcs_op;        
	int             ipcs_cursor;    
	int             ipcs_datalen;   
	void            *ipcs_data;     
};
struct user_IPCS_command {
	int             ipcs_magic;     
	int             ipcs_op;        
	int             ipcs_cursor;    
	int             ipcs_datalen;   
	user_addr_t     ipcs_data;      
};
struct user32_IPCS_command {
	int             ipcs_magic;     
	int             ipcs_op;        
	int             ipcs_cursor;    
	int             ipcs_datalen;   
	user32_addr_t   ipcs_data;      
};
struct kd_storage {
	union kds_ptr kds_next;
	uint32_t kds_bufindx;
	uint32_t kds_bufcnt;
	uint32_t kds_readlast;
	uint32_t kds_lostevents:1;
	uint32_t unused:31;
	uint64_t kds_timestamp;

	kd_buf kds_records[TRACE_EVENTS_PER_STORAGE_UNIT];
};
struct kd_region {
	struct kd_storage *kdr_addr;
	uint32_t           kdr_size;
};
struct kd_bufinfo {
	union  kds_ptr kd_list_head;
	union  kds_ptr kd_list_tail;
	bool kd_lostevents;
	uint32_t _pad;
	uint64_t kd_prev_timebase;
	uint32_t num_bufs;
	uint64_t latest_past_event_timestamp;
	bool continuous_timestamps;
} __attribute__((aligned(MAX_CPU_CACHE_LINE_SIZE))) __attribute__((packed));
struct kd_control {
	union kds_ptr kds_free_list;
	uint32_t enabled:1,
	    mode:3,
	    _pad0:28;
	uint32_t kdebug_events_per_storage_unit;
	uint32_t kdebug_min_storage_units_per_cpu;
	uint32_t kdebug_kdcopybuf_count;
	uint32_t kdebug_kdcopybuf_size;
	uint32_t kdebug_cpus;
	uint32_t alloc_cpus;
	uint32_t kdc_flags;
	kdebug_emit_filter_t kdc_emit;
	kdebug_live_flags_t kdc_live_flags;
	uint64_t kdc_oldest_time;
	int kdc_storage_used;

	lck_spin_t kdc_storage_lock;

	struct kd_coproc *kdc_coprocs;

	kd_event_matcher disable_event_match;
	kd_event_matcher disable_event_mask;
};
struct kd_buffer {
	int kdb_event_count;
	int kdb_storage_count;
	int kdb_storage_threshold;
	uint32_t kdb_region_count;
	struct kd_bufinfo *kdb_info;
	struct kd_region *kd_bufs;
	kd_buf *kdcopybuf;
};
struct kd_record {
	int32_t  cpu;
	uint32_t debugid;
	int64_t timestamp;
	kd_buf_argtype arg1;
	kd_buf_argtype arg2;
	kd_buf_argtype arg3;
	kd_buf_argtype arg4;
	kd_buf_argtype arg5;
} __attribute__((packed));
struct kd_callback {
	kd_callback_fn func;
	void *context;
	char iop_name[8];
};
struct ktriage_strings {
	int num_strings;
	const char **strings;
} ktriage_strings_t;
struct ctl_event_data {
	u_int32_t   ctl_id;             
	u_int32_t   ctl_unit;
};
struct ctl_info {
	u_int32_t   ctl_id;                             
	char        ctl_name[MAX_KCTL_NAME];            
};
struct sockaddr_ctl {
	u_char      sc_len;     
	u_char      sc_family;  
	u_int16_t   ss_sysaddr; 
	u_int32_t   sc_id;      
	u_int32_t   sc_unit;    
	u_int32_t   sc_reserved[5];
};
struct xkctl_reg {
	u_int32_t       xkr_len;
	u_int32_t       xkr_kind;
	u_int32_t       xkr_id;
	u_int32_t       xkr_reg_unit;
	u_int32_t       xkr_flags;
	u_int64_t       xkr_kctlref;
	u_int32_t       xkr_recvbufsize;
	u_int32_t       xkr_sendbufsize;
	u_int32_t       xkr_lastunit;
	u_int32_t       xkr_pcbcount;
	u_int64_t       xkr_connect;
	u_int64_t       xkr_disconnect;
	u_int64_t       xkr_send;
	u_int64_t       xkr_send_list;
	u_int64_t       xkr_setopt;
	u_int64_t       xkr_getopt;
	u_int64_t       xkr_rcvd;
	char            xkr_name[MAX_KCTL_NAME];
};
struct xkctlpcb {
	u_int32_t       xkp_len;
	u_int32_t       xkp_kind;
	u_int64_t       xkp_kctpcb;
	u_int32_t       xkp_unit;
	u_int32_t       xkp_kctlid;
	u_int64_t       xkp_kctlref;
	char            xkp_kctlname[MAX_KCTL_NAME];
};
struct kctlstat {
	u_int64_t       kcs_reg_total __attribute__((aligned(8)));
	u_int64_t       kcs_reg_count __attribute__((aligned(8)));
	u_int64_t       kcs_pcbcount __attribute__((aligned(8)));
	u_int64_t       kcs_gencnt __attribute__((aligned(8)));
	u_int64_t       kcs_connections __attribute__((aligned(8)));
	u_int64_t       kcs_conn_fail __attribute__((aligned(8)));
	u_int64_t       kcs_send_fail __attribute__((aligned(8)));
	u_int64_t       kcs_send_list_fail __attribute__((aligned(8)));
	u_int64_t       kcs_enqueue_fail __attribute__((aligned(8)));
	u_int64_t       kcs_enqueue_fullsock __attribute__((aligned(8)));
	u_int64_t       kcs_bad_kctlref __attribute__((aligned(8)));
	u_int64_t       kcs_tbl_size_too_big __attribute__((aligned(8)));
	u_int64_t       kcs_enqdata_mb_alloc_fail __attribute__((aligned(8)));
	u_int64_t       kcs_enqdata_sbappend_fail __attribute__((aligned(8)));
};
struct kern_ctl_reg {
	char            ctl_name[MAX_KCTL_NAME];
	u_int32_t       ctl_id;
	u_int32_t       ctl_unit;

	u_int32_t   ctl_flags;
	u_int32_t   ctl_sendsize;
	u_int32_t   ctl_recvsize;

	ctl_connect_func    ctl_connect;
	ctl_disconnect_func ctl_disconnect;
	ctl_send_func               ctl_send;
	ctl_setopt_func             ctl_setopt;
	ctl_getopt_func             ctl_getopt;
	ctl_rcvd_func               ctl_rcvd;   
	ctl_send_list_func          ctl_send_list;
	ctl_bind_func           ctl_bind;
	ctl_setup_func                  ctl_setup;
};
struct kern_event_msg {
	u_int32_t       total_size;     
	u_int32_t       vendor_code;    
	u_int32_t       kev_class;      
	u_int32_t       kev_subclass;   
	u_int32_t       id;             
	u_int32_t       event_code;     
	u_int32_t       event_data[XNU_KERN_EVENT_DATA_SIZE];   
};
struct kev_request {
	u_int32_t       vendor_code;
	u_int32_t       kev_class;
	u_int32_t       kev_subclass;
};
struct kev_vendor_code {
	u_int32_t       vendor_code;
	char            vendor_string[KEV_VENDOR_CODE_MAX_STR_LEN];
};
struct xkevtpcb {
	u_int32_t       kep_len;
	u_int32_t       kep_kind;
	u_int64_t       kep_evtpcb;
	u_int32_t       kep_vendor_code_filter;
	u_int32_t       kep_class_filter;
	u_int32_t       kep_subclass_filter;
};
struct kevtstat {
	u_int64_t       kes_pcbcount __attribute__((aligned(8)));
	u_int64_t       kes_gencnt __attribute__((aligned(8)));
	u_int64_t       kes_badvendor __attribute__((aligned(8)));
	u_int64_t       kes_toobig __attribute__((aligned(8)));
	u_int64_t       kes_nomem __attribute__((aligned(8)));
	u_int64_t       kes_fullsock __attribute__((aligned(8)));
	u_int64_t       kes_posted __attribute__((aligned(8)));
};
struct kev_d_vectors {
	u_int32_t       data_length;    
	void            *data_ptr;      
};
struct kev_msg {
	u_int32_t vendor_code;          
	u_int32_t kev_class;            
	u_int32_t kev_subclass;         
	u_int32_t event_code;           
	struct kev_d_vectors dv[N_KEV_VECTORS]; 
};
struct kern_event_pcb {
	decl_lck_mtx_data(, evp_mtx);   
	LIST_ENTRY(kern_event_pcb) evp_link;    
	struct socket *evp_socket;              
	u_int32_t evp_vendor_code_filter;
	u_int32_t evp_class_filter;
	u_int32_t evp_subclass_filter;
};
struct memorystatus_priority_entry {
	pid_t pid;
	int32_t priority;
	uint64_t user_data;
	int32_t limit;  
	memorystatus_proc_state_t state;
} memorystatus_priority_entry_t;
struct memorystatus_priority_entry_v2 {
	pid_t    pid;
	int32_t  priority;
	uint64_t user_data;
	int32_t  limit; 
	memorystatus_proc_state_t state;
	uint64_t priority_start_mtime;

	uint8_t  _reserved[96];
} memorystatus_priority_entry_v2_t;
struct memorystatus_properties_entry_v1 {
	int version;
	pid_t pid;
	int32_t priority;
	int use_probability;
	uint64_t user_data;
	int32_t limit;  
	memorystatus_proc_state_t state;
	char proc_name[MAXCOMLEN + 1];
	char __pad1[3];
} memorystatus_properties_entry_v1_t;
struct memorystatus_properties_freeze_entry_v1 {
	int version;
	pid_t pid;
	uint32_t priority;
	char proc_name[(2 * MAXCOMLEN) + 1];
	char __pad1[3];
} memorystatus_properties_freeze_entry_v1;
struct memorystatus_kernel_stats {
	uint32_t free_pages;
	uint32_t active_pages;
	uint32_t inactive_pages;
	uint32_t throttled_pages;
	uint32_t purgeable_pages;
	uint32_t wired_pages;
	uint32_t speculative_pages;
	uint32_t filebacked_pages;
	uint32_t anonymous_pages;
	uint32_t compressor_pages;
	uint64_t compressions;
	uint64_t decompressions;
	uint64_t total_uncompressed_pages_in_compressor;
	uint64_t zone_map_size;
	uint64_t zone_map_capacity;
	uint64_t largest_zone_size;
	char     largest_zone_name[MACH_ZONE_NAME_MAX_LEN];
} memorystatus_kernel_stats_t;
struct jetsam_snapshot_entry {
	pid_t    pid;
	char     name[(2 * MAXCOMLEN) + 1];
	int32_t  priority;
	memorystatus_proc_state_t state;
	uint32_t fds;
	memorystatus_freeze_skip_reason_t jse_freeze_skip_reason; 
	uint8_t  uuid[16];
	uint64_t user_data;
	uint64_t killed;
	uint64_t pages;
	uint64_t max_pages_lifetime;
	uint64_t purgeable_pages;
	uint64_t jse_internal_pages;
	uint64_t jse_internal_compressed_pages;
	uint64_t jse_purgeable_nonvolatile_pages;
	uint64_t jse_purgeable_nonvolatile_compressed_pages;
	uint64_t jse_alternate_accounting_pages;
	uint64_t jse_alternate_accounting_compressed_pages;
	uint64_t jse_iokit_mapped_pages;
	uint64_t jse_page_table_pages;
	uint64_t jse_memory_region_count;
	uint64_t jse_gencount;                  
	uint64_t jse_starttime;                 
	uint64_t jse_killtime;                  
	uint64_t jse_idle_delta;                
	uint64_t jse_coalition_jetsam_id;       
	struct timeval64 cpu_time;
	uint64_t jse_thaw_count;
	uint64_t jse_frozen_to_swap_pages;
	uint64_t csflags;
	uint32_t cs_trust_level;
	uint64_t jse_neural_nofootprint_total_pages;
} memorystatus_jetsam_snapshot_entry_t;
struct jetsam_snapshot {
	uint64_t snapshot_time;                 
	uint64_t notification_time;             
	uint64_t js_gencount;                   
	memorystatus_kernel_stats_t stats;      
	size_t entry_count;
	memorystatus_jetsam_snapshot_entry_t entries[];
} memorystatus_jetsam_snapshot_t;
struct memorystatus_priority_properties {
	int32_t  priority;
	uint64_t user_data;
} memorystatus_priority_properties_t;
struct memorystatus_memlimit_properties {
	int32_t memlimit_active;                
	uint32_t memlimit_active_attr;
	int32_t memlimit_inactive;              
	uint32_t memlimit_inactive_attr;
} memorystatus_memlimit_properties_t;
struct memorystatus_memlimit_properties2 {
	memorystatus_memlimit_properties_t v1;
	uint32_t memlimit_increase;             
	uint32_t memlimit_increase_bytes;       
} memorystatus_memlimit_properties2_t;
struct memorystatus_diag_memlimit_properties {
	uint64_t memlimit;                       
	bool     threshold_enabled;              
} memorystatus_diag_memlimit_properties_t;
struct memstat_bucket {
	TAILQ_HEAD(, proc) list;
	uint32_t count;
	uint32_t relaunch_high_count;
} memstat_bucket_t;
struct memorystatus_internal_probabilities {
	char proc_name[MAXCOMLEN + 1];
	int use_probability;
} memorystatus_internal_probabilities_t;
struct memorystatus_freeze_entry {
	int32_t pid;
	uint32_t flags;
	uint32_t pages;
} memorystatus_freeze_entry_t;
struct _global_frozen_procs {
	uint64_t gfp_num_frozen;

	struct {
		pid_t fp_pid;
		proc_name_t fp_name;
	} gfp_procs[FREEZER_CONTROL_GET_PROCS_MAX_COUNT];
} global_frozen_procs_t;
struct _memorystatus_freezer_trial_identifiers_v1 {
	int version; 
	uuid_string_t treatment_id;
	uuid_string_t experiment_id;
	int deployment_id;
} memorystatus_freezer_trial_identifiers_v1;
struct _vm_object_query_data_ {
	vm_object_id_t object_id;
	mach_vm_size_t virtual_size;
	mach_vm_size_t resident_size;
	mach_vm_size_t wired_size;
	mach_vm_size_t reusable_size;
	mach_vm_size_t compressed_size;
	struct {
		uint64_t vo_no_footprint : 1; 
		uint64_t vo_ledger_tag   : 3; 
		uint64_t purgable        : 2; 
	};
};
struct _vmobject_list_output_ {
	uint64_t entries;
	vm_object_query_data_t data[0];
};
struct mbuf_stat {
	u_int32_t       mbufs;          
	u_int32_t       clusters;       
	u_int32_t       clfree;         
	u_int32_t       drops;          
	u_int32_t       wait;           
	u_int32_t       drain;          
	u_short         mtypes[256];    
	u_int32_t       mcfail;         
	u_int32_t       mpfail;         
	u_int32_t       msize;          
	u_int32_t       mclbytes;       
	u_int32_t       minclsize;      
	u_int32_t       mlen;           
	u_int32_t       mhlen;          
	u_int32_t       bigclusters;    
	u_int32_t       bigclfree;      
	u_int32_t       bigmclbytes;    
};
struct {
	int32_t buf_interface; 
	int32_t buf_sndbuf; 
} mbuf_buffer_status_t;
struct sflt_filter {
	sflt_handle                     sf_handle;
	int                             sf_flags;
	char                            *sf_name;

	sf_unregistered_func            sf_unregistered;
	sf_attach_func                  sf_attach;
	sf_detach_func                  sf_detach;

	sf_notify_func                  sf_notify;
	sf_getpeername_func             sf_getpeername;
	sf_getsockname_func             sf_getsockname;
	sf_data_in_func                 sf_data_in;
	sf_data_out_func                sf_data_out;
	sf_connect_in_func              sf_connect_in;
	sf_connect_out_func             sf_connect_out;
	sf_bind_func                    sf_bind;
	sf_setoption_func               sf_setoption;
	sf_getoption_func               sf_getoption;
	sf_listen_func                  sf_listen;
	sf_ioctl_func                   sf_ioctl;
	struct sflt_filter_ext {
		unsigned int            sf_ext_len;
		sf_accept_func          sf_ext_accept;
		void                    *sf_ext_rsvd[5];        
	} sf_ext;
};
struct lockf {
	short   lf_flags;           
	short   lf_type;            
	off_t   lf_start;           
	off_t   lf_end;             
	caddr_t lf_id;              
	struct  lockf **lf_head;    
	struct  vnode *lf_vnode;    
	struct  lockf *lf_next;     
	struct  locklist lf_blkhd;  
	TAILQ_ENTRY(lockf) lf_block;
	struct  proc *lf_owner;     
};
struct mcache_obj {
	struct mcache_obj       *obj_next;
} mcache_obj_t;
struct mcache_bkt {
	void            *bkt_next;      
	struct mcache_bkttype *bkt_type; 
	void            *bkt_obj[1];    
} mcache_bkt_t;
struct mcache_bktlist {
	mcache_bkt_t    *bl_list;       
	u_int32_t       bl_total;       
	u_int32_t       bl_min;         
	u_int32_t       bl_reaplimit;   
	u_int64_t       bl_alloc;       
} mcache_bktlist_t;
struct mcache_bkttype {
	int             bt_bktsize;     
	size_t          bt_minbuf;      
	size_t          bt_maxbuf;      
	struct mcache   *bt_cache;      
} mcache_bkttype_t;
struct mcache_cpu {
	decl_lck_mtx_data(, cc_lock);
	mcache_bkt_t    *cc_filled;     
	mcache_bkt_t    *cc_pfilled;    
	u_int64_t       cc_alloc;       
	u_int64_t       cc_free;        
	int             cc_objs;        
	int             cc_pobjs;       
	int             cc_bktsize;     
} __attribute__((aligned(MAX_CPU_CACHE_LINE_SIZE))) mcache_cpu_t;
struct mcache {
	LIST_ENTRY(mcache) mc_list;     
	char            mc_name[32];    
	struct zone     *mc_slab_zone;  
	mcache_allocfn_t mc_slab_alloc; 
	mcache_freefn_t mc_slab_free;   
	mcache_auditfn_t mc_slab_audit; 
	mcache_logfn_t mc_slab_log;     
	mcache_notifyfn_t mc_slab_notify; 
	void            *mc_private;    
	size_t          mc_bufsize;     
	size_t          mc_align;       
	u_int32_t       mc_flags;       
	u_int32_t       mc_purge_cnt;   
	u_int32_t       mc_enable_cnt;  
	u_int32_t       mc_waiter_cnt;  
	u_int32_t       mc_wretry_cnt;  
	u_int32_t       mc_nwretry_cnt; 
	u_int32_t       mc_nwfail_cnt;  
	decl_lck_mtx_data(, mc_sync_lock); 
	lck_grp_t       *mc_sync_lock_grp;
	lck_grp_t       *mc_cpu_lock_grp;

	decl_lck_mtx_data(, mc_bkt_lock);
	lck_grp_t       *mc_bkt_lock_grp;
	mcache_bkttype_t *cache_bkttype;        
	mcache_bktlist_t mc_full;               
	mcache_bktlist_t mc_empty;              
	size_t          mc_chunksize;           
	u_int32_t       mc_bkt_contention;      
	u_int32_t       mc_bkt_contention_prev; 

	mcache_cpu_t    mc_cpu[1]
	__attribute__((aligned(MAX_CPU_CACHE_LINE_SIZE)));
} mcache_t;
struct mcache_audit {
	struct mcache_audit *mca_next;  
	void            *mca_addr;      
	mcache_t        *mca_cache;     
	size_t          mca_contents_size; 
	void            *mca_contents;  
	void            *mca_uptr;      
	uint32_t        mca_uflags;     
	uint32_t        mca_next_trn;
	struct mca_trn {
		struct thread   *mca_thread;    
		uint32_t        mca_tstamp;
		uint16_t        mca_depth;
		void            *mca_stack[MCACHE_STACK_DEPTH];
	} mca_trns[MCA_TRN_MAX];
} mcache_audit_t;
struct {
	__uint64_t version;
	__uint64_t originalSize;
	__uint64_t reserved[4];
} model_encryption_header_t;
struct monotonic_config {
	uint64_t event;
	uint64_t allowed_ctr_mask;
	uint64_t cpu_mask;
};
struct vfsstatfs {
	uint32_t        f_bsize;        
	size_t          f_iosize;       
	uint64_t        f_blocks;       
	uint64_t        f_bfree;        
	uint64_t        f_bavail;       
	uint64_t        f_bused;        
	uint64_t        f_files;        
	uint64_t        f_ffree;        
	fsid_t          f_fsid;         
	uid_t           f_owner;        
	uint64_t        f_flags;        
	char            f_fstypename[MFSTYPENAMELEN];
	char            f_mntonname[MAXPATHLEN];
	char            f_mntfromname[MAXPATHLEN];
	uint32_t        f_fssubtype;     
	void            *f_reserved[2];         
};
struct vfs_attr {
	uint64_t        f_supported;
	uint64_t        f_active;

	uint64_t        f_objcount;     
	uint64_t        f_filecount;    
	uint64_t        f_dircount;     
	uint64_t        f_maxobjcount;  

	uint32_t        f_bsize;        
	size_t          f_iosize;       
	uint64_t        f_blocks;       
	uint64_t        f_bfree;        
	uint64_t        f_bavail;       
	uint64_t        f_bused;        
	uint64_t        f_files;        
	uint64_t        f_ffree;        
	fsid_t          f_fsid;         
	uid_t           f_owner;        

	vol_capabilities_attr_t f_capabilities;
	vol_attributes_attr_t f_attributes;

	struct timespec f_create_time;  
	struct timespec f_modify_time;  
	struct timespec f_access_time;  
	struct timespec f_backup_time;  

	uint32_t        f_fssubtype;    

	char            *f_vol_name;    

	uint16_t        f_signature;    
	uint16_t        f_carbon_fsid;  
	uuid_t          f_uuid;         
	uint64_t        f_quota;        
	uint64_t        f_reserved;     
};
struct vfsconf {
	uint32_t vfc_reserved1;         
	char    vfc_name[MFSNAMELEN];   
	int     vfc_typenum;            
	int     vfc_refcount;           
	int     vfc_flags;              
	uint32_t vfc_reserved2;         
	uint32_t vfc_reserved3;         
};
struct vfsidctl {
	int             vc_vers;        
	fsid_t          vc_fsid;        
	void            *vc_ptr;        
	size_t          vc_len;         
	u_int32_t       vc_spare[12];   
};
struct user_vfsidctl {
	int                              vc_vers;       
	fsid_t                   vc_fsid;               
	user_addr_t              vc_ptr __attribute((aligned(8)));      
	user_size_t              vc_len;                
	u_int32_t                vc_spare[12];  
};
struct user32_vfsidctl {
	int                              vc_vers;       
	fsid_t                   vc_fsid;               
	user32_addr_t    vc_ptr;                
	user32_size_t    vc_len;                
	u_int32_t                vc_spare[12];  
};
struct vfsquery {
	u_int32_t       vq_flags;
	u_int32_t       vq_spare[31];
};
struct vfs_server {
	int32_t  vs_minutes;                    
	u_int8_t vs_server_name[MAXHOSTNAMELEN * 3]; 
};
struct netfs_status {
	u_int32_t       ns_status;              
	char            ns_mountopts[512];      
	uint32_t        ns_waittime;            
	uint32_t        ns_threadcount;         
	uint64_t        ns_threadids[0];        
};
struct vfsioattr {
	u_int32_t       io_maxreadcnt;          
	u_int32_t       io_maxwritecnt;         
	u_int32_t       io_segreadcnt;          
	u_int32_t       io_segwritecnt;         
	u_int32_t       io_maxsegreadsize;      
	u_int32_t       io_maxsegwritesize;     
	u_int32_t       io_devblocksize;        
	u_int32_t       io_flags;                       
	union {
		int64_t io_max_swappin_available;
		
		void *io_reserved[2];
	};
};
struct vfs_fsentry {
	struct vfsops * vfe_vfsops;     
	int             vfe_vopcnt;     
	struct vnodeopv_desc ** vfe_opvdescs; 
	int                     vfe_fstypenum;  
	char            vfe_fsname[MFSNAMELEN]; 
	uint32_t        vfe_flags;              
	void *              vfe_reserv[2];
};
struct vfsops {
	int  (*vfs_mount)(struct mount *mp, vnode_t devvp, user_addr_t data, vfs_context_t context);

	int  (*vfs_start)(struct mount *mp, int flags, vfs_context_t context);

	int  (*vfs_unmount)(struct mount *mp, int mntflags, vfs_context_t context);

	int  (*vfs_root)(struct mount *mp, struct vnode **vpp, vfs_context_t context);

	int  (*vfs_quotactl)(struct mount *mp, int cmds, uid_t uid, caddr_t arg, vfs_context_t context);

	int  (*vfs_getattr)(struct mount *mp, struct vfs_attr *vfa, vfs_context_t context);


	int  (*vfs_sync)(struct mount *mp, int waitfor, vfs_context_t context);

	int  (*vfs_vget)(struct mount *mp, ino64_t ino, struct vnode **vpp, vfs_context_t context);

	int  (*vfs_fhtovp)(struct mount *mp, int fhlen, unsigned char *fhp, struct vnode **vpp,
	    vfs_context_t context);

	int  (*vfs_vptofh)(struct vnode *vp, int *fhlen, unsigned char *fhp, vfs_context_t context);

	int  (*vfs_init)(struct vfsconf *vfsc);

	int  (*vfs_sysctl)(int *, u_int, user_addr_t, size_t *, user_addr_t, size_t, vfs_context_t context);

	int  (*vfs_setattr)(struct mount *mp, struct vfs_attr *vfa, vfs_context_t context);

	int  (*vfs_ioctl)(struct mount *mp, u_long command, caddr_t data,
	    int flags, vfs_context_t context);

	int  (*vfs_vget_snapdir)(struct mount *mp, struct vnode **vpp, vfs_context_t context);
	void *vfs_reserved5;
	void *vfs_reserved4;
	void *vfs_reserved3;
	void *vfs_reserved2;
	void *vfs_reserved1;
};
struct fs_snapshot_mount_args {
	mount_t sm_mp;
	struct componentname *sm_cnp;
};
struct fs_snapshot_revert_args {
	struct componentname *sr_cnp;
};
struct fs_snapshot_root_args {
	struct componentname *sr_cnp;
};
struct fs_role_mount_args {
	mount_t root_mp;
	uint32_t mount_role;
} fs_role_mount_args_t;
struct fhandle {
	unsigned int    fh_len;                         
	unsigned char   fh_data[NFS_MAX_FH_SIZE];       
};
struct mount {
	TAILQ_ENTRY(mount)      mnt_list;                   
	int32_t                 mnt_count;                  
	lck_mtx_t               mnt_mlock;                  
	const struct vfsops     * XNU_PTRAUTH_SIGNED_PTR("mount.vfsops") mnt_op;        
	struct vfstable         * XNU_PTRAUTH_SIGNED_PTR("mount.mnt_vtable") mnt_vtable;        
	struct vnode            * XNU_PTRAUTH_SIGNED_PTR("mount.mnt_vnodecovered") mnt_vnodecovered;    
	struct vnodelst         mnt_vnodelist;              
	struct vnodelst         mnt_workerqueue;            
	struct vnodelst         mnt_newvnodes;              
	uint32_t                mnt_flag;                   
	uint32_t                mnt_kern_flag;              
	uint32_t                mnt_compound_ops;           
	uint32_t                mnt_lflag;                  
	uint32_t                mnt_maxsymlinklen;          
	struct vfsstatfs        mnt_vfsstat;                
	qaddr_t                 mnt_data;                   
	uint32_t                mnt_maxreadcnt;             
	uint32_t                mnt_maxwritecnt;            
	uint32_t                mnt_segreadcnt;             
	uint32_t                mnt_segwritecnt;            
	uint32_t                mnt_maxsegreadsize;         
	uint32_t                mnt_maxsegwritesize;        
	uint32_t                mnt_alignmentmask;          
	uint32_t                mnt_devblocksize;           
	uint32_t                mnt_ioqueue_depth;          
	uint32_t                mnt_ioscale;                
	uint32_t                mnt_ioflags;                
	uint32_t                mnt_minsaturationbytecount; 
	pending_io_t            mnt_pending_write_size __attribute__((aligned(sizeof(pending_io_t))));  
	pending_io_t            mnt_pending_read_size  __attribute__((aligned(sizeof(pending_io_t))));  
	struct timeval          mnt_last_write_issued_timestamp;
	struct timeval          mnt_last_write_completed_timestamp;
	int64_t                 mnt_max_swappin_available;

	lck_rw_t                mnt_rwlock;                 
	lck_mtx_t               mnt_renamelock;             
	vnode_t                 mnt_devvp;                  
	uint32_t                mnt_devbsdunit;             
	uint64_t                mnt_throttle_mask;          
	void                    *mnt_throttle_info;         
	int32_t                 mnt_crossref;               
	int32_t                 mnt_iterref;                
	uid_t                   mnt_fsowner;
	gid_t                   mnt_fsgroup;

	struct label            *mnt_mntlabel;              

	vnode_t                 mnt_realrootvp;
	uint32_t                mnt_realrootvp_vid;
	uint32_t                mnt_generation;
	int                     mnt_authcache_ttl;
	char                    fstypename_override[MFSTYPENAMELEN];

	uint32_t                mnt_iobufinuse;

	void                    *mnt_disk_conditioner_info;

	lck_mtx_t               mnt_iter_lock;              

	uint64_t                mnt_mount_id;               
	uint32_t                mnt_supl_kern_flag;         
};
struct vfstable {
	const struct vfsops *vfc_vfsops;
	char        vfc_name[MFSNAMELEN];   
	int         vfc_typenum;            
	int         vfc_refcount;           
	int         vfc_flags;              
	int         (*vfc_mountroot)(mount_t, vnode_t, vfs_context_t);      
	struct      vfstable *vfc_next;     
	int32_t     vfc_reserved1;
	int32_t     vfc_reserved2;
	int         vfc_vfsflags;           
	void       *vfc_descptr;            
	uint32_t    vfc_descsize;           
	struct sysctl_oid       *vfc_sysctl;    
};
struct vfsmount_args {
	union {
		struct {
			char * mnt_fspec;
			void * mnt_fsdata;
		} mnt_localfs_args;
		struct {
			void *  mnt_fsdata;             
		} mnt_remotefs_args;
	} mountfs_args;
};
struct user64_statfs {
	short           f_otype;                
	short           f_oflags;               
	user64_long_t   f_bsize;                
	user64_long_t   f_iosize;               
	user64_long_t   f_blocks;               
	user64_long_t   f_bfree;                
	user64_long_t   f_bavail;               
	user64_long_t   f_files;                
	user64_long_t   f_ffree;                
	fsid_t          f_fsid;                 
	uid_t           f_owner;                
	short           f_reserved1;            
	short           f_type;                 
	user64_long_t   f_flags;                
	user64_long_t   f_reserved2[2];         
	char            f_fstypename[MFSNAMELEN]; 
	char            f_mntonname[MNAMELEN];  
	char            f_mntfromname[MNAMELEN];
	char            f_reserved3;    
	user64_long_t   f_reserved4[4]; 
};
struct user32_statfs {
	short           f_otype;                
	short           f_oflags;               
	user32_long_t   f_bsize;                
	user32_long_t   f_iosize;               
	user32_long_t   f_blocks;               
	user32_long_t   f_bfree;                
	user32_long_t   f_bavail;               
	user32_long_t   f_files;                
	user32_long_t   f_ffree;                
	fsid_t          f_fsid;                 
	uid_t           f_owner;                
	short           f_reserved1;    
	short           f_type;                 
	user32_long_t       f_flags;            
	user32_long_t f_reserved2[2];   
	char            f_fstypename[MFSNAMELEN]; 
	char            f_mntonname[MNAMELEN];  
	char            f_mntfromname[MNAMELEN];
	char            f_reserved3;    
	user32_long_t   f_reserved4[4]; 
};
struct  msgbuf {
	int             msg_magic;
	int             msg_size;
	int             msg_bufx;               
	int             msg_bufr;               
	char    *msg_bufc;              
};
struct nameidata {
	user_addr_t ni_dirp;            
	enum    uio_seg ni_segflg;      
	enum    path_operation ni_op;   
	struct  vnode *ni_startdir;     
	struct  vnode *ni_rootdir;      
	struct  vnode *ni_usedvp;       
	struct  vnode *ni_vp;           
	struct  vnode *ni_dvp;          
	u_int   ni_pathlen;             
	char    *ni_next;               
	char    ni_pathbuf[PATHBUFLEN];
	u_long  ni_loopcnt;             

	struct componentname ni_cnd;
	int32_t ni_flag;
	int ni_ncgeneration;            
};
struct  namecache {
	TAILQ_ENTRY(namecache)  nc_entry;       
	TAILQ_ENTRY(namecache)  nc_child;       
	union {
		LIST_ENTRY(namecache)  nc_link; 
		TAILQ_ENTRY(namecache) nc_negentry; 
	} nc_un;
	struct smrq_link        nc_hash;        
	uint32_t                nc_vid;         
	uint32_t                nc_counter;     
	vnode_t                 nc_dvp;         
	vnode_t                 nc_vp;          
	unsigned int            nc_hashval;     
	const char              *nc_name;       
};
struct  nchstats {
	long    ncs_goodhits;           
	long    ncs_neghits;            
	long    ncs_badhits;            
	long    ncs_miss;               
	long    ncs_pass2;              
	long    ncs_2passes;            
	long    ncs_stolen;
	long    ncs_enters;
	long    ncs_deletes;
	long    ncs_badvid;
};
struct {
	long        np_uid_high;
	long        np_uid_low;
} np_uid_t;
struct {
	netaddr_t   np_receiver;
	netaddr_t   np_owner;
	np_uid_t    np_puid;
	np_uid_t    np_sid;
} network_port_t;
struct kpersona_info {
	uint32_t persona_info_version;

	uid_t    persona_id;
	int      persona_type;
	gid_t    persona_gid; 
	uint32_t persona_ngroups; 
	gid_t    persona_groups[NGROUPS]; 
	uid_t    persona_gmuid; 
	char     persona_name[MAXLOGNAME + 1];

	uid_t    persona_uid;
} __attribute__((packed));
struct persona {
	os_refcnt_t  pna_refcount;
	int32_t      pna_valid;

	uid_t        pna_id;
	persona_type_t pna_type;
	char         pna_login[MAXLOGNAME + 1];
	char         *pna_path;
	uid_t        pna_uid;

	LIST_ENTRY(persona) pna_list;

	LIST_HEAD(, proc)   pna_members;

	lck_mtx_t    pna_lock;

};
struct pgo_metadata_footer {
	uint32_t number_of_pairs;

	uint32_t  offset_to_pairs;

	uint32_t magic;
};
struct pipebuf {
	u_int   cnt;            
	u_int   in;             
	u_int   out;            
	u_int   size;           
	caddr_t OS_PTRAUTH_SIGNED_PTR("pipe.buffer") buffer; 
};
struct pipe {
	struct  pipebuf pipe_buffer;    
	struct  selinfo pipe_sel;       
	pid_t   pipe_pgid;              
	struct  pipe *pipe_peer;        
	u_int   pipe_state;             
	int     pipe_busy;              
	lck_mtx_t *pipe_mtxp;           
	struct  timespec st_atimespec;  
	struct  timespec st_mtimespec;  
	struct  timespec st_ctimespec;  
	struct  label *pipe_label;      
};
struct pollfd {
	int     fd;
	short   events;
	short   revents;
};
struct pseminfo {
	unsigned int    psem_flags;
	unsigned int    psem_usecount;
	mode_t          psem_mode;
	uid_t           psem_uid;
	gid_t           psem_gid;
	char            psem_name[PSEMNAMLEN + 1];      
	void *          psem_semobject;
	struct label *  psem_label;
	pid_t           psem_creator_pid;
	uint64_t        psem_creator_uniqueid;
};
struct pshminfo {
	unsigned int pshm_flags;
	unsigned int pshm_usecount;
	off_t        pshm_length;
	mode_t       pshm_mode;
	uid_t        pshm_uid;
	gid_t        pshm_gid;
	char         pshm_name[PSHMNAMLEN + 1];
	void         *pshm_memobject;
	struct label *pshm_label;
};
struct proc_ident {
	uint64_t        p_uniqueid;
	pid_t           p_pid;
	int             p_idversion;
};
struct syscall_filter_callbacks {
	int version;
	const syscall_filter_cbfunc_t unix_filter_cbfunc;
	const syscall_filter_cbfunc_t mach_filter_cbfunc;
	const kobject_filter_cbfunc_t kobj_filter_cbfunc;
};
struct proc_policy_attribute {
	uint32_t        ppattr_attribute;  
	uint32_t        ppattr_resv;       
	uint64_t        ppattr_value1;     
	uint64_t        ppattr_value2;     
	uint64_t        ppattr_value3;     
	uint64_t        ppattr_resv1[4];    
} proc_policy_attribute_t;
struct proc_policy_cpuusage_attr {
	uint32_t        ppattr_cpu_attr;  
	uint32_t        ppattr_cpu_percentage;       
	uint64_t        ppattr_cpu_attr_interval;     
	uint64_t        ppattr_cpu_attr_deadline;     
} proc_policy_cpuusage_attr_t;
struct proc_bsdinfo {
	uint32_t                pbi_flags;              
	uint32_t                pbi_status;
	uint32_t                pbi_xstatus;
	uint32_t                pbi_pid;
	uint32_t                pbi_ppid;
	uid_t                   pbi_uid;
	gid_t                   pbi_gid;
	uid_t                   pbi_ruid;
	gid_t                   pbi_rgid;
	uid_t                   pbi_svuid;
	gid_t                   pbi_svgid;
	uint32_t                rfu_1;                  
	char                    pbi_comm[MAXCOMLEN];
	char                    pbi_name[2 * MAXCOMLEN];  
	uint32_t                pbi_nfiles;
	uint32_t                pbi_pgid;
	uint32_t                pbi_pjobc;
	uint32_t                e_tdev;                 
	uint32_t                e_tpgid;                
	int32_t                 pbi_nice;
	uint64_t                pbi_start_tvsec;
	uint64_t                pbi_start_tvusec;
};
struct proc_bsdshortinfo {
	uint32_t                pbsi_pid;               
	uint32_t                pbsi_ppid;              
	uint32_t                pbsi_pgid;              
	uint32_t                pbsi_status;            
	char                    pbsi_comm[MAXCOMLEN];   
	uint32_t                pbsi_flags;              
	uid_t                   pbsi_uid;               
	gid_t                   pbsi_gid;               
	uid_t                   pbsi_ruid;              
	gid_t                   pbsi_rgid;              
	uid_t                   pbsi_svuid;             
	gid_t                   pbsi_svgid;             
	uint32_t                pbsi_rfu;               
};
struct proc_taskinfo {
	uint64_t                pti_virtual_size;       
	uint64_t                pti_resident_size;      
	uint64_t                pti_total_user;         
	uint64_t                pti_total_system;
	uint64_t                pti_threads_user;       
	uint64_t                pti_threads_system;
	int32_t                 pti_policy;             
	int32_t                 pti_faults;             
	int32_t                 pti_pageins;            
	int32_t                 pti_cow_faults;         
	int32_t                 pti_messages_sent;      
	int32_t                 pti_messages_received;  
	int32_t                 pti_syscalls_mach;      
	int32_t                 pti_syscalls_unix;      
	int32_t                 pti_csw;                
	int32_t                 pti_threadnum;          
	int32_t                 pti_numrunning;         
	int32_t                 pti_priority;           
};
struct proc_taskallinfo {
	struct proc_bsdinfo     pbsd;
	struct proc_taskinfo    ptinfo;
};
struct proc_threadinfo {
	uint64_t                pth_user_time;          
	uint64_t                pth_system_time;        
	int32_t                 pth_cpu_usage;          
	int32_t                 pth_policy;             
	int32_t                 pth_run_state;          
	int32_t                 pth_flags;              
	int32_t                 pth_sleep_time;         
	int32_t                 pth_curpri;             
	int32_t                 pth_priority;           
	int32_t                 pth_maxpriority;        
	char                    pth_name[MAXTHREADNAMESIZE];    
};
struct proc_regioninfo {
	uint32_t                pri_protection;
	uint32_t                pri_max_protection;
	uint32_t                pri_inheritance;
	uint32_t                pri_flags;              
	uint64_t                pri_offset;
	uint32_t                pri_behavior;
	uint32_t                pri_user_wired_count;
	uint32_t                pri_user_tag;
	uint32_t                pri_pages_resident;
	uint32_t                pri_pages_shared_now_private;
	uint32_t                pri_pages_swapped_out;
	uint32_t                pri_pages_dirtied;
	uint32_t                pri_ref_count;
	uint32_t                pri_shadow_depth;
	uint32_t                pri_share_mode;
	uint32_t                pri_private_pages_resident;
	uint32_t                pri_shared_pages_resident;
	uint32_t                pri_obj_id;
	uint32_t                pri_depth;
	uint64_t                pri_address;
	uint64_t                pri_size;
};
struct proc_workqueueinfo {
	uint32_t        pwq_nthreads;           
	uint32_t        pwq_runthreads;         
	uint32_t        pwq_blockedthreads;     
	uint32_t        pwq_state;
};
struct proc_fileinfo {
	uint32_t                fi_openflags;
	uint32_t                fi_status;
	off_t                   fi_offset;
	int32_t                 fi_type;
	uint32_t                fi_guardflags;
};
struct proc_exitreasonbasicinfo {
	uint32_t                        beri_namespace;
	uint64_t                        beri_code;
	uint64_t                        beri_flags;
	uint32_t                        beri_reason_buf_size;
} __attribute__((packed));
struct proc_exitreasoninfo {
	uint32_t                        eri_namespace;
	uint64_t                        eri_code;
	uint64_t                        eri_flags;
	uint32_t                        eri_reason_buf_size;
	uint64_t                        eri_kcd_buf;
} __attribute__((packed));
struct vinfo_stat {
	uint32_t        vst_dev;        
	uint16_t        vst_mode;       
	uint16_t        vst_nlink;      
	uint64_t        vst_ino;        
	uid_t           vst_uid;        
	gid_t           vst_gid;        
	int64_t         vst_atime;      
	int64_t         vst_atimensec;  
	int64_t         vst_mtime;      
	int64_t         vst_mtimensec;  
	int64_t         vst_ctime;      
	int64_t         vst_ctimensec;  
	int64_t         vst_birthtime;  
	int64_t         vst_birthtimensec;      
	off_t           vst_size;       
	int64_t         vst_blocks;     
	int32_t         vst_blksize;    
	uint32_t        vst_flags;      
	uint32_t        vst_gen;        
	uint32_t        vst_rdev;       
	int64_t         vst_qspare[2];  
};
struct vnode_info {
	struct vinfo_stat       vi_stat;
	int                     vi_type;
	int                     vi_pad;
	fsid_t                  vi_fsid;
};
struct vnode_info_path {
	struct vnode_info       vip_vi;
	char                    vip_path[MAXPATHLEN];   
};
struct vnode_fdinfo {
	struct proc_fileinfo    pfi;
	struct vnode_info       pvi;
};
struct vnode_fdinfowithpath {
	struct proc_fileinfo    pfi;
	struct vnode_info_path  pvip;
};
struct proc_regionwithpathinfo {
	struct proc_regioninfo  prp_prinfo;
	struct vnode_info_path  prp_vip;
};
struct proc_regionpath {
	uint64_t prpo_addr;
	uint64_t prpo_regionlength;
	char prpo_path[MAXPATHLEN];
};
struct proc_vnodepathinfo {
	struct vnode_info_path  pvi_cdir;
	struct vnode_info_path  pvi_rdir;
};
struct proc_threadwithpathinfo {
	struct proc_threadinfo  pt;
	struct vnode_info_path  pvip;
};
struct in4in6_addr {
	u_int32_t               i46a_pad32[3];
	struct in_addr          i46a_addr4;
};
struct in_sockinfo {
	int                                     insi_fport;             
	int                                     insi_lport;             
	uint64_t                                insi_gencnt;            
	uint32_t                                insi_flags;             
	uint32_t                                insi_flow;

	uint8_t                                 insi_vflag;             
	uint8_t                                 insi_ip_ttl;            
	uint32_t                                rfu_1;                  
	union {
		struct in4in6_addr      ina_46;
		struct in6_addr         ina_6;
	}                                       insi_faddr;             
	union {
		struct in4in6_addr      ina_46;
		struct in6_addr         ina_6;
	}                                       insi_laddr;             
	struct {
		u_char                  in4_tos;                        
	}                                       insi_v4;
	struct {
		uint8_t                 in6_hlim;
		int                     in6_cksum;
		u_short                 in6_ifindex;
		short                   in6_hops;
	}                                       insi_v6;
};
struct tcp_sockinfo {
	struct in_sockinfo              tcpsi_ini;
	int                             tcpsi_state;
	int                             tcpsi_timer[TSI_T_NTIMERS];
	int                             tcpsi_mss;
	uint32_t                        tcpsi_flags;
	uint32_t                        rfu_1;          
	uint64_t                        tcpsi_tp;       
};
struct un_sockinfo {
	uint64_t                                unsi_conn_so;   
	uint64_t                                unsi_conn_pcb;  
	union {
		struct sockaddr_un      ua_sun;
		char                    ua_dummy[SOCK_MAXADDRLEN];
	}                                       unsi_addr;      
	union {
		struct sockaddr_un      ua_sun;
		char                    ua_dummy[SOCK_MAXADDRLEN];
	}                                       unsi_caddr;     
};
struct ndrv_info {
	uint32_t        ndrvsi_if_family;
	uint32_t        ndrvsi_if_unit;
	char            ndrvsi_if_name[IF_NAMESIZE];
};
struct kern_event_info {
	uint32_t        kesi_vendor_code_filter;
	uint32_t        kesi_class_filter;
	uint32_t        kesi_subclass_filter;
};
struct kern_ctl_info {
	uint32_t        kcsi_id;
	uint32_t        kcsi_reg_unit;
	uint32_t        kcsi_flags;                     
	uint32_t        kcsi_recvbufsize;               
	uint32_t        kcsi_sendbufsize;               
	uint32_t        kcsi_unit;
	char            kcsi_name[MAX_KCTL_NAME];       
};
struct vsock_sockinfo {
	uint32_t        local_cid;
	uint32_t        local_port;
	uint32_t        remote_cid;
	uint32_t        remote_port;
};
struct sockbuf_info {
	uint32_t                sbi_cc;
	uint32_t                sbi_hiwat;                      
	uint32_t                sbi_mbcnt;
	uint32_t                sbi_mbmax;
	uint32_t                sbi_lowat;
	short                   sbi_flags;
	short                   sbi_timeo;
};
struct socket_info {
	struct vinfo_stat                       soi_stat;
	uint64_t                                soi_so;         
	uint64_t                                soi_pcb;        
	int                                     soi_type;
	int                                     soi_protocol;
	int                                     soi_family;
	short                                   soi_options;
	short                                   soi_linger;
	short                                   soi_state;
	short                                   soi_qlen;
	short                                   soi_incqlen;
	short                                   soi_qlimit;
	short                                   soi_timeo;
	u_short                                 soi_error;
	uint32_t                                soi_oobmark;
	struct sockbuf_info                     soi_rcv;
	struct sockbuf_info                     soi_snd;
	int                                     soi_kind;
	uint32_t                                rfu_1;          
	union {
		struct in_sockinfo      pri_in;                 
		struct tcp_sockinfo     pri_tcp;                
		struct un_sockinfo      pri_un;                 
		struct ndrv_info        pri_ndrv;               
		struct kern_event_info  pri_kern_event;         
		struct kern_ctl_info    pri_kern_ctl;           
		struct vsock_sockinfo   pri_vsock;              
	}                                       soi_proto;
};
struct socket_fdinfo {
	struct proc_fileinfo    pfi;
	struct socket_info      psi;
};
struct psem_info {
	struct vinfo_stat       psem_stat;
	char                    psem_name[MAXPATHLEN];
};
struct psem_fdinfo {
	struct proc_fileinfo    pfi;
	struct psem_info        pseminfo;
};
struct pshm_info  {
	struct vinfo_stat       pshm_stat;
	uint64_t                pshm_mappaddr;
	char                    pshm_name[MAXPATHLEN];
};
struct pshm_fdinfo {
	struct proc_fileinfo    pfi;
	struct pshm_info        pshminfo;
};
struct pipe_info {
	struct vinfo_stat       pipe_stat;
	uint64_t                pipe_handle;
	uint64_t                pipe_peerhandle;
	int                     pipe_status;
	int                     rfu_1;  
};
struct pipe_fdinfo {
	struct proc_fileinfo    pfi;
	struct pipe_info        pipeinfo;
};
struct kqueue_info {
	struct vinfo_stat       kq_stat;
	uint32_t                kq_state;
	uint32_t                rfu_1;  
};
struct kqueue_dyninfo {
	struct kqueue_info kqdi_info;
	uint64_t kqdi_servicer;
	uint64_t kqdi_owner;
	uint32_t kqdi_sync_waiters;
	uint8_t  kqdi_sync_waiter_qos;
	uint8_t  kqdi_async_qos;
	uint16_t kqdi_request_state;
	uint8_t  kqdi_events_qos;
	uint8_t  kqdi_pri;
	uint8_t  kqdi_pol;
	uint8_t  kqdi_cpupercent;
	uint8_t  _kqdi_reserved0[4];
	uint64_t _kqdi_reserved1[4];
};
struct kqueue_fdinfo {
	struct proc_fileinfo    pfi;
	struct kqueue_info      kqueueinfo;
};
struct appletalk_info {
	struct vinfo_stat       atalk_stat;
};
struct appletalk_fdinfo {
	struct proc_fileinfo    pfi;
	struct appletalk_info   appletalkinfo;
};
struct proc_fdinfo {
	int32_t                 proc_fd;
	uint32_t                proc_fdtype;
};
struct proc_fileportinfo {
	uint32_t                proc_fileport;
	uint32_t                proc_fdtype;
};
struct proc_channel_info {
	uuid_t                  chi_instance;
	uint32_t                chi_port;
	uint32_t                chi_type;
	uint32_t                chi_flags;
	uint32_t                rfu_1;
};
struct channel_fdinfo {
	struct proc_fileinfo    pfi;
	struct proc_channel_info channelinfo;
};
struct proc_uniqidentifierinfo {
	uint8_t                 p_uuid[16];             
	uint64_t                p_uniqueid;             
	uint64_t                p_puniqueid;            
	int32_t                 p_idversion;            
	int32_t                 p_orig_ppidversion;     
	uint64_t                p_reserve2;             
	uint64_t                p_reserve3;             
};
struct proc_bsdinfowithuniqid {
	struct proc_bsdinfo             pbsd;
	struct proc_uniqidentifierinfo  p_uniqidentifier;
};
struct proc_archinfo {
	cpu_type_t              p_cputype;
	cpu_subtype_t           p_cpusubtype;
};
struct proc_pidcoalitioninfo {
	uint64_t coalition_id[COALITION_NUM_TYPES];
	uint64_t reserved1;
	uint64_t reserved2;
	uint64_t reserved3;
};
struct proc_originatorinfo {
	uuid_t                  originator_uuid;        
	pid_t                   originator_pid;         
	uint64_t                p_reserve2;
	uint64_t                p_reserve3;
	uint64_t                p_reserve4;
};
struct proc_ipctableinfo {
	uint32_t               table_size;
	uint32_t               table_free;
};
struct proc_threadschedinfo {
	uint64_t               int_time_ns;         
};
struct proc_threadcounts_data {
	uint64_t ptcd_instructions;
	uint64_t ptcd_cycles;
	uint64_t ptcd_user_time_mach;
	uint64_t ptcd_system_time_mach;
	uint64_t ptcd_energy_nj;
};
struct proc_threadcounts {
	uint16_t ptc_len;
	uint16_t ptc_reserved0;
	uint32_t ptc_reserved1;
	struct proc_threadcounts_data ptc_counts[];
};
struct proc_delegated_signal_info {
	audit_token_t instigator;
	audit_token_t target;
};
struct kevent_extinfo {
	struct kevent_qos_s kqext_kev;
	uint64_t kqext_sdata;
	int kqext_status;
	int kqext_sfflags;
	uint64_t kqext_reserved[2];
};
struct session {
	lck_mtx_t               s_mlock;             
	LIST_ENTRY(session)     s_hash;              
	struct proc            *s_leader;            
	struct vnode           *s_ttyvp;             
	struct tty             *s_ttyp;              
	uint32_t                s_ttyvid;            
	pid_t                   s_ttypgrpid;         
	dev_t _Atomic           s_ttydev;            
	pid_t                   s_sid;               
	os_ref_atomic_t         s_refcount;
	char                    s_login[MAXLOGNAME]; 
};
struct pgrp {
	union {
		lck_mtx_t       pg_mlock;       
		struct smr_node pg_smr_node;
	};
	struct smrq_slink       pg_hash;        
	LIST_HEAD(, proc)       pg_members;     
	struct session         *pg_session;     
	pid_t                   pg_id;          
	int                     pg_jobc;        
	os_ref_atomic_t         pg_refcount;
	os_ref_atomic_t         pg_hashref;
};
struct  sigacts {
	user_addr_t ps_sigact[NSIG];    
	user_addr_t ps_trampact[NSIG];  
	sigset_t ps_catchmask[NSIG];    
	sigset_t ps_sigonstack;         
	sigset_t ps_sigintr;            
	sigset_t ps_sigreset;           
	sigset_t ps_signodefer;         
	sigset_t ps_siginfo;            
	sigset_t ps_oldmask;            
	_Atomic uint32_t ps_sigreturn_validation; 
	int     ps_flags;               
	int     ps_sig;                 
	int     ps_code;                
	int     ps_addr;                
};
struct proc {
	union {
		LIST_ENTRY(proc) p_list;                
		struct smr_node  p_smr_node;
	};
	struct  proc *  XNU_PTRAUTH_SIGNED_PTR("proc.p_pptr") p_pptr;   
	proc_ro_t       p_proc_ro;
	pid_t           p_ppid;                 
	pid_t           p_pgrpid;               
	uid_t           p_uid;
	gid_t           p_gid;
	uid_t           p_ruid;
	gid_t           p_rgid;
	uid_t           p_svuid;
	gid_t           p_svgid;
	pid_t           p_sessionid;
	uint64_t        p_puniqueid;            

	lck_mtx_t       p_mlock;                
	pid_t           p_pid;                  
	char            p_stat;                 
	char            p_shutdownstate;
	char            p_kdebug;               
	char            p_btrace;               

	LIST_ENTRY(proc) p_pglist;              
	LIST_ENTRY(proc) p_sibling;             
	LIST_HEAD(, proc) p_children;           
	TAILQ_HEAD(, uthread) p_uthlist;        

	struct smrq_slink p_hash;               


	lck_mtx_t       p_ucred_mlock;          
	lck_mtx_t       p_audit_mlock;          

	struct  filedesc p_fd;                  
	struct  pstats *p_stats;                
	SMR_POINTER(struct plimit *) p_limit;
	SMR_POINTER(struct pgrp *XNU_PTRAUTH_SIGNED_PTR("proc.p_pgrp")) p_pgrp; 

	struct sigacts  p_sigacts;
	lck_spin_t      p_slock;                

	int             p_siglist;              
	unsigned int    p_flag;                 
	unsigned int    p_lflag;                
	unsigned int    p_listflag;             
	unsigned int    p_ladvflag;             
	os_ref_atomic_t p_refcount;             
	os_ref_atomic_t p_waitref;              
	int             p_childrencnt;          
	int             p_parentref;            
	pid_t           p_oppid;                
	u_int           p_xstat;                
	int             p_aio_total_count;              


	struct  itimerval p_realtimer;          
	struct  timeval p_rtime;                
	struct  itimerval p_vtimer_user;        
	struct  itimerval p_vtimer_prof;        

	struct  timeval p_rlim_cpu;             
	int             p_debugger;             
	boolean_t       sigwait;        
	void    *sigwait_thread;        
	void    *exit_thread;           
	pid_t   si_pid;                 
	u_int   si_status;              
	u_int   si_code;                
	uid_t   si_uid;                 

	void * vm_shm;                  
	int             p_ractive;
	pid_t             p_responsible_pid;    

	int                             p_dtrace_probes;                
	u_int                           p_dtrace_count;                 
	uint8_t                         p_dtrace_stop;                  
	user_addr_t                     p_dtrace_argv;                  
	user_addr_t                     p_dtrace_envp;                  
	lck_mtx_t                       p_dtrace_sprlock;               
	struct dtrace_ptss_page*        p_dtrace_ptss_pages;            
	struct dtrace_ptss_page_entry*  p_dtrace_ptss_free_list;        
	struct dtrace_helpers*          p_dtrace_helpers;               
	struct dof_ioctl_data*          p_dtrace_lazy_dofs;             

	__xnu_struct_group(proc_forkcopy_data, p_forkcopy, {
		u_int   p_argslen;       
		int     p_argc;                 
		user_addr_t user_stack;         
		struct  vnode * XNU_PTRAUTH_SIGNED_PTR("proc.p_textvp") p_textvp;       
		off_t   p_textoff;              

		sigset_t p_sigmask;             
		sigset_t p_sigignore;   
		sigset_t p_sigcatch;    
		sigset_t p_workq_allow_sigmask; 

		u_char  p_priority;     
		u_char  p_resv0;        
		char    p_nice;         
		u_char  p_resv1;        

		
		command_t   p_comm;
		proc_name_t p_name;     
		uint8_t p_xhighbits;    
		pid_t   p_contproc;     

		uint32_t        p_pcaction;     
		uint8_t p_uuid[16];                                

		uint8_t p_responsible_uuid[16]; 

		
		cpu_type_t      p_cputype;
		cpu_subtype_t   p_cpusubtype;
	});

	TAILQ_HEAD(, aio_workq_entry ) p_aio_activeq;   
	TAILQ_HEAD(, aio_workq_entry ) p_aio_doneq;     

	struct klist p_klist;  

	struct  rusage_superset *p_ru;  
	thread_t        p_signalholder;
	thread_t        p_transholder;
	int             p_sigwaitcnt;
	u_short p_acflag;       
	volatile u_short p_vfs_iopolicy;        

	user_addr_t     p_threadstart;          
	user_addr_t     p_wqthread;             
	int     p_pthsize;                      
	uint32_t        p_pth_tsd_offset;       
	user_addr_t     p_stack_addr_hint;      
	struct workqueue *_Atomic p_wqptr;                      

	struct  timeval p_start;                
	void *  p_rcall;
	void *  p_pthhash;                      
	volatile uint64_t was_throttled __attribute__((aligned(8))); 
	volatile uint64_t did_throttle __attribute__((aligned(8)));  

	uint64_t        p_dispatchqueue_offset;
	uint64_t        p_dispatchqueue_serialno_offset;
	uint64_t        p_dispatchqueue_label_offset;
	uint64_t        p_return_to_kernel_offset;
	uint64_t        p_mach_thread_self_offset;
	uint64_t        p_pthread_wq_quantum_offset;
	uint8_t p_crash_behavior;  
	bool p_posix_spawn_failed; 
	bool p_disallow_map_with_linking; 


	_Atomic uint32_t  p_user_faults; 

	uint32_t          p_memlimit_increase; 

	uint64_t p_crash_behavior_deadline; 

	uint32_t          p_crash_count;      
	uint32_t          p_throttle_timeout; 

	struct os_reason     *p_exit_reason;


	char * p_subsystem_root_path;
};
struct user32_extern_proc {
	union {
		struct {
			uint32_t __p_forw;      
			uint32_t __p_back;
		} p_st1;
		struct user32_timeval __p_starttime;    
	} p_un;
	uint32_t        p_vmspace;      
	uint32_t        p_sigacts;      
	int             p_flag;                 
	char    p_stat;                 
	pid_t   p_pid;                  
	pid_t   p_oppid;                
	int             p_dupfd;                
	uint32_t user_stack;    
	uint32_t exit_thread;  
	int             p_debugger;             
	boolean_t       sigwait;        
	u_int   p_estcpu;        
	int             p_cpticks;       
	fixpt_t p_pctcpu;        
	uint32_t        p_wchan;         
	uint32_t        p_wmesg;         
	u_int   p_swtime;        
	u_int   p_slptime;       
	struct  user32_itimerval p_realtimer;   
	struct  user32_timeval p_rtime; 
	u_quad_t p_uticks;              
	u_quad_t p_sticks;              
	u_quad_t p_iticks;              
	int             p_traceflag;            
	uint32_t        p_tracep;       
	int             p_siglist;              
	uint32_t        p_textvp;       
	int             p_holdcnt;              
	sigset_t p_sigmask;     
	sigset_t p_sigignore;   
	sigset_t p_sigcatch;    
	u_char  p_priority;     
	u_char  p_usrpri;       
	char    p_nice;         
	char    p_comm[MAXCOMLEN + 1];
	uint32_t        p_pgrp; 
	uint32_t        p_addr; 
	u_short p_xstat;        
	u_short p_acflag;       
	uint32_t        p_ru;   
};
struct user64_extern_proc {
	union {
		struct {
			user_addr_t __p_forw;   
			user_addr_t __p_back;
		} p_st1;
		struct user64_timeval __p_starttime;    
	} p_un;
	user_addr_t     p_vmspace;      
	user_addr_t             p_sigacts;      
	int             p_flag;                 
	char    p_stat;                 
	pid_t   p_pid;                  
	pid_t   p_oppid;                
	int             p_dupfd;                
	user_addr_t user_stack __attribute((aligned(8)));       
	user_addr_t exit_thread;  
	int             p_debugger;             
	boolean_t       sigwait;        
	u_int   p_estcpu;        
	int             p_cpticks;       
	fixpt_t p_pctcpu;        
	user_addr_t     p_wchan __attribute((aligned(8)));       
	user_addr_t     p_wmesg;         
	u_int   p_swtime;        
	u_int   p_slptime;       
	struct  user64_itimerval p_realtimer;   
	struct  user64_timeval p_rtime; 
	u_quad_t p_uticks;              
	u_quad_t p_sticks;              
	u_quad_t p_iticks;              
	int             p_traceflag;            
	user_addr_t     p_tracep __attribute((aligned(8)));     
	int             p_siglist;              
	user_addr_t     p_textvp __attribute((aligned(8)));     
	int             p_holdcnt;              
	sigset_t p_sigmask;     
	sigset_t p_sigignore;   
	sigset_t p_sigcatch;    
	u_char  p_priority;     
	u_char  p_usrpri;       
	char    p_nice;         
	char    p_comm[MAXCOMLEN + 1];
	user_addr_t     p_pgrp __attribute((aligned(8)));       
	user_addr_t     p_addr; 
	u_short p_xstat;        
	u_short p_acflag;       
	user_addr_t     p_ru __attribute((aligned(8))); 
};
struct proc_platform_ro_data {
	uint32_t p_platform;
	uint32_t p_min_sdk;
	uint32_t p_sdk;
};
struct task_token_ro_data {
	security_token_t sec_token;
	audit_token_t audit_token;
};
struct task_filter_ro_data {
	uint8_t *__unsafe_indexable mach_trap_filter_mask; 
	uint8_t *__unsafe_indexable mach_kobj_filter_mask; 
};
struct proc_ro {
	struct proc *pr_proc;
	struct task *pr_task;

	__xnu_struct_group(proc_ro_data, proc_data, {
		uint64_t p_uniqueid;                               
		int p_idversion;                                   
		pid_t p_orig_ppid;                                 
		int p_orig_ppidversion;                            
		uint32_t p_csflags;
		SMR_POINTER(struct ucred *) p_ucred;               
		uint8_t *__unsafe_indexable syscall_filter_mask;   
		struct proc_platform_ro_data p_platform_data;
	});

	__xnu_struct_group(task_ro_data, task_data, {
		
		struct task_token_ro_data task_tokens;
		struct task_filter_ro_data task_filters;
		uint32_t t_flags_ro;                               
		uint32_t task_control_port_options;
	});
};
struct ipctlparam {
	struct ip   *ipc_icmp_ip;  
	struct mbuf *ipc_m;        
	struct icmp *ipc_icmp;     
	size_t       ipc_off;      
};
struct protosw_old {
	short   pr_type;                
	struct  domain *pr_domain;      
	short   pr_protocol;            
	unsigned int pr_flags;          
	void    (*pr_input)             
	(struct mbuf *, int len);
	int     (*pr_output)            
	(struct mbuf *m, struct socket *so);
	void    (*pr_ctlinput)          
	(int, struct sockaddr *, void *, struct ifnet *);
	int     (*pr_ctloutput)         
	(struct socket *, struct sockopt *);
	void    *pr_ousrreq;
	void    (*pr_init)(void);       
	void    (*pr_unused)(void);     
	void    (*pr_unused2)(void);    
	void    (*pr_drain)(void);      
	int     (*pr_sysctl)            
	(int *, u_int, void *, size_t *, void *, size_t);
	struct  pr_usrreqs_old *pr_usrreqs; 
	int     (*pr_lock)              
	(struct socket *so, int refcnt, void *debug);
	int     (*pr_unlock)            
	(struct socket *so, int refcnt, void *debug);
	lck_mtx_t * __single (*pr_getlock)        
	(struct socket *so, int flags);
	TAILQ_HEAD(, socket_filter) pr_filter_head;
	struct protosw_old *pr_next;    
	u_int32_t       reserved[1];    
};
struct protosw {
	TAILQ_ENTRY(protosw) pr_entry; 
	struct  domain *pr_domain;      
	struct protosw *pr_protosw;     
	u_int16_t pr_type;              
	u_int16_t pr_protocol;          
	u_int32_t pr_flags;             
	void    (*pr_input)             
	(struct mbuf *, int len);
	int     (*pr_output)            
	(struct mbuf *m, struct socket *so);
	void    (*pr_ctlinput)          
	(int, struct sockaddr *, void *, struct ifnet *);
	int     (*pr_ctloutput)         
	(struct socket *, struct sockopt *);
	struct  pr_usrreqs *pr_usrreqs; 
	void    (*pr_init)              
	(struct protosw *, struct domain *);
	void    (*pr_drain)(void);      
	int     (*pr_sysctl)            
	(int *, u_int, void *, size_t *, void *, size_t);
	int     (*pr_lock)              
	(struct socket *so, int refcnt, void *debug);
	int     (*pr_unlock)            
	(struct socket *so, int refcnt, void *debug);
	lck_mtx_t * __single (*pr_getlock)        
	(struct socket *so, int flags);
	TAILQ_HEAD(, socket_filter) pr_filter_head;
	struct protosw_old *pr_old;

	void    (*pr_update_last_owner) 
	(struct socket *so, struct proc *p, struct proc *ep);

	void    (*pr_copy_last_owner) 
	(struct socket *so, struct socket *head);
};
struct pr_usrreqs_old {
	int     (*pru_abort)(struct socket *so);
	int     (*pru_accept)(struct socket *so, struct sockaddr **nam);
	int     (*pru_attach)(struct socket *so, int proto, struct proc *p);
	int     (*pru_bind)(struct socket *so, struct sockaddr *nam,
	    struct proc *p);
	int     (*pru_connect)(struct socket *so, struct sockaddr *nam,
	    struct proc *p);
	int     (*pru_connect2)(struct socket *so1, struct socket *so2);
	int     (*pru_control)(struct socket *so, u_long cmd, caddr_t data,
	    struct ifnet *ifp, struct proc *p);
	int     (*pru_detach)(struct socket *so);
	int     (*pru_disconnect)(struct socket *so);
	int     (*pru_listen)(struct socket *so, struct proc *p);
	int     (*pru_peeraddr)(struct socket *so, struct sockaddr **nam);
	int     (*pru_rcvd)(struct socket *so, int flags);
	int     (*pru_rcvoob)(struct socket *so, struct mbuf *m, int flags);
	int     (*pru_send)(struct socket *so, int flags, struct mbuf *m,
	    struct sockaddr *addr, struct mbuf *control,
	    struct proc *p);
	int     (*pru_sense)(struct socket *so, void  *sb, int isstat64);
	int     (*pru_shutdown)(struct socket *so);
	int     (*pru_sockaddr)(struct socket *so, struct sockaddr **nam);
	int     (*pru_sosend)(struct socket *so, struct sockaddr *addr,
	    struct uio *uio, struct mbuf *top, struct mbuf *control,
	    int flags);
	int     (*pru_soreceive)(struct socket *so, struct sockaddr **paddr,
	    struct uio *uio, struct mbuf **mp0, struct mbuf *__single *controlp,
	    int *flagsp);
	int     (*pru_sopoll)(struct socket *so, int events,
	    struct ucred *cred, void *);
};
struct pr_usrreqs {
	uint32_t pru_flags;     
	int     (*pru_abort)(struct socket *);
	int     (*pru_accept)(struct socket *, struct sockaddr **);
	int     (*pru_attach)(struct socket *, int proto, struct proc *);
	int     (*pru_bind)(struct socket *, struct sockaddr *, struct proc *);
	int     (*pru_connect)(struct socket *, struct sockaddr *,
	    struct proc *);
	int     (*pru_connect2)(struct socket *, struct socket *);
	int     (*pru_connectx)(struct socket *, struct sockaddr *,
	    struct sockaddr *, struct proc *, uint32_t,
	    sae_associd_t, sae_connid_t *, uint32_t, void *, uint32_t,
	    struct uio *, user_ssize_t *);
	int     (*pru_control)(struct socket *,
	    u_long cmd, caddr_t __sized_by(IOCPARM_LEN(cmd)) data,
	    struct ifnet *, struct proc *);
	int     (*pru_detach)(struct socket *);
	int     (*pru_disconnect)(struct socket *);
	int     (*pru_disconnectx)(struct socket *,
	    sae_associd_t, sae_connid_t);
	int     (*pru_listen)(struct socket *, struct proc *);
	int     (*pru_peeraddr)(struct socket *, struct sockaddr **);
	int     (*pru_rcvd)(struct socket *, int);
	int     (*pru_rcvoob)(struct socket *, struct mbuf *, int);
	int     (*pru_send)(struct socket *, int, struct mbuf *,
	    struct sockaddr *, struct mbuf *, struct proc *);
	int     (*pru_send_list)(struct socket *, struct mbuf *, u_int *, int);
	int     (*pru_sense)(struct socket *, void *, int);
	int     (*pru_shutdown)(struct socket *);
	int     (*pru_sockaddr)(struct socket *, struct sockaddr **);
	int     (*pru_sopoll)(struct socket *, int, struct ucred *, void *);
	int     (*pru_soreceive)(struct socket *, struct sockaddr **,
	    struct uio *, struct mbuf **, struct mbuf **, int *);
	int     (*pru_sosend)(struct socket *, struct sockaddr *,
	    struct uio *, struct mbuf *, struct mbuf *, int);
	int     (*pru_sosend_list)(struct socket *, struct mbuf *, size_t, u_int *, int);
	int     (*pru_socheckopt)(struct socket *, struct sockopt *);
	int     (*pru_preconnect)(struct socket *so);
	int     (*pru_defunct)(struct socket *);
};
struct ksyn_waitq_element {
	char opaque[48];
};
struct pthread_functions_s {
	int version;

	void (*pthread_init)(void);

	void *__unused_was_fill_procworkqueue;
	void *__unused1;
	void *__unused2;
	void *__unused_was_workqueue_exit;
	void *__unused_was_workqueue_mark_exiting;
	void *__unused_was_workqueue_thread_yielded;

	void (*pth_proc_hashinit)(proc_t p);
	void (*pth_proc_hashdelete)(proc_t p);

	int (*bsdthread_create)(struct proc *p, user_addr_t user_func, user_addr_t user_funcarg, user_addr_t user_stack, user_addr_t user_pthread, uint32_t flags, user_addr_t *retval);
	int (*bsdthread_register)(struct proc *p, user_addr_t threadstart, user_addr_t wqthread, int pthsize, user_addr_t dummy_value, user_addr_t targetconc_ptr, uint64_t dispatchqueue_offset, int32_t *retval);
	int (*bsdthread_terminate)(struct proc *p, user_addr_t stackaddr, size_t size, uint32_t kthport, uint32_t sem, int32_t *retval);
	int (*thread_selfid)(struct proc *p, uint64_t *retval);
	void *__unused_was_workq_kernreturn;
	void *__unused_was_workq_open;

	int (*psynch_mutexwait)(proc_t p, user_addr_t mutex, uint32_t mgen, uint32_t  ugen, uint64_t tid, uint32_t flags, uint32_t *retval);
	int (*psynch_mutexdrop)(proc_t p, user_addr_t mutex, uint32_t mgen, uint32_t  ugen, uint64_t tid, uint32_t flags, uint32_t *retval);
	int (*psynch_cvbroad)(proc_t p, user_addr_t cv, uint64_t cvlsgen, uint64_t cvudgen, uint32_t flags, user_addr_t mutex, uint64_t mugen, uint64_t tid, uint32_t *retval);
	int (*psynch_cvsignal)(proc_t p, user_addr_t cv, uint64_t cvlsgen, uint32_t cvugen, int thread_port, user_addr_t mutex, uint64_t mugen, uint64_t tid, uint32_t flags, uint32_t *retval);
	int (*psynch_cvwait)(proc_t p, user_addr_t cv, uint64_t cvlsgen, uint32_t cvugen, user_addr_t mutex, uint64_t mugen, uint32_t flags, int64_t sec, uint32_t nsec, uint32_t * retval);
	int (*psynch_cvclrprepost)(proc_t p, user_addr_t cv, uint32_t cvgen, uint32_t cvugen, uint32_t cvsgen, uint32_t prepocnt, uint32_t preposeq, uint32_t flags, int *retval);
	int (*psynch_rw_longrdlock)(proc_t p, user_addr_t rwlock, uint32_t lgenval, uint32_t ugenval, uint32_t rw_wc, int flags, uint32_t *retval);
	int (*psynch_rw_rdlock)(proc_t p, user_addr_t rwlock, uint32_t lgenval, uint32_t ugenval, uint32_t rw_wc, int flags, uint32_t *retval);
	int (*psynch_rw_unlock)(proc_t p, user_addr_t rwlock, uint32_t lgenval, uint32_t ugenval, uint32_t rw_wc, int flags, uint32_t *retval);
	int (*psynch_rw_wrlock)(proc_t p, user_addr_t rwlock, uint32_t lgenval, uint32_t ugenval, uint32_t rw_wc, int flags, uint32_t *retval);
	int (*psynch_rw_yieldwrlock)(proc_t p, user_addr_t rwlock, uint32_t lgenval, uint32_t ugenval, uint32_t rw_wc, int flags, uint32_t *retval);

	void *__unused_was_workqueue_get_sched_callback;

	int (*bsdthread_register2)(struct proc *p, user_addr_t threadstart, user_addr_t wqthread, uint32_t flags, user_addr_t stack_addr_hint, user_addr_t targetconc_ptr, uint32_t dispatchqueue_offset, uint32_t tsd_offset, int32_t *retval);

	void *__unused_was_bsdthread_ctl;
	void *__unused_was_workq_reqthreads;

	void *__unused_was_thread_qos_from_pthread_priority;
	void *__unused_was_get_pwq_state_kdp;
	void *__unused3;
	void *__unused_was_pthread_priority_canonicalize2;
	void *__unused_was_workq_thread_has_been_unbound;

	void (*pthread_find_owner)(thread_t thread, struct stackshot_thread_waitinfo *waitinfo);
	void *(*pthread_get_thread_kwq)(thread_t thread);

	void *__unused_was_workq_threadreq;

	int  (*workq_handle_stack_events)(proc_t p, thread_t th, vm_map_t map,
	    user_addr_t stackaddr, mach_port_name_t kport,
	    user_addr_t events, int nevents, int upcall_flags);

	int (*workq_create_threadstack)(proc_t p, vm_map_t vmap,
	    mach_vm_offset_t *out_addr);

	int (*workq_destroy_threadstack)(proc_t p, vm_map_t vmap,
	    mach_vm_offset_t stackaddr);

	void (*workq_setup_thread)(proc_t p, thread_t th, vm_map_t map,
	    user_addr_t stackaddr, mach_port_name_t kport, int th_qos,
	    int setup_flags, int upcall_flags);

	void (*workq_markfree_threadstack)(proc_t p, thread_t, vm_map_t map,
	    user_addr_t stackaddr);

	void * _pad[83];
} * pthread_functions_t;
struct pthread_callbacks_s {
	int version;

	uint32_t config_thread_max;
	uint32_t (*get_task_threadmax)(void);

	uint64_t (*proc_get_register)(struct proc *t);
	void (*proc_set_register)(struct proc *t);

	user_addr_t (*proc_get_threadstart)(struct proc *t);
	void (*proc_set_threadstart)(struct proc *t, user_addr_t addr);
	user_addr_t (*proc_get_wqthread)(struct proc *t);
	void (*proc_set_wqthread)(struct proc *t, user_addr_t addr);
	int (*proc_get_pthsize)(struct proc *t);
	void (*proc_set_pthsize)(struct proc *t, int size);

	thread_t (*task_findtid)(task_t t, uint64_t tid);
	void (*thread_deallocate_safe)(thread_t);
	bool (*proc_get_jit_entitled)(struct proc *t);
	void (*proc_set_dispatchqueue_offset)(struct proc *t, uint64_t offset);
	bool (*proc_get_pthread_jit_allowlist2)(struct proc *t, bool *late_out);
	void *__unused_was_proc_get_wqinitingptr;
	void *__unused_was_proc_get_wqptr;

	wait_result_t (*psynch_wait_prepare)(uintptr_t kwq,
	    struct turnstile **tstore, thread_t owner, block_hint_t block_hint,
	    uint64_t deadline);

	void (*psynch_wait_update_complete)(struct turnstile *turnstile);

	void (*psynch_wait_complete)(uintptr_t kwq, struct turnstile **tstore);

	void (*psynch_wait_cleanup)(void);

	kern_return_t (*psynch_wait_wakeup)(uintptr_t kwq,
	    struct ksyn_waitq_element *kwe, struct turnstile **tstore);

	void (*psynch_wait_update_owner)(uintptr_t kwq, thread_t owner,
	    struct turnstile **tstore);

	void* (*proc_get_pthhash)(struct proc *t);
	void (*proc_set_pthhash)(struct proc *t, void* ptr);

	void *__unused_was_uthread_get_threadlist;
	void *__unused_was_uthread_set_threadlist;
	void *__unused_was_uthread_get_sigmask;
	void *__unused_was_uthread_set_sigmask;

	void* (*uthread_get_uukwe)(struct uthread *t);
	void *__unused_was_uthread_get_returnval;
	void (*uthread_set_returnval)(struct uthread *t, int val);
	int (*uthread_is_cancelled)(struct uthread *t);

	ipc_space_t (*task_get_ipcspace)(task_t t);
	void *__unused_was_ipc_port_copyout_send;

	kern_return_t (*vm_map_page_info)(vm_map_t map, vm_map_offset_t offset, vm_page_info_flavor_t flavor, vm_page_info_t info, mach_msg_type_number_t *count);
	mach_port_name_t (*ipc_port_copyout_send_pinned)(ipc_port_t sright, ipc_space_t space);

	kern_return_t (*thread_set_wq_state32)(thread_t thread, thread_state_t state);

	void (*thread_exception_return)(void);
	void (*thread_bootstrap_return)(void);

	void *__unused_was_absolutetime_to_microtime;
	void *__unused_was_thread_set_workq_pri;
	void *__unused_was_thread_set_workq_qos;

	struct uthread* (*get_bsdthread_info)(thread_t th);
	void *__unused_was_thread_sched_call;
	void *__unused_was_thread_static_param;
	void *__unused_was_thread_create_workq_waiting_parameter;
	kern_return_t (*thread_policy_set_internal)(thread_t t, thread_policy_flavor_t flavour, thread_policy_t info, mach_msg_type_number_t count);

	void *__unused_was_thread_affinity_set;

	void (*unix_syscall_return)(int error);

	void *__unused_was_zalloc;
	void *__unused_was_zfree;
	void *__unused_was_zinit;

	void (*__pthread_testcancel)(int);

	kern_return_t (*mach_port_deallocate)(ipc_space_t space, mach_port_name_t name);
	kern_return_t (*semaphore_signal_internal_trap)(mach_port_name_t sema_name);
	vm_map_t (*current_map)(void);

	void *__unused_was_convert_thread_to_port;
	void *__unused_was_thread_create;

	kern_return_t (*thread_resume)(thread_act_t target_act);

	int (*kevent_workq_internal)(struct proc *p,
	    user_addr_t changelist, int nchanges,
	    user_addr_t eventlist, int nevents,
	    user_addr_t data_out, user_size_t *data_available,
	    unsigned int flags, int32_t *retval);


	void *__unused_was_proc_get_dispatchqueue_serialno_offset;
	void *__unused_was_proc_set_dispatchqueue_serialno_offset;

	void *__unused_was_proc_usynch_thread_qos_add_override_for_resource_check_owner;
	void (*proc_set_workqueue_quantum_offset)(struct proc *p, uint64_t offset);

	uint32_t (*proc_get_pthread_tsd_offset)(struct proc *p);
	void (*proc_set_pthread_tsd_offset)(struct proc *p, uint32_t pthread_tsd_offset);

	kern_return_t (*thread_set_tsd_base)(thread_t thread, mach_vm_offset_t tsd_base);

	int     (*proc_usynch_get_requested_thread_qos)(struct uthread *);
	uint64_t (*proc_get_mach_thread_self_tsd_offset)(struct proc *p);
	void (*proc_set_mach_thread_self_tsd_offset)(struct proc *p, uint64_t mach_thread_self_tsd_offset);

	kern_return_t (*thread_policy_get)(thread_t t, thread_policy_flavor_t flavor, thread_policy_t info, mach_msg_type_number_t *count, boolean_t *get_default);
	boolean_t (*qos_main_thread_active)(void);

	kern_return_t (*thread_set_voucher_name)(mach_port_name_t name);

	boolean_t (*proc_usynch_thread_qos_add_override_for_resource)(task_t task, struct uthread *, uint64_t tid, int override_qos, boolean_t first_override_for_resource, user_addr_t resource, int resource_type);
	boolean_t (*proc_usynch_thread_qos_remove_override_for_resource)(task_t task, struct uthread *, uint64_t tid, user_addr_t resource, int resource_type);
	void *__unused_was_proc_usynch_thread_qos_reset_override_for_resource;

	void *__unused_was_proc_init_wqptr_or_wait;

	uint16_t (*thread_set_tag)(thread_t thread, uint16_t tag);
	uint16_t (*thread_get_tag)(thread_t thread);

	void *__unused_was_thread_create_pinned;

	kern_return_t (*thread_terminate_pinned)(thread_t thread);
	ipc_port_t (*convert_thread_to_port_pinned)(thread_t th);

	user_addr_t (*proc_get_stack_addr_hint)(struct proc *p);
	void (*proc_set_stack_addr_hint)(struct proc *p, user_addr_t stack_addr_hint);

	kern_return_t (*thread_create_immovable)(task_t parent_task, thread_t *new_thread);
	void (*proc_set_return_to_kernel_offset)(struct proc *t, uint64_t offset);

	void *__unused_was_workloop_fulfill_threadreq;
	void (*thread_will_park_or_terminate)(thread_t thread);

	void *__unused_was_qos_max_parallelism;

	user_addr_t (*proc_get_user_stack)(struct proc *p);
	void *__unused_was_proc_set_user_stack;

	void* _pad[69];
} *pthread_callbacks_t;
struct os_reason {
	decl_lck_mtx_data(, osr_lock);
	os_refcnt_t                     osr_refcount;
	uint32_t                        osr_namespace;
	uint64_t                        osr_code;
	uint64_t                        osr_flags;
	uint32_t                        osr_bufsize;
	struct kcdata_descriptor        osr_kcd_descriptor;
	char                            *osr_kcd_buf;
} *os_reason_t;
struct _exception_info {
	int os_reason;
	int signal;
	exception_type_t exception_type;
	mach_exception_data_type_t mx_code;
	mach_exception_data_type_t mx_subcode;
	struct kt_info {
		int kt_subsys;
		uint32_t kt_error;
	} kt_info;
} exception_info_t;
struct  rusage {
	struct timeval ru_utime;        
	struct timeval ru_stime;        
};
struct rusage_info_v0 {
	uint8_t  ri_uuid[16];
	uint64_t ri_user_time;
	uint64_t ri_system_time;
	uint64_t ri_pkg_idle_wkups;
	uint64_t ri_interrupt_wkups;
	uint64_t ri_pageins;
	uint64_t ri_wired_size;
	uint64_t ri_resident_size;
	uint64_t ri_phys_footprint;
	uint64_t ri_proc_start_abstime;
	uint64_t ri_proc_exit_abstime;
};
struct rusage_info_v1 {
	uint8_t  ri_uuid[16];
	uint64_t ri_user_time;
	uint64_t ri_system_time;
	uint64_t ri_pkg_idle_wkups;
	uint64_t ri_interrupt_wkups;
	uint64_t ri_pageins;
	uint64_t ri_wired_size;
	uint64_t ri_resident_size;
	uint64_t ri_phys_footprint;
	uint64_t ri_proc_start_abstime;
	uint64_t ri_proc_exit_abstime;
	uint64_t ri_child_user_time;
	uint64_t ri_child_system_time;
	uint64_t ri_child_pkg_idle_wkups;
	uint64_t ri_child_interrupt_wkups;
	uint64_t ri_child_pageins;
	uint64_t ri_child_elapsed_abstime;
};
struct rusage_info_v2 {
	uint8_t  ri_uuid[16];
	uint64_t ri_user_time;
	uint64_t ri_system_time;
	uint64_t ri_pkg_idle_wkups;
	uint64_t ri_interrupt_wkups;
	uint64_t ri_pageins;
	uint64_t ri_wired_size;
	uint64_t ri_resident_size;
	uint64_t ri_phys_footprint;
	uint64_t ri_proc_start_abstime;
	uint64_t ri_proc_exit_abstime;
	uint64_t ri_child_user_time;
	uint64_t ri_child_system_time;
	uint64_t ri_child_pkg_idle_wkups;
	uint64_t ri_child_interrupt_wkups;
	uint64_t ri_child_pageins;
	uint64_t ri_child_elapsed_abstime;
	uint64_t ri_diskio_bytesread;
	uint64_t ri_diskio_byteswritten;
};
struct rusage_info_v3 {
	uint8_t  ri_uuid[16];
	uint64_t ri_user_time;
	uint64_t ri_system_time;
	uint64_t ri_pkg_idle_wkups;
	uint64_t ri_interrupt_wkups;
	uint64_t ri_pageins;
	uint64_t ri_wired_size;
	uint64_t ri_resident_size;
	uint64_t ri_phys_footprint;
	uint64_t ri_proc_start_abstime;
	uint64_t ri_proc_exit_abstime;
	uint64_t ri_child_user_time;
	uint64_t ri_child_system_time;
	uint64_t ri_child_pkg_idle_wkups;
	uint64_t ri_child_interrupt_wkups;
	uint64_t ri_child_pageins;
	uint64_t ri_child_elapsed_abstime;
	uint64_t ri_diskio_bytesread;
	uint64_t ri_diskio_byteswritten;
	uint64_t ri_cpu_time_qos_default;
	uint64_t ri_cpu_time_qos_maintenance;
	uint64_t ri_cpu_time_qos_background;
	uint64_t ri_cpu_time_qos_utility;
	uint64_t ri_cpu_time_qos_legacy;
	uint64_t ri_cpu_time_qos_user_initiated;
	uint64_t ri_cpu_time_qos_user_interactive;
	uint64_t ri_billed_system_time;
	uint64_t ri_serviced_system_time;
};
struct rusage_info_v4 {
	uint8_t  ri_uuid[16];
	uint64_t ri_user_time;
	uint64_t ri_system_time;
	uint64_t ri_pkg_idle_wkups;
	uint64_t ri_interrupt_wkups;
	uint64_t ri_pageins;
	uint64_t ri_wired_size;
	uint64_t ri_resident_size;
	uint64_t ri_phys_footprint;
	uint64_t ri_proc_start_abstime;
	uint64_t ri_proc_exit_abstime;
	uint64_t ri_child_user_time;
	uint64_t ri_child_system_time;
	uint64_t ri_child_pkg_idle_wkups;
	uint64_t ri_child_interrupt_wkups;
	uint64_t ri_child_pageins;
	uint64_t ri_child_elapsed_abstime;
	uint64_t ri_diskio_bytesread;
	uint64_t ri_diskio_byteswritten;
	uint64_t ri_cpu_time_qos_default;
	uint64_t ri_cpu_time_qos_maintenance;
	uint64_t ri_cpu_time_qos_background;
	uint64_t ri_cpu_time_qos_utility;
	uint64_t ri_cpu_time_qos_legacy;
	uint64_t ri_cpu_time_qos_user_initiated;
	uint64_t ri_cpu_time_qos_user_interactive;
	uint64_t ri_billed_system_time;
	uint64_t ri_serviced_system_time;
	uint64_t ri_logical_writes;
	uint64_t ri_lifetime_max_phys_footprint;
	uint64_t ri_instructions;
	uint64_t ri_cycles;
	uint64_t ri_billed_energy;
	uint64_t ri_serviced_energy;
	uint64_t ri_interval_max_phys_footprint;
	uint64_t ri_runnable_time;
};
struct rusage_info_v5 {
	uint8_t  ri_uuid[16];
	uint64_t ri_user_time;
	uint64_t ri_system_time;
	uint64_t ri_pkg_idle_wkups;
	uint64_t ri_interrupt_wkups;
	uint64_t ri_pageins;
	uint64_t ri_wired_size;
	uint64_t ri_resident_size;
	uint64_t ri_phys_footprint;
	uint64_t ri_proc_start_abstime;
	uint64_t ri_proc_exit_abstime;
	uint64_t ri_child_user_time;
	uint64_t ri_child_system_time;
	uint64_t ri_child_pkg_idle_wkups;
	uint64_t ri_child_interrupt_wkups;
	uint64_t ri_child_pageins;
	uint64_t ri_child_elapsed_abstime;
	uint64_t ri_diskio_bytesread;
	uint64_t ri_diskio_byteswritten;
	uint64_t ri_cpu_time_qos_default;
	uint64_t ri_cpu_time_qos_maintenance;
	uint64_t ri_cpu_time_qos_background;
	uint64_t ri_cpu_time_qos_utility;
	uint64_t ri_cpu_time_qos_legacy;
	uint64_t ri_cpu_time_qos_user_initiated;
	uint64_t ri_cpu_time_qos_user_interactive;
	uint64_t ri_billed_system_time;
	uint64_t ri_serviced_system_time;
	uint64_t ri_logical_writes;
	uint64_t ri_lifetime_max_phys_footprint;
	uint64_t ri_instructions;
	uint64_t ri_cycles;
	uint64_t ri_billed_energy;
	uint64_t ri_serviced_energy;
	uint64_t ri_interval_max_phys_footprint;
	uint64_t ri_runnable_time;
	uint64_t ri_flags;
};
struct rusage_info_v6 {
	uint8_t  ri_uuid[16];
	uint64_t ri_user_time;
	uint64_t ri_system_time;
	uint64_t ri_pkg_idle_wkups;
	uint64_t ri_interrupt_wkups;
	uint64_t ri_pageins;
	uint64_t ri_wired_size;
	uint64_t ri_resident_size;
	uint64_t ri_phys_footprint;
	uint64_t ri_proc_start_abstime;
	uint64_t ri_proc_exit_abstime;
	uint64_t ri_child_user_time;
	uint64_t ri_child_system_time;
	uint64_t ri_child_pkg_idle_wkups;
	uint64_t ri_child_interrupt_wkups;
	uint64_t ri_child_pageins;
	uint64_t ri_child_elapsed_abstime;
	uint64_t ri_diskio_bytesread;
	uint64_t ri_diskio_byteswritten;
	uint64_t ri_cpu_time_qos_default;
	uint64_t ri_cpu_time_qos_maintenance;
	uint64_t ri_cpu_time_qos_background;
	uint64_t ri_cpu_time_qos_utility;
	uint64_t ri_cpu_time_qos_legacy;
	uint64_t ri_cpu_time_qos_user_initiated;
	uint64_t ri_cpu_time_qos_user_interactive;
	uint64_t ri_billed_system_time;
	uint64_t ri_serviced_system_time;
	uint64_t ri_logical_writes;
	uint64_t ri_lifetime_max_phys_footprint;
	uint64_t ri_instructions;
	uint64_t ri_cycles;
	uint64_t ri_billed_energy;
	uint64_t ri_serviced_energy;
	uint64_t ri_interval_max_phys_footprint;
	uint64_t ri_runnable_time;
	uint64_t ri_flags;
	uint64_t ri_user_ptime;
	uint64_t ri_system_ptime;
	uint64_t ri_pinstructions;
	uint64_t ri_pcycles;
	uint64_t ri_energy_nj;
	uint64_t ri_penergy_nj;
	uint64_t ri_secure_time_in_system;
	uint64_t ri_secure_ptime_in_system;
	uint64_t ri_neural_footprint;
	uint64_t ri_lifetime_max_neural_footprint;
	uint64_t ri_interval_max_neural_footprint;
	uint64_t ri_reserved[9];
};
struct rusage_superset {
	struct rusage           ru;
	rusage_info_current     ri;
};
struct rusage_info_child {
	uint64_t ri_child_user_time;
	uint64_t ri_child_system_time;
	uint64_t ri_child_pkg_idle_wkups;
	uint64_t ri_child_interrupt_wkups;
	uint64_t ri_child_pageins;
	uint64_t ri_child_elapsed_abstime;
};
struct  user64_rusage {
	struct user64_timeval ru_utime; 
	struct user64_timeval ru_stime; 
	user64_long_t   ru_maxrss;              
	user64_long_t   ru_ixrss;               
	user64_long_t   ru_idrss;               
	user64_long_t   ru_isrss;               
	user64_long_t   ru_minflt;              
	user64_long_t   ru_majflt;              
	user64_long_t   ru_nswap;               
	user64_long_t   ru_inblock;             
	user64_long_t   ru_oublock;             
	user64_long_t   ru_msgsnd;              
	user64_long_t   ru_msgrcv;              
	user64_long_t   ru_nsignals;    
	user64_long_t   ru_nvcsw;               
	user64_long_t   ru_nivcsw;              
};
struct  user32_rusage {
	struct user32_timeval ru_utime; 
	struct user32_timeval ru_stime; 
	user32_long_t   ru_maxrss;              
	user32_long_t   ru_ixrss;               
	user32_long_t   ru_idrss;               
	user32_long_t   ru_isrss;               
	user32_long_t   ru_minflt;              
	user32_long_t   ru_majflt;              
	user32_long_t   ru_nswap;               
	user32_long_t   ru_inblock;             
	user32_long_t   ru_oublock;             
	user32_long_t   ru_msgsnd;              
	user32_long_t   ru_msgrcv;              
	user32_long_t   ru_nsignals;    
	user32_long_t   ru_nvcsw;               
	user32_long_t   ru_nivcsw;              
};
struct rlimit {
	rlim_t  rlim_cur;               
	rlim_t  rlim_max;               
};
struct proc_rlimit_control_wakeupmon {
	uint32_t wm_flags;
	int32_t wm_rate;
};
struct pstats {
	struct  rusage            p_ru;         
	struct  rusage            p_cru;        

	struct uprof {                  
		struct uprof *pr_next;  
		caddr_t pr_base;        
		u_int32_t       pr_size;        
		u_int32_t       pr_off;         
		u_int32_t       pr_scale;       
		u_int32_t       pr_addr;        
		u_int32_t       pr_ticks;       
	} p_prof;

	uint64_t ps_start;              
	struct  rusage_info_child ri_child;     
	struct user_uprof {                         
		struct user_uprof *pr_next;  
		user_addr_t         pr_base;    
		user_size_t         pr_size;    
		user_ulong_t    pr_off;         
		user_ulong_t    pr_scale;       
		user_ulong_t    pr_addr;        
		user_ulong_t    pr_ticks;       
	} user_p_prof;
};
struct plimit {
	struct smr_node  pl_node;
	struct rlimit    pl_rlimit[RLIM_NLIMITS];
	os_refcnt_t      pl_refcnt;
};
struct thsc_cpi {
	uint64_t tcpi_instructions;
	uint64_t tcpi_cycles;
};
struct thsc_time_cpi {
	uint64_t ttci_instructions;
	uint64_t ttci_cycles;
	uint64_t ttci_user_time_mach;
	uint64_t ttci_system_time_mach;
};
struct thsc_time_energy_cpi {
	uint64_t ttec_instructions;
	uint64_t ttec_cycles;
	uint64_t ttec_user_time_mach;
	uint64_t ttec_system_time_mach;
	uint64_t ttec_energy_nj;
};
struct _iopol_param_t {
	int iop_scope;  
	int iop_iotype;
	int iop_policy;
};
struct sbuf {
	char            *s_buf;         
	void            *s_unused;      
	int              s_size;        
	int              s_len;         
	int              s_flags;       
};
struct sdt_probedesc {
	char                    *sdpd_name;     
	int                     sdpd_namelen;
	char                    *sdpd_func;     
	const char              *sdpd_prov;     
	unsigned long           sdpd_offset;    
	struct sdt_probedesc    *sdpd_next;     
} sdt_probedesc_t;
struct module {
	int sdt_nprobes;
	sdt_probedesc_t *sdt_probes;
};
struct sdt_provider {
	const char                      *sdtp_name;     
	const char                      *sdtp_prefix;   
	dtrace_pattr_t          *sdtp_attr;     
	dtrace_provider_id_t    sdtp_id;        
} sdt_provider_t;
struct sdt_probe {
	sdt_provider_t  *sdp_provider;          
	char            *sdp_name;              
	int             sdp_namelen;            
	dtrace_id_t     sdp_id;                 
	struct modctl   *sdp_ctl;               
	int             sdp_loadcnt;            
	int             sdp_primary;            
	sdt_instr_t     *sdp_patchpoint;        
	sdt_instr_t     sdp_patchval;           
	sdt_instr_t     sdp_savedval;           
	struct sdt_probe *sdp_next;             
	struct sdt_probe *sdp_hashnext;         
} sdt_probe_t;
struct sdt_argdesc {
	const char *sda_provider;               
	const char *sda_name;                   
	const int sda_ndx;                      
	const int sda_mapping;                  
	const char *sda_native;                 
	const char *sda_xlate;                  
} sdt_argdesc_t;
struct selinfo {
	union {
		struct  waitq si_waitq; 
		uint8_t si_waitq_storage[WQ_OPAQUE_SIZE]; 
	};
	struct  klist si_note;          
	u_int   si_flags;               
};
struct sem {
	unsigned short  semval;         
	pid_t           sempid;         
	unsigned short  semncnt;        
	unsigned short  semzcnt;        
};
struct sembuf {
	unsigned short  sem_num;        
	short           sem_op;         
	short           sem_flg;        
};
struct user_semid_ds {
	struct ipc_perm sem_perm;       
	struct sem      *sem_base;      
	unsigned short  sem_nsems;      
	user_time_t     sem_otime;      
	__int32_t       sem_pad1;       
	user_time_t     sem_ctime;      
	                                
	                                
	__int32_t       sem_pad2;       
	__int32_t       sem_pad3[4];    
};
struct user64_semid_ds {
	struct ipc_perm sem_perm;       
	int32_t sem_base;       
	unsigned short  sem_nsems;      
	user64_time_t   sem_otime;      
	int32_t sem_pad1;       
	user64_time_t   sem_ctime;      
	                                
	                                
	int32_t sem_pad2;       
	int32_t sem_pad3[4];    
};
struct user32_semid_ds {
	struct ipc_perm sem_perm;       
	int32_t sem_base;       
	unsigned short  sem_nsems;      
	user32_time_t   sem_otime;      
	int32_t sem_pad1;       
	user32_time_t   sem_ctime;      
	                                
	                                
	int32_t sem_pad2;       
	int32_t sem_pad3[4];    
};
struct sem_undo {
	int     un_next_idx;    
	struct  proc *un_proc;          
	short   un_cnt;                 
	struct undo {
		short   une_adjval;     
		short   une_num;        
		int     une_id;         
		struct undo *une_next;  
	} *un_ent;                      
};
struct seminfo {
	int     semmap,         
	    semmni,             
	    semmns,             
	    semmnu,             
	    semmsl,             
	    semopm,             
	    semume,             
	    semusz,             
	    semvmx,             
	    semaem;             
};
struct semid_kernel {
	struct  user_semid_ds u;
	struct  label *label;   
};
struct user_shmid_ds {
	struct ipc_perm shm_perm;       
	user_size_t     shm_segsz;      
	pid_t           shm_lpid;       
	pid_t           shm_cpid;       
	short           shm_nattch;     
	user_time_t     shm_atime;      
	user_time_t     shm_dtime;      
	user_time_t     shm_ctime;      
	user_addr_t     shm_internal;   
};
struct user32_shmid_ds {
	struct ipc_perm shm_perm;       
	uint32_t        shm_segsz;      
	pid_t           shm_lpid;       
	pid_t           shm_cpid;       
	short           shm_nattch;     
	uint32_t                shm_atime;      
	uint32_t                shm_dtime;      
	uint32_t                shm_ctime;      
	user32_addr_t   shm_internal;   
};
struct shminfo {
	int64_t shmmax;         
	int64_t shmmin;         
	int64_t shmmni;         
	int64_t shmseg;         
	int64_t shmall;         
};
struct shmid_kernel {
	struct user_shmid_ds u;
	struct label *label;    
};
struct user64_sigevent {
	int             sigev_notify;                   
	int             sigev_signo;                    
	union user64_sigval sigev_value;                        
	user64_addr_t   sigev_notify_function;          
	user64_addr_t   sigev_notify_attributes;        
};
struct user32_sigevent {
	int             sigev_notify;                   
	int             sigev_signo;                    
	union user32_sigval sigev_value;                        
	user32_addr_t   sigev_notify_function;          
	user32_addr_t   sigev_notify_attributes;        
};
struct user_sigevent {
	int             sigev_notify;                   
	int             sigev_signo;                    
	union user_sigval sigev_value;                  
	user_addr_t     sigev_notify_function;          
	user_addr_t     sigev_notify_attributes;        
};
struct __siginfo {
	int     si_signo;               
	int     si_errno;               
	int     si_code;                
	pid_t   si_pid;                 
	uid_t   si_uid;                 
	int     si_status;              
	void    *si_addr;               
	union sigval si_value;          
	long    si_band;                
	unsigned long   __pad[7];       
} siginfo_t;
struct user_siginfo {
	int             si_signo;       
	int             si_errno;       
	int             si_code;        
	pid_t           si_pid;         
	uid_t           si_uid;         
	int             si_status;      
	user_addr_t     si_addr;        
	union user_sigval si_value;     
	user_long_t     si_band;        
	user_ulong_t    pad[7];         
} user_siginfo_t;
struct user64_siginfo {
	int             si_signo;       
	int             si_errno;       
	int             si_code;        
	pid_t           si_pid;         
	uid_t           si_uid;         
	int             si_status;      
	user64_addr_t   si_addr;        
	union user64_sigval si_value;   
	user64_long_t   si_band;        
	user64_ulong_t  __pad[7];               
} user64_siginfo_t;
struct user32_siginfo {
	int             si_signo;       
	int             si_errno;       
	int             si_code;        
	pid_t           si_pid;         
	uid_t           si_uid;         
	int             si_status;      
	user32_addr_t   si_addr;        
	union user32_sigval     si_value;       
	user32_long_t   si_band;        
	user32_ulong_t  __pad[7];               
} user32_siginfo_t;
struct  __sigaction {
	union __sigaction_u __sigaction_u;  
	void    (*sa_tramp)(void *, int, int, siginfo_t *, void *);
	sigset_t sa_mask;               
	int     sa_flags;               
};
struct  sigaction {
	union __sigaction_u __sigaction_u;  
	sigset_t sa_mask;               
	int     sa_flags;               
};
struct  user32_sigaction {
	union __user32_sigaction_u __sigaction_u;  
	sigset_t sa_mask;               
	int     sa_flags;               
};
struct  __user32_sigaction {
	union __user32_sigaction_u __sigaction_u;  
	user32_addr_t sa_tramp;
	sigset_t sa_mask;               
	int     sa_flags;               
};
struct  user64_sigaction {
	union __user64_sigaction_u __sigaction_u;  
	sigset_t sa_mask;               
	int     sa_flags;               
};
struct  __user64_sigaction {
	union __user64_sigaction_u __sigaction_u;  
	user64_addr_t   sa_tramp;       
	sigset_t sa_mask;               
	int     sa_flags;               
};
struct  kern_sigaction {
	union __kern_sigaction_u __sigaction_u;  
	sigset_t sa_mask;               
	int     sa_flags;               
};
struct  __kern_sigaction {
	union __kern_sigaction_u __sigaction_u;  
	user_addr_t     sa_tramp;       
	sigset_t sa_mask;               
	int     sa_flags;               
};
struct  user32_sigaltstack {
	user32_addr_t   ss_sp;          
	user32_size_t   ss_size;        
	int                 ss_flags;   
};
struct  user64_sigaltstack {
	user64_addr_t   ss_sp;          
	user64_size_t   ss_size;        
	int             ss_flags;       
};
struct  kern_sigaltstack {
	user_addr_t     ss_sp;          
	user_size_t     ss_size;        
	int             ss_flags;       
};
struct  sigstack {
	char    *ss_sp;                 
	int     ss_onstack;             
};
struct  linger {
	int     l_onoff;                
	int     l_linger;               
};
struct sockaddr {
	__uint8_t       sa_len;         
	sa_family_t     sa_family;      
	char            sa_data[14];    
};
struct __sockaddr_header {
	__uint8_t           sa_len;
	sa_family_t         sa_family;
};
struct sockaddr_storage {
	__uint8_t       ss_len;         
	sa_family_t     ss_family;      
	char                    __ss_pad1[_SS_PAD1SIZE];
	__int64_t       __ss_align;     
	char                    __ss_pad2[_SS_PAD2SIZE];
};
struct msghdr {
	void            *__sized_by(msg_namelen) msg_name; 
	socklen_t       msg_namelen;    
	struct          iovec *msg_iov; 
	int             msg_iovlen;     
	void            *__sized_by(msg_controllen) msg_control; 
	socklen_t       msg_controllen; 
	int             msg_flags;      
};
struct cmsghdr {
	socklen_t       cmsg_len;       
	int             cmsg_level;     
	int             cmsg_type;      

};
struct data_stats {
	u_int64_t       rxpackets;
	u_int64_t       rxbytes;
	u_int64_t       txpackets;
	u_int64_t       txbytes;
};
struct socket {
	int     so_zone;                
	short   so_type;                
	uint16_t so_protocol;
	int     so_family;
	u_short so_error;               
	u_int32_t so_options;           
	short   so_linger;              
	short   so_state;               
	void    *so_pcb;                
	struct  protosw *so_proto;      
	struct  socket *so_head;        
	TAILQ_HEAD(, socket) so_incomp; 
	TAILQ_HEAD(, socket) so_comp;   
	TAILQ_ENTRY(socket) so_list;    
	short   so_qlen;                
	short   so_incqlen;             
	short   so_qlimit;              
	short   so_timeo;               
	pid_t   so_pgid;                
	u_int32_t so_oobmark;           
	struct sockbuf {
		uint32_t       sb_cc;          
		uint32_t       sb_hiwat;       
		uint32_t       sb_mbcnt;       
		uint32_t       sb_mbmax;       
		uint32_t       sb_ctl;         
		uint32_t       sb_lowat;       
		struct mbuf     *sb_mb;         
		struct mbuf     *sb_mbtail;     
		struct mbuf     *sb_lastrecord; 
		struct socket   *sb_so;         
		struct selinfo  sb_sel;         
		struct timeval  sb_timeo;       
		uint32_t       sb_flags;       
		uint32_t       sb_idealsize;   
		void    (*sb_upcall)(struct socket *, void *arg, int waitf);
		void    *sb_upcallarg;          
		uint32_t       sb_wantlock;    
		uint32_t       sb_waiters;     
		thread_t        sb_cfil_thread; 
		uint32_t       sb_cfil_refs;   
		uint32_t       sb_preconn_hiwat; 
		struct mbuf   *sb_sendhead;
		int            sb_sendoff;
	} so_rcv, so_snd;
	caddr_t so_tpcb;                

	void            (*so_event)(struct socket *, void *, uint32_t);
	void            *so_eventarg;   
	kauth_cred_t    so_cred;        
	so_gen_t so_gencnt;             
	STAILQ_ENTRY(socket) so_cache_ent;      
	caddr_t         so_saved_pcb;           
	u_int64_t       cache_timestamp;        
	uint32_t        so_eventmask;           

	pid_t           last_pid;       
	u_int64_t       last_upid;      

	struct socket_filter_entry *so_filt;    
	u_int32_t       so_flags;               

	u_int32_t       so_flags1;

	uint32_t        so_upcallusecount; 
	int             so_usecount;    
	int             so_retaincnt;
	uint16_t        so_traffic_class;
	int8_t          so_netsvctype;
	uint8_t         so_restrictions;
	thread_t        so_send_filt_thread;

	void    *lock_lr[SO_LCKDBG_MAX];        
	void    *unlock_lr[SO_LCKDBG_MAX];      
	u_int8_t        next_lock_lr;
	u_int8_t        next_unlock_lr;

	u_int16_t       so_pktheadroom; 

	u_int32_t       so_ifdenied_notifies; 

	thread_t        so_background_thread;   
	struct data_stats so_tc_stats[SO_TC_STATS_MAX];
	struct klist    so_klist;               

	struct flow_divert_pcb  *so_fd_pcb;     

	struct soflow_db    *so_flow_db;


	pid_t           e_pid;          
	u_int64_t       e_upid;         
	pid_t           so_rpid;        

	uuid_t          last_uuid;      
	uuid_t          e_uuid;         
	uuid_t          so_vuuid;       
	uuid_t          so_ruuid;       

	uid_t           so_persona_id;  

	int32_t         so_policy_gencnt; 

	u_int64_t       so_extended_bk_start;

	u_int8_t        so_fallback_mode;

	u_int8_t        so_log_seqn;    
	uint8_t         so_mpkl_send_proto;
	uuid_t          so_mpkl_send_uuid;
};
struct xsockbuf {
	u_int32_t       sb_cc;
	u_int32_t       sb_hiwat;
	u_int32_t       sb_mbcnt;
	u_int32_t       sb_mbmax;
	int32_t         sb_lowat;
	short           sb_flags;
	short           sb_timeo;
};
struct xsocket {
	u_int32_t               xso_len;        
	_XSOCKET_PTR(struct socket *) xso_so;   
	short                   so_type;
	short                   so_options;
	short                   so_linger;
	short                   so_state;
	_XSOCKET_PTR(caddr_t)   so_pcb;         
	int                     xso_protocol;
	int                     xso_family;
	short                   so_qlen;
	short                   so_incqlen;
	short                   so_qlimit;
	short                   so_timeo;
	u_short                 so_error;
	pid_t                   so_pgid;
	u_int32_t               so_oobmark;
	struct xsockbuf         so_rcv;
	struct xsockbuf         so_snd;
	uid_t                   so_uid;         
};
struct  xsocket_n {
	u_int32_t               xso_len;        
	u_int32_t               xso_kind;       
	u_int64_t               xso_so;         
	short                   so_type;
	u_int32_t               so_options;
	short                   so_linger;
	short                   so_state;
	u_int64_t               so_pcb;         
	int                     xso_protocol;
	int                     xso_family;
	short                   so_qlen;
	short                   so_incqlen;
	short                   so_qlimit;
	short                   so_timeo;
	u_short                 so_error;
	pid_t                   so_pgid;
	u_int32_t               so_oobmark;
	uid_t                   so_uid;         
	pid_t                   so_last_pid;
	pid_t                   so_e_pid;
	so_gen_t                so_gencnt;
	u_int32_t               so_flags;
	u_int32_t               so_flags1;
	int32_t                 so_usecount;
	int32_t                 so_retaincnt;
	u_int32_t               xso_filter_flags;
};
struct xsockbuf_n {
	u_int32_t               xsb_len;        
	u_int32_t               xsb_kind;       
	u_int32_t               sb_cc;
	u_int32_t               sb_hiwat;
	u_int32_t               sb_mbcnt;
	u_int32_t               sb_mbmax;
	int32_t                 sb_lowat;
	short                   sb_flags;
	short                   sb_timeo;
};
struct xsockstat_n {
	u_int32_t               xst_len;        
	u_int32_t               xst_kind;       
	struct data_stats       xst_tc_stats[SO_TC_STATS_MAX];
};
struct soextbkidlestat {
	u_int32_t       so_xbkidle_maxperproc;
	u_int32_t       so_xbkidle_time;
	u_int32_t       so_xbkidle_rcvhiwat;
	int32_t         so_xbkidle_notsupp;
	int32_t         so_xbkidle_toomany;
	int32_t         so_xbkidle_wantok;
	int32_t         so_xbkidle_active;
	int32_t         so_xbkidle_nocell;
	int32_t         so_xbkidle_notime;
	int32_t         so_xbkidle_forced;
	int32_t         so_xbkidle_resumed;
	int32_t         so_xbkidle_expired;
	int32_t         so_xbkidle_resched;
	int32_t         so_xbkidle_nodlgtd;
	int32_t         so_xbkidle_drained;
};
struct sockopt {
	enum    sopt_dir sopt_dir; 
	int     sopt_level;     
	int     sopt_name;      
	user_addr_t sopt_val;   
	size_t  sopt_valsize;   
	struct  proc *sopt_p;   
};
struct kextcb {
	struct kextcb *e_next;          
	void *e_fcb;                    
	struct NFDescriptor *e_nfd;     
	struct sockif *e_soif;          
	struct sockutil *e_sout;        
};
struct so_procinfo {
	pid_t           spi_pid;
	pid_t           spi_epid;
	uuid_t          spi_uuid;
	uuid_t          spi_euuid;
	int             spi_delegated;
	char            spi_proc_name[MAXCOMLEN + 1];
	char            spi_e_proc_name[MAXCOMLEN + 1];
};
struct recv_msg_elem {
	struct uio *uio;
	struct sockaddr *psa;
	struct mbuf *controlp;
	int which;
	int flags;
};
struct tracker_metadata {
	uint32_t flags;
	char domain[TRACKER_DOMAIN_MAX + 1];
	char domain_owner[TRACKER_DOMAIN_MAX + 1];
} tracker_metadata_t;
struct tracker_metadata_short {
	uint32_t flags;
	char domain[TRACKER_DOMAIN_SHORT_MAX + 1];
	char domain_owner[TRACKER_DOMAIN_SHORT_MAX + 1];
} tracker_metadata_short_t;
struct msghdr_x {
	void            *__sized_by(msg_namelen) msg_name; 
	socklen_t       msg_namelen;    
	struct iovec    *msg_iov;       
	int             msg_iovlen;     
	void            *__sized_by(msg_controllen) msg_control; 
	socklen_t       msg_controllen; 
	int             msg_flags;      
	size_t          msg_datalen;    
};
struct user_msghdr {
	user_addr_t     msg_name;               
	socklen_t       msg_namelen;            
	vm_address_t    msg_iov;                
	int             msg_iovlen;             
	user_addr_t     msg_control;            
	socklen_t       msg_controllen;         
	int             msg_flags;              
};
struct user64_msghdr {
	user64_addr_t   msg_name;               
	socklen_t       msg_namelen;            
	user64_addr_t   msg_iov;                
	int             msg_iovlen;             
	user64_addr_t   msg_control;            
	socklen_t       msg_controllen;         
	int             msg_flags;              
};
struct user32_msghdr {
	user32_addr_t   msg_name;       
	socklen_t       msg_namelen;    
	user32_addr_t   msg_iov;        
	int             msg_iovlen;     
	user32_addr_t   msg_control;    
	socklen_t       msg_controllen; 
	int             msg_flags;      
};
struct user_msghdr_x {
	user_addr_t     msg_name;       
	socklen_t       msg_namelen;    
	vm_address_t    msg_iov;        
	int             msg_iovlen;     
	user_addr_t     msg_control;    
	socklen_t       msg_controllen; 
	int             msg_flags;      
	size_t          msg_datalen;    
};
struct user64_msghdr_x {
	user64_addr_t   msg_name;       
	socklen_t       msg_namelen;    
	user64_addr_t   msg_iov;        
	int             msg_iovlen;     
	user64_addr_t   msg_control;    
	socklen_t       msg_controllen; 
	int             msg_flags;      
	user64_size_t   msg_datalen;    
};
struct user32_msghdr_x {
	user32_addr_t   msg_name;       
	socklen_t       msg_namelen;    
	user32_addr_t   msg_iov;        
	int             msg_iovlen;     
	user32_addr_t   msg_control;    
	socklen_t       msg_controllen; 
	int             msg_flags;      
	user32_size_t   msg_datalen;    
};
struct user_sa_endpoints {
	unsigned int    sae_srcif;      
	user_addr_t     sae_srcaddr;    
	socklen_t       sae_srcaddrlen; 
	user_addr_t     sae_dstaddr;    
	socklen_t       sae_dstaddrlen; 
};
struct user64_sa_endpoints {
	unsigned int    sae_srcif;      
	user64_addr_t   sae_srcaddr;    
	socklen_t       sae_srcaddrlen; 
	user64_addr_t   sae_dstaddr;    
	socklen_t       sae_dstaddrlen; 
};
struct user32_sa_endpoints {
	unsigned int    sae_srcif;      
	user32_addr_t   sae_srcaddr;    
	socklen_t       sae_srcaddrlen; 
	user32_addr_t   sae_dstaddr;    
	socklen_t       sae_dstaddrlen; 
};
struct _ps_port_action {
	pspa_t                  port_type;
	exception_mask_t        mask;
	mach_port_name_t        new_port;
	exception_behavior_t    behavior;
	thread_state_flavor_t   flavor;
	int                     which;
} _ps_port_action_t;
struct _posix_spawn_port_actions {
	int                     pspa_alloc;
	int                     pspa_count;
	_ps_port_action_t       pspa_actions[];
} *_posix_spawn_port_actions_t;
struct _ps_mac_policy_extension {
	char                    policyname[128];
	union {
		
		uint64_t        data;
		
		uint64_t        dataoff;
	};
	uint64_t                datalen;
} _ps_mac_policy_extension_t;
struct _posix_spawn_mac_policy_extensions {
	int                     psmx_alloc;
	int                     psmx_count;
	_ps_mac_policy_extension_t psmx_extensions[];
} *_posix_spawn_mac_policy_extensions_t;
struct _posix_spawn_coalition_info {
	struct {
		uint64_t psci_id;
		uint32_t psci_role;
		uint32_t psci_reserved1;
		uint64_t psci_reserved2;
	} psci_info[COALITION_NUM_TYPES];
};
struct _posix_spawn_posix_cred_info {
	uint32_t pspci_flags;    
	uid_t    pspci_uid;      
	gid_t    pspci_gid;      
	uint32_t pspci_ngroups;  
	gid_t    pspci_groups[NGROUPS];
	uid_t    pspci_gmuid;    
	char     pspci_login[MAXLOGNAME + 1];
};
struct _posix_spawn_persona_info {
	uid_t    pspi_id;       
	uint32_t pspi_flags;    
	uid_t    pspi_uid;      
	gid_t    pspi_gid;      
	uint32_t pspi_ngroups;  
	gid_t    pspi_groups[NGROUPS];
	uid_t    pspi_gmuid;    
};
struct _posix_spawnattr {
	short           psa_flags;              
	short           flags_padding;  
	sigset_t        psa_sigdefault;         
	sigset_t        psa_sigmask;            
	pid_t           psa_pgroup;             
	cpu_type_t      psa_binprefs[NBINPREFS];   
	int             psa_pcontrol;           
	int             psa_apptype;            
	uint64_t        psa_cpumonitor_percent; 
	uint64_t        psa_cpumonitor_interval; 
	uint64_t        psa_reserved;

	short       psa_jetsam_flags;           
	short           short_padding;          
	int         psa_priority;               
	int         psa_memlimit_active;        
	int         psa_memlimit_inactive;      

	uint64_t        psa_qos_clamp;          
	task_role_t     psa_darwin_role;           
	int             psa_thread_limit;       

	uint64_t        psa_max_addr;           
	bool            psa_no_smt;
	bool            psa_tecs;
	int             psa_platform;           

	cpu_subtype_t      psa_subcpuprefs[NBINPREFS];   
	uint32_t        psa_options;             
	uint32_t        psa_port_soft_limit;     
	uint32_t        psa_port_hard_limit;     
	uint32_t        psa_filedesc_soft_limit; 
	uint32_t        psa_filedesc_hard_limit; 
	uint32_t        psa_crash_behavior;      
	int             psa_dataless_iopolicy;   
	uint64_t        psa_crash_behavior_deadline; 
	uint8_t         psa_launch_type;         
	uint16_t        psa_sec_flags;           

	uint32_t        psa_crash_count;
	uint32_t        psa_throttle_timeout;

	uint32_t        psa_kqworkloop_soft_limit; 
	uint32_t        psa_kqworkloop_hard_limit; 

	_posix_spawn_port_actions_t    psa_ports;  
	_posix_spawn_mac_policy_extensions_t psa_mac_extensions; 
	struct _posix_spawn_coalition_info *psa_coalition_info;  
	struct _posix_spawn_persona_info   *psa_persona_info;    
	struct _posix_spawn_posix_cred_info *psa_posix_cred_info; 
	char                                *psa_subsystem_root_path; 
	char                                *psa_conclave_id;         
} *_posix_spawnattr_t;
struct _psfa_action {
	psfa_t  psfaa_type;                         
	union {
		int psfaa_filedes;                  
		mach_port_name_t psfaa_fileport;    
	};
	union {
		struct {
			int     psfao_oflag;            
			mode_t  psfao_mode;             
			char    psfao_path[PATH_MAX];   
		} psfaa_openargs;
		struct {
			int psfad_newfiledes;           
		} psfaa_dup2args;
		struct {
			char    psfac_path[PATH_MAX];   
		} psfaa_chdirargs;
	};
} _psfa_action_t;
struct _posix_spawn_file_actions {
	int             psfa_act_alloc;         
	int             psfa_act_count;         
	_psfa_action_t  psfa_act_acts[];        
} *_posix_spawn_file_actions_t;
struct _posix_spawn_args_desc {
	__darwin_size_t         attr_size;      
	_posix_spawnattr_t      attrp;          
	__darwin_size_t file_actions_size;      
	_posix_spawn_file_actions_t
	    file_actions;                       
	__darwin_size_t port_actions_size;      
	_posix_spawn_port_actions_t
	    port_actions;                       
	__darwin_size_t mac_extensions_size;
	_posix_spawn_mac_policy_extensions_t
	    mac_extensions;                     
	__darwin_size_t coal_info_size;
	struct _posix_spawn_coalition_info *coal_info;  

	__darwin_size_t persona_info_size;
	struct _posix_spawn_persona_info   *persona_info;

	__darwin_size_t posix_cred_info_size;
	struct _posix_spawn_posix_cred_info *posix_cred_info;

	__darwin_size_t subsystem_root_path_size;
	char *subsystem_root_path;

	__darwin_size_t conclave_id_size;
	char *conclave_id;
};
struct stackshot_config {
	int             sc_pid;                 
	uint64_t        sc_flags;               
	uint64_t        sc_delta_timestamp;     

	uint64_t        sc_buffer;              
	uint32_t        sc_size;                

	uint64_t        sc_out_buffer_addr;     
	uint64_t        sc_out_size_addr;       
	uint64_t                sc_pagetable_mask;      
} stackshot_config_t;
struct stackshot_stats {
	uint64_t        ss_last_start;          
	uint64_t        ss_last_end;            
	uint64_t        ss_count;               
	uint64_t        ss_duration;            
} stackshot_stats_t;
struct user64_stat {
	dev_t           st_dev;         
	ino_t           st_ino;         
	mode_t          st_mode;        
	nlink_t         st_nlink;       
	uid_t           st_uid;         
	gid_t           st_gid;         
	dev_t           st_rdev;        
	off_t           st_size;        
	blkcnt_t        st_blocks;      
	blksize_t       st_blksize;     
	__uint32_t      st_flags;       
	__uint32_t      st_gen;         
	__int32_t       st_lspare;      
	__int64_t       st_qspare[2];   
};
struct user32_stat {
	dev_t           st_dev;         
	ino_t           st_ino;         
	mode_t          st_mode;        
	nlink_t         st_nlink;       
	uid_t           st_uid;         
	gid_t           st_gid;         
	dev_t           st_rdev;        
	off_t           st_size;        
	blkcnt_t        st_blocks;      
	blksize_t       st_blksize;     
	__uint32_t      st_flags;       
	__uint32_t      st_gen;         
	__int32_t       st_lspare;      
	__int64_t       st_qspare[2];   
};
struct user64_stat64 {
	dev_t           st_dev;                                 
	mode_t          st_mode;                                
	nlink_t         st_nlink;                               
	ino64_t         st_ino;                                 
	uid_t           st_uid;                                 
	gid_t           st_gid;                                 
	dev_t           st_rdev;                                
	struct user64_timespec st_atimespec;            
	struct user64_timespec st_mtimespec;            
	struct user64_timespec st_ctimespec;            
	struct user64_timespec st_birthtimespec;        
	off_t           st_size;                                
	blkcnt_t        st_blocks;                              
	blksize_t       st_blksize;                             
	__uint32_t      st_flags;                               
	__uint32_t      st_gen;                                 
	__uint32_t      st_lspare;                              
	__int64_t       st_qspare[2];                   
};
struct ctlname {
	char    *ctl_name;      
	int     ctl_type;       
};
struct sysctl_req {
	struct proc     *p;
	int             lock;
	user_addr_t     oldptr;         
	size_t          oldlen;         
	size_t          oldidx;         
	int             (*oldfunc)(struct sysctl_req *, const void *, size_t);
	user_addr_t     newptr;         
	size_t          newlen;         
	size_t          newidx;         
	int             (*newfunc)(struct sysctl_req *, void *, size_t);
};
struct sysctl_oid {
	struct sysctl_oid_list * OS_PTRAUTH_SIGNED_PTR("sysctl_oid.oid_parent") oid_parent;
	SLIST_ENTRY(sysctl_oid) oid_link;
	int             oid_number;
	int             oid_kind;
	void            *oid_arg1;
	int             oid_arg2;
	const char      *oid_name;
	int             (*oid_handler)SYSCTL_HANDLER_ARGS;
	const char      *oid_fmt;
	const char      *oid_descr; 
	int             oid_version;
	int             oid_refcnt;
};
struct experiment_spec {
	void *ptr; 
	uint64_t min_value; 
	uint64_t max_value; 
	uint64_t original_value; 
	_Atomic bool modified; 
};
struct user32_pcred {
	char          pc_lock[72];    
	user32_addr_t pc_ucred;       
	uid_t         p_ruid;         
	uid_t         p_svuid;        
	gid_t         p_rgid;         
	gid_t         p_svgid;        
	int           p_refcnt;       
};
struct user64_pcred {
	char          pc_lock[72];      
	user64_addr_t pc_ucred;         
	uid_t         p_ruid;           
	uid_t         p_svuid;          
	gid_t         p_rgid;           
	gid_t         p_svgid;          
	int           p_refcnt;         
};
struct user32_kinfo_proc {
	struct  user32_extern_proc kp_proc;     
	struct  user32_eproc {
		user32_addr_t e_paddr;          
		user32_addr_t e_sess;                   
		struct  user32_pcred e_pcred;           
		struct  _ucred e_ucred;         
		struct  user32_vmspace e_vm; 
		pid_t   e_ppid;                 
		pid_t   e_pgid;                 
		int     e_jobc;                 
		dev_t   e_tdev;                 
		pid_t   e_tpgid;                
		user32_addr_t   e_tsess;        
		char    e_wmesg[WMESGLEN + 1];    
		segsz_t e_xsize;                
		short   e_xrssize;              
		short   e_xccount;              
		short   e_xswrss;
		int32_t e_flag;
		char    e_login[COMAPT_MAXLOGNAME];     
		int32_t e_spare[4];
	} kp_eproc;
};
struct user64_kinfo_proc {
	struct  user64_extern_proc kp_proc;     
	struct  user64_eproc {
		user_addr_t e_paddr;            
		user_addr_t e_sess;                     
		struct  user64_pcred e_pcred;           
		struct  _ucred e_ucred;         
		struct   user_vmspace e_vm; 
		pid_t   e_ppid;                 
		pid_t   e_pgid;                 
		int     e_jobc;                 
		dev_t   e_tdev;                 
		pid_t   e_tpgid;                
		user64_addr_t   e_tsess __attribute((aligned(8)));      
		char    e_wmesg[WMESGLEN + 1];    
		segsz_t e_xsize;                
		short   e_xrssize;              
		short   e_xccount;              
		short   e_xswrss;
		int32_t e_flag;
		char    e_login[COMAPT_MAXLOGNAME];     
		int32_t e_spare[4];
	} kp_eproc;
};
struct xsw_usage {
	u_int64_t       xsu_total;
	u_int64_t       xsu_avail;
	u_int64_t       xsu_used;
	u_int32_t       xsu_pagesize;
	boolean_t       xsu_encrypted;
};
struct sockaddr_sys {
	u_char          ss_len;         
	u_char          ss_family;      
	u_int16_t       ss_sysaddr;     
	u_int32_t       ss_reserved[7]; 
};
struct  xsystmgen {
	u_int32_t       xg_len; 
	u_int64_t       xg_count;       
	u_int64_t       xg_gen; 
	u_int64_t       xg_sogen;       
};
struct termios {
	tcflag_t        c_iflag;        
	tcflag_t        c_oflag;        
	tcflag_t        c_cflag;        
	tcflag_t        c_lflag;        
	cc_t            c_cc[NCCS];     
	speed_t         c_ispeed;       
	speed_t         c_ospeed;       
};
struct user_termios {
	user_tcflag_t   c_iflag;        
	user_tcflag_t   c_oflag;        
	user_tcflag_t   c_cflag;        
	user_tcflag_t   c_lflag;        
	cc_t            c_cc[NCCS];     
	user_speed_t    c_ispeed __attribute((aligned(8)));     
	user_speed_t    c_ospeed;       
};
struct termios32 {
	__uint32_t      c_iflag;        
	__uint32_t      c_oflag;        
	__uint32_t      c_cflag;        
	__uint32_t      c_lflag;        
	cc_t            c_cc[NCCS];     
	__uint32_t      c_ispeed;       
	__uint32_t      c_ospeed;       
};
struct timeb {
	time_t          time;           
	unsigned short  millitm;        
	short           timezone;       
	short           dstflag;        
};
struct tms {
	clock_t tms_utime;      
	clock_t tms_stime;      
	clock_t tms_cutime;     
	clock_t tms_cstime;     
};
struct ntptimeval {
	struct timespec time;           
	long maxerror;                  
	long esterror;                  
	long tai;                       
	int time_state;                 
};
struct timex {
	unsigned int modes;             
	long    offset;                 
	long    freq;                   
	long    maxerror;               
	long    esterror;               
	int     status;                 
	long    constant;               
	long    precision;              
	long    tolerance;              
	long    ppsfreq;                
	long    jitter;                 
	int     shift;                  
	long    stabil;                 
	long    jitcnt;                 
	long    calcnt;                 
	long    errcnt;                 
	long    stbcnt;                 
};
struct DTTrustCacheRange {
	vm_offset_t paddr;
	size_t length;
} DTTrustCacheRange;
struct _trust_cache_offsets {
	uint32_t num_caches;

	uint32_t offsets[0];
} __attribute__((__packed__)) trust_cache_offsets_t;
struct clist {
	int     c_cc;           
	int     c_cn;           
	u_char  *c_cf;          
	u_char  *c_cl;          
	u_char  *c_cs;          
	u_char  *c_ce;          
	u_char  *c_cq;          
};
struct tty {
	lck_mtx_t       t_lock;         

	struct  clist t_rawq;           
	long    t_rawcc;                
	struct  clist t_canq;           
	long    t_cancc;                
	struct  clist t_outq;           
	long    t_outcc;                
	int     t_line;                 
	dev_t   t_dev;                  
	int     t_state;                
	int     t_flags;                
	int     t_timeout;              
	struct  pgrp *t_pgrp;           
	struct  session *t_session;     
	struct  selinfo t_rsel;         
	struct  selinfo t_wsel;         
	struct  termios t_termios;      
	struct  winsize t_winsize;      
	                                
	void    (*t_oproc)(struct tty *);
	void    (*t_stop)(struct tty *, int);
	int     (*t_param)(struct tty *, struct termios *);
	void    *t_sc;                  
	int     t_column;               
	int     t_rocount, t_rocol;     
	int     t_hiwat;                
	int     t_lowat;                
	int     t_gen;                  
	void    *t_iokit;               
	os_ref_atomic_t t_refcnt;
	thread_t t_locked_thread;       
};
struct speedtab {
	int sp_speed;
	int sp_code;
};
struct winsize {
	unsigned short  ws_row;         
	unsigned short  ws_col;         
	unsigned short  ws_xpixel;      
	unsigned short  ws_ypixel;      
};
struct cl_extent {
	daddr64_t       b_addr;
	daddr64_t       e_addr;
};
struct cl_wextent {
	daddr64_t       b_addr;
	daddr64_t       e_addr;
	int             io_flags;
};
struct cl_readahead {
	lck_mtx_t       cl_lockr;
	daddr64_t       cl_lastr;                       
	daddr64_t       cl_maxra;                       
	int             cl_ralen;                       
};
struct cl_writebehind {
	lck_mtx_t       cl_lockw;
	void    *       cl_scmap;                       
	off_t           cl_last_write;                  
	off_t           cl_seq_written;                 
	int             cl_sparse_pushes;               
	int             cl_sparse_wait;                 
	int             cl_number;                      
	struct cl_wextent cl_clusters[MAX_CLUSTERS];    
};
struct cs_blob {
	struct cs_blob  *csb_next;
	vnode_t         csb_vnode;
	void            *csb_ro_addr;
	__xnu_struct_group(cs_cpu_info, csb_cpu_info, {
		cpu_type_t      csb_cpu_type;
		cpu_subtype_t   csb_cpu_subtype;
	});
	__xnu_struct_group(cs_signer_info, csb_signer_info, {
		unsigned int    csb_flags;
		unsigned int    csb_signer_type;
	});
	off_t           csb_base_offset;        
	off_t           csb_start_offset;       
	off_t           csb_end_offset;         
	vm_size_t       csb_mem_size;
	vm_offset_t     csb_mem_offset;
	void            *csb_mem_kaddr;
	unsigned char   csb_cdhash[CS_CDHASH_LEN];
	const struct cs_hash  *csb_hashtype;
	int             csb_hash_pageshift;
	int             csb_hash_firstlevel_pageshift;   
	const CS_CodeDirectory *csb_cd;
	const char      *csb_teamid;
	const CS_GenericBlob *csb_entitlements_blob;    
	const CS_GenericBlob *csb_der_entitlements_blob;    

	void *XNU_PTRAUTH_SIGNED_PTR("cs_blob.csb_entitlements") csb_entitlements;

	unsigned int    csb_reconstituted;      
	__xnu_struct_group(cs_blob_platform_flags, csb_platform_flags, {
		
		unsigned int    csb_platform_binary:1;
		unsigned int    csb_platform_path:1;
	});

	unsigned int    csb_validation_category;

	uint64_t    csb_auxiliary_info;

};
struct ubc_info {
	memory_object_t         ui_pager;       
	memory_object_control_t ui_control;     
	vnode_t                 XNU_PTRAUTH_SIGNED_PTR("ubc_info.ui_vnode") ui_vnode;       
	kauth_cred_t            ui_ucred;       
	off_t                   ui_size;        
	uint32_t                ui_flags;       
	uint32_t                cs_add_gen;     

	struct  cl_readahead   *cl_rahead;      
	struct  cl_writebehind *cl_wbehind;     

	struct timespec         cs_mtime;       
	struct  cs_blob         * XNU_PTRAUTH_SIGNED_PTR("ubc_info.cs_blob") cs_blobs; 
};
struct user_ucontext64 {
	int                             uc_onstack;
	sigset_t                        uc_sigmask;     
	struct user64_sigaltstack       uc_stack;       
	user_addr_t                     uc_link;        
	user_size_t                     uc_mcsize;      
	user_addr_t                     uc_mcontext64;  
} user_ucontext64_t;
struct user_ucontext32 {
	int                             uc_onstack;
	sigset_t                        uc_sigmask;     
	struct user32_sigaltstack       uc_stack;       
	user32_addr_t                   uc_link;        
	user32_size_t                   uc_mcsize;      
	user32_addr_t                   uc_mcontext;    
} user_ucontext32_t;
struct kern_iovec {
	u_int64_t       iov_base;       
	u_int64_t       iov_len;        
};
struct user_iovec {
	user_addr_t     iov_base;       
	user_size_t     iov_len;        
};
struct user32_iovec {
	uint32_t        iov_base;       
	uint32_t        iov_len;        
};
struct user64_iovec {
	uint64_t        iov_base;       
	uint64_t        iov_len;        
};
struct uio {
	void * XNU_PTRAUTH_SIGNED_PTR("uio.uio_iovs") uio_iovs;       
	void * XNU_PTRAUTH_SIGNED_PTR("uio.uio_iovbase") uio_iovbase; 
	int             uio_max_iovs;   
	int             uio_iovcnt;     
	off_t           uio_offset;
	enum uio_seg    uio_segflg;
	enum uio_rw     uio_rw;
	user_size_t     uio_resid_64;
	u_int32_t       uio_flags;
};
struct  sockaddr_un {
	unsigned char   sun_len;        
	sa_family_t     sun_family;     
	char            sun_path[104];  
};
struct _unpcb_list_entry {
	u_int32_t   le_next;
	u_int32_t   le_prev;
};
struct  unpcb_compat {
	_UNPCB_LIST_ENTRY(unpcb_compat) unp_link;       
	_UNPCB_PTR(struct socket *)     unp_socket;     
	_UNPCB_PTR(struct vnode *)      unp_vnode;      
	u_int32_t                       unp_ino;        
	_UNPCB_PTR(struct unpcb_compat *) unp_conn;     
	u_int32_t                       unp_refs;
	_UNPCB_LIST_ENTRY(unpcb_compat) unp_reflink;    
	_UNPCB_PTR(struct sockaddr_un *) unp_addr;      
	int                             unp_cc;         
	int                             unp_mbcnt;      
	unp_gen_t                       unp_gencnt;     
};
struct  xunpgen {
	u_int32_t       xug_len;
	u_int           xug_count;
	unp_gen_t       xug_gen;
	so_gen_t        xug_sogen;
};
struct  user {
};
struct  utsname {
	char    sysname[_SYS_NAMELEN];  
	char    nodename[_SYS_NAMELEN]; 
	char    release[_SYS_NAMELEN];  
	char    version[_SYS_NAMELEN];  
	char    machine[_SYS_NAMELEN];  
};
struct vmspace {
	int     vm_refcnt;      
	caddr_t vm_shm;         

	segsz_t vm_rssize;      
	segsz_t vm_swrss;       
	segsz_t vm_tsize;       
	segsz_t vm_dsize;       
	segsz_t vm_ssize;       
	caddr_t vm_taddr;       
	caddr_t vm_daddr;       
	caddr_t vm_maxsaddr;    
};
struct user32_vmspace {
	int             vm_refcnt;      
	uint32_t        vm_shm;                 
	segsz_t         vm_rssize;              
	segsz_t         vm_swrss;               
	segsz_t         vm_tsize;               
	segsz_t         vm_dsize;               
	segsz_t         vm_ssize;               
	uint32_t        vm_taddr;       
	uint32_t        vm_daddr;       
	uint32_t vm_maxsaddr;   
};
struct user_vmspace {
	int             vm_refcnt;      
	user_addr_t     vm_shm __attribute((aligned(8)));                       
	segsz_t         vm_rssize;              
	segsz_t         vm_swrss;               
	segsz_t         vm_tsize;               
	segsz_t         vm_dsize;               
	segsz_t         vm_ssize;               
	user_addr_t     vm_taddr __attribute((aligned(8)));       
	user_addr_t     vm_daddr;       
	user_addr_t vm_maxsaddr;        
};
struct componentname {
	uint32_t        cn_nameiop;     
	uint32_t        cn_flags;       
	vfs_context_t   cn_context;
	struct nameidata *cn_ndp;       



	char    *cn_pnbuf;      
	int     cn_pnlen;       
	char    *cn_nameptr;    
	int     cn_namelen;     
	uint32_t        cn_hash;        
	uint32_t        cn_consume;     
};
struct vnode_fsparam {
	struct mount * vnfs_mp;         
	enum vtype      vnfs_vtype;             
	const char * vnfs_str;          
	struct vnode * vnfs_dvp;                        
	void * vnfs_fsnode;                     
	int(**vnfs_vops)(void *);               
	int vnfs_markroot;                      
	int vnfs_marksystem;            
	dev_t vnfs_rdev;                        
	off_t vnfs_filesize;            
	struct componentname * vnfs_cnp; 
	uint32_t vnfs_flags;            
};
struct vnode_trigger_info {
	trigger_vnode_resolve_callback_t        vti_resolve_func;
	trigger_vnode_unresolve_callback_t      vti_unresolve_func;
	trigger_vnode_rearm_callback_t          vti_rearm_func;
	trigger_vnode_reclaim_callback_t        vti_reclaim_func;
	void *                                  vti_data;   
	uint32_t                                vti_flags;  
};
struct vnode_trigger_param {
	struct vnode_fsparam                    vnt_params; 
	trigger_vnode_resolve_callback_t        vnt_resolve_func;
	trigger_vnode_unresolve_callback_t      vnt_unresolve_func;
	trigger_vnode_rearm_callback_t          vnt_rearm_func;
	trigger_vnode_reclaim_callback_t        vnt_reclaim_func;
	void *                                  vnt_data;   
	uint32_t                                vnt_flags;  
};
struct vnode_attr {
	uint64_t        va_supported;
	uint64_t        va_active;

	int             va_vaflags;

	dev_t           va_rdev;        
	uint64_t        va_nlink;       
	uint64_t        va_total_size;  
	uint64_t        va_total_alloc; 
	uint64_t        va_data_size;   
	uint64_t        va_data_alloc;  
	uint32_t        va_iosize;      

	uid_t           va_uid;         
	gid_t           va_gid;         
	mode_t          va_mode;        
	uint32_t        va_flags;       
	struct kauth_acl *va_acl;       

	struct timespec va_create_time; 
	struct timespec va_access_time; 
	struct timespec va_modify_time; 
	struct timespec va_change_time; 
	struct timespec va_backup_time; 

	uint64_t        va_fileid;      
	uint64_t        va_linkid;      
	uint64_t        va_parentid;    
	uint32_t        va_fsid;        
	uint64_t        va_filerev;     	
	uint32_t        va_gen;         	
	uint32_t        va_encoding;    

	enum vtype      va_type;        
	char *          va_name;        
	guid_t          va_uuuid;       
	guid_t          va_guuid;       

	uint64_t        va_nchildren;     
	uint64_t        va_dirlinkcount;  

	struct kauth_acl *va_base_acl;
	struct timespec va_addedtime;   

	uint32_t va_dataprotect_class;  
	uint32_t va_dataprotect_flags;  

	uint32_t va_document_id;

	uint32_t        va_devid;       
	uint32_t        va_objtype;     
	uint32_t        va_objtag;      
	uint32_t        va_user_access; 
	uint8_t         va_finderinfo[32];      
	uint64_t        va_rsrc_length; 
	uint64_t        va_rsrc_alloc;  
	fsid_t          va_fsid64;      

	uint32_t va_write_gencount;     

	uint64_t va_private_size; 
	uint64_t va_clone_id;     
	uint64_t va_extflags;     
	uint64_t va_recursive_gencount; 
	uint64_t va_attribution_tag;    
	uint32_t va_clone_refcnt;       

};
struct vnodeopv_entry_desc {
	struct vnodeop_desc *opve_op;   
	int (*opve_impl)(void *);               
};
struct vnodeopv_desc {
	int(***opv_desc_vector_p)(void *);
	const struct vnodeopv_entry_desc *opv_desc_ops;   
};
struct vnop_generic_args {
	struct vnodeop_desc *a_desc;
};
struct io_compression_stats {
	uint64_t uncompressed_size;
	uint64_t compressed_size;
	uint32_t buffer_size_compression_dist[IOCS_BUFFER_NUM_SIZE_BUCKETS][IOCS_BUFFER_NUM_COMPRESSION_BUCKETS];
	uint32_t block_compressed_size_dist[IOCS_BLOCK_NUM_SIZE_BUCKETS];
};
struct iocs_store_buffer_entry {
	char     path_name[IOCS_SBE_PATH_LEN];
	struct io_compression_stats iocs;
};
struct vnop_lookup_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_dvp;
	vnode_t *a_vpp;
	struct componentname *a_cnp;
	vfs_context_t a_context;
};
struct vnop_create_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_dvp;
	vnode_t *a_vpp;
	struct componentname *a_cnp;
	struct vnode_attr *a_vap;
	vfs_context_t a_context;
};
struct vnop_whiteout_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_dvp;
	struct componentname *a_cnp;
	int a_flags;
	vfs_context_t a_context;
};
struct vnop_mknod_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_dvp;
	vnode_t *a_vpp;
	struct componentname *a_cnp;
	struct vnode_attr *a_vap;
	vfs_context_t a_context;
};
struct vnop_open_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	int a_mode;
	vfs_context_t a_context;
};
struct vnop_compound_open_args {
	struct vnodeop_desc *a_desc;

	vnode_t a_dvp;                          
	vnode_t *a_vpp;                         
	int a_fmode;                            
	struct componentname *a_cnp;            
	struct vnode_attr *a_vap;               
	uint32_t a_flags;                       
	uint32_t *a_status;                     

	vfs_context_t a_context;                        

	int (*a_open_create_authorizer)(        
		vnode_t dvp,                            
		struct componentname *cnp,              
		struct vnode_attr *vap,                 
		vfs_context_t ctx,                      
		void *reserved);                        

	int (*a_open_existing_authorizer)(      
		vnode_t vp,                             
		struct componentname *cnp,              
		int fmode,                              
		vfs_context_t ctx,                      
		void *reserved);                        

	void *a_reserved;
};
struct vnop_close_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	int a_fflag;
	vfs_context_t a_context;
};
struct vnop_access_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	int a_action;
	vfs_context_t a_context;
};
struct vnop_getattr_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	struct vnode_attr *a_vap;
	vfs_context_t a_context;
};
struct vnop_setattr_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	struct vnode_attr *a_vap;
	vfs_context_t a_context;
};
struct vnop_read_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	struct uio *a_uio;
	int a_ioflag;
	vfs_context_t a_context;
};
struct vnop_write_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	struct uio *a_uio;
	int a_ioflag;
	vfs_context_t a_context;
};
struct vnop_ioctl_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	u_long a_command;
	caddr_t a_data;
	int a_fflag;
	vfs_context_t a_context;
};
struct vnop_select_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	int a_which;
	int a_fflags;
	void *a_wql;
	vfs_context_t a_context;
};
struct vnop_exchange_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_fvp;
	vnode_t a_tvp;
	int a_options;
	vfs_context_t a_context;
};
struct vnop_revoke_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	int a_flags;
	vfs_context_t a_context;
};
struct vnop_mmap_check_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	int a_flags;
	vfs_context_t a_context;
};
struct vnop_mmap_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	int a_fflags;
	vfs_context_t a_context;
};
struct vnop_mnomap_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	vfs_context_t a_context;
};
struct vnop_fsync_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	int a_waitfor;
	vfs_context_t a_context;
};
struct vnop_remove_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_dvp;
	vnode_t a_vp;
	struct componentname *a_cnp;
	int a_flags;
	vfs_context_t a_context;
};
struct vnop_compound_remove_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_dvp;                          
	vnode_t *a_vpp;                         
	struct componentname *a_cnp;            
	struct vnode_attr *a_vap;               
	uint32_t a_flags;                       
	vfs_context_t a_context;                
	int (*a_remove_authorizer)(             
		vnode_t dvp,                            
		vnode_t vp,                             
		struct componentname *cnp,              
		vfs_context_t ctx,                      
		void *reserved);                        
	void *a_reserved;                       
};
struct vnop_link_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	vnode_t a_tdvp;
	struct componentname *a_cnp;
	vfs_context_t a_context;
};
struct vnop_rename_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_fdvp;
	vnode_t a_fvp;
	struct componentname *a_fcnp;
	vnode_t a_tdvp;
	vnode_t a_tvp;
	struct componentname *a_tcnp;
	vfs_context_t a_context;
};
struct vnop_renamex_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_fdvp;
	vnode_t a_fvp;
	struct componentname *a_fcnp;
	vnode_t a_tdvp;
	vnode_t a_tvp;
	struct componentname *a_tcnp;
	struct vnode_attr *a_vap;               
	vfs_rename_flags_t a_flags;
	vfs_context_t a_context;
};
struct vnop_compound_rename_args {
	struct vnodeop_desc *a_desc;

	vnode_t a_fdvp;                 
	vnode_t *a_fvpp;                
	struct componentname *a_fcnp;   
	struct vnode_attr *a_fvap;

	vnode_t a_tdvp;                 
	vnode_t *a_tvpp;                
	struct componentname *a_tcnp;   
	struct vnode_attr *a_tvap;

	uint32_t a_flags;               
	vfs_context_t a_context;        
	int (*a_rename_authorizer)(                     
		vnode_t fdvp,                           
		vnode_t fvp,                            
		struct componentname *fcnp,             
		vnode_t tdvp,                           
		vnode_t tvp,                            
		struct componentname *tcnp,             
		vfs_context_t ctx,                      
		void *reserved);                        
	void *a_reserved;               
};
struct vnop_mkdir_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_dvp;
	vnode_t *a_vpp;
	struct componentname *a_cnp;
	struct vnode_attr *a_vap;
	vfs_context_t a_context;
};
struct vnop_compound_mkdir_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_dvp;                  
	vnode_t *a_vpp;                 
	struct componentname *a_cnp;    
	struct vnode_attr *a_vap;       
	uint32_t a_flags;               
	vfs_context_t a_context;        
	void *a_reserved;               
};
struct vnop_rmdir_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_dvp;
	vnode_t a_vp;
	struct componentname *a_cnp;
	vfs_context_t a_context;
};
struct vnop_compound_rmdir_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_dvp;                          
	vnode_t *a_vpp;                         
	struct componentname *a_cnp;            
	struct vnode_attr *a_vap;               
	uint32_t a_flags;                       
	vfs_context_t a_context;                
	int (*a_rmdir_authorizer)(              
		vnode_t dvp,                            
		vnode_t vp,                             
		struct componentname *cnp,              
		vfs_context_t ctx,                      
		void *reserved);                        
	void *a_reserved;                       
};
struct vnop_symlink_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_dvp;
	vnode_t *a_vpp;
	struct componentname *a_cnp;
	struct vnode_attr *a_vap;
	char *a_target;
	vfs_context_t a_context;
};
struct vnop_readdir_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	struct uio *a_uio;
	int a_flags;
	int *a_eofflag;
	int *a_numdirent;
	vfs_context_t a_context;
};
struct vnop_readdirattr_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	struct attrlist *a_alist;
	struct uio *a_uio;
	uint32_t a_maxcount;
	uint32_t a_options;
	uint32_t *a_newstate;
	int *a_eofflag;
	uint32_t *a_actualcount;
	vfs_context_t a_context;
};
struct vnop_getattrlistbulk_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	struct attrlist *a_alist;
	struct vnode_attr *a_vap;
	struct uio *a_uio;
	void *a_private;
	uint64_t a_options;
	int32_t *a_eofflag;
	int32_t *a_actualcount;
	vfs_context_t a_context;
};
struct vnop_readlink_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	struct uio *a_uio;
	vfs_context_t a_context;
};
struct vnop_inactive_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	vfs_context_t a_context;
};
struct vnop_reclaim_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	vfs_context_t a_context;
};
struct vnop_pathconf_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	int a_name;
	int32_t *a_retval;
	vfs_context_t a_context;
};
struct vnop_advlock_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	caddr_t a_id;
	int a_op;
	struct flock *a_fl;
	int a_flags;
	vfs_context_t a_context;
	struct timespec *a_timeout;
};
struct vnop_allocate_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	off_t a_length;
	u_int32_t a_flags;
	off_t *a_bytesallocated;
	off_t a_offset;
	vfs_context_t a_context;
};
struct vnop_pagein_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	upl_t a_pl;
	upl_offset_t a_pl_offset;
	off_t a_f_offset;
	size_t a_size;
	int a_flags;
	vfs_context_t a_context;
};
struct vnop_pageout_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	upl_t a_pl;
	upl_offset_t a_pl_offset;
	off_t a_f_offset;
	size_t a_size;
	int a_flags;
	vfs_context_t a_context;
};
struct vnop_searchfs_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	void *a_searchparams1;
	void *a_searchparams2;
	struct attrlist *a_searchattrs;
	uint32_t a_maxmatches;
	struct timeval *a_timelimit;
	struct attrlist *a_returnattrs;
	uint32_t *a_nummatches;
	uint32_t a_scriptcode;
	uint32_t a_options;
	struct uio *a_uio;
	struct searchstate *a_searchstate;
	vfs_context_t a_context;
};
struct vnop_copyfile_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_fvp;
	vnode_t a_tdvp;
	vnode_t a_tvp;
	struct componentname *a_tcnp;
	int a_mode;
	int a_flags;
	vfs_context_t a_context;
};
struct vnop_clonefile_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_fvp;
	vnode_t a_dvp;
	vnode_t *a_vpp;
	struct componentname *a_cnp;
	struct vnode_attr *a_vap;
	uint32_t a_flags;
	vfs_context_t a_context;
	int (*a_dir_clone_authorizer)(  
		struct vnode_attr *vap,         
		kauth_action_t action,         
		struct vnode_attr *dvap,         
		vnode_t sdvp,         
		mount_t mp,         
		dir_clone_authorizer_op_t vattr_op,         
		uint32_t flags,         
		vfs_context_t ctx,                      
		void *reserved);                        
	void *a_reserved;               
};
struct vnop_getxattr_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	const char * a_name;
	uio_t a_uio;
	size_t *a_size;
	int a_options;
	vfs_context_t a_context;
};
struct vnop_setxattr_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	const char * a_name;
	uio_t a_uio;
	int a_options;
	vfs_context_t a_context;
};
struct vnop_removexattr_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	const char * a_name;
	int a_options;
	vfs_context_t a_context;
};
struct vnop_listxattr_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	uio_t a_uio;
	size_t *a_size;
	int a_options;
	vfs_context_t a_context;
};
struct vnop_blktooff_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	daddr64_t a_lblkno;
	off_t *a_offset;
};
struct vnop_offtoblk_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	off_t a_offset;
	daddr64_t *a_lblkno;
};
struct vnop_blockmap_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	off_t a_foffset;
	size_t a_size;
	daddr64_t *a_bpn;
	size_t *a_run;
	void *a_poff;
	int a_flags;
	vfs_context_t a_context;
};
struct vnop_strategy_args {
	struct vnodeop_desc *a_desc;
	struct buf *a_bp;
};
struct vnop_bwrite_args {
	struct vnodeop_desc *a_desc;
	buf_t a_bp;
};
struct vnop_kqfilt_add_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	struct knote *a_kn;
	vfs_context_t a_context;
};
struct vnop_kqfilt_remove_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	uintptr_t a_ident;
	vfs_context_t a_context;
};
struct vnop_monitor_args {
	struct vnodeop_desc *a_desc;
	vnode_t a_vp;
	uint32_t a_events;
	uint32_t a_flags;
	void *a_handle;
	vfs_context_t a_context;
};
struct vnop_setlabel_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	struct label *a_vl;
	vfs_context_t a_context;
};
struct vnode {
	lck_mtx_t v_lock;                       
	TAILQ_ENTRY(vnode) v_freelist;          
	TAILQ_ENTRY(vnode) v_mntvnodes;         
	TAILQ_HEAD(, namecache) v_ncchildren;   
	LIST_HEAD(, namecache) v_nclinks;       
	vnode_t  v_defer_reclaimlist;           
	uint32_t v_listflag;                    
	uint32_t v_flag;                        
	uint16_t v_lflag;                       
	uint8_t  v_iterblkflags;                
	uint8_t  v_references;                  
	int32_t  v_kusecount;                   
	int32_t  v_usecount;                    
	int32_t  v_iocount;                     
	void *   XNU_PTRAUTH_SIGNED_PTR("vnode.v_owner") v_owner; 
	uint8_t  v_ext_flag;                    
	uint8_t  v_type;                        
	uint16_t v_tag;                         
	uint32_t v_id;                          
	union {
		struct mount    * XNU_PTRAUTH_SIGNED_PTR("vnode.v_data") vu_mountedhere;  
		struct socket   * XNU_PTRAUTH_SIGNED_PTR("vnode.vu_socket") vu_socket;     
		struct specinfo * XNU_PTRAUTH_SIGNED_PTR("vnode.vu_specinfo") vu_specinfo;   
		struct fifoinfo * XNU_PTRAUTH_SIGNED_PTR("vnode.vu_fifoinfo") vu_fifoinfo;   
		struct ubc_info * XNU_PTRAUTH_SIGNED_PTR("vnode.vu_ubcinfo") vu_ubcinfo;    
	} v_un;
	struct  buflists v_cleanblkhd;          
	struct  buflists v_dirtyblkhd;          
	struct klist v_knotes;                  
	kauth_cred_t    XNU_PTRAUTH_SIGNED_PTR("vnode.v_cred") v_cred; 
	kauth_action_t  v_authorized_actions;   
	int             v_cred_timestamp;       
	int             v_nc_generation;        
	int32_t         v_numoutput;            
	int32_t         v_writecount;           
	uint32_t        v_holdcount;            
	const char *v_name;                     
	vnode_t XNU_PTRAUTH_SIGNED_PTR("vnode.v_parent") v_parent;                       
	struct lockf    *v_lockf;               
	int(**v_op)(void *);                    
	mount_t XNU_PTRAUTH_SIGNED_PTR("vnode.v_mount") v_mount;                        
	void *  v_data;                         
	struct label *v_label;                  


};
struct fd_vn_data {
	lck_mtx_t fv_lock;   
	off_t     fv_offset; 
	void      *fv_dircookie; 
	caddr_t   fv_buf;    
	size_t    fv_bufsiz;  
	size_t    fv_bufdone; 
	size_t    fv_bufallocsiz; 
	off_t     fv_soff;   
	off_t     fv_eoff;   
	int       fv_eofflag;
};
struct vnodeop_desc {
	int     vdesc_offset;           
	const char *vdesc_name;         
	int     vdesc_flags;            

	int     *vdesc_vp_offsets;      
	int     vdesc_vpp_offset;       
	int     vdesc_cred_offset;      
	int     vdesc_proc_offset;      
	int     vdesc_componentname_offset; 
	int     vdesc_context_offset;   
	caddr_t *vdesc_transports;
};
struct sockaddr_vm {
	__uint8_t      svm_len;        
	sa_family_t    svm_family;     
	__uint16_t     svm_reserved1;
	__uint32_t     svm_port;       
	__uint32_t     svm_cid;        
} __attribute__((__packed__));
struct xvsockpcb {
	u_int32_t      xv_len;            
	u_int64_t      xv_vsockpp;
	u_int32_t      xvp_local_cid;     
	u_int32_t      xvp_local_port;    
	u_int32_t      xvp_remote_cid;    
	u_int32_t      xvp_remote_port;   
	u_int32_t      xvp_rxcnt;         
	u_int32_t      xvp_txcnt;         
	u_int32_t      xvp_peer_rxhiwat;  
	u_int32_t      xvp_peer_rxcnt;    
	pid_t          xvp_last_pid;      
	vsock_gen_t    xvp_gencnt;        
	struct xsocket xv_socket;
};
struct  xvsockpgen {
	u_int32_t      xvg_len;      
	u_int64_t      xvg_count;    
	vsock_gen_t    xvg_gen;      
	so_gen_t       xvg_sogen;    
};
struct vsockpcb {
	TAILQ_ENTRY(vsockpcb) all;
	LIST_ENTRY(vsockpcb) bound;
	struct socket *so;
	struct vsock_address local_address;
	struct vsock_address remote_address;
	struct vsock_transport *transport;
	uint32_t fwd_cnt;
	uint32_t tx_cnt;
	uint32_t peer_buf_alloc;
	uint32_t peer_fwd_cnt;
	uint32_t last_buf_alloc;
	uint32_t last_fwd_cnt;
	size_t waiting_send_size;
	vsock_gen_t vsock_gencnt;
};
struct vsockpcbinfo {
	lck_rw_t all_lock;
	lck_rw_t bound_lock;
	TAILQ_HEAD(, vsockpcb) all;
	LIST_HEAD(, vsockpcb) bound;
	uint32_t last_port;
	lck_mtx_t port_lock;
	uint64_t all_pcb_count;
	vsock_gen_t vsock_gencnt;
};
struct vsock_address {
	uint32_t cid;
	uint32_t port;
};
struct vsock_transport {
	void *provider;
	int (*get_cid)(void *provider, uint32_t *cid);
	int (*attach_socket)(void *provider);
	int (*detach_socket)(void *provider);
	int (*put_message)(void *provider, struct vsock_address src, struct vsock_address dst,
	    enum vsock_operation op, uint32_t buf_alloc, uint32_t fwd_cnt, mbuf_t m);
};
struct work_interval_notification {
	uint64_t        start;
	uint64_t        finish;
	uint64_t        deadline;
	uint64_t        next_start;
	uint32_t        notify_flags;
	uint32_t        create_flags;
};
struct work_interval_create_params {
	uint64_t        wicp_id;          
	mach_port_name_t wicp_port;       
	uint32_t        wicp_create_flags;
};
struct work_interval_workload_id_params {
	uint32_t        wlidp_flags;            
	uint32_t        wlidp_wicreate_flags;   
	uint64_t        wlidp_name;             
	uint64_t        wlidp_syscall_mask[2];  
};
struct {
	uint32_t length;
	uint32_t returned_attrs[5];
	int32_t name_offset;
	uint32_t name_length;
	uint32_t obj_type;
	uint64_t file_id;
	off_t data_length;
} __attribute__((packed)) exclave_fs_dirent_t;
struct iocs_store_buffer {
	void*                   buffer;
	uint32_t                current_position;
	uint32_t                marked_point;
};
struct  pager_struct {
	boolean_t       is_device;
};
struct pager_file {
	queue_chain_t   pf_chain;       
	struct  vnode   *pf_vp;         
	u_int           pf_count;       
	u_char          *pf_bmap;       
	long            pf_npgs;        
	long            pf_pfree;       
	long            pf_lowat;       
	long            pf_hipage;      
	long            pf_hint;        
	char            *pf_name;       
	boolean_t       pf_prefer;
	int             pf_index;       
	void *          pf_lock;        
} *pager_file_t;
struct bs_map {
	struct vnode    *vp;
	void            *bs;
};
struct {
	unsigned int index:8;   
	unsigned int offset:24; 
} pf_entry;
struct vstruct {
	boolean_t       is_device;      
	pager_file_t    vs_pf;          
	pf_entry        **vs_pmap;      
	unsigned int
	 vs_swapfile:1;  
	short           vs_count;       
	int             vs_size;        
	struct vnode    *vs_vp;         
} *vnode_pager_t;
struct fd_set {
	__int32_t       fds_bits[__DARWIN_howmany(__DARWIN_FD_SETSIZE, __DARWIN_NFDBITS)];
} fd_set;
struct fsobj_id {
	u_int32_t fid_objno;
	u_int32_t fid_generation;
} fsobj_id_t;
struct secure_boot_cryptex_args {
	u_int32_t sbc_version;
	u_int32_t sbc_4cc;
	int sbc_authentic_manifest_fd;
	int sbc_user_manifest_fd;
	int sbc_payload_fd;
	u_int64_t sbc_flags;
} __attribute__((aligned(4), packed))  secure_boot_cryptex_args_t;
struct iovec {
	void *   iov_base;      
	size_t   iov_len;       
};
struct timeval64 {
	__int64_t               tv_sec;         
	__int64_t               tv_usec;        
};
struct ch_selinfo {
	decl_lck_mtx_data(, csi_lock);
	struct selinfo  csi_si;
	uint32_t        csi_flags;
	uint32_t        csi_pending;
	uint64_t        csi_eff_interval;
	uint64_t        csi_interval;
	thread_call_t   csi_tcall;
};
struct __kern_slot_desc {
	union {
		struct __kern_quantum *sd_qum;
		struct __kern_packet *sd_pkt;
		struct __kern_buflet *sd_buf;
		void *sd_md;                    
	};

};
struct slot_ctx {
	void                    *slot_ctx_arg;   
};
struct kern_channel {
	decl_lck_mtx_data(, ch_lock);
	struct nexus_adapter    *ch_na;
	struct kern_nexus       *ch_nexus;
	struct ch_info          *ch_info;
	struct kern_pbufpool    *ch_pp;

	uint32_t                ch_refcnt;
	volatile uint32_t       ch_flags;       

	ring_id_t               ch_first[NR_ALL];
	ring_id_t               ch_last[NR_ALL];

	struct __user_channel_schema *ch_schema;

	struct ch_selinfo       *ch_si[NR_ALL];

	STAILQ_ENTRY(kern_channel) ch_link;
	STAILQ_ENTRY(kern_channel) ch_link_if_adv;
	void                    *ch_ctx;
	mach_vm_offset_t        ch_schema_offset;
	struct skmem_arena_mmap_info ch_mmap;
	int                     ch_fd;          
	pid_t                   ch_pid;         
	char                    ch_name[32];    
};
struct chreq {
	char            cr_name[CHREQ_NAMELEN];         
	uuid_t          cr_spec_uuid;                   
	struct ch_ev_thresh cr_tx_lowat;                
	struct ch_ev_thresh cr_rx_lowat;                
	nexus_port_t    cr_port;                        
	uint32_t        cr_mode;                        
	uint32_t        cr_pipe_id;                     
	ring_id_t       cr_ring_id;                     
	ring_set_t      cr_ring_set;                    
	ch_endpoint_t   cr_real_endpoint;               
	ch_endpoint_t   cr_endpoint;                    
	mach_vm_size_t  cr_memsize;                     
	mach_vm_offset_t cr_memoffset;                  
};
struct __kern_channel_ring {
	struct __user_channel_ring      *ckr_ring;

	uint32_t                ckr_flags;      
	slot_idx_t              ckr_num_slots;  
	uint32_t                ckr_max_pkt_len;
	uint32_t                ckr_largest;    
	const slot_idx_t        ckr_lim; 
	enum txrx               ckr_tx;  

	volatile slot_idx_t     ckr_khead;
	volatile slot_idx_t     ckr_ktail;
	volatile slot_idx_t     ckr_khead_pre;
	volatile slot_idx_t     ckr_rhead;
	volatile slot_idx_t     ckr_rtail;

	uint32_t                ckr_transfer_decay;

	uint64_t                ckr_ready_bytes;
	uint64_t                ckr_ready_slots;

	decl_lck_spin_data(, ckr_slock);
	struct thread *ckr_owner; 
	uint32_t ckr_busy;      
	uint32_t ckr_want;      
	uint32_t ckr_state;     

	volatile uint32_t       ckr_alloc_ws;

	struct nexus_adapter *ckr_na;   
	struct kern_pbufpool *ckr_pp;   

	struct __slot_desc *__counted_by(ckr_usds_cnt) ckr_usds;   
	slot_idx_t ckr_usds_cnt;
	struct __slot_desc *__counted_by(ckr_ksds_cnt) ckr_ksds;   
	slot_idx_t ckr_ksds_cnt;
	struct __slot_desc *ckr_ksds_last; 
	struct skmem_cache *ckr_ksds_cache; 

	uint32_t        ckr_ring_id;      

	boolean_t       ckr_rate_limited; 

	uint64_t        *__counted_by(ckr_scratch_cnt)ckr_scratch;
	slot_idx_t      ckr_scratch_cnt;
	int (*ckr_na_sync)(struct __kern_channel_ring *,
	    struct proc *, uint32_t);
	int(*volatile ckr_na_notify)(struct __kern_channel_ring *,
	    struct proc *, uint32_t);

	int (*ckr_prologue)(struct kern_channel *,
	    struct __kern_channel_ring *, const slot_idx_t,
	    uint32_t *, uint64_t *, struct proc *);
	void (*ckr_finalize)(struct kern_channel *,
	    struct __kern_channel_ring *, const slot_idx_t, struct proc *);

	uint64_t        ckr_sync_time;


	kern_packet_svc_class_t ckr_svc;

	uint32_t        ckr_slot_ctxs_set; 
	struct slot_ctx *__counted_by(ckr_slot_ctxs_cnt)ckr_slot_ctxs; 
	uint32_t        ckr_slot_ctxs_cnt;
	void            *ckr_ctx;       

	struct ch_selinfo ckr_si;       



	decl_lck_mtx_data(, ckr_qlock);


	uint32_t        ckr_users;      

	int64_t         ckr_tbr_token;
	int64_t         ckr_tbr_depth;
	uint64_t        ckr_tbr_last;

	channel_ring_error_stats ckr_err_stats
	__attribute__((aligned(sizeof(uint64_t))));

	channel_ring_stats ckr_stats
	__attribute__((aligned(sizeof(uint64_t))));
	uint64_t        ckr_accumulated_bytes;
	uint64_t        ckr_accumulated_slots;
	uint64_t        ckr_accumulate_start; 

	channel_ring_user_stats ckr_usr_stats
	__attribute__((aligned(sizeof(uint64_t))));
	uint64_t        ckr_user_accumulated_bytes;
	uint64_t        ckr_user_accumulated_slots;
	uint64_t        ckr_user_accumulated_syncs;
	uint64_t        ckr_user_accumulate_start; 

	lck_grp_t       *ckr_qlock_group;
	lck_grp_t       *ckr_slock_group;

	char            ckr_name[64];   

	uint64_t        ckr_rx_dequeue_ts; 
	uint64_t        ckr_rx_enqueue_ts; 
} __attribute__((__aligned__(CHANNEL_CACHE_ALIGN_MAX)));
struct slot_prop {
	uint16_t sp_flags;              
	uint16_t sp_len;                
	uint32_t sp_idx;                
	mach_vm_address_t sp_ext_ptr;   
	mach_vm_address_t sp_buf_ptr;   
	mach_vm_address_t sp_mdata_ptr; 
	uint32_t _sp_pad[8];            
} slot_prop_t __attribute__((aligned(sizeof(uint64_t))));
struct os_channel_event_packet_transmit_status {
	packet_id_t    packet_id;
	int32_t        packet_status;
} os_channel_event_packet_transmit_status_t;
struct os_channel_event_packet_transmit_expired {
	packet_id_t    packet_id;
	uint64_t       packet_tx_expiration_deadline;
	uint64_t       packet_tx_expiration_timestamp;
	uint16_t       packet_tx_expiration_status;
	uint16_t       packet_tx_expiration_origin;
}  os_channel_event_packet_transmit_expired_t;
struct __kern_channel_event_metadata {
	os_channel_event_type_t    emd_etype;
	uint32_t                   emd_nevents;
};
struct __kern_channel_event {
	os_channel_event_type_t    ev_type;
	uint32_t                   ev_flags;
	uint16_t                   _reserved;
	uint16_t                   ev_dlen;
	uint8_t                    ev_data[__counted_by(ev_dlen)];
};
struct __user_channel_schema {
	const uint32_t  csm_ver;                
	const volatile uint32_t csm_flags;      
	char      csm_kern_name[CHANNEL_SCHEMA_KERN_NAME];
	uuid_t    csm_kern_uuid;


	uint32_t  csm_tx_rings;   
	uint32_t  csm_rx_rings;   

	uint32_t  csm_allocator_ring_pairs;

	uint32_t  csm_num_event_rings;
	uint32_t  csm_large_buf_alloc_rings;

	const uint32_t          csm_flowadv_max;
	const mach_vm_offset_t  csm_flowadv_ofs
	__attribute__((aligned(sizeof(uint64_t))));

	const uint64_t  csm_md_redzone_cookie   
	__attribute__((aligned(sizeof(uint64_t))));
	const nexus_meta_type_t csm_md_type;    
	const nexus_meta_subtype_t csm_md_subtype; 

	const mach_vm_offset_t  csm_stats_ofs
	__attribute__((aligned(sizeof(uint64_t))));
	const nexus_stats_type_t csm_stats_type;

	const mach_vm_offset_t csm_nexusadv_ofs
	__attribute__((aligned(sizeof(uint64_t))));

	struct {
		const mach_vm_offset_t  ring_off; 
		const mach_vm_offset_t  sd_off;   
	} csm_ring_ofs[__counted_by(csm_tx_rings + csm_rx_rings +
	csm_allocator_ring_pairs + csm_num_event_rings + csm_large_buf_alloc_rings)]
	__attribute__((aligned(sizeof(uint64_t))));
};
struct __user_slot_desc {
	obj_idx_t       sd_md_idx;      
	uint16_t        sd_flags;       
	uint16_t        sd_len;         
};
struct __slot_desc {
	union {
		struct __user_slot_desc _sd_user;
		uint64_t                _sd_private[1];
	};
};
struct __user_channel_ring {
	volatile slot_idx_t     ring_head;      
	const volatile slot_idx_t ring_tail;    
	const volatile slot_idx_t ring_khead;   

	const uint32_t  ring_num_slots; 
	const uint32_t  ring_def_buf_size;  
	const uint32_t  ring_large_buf_size;  
	const uint16_t  ring_md_size;   
	const uint16_t  ring_bft_size;  
	const uint16_t  ring_id;        
	const uint16_t  ring_kind;      

	const mach_vm_offset_t  ring_def_buf_base
	__attribute((aligned(sizeof(uint64_t))));
	const mach_vm_offset_t  ring_large_buf_base
	__attribute((aligned(sizeof(uint64_t))));
	const mach_vm_offset_t  ring_md_base    
	__attribute((aligned(sizeof(uint64_t))));
	const mach_vm_offset_t  ring_sd_base    
	__attribute((aligned(sizeof(uint64_t))));
	const mach_vm_offset_t  ring_bft_base
	__attribute((aligned(sizeof(uint64_t))));

	const volatile uint64_t ring_sync_time 
	__attribute((aligned(sizeof(uint64_t))));
	const volatile uint64_t ring_notify_time 
	__attribute((aligned(sizeof(uint64_t))));
	const volatile uint32_t ring_alloc_ws;
	const volatile uint32_t ring_alloc_buf_ws;
};
struct __flowadv_entry {
	union {
		uint64_t        fae_id_64[2];
		uint32_t        fae_id_32[4];
		uuid_t          fae_id; 
	};
	volatile uint32_t       fae_ce_cnt;
	volatile uint32_t       fae_pkt_cnt;
	volatile uint32_t       fae_flags;  
	uint32_t                fae_flowid;
} __attribute__((aligned(sizeof(uint64_t))));
struct ch_ev_thresh {
	channel_threshold_unit_t cet_unit;
	uint32_t                cet_value;
};
struct ch_info {
	union {
		uint64_t  cinfo_ch_id_64[2];
		uint32_t  cinfo_ch_id_32[4];
		uuid_t    cinfo_ch_id;          
	};
	uint32_t          cinfo_ch_mode;        
	ring_id_t         cinfo_ch_ring_id;     
	struct nxprov_params cinfo_nxprov_params; 
	uuid_t            cinfo_nx_uuid;        
	nexus_port_t      cinfo_nx_port;        
	uint32_t          cinfo_num_bufs;       
	mach_vm_size_t    cinfo_mem_map_size;   
	mach_vm_address_t cinfo_mem_base;       
	mach_vm_offset_t  cinfo_schema_offset;  
	ring_id_t         cinfo_first_tx_ring;  
	ring_id_t         cinfo_last_tx_ring;   
	ring_id_t         cinfo_first_rx_ring;  
	ring_id_t         cinfo_last_rx_ring;   
	struct ch_ev_thresh cinfo_tx_lowat;     
	struct ch_ev_thresh cinfo_rx_lowat;     
} __attribute__((aligned(sizeof(uint64_t))));
struct ch_init {
	uint32_t        ci_version;     
	uint32_t        ci_ch_mode;     
	ring_id_t       ci_ch_ring_id;  
	nexus_port_t    ci_nx_port;     
	uuid_t          ci_nx_uuid;     
	user_addr_t     ci_key;         
	uint32_t        ci_key_len;     
	uint32_t        __ci_align;     
	struct ch_ev_thresh ci_tx_lowat; 
	struct ch_ev_thresh ci_rx_lowat; 
	guardid_t       ci_guard;       
};
struct skoid {
	struct sysctl_oid_list  sko_oid_list;   
	struct sysctl_oid       sko_oid;        
	char                    sko_name[SKOID_NAME_SIZE];      
};
struct cuckoo_node {
	struct cuckoo_node *next;
};
struct cuckoo_hashtable_params {
	size_t cht_capacity;
	cuckoo_obj_cmp_func cht_obj_cmp;
	cuckoo_obj_retain_func cht_obj_retain;
	cuckoo_obj_release_func cht_obj_release;
};
struct skmem_arena {
	decl_lck_mtx_data(, ar_lock);           
	uint32_t                ar_refcnt;      

	TAILQ_ENTRY(skmem_arena) ar_link;       
	char                    ar_name[64];    
	skmem_arena_type_t      ar_type;        
	uint32_t                ar_flags;       
	size_t                  ar_zsize;       
	IOSKArenaRef            ar_ar;          

	struct skmem_region     *ar_regions[SKMEM_REGIONS]; 

	mach_vm_size_t          ar_mapsize;     
	uint32_t                ar_mapcnt;      
	uint32_t                ar_maprdrcnt;   
	SLIST_HEAD(, skmem_arena_mmap_info) ar_map_head; 
};
struct skmem_arena_mmap_info {
	SLIST_ENTRY(skmem_arena_mmap_info)      ami_link;
	struct skmem_arena      *ami_arena;     
	IOSKMapperRef           ami_mapref;     
	task_t                  ami_maptask;    
	mach_vm_address_t       ami_mapaddr;    
	mach_vm_size_t          ami_mapsize;    
	boolean_t               ami_redirect;   
};
struct skmem_arena_nexus {
	struct skmem_arena      arn_cmn;        

	struct kern_pbufpool    *arn_rx_pp;     
	struct kern_pbufpool    *arn_tx_pp;     
	uint32_t                arn_mode;       
	nexus_meta_type_t       arn_md_type;    
	nexus_meta_subtype_t    arn_md_subtype; 
	int                     arn_ksd_nodefunct;

	struct skmem_cache      *arn_schema_cache; 
	struct skmem_cache      *arn_ring_cache;   
	struct skmem_cache      *arn_txaksd_cache; 
	struct skmem_cache      *arn_rxfksd_cache; 

	void                    *__sized_by(arn_stats_obj_size)arn_stats_obj;
	size_t                  arn_stats_obj_size;

	struct __flowadv_entry  *__counted_by(arn_flowadv_entries)arn_flowadv_obj;
	size_t                  arn_flowadv_entries;

	void                    *arn_nexusadv_obj;
};
struct skmem_arena_necp {
	struct skmem_arena      arc_cmn;        

	struct skmem_cache      *arc_kstats_cache;
};
struct skmem_arena_system {
	struct skmem_arena      ars_cmn;        

	void                    *ars_sysctls_obj;
	size_t                  ars_sysctls_objsize;
};
struct skmem_bufctl {
	SLIST_ENTRY(skmem_bufctl) bc_link;      
	void                    *__sized_by(bc_lim) bc_addr;       
	void                    *bc_addrm;      
	struct skmem_slab       *bc_slab;       
	uint32_t                bc_lim;         
	uint32_t                bc_flags;       
	uint32_t                bc_idx;         
	volatile uint32_t       bc_usecnt;      
};
struct skmem_bufctl_audit {
	SLIST_ENTRY(skmem_bufctl) bc_link;      
	void                    *__sized_by(bc_lim) bc_addr;       
	void                    *bc_addrm;      
	struct skmem_slab       *bc_slab;       
	uint32_t                bc_lim;         
	uint32_t                bc_flags;       
	uint32_t                bc_idx;         
	volatile uint32_t       bc_usecnt;      
	struct thread           *bc_thread;     
	uint32_t                bc_timestamp;   
	uint32_t                bc_depth;       
	void                    *bc_stack[SKMEM_STACK_DEPTH]; 
};
struct skmem_bufctl_bkt {
	SLIST_HEAD(, skmem_bufctl) bcb_head;    
};
struct skmem_slab {
	TAILQ_ENTRY(skmem_slab) sl_link;        
	struct skmem_cache      *sl_cache;      
	void                    *sl_base;       
	void                    *sl_basem;      
	struct sksegment        *sl_seg;        
	struct sksegment        *sl_segm;       
	SLIST_HEAD(, skmem_bufctl) sl_head;     
	uint32_t                sl_refcnt;      
	uint32_t                sl_chunks;      
};
struct skmem_magtype {
	int                     mt_magsize;     
	int                     mt_align;       
	size_t                  mt_minbuf;      
	size_t                  mt_maxbuf;      
	struct skmem_cache      *mt_cache;      
	char                    mt_cname[64];   
};
struct skmem_mag {
	SLIST_ENTRY(skmem_mag)  mg_link;        
	struct skmem_magtype    *mg_magtype;    
	size_t                  mg_count;       
	void                    *mg_round[__counted_by(mg_count)];   
};
struct skmem_maglist {
	SLIST_HEAD(, skmem_mag) ml_list;        
	uint32_t                ml_total;       
	uint32_t                ml_min;         
	uint32_t                ml_reaplimit;   
	uint64_t                ml_alloc;       
};
struct skmem_cpu_cache {
	decl_lck_mtx_data(, cp_lock);
	struct skmem_mag        *cp_loaded;     
	struct skmem_mag        *cp_ploaded;    
	uint64_t                cp_alloc;       
	uint64_t                cp_free;        
	int                     cp_rounds;      
	int                     cp_prounds;     
	int                     cp_magsize;     
} __attribute__((aligned(CHANNEL_CACHE_ALIGN_MAX)));
struct skmem_obj_info {
	void                    *__sized_by(oi_size) oi_addr;       
	struct skmem_bufctl     *oi_bc;         
	uint32_t                oi_size;        
	obj_idx_t               oi_idx_reg;     
	obj_idx_t               oi_idx_seg;     
} __attribute__((__packed__));
struct skmem_obj {
	struct skmem_obj        *mo_next;       
	struct skmem_obj_info   mo_info;        
	struct skmem_obj_info   mo_minfo;       
};
struct skmem_cache {
	uint32_t        skm_mode;               
	skmem_ctor_fn_t skm_ctor;               
	skmem_dtor_fn_t skm_dtor;               
	skmem_reclaim_fn_t skm_reclaim;         
	void            *skm_private;           

	decl_lck_mtx_data(, skm_dp_lock);       
	struct skmem_magtype *skm_magtype;      
	struct skmem_maglist skm_full;          
	struct skmem_maglist skm_empty;         

	decl_lck_mtx_data(, skm_sl_lock);       
	skmem_slab_alloc_fn_t skm_slab_alloc;   
	skmem_slab_free_fn_t skm_slab_free;     
	size_t          skm_chunksize;          
	size_t          skm_objsize;            
	size_t          skm_slabsize;           
	size_t          skm_hash_initial;       
	size_t          skm_hash_limit;         
	size_t          skm_hash_shift;         
	size_t          skm_hash_mask;          
	size_t          skm_hash_size;
	struct skmem_bufctl_bkt *__counted_by(skm_hash_size) skm_hash_table; 
	TAILQ_HEAD(, skmem_slab) skm_sl_partial_list; 
	TAILQ_HEAD(, skmem_slab) skm_sl_empty_list;   
	struct skmem_region *skm_region;        

	uint32_t        skm_cpu_mag_size;       
	uint32_t        skm_cpu_mag_resize;     
	uint32_t        skm_cpu_mag_purge;      
	uint32_t        skm_cpu_mag_reap;       
	uint64_t        skm_depot_contention;   
	uint64_t        skm_depot_contention_prev; 
	uint32_t        skm_depot_full;         
	uint32_t        skm_depot_empty;        
	uint32_t        skm_depot_ws_zero;      
	uint32_t        skm_sl_rescale;         
	uint32_t        skm_sl_create;          
	uint32_t        skm_sl_destroy;         
	uint32_t        skm_sl_alloc;           
	uint32_t        skm_sl_free;            
	uint32_t        skm_sl_partial;         
	uint32_t        skm_sl_empty;           
	uint64_t        skm_sl_alloc_fail;      
	uint64_t        skm_sl_bufinuse;        
	uint64_t        skm_sl_bufmax;          

	TAILQ_ENTRY(skmem_cache) skm_link;      
	char            skm_name[64];           
	uuid_t          skm_uuid;               
	size_t          skm_bufsize;            
	size_t          skm_bufalign;           
	size_t          skm_objalign;           

	decl_lck_mtx_data(, skm_rs_lock);       
	struct thread    *skm_rs_owner;         
	uint32_t        skm_rs_busy;            
	uint32_t        skm_rs_want;            
	size_t          skm_cpu_cache_count;
	struct skmem_cpu_cache  skm_cpu_cache[__counted_by(skm_cpu_cache_count)]
	__attribute__((aligned(CHANNEL_CACHE_ALIGN_MAX)));
};
struct sksegment {
	TAILQ_ENTRY(sksegment)  sg_link;        
	RB_ENTRY(sksegment)     sg_node;        
	struct skmem_region     *sg_region;     

	IOSKMemoryBufferRef     sg_md;          
	mach_vm_address_t       sg_start;       
	mach_vm_address_t       sg_end;         

	uint32_t                sg_index;       
	sksegment_type_t        sg_type;        
	sksegment_state_t       sg_state;       
};
struct sksegment_bkt {
	TAILQ_HEAD(, sksegment) sgb_head;       
};
struct skmem_region_params {
	const char              *srp_name;      
	skmem_region_id_t       srp_id;         
	uint32_t                srp_cflags;     
	uint32_t                srp_r_seg_size; 
	uint32_t                srp_c_seg_size; 
	uint32_t                srp_seg_cnt;    

	uint32_t                srp_r_obj_size; 
	uint32_t                srp_r_obj_cnt;  
	uint32_t                srp_c_obj_size; 
	uint32_t                srp_c_obj_cnt;  
	size_t                  srp_align;      

	nexus_meta_type_t       srp_md_type;    
	nexus_meta_subtype_t    srp_md_subtype; 
	uint16_t                srp_max_frags;  
};
struct skmem_region {
	decl_lck_mtx_data(, skr_lock);          

	uint64_t                skr_meminuse;   
	uint64_t                skr_w_meminuse; 
	uint64_t                skr_memtotal;   
	uint64_t                skr_alloc;      
	uint64_t                skr_free;       
	uint32_t                skr_seginuse;   
	uint32_t                skr_rescale;    

	struct skmem_region_params skr_params;  
	TAILQ_ENTRY(skmem_region) skr_link;     
	char                    skr_name[64];   
	uuid_t                  skr_uuid;       
	uint32_t                skr_mode;       
	uint32_t                skr_size;       
	IOSKMemoryBufferSpec    skr_bufspec;    
	IOSKRegionSpec          skr_regspec;    
	IOSKRegionRef           skr_reg;        
	struct zone             *skr_zreg;      
	void                    *skr_private;   
	struct skmem_cache      *skr_cache[SKR_MAX_CACHES]; 


	sksegment_ctor_fn_t     skr_seg_ctor;   
	sksegment_dtor_fn_t     skr_seg_dtor;   
	uint32_t                skr_seg_objs;   
	uint32_t                skr_seg_bmap_len; 
	size_t                  skr_seg_bmap_size;
	bitmap_t                *__sized_by(skr_seg_bmap_size) skr_seg_bmap;  
	uint32_t                skr_seg_free_cnt; 
	uint32_t                skr_hash_initial; 
	uint32_t                skr_hash_limit; 
	uint32_t                skr_hash_shift; 
	uint32_t                skr_hash_mask;  
	size_t                  skr_hash_size;
	struct sksegment_bkt    *__counted_by(skr_hash_size) skr_hash_table; 
	TAILQ_HEAD(segfreehead, sksegment) skr_seg_free; 
	RB_HEAD(segtfreehead, sksegment) skr_seg_tfree; 
	uint32_t                skr_seg_waiters; 

	uint32_t                skr_refcnt;     

	struct skmem_region     *skr_mirror;
};
struct flowidns_flow_key {
	union {
		struct in_addr  _v4;
		struct in6_addr _v6;
	} ffk_laddr; 
	union {
		struct in_addr  _v4;
		struct in6_addr _v6;
	} ffk_raddr; 
	union {
		struct {
			uint16_t _lport; 
			uint16_t _rport; 
		} ffk_ports;
		uint32_t ffk_spi; 
		uint32_t ffk_protoid; 
	};
	uint8_t ffk_af; 
	uint8_t ffk_proto; 
};
struct ns_flow_info {
	uuid_t                  nfi_flow_uuid
	__attribute((aligned(sizeof(uint64_t))));

	struct ifnet            *nfi_ifp;       
	union sockaddr_in_4_6   nfi_laddr;      
	union sockaddr_in_4_6   nfi_faddr;      
	uint8_t                 nfi_protocol;   
	uint8_t                 nfi_pad[3];     
	pid_t                   nfi_owner_pid;
	pid_t                   nfi_effective_pid;
	char                    nfi_owner_name[MAXCOMLEN + 1];
	char                    nfi_effective_name[MAXCOMLEN + 1];
};
struct nexus_pkt_stats {
	uint64_t nps_pkts;
	uint64_t nps_bytes;
};
struct nexus_adapter {
	volatile uint32_t               na_flags;       
	nexus_adapter_type_t            na_type;        
	const nexus_meta_type_t         na_md_type;     
	const nexus_meta_subtype_t      na_md_subtype;  

	nexus_port_t na_nx_port;

	uint32_t na_channels;

	uint32_t na_num_rx_rings;
	uint32_t na_num_tx_rings;

	uint32_t na_num_allocator_ring_pairs;

	uint32_t na_num_event_rings;

	uint32_t na_num_large_buf_alloc_rings;

	uint32_t na_rx_rings_cnt;
	uint32_t na_tx_rings_cnt;
	uint32_t na_alloc_free_rings_cnt;
	uint32_t na_event_rings_cnt;
	uint32_t na_large_buf_alloc_rings_cnt;
	uint32_t na_slot_ctxs_cnt;
	uint32_t na_scratch_cnt;
	uint32_t na_all_rings_cnt;

	uint64_t na_work_ts;            

	struct __kern_channel_ring *__counted_by(na_tx_rings_cnt) na_tx_rings; 
	struct __kern_channel_ring *__counted_by(na_rx_rings_cnt) na_rx_rings; 
	struct __kern_channel_ring *__counted_by(na_all_rings_cnt) na_all_rings;

	struct kern_nexus *na_nx;

	volatile uint32_t na_refcount;

	int na_si_users[NR_ALL];         
	struct ch_selinfo na_si[NR_ALL]; 

	struct skmem_arena *na_arena;

	uint32_t na_num_tx_slots;
	uint32_t na_num_rx_slots;
	uint32_t na_num_allocator_slots;
	uint32_t na_num_event_slots;
	uint32_t na_num_large_buf_alloc_slots;

	uint32_t na_total_slots;

	const uint32_t na_flowadv_max;  

	const nexus_stats_type_t na_stats_type; 

	struct __kern_channel_ring *__counted_by(na_alloc_free_rings_cnt)na_alloc_rings;
	struct __kern_channel_ring *__counted_by(na_alloc_free_rings_cnt)na_free_rings;
	struct __kern_channel_ring *__counted_by(na_event_rings_cnt)na_event_rings;
	struct __kern_channel_ring *__counted_by(na_large_buf_alloc_rings_cnt)na_large_buf_alloc_rings;

	uint64_t na_ch_mit_ival;        

	struct kern_nexus_domain_provider *na_nxdom_prov;

	struct slot_ctx *__counted_by(na_slot_ctxs_cnt)na_slot_ctxs;

	kern_packet_t *__counted_by(na_scratch_cnt)na_scratch;

	struct __kern_channel_ring *__counted_by(0) na_tail; 



	char na_name[NEXUS_ADAPTER_NAMELEN];    
	uuid_t na_uuid;

	int (*na_activate)(struct nexus_adapter *, na_activate_mode_t);
	int (*na_special)(struct nexus_adapter *, struct kern_channel *,
	    struct chreq *, nxspec_cmd_t);
	int (*na_txsync)(struct __kern_channel_ring *kring, struct proc *,
	    uint32_t flags);
	int (*na_rxsync)(struct __kern_channel_ring *kring, struct proc *,
	    uint32_t flags);

	int (*na_notify)(struct __kern_channel_ring *kring, struct proc *,
	    uint32_t flags);

	int (*na_channel_event_notify)(struct nexus_adapter *,
	    struct __kern_channel_event *, uint16_t);
	int (*na_config)(struct nexus_adapter *,
	    uint32_t *txr, uint32_t *txd, uint32_t *rxr, uint32_t *rxd);
	int (*na_krings_create)(struct nexus_adapter *, struct kern_channel *);
	void (*na_krings_delete)(struct nexus_adapter *, struct kern_channel *,
	    boolean_t);
	void (*na_dtor)(struct nexus_adapter *);
	void (*na_free)(struct nexus_adapter *);

	void (*na_rx)(struct nexus_adapter *,
	    struct __kern_packet *, struct nexus_pkt_stats *);
};
struct nxctl_add_traffic_rule_inet_iocargs {
	char atri_ifname[IFNAMSIZ];
	struct ifnet_traffic_descriptor_inet atri_td;
	struct ifnet_traffic_rule_action_steer atri_ra;
	uint32_t atri_flags;
	uuid_t atri_uuid;
};
struct nxctl_remove_traffic_rule_iocargs {
	uuid_t rtr_uuid;
};
struct nxctl_traffic_rule_generic_iocinfo {
	uuid_t trg_uuid;
	char trg_procname[NTR_PROCNAME_SZ];
	char trg_ifname[IFNAMSIZ];
};
struct nxctl_traffic_rule_inet_iocinfo {
	struct nxctl_traffic_rule_generic_iocinfo tri_common;
	struct ifnet_traffic_descriptor_inet tri_td;
	struct ifnet_traffic_rule_action_steer tri_ra;
};
struct nxctl_get_traffic_rules_iocargs {
	uint8_t gtr_type;
	uint32_t gtr_size;
	uint32_t gtr_count;
	union {
		void *gtr_buf;
		uint64_t gtr_buf64;
	};
};
struct nx_mbq {
	decl_lck_mtx_data(, nx_mbq_lock);
	class_queue_t           nx_mbq_q;
	lck_grp_t               *nx_mbq_grp;
	struct __kern_channel_ring *nx_mbq_kring;
};
struct nx_pktq {
	decl_lck_mtx_data(, nx_pktq_lock);
	class_queue_t           nx_pktq_q;
	lck_grp_t               *nx_pktq_grp;
	struct __kern_channel_ring *nx_pktq_kring;
};
struct nxctl {
	decl_lck_mtx_data(, nxctl_lock);
	uint32_t                nxctl_refcnt;
	uint32_t                nxctl_flags;
	uuid_t                  nxctl_uuid;
	uuid_t                  nxctl_proc_uuid;
	uint64_t                nxctl_proc_uniqueid;
	STAILQ_ENTRY(nxctl)     nxctl_link;
	struct fileproc         *nxctl_fp;
	kauth_cred_t            nxctl_cred;
	struct nxctl_traffic_rule_storage *nxctl_traffic_rule_storage;
};
struct nxbind {
	uint32_t                nxb_flags;
	pid_t                   nxb_pid;
	uint64_t                nxb_uniqueid;
	uuid_t                  nxb_exec_uuid;
	uint32_t                nxb_key_len;
	void                    *__sized_by(nxb_key_len) nxb_key;
};
struct nx_port_info {
	uintptr_t               npi_nah;
	struct nxbind           *npi_nxb;
	void                    *npi_info;
};
struct nx_port_info_header {
	nx_port_info_type_t     ih_type;
	size_t                  ih_size;
};
struct kern_nexus_advisory {
	struct skmem_region     *nxv_reg;
	void                    *__sized_by(nxv_adv_size) nxv_adv;
	nexus_advisory_type_t   nxv_adv_type;
	union {
		struct sk_nexusadv             *flowswitch_nxv_adv;
		struct netif_nexus_advisory    *netif_nxv_adv;
	};
	uint32_t                nxv_adv_size;
};
struct kern_nexus {
	uint32_t                nx_refcnt;
	volatile uint32_t       nx_flags;
	void                    *nx_ctx;
	nexus_ctx_release_fn_t  nx_ctx_release;
	struct kern_nexus_provider *nx_prov;
	uint64_t                nx_id;
	uuid_t                  nx_uuid;
	STAILQ_ENTRY(kern_nexus) nx_prov_link;
	RB_ENTRY(kern_nexus)    nx_link;
	STAILQ_HEAD(, kern_channel) nx_ch_head;
	uint32_t                nx_ch_count;
	STAILQ_HEAD(, kern_channel) nx_ch_nonxref_head;
	decl_lck_rw_data(, nx_ch_if_adv_lock);
	STAILQ_HEAD(, kern_channel) nx_ch_if_adv_head;
	void                    *nx_arg;
	struct kern_pbufpool    *nx_rx_pp;
	struct kern_pbufpool    *nx_tx_pp;
	struct kern_nexus_advisory nx_adv;

	struct nx_port_info     *__counted_by(nx_num_ports) nx_ports;
	bitmap_t                *__sized_by(nx_ports_bmap_size) nx_ports_bmap;
	nexus_port_size_t       nx_active_ports;
	nexus_port_size_t       nx_num_ports;
	size_t                  nx_ports_bmap_size;
};
struct kern_nexus_provider {
	uint32_t                        nxprov_refcnt;
	uint32_t                        nxprov_flags;
	STAILQ_ENTRY(kern_nexus_provider) nxprov_link;
	STAILQ_HEAD(, kern_nexus)       nxprov_nx_head;
	uint32_t                        nxprov_nx_count;
	struct nxctl                    *nxprov_ctl;
	uuid_t                          nxprov_uuid;
	struct kern_nexus_domain_provider *nxprov_dom_prov;
	union {
		struct kern_nexus_provider_init nxprov_ext;
		struct kern_nexus_netif_provider_init nxprov_netif_ext;
	};
	struct nxprov_params            *nxprov_params;
	struct skmem_region_params      nxprov_region_params[SKMEM_REGIONS];
};
struct kern_nexus_domain_provider {
	STAILQ_ENTRY(kern_nexus_domain_provider) nxdom_prov_link;
	STAILQ_ENTRY(kern_nexus_domain_provider) nxdom_prov_detaching_link;
	char                    nxdom_prov_name[64];
	uuid_t                  nxdom_prov_uuid;
	uint64_t                nxdom_prov_gencnt;
	uint32_t                nxdom_prov_refcnt;
	uint32_t                nxdom_prov_flags;
	struct nxdom            *nxdom_prov_dom;
	struct kern_nexus_domain_provider_init nxdom_prov_ext;
	struct nxdom_prov_cb {
		int (*dp_cb_init)(struct kern_nexus_domain_provider *);
		void (*dp_cb_fini)(struct kern_nexus_domain_provider *);
		int (*dp_cb_params)(struct kern_nexus_domain_provider *,
		    const uint32_t, const struct nxprov_params *,
		    struct nxprov_params *,
		    struct skmem_region_params[SKMEM_REGIONS], uint32_t);
		int (*dp_cb_mem_new)(struct kern_nexus_domain_provider *,
		    struct kern_nexus *, struct nexus_adapter *);
		int (*dp_cb_config)(struct kern_nexus_domain_provider *,
		    struct kern_nexus *, struct nx_cfg_req *, int,
		    struct proc *, kauth_cred_t);
		int (*dp_cb_nx_ctor)(struct kern_nexus *);
		void (*dp_cb_nx_dtor)(struct kern_nexus *);
		int (*dp_cb_nx_mem_info)(struct kern_nexus *,
		    struct kern_pbufpool **, struct kern_pbufpool **);
		size_t (*dp_cb_nx_mib_get)(struct kern_nexus *,
		    struct nexus_mib_filter *, void *, size_t, struct proc *);
		int (*dp_cb_nx_stop)(struct kern_nexus *);
	} nxdom_prov_cb;
};
struct nxp_bounds {
	uint32_t        nb_def;
	uint32_t        nb_min;
	uint32_t        nb_max;
};
struct nxdom {
	STAILQ_ENTRY(nxdom) nxdom_link;
	STAILQ_HEAD(, kern_nexus_domain_provider) nxdom_prov_head;
	nexus_type_t    nxdom_type;
	nexus_meta_type_t nxdom_md_type;
	nexus_meta_subtype_t nxdom_md_subtype;
	uint32_t        nxdom_flags;
	struct nxp_bounds nxdom_ports;
	struct nxp_bounds nxdom_tx_rings;
	struct nxp_bounds nxdom_rx_rings;
	struct nxp_bounds nxdom_tx_slots;
	struct nxp_bounds nxdom_rx_slots;
	struct nxp_bounds nxdom_buf_size;
	struct nxp_bounds nxdom_large_buf_size;
	struct nxp_bounds nxdom_meta_size;
	struct nxp_bounds nxdom_stats_size;
	struct nxp_bounds nxdom_pipes;
	struct nxp_bounds nxdom_extensions;
	struct nxp_bounds nxdom_mhints;
	struct nxp_bounds nxdom_flowadv_max;
	struct nxp_bounds nxdom_nexusadv_size;
	struct nxp_bounds nxdom_capabilities;
	struct nxp_bounds nxdom_qmap;
	struct nxp_bounds nxdom_max_frags;
	struct skmem_region_params nxdom_region_params[SKMEM_REGIONS];
	const char      *nxdom_name;

	void (*nxdom_init)(struct nxdom *);             
	void (*nxdom_terminate)(struct nxdom *);        
	void (*nxdom_fini)(struct nxdom *);             
	int (*nxdom_find_port)                          
	(struct kern_nexus *, boolean_t, nexus_port_t *);
	boolean_t (*nxdom_port_is_reserved)             
	(struct kern_nexus *, nexus_port_t);
	int (*nxdom_bind_port)                          
	(struct kern_nexus *, nexus_port_t *, struct nxbind *, void *);
	int (*nxdom_unbind_port)                        
	(struct kern_nexus *, nexus_port_t);
	int (*nxdom_connect)                            
	(struct kern_nexus_domain_provider *, struct kern_nexus *,
	struct kern_channel *, struct chreq *, struct kern_channel *,
	struct nxbind *, struct proc *);
	void (*nxdom_disconnect)                        
	(struct kern_nexus_domain_provider *, struct kern_nexus *,
	struct kern_channel *);
	void (*nxdom_defunct)                           
	(struct kern_nexus_domain_provider *, struct kern_nexus *,
	struct kern_channel *, struct proc *);
	void (*nxdom_defunct_finalize)                  
	(struct kern_nexus_domain_provider *, struct kern_nexus *,
	struct kern_channel *, boolean_t);
};
struct nxprov_adjusted_params {
	nexus_meta_subtype_t *adj_md_subtype;
	uint32_t *adj_stats_size;
	uint32_t *adj_flowadv_max;
	uint32_t *adj_nexusadv_size;
	uint32_t *adj_caps;
	uint32_t *adj_tx_rings;
	uint32_t *adj_rx_rings;
	uint32_t *adj_tx_slots;
	uint32_t *adj_rx_slots;
	uint32_t *adj_alloc_rings;
	uint32_t *adj_free_rings;
	uint32_t *adj_alloc_slots;
	uint32_t *adj_free_slots;
	uint32_t *adj_buf_size;
	uint32_t *adj_buf_region_segment_size;
	uint32_t *adj_pp_region_config_flags;
	uint32_t *adj_max_frags;
	uint32_t *adj_event_rings;
	uint32_t *adj_event_slots;
	uint32_t *adj_max_buffers;
	uint32_t *adj_large_buf_size;
};
struct nexus_mdata {
	union {
		uuid_t          __uuid;         
		uint8_t         __val8[16];
		uint16_t        __val16[8];
		uint32_t        __val32[4];
		uint64_t        __val64[2];
	} __flowid_u;
} nexus_mdata_t __attribute((aligned(8)));
struct nxctl_init {
	uint32_t        ni_version;     
	uint32_t        __ni_align;     
	guardid_t       ni_guard;       
};
struct nxprov_params {
	nexus_name_t    nxp_name;       
	uint32_t        nxp_namelen;    
	nexus_type_t    nxp_type;       
	nexus_meta_type_t nxp_md_type;  
	nexus_meta_subtype_t nxp_md_subtype; 
	uint32_t        nxp_flags;      
	uint32_t        nxp_format;     
	uint32_t        nxp_tx_rings;   
	uint32_t        nxp_rx_rings;   
	uint32_t        nxp_tx_slots;   
	uint32_t        nxp_rx_slots;   
	uint32_t        nxp_buf_size;   
	uint32_t        nxp_meta_size;  
	uint32_t        nxp_stats_size; 
	uint32_t        nxp_pipes;      
	nexus_extension_t nxp_extensions;  
	uint32_t        nxp_mhints;        
	uint32_t        nxp_ifindex;       
	uint32_t        nxp_flowadv_max;   
	nexus_qmap_type_t nxp_qmap;        
	uint32_t        nxp_capabilities;  
	uint32_t        nxp_nexusadv_size; 
	uint32_t        nxp_max_frags;     
	boolean_t       nxp_reject_on_close;
	uint32_t        nxp_large_buf_size;   
} __attribute__((aligned(64)));
struct nxprov_reg {
	uint32_t        nxpreg_version;         
	uint32_t        nxpreg_requested;       
	struct nxprov_params nxpreg_params;     
};
struct nxprov_reg_ent {
	uuid_t          npre_prov_uuid;         
	struct nxprov_params npre_prov_params;  
};
struct nxprov_list_req {
	uint32_t                nrl_num_regs;   
	uint32_t                __nrl_align;    
	user_addr_t             nrl_regs;       
};
struct nx_list_req {
	uuid_t                  nl_prov_uuid;   
	uint32_t                nl_num_nx_uuids; 
	uint32_t                __nl_align;     
	user_addr_t             nl_nx_uuids;    
};
struct nx_bind_req {
	uuid_t                  nb_nx_uuid;     
	nexus_port_t            nb_port;        
	uint32_t                nb_flags;       
	uuid_t                  nb_exec_uuid;   
	user_addr_t             nb_key;         
	uint32_t                nb_key_len;     
	pid_t                   nb_pid;         
};
struct nx_unbind_req {
	uuid_t                  nu_nx_uuid;     
	nexus_port_t            nu_port;        
};
struct ch_list_req {
	uuid_t                  cl_nx_uuid;     
	uint32_t                cl_num_ch_uuids; 
	uint32_t                __cl_align;     
	user_addr_t             cl_ch_uuids;    
};
struct nexus_mib_filter {
	uint32_t                nmf_type;       
	uint64_t                nmf_bitmap;     

	uuid_t                  nmf_nx_uuid;    
	uuid_t                  nmf_flow_id;    
	pid_t                   nmf_pid;        
	struct info_tuple       nmf_info_tuple; 
};
struct nx_cfg_req {
	uuid_t                  nc_nx_uuid;     
	nxcfg_cmd_t             nc_cmd;         
	uint32_t                nc_req_len;     
	user_addr_t             nc_req;         
};
struct nx_spec_req {
	union {
		char            nsru_name[NX_SPEC_IF_NAMELEN];
		uuid_t          nsru_uuid;
		struct ifnet    *nsru_ifp;
	} nsr_u __attribute__((aligned(sizeof(uint64_t))));     
	uint32_t                nsr_flags;                      
	uuid_t                  nsr_if_uuid;    
};
struct flow_demux_pattern {
	uint16_t                fdp_offset;
	uint16_t                fdp_len;
	uint8_t                 fdp_mask[FLOW_DEMUX_MAX_LEN];
	uint8_t                 fdp_value[FLOW_DEMUX_MAX_LEN];
};
struct nx_flow_req {
	nexus_port_t                    nfr_nx_port;
	uint16_t                        nfr_ethertype;
	ether_addr_t                    nfr_etheraddr;
	union sockaddr_in_4_6           nfr_saddr;
	union sockaddr_in_4_6           nfr_daddr;
	uint8_t                         nfr_ip_protocol;
	uint8_t                         nfr_transport_protocol;
	uint16_t                        nfr_flags;
	uuid_t                          nfr_flow_uuid;
	packet_svc_class_t              nfr_svc_class;
	uuid_t                          nfr_euuid;
	uint32_t                        nfr_policy_id;
	uint32_t                        nfr_skip_policy_id;
	pid_t                           nfr_epid;
	flowadv_idx_t                   nfr_flowadv_idx;
	uuid_t                          nfr_bind_key;
	uint64_t                        nfr_qset_id;
	uuid_t                          nfr_parent_flow_uuid;
	uint8_t                         nfr_flow_demux_count;
	struct flow_demux_pattern       nfr_flow_demux_patterns[MAX_FLOW_DEMUX_PATTERN];
	union {
		struct {
			char                    _nfr_kernel_field_start[0];
			void                    *nfr_context;
			struct proc             *nfr_proc;
			struct ifnet            *nfr_ifp;
			struct flow_route       *nfr_route;
			struct ns_token         *nfr_port_reservation;
			struct protons_token    *nfr_proto_reservation;
			struct flow_stats       *nfr_flow_stats;
			pid_t                   nfr_pid;
			uint32_t                nfr_saddr_gencnt;
			void                    *nfr_ipsec_reservation;
			uint32_t                nfr_inp_flowhash;
			uint8_t                 _nfr_kernel_pad[4];
			char                    _nfr_kernel_field_end[0];
		};
		struct {
			uint8_t                 _nfr_opaque[80];
			
			char                    _nfr_common_field_end[0];
		};
	};
};
struct flow_ip_addr {
	union {
		struct in_addr  _v4;
		struct in6_addr _v6;
		uint8_t         _addr8[16];
		uint16_t        _addr16[8];
		uint32_t        _addr32[4];
		uint64_t        _addr64[2];
	};
};
struct flow_key {
	uint16_t                fk_mask;
	uint8_t                 fk_ipver;
	uint8_t                 fk_proto;
	uint16_t                fk_sport;
	uint16_t                fk_dport;
	struct flow_ip_addr     fk_src;
	struct flow_ip_addr     fk_dst;
	uint64_t                fk_pad[1];      
} __attribute__((__aligned__(16)));
struct nx_qset_info {
	uint64_t        nqi_id;
	uint16_t        nqi_flags;
	uint8_t         nqi_num_rx_queues;
	uint8_t         nqi_num_tx_queues;
};
struct nx_llink_info {
	uuid_t          nli_netif_uuid;            
	uint64_t        nli_link_id;
	uint16_t        nli_link_id_internal;
	uint8_t         nli_state;
	uint8_t         nli_flags;
	uint16_t        nli_qset_cnt;
	struct nx_qset_info nli_qset[NETIF_LLINK_MAX_QSETS];
};
struct nx_llink_info_req {
	uint16_t        nlir_version;
	uint16_t        nlir_llink_cnt;
	struct nx_llink_info nlir_llink[__counted_by(nlir_llink_cnt)];
};
struct nexus_controller {
};
struct nexus_attr {
	uint64_t        nxa_requested;  
	uint64_t        nxa_tx_rings;   
	uint64_t        nxa_rx_rings;   
	uint64_t        nxa_tx_slots;   
	uint64_t        nxa_rx_slots;   
	uint64_t        nxa_buf_size;   
	uint64_t        nxa_meta_size;  
	uint64_t        nxa_stats_size; 
	uint64_t        nxa_anonymous;  
	uint64_t        nxa_pipes;      
	uint64_t        nxa_extensions; 
	uint64_t        nxa_mhints;     
	uint64_t        nxa_ifindex;    
	uint64_t        nxa_flowadv_max; 
	uint64_t        nxa_qmap;       
	uint64_t        nxa_checksum_offload;   
	uint64_t        nxa_user_packet_pool;   
	uint64_t        nxa_nexusadv_size;      
	uint64_t        nxa_user_channel;       
	uint64_t        nxa_max_frags;  
	uint64_t        nxa_reject_on_close;
	uint64_t        nxa_large_buf_size;  
};
struct packet_id {
	uint8_t     pktid_version;
	uint8_t     pktid_payload_type;
	uint16_t    pktid_sequence_number;
	uint32_t    pktid_timestamp;
	uint32_t    pktid_stream_identifier;
	uint32_t    _reserved;
} packet_id_t;
struct __flow {
	union {
		
		struct __flow_init {
			
			struct __flow_l3 {
				union {
					struct __flow_l3_ipv4_addrs {
						struct in_addr _src;
						struct in_addr _dst;
					} _l3_ipv4;
					struct __flow_l3_ipv6_addrs {
						struct in6_addr _src;
						struct in6_addr _dst;
					} _l3_ipv6;
				};
				uint8_t  _l3_ip_ver;
				uint8_t  _l3_proto;
				uint8_t  _l3_hlen;
				unsigned _l3_is_frag : 1;
				unsigned _l3_is_first_frag : 1;
				unsigned _l3_reserved_flags : 6;
				uint32_t _l3_frag_id;
				mach_vm_address_t _l3_ptr;
			} __l3;
			
			struct __flow_classq {
				uint32_t _fcq_hash;  
				uint32_t _fcq_flags; 
			} __classq;
			
			uint32_t __ulen;      
			uint8_t  __ulp_encap; 
			uint8_t  __pad[3];
			uint64_t __pad64[2];
			
			struct __flow_source {
				union {
					
					uint64_t _fsrc_id_64[2];
					uint32_t _fsrc_id_32[4];
					uuid_t   _fsrc_id;
				} __attribute__((aligned(sizeof(uint64_t))));
				flowadv_idx_t _fsrc_fidx; 
				uint8_t       _fsrc_type; 
				uint8_t       _fsrc_pad[3];
			} __source;
			
			struct __flow_policy {
				uint32_t _fpc_id; 
				uint32_t _fpc_skip_id; 
				union {
					
					uint64_t _fpc_euuid_64[2];
					uint32_t _fpc_euuid_32[4];
					uuid_t   _fpc_euuid;
				} __attribute__((aligned(sizeof(uint64_t))));
			} __policy;
		} flow_init;
		uint64_t flow_init_data[16];
	} __attribute((aligned(16)));





	union {
		struct __flow_l4 {
			union {
				struct __flow_l4_tcp {
					in_port_t _src;
					in_port_t _dst;
					uint32_t _seq;
					uint32_t _ack;
					union {
						struct {
							uint8_t _tcp_res:4;
							uint8_t _off:4;
							uint8_t _flags;
							uint16_t _win;
						};
						uint32_t _ofw;
					};
				} _l4_tcp;
				struct __flow_l4_udp {
					in_port_t _src;
					in_port_t _dst;
					uint32_t _ls;
				} _l4_udp;
				struct __flow_l4_esp {
					uint32_t _spi;
				} _l4_esp;
			};
			uint8_t _l4_hlen;
			uint8_t _l4_agg_fast;
			uint8_t _l4_pad[6];
			mach_vm_address_t _l4_ptr;
		} flow_l4;
		uint64_t flow_l4_data[4];
	} __attribute((aligned(sizeof(uint64_t))));
} __attribute((aligned(16)));
struct __buflet {
	union {
		
		uint64_t __buflet_next;
		
		const mach_vm_address_t __nbft_addr;
	};
	const mach_vm_address_t __baddr;
	const obj_idx_t __bft_idx;
	const obj_idx_t __bidx;
	const obj_idx_t __nbft_idx;
	const uint32_t  __dlim;         
	uint32_t        __doff;         
	uint32_t        __dlen;         
	const uint16_t  __flag;
} __attribute((packed));
struct __user_buflet {
	struct __buflet buf_com;
};
struct __metadata_preamble {
	union {
		uint64_t        _mdp_next;      
		uint64_t        mdp_redzone;    
	};
	const obj_idx_t         mdp_idx;        
	uint16_t                mdp_type;       
	uint16_t                mdp_subtype;    
};
struct __quantum {
	union {
		uuid_t          __uuid;         
		uint8_t         __val8[16];
		uint16_t        __val16[8];
		uint32_t        __val32[4];
		uint64_t        __val64[2];
	} __flow_id_u;

	uint32_t                __q_len;

	uint32_t                __q_svc_class;  

	volatile uint16_t       __q_flags;      
	uint16_t                __q_pad[3];
} __attribute((aligned(sizeof(uint64_t))));
struct __user_quantum {
	struct __quantum qum_com;

	struct __user_buflet    qum_buf[1];             
	uint16_t qum_usecnt;
} __attribute((aligned(sizeof(uint64_t))));
struct __packet_com {
	uint16_t __link_flags;                          

	uint8_t __headroom;
	uint8_t __l2_len;

	uint32_t __csum_flags;                          
	union {
		struct {
			uint16_t __csum_start_off;      
			uint16_t __csum_value;          
		} __csum_rx;
		struct {
			uint16_t __csum_start_off;      
			uint16_t __csum_stuff_off;      
		} __csum_tx;
		uint32_t __csum_data;
	};

	uint32_t __comp_gencnt;

	packet_trace_id_t __trace_id;

	uint8_t __aggr_type;                     
	uint8_t __seg_cnt;                       

	uint16_t __proto_seg_sz;                 

	union {
		volatile uint32_t __flags32[2];
		volatile uint64_t __flags;              
	};
} __attribute((aligned(sizeof(uint64_t))));
struct __packet {
	union {
		uint64_t                __pkt_data[4];
		struct __packet_com     __pkt_com;
	};
};
struct __packet_opt_com {
	union {
		uint64_t        __token_data[2];
		uint8_t         __token[PKT_OPT_MAX_TOKEN_SIZE];
	};
	uint64_t        __expire_ts;
	uint64_t        __pkt_tx_time;
	uint16_t        __vlan_tag;
	uint16_t        __token_len;
	uint8_t         __token_type;
	uint8_t         __expiry_action;
	uint8_t         __app_type;
	uint8_t         __app_metadata;
} __attribute((aligned(sizeof(uint64_t))));
struct __packet_opt {
	union {
		uint64_t                __pkt_opt_data[5];
		struct __packet_opt_com __pkt_opt_com;
	};
};
struct __user_packet {
	struct __user_quantum   pkt_qum;



	struct __packet pkt_com;

	struct __packet_opt pkt_com_opt;


	const uint16_t  pkt_bufs_max;       
	const uint16_t  pkt_bufs_cnt;       
} __attribute((aligned(sizeof(uint64_t))));
struct __kern_buflet {
	struct __buflet buf_com;
	const struct skmem_bufctl *buf_ctl;

} __attribute((packed));
struct __kern_buflet_ext {
	struct __kern_buflet kbe_overlay;
	struct __user_buflet const *kbe_buf_user;

	SLIST_ENTRY(__kern_buflet_ext) kbe_buf_upp_link;

	pid_t kbe_buf_pid;
} __attribute((packed));
struct __kern_quantum {
	struct __quantum qum_com;

	SLIST_ENTRY(__kern_quantum)     qum_upp_link;
	const struct kern_pbufpool      *qum_pp;
	const struct __user_quantum     *qum_user;
	const struct __kern_slot_desc   *qum_ksd;
	struct __kern_buflet            qum_buf[1];     
	pid_t                           qum_pid;
} __attribute((aligned(sizeof(uint64_t))));
struct __packet_compl {
	union {
		uint64_t        compl_data64[3];
		struct {
			uintptr_t       _cb_arg;
			uintptr_t       _cb_data;
			uint32_t        _tx_status;
			uint32_t        _pad;
		} compl_data;
	};
	uint8_t        compl_callbacks;
	uint32_t        compl_context;
};
struct __kern_packet {
	struct __kern_quantum   pkt_qum;

	struct __packet         pkt_com;

	struct __packet_opt     *pkt_com_opt;

	uint64_t                pkt_timestamp;

	struct __kern_packet    *pkt_nextpkt;

	union {
		struct mbuf             *pkt_mbuf;
		struct __kern_packet    *pkt_pkt;
	};
	struct __flow           *pkt_flow;       

	struct __packet_compl   *pkt_tx_compl;   

	void *      pkt_priv;   


	const uint16_t  pkt_bufs_max;       
	const uint16_t  pkt_bufs_cnt;       
	uint32_t        pkt_chain_count;    
	uint32_t        pkt_chain_bytes;    

	nexus_port_t    pkt_nx_port;        
	uint16_t        pkt_vpna_gencnt;

	packet_trace_tag_t       pkt_trace_tag;
	uint8_t                  pkt_qset_idx;
	uint8_t                  _pad[1];
} __attribute((aligned(sizeof(uint64_t))));
struct kern_pbufpool_u_bkt {
	SLIST_HEAD(, __kern_quantum) upp_head;
};
struct kern_pbufpool_u_bft_bkt {
	SLIST_HEAD(, __kern_buflet_ext) upp_head;
};
struct kern_pbufpool {
	decl_lck_mtx_data(, pp_lock);
	uint32_t                pp_refcnt;
	uint32_t                pp_flags;
	uint32_t                pp_buf_obj_size[PBUFPOOL_MAX_BUF_REGIONS];
	uint32_t                pp_buf_size[PBUFPOOL_MAX_BUF_REGIONS];
	uint16_t                pp_max_frags;

	struct skmem_cache      *pp_buf_cache[PBUFPOOL_MAX_BUF_REGIONS];
	struct skmem_cache      *pp_kmd_cache;
	struct skmem_cache      *pp_kbft_cache[PBUFPOOL_MAX_BUF_REGIONS];

	struct skmem_region     *pp_buf_region[PBUFPOOL_MAX_BUF_REGIONS];
	struct skmem_region     *pp_kmd_region;
	struct skmem_region     *pp_umd_region;
	struct skmem_region     *pp_ubft_region;
	struct skmem_region     *pp_kbft_region;

	struct kern_pbufpool_u_bkt *__counted_by(pp_u_hash_table_size) pp_u_hash_table;
	uint64_t                pp_u_bufinuse;

	struct kern_pbufpool_u_bft_bkt *__counted_by(pp_u_bft_hash_table_size) pp_u_bft_hash_table;
	uint64_t                pp_u_bftinuse;

	void                    *pp_ctx;
	pbuf_ctx_retain_fn_t    pp_ctx_retain;
	pbuf_ctx_release_fn_t   pp_ctx_release;
	nexus_meta_type_t       pp_md_type;
	nexus_meta_subtype_t    pp_md_subtype;
	uint32_t                pp_midx_start;
	uint32_t                pp_bidx_start;
	pbufpool_name_t         pp_name;
	pbuf_seg_ctor_fn_t      pp_pbuf_seg_ctor;
	pbuf_seg_dtor_fn_t      pp_pbuf_seg_dtor;

	uint32_t                pp_u_hash_table_size;
	uint32_t                pp_u_bft_hash_table_size;
};
struct flow_owner_bucket {
	decl_lck_mtx_data(, fob_lock);
	struct flow_owner_tree  fob_owner_head;
	uint16_t                fob_busy_flags;
	uint16_t                fob_open_waiters;
	uint16_t                fob_close_waiters;
	uint16_t                fob_dtor_waiters;
	const size_t            fob_idx;
};
struct flow_owner {
	RB_ENTRY(flow_owner)    fo_link;
	struct flow_entry_id_tree fo_flow_entry_id_head;
	const struct flow_owner_bucket *fo_bucket;
	void                    *fo_context;
	pid_t                   fo_pid;
	bool                    fo_nx_port_pid_bound;
	bool                    fo_nx_port_destroyed;
	bool                    fo_low_latency;
	nexus_port_t            fo_nx_port;
	uuid_t                  fo_key;

	struct nexus_adapter *  const fo_nx_port_na;
	struct nx_flowswitch *  const fo_fsw;

	bitmap_t                *__counted_by(fo_num_flowadv_bmaps)fo_flowadv_bmap;
	uint32_t                fo_flowadv_max;
	uint32_t                fo_num_flowadv;
	uint32_t                fo_num_flowadv_bmaps;

	char                    fo_name[FLOW_PROCESS_NAME_LENGTH];
};
struct flow_track_rtt {
	uint64_t        frtt_timestamp; 
	uint64_t        frtt_last;      
	uint32_t        frtt_seg_begin; 
	uint32_t        frtt_seg_end;   
	uint32_t        frtt_usec;      
};
struct flow_track {
	uint32_t fse_seqlo;     
	uint32_t fse_seqhi;     
	uint32_t fse_seqlast;   
	uint16_t fse_max_win;   
	uint16_t fse_mss;       
	uint8_t fse_state;      
	uint8_t fse_wscale;     
	uint16_t fse_flags;     
	uint32_t fse_syn_ts;    
	uint32_t fse_syn_cnt;   

	struct flow_track_rtt   fse_rtt;        
} __sk_aligned(8);
struct flow_llhdr {
	uint32_t                flh_gencnt;     

	const uint8_t           flh_off;
	const uint8_t           flh_len;
	uint16_t                flh_pad;        

	union _flh_u {
		uint64_t        _buf[2];
		struct {
			uint16_t _eth_pad;
			struct ether_header _eth;
		} _eth_padded;
	}  __sk_aligned(8)      _flh;
};
struct kern_flow_demux_pattern {
	struct flow_demux_pattern  fdp_demux_pattern;
	flow_demux_memcmp_mask_t   fdp_memcmp_mask;
};
struct flow_entry {
	os_refcnt_t             fe_refcnt;
	struct flow_key         fe_key;
	uint32_t                fe_flags;
	uint32_t                fe_key_hash;
	struct cuckoo_node      fe_cnode;

	uuid_t                  fe_uuid __sk_aligned(8);
	nexus_port_t            fe_nx_port;
	uint32_t                fe_laddr_gencnt;
	uint32_t                fe_want_nonviable;
	uint32_t                fe_want_withdraw;
	uint8_t                 fe_transport_protocol;

	uint16_t                fe_rx_frag_count;
	uint32_t                fe_rx_pktq_bytes;
	decl_lck_mtx_data(, fe_rx_pktq_lock);
	struct pktq             fe_rx_pktq;
	TAILQ_ENTRY(flow_entry) fe_rx_link;
	flow_rx_action_t        fe_rx_process;
	uint64_t                fe_rx_worker_tid;

	uint32_t                fe_rx_largest_size;

	bool                    fe_tx_is_cont_frag;
	uint32_t                fe_tx_frag_id;
	struct pktq             fe_tx_pktq;
	TAILQ_ENTRY(flow_entry) fe_tx_link;
	flow_tx_action_t        fe_tx_process;

	uuid_t                  fe_eproc_uuid __sk_aligned(8);
	flowadv_idx_t           fe_adv_idx;
	kern_packet_svc_class_t fe_svc_class;
	uint32_t                fe_policy_id;   
	uint32_t                fe_skip_policy_id; 

	struct nx_flowswitch *  const fe_fsw;
	struct ns_token         *fe_port_reservation;
	struct protons_token    *fe_proto_reservation;
	void                    *fe_ipsec_reservation;

	struct flow_track       fe_ltrack;      
	struct flow_track       fe_rtrack;      

	struct flow_stats       *fe_stats;
	struct flow_route       *fe_route;

	RB_ENTRY(flow_entry)    fe_id_link;

	TAILQ_ENTRY(flow_entry) fe_linger_link;
	uint64_t                fe_linger_expire; 
	uint32_t                fe_linger_wait;   

	pid_t                   fe_pid;
	pid_t                   fe_epid;
	char                    fe_proc_name[FLOW_PROCESS_NAME_LENGTH];
	char                    fe_eproc_name[FLOW_PROCESS_NAME_LENGTH];

	uint32_t                fe_flowid; 

	struct netif_qset      *fe_qset;
	uint64_t                fe_qset_id;
	flow_qset_select_t      fe_qset_select;
	uint32_t                fe_tr_genid;

	decl_lck_rw_data(, fe_child_list_lock);
	struct flow_entry_list          fe_child_list;
	TAILQ_ENTRY(flow_entry)         fe_child_link;
	uint8_t                         fe_demux_pattern_count;
	struct kern_flow_demux_pattern  *__counted_by(fe_demux_pattern_count)fe_demux_patterns;
	uint8_t                         *__sized_by_or_null(FLOW_DEMUX_MAX_LEN) fe_demux_pkt_data;
};
struct flow_entry_dead {
	LIST_ENTRY(flow_entry_dead)     fed_link;

	boolean_t               fed_want_nonviable;
	boolean_t               fed_want_clonotify;

	union {
		uint64_t        fed_uuid_64[2];
		uint32_t        fed_uuid_32[4];
		uuid_t          fed_uuid;
	} __sk_aligned(8);
};
struct flow_route {
	RB_ENTRY(flow_route)    fr_link;
	RB_ENTRY(flow_route)    fr_id_link;

	union sockaddr_in_4_6   fr_laddr;       
	union sockaddr_in_4_6   fr_faddr;       
	union sockaddr_in_4_6   fr_gaddr;       

	struct flow_llhdr       fr_llhdr;

	void                    *fr_addr_key;

	uuid_t                  fr_uuid __sk_aligned(8);

	decl_lck_spin_data(, fr_reflock);
	uint64_t                fr_expire;
	volatile uint32_t       fr_usecnt;

	uint32_t                fr_flags;
	uint32_t                fr_laddr_gencnt; 
	uint32_t                fr_addr_len;     

	volatile uint32_t       fr_want_configure;
	volatile uint32_t       fr_want_probe;

	decl_lck_mtx_data(, fr_lock);

	eventhandler_tag        fr_rt_evhdlr_tag;
	struct rtentry          *fr_rt_dst;
	struct rtentry          *fr_rt_gw;

	uuid_t                  fr_nx_uuid __sk_aligned(8);

	const struct flow_mgr   *fr_mgr;
	const struct flow_route_bucket  *fr_frb;
	const struct flow_route_id_bucket *fr_frib;
};
struct flow_route_bucket {
	decl_lck_rw_data(, frb_lock);
	struct flow_route_tree  frb_head;
	const uint32_t          frb_idx;
};
struct flow_route_id_bucket {
	decl_lck_rw_data(, frib_lock);
	struct flow_route_id_tree       frib_head;
	const uint32_t                  frib_idx;
};
struct flow_mgr {
	char            fm_name[IFNAMSIZ];
	uuid_t          fm_uuid;
	RB_ENTRY(flow_mgr) fm_link;

	struct cuckoo_hashtable *fm_flow_table;
	size_t   fm_flow_hash_count[FKMASK_IDX_MAX]; 
	uint16_t fm_flow_hash_masks[FKMASK_IDX_MAX];

	void      *__sized_by(fm_owner_bucket_tot_sz) fm_owner_buckets;     
	size_t    fm_owner_buckets_cnt;  
	size_t    fm_owner_bucket_sz;    
	size_t    fm_owner_bucket_tot_sz; 

	void      *__sized_by(fm_route_bucket_tot_sz) fm_route_buckets;     
	size_t    fm_route_buckets_cnt;  
	size_t    fm_route_bucket_sz;    
	size_t    fm_route_bucket_tot_sz; 

	void      *__sized_by(fm_route_id_bucket_tot_sz) fm_route_id_buckets;    
	size_t    fm_route_id_buckets_cnt; 
	size_t    fm_route_id_bucket_sz;   
	size_t    fm_route_id_bucket_tot_sz; 
};
struct mac_audit_record {
	int type;               
	int length;             
	u_char *data;           
	LIST_ENTRY(mac_audit_record) records;
};
struct  au_malloc_type {
	SInt64           mt_size;
	SInt64           mt_maxsize;
	SInt32           mt_inuse;
	SInt32           mt_maxused;
	unsigned         mt_type;
	unsigned         mt_magic;
	const char      *mt_shortdesc;
	const char      *mt_lastcaller;
};
struct cv {
	const char      *cv_description;
	int              cv_waiters;
};
struct mtx {
	lck_mtx_t       *mtx_lock;
};
struct rwlock {
	lck_rw_t        *rw_lock;
};
struct slck {
	lck_mtx_t       *sl_mtx;
	int              sl_locked;
	int              sl_waiting;
};
struct rlck {
	lck_mtx_t       *rl_mtx;
	uint32_t         rl_recurse;
	thread_t         rl_thread;
};
struct auditpipe_ioctl_preselect {
	au_id_t         aip_auid;
	au_mask_t       aip_mask;
};
struct vnode_au_info {
	mode_t  vn_mode;
	uid_t   vn_uid;
	gid_t   vn_gid;
	dev_t   vn_dev;
	long    vn_fsid;
	long    vn_fileid;
	long    vn_gen;
};
struct groupset {
	gid_t   gidset[NGROUPS];
	u_int   gidset_size;
};
struct socket_au_info {
	int                     sai_domain;
	int                     sai_type;
	int                     sai_protocol;

	struct sockaddr_storage sai_faddr;

	struct sockaddr_storage sai_laddr;
};
struct  au_qctrl64 {
	u_int64_t               aq64_hiwater;
	u_int64_t               aq64_lowater;
	u_int64_t               aq64_bufsz;
	u_int64_t               aq64_delay;
	int64_t                 aq64_minfree;
};
struct posix_ipc_perm {
	uid_t   pipc_uid;
	gid_t   pipc_gid;
	mode_t  pipc_mode;
};
struct au_identity_info {
	u_int32_t       signer_type;
	char            *signing_id;
	u_char          signing_id_trunc;
	char            *team_id;
	u_char          team_id_trunc;
	u_int8_t        *cdhash;
	u_int16_t       cdhash_len;
};
struct audit_record {
	u_int32_t               ar_magic;
	int                     ar_event;
	int                     ar_retval; 
	int                     ar_errno;  
	struct timespec         ar_starttime;
	struct timespec         ar_endtime;
	u_int64_t               ar_valid_arg;  

	struct xucred           ar_subj_cred;
	uid_t                   ar_subj_ruid;
	gid_t                   ar_subj_rgid;
	gid_t                   ar_subj_egid;
	uid_t                   ar_subj_auid; 
	pid_t                   ar_subj_asid; 
	pid_t                   ar_subj_pid;
	struct au_tid           ar_subj_term;
	struct au_tid_addr      ar_subj_term_addr;
	struct au_mask          ar_subj_amask;

	uid_t                   ar_arg_euid;
	uid_t                   ar_arg_ruid;
	uid_t                   ar_arg_suid;
	gid_t                   ar_arg_egid;
	gid_t                   ar_arg_rgid;
	gid_t                   ar_arg_sgid;
	pid_t                   ar_arg_pid;
	pid_t                   ar_arg_asid;
	struct au_tid           ar_arg_termid;
	struct au_tid_addr      ar_arg_termid_addr;
	uid_t                   ar_arg_uid;
	uid_t                   ar_arg_auid;
	gid_t                   ar_arg_gid;
	struct groupset         ar_arg_groups;
	int                     ar_arg_fd;
	int                     ar_arg_fflags;
	mode_t                  ar_arg_mode;
	uint32_t                ar_arg_value32;
	uint64_t                ar_arg_value64;
	user_addr_t             ar_arg_addr;
	user_size_t             ar_arg_len;
	int                     ar_arg_mask;
	u_int                   ar_arg_signum;
	char                    ar_arg_login[MAXLOGNAME];
	int                     ar_arg_ctlname[CTL_MAXNAME];
	struct socket_au_info   ar_arg_sockinfo;
	char                    *ar_arg_upath1;
	char                    *ar_arg_upath2;
	char                    *ar_arg_kpath1;         
	char                    *ar_arg_kpath2;         
	char                    *ar_vnode1_mac_labels;
	char                    *ar_vnode2_mac_labels;
	char                    *ar_cred_mac_labels;
	char                    *ar_arg_mac_string;
	char                    *ar_arg_text;
	void                    *ar_arg_opaque;         
	void                    *ar_arg_data;           
	u_int16_t               ar_arg_opq_size;        
	u_char                  ar_arg_data_type;       
	u_char                  ar_arg_data_count;      
	struct au_mask          ar_arg_amask;
	struct vnode_au_info    ar_arg_vnode1;
	struct vnode_au_info    ar_arg_vnode2;
	int                     ar_arg_cmd;
	int                     ar_arg_svipc_cmd;
	struct ipc_perm         ar_arg_svipc_perm;
	int                     ar_arg_svipc_id;
	user_addr_t             ar_arg_svipc_addr;
	struct posix_ipc_perm   ar_arg_pipc_perm;
	mach_port_name_t        ar_arg_mach_port1;      
	mach_port_name_t        ar_arg_mach_port2;      
	union auditon_udata     ar_arg_auditon;
	char                    *ar_arg_argv;
	int                     ar_arg_argc;
	char                    *ar_arg_envv;
	int                     ar_arg_envc;
	int                     ar_arg_exitstatus;
	int                     ar_arg_exitretval;
	struct sockaddr_storage ar_arg_sockaddr;
	int                     ar_arg_fd2;

	LIST_HEAD(mac_audit_record_list_t, mac_audit_record)    * ar_mac_records;
	int                     ar_forced_by_mac;
	struct au_identity_info ar_arg_identity;
};
struct kaudit_record {
	struct audit_record              k_ar;
	u_int32_t                        k_ar_commit;
	void                            *k_udata;       
	u_int                            k_ulen;        
	struct uthread                  *k_uthread;     
	TAILQ_ENTRY(kaudit_record)       k_q;
};
struct lucid_key {
	uint32_t etype;
	struct {
		uint32_t key_len;
		uint8_t *key_val;
	} key;
};
struct key_data_1964 {
	uint32_t sign_alg;
	uint32_t seal_alg;
};
struct key_data_4121 {
	uint32_t acceptor_subkey;
};
struct lucid_protocol {
	uint32_t proto;
	union {
		key_data_1964 data_1964;
		key_data_4121 data_4121;
	} lucid_protocol_u;
};
struct lucid_context {
	uint32_t vers;
	uint32_t initiate;
	uint32_t endtime;
	uint64_t send_seq;
	uint64_t recv_seq;
	lucid_protocol key_data;
	lucid_key ctx_key;
};
struct lucid_context_version {
	uint32_t        version;
} *lucid_context_version_t;
struct krb5_key {
	void   *key_val;
	size_t key_len;
} krb5_key_t;
struct key_schedule {
	cccbc_ctx *enc;
	cccbc_ctx *dec;
	krb5_key_t ikeys[2];  
};
struct crypto_ctx {
	uint32_t etype;
	uint32_t flags;
	size_t mpad;             
	lck_mtx_t lock;
	lucid_context_t gss_ctx;  
	void *key;   
	const struct ccdigest_info *di;
	const struct ccmode_cbc *enc_mode;
	const struct ccmode_cbc *dec_mode;
	struct key_schedule ks;
	uint32_t digest_size;
	uint32_t keylen;
	krb5_key_t ckeys[2];  
} *crypto_ctx_t;
struct gss_ctx_id_desc {
	lucid_context  gss_lucid_ctx;
	struct crypto_ctx  gss_cryptor;
} *gss_ctx_id_t;
struct gss_buffer_desc_struct {
	size_t length;
	void *value;
} gss_buffer_desc, *gss_buffer_t;
struct hmac_ctx_struct {
	size_t keylen;
	uint8_t *key;
	ccdigest_ctx_t di_ctx;
} hmac_ctx, hmac_ctx_t[1];
struct classq_pkt {
	union {
		struct mbuf             *cp_mbuf;       
	};
	classq_pkt_type_t       cp_ptype;
} classq_pkt_t;
struct pktcntr {
	u_int64_t       packets;
	u_int64_t       bytes;
};
struct _class_queue_ {
	union {
		MBUFQ_HEAD(mq_head) __mbufq; 
	} __pktq_u;
	u_int32_t       qlen;   
	u_int32_t       qlim;   
	u_int64_t       qsize;  
	classq_type_t   qtype;  
	classq_state_t  qstate; 
	classq_pkt_type_t       qptype; 
} class_queue_t;
struct blue_stats {
	int32_t                 q_pmark;
	u_int32_t               _pad;
	u_int64_t               drop_forced;
	u_int64_t               drop_unforced;
	u_int64_t               marked_packets;
};
struct flowq {
#pragma pack(push,1)
	union {
		MBUFQ_HEAD(mbufq_head) __mbufq; 
	} __fq_pktq_u;
#pragma pack(pop)
	uint32_t       fq_flowhash;    
	uint32_t       fq_bytes;       
	int32_t        fq_deficit;     
	fq_if_group_t  *fq_group;          
	uint8_t        fq_flags;       
	uint8_t        fq_sc_index; 
	bool           fq_in_dqlist;
	fq_tfc_type_t  fq_tfc_type;
	uint8_t        __fq_pad_uint8[4];
	uint64_t       fq_min_qdelay; 
	uint64_t       fq_getqtime;    
	uint32_t       fq_pkts_since_last_report;
	uint64_t       fq_next_tx_time;
	union {
		uint64_t   fq_updatetime; 
		
		uint64_t   fq_empty_purge_time;
	};
	LIST_ENTRY(flowq) fq_hashlink; 
	union {
		STAILQ_ENTRY(flowq) fq_actlink; 
		
		TAILQ_ENTRY(flowq) fq_empty_link;
	};
	STAILQ_ENTRY(flowq) fq_dqlink;
	classq_pkt_t   fq_dq_head;
	classq_pkt_t   fq_dq_tail;
};
struct redparams {
	int th_min;             
	int th_max;             
	int inv_pmax;           
};
struct red_stats {
	int32_t         q_avg;
	u_int32_t       _pad;
	u_int32_t       drop_forced;
	u_int32_t       drop_unforced;
	u_int32_t       marked_packets;
};
struct sfbstats {
	u_int64_t               drop_early;
	u_int64_t               drop_pbox;
	u_int64_t               drop_queue;
	u_int64_t               marked_packets;
	u_int64_t               pbox_packets;
	u_int64_t               pbox_time;
	u_int64_t               hold_time;
	u_int64_t               dequeue_avg;
	u_int64_t               rehash_intval;
	u_int64_t               num_rehash;
	u_int64_t               null_flowid;
	u_int64_t               flow_controlled;
	u_int64_t               flow_feedback;
	u_int64_t               dequeue_stall;
};
struct sfbbinstats {
	int16_t         pmark;          
	u_int16_t       pkts;           
	u_int32_t       bytes;          
};
struct sfb_stats {
	u_int32_t               allocation;
	u_int32_t               dropthresh;
	u_int32_t               clearpkts;
	u_int32_t               current;
	u_int64_t               target_qdelay;
	u_int64_t               update_interval;
	u_int64_t               min_estdelay;
	u_int32_t               delay_fcthreshold;
	u_int32_t               flags;
	struct sfbstats         sfbstats;
	struct sfbbins {
		struct sfbbinstats stats[SFB_LEVELS][SFB_BINS];
	} binstats[2] __attribute__((aligned(8)));
};
struct sfb_bins {
	u_int32_t               fudge;
	struct sfbbinstats      stats[SFB_LEVELS][SFB_BINS];
	struct timespec         freezetime[SFB_LEVELS][SFB_BINS];
};
struct sfb_fcl {
	u_int32_t               cnt;
	struct flowadv_fclist   fclist;
};
struct sfb {
	u_int32_t       sfb_flags;      
	u_int32_t       sfb_qlim;
	u_int32_t       sfb_qid;
	u_int16_t       sfb_allocation;
	u_int16_t       sfb_drop_thresh;
	u_int32_t       sfb_clearpkts;
	u_int64_t       sfb_eff_rate;   
	struct timespec sfb_getqtime;   
	struct timespec sfb_holdtime;   
	struct ifnet    *sfb_ifp;       

	u_int64_t       sfb_target_qdelay;
	struct timespec sfb_update_interval;
	u_int64_t       sfb_fc_threshold; 

	u_int64_t       sfb_min_qdelay;
	struct timespec sfb_update_time;

	struct timespec sfb_hinterval;  
	struct timespec sfb_nextreset;  

	struct timespec sfb_pboxtime;   
	struct timespec sfb_pboxfreeze;

	u_int32_t       sfb_current;    
	struct sfb_bins (*sfb_bins)[ 2];

	struct sfb_fcl  (*sfb_fc_lists)[ SFB_BINS];

	struct sfbstats sfb_stats __attribute__((aligned(8)));
} sfb_t;
struct cqrq_purge_sc {
	mbuf_svc_class_t        sc;     
	u_int32_t               flow;   
	u_int32_t               packets; 
	u_int32_t               bytes;  
} cqrq_purge_sc_t;
struct cqrq_throttle {
	u_int32_t               set;    
	u_int32_t               level;  
} cqrq_throttle_t;
struct cqrq_stat_sc {
	mbuf_svc_class_t        sc;     
	u_int8_t                grp_idx; 
	u_int32_t               packets; 
	u_int32_t               bytes;  
} cqrq_stat_sc_t;
struct tb_regulator {
	u_int64_t       tbr_rate_raw;   
	u_int32_t       tbr_percent;    
	int64_t         tbr_rate;       
	int64_t         tbr_depth;      

	int64_t         tbr_token;      
	int64_t         tbr_filluptime; 
	u_int64_t       tbr_last;       

};
struct tb_profile {
	u_int64_t       rate;   
	u_int32_t       percent; 
	u_int32_t       depth;  
};
struct ifclassq {
	decl_lck_mtx_data(, ifcq_lock);

	os_refcnt_t     ifcq_refcnt;
	struct ifnet    *ifcq_ifp;      
	u_int32_t       ifcq_len;       
	u_int32_t       ifcq_maxlen;
	struct pktcntr  ifcq_xmitcnt;
	struct pktcntr  ifcq_dropcnt;

	u_int32_t       ifcq_type;      
	u_int32_t       ifcq_flags;     
	u_int32_t       ifcq_sflags;    
	u_int32_t       ifcq_target_qdelay; 
	u_int32_t       ifcq_bytes;     
	u_int32_t       ifcq_pkt_drop_limit;
	uint64_t        ifcq_doorbells;
	void            *ifcq_disc;     
	struct ifclassq_disc_slot {
		u_int32_t       qid;
		void            *cl;
	} ifcq_disc_slots[IFCQ_SC_MAX]; 

	struct tb_regulator     ifcq_tbr;       
};
struct if_ifclassq_stats {
	u_int32_t       ifqs_len;
	u_int32_t       ifqs_maxlen;
	uint64_t        ifqs_doorbells;
	struct pktcntr  ifqs_xmitcnt;
	struct pktcntr  ifqs_dropcnt;
	u_int32_t       ifqs_scheduler;
	struct fq_codel_classstats      ifqs_fq_codel_stats;
} __attribute__((aligned(8)));
struct _pktsched_pkt_ {
	classq_pkt_t            __pkt;
	classq_pkt_t            __tail;
	uint32_t                __plen;
	uint32_t                __pcnt;
} pktsched_pkt_t;
struct callout {
	void            *c_arg;                 
	void            (*c_func)(void *);      
};
struct cbq_classstats {
	u_int32_t       handle;
	u_int32_t       depth;

	struct pktcntr  xmit_cnt;       
	struct pktcntr  drop_cnt;       
	u_int32_t       over;           
	u_int32_t       borrows;        
	u_int32_t       overactions;    
	u_int32_t       delays;         

	int             priority;
	int             maxidle;
	int             minidle;
	int             offtime;
	int             qmax;
	int             ns_per_byte;
	int             wrr_allot;

	int             qcnt;           
	int             avgidle;

	classq_type_t   qtype;
	union {
		
		struct red_stats        red[RIO_NDROPPREC];
		struct blue_stats       blue;
		struct sfb_stats        sfb;
	};
	classq_state_t  qstate;
} class_stats_t;
struct fairq_classstats {
	u_int32_t               class_handle;
	u_int32_t               priority;

	u_int32_t               qlength;
	u_int32_t               qlimit;
	struct pktcntr          xmit_cnt;  
	struct pktcntr          drop_cnt;  

	classq_type_t           qtype;
	union {
		
		struct red_stats        red[RIO_NDROPPREC];
		struct blue_stats       blue;
		struct sfb_stats        sfb;
	};
	classq_state_t          qstate;
};
struct fcl_stat {
	u_int32_t fcl_flow_control;
	u_int32_t fcl_flow_feedback;
	u_int32_t fcl_dequeue_stall;
	u_int32_t fcl_flow_control_fail;
	u_int64_t fcl_drop_overflow;
	u_int64_t fcl_drop_early;
	u_int32_t fcl_drop_memfailure;
	u_int32_t fcl_flows_cnt;
	u_int32_t fcl_newflows_cnt;
	u_int32_t fcl_oldflows_cnt;
	u_int64_t fcl_pkt_cnt;
	u_int64_t fcl_dequeue;
	u_int64_t fcl_dequeue_bytes;
	u_int64_t fcl_byte_cnt;
	u_int32_t fcl_throttle_on;
	u_int32_t fcl_throttle_off;
	u_int32_t fcl_throttle_drops;
	u_int32_t fcl_dup_rexmts;
	u_int32_t fcl_pkts_compressible;
	u_int32_t fcl_pkts_compressed;
	uint64_t fcl_min_qdelay;
	uint64_t fcl_max_qdelay;
	uint64_t fcl_avg_qdelay;
	uint32_t fcl_overwhelming;
	uint64_t fcl_ce_marked;
	uint64_t fcl_ce_reported;
	uint64_t fcl_ce_mark_failures;
	uint64_t fcl_l4s_pkts;
	uint64_t fcl_ignore_tx_time;
	uint64_t fcl_paced_pkts;
	uint64_t fcl_fcl_pacemaker_needed;
};
struct fq_if_classq {
	uint32_t fcl_pri;      
	uint32_t fcl_service_class;    
	uint32_t fcl_quantum;          
	uint32_t fcl_drr_max;          
	int64_t  fcl_budget;             
	uint64_t fcl_next_tx_time;      
	flowq_stailq_t fcl_new_flows;   
	flowq_stailq_t fcl_old_flows;   
	struct fcl_stat fcl_stat;
	uint8_t fcl_flags;
} fq_if_classq_t;
struct fq_codel_classq_group {
	uint64_t                fqg_target_qdelays[FQ_TFC_CNT];
	uint64_t                fqg_update_intervals[FQ_TFC_CNT];
	pktsched_bitmap_t       fqg_bitmaps[FQ_IF_MAX_STATE];
	TAILQ_ENTRY(fq_codel_classq_group) fqg_grp_link;
	uint32_t                fqg_bytes;     
	uint32_t                fqg_len;       
	uint8_t                 fqg_flags;     
	uint8_t                 fqg_index;     
	fq_if_classq_t          fqg_classq[FQ_IF_MAX_CLASSES]; 
	struct flowq            *fqg_large_flow; 
} fq_if_group_t;
struct fq_if_bitmap_ops {
	fq_if_bitmaps_ffs       ffs;
	fq_if_bitmaps_zeros     zeros;
	fq_if_bitmaps_cpy       cpy;
	fq_if_bitmaps_clr       clr;
	fq_if_bitmaps_move      move;
} bitmap_ops_t;
struct fq_codel_sched_data {
	struct ifclassq         *fqs_ifq;       
	flowq_list_t            *fqs_flows __counted_by(fqs_flows_count); 
	uint32_t                fqs_flows_count;
	uint32_t                fqs_pkt_droplimit;  
	uint8_t                 fqs_throttle;   
	uint8_t                 fqs_flags;      
	struct flowadv_fclist   fqs_fclist; 
	struct flowq            *fqs_large_flow; 
	TAILQ_HEAD(, flowq)     fqs_empty_list; 
	fq_grp_tailq_t          fqs_combined_grp_list;
	uint32_t                fqs_empty_list_cnt;
	pktsched_bitmap_t       fqs_combined_grp_bitmap;
	classq_pkt_type_t       fqs_ptype;
	thread_call_t           fqs_pacemaker_tcall;
	bitmap_ops_t            *fqs_bm_ops;
	fq_if_group_t           *fqs_classq_groups[FQ_IF_MAX_GROUPS];
} fq_if_t;
struct fq_codel_flowstats {
	u_int32_t       fqst_min_qdelay;
	u_int32_t       fqst_flags;
	u_int32_t       fqst_bytes;
	u_int32_t       fqst_flowhash;
};
struct fq_codel_classstats {
	u_int32_t       fcls_pri;
	u_int32_t       fcls_service_class;
	u_int32_t       fcls_quantum;
	u_int32_t       fcls_drr_max;
	int64_t         fcls_budget;
	u_int64_t       fcls_target_qdelay;
	u_int64_t       fcls_l4s_target_qdelay;
	u_int64_t       fcls_update_interval;
	u_int32_t       fcls_flow_control;
	u_int32_t       fcls_flow_feedback;
	u_int32_t       fcls_dequeue_stall;
	u_int32_t       fcls_flow_control_fail;
	u_int64_t       fcls_drop_overflow;
	u_int64_t       fcls_drop_early;
	u_int32_t       fcls_drop_memfailure;
	u_int32_t       fcls_flows_cnt;
	u_int32_t       fcls_newflows_cnt;
	u_int32_t       fcls_oldflows_cnt;
	u_int64_t       fcls_pkt_cnt;
	u_int64_t       fcls_dequeue;
	u_int64_t       fcls_dequeue_bytes;
	u_int64_t       fcls_byte_cnt;
	u_int32_t       fcls_throttle_on;
	u_int32_t       fcls_throttle_off;
	u_int32_t       fcls_throttle_drops;
	u_int32_t       fcls_dup_rexmts;
	u_int32_t       fcls_flowstats_cnt;
	struct fq_codel_flowstats fcls_flowstats[FQ_IF_MAX_FLOWSTATS];
	u_int32_t       fcls_pkts_compressible;
	u_int32_t       fcls_pkts_compressed;
	uint64_t        fcls_min_qdelay;
	uint64_t        fcls_max_qdelay;
	uint64_t        fcls_avg_qdelay;
	uint32_t        fcls_overwhelming;
	uint64_t        fcls_ce_marked;
	uint64_t        fcls_ce_reported;
	uint64_t        fcls_ce_mark_failures;
	uint64_t        fcls_l4s_pkts;
	uint64_t        fcls_ignore_tx_time;
	uint64_t        fcls_paced_pkts;
	uint64_t        fcls_fcl_pacing_needed;
};
struct service_curve {
	u_int32_t fl;   
	u_int64_t m1;   
	u_int32_t d;    
	u_int64_t m2;   
};
struct hfsc_classstats {
	u_int32_t               class_id;
	u_int32_t               class_handle;
	struct service_curve    rsc;
	struct service_curve    fsc;
	struct service_curve    usc;    

	u_int64_t               total;  
	u_int64_t               cumul;  
	                                
	u_int64_t               d;              
	u_int64_t               e;              
	u_int64_t               vt;             
	u_int64_t               f;              

	u_int64_t               initvt;         
	u_int64_t               vtoff;          
	u_int64_t               cvtmax;         
	u_int64_t               myf;            
	u_int64_t               cfmin;          
	u_int64_t               cvtmin;         
	u_int64_t               myfadj;         
	u_int64_t               vtadj;          
	u_int64_t               cur_time;
	u_int32_t               machclk_freq;

	u_int32_t               qlength;
	u_int32_t               qlimit;
	struct pktcntr          xmit_cnt;
	struct pktcntr          drop_cnt;
	u_int32_t               period;

	u_int32_t               vtperiod;       
	u_int32_t               parentperiod;   
	int                     nactive;        

	classq_type_t           qtype;
	union {
		
		struct red_stats        red[RIO_NDROPPREC];
		struct blue_stats       blue;
		struct sfb_stats        sfb;
	};
	classq_state_t          qstate;
};
struct priq_classstats {
	u_int32_t               class_handle;
	u_int32_t               priority;

	u_int32_t               qlength;
	u_int32_t               qlimit;
	u_int32_t               period;
	struct pktcntr          xmitcnt;  
	struct pktcntr          dropcnt;  

	classq_type_t           qtype;
	union {
		
		struct red_stats        red[RIO_NDROPPREC];
		struct blue_stats       blue;
		struct sfb_stats        sfb;
	};
	classq_state_t          qstate;
};
struct bind_mount {
	struct vnode * bindm_rootvp;       
	struct vnode * bindm_lowerrootvp;  
	uint32_t bindm_lowerrootvid;       
	uint64_t bindm_flags;
};
struct bind_node {
	LIST_ENTRY(bind_node) bind_hash; 
	struct vnode * bind_lowervp;     
	struct vnode * bind_vnode;       
	uint32_t bind_lowervid;          
	uint32_t bind_myvid;
	uint32_t bind_flags;
};
struct vnodeop_desc_fake {
	int vdesc_offset;
	const char * vdesc_name;
};
struct fifoinfo {
	unsigned int    fi_flags;
	struct socket   *fi_readsock;
	struct socket   *fi_writesock;
	long        fi_readers;
	long        fi_writers;
	unsigned int    fi_count;
};
struct null_mount {
	struct vnode * nullm_rootvp;       
	struct vnode * nullm_secondvp;     
	struct vnode * nullm_lowerrootvp;  
	uint32_t nullm_lowerrootvid;       
	lck_mtx_t nullm_lock;              
	uint64_t nullm_flags;
	uid_t uid;
	gid_t gid;
};
struct null_mount_conf {
	uint64_t flags;
};
struct null_node {
	LIST_ENTRY(null_node) null_hash; 
	struct vnode * null_lowervp;     
	struct vnode * null_vnode;       
	uint32_t null_lowervid;          
	uint32_t null_myvid;
	uint32_t null_flags;
};
struct vnodeop_desc_fake {
	int vdesc_offset;
	const char * vdesc_name;
};
struct routefs_args {
	char    route_path[MAXPATHLEN];
	vnode_t route_rvp; 
};
struct routefs_mount {
	char    route_path[MAXPATHLEN];
	mount_t route_mount;
	vnode_t route_rvp; 
	int route_vpvid; 
};
struct blmeta {
	union {
		daddr_t     bmu_avail;  
		u_daddr_t   bmu_bitmap; 
	} u;
	daddr_t         bm_bighint;     
} blmeta_t;
struct blist {
	daddr_t         bl_blocks;      
	daddr_t         bl_radix;       
	daddr_t         bl_skip;        
	daddr_t         bl_free;        
	blmeta_t        *bl_root;       
	daddr_t         bl_rootblks;    
} *blist_t;
struct systrace_sysent {
	dtrace_id_t     stsy_entry;
	dtrace_id_t     stsy_return;
	int32_t         (*stsy_underlying)(struct proc *, void *, int *);
	int32_t         stsy_return_type;
} systrace_sysent_t;
