__ASSERTMACROS__ None
DEBUG_ASSERT_COMPONENT_NAME_STRING ""
DEBUG_ASSERT_PRODUCTION_CODE !DEBUG
DEBUG_ASSERT_MESSAGE(name, assertion, label, message, file, line, value)                                   printf( "AssertMacros: %s, %s file: %s, line: %d\n", assertion, (message!=0) ? message : "", file, line);
__Debug_String(message) None
__Check(assertion) None
__nCheck(assertion) __Check(!(assertion))
__Check_String(assertion, message)
__nCheck_String(assertion, message)  __Check_String(!(assertion), message)
__Check_noErr(errorCode) None
__Check_noErr_String(errorCode, message)
__Verify(assertion) do                                                                      		  {                                                                       			  if ( !(assertion) )                                                 			  {                                                                   			  }                                                                   		  } while ( 0 )
__nVerify(assertion) __Verify(!(assertion))
__Verify_String(assertion, message)                                		  do                                                                      		  {                                                                       			  if ( !(assertion) )                                                 			  {                                                                   			  }                                                                   		  } while ( 0 )
__nVerify_String(assertion, message)  __Verify_String(!(assertion), message)
__Verify_noErr(errorCode) do                                                                      		  {                                                                       			  if ( 0 != (errorCode) )                                             			  {                                                                   			  }                                                                   		  } while ( 0 )
__Verify_noErr_String(errorCode, message)                          		  do                                                                      		  {                                                                       			  if ( 0 != (errorCode) )                                             			  {                                                                   			  }                                                                   		  } while ( 0 )
__Verify_noErr_Action(errorCode, action)                          		  if ( 0 != (errorCode) ) {                                              			  action;                                                            		  }                                                                      		  else do {} while (0)
__Verify_Action(assertion, action)                                		  if ( __builtin_expect(!(assertion), 0) ) {                             			action;                                                              		  }                                                                      		  else do {} while (0)
__Require(assertion, exceptionLabel)                               		  do                                                                      		  {                                                                       			  if ( __builtin_expect(!(assertion), 0) )                            			  {                                                                   				  goto exceptionLabel;                                            			  }                                                                   		  } while ( 0 )
__nRequire(assertion, exceptionLabel)  __Require(!(assertion), exceptionLabel)
__Require_Action(assertion, exceptionLabel, action)                		  do                                                                      		  {                                                                       			  if ( __builtin_expect(!(assertion), 0) )                            			  {                                                                   				  {                                                               					  action;                                                     				  }                                                               				  goto exceptionLabel;                                            			  }                                                                   		  } while ( 0 )
__nRequire_Action(assertion, exceptionLabel, action)                  	__Require_Action(!(assertion), exceptionLabel, action)
__Require_Quiet(assertion, exceptionLabel)                            	  do                                                                          	  {                                                                           		  if ( __builtin_expect(!(assertion), 0) )                                		  {                                                                       			  goto exceptionLabel;                                                		  }                                                                       	  } while ( 0 )
__nRequire_Quiet(assertion, exceptionLabel)  __Require_Quiet(!(assertion), exceptionLabel)
__Require_Action_Quiet(assertion, exceptionLabel, action)             	  do                                                                          	  {                                                                           		  if ( __builtin_expect(!(assertion), 0) )                                		  {                                                                       			  {                                                                   				  action;                                                         			  }                                                                   			  goto exceptionLabel;                                                		  }                                                                       	  } while ( 0 )
__nRequire_Action_Quiet(assertion, exceptionLabel, action)              		__Require_Action_Quiet(!(assertion), exceptionLabel, action)
__Require_String(assertion, exceptionLabel, message)               		  do                                                                      		  {                                                                       			  if ( __builtin_expect(!(assertion), 0) )                            			  {                                                                   				  goto exceptionLabel;                                            			  }                                                                   		  } while ( 0 )
__nRequire_String(assertion, exceptionLabel, string)                  		__Require_String(!(assertion), exceptionLabel, string)
__Require_Action_String(assertion, exceptionLabel, action, message)  		  do                                                                      		  {                                                                       			  if ( __builtin_expect(!(assertion), 0) )                            			  {                                                                   				  {                                                               					  action;                                                     				  }                                                               				  goto exceptionLabel;                                            			  }                                                                   		  } while ( 0 )
__nRequire_Action_String(assertion, exceptionLabel, action, message)    		__Require_Action_String(!(assertion), exceptionLabel, action, message)
__Require_noErr(errorCode, exceptionLabel)                         		  do                                                                      		  {                                                                       			  if ( __builtin_expect(0 != (errorCode), 0) )                        			  {                                                                   				  goto exceptionLabel;                                            			  }                                                                   		  } while ( 0 )
__Require_noErr_Action(errorCode, exceptionLabel, action)          		  do                                                                      		  {                                                                       			  if ( __builtin_expect(0 != (errorCode), 0) )                        			  {                                                                   				  {                                                               					  action;                                                     				  }                                                               				  goto exceptionLabel;                                            			  }                                                                   		  } while ( 0 )
__Require_noErr_Quiet(errorCode, exceptionLabel)                      	  do                                                                          	  {                                                                           		  if ( __builtin_expect(0 != (errorCode), 0) )                            		  {                                                                       			  goto exceptionLabel;                                                		  }                                                                       	  } while ( 0 )
__Require_noErr_Action_Quiet(errorCode, exceptionLabel, action)       	  do                                                                          	  {                                                                           		  if ( __builtin_expect(0 != (errorCode), 0) )                            		  {                                                                       			  {                                                                   				  action;                                                         			  }                                                                   			  goto exceptionLabel;                                                		  }                                                                       	  } while ( 0 )
__Require_noErr_String(errorCode, exceptionLabel, message)         		  do                                                                      		  {                                                                       			  if ( __builtin_expect(0 != (errorCode), 0) )                        			  {                                                                   				  goto exceptionLabel;                                            			  }                                                                   		  } while ( 0 )
__Require_noErr_Action_String(errorCode, exceptionLabel, action, message) 		  do                                                                      		  {                                                                       			  if ( __builtin_expect(0 != (errorCode), 0) )                        			  {                                                                   				  {                                                               					  action;                                                     				  }                                                               				  goto exceptionLabel;                                            			  }                                                                   		  } while ( 0 )
__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 1
check(assertion) __Check(assertion)
check_noerr(errorCode) __Check_noErr(errorCode)
check_noerr_string(errorCode, message)  __Check_noErr_String(errorCode, message)
check_string(assertion, message)  __Check_String(assertion, message)
require(assertion, exceptionLabel)  __Require(assertion, exceptionLabel)
require_action(assertion, exceptionLabel, action)  __Require_Action(assertion, exceptionLabel, action)
require_action_string(assertion, exceptionLabel, action, message)  __Require_Action_String(assertion, exceptionLabel, action, message)
require_noerr(errorCode, exceptionLabel)  __Require_noErr(errorCode, exceptionLabel)
require_noerr_action(errorCode, exceptionLabel, action)  __Require_noErr_Action(errorCode, exceptionLabel, action)
require_noerr_action_string(errorCode, exceptionLabel, action, message)  __Require_noErr_Action_String(errorCode, exceptionLabel, action, message)
require_noerr_string(errorCode, exceptionLabel, message)  __Require_noErr_String(errorCode, exceptionLabel, message)
require_string(assertion, exceptionLabel, message)  __Require_String(assertion, exceptionLabel, message)
verify(assertion) __Verify(assertion)
verify_action(assertion, action)  __Verify_Action(assertion, action)
verify_noerr(errorCode) __Verify_noErr(errorCode)
verify_noerr_action(errorCode, action)  __Verify_noErr_Action(errorCode, action)
verify_noerr_string(errorCode, message)  __Verify_noErr_String(errorCode, message)
verify_string(assertion, message)  __Verify_String(assertion, message)
ncheck(assertion) __nCheck(assertion)
ncheck_string(assertion, message)  __nCheck_String(assertion, message)
nrequire(assertion, exceptionLabel)  __nRequire(assertion, exceptionLabel)
nrequire_action(assertion, exceptionLabel, action)  __nRequire_Action(assertion, exceptionLabel, action)
nrequire_action_quiet(assertion, exceptionLabel, action)  __nRequire_Action_Quiet(assertion, exceptionLabel, action)
nrequire_action_string(assertion, exceptionLabel, action, message)  __nRequire_Action_String(assertion, exceptionLabel, action, message)
nrequire_quiet(assertion, exceptionLabel)  __nRequire_Quiet(assertion, exceptionLabel)
nrequire_string(assertion, exceptionLabel, string)  __nRequire_String(assertion, exceptionLabel, string)
nverify(assertion) __nVerify(assertion)
nverify_string(assertion, message)  __nVerify_String(assertion, message)
require_action_quiet(assertion, exceptionLabel, action)  __Require_Action_Quiet(assertion, exceptionLabel, action)
require_noerr_action_quiet(errorCode, exceptionLabel, action)  __Require_noErr_Action_Quiet(errorCode, exceptionLabel, action)
require_noerr_quiet(errorCode, exceptionLabel)  __Require_noErr_Quiet(errorCode, exceptionLabel)
require_quiet(assertion, exceptionLabel)  __Require_Quiet(assertion, exceptionLabel)
debug_string(message) __Debug_String(message)
__AVAILABILITY__ None
__MAC_10_0 1000
__MAC_10_1 1010
__MAC_10_2 1020
__MAC_10_3 1030
__MAC_10_4 1040
__MAC_10_5 1050
__MAC_10_6 1060
__MAC_10_7 1070
__MAC_10_8 1080
__MAC_10_9 1090
__MAC_10_10 101000
__MAC_10_10_2 101002
__MAC_10_10_3 101003
__MAC_10_11 101100
__MAC_10_11_2 101102
__MAC_10_11_3 101103
__MAC_10_11_4 101104
__MAC_10_12 101200
__MAC_10_12_1 101201
__MAC_10_12_2 101202
__MAC_10_12_4 101204
__IPHONE_2_0 20000
__IPHONE_2_1 20100
__IPHONE_2_2 20200
__IPHONE_3_0 30000
__IPHONE_3_1 30100
__IPHONE_3_2 30200
__IPHONE_4_0 40000
__IPHONE_4_1 40100
__IPHONE_4_2 40200
__IPHONE_4_3 40300
__IPHONE_5_0 50000
__IPHONE_5_1 50100
__IPHONE_6_0 60000
__IPHONE_6_1 60100
__IPHONE_7_0 70000
__IPHONE_7_1 70100
__IPHONE_8_0 80000
__IPHONE_8_1 80100
__IPHONE_8_2 80200
__IPHONE_8_3 80300
__IPHONE_8_4 80400
__IPHONE_9_0 90000
__IPHONE_9_1 90100
__IPHONE_9_2 90200
__IPHONE_9_3 90300
__IPHONE_10_0 100000
__IPHONE_10_1 100100
__IPHONE_10_2 100200
__IPHONE_10_3 100300
__TVOS_9_0 90000
__TVOS_9_1 90100
__TVOS_9_2 90200
__TVOS_10_0 100000
__TVOS_10_0_1 100001
__TVOS_10_1 100100
__TVOS_10_2 100200
__WATCHOS_1_0 10000
__WATCHOS_2_0 20000
__WATCHOS_3_0 30000
__WATCHOS_3_1 30100
__WATCHOS_3_1_1 30101
__WATCHOS_3_2 30200
__OS_EXTENSION_UNAVAILABLE(_msg) __OSX_EXTENSION_UNAVAILABLE(_msg) __IOS_EXTENSION_UNAVAILABLE(_msg)
__OSX_UNAVAILABLE None
__OSX_AVAILABLE(_vers) None
__OSX_DEPRECATED(_start, _dep, _msg)
__IOS_UNAVAILABLE None
__IOS_PROHIBITED None
__IOS_AVAILABLE(_vers) None
__IOS_DEPRECATED(_start, _dep, _msg)
__TVOS_UNAVAILABLE None
__TVOS_PROHIBITED None
__TVOS_AVAILABLE(_vers) None
__TVOS_DEPRECATED(_start, _dep, _msg)
__WATCHOS_UNAVAILABLE None
__WATCHOS_PROHIBITED None
__WATCHOS_AVAILABLE(_vers) None
__WATCHOS_DEPRECATED(_start, _dep, _msg)
__SWIFT_UNAVAILABLE None
__SWIFT_UNAVAILABLE_MSG(_msg) None
__API_AVAILABLE(...) __API_AVAILABLE_GET_MACRO(__VA_ARGS__,__API_AVAILABLE4, __API_AVAILABLE3, __API_AVAILABLE2, __API_AVAILABLE1)(__VA_ARGS__)
__API_DEPRECATED(...) __API_DEPRECATED_MSG_GET_MACRO(__VA_ARGS__,__API_DEPRECATED_MSG5,__API_DEPRECATED_MSG4,__API_DEPRECATED_MSG3,__API_DEPRECATED_MSG2,__API_DEPRECATED_MSG1)(__VA_ARGS__)
__API_DEPRECATED_WITH_REPLACEMENT(...) __API_DEPRECATED_REP_GET_MACRO(__VA_ARGS__,__API_DEPRECATED_REP5,__API_DEPRECATED_REP4,__API_DEPRECATED_REP3,__API_DEPRECATED_REP2,__API_DEPRECATED_REP1)(__VA_ARGS__)
__API_UNAVAILABLE(...) __API_UNAVAILABLE_GET_MACRO(__VA_ARGS__,__API_UNAVAILABLE3,__API_UNAVAILABLE2,__API_UNAVAILABLE1)(__VA_ARGS__)
__AVAILABILITY_INTERNAL__ None
__AVAILABILITY_INTERNAL_DEPRECATED __attribute__((deprecated))
__AVAILABILITY_INTERNAL_UNAVAILABLE __attribute__((unavailable))
__AVAILABILITY_INTERNAL_WEAK_IMPORT __attribute__((weak_import))
__AVAILABILITY_INTERNAL_REGULAR None
__API_AVAILABLE_PLATFORM_macos(x) macos,introduced=x
__API_AVAILABLE_PLATFORM_macosx(x) macosx,introduced=x
__API_AVAILABLE_PLATFORM_ios(x) ios,introduced=x
__API_AVAILABLE_PLATFORM_watchos(x) watchos,introduced=x
__API_AVAILABLE_PLATFORM_tvos(x) tvos,introduced=x
__API_A(x) __attribute__((availability(__API_AVAILABLE_PLATFORM_##x)))
__API_AVAILABLE1(x) __API_A(x)
__API_AVAILABLE2(x,y) __API_A(x) __API_A(y)
__API_AVAILABLE3(x,y,z) __API_A(x) __API_A(y) __API_A(z)
__API_AVAILABLE4(x,y,z,t) __API_A(x) __API_A(y) __API_A(z) __API_A(t)
__API_AVAILABLE_GET_MACRO(_1,_2,_3,_4,NAME,...) NAME
__API_DEPRECATED_PLATFORM_macos(x,y) macos,introduced=x,deprecated=y
__API_DEPRECATED_PLATFORM_macosx(x,y) macosx,introduced=x,deprecated=y
__API_DEPRECATED_PLATFORM_ios(x,y) ios,introduced=x,deprecated=y
__API_DEPRECATED_PLATFORM_watchos(x,y) watchos,introduced=x,deprecated=y
__API_DEPRECATED_PLATFORM_tvos(x,y) tvos,introduced=x,deprecated=y
__API_D(msg,x) __attribute__((availability(__API_DEPRECATED_PLATFORM_##x,message=msg)))
__API_DEPRECATED_MSG2(msg,x) __API_D(msg,x)
__API_DEPRECATED_MSG3(msg,x,y) __API_D(msg,x) __API_D(msg,y)
__API_DEPRECATED_MSG4(msg,x,y,z) __API_DEPRECATED_MSG3(msg,x,y) __API_D(msg,z)
__API_DEPRECATED_MSG5(msg,x,y,z,t) __API_DEPRECATED_MSG4(msg,x,y,z) __API_D(msg,t)
__API_DEPRECATED_MSG_GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME
__API_DEPRECATED_REP2(rep,x) __API_R(rep,x)
__API_DEPRECATED_REP3(rep,x,y) __API_R(rep,x) __API_R(rep,y)
__API_DEPRECATED_REP4(rep,x,y,z) __API_DEPRECATED_REP3(rep,x,y) __API_R(rep,z)
__API_DEPRECATED_REP5(rep,x,y,z,t) __API_DEPRECATED_REP4(rep,x,y,z) __API_R(rep,t)
__API_DEPRECATED_REP_GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME
__API_UNAVAILABLE_PLATFORM_macos macos,unavailable
__API_UNAVAILABLE_PLATFORM_macosx macosx,unavailable
__API_UNAVAILABLE_PLATFORM_ios ios,unavailable
__API_UNAVAILABLE_PLATFORM_watchos watchos,unavailable
__API_UNAVAILABLE_PLATFORM_tvos tvos,unavailable
__API_U(x) __attribute__((availability(__API_UNAVAILABLE_PLATFORM_##x)))
__API_UNAVAILABLE1(x) __API_U(x)
__API_UNAVAILABLE2(x,y) __API_U(x) __API_U(y)
__API_UNAVAILABLE3(x,y,z) __API_UNAVAILABLE2(x,y) __API_U(z)
__API_UNAVAILABLE_GET_MACRO(_1,_2,_3,NAME,...) NAME
__AVAILABILITYMACROS__ None
MAC_OS_X_VERSION_10_0 1000
MAC_OS_X_VERSION_10_1 1010
MAC_OS_X_VERSION_10_2 1020
MAC_OS_X_VERSION_10_3 1030
MAC_OS_X_VERSION_10_4 1040
MAC_OS_X_VERSION_10_5 1050
MAC_OS_X_VERSION_10_6 1060
MAC_OS_X_VERSION_10_7 1070
MAC_OS_X_VERSION_10_8 1080
MAC_OS_X_VERSION_10_9 1090
MAC_OS_X_VERSION_10_10 101000
MAC_OS_X_VERSION_10_10_2 101002
MAC_OS_X_VERSION_10_10_3 101003
MAC_OS_X_VERSION_10_11 101100
MAC_OS_X_VERSION_10_11_2 101102
MAC_OS_X_VERSION_10_11_3 101103
MAC_OS_X_VERSION_10_11_4 101104
MAC_OS_X_VERSION_10_12 101200
MAC_OS_X_VERSION_10_12_1 101201
MAC_OS_X_VERSION_10_12_2 101202
MAC_OS_X_VERSION_10_12_4 101204
AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER None
AVAILABLE_MAC_OS_X_VERSION_10_0_AND_LATER_BUT_DEPRECATED DEPRECATED_ATTRIBUTE
DEPRECATED_IN_MAC_OS_X_VERSION_10_0_AND_LATER DEPRECATED_ATTRIBUTE
__PTRAUTH_H None
__PTRCHECK_H None
_KCDATA_H_ None
KCDATA_DESC_MAXLEN 32
KCDATA_FLAGS_STRUCT_PADDING_MASK 0xf
KCDATA_FLAGS_STRUCT_HAS_PADDING 0x80
KCDATA_ALIGNMENT_SIZE 0x10
KCS_SUBTYPE_FLAGS_NONE 0x0
KCS_SUBTYPE_FLAGS_ARRAY 0x1
KCS_SUBTYPE_FLAGS_STRUCT 0x2
KCS_SUBTYPE_FLAGS_MERGE 0x4
KCS_SUBTYPE_PACK_SIZE(e_count, e_size) (((e_count)&0xffffu) << 16 | ((e_size)&0xffffu))
KCDATA_TYPE_INVALID 0x0u
KCDATA_TYPE_STRING_DESC 0x1u
KCDATA_TYPE_UINT32_DESC 0x2u
KCDATA_TYPE_UINT64_DESC 0x3u
KCDATA_TYPE_INT32_DESC 0x4u
KCDATA_TYPE_INT64_DESC 0x5u
KCDATA_TYPE_BINDATA_DESC 0x6u
KCDATA_TYPE_ARRAY 0x11u
KCDATA_TYPE_TYPEDEFINTION 0x12u
KCDATA_TYPE_CONTAINER_BEGIN 0x13u
KCDATA_TYPE_CONTAINER_END 0x14u
KCDATA_TYPE_ARRAY_PAD0 0x20u
KCDATA_TYPE_ARRAY_PAD1 0x21u
KCDATA_TYPE_ARRAY_PAD2 0x22u
KCDATA_TYPE_ARRAY_PAD3 0x23u
KCDATA_TYPE_ARRAY_PAD4 0x24u
KCDATA_TYPE_ARRAY_PAD5 0x25u
KCDATA_TYPE_ARRAY_PAD6 0x26u
KCDATA_TYPE_ARRAY_PAD7 0x27u
KCDATA_TYPE_ARRAY_PAD8 0x28u
KCDATA_TYPE_ARRAY_PAD9 0x29u
KCDATA_TYPE_ARRAY_PADa 0x2au
KCDATA_TYPE_ARRAY_PADb 0x2bu
KCDATA_TYPE_ARRAY_PADc 0x2cu
KCDATA_TYPE_ARRAY_PADd 0x2du
KCDATA_TYPE_ARRAY_PADe 0x2eu
KCDATA_TYPE_ARRAY_PADf 0x2fu
KCDATA_TYPE_LIBRARY_LOADINFO 0x30u
KCDATA_TYPE_LIBRARY_LOADINFO64 0x31u
KCDATA_TYPE_TIMEBASE 0x32u
KCDATA_TYPE_MACH_ABSOLUTE_TIME 0x33u
KCDATA_TYPE_TIMEVAL 0x34u
KCDATA_TYPE_USECS_SINCE_EPOCH 0x35u
KCDATA_TYPE_PID 0x36u
KCDATA_TYPE_PROCNAME 0x37u
KCDATA_TYPE_NESTED_KCDATA 0x38u
KCDATA_TYPE_LIBRARY_AOTINFO 0x39u
KCDATA_TYPE_BUFFER_END 0xF19158EDu
KCDATA_BUFFER_BEGIN_CRASHINFO 0xDEADF157u
KCDATA_BUFFER_BEGIN_STACKSHOT 0x59a25807u
KCDATA_BUFFER_BEGIN_COMPRESSED 0x434f4d50u
KCDATA_BUFFER_BEGIN_DELTA_STACKSHOT 0xDE17A59Au
KCDATA_BUFFER_BEGIN_BTINFO 0x46414E47u
KCDATA_BUFFER_BEGIN_OS_REASON 0x53A20900u
KCDATA_BUFFER_BEGIN_XNUPOST_CONFIG 0x1e21c09fu
XNUPOST_KCTYPE_TESTCONFIG 0x1040
STACKSHOT_IO_NUM_PRIORITIES 4
STACKSHOT_MAX_THREAD_NAME_SIZE 64
STACKSHOT_KCTYPE_IOSTATS 0x901u
STACKSHOT_KCTYPE_GLOBAL_MEM_STATS 0x902u
STACKSHOT_KCCONTAINER_TASK 0x903u
STACKSHOT_KCCONTAINER_THREAD 0x904u
STACKSHOT_KCTYPE_TASK_SNAPSHOT 0x905u
STACKSHOT_KCTYPE_THREAD_SNAPSHOT 0x906u
STACKSHOT_KCTYPE_DONATING_PIDS 0x907u
STACKSHOT_KCTYPE_SHAREDCACHE_LOADINFO 0x908u
STACKSHOT_KCTYPE_THREAD_NAME 0x909u
STACKSHOT_KCTYPE_KERN_STACKFRAME 0x90Au
STACKSHOT_KCTYPE_KERN_STACKFRAME64 0x90Bu
STACKSHOT_KCTYPE_USER_STACKFRAME 0x90Cu
STACKSHOT_KCTYPE_USER_STACKFRAME64 0x90Du
STACKSHOT_KCTYPE_BOOTARGS 0x90Eu
STACKSHOT_KCTYPE_OSVERSION 0x90Fu
STACKSHOT_KCTYPE_KERN_PAGE_SIZE 0x910u
STACKSHOT_KCTYPE_JETSAM_LEVEL 0x911u
STACKSHOT_KCTYPE_DELTA_SINCE_TIMESTAMP 0x912u
STACKSHOT_KCTYPE_KERN_STACKLR 0x913u
STACKSHOT_KCTYPE_KERN_STACKLR64 0x914u
STACKSHOT_KCTYPE_USER_STACKLR 0x915u
STACKSHOT_KCTYPE_USER_STACKLR64 0x916u
STACKSHOT_KCTYPE_NONRUNNABLE_TIDS 0x917u
STACKSHOT_KCTYPE_NONRUNNABLE_TASKS 0x918u
STACKSHOT_KCTYPE_CPU_TIMES 0x919u
STACKSHOT_KCTYPE_STACKSHOT_DURATION 0x91au
STACKSHOT_KCTYPE_STACKSHOT_FAULT_STATS 0x91bu
STACKSHOT_KCTYPE_KERNELCACHE_LOADINFO 0x91cu
STACKSHOT_KCTYPE_THREAD_WAITINFO 0x91du
STACKSHOT_KCTYPE_THREAD_GROUP_SNAPSHOT 0x91eu
STACKSHOT_KCTYPE_THREAD_GROUP 0x91fu
STACKSHOT_KCTYPE_JETSAM_COALITION_SNAPSHOT 0x920u
STACKSHOT_KCTYPE_JETSAM_COALITION 0x921u
STACKSHOT_KCTYPE_THREAD_POLICY_VERSION 0x922u
STACKSHOT_KCTYPE_INSTRS_CYCLES 0x923u
STACKSHOT_KCTYPE_USER_STACKTOP 0x924u
STACKSHOT_KCTYPE_ASID 0x925u
STACKSHOT_KCTYPE_PAGE_TABLES 0x926u
STACKSHOT_KCTYPE_SYS_SHAREDCACHE_LAYOUT 0x927u
STACKSHOT_KCTYPE_THREAD_DISPATCH_QUEUE_LABEL 0x928u
STACKSHOT_KCTYPE_THREAD_TURNSTILEINFO 0x929u
STACKSHOT_KCTYPE_TASK_CPU_ARCHITECTURE 0x92au
STACKSHOT_KCTYPE_LATENCY_INFO 0x92bu
STACKSHOT_KCTYPE_LATENCY_INFO_TASK 0x92cu
STACKSHOT_KCTYPE_LATENCY_INFO_THREAD 0x92du
STACKSHOT_KCTYPE_LOADINFO64_TEXT_EXEC 0x92eu
STACKSHOT_KCTYPE_AOTCACHE_LOADINFO 0x92fu
STACKSHOT_KCTYPE_TRANSITIONING_TASK_SNAPSHOT 0x930u
STACKSHOT_KCCONTAINER_TRANSITIONING_TASK 0x931u
STACKSHOT_KCTYPE_USER_ASYNC_START_INDEX 0x932u
STACKSHOT_KCTYPE_USER_ASYNC_STACKLR64 0x933u
STACKSHOT_KCCONTAINER_PORTLABEL 0x934u
STACKSHOT_KCTYPE_PORTLABEL 0x935u
STACKSHOT_KCTYPE_PORTLABEL_NAME 0x936u
STACKSHOT_KCTYPE_DYLD_COMPACTINFO 0x937u
STACKSHOT_KCTYPE_SUSPENSION_INFO 0x938u
STACKSHOT_KCTYPE_SUSPENSION_SOURCE 0x939u
STACKSHOT_KCTYPE_TASK_DELTA_SNAPSHOT 0x940u
STACKSHOT_KCTYPE_THREAD_DELTA_SNAPSHOT 0x941u
STACKSHOT_KCCONTAINER_SHAREDCACHE 0x942u
STACKSHOT_KCTYPE_SHAREDCACHE_INFO 0x943u
STACKSHOT_KCTYPE_SHAREDCACHE_AOTINFO 0x944u
STACKSHOT_KCTYPE_SHAREDCACHE_ID 0x945u
STACKSHOT_KCTYPE_CODESIGNING_INFO 0x946u
STACKSHOT_KCTYPE_OS_BUILD_VERSION 0x947u
STACKSHOT_KCTYPE_KERN_EXCLAVES_THREADINFO 0x948u
STACKSHOT_KCCONTAINER_EXCLAVES 0x949u
STACKSHOT_KCCONTAINER_EXCLAVE_SCRESULT 0x94au
STACKSHOT_KCTYPE_EXCLAVE_SCRESULT_INFO 0x94bu
STACKSHOT_KCCONTAINER_EXCLAVE_IPCSTACKENTRY 0x94cu
STACKSHOT_KCTYPE_EXCLAVE_IPCSTACKENTRY_INFO 0x94du
STACKSHOT_KCTYPE_EXCLAVE_IPCSTACKENTRY_ECSTACK 0x94eu
STACKSHOT_KCCONTAINER_EXCLAVE_ADDRESSSPACE 0x94fu
STACKSHOT_KCTYPE_EXCLAVE_ADDRESSSPACE_INFO 0x950u
STACKSHOT_KCTYPE_EXCLAVE_ADDRESSSPACE_NAME 0x951u
STACKSHOT_KCCONTAINER_EXCLAVE_TEXTLAYOUT 0x952u
STACKSHOT_KCTYPE_EXCLAVE_TEXTLAYOUT_INFO 0x953u
STACKSHOT_KCTYPE_EXCLAVE_TEXTLAYOUT_SEGMENTS 0x954u
STACKSHOT_KCTYPE_KERN_EXCLAVES_CRASH_THREADINFO 0x955u
STACKSHOT_KCTYPE_LATENCY_INFO_CPU 0x956u
DYLD_AOT_IMAGE_KEY_SIZE 32
SS_TH_WAIT 0x01
SS_TH_SUSP 0x02
SS_TH_RUN 0x04
SS_TH_UNINT 0x08
SS_TH_TERMINATE 0x10
SS_TH_TERMINATE2 0x20
SS_TH_IDLE 0x80
KCDATA_INVALID_CS_TRUST_LEVEL 0xffffffff
STACKSHOT_WAITINFO_FLAGS_SPECIALREPLY 0x1
STACKSHOT_TURNSTILE_STATUS_UNKNOWN 0x01
STACKSHOT_TURNSTILE_STATUS_LOCKED_WAITQ 0x02
STACKSHOT_TURNSTILE_STATUS_WORKQUEUE 0x04
STACKSHOT_TURNSTILE_STATUS_THREAD 0x08
STACKSHOT_TURNSTILE_STATUS_BLOCKED_ON_TASK 0x10
STACKSHOT_TURNSTILE_STATUS_HELD_IPLOCK 0x20
STACKSHOT_TURNSTILE_STATUS_SENDPORT 0x40
STACKSHOT_TURNSTILE_STATUS_RECEIVEPORT 0x80
STACKSHOT_PORTLABEL_READFAILED 0x1
STACKSHOT_PORTLABEL_THROTTLED 0x2
MAX_CRASHINFO_SIGNING_ID_LEN 64
MAX_CRASHINFO_TEAM_ID_LEN 32
TASK_CRASHINFO_BEGIN KCDATA_BUFFER_BEGIN_CRASHINFO
TASK_CRASHINFO_STRING_DESC KCDATA_TYPE_STRING_DESC
TASK_CRASHINFO_UINT32_DESC KCDATA_TYPE_UINT32_DESC
TASK_CRASHINFO_UINT64_DESC KCDATA_TYPE_UINT64_DESC
TASK_CRASHINFO_EXTMODINFO 0x801
TASK_CRASHINFO_BSDINFOWITHUNIQID 0x802
TASK_CRASHINFO_TASKDYLD_INFO 0x803
TASK_CRASHINFO_UUID 0x804
TASK_CRASHINFO_PID 0x805
TASK_CRASHINFO_PPID 0x806
TASK_CRASHINFO_RUSAGE 0x807
TASK_CRASHINFO_RUSAGE_INFO 0x808
TASK_CRASHINFO_PROC_NAME 0x809
TASK_CRASHINFO_PROC_STARTTIME 0x80B
TASK_CRASHINFO_USERSTACK 0x80C
TASK_CRASHINFO_ARGSLEN 0x80D
TASK_CRASHINFO_EXCEPTION_CODES 0x80E
TASK_CRASHINFO_PROC_PATH 0x80F
TASK_CRASHINFO_PROC_CSFLAGS 0x810
TASK_CRASHINFO_PROC_STATUS 0x811
TASK_CRASHINFO_UID 0x812
TASK_CRASHINFO_GID 0x813
TASK_CRASHINFO_PROC_ARGC 0x814
TASK_CRASHINFO_PROC_FLAGS 0x815
TASK_CRASHINFO_CPUTYPE 0x816
TASK_CRASHINFO_WORKQUEUEINFO 0x817
TASK_CRASHINFO_RESPONSIBLE_PID 0x818
TASK_CRASHINFO_DIRTY_FLAGS 0x819
TASK_CRASHINFO_CRASHED_THREADID 0x81A
TASK_CRASHINFO_COALITION_ID 0x81B
TASK_CRASHINFO_UDATA_PTRS 0x81C
TASK_CRASHINFO_MEMORY_LIMIT 0x81D
TASK_CRASHINFO_LEDGER_INTERNAL 0x81E
TASK_CRASHINFO_LEDGER_INTERNAL_COMPRESSED 0x81F
TASK_CRASHINFO_LEDGER_IOKIT_MAPPED 0x820
TASK_CRASHINFO_LEDGER_ALTERNATE_ACCOUNTING 0x821
TASK_CRASHINFO_LEDGER_ALTERNATE_ACCOUNTING_COMPRESSED 0x822
TASK_CRASHINFO_LEDGER_PURGEABLE_NONVOLATILE 0x823
TASK_CRASHINFO_LEDGER_PURGEABLE_NONVOLATILE_COMPRESSED 0x824
TASK_CRASHINFO_LEDGER_PAGE_TABLE 0x825
TASK_CRASHINFO_LEDGER_PHYS_FOOTPRINT 0x826
TASK_CRASHINFO_LEDGER_PHYS_FOOTPRINT_LIFETIME_MAX 0x827
TASK_CRASHINFO_LEDGER_NETWORK_NONVOLATILE 0x828
TASK_CRASHINFO_LEDGER_NETWORK_NONVOLATILE_COMPRESSED 0x829
TASK_CRASHINFO_LEDGER_WIRED_MEM 0x82A
TASK_CRASHINFO_PROC_PERSONA_ID 0x82B
TASK_CRASHINFO_MEMORY_LIMIT_INCREASE 0x82C
TASK_CRASHINFO_LEDGER_TAGGED_FOOTPRINT 0x82D
TASK_CRASHINFO_LEDGER_TAGGED_FOOTPRINT_COMPRESSED 0x82E
TASK_CRASHINFO_LEDGER_MEDIA_FOOTPRINT 0x82F
TASK_CRASHINFO_LEDGER_MEDIA_FOOTPRINT_COMPRESSED 0x830
TASK_CRASHINFO_LEDGER_GRAPHICS_FOOTPRINT 0x831
TASK_CRASHINFO_LEDGER_GRAPHICS_FOOTPRINT_COMPRESSED 0x832
TASK_CRASHINFO_LEDGER_NEURAL_FOOTPRINT 0x833
TASK_CRASHINFO_LEDGER_NEURAL_FOOTPRINT_COMPRESSED 0x834
TASK_CRASHINFO_MEMORYSTATUS_EFFECTIVE_PRIORITY 0x835
TASK_CRASHINFO_KERNEL_TRIAGE_INFO_V1 0x836
TASK_CRASHINFO_TASK_IS_CORPSE_FORK 0x837
TASK_CRASHINFO_EXCEPTION_TYPE 0x838
TASK_CRASHINFO_CRASH_COUNT 0x839
TASK_CRASHINFO_THROTTLE_TIMEOUT 0x83A
TASK_CRASHINFO_CS_SIGNING_ID 0x83B
TASK_CRASHINFO_CS_TEAM_ID 0x83C
TASK_CRASHINFO_CS_VALIDATION_CATEGORY 0x83D
TASK_CRASHINFO_CS_TRUST_LEVEL 0x83E
TASK_CRASHINFO_PROC_CPUTYPE 0x83F
TASK_CRASHINFO_JIT_ADDRESS_RANGE 0x840
TASK_CRASHINFO_MB 0x841
TASK_CRASHINFO_CS_AUXILIARY_INFO 0x842
TASK_CRASHINFO_END KCDATA_TYPE_BUFFER_END
TASK_BTINFO_BEGIN KCDATA_BUFFER_BEGIN_BTINFO
TASK_BTINFO_PID 0xA01
TASK_BTINFO_PPID 0xA02
TASK_BTINFO_PROC_NAME 0xA03
TASK_BTINFO_PROC_PATH 0xA04
TASK_BTINFO_UID 0xA05
TASK_BTINFO_GID 0xA06
TASK_BTINFO_PROC_FLAGS 0xA07
TASK_BTINFO_CPUTYPE 0xA08
TASK_BTINFO_EXCEPTION_CODES 0xA09
TASK_BTINFO_EXCEPTION_TYPE 0xA0A
TASK_BTINFO_RUSAGE_INFO 0xA0B
TASK_BTINFO_COALITION_ID 0xA0C
TASK_BTINFO_CRASH_COUNT 0xA0D
TASK_BTINFO_THROTTLE_TIMEOUT 0xA0E
TASK_BTINFO_THREAD_ID 0xA20
TASK_BTINFO_THREAD_NAME 0xA21
TASK_BTINFO_THREAD_STATE 0xA22
TASK_BTINFO_THREAD_EXCEPTION_STATE 0xA23
TASK_BTINFO_BACKTRACE 0xA24
TASK_BTINFO_BACKTRACE64 0xA25
TASK_BTINFO_ASYNC_BACKTRACE64 0xA26
TASK_BTINFO_ASYNC_START_INDEX 0xA27
TASK_BTINFO_PLATFORM 0xA28
TASK_BTINFO_SC_LOADINFO 0xA29
TASK_BTINFO_SC_LOADINFO64 0xA2A
TASK_BTINFO_DYLD_LOADINFO KCDATA_TYPE_LIBRARY_LOADINFO
TASK_BTINFO_DYLD_LOADINFO64 KCDATA_TYPE_LIBRARY_LOADINFO64
TASK_BTINFO_FLAGS 0xAFF
TASK_BTINFO_FLAG_BT_TRUNCATED 0x1
TASK_BTINFO_FLAG_ASYNC_BT_TRUNCATED 0x2
TASK_BTINFO_FLAG_TASK_TERMINATED 0x4
TASK_BTINFO_FLAG_KCDATA_INCOMPLETE 0x8
TASK_BTINFO_END KCDATA_TYPE_BUFFER_END
EXIT_REASON_SNAPSHOT 0x1001
EXIT_REASON_USER_DESC 0x1002
EXIT_REASON_USER_PAYLOAD 0x1003
EXIT_REASON_CODESIGNING_INFO 0x1004
EXIT_REASON_WORKLOOP_ID 0x1005
EXIT_REASON_DISPATCH_QUEUE_NO 0x1006
EXIT_REASON_CODESIG_PATH_MAX 1024
EXIT_REASON_USER_DESC_MAX_LEN 1024
EXIT_REASON_PAYLOAD_MAX_LEN 2048
_STR_VALUE(x) #x
_SUBTYPE_TRUNC(t, s, f, name) do {     setup_subtype_description(&subtypes[i++], (t), offsetof(s, f), name);     _Static_assert(sizeof(name) == sizeof ((struct kcdata_subtype_descriptor *)0)->kcs_name, "\"" name "\" should fit exactly in kcs_name"); } while (0)
_SUBTYPE(t, s, f) do {     setup_subtype_description(&subtypes[i++], (t), offsetof(s, f), _STR_VALUE(f));     _Static_assert(sizeof(_STR_VALUE(f)) <= sizeof ((struct kcdata_subtype_descriptor *)0)->kcs_name, "\"" _STR_VALUE(f) "\" should fit in kcs_name"); } while (0)
_SUBTYPE_ARRAY(t, s, f, c) setup_subtype_array_description(&subtypes[i++], (t), offsetof(s, f), (c), _STR_VALUE(f))
_STRINGTYPE(f) setup_subtype_array_description(&subtypes[i++], KC_ST_CHAR, 0, UINT16_MAX, f)
_KDD_H_ None
BASE 65521L
NMAX 5552
DO1(buf, i)  {s1 += buf[i]; s2 += s1;}
DO2(buf, i)  DO1(buf,i); DO1(buf,i+1);
DO4(buf, i)  DO2(buf,i); DO2(buf,i+2);
DO8(buf, i)  DO4(buf,i); DO4(buf,i+4);
DO16(buf) DO8(buf,0); DO8(buf,8);
N 4096
F 18
THRESHOLD 2
IOKIT_ENABLE_SHARED_PTR None
BOOTER_KEXT_PREFIX "Driver-"
COM_APPLE "com.apple."
COM_APPLE_KEC "com.apple.kec."
PAD_SIZE PAGE_MAX_SIZE
_SECURITY_MAC_H_ None
_POSIX_MAC None
MAC_MAX_POLICY_NAME 32
MAC_MAX_LABEL_ELEMENT_NAME 32
MAC_MAX_LABEL_ELEMENT_DATA 4096
MAC_MAX_LABEL_BUF_LEN 8192
MAC_MAX_MANAGED_NAMESPACES 4
MAC_PROC_CHECK_SUSPEND 0
MAC_PROC_CHECK_RESUME 1
MAC_PROC_CHECK_HIBERNATE 2
MAC_PROC_CHECK_SHUTDOWN_SOCKETS 3
MAC_PROC_CHECK_PIDBIND 4
MAC_POLICY_LIST_CHUNKSIZE 8
_SECURITY_MAC_DATA_H_ None
MAC_DATA_TYPE_PRIMITIVE 0
MAC_DATA_TYPE_ARRAY 1
MAC_DATA_TYPE_DICT 2
_SECURITY_MAC_FRAMEWORK_H_ None
__IOKIT_PORTS_DEFINED__ None
VNODE_LABEL_CREATE 1
_SECURITY_MAC_INTERNAL_H_ None
MAC_POLICY_ITERATE(...) do {                                    struct mac_policy_conf *mpc;                                        u_int i;                                                                                                                                for (i = 0; i < mac_policy_list.staticmax; i++) {               	    mpc = mac_policy_list.entries[i].mpc;                       	    if (mpc == NULL)                                            	            continue;                                                                                                               	    __VA_ARGS__                                                     }                                                                   if (mac_policy_list_conditional_busy() != 0) {                  	    for (; i <= mac_policy_list.maxindex; i++) {                	            mpc = mac_policy_list.entries[i].mpc;               	            if (mpc == NULL)                                    	                    continue;                                                                                                       	            __VA_ARGS__                                         	    }                                                           	    mac_policy_list_unbusy();                                       }                                                               } while (0)
MAC_CHECK_CALL(check, mpc) DTRACE_MACF3(mac__call__ ## check, void *, mpc, int, error, int, MAC_ITERATE_CHECK)
MAC_CHECK_RSLT(check, mpc) DTRACE_MACF2(mac__rslt__ ## check, void *, mpc, int, __step_err)
MAC_CHECK(check, args...) do {                                       error = 0;                                                               MAC_POLICY_ITERATE({                                                 	    if (mpc->mpc_ops->mpo_ ## check != NULL) {                   	            MAC_CHECK_CALL(check, mpc);                          	            int __step_err = mpc->mpc_ops->mpo_ ## check (args); 	            MAC_CHECK_RSLT(check, mpc);                          	            error = mac_error_select(__step_err, error);         	    }                                                                });                                                                  } while (0)
MAC_GRANT(check, args...) do {                                  error = EPERM;                                                      MAC_POLICY_ITERATE({                                            	if (mpc->mpc_ops->mpo_ ## check != NULL) {                  	        DTRACE_MACF3(mac__call__ ## check, void *, mpc, int, error, int, MAC_ITERATE_GRANT); 	        int __step_res = mpc->mpc_ops->mpo_ ## check (args); 	        if (__step_res == 0) {                              	                error = 0;                                  	        }                                                   	        DTRACE_MACF2(mac__rslt__ ## check, void *, mpc, int, __step_res); 	    }                                                               });                                                             } while (0)
MAC_INTERNALIZE(obj, label, instring)                           mac_internalize(offsetof(struct mac_policy_ops, mpo_ ## obj ## _label_internalize), label, instring)
MAC_EXTERNALIZE(obj, label, elementlist, outbuf, outbuflen)     mac_externalize(offsetof(struct mac_policy_ops, mpo_ ## obj ## _label_externalize), label, elementlist, outbuf, outbuflen)
MAC_EXTERNALIZE_AUDIT(obj, label, outbuf, outbuflen)            mac_externalize(offsetof(struct mac_policy_ops, mpo_ ## obj ## _label_externalize_audit), label, "*", outbuf, outbuflen)
MAC_PERFORM_CALL(operation, mpc) DTRACE_MACF3(mac__call__ ## operation, void *, mpc, int, 0, int, MAC_ITERATE_PERFORM)
MAC_PERFORM_RSLT(operation, mpc) DTRACE_MACF2(mac__rslt__ ## operation, void *, mpc, int, 0)
MAC_PERFORM(operation, args...) do {                    MAC_POLICY_ITERATE({                                    	if (mpc->mpc_ops->mpo_ ## operation != NULL) {      	        MAC_PERFORM_CALL(operation, mpc);           	        mpc->mpc_ops->mpo_ ## operation (args);     	        MAC_PERFORM_RSLT(operation, mpc);           	}                                                       });                                                     } while (0)
_SECURITY_MAC_MACH_INTERNAL_H_ None
MAC_DOEXCF_TRACED 0x01
_SECURITY_MAC_POLICY_H_ None
MAC_PROC_IDENT_SUPPORT None
_KAUTH_CRED_T None
__IOKIT_PORTS_DEFINED__ None
NEEDS_RDAR_103115865 1
NEEDS_RDAR_132584934 1
MAC_POLICY_OPS_VERSION 87
mpc_t struct mac_policy_conf *
MAC_AUDIT_DATA_LIMIT 1024
MAC_AUDIT_DEFAULT 0
MAC_AUDIT_NO 1
MAC_AUDIT_YES 2
MPC_LOADTIME_FLAG_NOTLATE 0x00000001
MPC_LOADTIME_FLAG_UNLOADOK 0x00000002
MPC_LOADTIME_FLAG_LABELMBUFS 0x00000004
MPC_LOADTIME_BASE_POLICY 0x00000008
MPC_RUNTIME_FLAG_REGISTERED 0x00000001
POLICY_VER 1.0
MAC_POLICY_SET(handle, mpops, mpname, mpfullname, lnames, lcount, slot, lflags, rflags) 	static struct mac_policy_conf mpname##_mac_policy_conf = {      	        .mpc_name		= #mpname,                      	        .mpc_fullname		= mpfullname,                   	        .mpc_labelnames		= lnames,                       	        .mpc_labelname_count	= lcount,                       	        .mpc_ops		= mpops,                        	        .mpc_loadtime_flags	= lflags,                       	        .mpc_field_off		= slot,                         	        .mpc_runtime_flags	= rflags                        	};                                                                                                                                      	static kern_return_t                                            	kmod_start(kmod_info_t *ki, void *xd)                           	{                                                               	        return mac_policy_register(&mpname##_mac_policy_conf,   	            &handle, xd);                                       	}                                                                                                                                       	static kern_return_t                                            	kmod_stop(kmod_info_t *ki, void *xd)                            	{                                                               	        return mac_policy_unregister(handle);                   	}                                                                                                                                       	extern kern_return_t _start(kmod_info_t *ki, void *data);       	extern kern_return_t _stop(kmod_info_t *ki, void *data);                                                                                	KMOD_EXPLICIT_DECL(security.mpname, POLICY_VER, _start, _stop)  	kmod_start_func_t *_realmain = kmod_start;                      	kmod_stop_func_t *_antimain = kmod_stop;                        	int _kext_apple_cc = __APPLE_CC__
MAC_WAITOK 0
MAC_NOWAIT 1
_SECURITY_LABEL_H_ None
MAC_MAX_SLOTS 7
MAX_STACK_DEPTH 8
KHEAP_NUM_ZONES 22
DRIVER 1
NORMAL 2
INVISIBLE 3
PROFILING 4
CONFIGDEP 0x01
OPTIONSDEF 0x02
LIBRARYDEP 0x04
BOUND_CHECKS_MASK 0x78
BOUND_CHECKS_NONE 0x00
BOUND_CHECKS_PENDING 0x08
BOUND_CHECKS 0x10
BOUND_CHECKS_SOFT 0x18
BOUND_CHECKS_DEBUG 0x20
BOUND_CHECKS_SEED 0x40
BOUND_CHECKS_NEW_CHECKS 0x80
QUES -1
UNKNOWN -2
VPATH get_VPATH()
eq(a, b) (!strcmp(a,b))
DEV_MASK 0x7
DEV_SHIFT 3
next_word(fp, wd) 	{ const char *word = get_word(fp); 	  if (word == (char *)EOF) 	        return; 	  else 	        wd = word; 	}
OLDSALUTATION "# DO NOT DELETE THIS LINE"
LINESIZE 1024
_KCOV_H_ None
_KCOV_DATA_H_ None
USE_PC_TABLE 0
KSANCOV_MAX_DEV 64
KSANCOV_OD_SUPPORT 0x0010
KSANCOV_OD_LOGGING 0x0020
ksancov_od_log(...) do { 	        if (ksancov_od_logging_enabled) { 	                os_log_debug(OS_LOG_DEFAULT, __VA_ARGS__); 	        } 	} while (0)
_KCOV_KSANCOV_H_ None
_KCOV_KSANCOV_DATA_H_ None
_KCOV_STKSZ_H_ None
_KCOV_STKSZ_DATA_H_ None
KASAN_ARM64_MAP_STATIC_VALID_PAGE 0x1
KASAN_ARM64_PREALLOCATE_L1L2 0x2
KASAN_ARM64_NO_PHYSMAP 0x4
_KASAN_CLASSIC_ARM64_H_ None
STOLEN_MEM_PERCENT 13UL
STOLEN_MEM_BYTES MiB(40)
KASAN_OFFSET_ARM64 0xe000000000000000ULL
_KASAN_CLASSIC_H_ None
KASAN_SIZE_ALIGNMENT 0x7UL
KASAN_DEBUG 0
KASAN_DYNAMIC_BLACKLIST 1
KASAN_FAKESTACK 1
QUARANTINE_ENTRIES 5000
QUARANTINE_MAXSIZE MiB(4)
ASAN_VALID 0x00
ASAN_PARTIAL1 0x01
ASAN_PARTIAL2 0x02
ASAN_PARTIAL3 0x03
ASAN_PARTIAL4 0x04
ASAN_PARTIAL5 0x05
ASAN_PARTIAL6 0x06
ASAN_PARTIAL7 0x07
ASAN_ARRAY_COOKIE 0xac
ASAN_STACK_RZ 0xf0
ASAN_STACK_LEFT_RZ 0xf1
ASAN_STACK_MID_RZ 0xf2
ASAN_STACK_RIGHT_RZ 0xf3
ASAN_STACK_FREED 0xf5
ASAN_STACK_OOSCOPE 0xf8
ASAN_GLOBAL_RZ 0xf9
ASAN_HEAP_RZ 0xe9
ASAN_HEAP_LEFT_RZ 0xfa
ASAN_HEAP_RIGHT_RZ 0xfb
ASAN_HEAP_FREED 0xfd
KASAN_HEAP_ZALLOC 0
KASAN_HEAP_FAKESTACK 1
KASAN_HEAP_TYPES 2
FAKESTACK_HEADER_SZ 64
FAKESTACK_NUM_SZCLASS 7
FAKESTACK_UNUSED 0
FAKESTACK_ALLOCATED 1
FAKESTACK_FREED 2
FAKESTACK_DECLARE(szclass) uptr __asan_stack_malloc_##szclass(size_t sz)  { return kasan_fakestack_alloc(szclass, sz); } 	void FAKESTACK_NORETURN __asan_stack_free_##szclass (uptr dst, size_t sz)  { kasan_fakestack_free(szclass, dst, sz); }
REPORT_DECLARE(n) void OS_NORETURN __asan_report_load##n(uptr p)  { kasan_crash_report(p, n, TYPE_LOAD,  0); } 	void OS_NORETURN __asan_report_store##n(uptr p) { kasan_crash_report(p, n, TYPE_STORE, 0); } 	void OS_NORETURN UNSUPPORTED_API(__asan_report_exp_load##n, uptr a, int32_t b); 	void OS_NORETURN UNSUPPORTED_API(__asan_report_exp_store##n, uptr a, int32_t b);
ACCESS_CHECK_DECLARE(type, sz, access) 	void __asan_##type##sz(uptr addr) { 	        kasan_check_range((const void *)addr, sz, access); 	} 	void OS_NORETURN UNSUPPORTED_API(__asan_exp_##type##sz, uptr a, int32_t b);
ACCESS_CHECK_DECLARE(type, sz, access) 	void __asan_##type##sz(uptr addr) { 	        kasan_check_range((const void *)addr, sz, access); 	} 	void OS_NORETURN UNSUPPORTED_API(__asan_exp_##type##sz, uptr a, int32_t b);
SET_SHADOW_DECLARE(val) void __asan_set_shadow_##val(uptr addr, size_t sz) { 	        kasan_set_shadow(addr, sz, 0x##val); 	}
UNUSED_ABI(func, ...) 	_Pragma("clang diagnostic push") 	_Pragma("clang diagnostic ignored \"-Wunused-parameter\"") 	void func(__VA_ARGS__); 	void func(__VA_ARGS__) {}; 	_Pragma("clang diagnostic pop")
CRASH_CONTEXT_BEFORE 5
CRASH_CONTEXT_AFTER 5
CONTEXT_BLOCK_SIZE 16
KASAN_REPORT_BUFSIZE 4096
_KASAN_TBI_ARM64_H_ None
STOLEN_MEM_BYTES MiB(20)
KASAN_OFFSET_ARM64 0xf000000000000000ULL
P2ALIGN(x, align)           ((x) & -(align))
P2ROUNDUP(x, align)         (-(-(x) & -(align)))
KASAN_TBI_DEFAULT_TAG 0xFF
KASAN_TBI_DEFAULT_FREE_TAG 0xF0
KASAN_TBI_REDZONE_POISON 0x80
_KASAN_TBI_H_ None
KASAN_DEBUG 0
KASAN_DYNAMIC_BLACKLIST 1
KASAN_FAKESTACK 0
KASAN_SIZE_ALIGNMENT 0xFUL
STOLEN_MEM_PERCENT 25UL
STOLEN_MEM_BYTES 0
KASAN_ARGS_FAKESTACK 0x0010U
KASAN_ARGS_REPORTIGNORED 0x0020U
KASAN_ARGS_NODYCHECKS 0x0100U
KASAN_ARGS_NOPOISON_HEAP 0x0200U
KASAN_ARGS_NOPOISON_GLOBAL 0x0400U
_KASAN_H_ None
KASAN_GLOBAL_SEGNAME "__DATA"
KASAN_GLOBAL_SECTNAME "__asan_globals"
_KASAN_INTERNAL_H_ None
ALWAYS_INLINE inline __attribute__((always_inline))
_SAN_MEMINTRINSICS_H_ None
DEFINE_OVERFLOW(op) void __ubsan_handle_##op##_overflow(struct ubsan_overflow_desc *desc, uint64_t lhs, uint64_t rhs) { 	        ubsan_violation_t v = { UBSAN_OVERFLOW_##op, lhs, rhs, .overflow = desc, &desc->loc }; 	        ubsan_handle(&v, FleshWound); 	} 	void __ubsan_handle_##op##_overflow_abort(struct ubsan_overflow_desc *desc, uint64_t lhs, uint64_t rhs) { 	        ubsan_violation_t v = { UBSAN_OVERFLOW_##op, lhs, rhs, .overflow = desc, &desc->loc }; 	        ubsan_handle(&v, Fatal); 	}
_UBSAN_H_ None
UBSAN_MINIMAL_TRAPS_START UBSAN_SOFT_TRAP_SIGNED_OF
UBSAN_MINIMAL_TRAPS_END UBSAN_SOFT_TRAP_SIGNED_OF
UBSAN_M_ATTR __attribute__((always_inline, cold))
_UBSAN_MINIMAL_H_ None
_KSANCOV_H_ None
KSANCOV_DEVNODE "ksancov"
KSANCOV_PATH "/dev/" KSANCOV_DEVNODE
KSANCOV_IOC_TRACE _IOW('K', 1, size_t)
KSANCOV_IOC_COUNTERS _IO('K', 2)
KSANCOV_IOC_STKSIZE _IOW('K', 3, size_t)
KSANCOV_IOC_MAP _IOWR('K', 8, struct ksancov_buf_desc)
KSANCOV_IOC_MAP_EDGEMAP _IOWR('K', 9, struct ksancov_buf_desc)
KSANCOV_IOC_START _IOW('K', 10, uintptr_t)
KSANCOV_IOC_NEDGES _IOR('K', 50, size_t)
KSANCOV_IOC_ON_DEMAND _IOWR('K', 60, struct ksancov_on_demand_msg)
KSANCOV_MAX_HITS UINT8_MAX
FW_VERS_LEN 128
NUM 0
STR 1
ASSERT_IN_DT(p) assert_in_dt_region((vm_offset_t)DTRootNode, (vm_offset_t)DTEnd, (p))
ASSERT_PROP_IN_DT(prop) assert_prop_in_dt_region((vm_offset_t)DTRootNode, (vm_offset_t)DTEnd, (prop))
ASSERT_HEADER_IN_DT_REGION(start, end, p, size) assert_in_dt_region((start), (end), (uint8_t const *)(p) + (size))
ASSERT_HEADER_IN_DT(p, size) ASSERT_IN_DT((uint8_t const *)(p) + (size))
next_prop(prop) next_prop_region((vm_offset_t)DTRootNode, (vm_offset_t)DTEnd, (prop))
kFailedBootWidth 28
kFailedBootHeight 28
kFailedBootOffset -44
DEFAULT_UART_BAUD_RATE 115200
LEGACY_UART_PORT_ADDR COM1_PORT_ADDR
LEGACY_UART_CLOCK 1843200
IO_WRITE(r, v)  outb(LEGACY_UART_PORT_ADDR + UART_##r, v)
IO_READ(r) inb(LEGACY_UART_PORT_ADDR + UART_##r)
MMIO_UART2_BASE_LEGACY 0xFE034000
MMIO_UART2_BASE 0xFE036000
PCI_UART2 0xFE037000
MMIO_WRITE(r, v)  ml_phys_write_word(mmio_uart_base + MMIO_UART_##r, v)
MMIO_READ(r) ml_phys_read_word(mmio_uart_base + MMIO_UART_##r)
PCIE_MMIO_UART_BASE 0xFE410000
PCIE_MMIO_WRITE(r, v)  ml_phys_write_byte(pcie_mmio_uart_base + PCIE_MMIO_UART_##r, v)
PCIE_MMIO_READ(r) ml_phys_read_byte(pcie_mmio_uart_base + PCIE_MMIO_UART_##r)
_PEXPERT_BOOT_H_ None
_PEXPERT_DEVICE_TREE_H_ None
_PEXPERT_PEXPERT_H_ None
kPEICanHasAssertions 0x00000001
kPEICanHasStatistics 0x00000002
kPEICanHasDiagnosticAPI 0x00000004
_FN_KPRINTF None
kPEGraphicsMode 1
kPETextMode 2
kPETextScreen 3
kPEAcquireScreen 4
kPEReleaseScreen 5
kPEEnableScreen 6
kPEDisableScreen 7
kPEBaseAddressChange 8
kPERefreshBootGraphics 9
PE_default_value(_key, _variable, _default)     	do {                                                                                                                      	        if (!PE_get_default((_key), &(_variable), sizeof(_variable))) 	                _variable = _default;                                                                     	} while(0)
_PEXPERT_PROTOS_H_ None
_PEXPERT_ARM_AIC_H None
aic_read32(offset, data) (_aic_read32(pic_base + (offset)))
aic_write32(offset, data) (_aic_write32(pic_base + (offset), (data)))
_PEXPERT_ARM_APPLE_UART_REGS_H None
APPLE_UART None
_PEXPERT_ARM_BOARD_CONFIG_H None
_PEXPERT_ARM_BOOT_H_ None
BOOT_LINE_LENGTH 256
kBootArgsRevision 1
kBootArgsRevision2 2
kBootArgsVersion1 1
kBootArgsVersion2 2
SOC_DEVICE_TYPE_BUFFER_SIZE 32
PC_TRACE_BUF_SIZE 1024
PE_CONSISTENT_DEBUG_H None
DEBUG_RECORD_ID_LONG(a, b, c, d, e, f, g, h) 	( ((uint64_t)(	(((h) << 24) & 0xFF000000) | 	                (((g) << 16) & 0x00FF0000) | 	                (((f) <<  8) & 0x0000FF00) | 	                ((e)         & 0x000000FF) ) << 32) | 	  (uint64_t)(	(((d) << 24) & 0xFF000000) | 	                (((c) << 16) & 0x00FF0000) | 	                (((b) <<  8) & 0x0000FF00) | 	                ((a)         & 0x000000FF) ) )
DEBUG_RECORD_ID_SHORT(a, b, c, d) DEBUG_RECORD_ID_LONG(a,b,c,d,0,0,0,0)
DbgIdConsoleHeaderForIOP(which_dbg_processor, which_num) (DEBUG_RECORD_ID_LONG('C','O','N',0,0,0,which_dbg_processor,which_num))
kDbgIdConsoleHeaderAP DbgIdConsoleHeaderForIOP(DBG_PROCESSOR_AP, 0)
kDbgIdConsoleHeaderANS DbgIdConsoleHeaderForIOP(DBG_COPROCESSOR_ANS, 0)
kDbgIdConsoleHeaderSIO DbgIdConsoleHeaderForIOP(DBG_COPROCESSOR_SIO, 0)
kDbgIdConsoleHeaderSEP DbgIdConsoleHeaderForIOP(DBG_COPROCESSOR_SEP, 0)
kDbgIdConsoleHeaderISP DbgIdConsoleHeaderForIOP(DBG_COPROCESSOR_ISP, 0)
kDbgIdConsoleHeaderOscar DbgIdConsoleHeaderForIOP(DBG_COPROCESSOR_OSCAR, 0)
kDbgIdAstrisConnection DEBUG_RECORD_ID_LONG('A','S','T','R','C','N','X','N')
kDbgIdAstrisConnectionVers DEBUG_RECORD_ID_LONG('A','S','T','R','C','V','E','R')
kDbgIdMacOSPanicRegion DEBUG_RECORD_ID_LONG('M','A','C','P','A','N','I','C')
kDbgIdUnusedEntry 0x0ULL
kDbgIdReservedEntry DEBUG_RECORD_ID_LONG('R','E','S','E','R','V','E', 'D')
kDbgIdFreeReqEntry DEBUG_RECORD_ID_LONG('F','R','E','E','-','R','E','Q')
kDbgIdFreeAckEntry DEBUG_RECORD_ID_LONG('F','R','E','E','-','A','C','K')
DEBUG_REGISTRY_MAX_RECORDS 512
CPR_MAX_STATE_ENTRIES 16
_PEXPERT_ARM_DOCKCHANNEL_H None
rDOCKCHANNELS_DEV_WR_WATERMARK(_base, _ch)     ((uintptr_t) ((_base) + ((_ch) * DOCKCHANNEL_STRIDE) + 0x0000))
rDOCKCHANNELS_DEV_RD_WATERMARK(_base, _ch)     ((uintptr_t) ((_base) + ((_ch) * DOCKCHANNEL_STRIDE) + 0x0004))
rDOCKCHANNELS_DEV_DRAIN_CFG(_base, _ch)        ((uintptr_t) ((_base) + ((_ch) * DOCKCHANNEL_STRIDE) + 0x0008))
rDOCKCHANNELS_DEV_WDATA1(_base, _ch)           ((uintptr_t) ((_base) + ((_ch) * DOCKCHANNEL_STRIDE) + 0x4004))
rDOCKCHANNELS_DEV_WSTAT(_base, _ch)            ((uintptr_t) ((_base) + ((_ch) * DOCKCHANNEL_STRIDE) + 0x4014))
rDOCKCHANNELS_DEV_RDATA0(_base, _ch)           ((uintptr_t) ((_base) + ((_ch) * DOCKCHANNEL_STRIDE) + 0x4018))
rDOCKCHANNELS_DEV_RDATA1(_base, _ch)           ((uintptr_t) ((_base) + ((_ch) * DOCKCHANNEL_STRIDE) + 0x401c))
rDOCKCHANNELS_DOCK_RDATA1(_base, _ch)          ((uintptr_t) ((_base) + ((_ch) * DOCKCHANNEL_STRIDE) + 0xc01c))
rDOCKCHANNELS_DOCK_RDATA3(_base, _ch)          ((uintptr_t) ((_base) + ((_ch) * DOCKCHANNEL_STRIDE) + 0xc024))
_PEXPERT_ARM_PL192_VIC_H None
ARM_CELL_PL192_VIC None
_PEXPERT_ARM_PROTOS_H None
_PEXPERT_ARM_AIC_H None
aic_read32(offset, data) (_aic_read32(pic_base + (offset)))
aic_write32(offset, data) (_aic_write32(pic_base + (offset), (data)))
_PEXPERT_ARM64_APPLE_ARM64_COMMON_H None
__ARM_ARCH__ 8
__ARM_VMSA__ 8
__ARM_VFP__ 4
__ARM_COHERENT_CACHE__ 1
__ARM_COHERENT_IO__ 1
__ARM_IC_NOALIAS_ICACHE__ 1
__ARM_DEBUG__ 7
__ARM_ENABLE_SWAP__ 1
__ARM_V8_CRYPTO_EXTENSIONS__ 1
__ARM64_PMAP_SUBPAGE_L1__ 1
APPLE_ARM64_ARCH_FAMILY 1
ARM_ARCH_TIMER None
CPU_VERSION_A0 0x00
CPU_VERSION_A1 0x01
CPU_VERSION_B0 0x10
CPU_VERSION_B1 0x11
CPU_VERSION_C0 0x20
CPU_VERSION_UNKNOWN 0xff
BTI_ENFORCED 1
_PEXPERT_ARM64_COMMON_H None
_PEXPERT_ARM64_APT_MSG_H None
APT_MSG_NS_KERN 0
APT_MSG_KERN_CSWITCH_TIME 0
_PEXPERT_ARM_BOARD_CONFIG_H None
MAX_L2_CLINE 7
MAX_CPUS 20
MAX_CPU_CLUSTERS 6
MAX_CPU_CLUSTER_PHY_ID 10
HAS_IOA 1
PMAP_CS 1
PMAP_CS_ENABLE 1
XNU_MONITOR 1
__ARM_42BIT_PA_SPACE__ 1
USE_APPLEARMSMP 1
XNU_HANDLE_MCC 1
NO_XNU_PLATFORM_ERROR_HANDLER 1
MAX_L2_CLINE 7
MAX_CPUS 24
MAX_CPU_CLUSTERS 6
MAX_CPU_CLUSTER_PHY_ID 10
HAS_IOA 1
PMAP_CS 1
PMAP_CS_ENABLE 1
XNU_MONITOR 1
__ARM_42BIT_PA_SPACE__ 1
USE_APPLEARMSMP 1
XNU_CLUSTER_POWER_DOWN 1
RHODES_CLUSTER_POWERDOWN_WORKAROUND 1
XNU_PLATFORM_ERROR_HANDLER 1
XNU_HANDLE_ECC 1
XNU_HANDLE_MCC 1
EXTENDED_USER_VA_SUPPORT 1
MAX_L2_CLINE 7
MAX_CPUS 8
MAX_CPU_CLUSTERS 2
PMAP_CS 1
PMAP_CS_ENABLE 1
XNU_MONITOR 1
NO_XNU_PLATFORM_ERROR_HANDLER 1
MAX_L2_CLINE 7
MAX_CPUS 8
MAX_CPU_CLUSTERS 2
PMAP_CS 1
PMAP_CS_ENABLE 1
XNU_MONITOR 1
NO_XNU_PLATFORM_ERROR_HANDLER 1
MAX_L2_CLINE 7
MAX_CPUS 8
MAX_CPU_CLUSTERS 2
PMAP_CS 1
PMAP_CS_ENABLE 1
XNU_MONITOR 1
USE_APPLEARMSMP 1
NO_XNU_PLATFORM_ERROR_HANDLER 1
MAX_L2_CLINE 7
MAX_CPUS 8
MAX_CPU_CLUSTERS 2
HAS_IOA 1
PMAP_CS 1
PMAP_CS_ENABLE 1
XNU_MONITOR 1
__ARM_42BIT_PA_SPACE__ 1
USE_APPLEARMSMP 1
XNU_PLATFORM_ERROR_HANDLER 1
XNU_HANDLE_MCC 1
MAX_L2_CLINE 7
MAX_CPUS 10
MAX_CPU_CLUSTERS 2
PMAP_CS 1
PMAP_CS_ENABLE 1
XNU_MONITOR 1
__ARM_42BIT_PA_SPACE__ 1
USE_APPLEARMSMP 1
XNU_PLATFORM_ERROR_HANDLER 1
XNU_HANDLE_MCC 1
NO_CPU_OVRD 1
MAX_L2_CLINE 7
MAX_CPUS 12
MAX_CPU_CLUSTERS 2
HAS_IOA 1
PMAP_CS 1
PMAP_CS_ENABLE 1
XNU_MONITOR 1
__ARM_42BIT_PA_SPACE__ 1
USE_APPLEARMSMP 1
XNU_PLATFORM_ERROR_HANDLER 1
XNU_HANDLE_MCC 1
MAX_L2_CLINE 7
MAX_CPUS 32
MAX_CPU_CLUSTERS 6
MAX_CPU_CLUSTER_PHY_ID 10
HAS_IOA 1
PMAP_CS 1
PMAP_CS_ENABLE 1
XNU_MONITOR 1
__ARM_42BIT_PA_SPACE__ 1
USE_APPLEARMSMP 1
XNU_CLUSTER_POWER_DOWN 1
RHODES_CLUSTER_POWERDOWN_WORKAROUND 1
MAX_L2_CLINE 7
MAX_CPUS 32
MAX_CPU_CLUSTERS 1
CORE_NCTRS 2
USE_APPLEARMSMP 1
NO_XNU_PLATFORM_ERROR_HANDLER 1
_PEXPERT_ARM64_BOOT_H_ None
BOOT_LINE_LENGTH 1024
kBootArgsRevision 1
kBootArgsRevision2 2
kBootArgsVersion1 1
kBootArgsVersion2 2
SOC_DEVICE_TYPE_BUFFER_SIZE 32
PC_TRACE_BUF_SIZE 1024
_PEXPERT_ARM64_H13_H None
APPLEFIRESTORM None
NO_MONITOR 1
HAS_EL2 1
HAS_CTRR 1
HAS_NEX_PG 1
HAS_BP_RET 1
HAS_CONTINUOUS_HWCLOCK 1
HAS_IPI 1
HAS_CLUSTER 1
HAS_RETENTION_STATE 1
HAS_UCNORMAL_MEM 1
HAS_FAST_CNTVCT 1
HAS_ACNTVCT 1
HAS_ARM_FEAT_SSBS2 1
HAS_USAT_BIT 1
HAS_E0PD 1
HAS_CPU_DPE_COUNTER 1
HAS_GUARDED_IO_FILTER 1
HAS_SPECRES 1
CPU_HAS_APPLE_PAC 1
HAS_UNCORE_CTRS 1
UNCORE_VERSION 2
UNCORE_PER_CLUSTER 1
UNCORE_NCTRS 16
CORE_NCTRS 10
HAS_CPMU_PC_CAPTURE 1
CPMU_PMC_COUNT 10
CPMU_INSTRUCTION_MATCHING 1
CPMU_MEMORY_FILTERING 1
HAS_UPMU 1
UPMU_VERSION 2
UPMU_PMC_COUNT 16
UPMU_PER_CLUSTER 1
UPMU_AF_LATENCY 1
UPMU_META_EVENTS 1
__ARM_AMP__ 1
__ARM_16K_PG__ 1
__ARM_GLOBAL_SLEEP_BIT__ 1
__ARM_PAN_AVAILABLE__ 1
__ARM_SB_AVAILABLE__ 1
__HWP_CFG_BIT_VER__ 1
ARM_PARAMETERIZED_PMAP 1
__ARM_MIXED_PAGE_SIZE__ 1
__ARM_RANGE_TLBI__ 1
_PEXPERT_ARM64_H14_H None
APPLEAVALANCHE None
NO_MONITOR 1
HAS_EL2 1
HAS_CTRR 1
HAS_NEX_PG 1
HAS_BP_RET 1
HAS_CONTINUOUS_HWCLOCK 1
HAS_IPI 1
HAS_CLUSTER 1
HAS_RETENTION_STATE 1
HAS_UCNORMAL_MEM 1
HAS_FAST_CNTVCT 1
HAS_ACNTVCT 1
HAS_USAT_BIT 1
HAS_ARM_FEAT_SSBS2 1
HAS_E0PD 1
HAS_ACFG 1
HAS_AMDSCR 1
HAS_HCR_TSC_RW 1
HAS_CPU_DPE_COUNTER 1
HAS_GUARDED_IO_FILTER 1
HAS_SPECRES 1
HAS_ERRATA_123855614 1
HAS_BTI 1
CPU_HAS_APPLE_PAC 1
HAS_UNCORE_CTRS 1
UNCORE_VERSION 2
UNCORE_PER_CLUSTER 1
UNCORE_NCTRS 16
CORE_NCTRS 10
HAS_CPMU_PC_CAPTURE 1
CPMU_PMC_COUNT 10
CPMU_INSTRUCTION_MATCHING 1
CPMU_MEMORY_FILTERING 1
CPMU_64BIT_PMCS 1
HAS_UPMU 1
UPMU_VERSION 2
UPMU_PMC_COUNT 16
UPMU_PER_CLUSTER 1
UPMU_AF_LATENCY 1
UPMU_META_EVENTS 1
UPMU_64BIT_PMCS 1
__ARM_AMP__ 1
__ARM_16K_PG__ 1
__ARM_GLOBAL_SLEEP_BIT__ 1
__ARM_PAN_AVAILABLE__ 1
__ARM_SB_AVAILABLE__ 1
__HWP_CFG_BIT_VER__ 2
ARM_PARAMETERIZED_PMAP 1
__ARM_MIXED_PAGE_SIZE__ 1
__ARM_RANGE_TLBI__ 1
_PEXPERT_ARM64_H15_H None
APPLEEVEREST None
NO_MONITOR 1
HAS_EL2 1
HAS_CTRR 1
HAS_NEX_PG 1
HAS_BP_RET 1
HAS_CONTINUOUS_HWCLOCK 1
HAS_IPI 1
HAS_CLUSTER 1
HAS_RETENTION_STATE 1
HAS_UCNORMAL_MEM 1
HAS_FAST_CNTVCT 1
HAS_USAT_BIT 1
HAS_ARM_FEAT_SSBS2 1
HAS_E0PD 1
HAS_APPLE_GENERIC_TIMER 1
HAS_ARM_FEAT_PAN3 1
HAS_ACFG 1
HAS_AMDSCR 1
HAS_HCR_TSC_RW 1
HAS_EL1_SHAREABILITY_BOUNDARY 1
HAS_CPU_DPE_COUNTER 1
HAS_BTI 1
HAS_GUARDED_IO_FILTER 1
HAS_SPECRES 1
HAS_ERRATA_123855614 1
CPU_HAS_APPLE_PAC 1
HAS_UNCORE_CTRS 1
UNCORE_VERSION 2
UNCORE_PER_CLUSTER 1
UNCORE_NCTRS 16
CORE_NCTRS 10
HAS_CPMU_PC_CAPTURE 1
CPMU_PMC_COUNT 10
CPMU_INSTRUCTION_MATCHING 1
CPMU_MEMORY_FILTERING 1
CPMU_64BIT_PMCS 1
CPMU_16BIT_EVENTS 1
HAS_UPMU 1
UPMU_VERSION 2
UPMU_PMC_COUNT 16
UPMU_PER_CLUSTER 1
UPMU_AF_LATENCY 1
UPMU_META_EVENTS 1
UPMU_64BIT_PMCS 1
__ARM_AMP__ 1
__ARM_16K_PG__ 1
__ARM_GLOBAL_SLEEP_BIT__ 1
__ARM_PAN_AVAILABLE__ 1
__ARM_SB_AVAILABLE__ 1
__HWP_CFG_BIT_VER__ 2
__APPLE_NV__ 1
__APPLE_NV1__ 1
ARM_PARAMETERIZED_PMAP 1
__ARM_MIXED_PAGE_SIZE__ 1
__ARM_RANGE_TLBI__ 1
_PEXPERT_ARM64_H16_H None
APPLEH16 None
NO_MONITOR 1
HAS_EL2 1
HAS_CTRR3 1
HAS_CONTINUOUS_HWCLOCK 1
HAS_IPI 1
HAS_CLUSTER 1
HAS_RETENTION_STATE 1
HAS_DPC_ERR 1
HAS_UCNORMAL_MEM 1
HAS_FAST_CNTVCT 1
HAS_E0PD 1
HAS_ACFG 1
HAS_AMDSCR 1
HAS_HCR_TSC_RW 1
HAS_APPLE_GENERIC_TIMER 1
HAS_CPM_PWRDN_CTL 1
HAS_EL1_SHAREABILITY_BOUNDARY 1
HAS_CPU_DPE_COUNTER 1
HAS_GUARDED_IO_FILTER 1
HAS_ACFG_DIS_DC_OPS 1
HAS_16BIT_ASID 1
HAS_FEAT_XS 1
HAS_DC_INCPA 1
HAS_ARM_FEAT_SME 1
HAS_ARM_FEAT_SME2 1
HAS_SPECRES 1
HAS_ERRATA_123855614 1
HAS_BTI 1
HAS_GUARDED_IO_FILTER 1
CPU_HAS_APPLE_PAC 1
HAS_UNCORE_CTRS 1
UNCORE_VERSION 2
UNCORE_PER_CLUSTER 1
UNCORE_NCTRS 16
CORE_NCTRS 10
HAS_CPMU_PC_CAPTURE 1
CPMU_PMC_COUNT 10
CPMU_INSTRUCTION_MATCHING 1
CPMU_MEMORY_FILTERING 1
CPMU_64BIT_PMCS 1
CPMU_16BIT_EVENTS 1
HAS_UPMU 1
UPMU_VERSION 2
UPMU_PMC_COUNT 16
UPMU_PER_CLUSTER 1
UPMU_AF_LATENCY 1
UPMU_META_EVENTS 1
UPMU_64BIT_PMCS 1
__ARM_AMP__ 1
__ARM_16K_PG__ 1
__ARM_GLOBAL_SLEEP_BIT__ 1
__ARM_PAN_AVAILABLE__ 1
__APPLE_WKDM_EXTENSIONS__ 1
__APPLE_WKDM_POPCNT_EXTENSIONS__ 1
__APPLE_WKDM_POPCNT_COMPRESSED_DATA__ 1
__ARM_SB_AVAILABLE__ 1
__HWP_CFG_BIT_VER__ 2
ARM_PARAMETERIZED_PMAP 1
__ARM_MIXED_PAGE_SIZE__ 1
__ARM_RANGE_TLBI__ 1
_PEXPERT_ARM64_PLATFORM_H_ None
SPDS_ENABLE_STRUCTS 1
SPDS_ENABLE_ENUMS 1
NOQUOTE(x) x
COMBINE3(a, b, c)                       NOQUOTE(a)NOQUOTE(b)NOQUOTE(c)
COMBINE5(a, b, c, d, e)                 NOQUOTE(a)NOQUOTE(b)NOQUOTE(c)NOQUOTE(d)NOQUOTE(e)
COMBINE7(a, b, c, d, e, f, g)           NOQUOTE(a)NOQUOTE(b)NOQUOTE(c)NOQUOTE(d)NOQUOTE(e)NOQUOTE(f)NOQUOTE(g)
SUB_PLATFORM_HEADER(x) <COMBINE5(platform/,x,_,ARM64_SOC_NAME,.h)>
SUB_PLATFORM_SOC_HEADER(x) <COMBINE5(platform/soc/,x,_,ARM64_SOC_NAME,.h)>
SUB_PLATFORM_NONMODULE_HEADER(x) <COMBINE5(soc/,PLATFORM_SPDS_CHIP_REV_LC,/,x,.h)>
SUB_PLATFORM_SPDS_HEADER(x) <COMBINE5(soc/,PLATFORM_SPDS_CHIP_REV_LC,/module/,x,.h)>
SUB_PLATFORM_TARGET_HEADER(x) <COMBINE5(target/,x,_,ARM64_SOC_NAME,.h)>
SUB_PLATFORM_TUNABLE_HEADER(r, x)       <COMBINE7(platform/soc/tunables/,ARM64_SOC_NAME,/,r,/,x,.h)>
SUB_TARGET_TUNABLE_HEADER(r, t, x)      <COMBINE7(target/tunables/,t,/,r,/,x,.h)>
ARM64_SOC_NAME CURRENT_MACHINE_CONFIG_LC
SPDS_CHIP_REV_LC latest
PLATFORM_SPDS_CHIP_REV_LC ARM64_SOC_NAME/SPDS_CHIP_REV_LC
_PEXPERT_ARM64_VMAPPLE_H None
NO_MONITOR 1
NO_ECORE 1
VMAPPLE 1
APPLEVIRTUALPLATFORM 1
CPU_HAS_APPLE_PAC 1
HAS_PARAVIRTUALIZED_PAC 1
HAS_GIC_V3 1
HAS_ARM_FEAT_SSBS2 1
HAS_ARM_FEAT_SME 1
HAS_ARM_FEAT_SME2 1
HAS_ARM_FEAT_PAN3 1
__ARM_PAN_AVAILABLE__ 1
__ARM_16K_PG__ 1
__ARM_RANGE_TLBI__ 1
ARM_PARAMETERIZED_PMAP 1
__ARM_MIXED_PAGE_SIZE__ 1
PL011_UART None
PLATFORM_PANIC_LOG_DISABLED None
GIC_SPURIOUS_IRQ 1023
GICR_PE_SIZE 0x20000
GICD_CTLR 0x0
GICD_CTLR_ENABLEGRP0 0x1
GICR_TYPER 0x08
GICR_WAKER 0x14
GICR_IGROUPR0 0x10080
GICR_ISENABLER0 0x10100
GICR_TYPER_AFFINITY_VALUE_SHIFT 32
GICR_TYPER_LAST 0x10
GICR_WAKER_PROCESSORSLEEP 0x2
GICR_WAKER_CHILDRENASLEEP 0x4
ICC_CTLR_EOIMODE 0x1
ICC_SRE_SRE 0x1
_PEXPERT_I386_BOOT_H None
BOOT_LINE_LENGTH 1024
BOOT_STRING_LEN BOOT_LINE_LENGTH
GRAPHICS_MODE 1
FB_TEXT_MODE 2
kBootArgsRevision 0
kBootArgsRevision0 kBootArgsRevision
kBootArgsRevision1 1
kBootArgsVersion 2
kBootArgsVersion1 1
kBootArgsVersion2 2
kBootArgsRevision2_0 0
kBootArgsEfiMode32 32
kBootArgsEfiMode64 64
_PEXPERT_I386_EFI_H None
EFI_RUNTIMESERVICE None
EFIAPI None
IN None
OUT None
OPTIONAL None
EFI_MAX_BIT 0x80000000
EFI_SUCCESS 0
EFI_LOAD_ERROR EFIERR (1)
EFI_INVALID_PARAMETER EFIERR (2)
EFI_UNSUPPORTED EFIERR (3)
EFI_BAD_BUFFER_SIZE EFIERR (4)
EFI_BUFFER_TOO_SMALL EFIERR (5)
EFI_NOT_READY EFIERR (6)
EFI_DEVICE_ERROR EFIERR (7)
EFI_WRITE_PROTECTED EFIERR (8)
EFI_OUT_OF_RESOURCES EFIERR (9)
EFI_VOLUME_CORRUPTED EFIERR (10)
EFI_VOLUME_FULL EFIERR (11)
EFI_NO_MEDIA EFIERR (12)
EFI_MEDIA_CHANGED EFIERR (13)
EFI_NOT_FOUND EFIERR (14)
EFI_ACCESS_DENIED EFIERR (15)
EFI_NO_RESPONSE EFIERR (16)
EFI_NO_MAPPING EFIERR (17)
EFI_TIMEOUT EFIERR (18)
EFI_NOT_STARTED EFIERR (19)
EFI_ALREADY_STARTED EFIERR (20)
EFI_ABORTED EFIERR (21)
EFI_ICMP_ERROR EFIERR (22)
EFI_TFTP_ERROR EFIERR (23)
EFI_PROTOCOL_ERROR EFIERR (24)
EFI_INCOMPATIBLE_VERSION EFIERR (25)
EFI_SECURITY_VIOLATION EFIERR (26)
EFI_CRC_ERROR EFIERR (27)
EFI_WARN_UNKNOWN_GLYPH EFIWARN (1)
EFI_WARN_DELETE_FAILURE EFIWARN (2)
EFI_WARN_WRITE_FAILURE EFIWARN (3)
EFI_WARN_BUFFER_TOO_SMALL EFIWARN (4)
EFI_SPECIFICATION_MAJOR_REVISION 1
EFI_SPECIFICATION_MINOR_REVISION 10
APPLE_VENDOR_GUID {0xAC39C713, 0x7E50, 0x423D, {0x88, 0x9D, 0x27,0x8F, 0xCC, 0x34, 0x22, 0xB6} }
EFI_GLOBAL_VARIABLE_GUID {0x8BE4DF61, 0x93CA, 0x11d2, {0xAA, 0x0D, 0x00, 0xE0, 0x98, 0x03, 0x2B, 0x8C} }
EFI_TIME_ADJUST_DAYLIGHT 0x01
EFI_TIME_IN_DAYLIGHT 0x02
EFI_UNSPECIFIED_TIMEZONE 0x07FF
EFI_MEMORY_UC 0x0000000000000001ULL
EFI_MEMORY_WC 0x0000000000000002ULL
EFI_MEMORY_WT 0x0000000000000004ULL
EFI_MEMORY_WB 0x0000000000000008ULL
EFI_MEMORY_UCE 0x0000000000000010ULL
EFI_MEMORY_WP 0x0000000000001000ULL
EFI_MEMORY_RP 0x0000000000002000ULL
EFI_MEMORY_XP 0x0000000000004000ULL
EFI_MEMORY_RUNTIME 0x8000000000000000ULL
EFI_MEMORY_DESCRIPTOR_VERSION 1
EFI_VARIABLE_NON_VOLATILE 0x00000001
EFI_VARIABLE_BOOTSERVICE_ACCESS 0x00000002
EFI_VARIABLE_RUNTIME_ACCESS 0x00000004
EFI_VARIABLE_READ_ONLY 0x00000008
EFI_RUNTIME_SERVICES_SIGNATURE 0x56524553544e5552ULL
EFI_SYSTEM_TABLE_SIGNATURE 0x5453595320494249ULL
_PEXPERT_I386_PROTOS_H None
__IN(s, u) static __inline__ unsigned u in##s(i386_ioport_t port) {     unsigned u data;     asm volatile ( 	"in" #s " %1,%0" 	: "=a" (data) 	: "d" (port));     return (data); }
__OUT(s, u) static __inline__ void out##s(i386_ioport_t port, unsigned u data) {     asm volatile ( 	"out" #s " %1,%0" 	: 	: "d" (port), "a" (data)); }
_PEXPERT_MACHINE_BOOT_H None
_PEXPERT_MACHINE_PROTOS_H None
NEED_STUB 1
PANIC_TRACE_LOG 1
panic_trace_error(msg, args...) { if (panic_trace_debug == 1) kprintf("panic_trace: " msg "\n", ##args); else if (panic_trace_debug == 2) printf("panic_trace: " msg "\n", ##args); }
panic_trace_log(msg, args...) { if (panic_trace_debug) panic_trace_error(msg, ##args); }
_ARM_ARCH_H None
dyldLogFunc(msg, ...)
_ARM_ASM_H_ None
FRAME pushl %ebp; movl %esp, %ebp
EMARF leave
FALIGN ALIGN
LB(x,n) n
String .asciz
Value .word
Entry(x) .globl EXT(x); ELF_FUNC(EXT(x)); .align FALIGN; LEXT(x)
ENTRY(x) Entry(x) MCOUNT
ENTRY2(x,y) .globl EXT(x); .globl EXT(y); 			ELF_FUNC(EXT(x)); ELF_FUNC(EXT(y)); 			.align FALIGN; LEXT(x); LEXT(y) 			MCOUNT
DATA(x) .globl EXT(x); ELF_DATA(EXT(x)); .align ALIGN; LEXT(x)
End(x) ELF_SIZE(x,.-x)
END(x) End(EXT(x))
ENDDATA(x) END(x)
Enddata(x) End(x)
_ARM_ATOMIC_H_ None
DMB_OSHLD 0x1
DMB_OSHST 0x2
DMB_OSH 0x3
DMB_NSHLD 0x5
DMB_NSHST 0x6
DMB_NSH 0x7
DMB_ISHLD 0x9
DMB_ISHST 0xa
DMB_ISH 0xb
DMB_LD 0xd
DMB_ST 0xe
DMB_SY 0xf
DSB_OSHLD 0x1
DSB_OSHST 0x2
DSB_OSH 0x3
DSB_NSHLD 0x5
DSB_NSHST 0x6
DSB_NSH 0x7
DSB_ISHLD 0x9
DSB_ISHST 0xa
DSB_ISH 0xb
DSB_LD 0xd
DSB_ST 0xe
DSB_SY 0xf
ISB_SY 0xf
LWOpDone 1
BWOpDone 3
_ARM_CACHES_INTERNAL 1
_MACHINE_CPUID_H_ None
CPU_VID_ARM 0x41
CPU_VID_DEC 0x44
CPU_VID_MOTOROLA 0x4D
CPU_VID_MARVELL 0x56
CPU_VID_INTEL 0x69
CPU_VID_APPLE 0x61
CPU_ARCH_ARMv4 0x1
CPU_ARCH_ARMv4T 0x2
CPU_ARCH_ARMv5 0x3
CPU_ARCH_ARMv5T 0x4
CPU_ARCH_ARMv5TE 0x5
CPU_ARCH_ARMv5TEJ 0x6
CPU_ARCH_ARMv6 0x7
CPU_ARCH_ARMv7 0x8
CPU_ARCH_ARMv7f 0x9
CPU_ARCH_ARMv7s 0xa
CPU_ARCH_ARMv7k 0xb
CPU_ARCH_ARMv8 0xc
CPU_ARCH_ARMv8E 0xd
CPU_ARCH_EXTENDED 0xF
CPU_PART_920T 0x920
CPU_PART_926EJS 0x926
CPU_PART_1136JFS 0xB36
CPU_PART_1176JZFS 0xB76
CPU_PART_CORTEXA5 0xC05
CPU_PART_CORTEXA7 0xC07
CPU_PART_CORTEXA8 0xC08
CPU_PART_CORTEXA9 0xC09
CPU_PART_TYPHOON 0x2
CPU_PART_TYPHOON_CAPRI 0x3
CPU_PART_TWISTER 0x4
CPU_PART_TWISTER_ELBA_MALTA 0x5
CPU_PART_HURRICANE 0x6
CPU_PART_HURRICANE_MYST 0x7
CPU_PART_MONSOON 0x8
CPU_PART_MISTRAL 0x9
CPU_PART_VORTEX 0xB
CPU_PART_TEMPEST 0xC
CPU_PART_TEMPEST_M9 0xF
CPU_PART_VORTEX_ARUBA 0x10
CPU_PART_TEMPEST_ARUBA 0x11
CPU_PART_LIGHTNING 0x12
CPU_PART_THUNDER 0x13
CPU_PART_THUNDER_M10 0x26
CPU_PART_ICESTORM 0x20
CPU_PART_FIRESTORM 0x21
CPU_PART_ICESTORM_TONGA 0x22
CPU_PART_FIRESTORM_TONGA 0x23
CPU_PART_ICESTORM_JADE_CHOP 0x24
CPU_PART_ICESTORM_JADE_DIE 0x28
CPU_PART_FIRESTORM_JADE_CHOP 0x25
CPU_PART_FIRESTORM_JADE_DIE 0x29
CPU_PART_BLIZZARD 0x30
CPU_PART_AVALANCHE 0x31
CPU_PART_BLIZZARD_STATEN 0x32
CPU_PART_AVALANCHE_STATEN 0x33
CPU_PART_BLIZZARD_RHODES_CHOP 0x34
CPU_PART_AVALANCHE_RHODES_CHOP 0x35
CPU_PART_BLIZZARD_RHODES_DIE 0x38
CPU_PART_AVALANCHE_RHODES_DIE 0x39
CPU_PART_SAWTOOTH 0x40
CPU_PART_EVEREST 0x41
CPU_PART_ECORE_IBIZA 0x42
CPU_PART_PCORE_IBIZA 0x43
CPU_PART_ECORE_PALMA 0x48
CPU_PART_PCORE_PALMA 0x49
CPU_PART_ECORE_COLL 0x50
CPU_PART_PCORE_COLL 0x51
CPU_PART_ECORE_LOBOS 0x44
CPU_PART_PCORE_LOBOS 0x45
CPU_PART_SAWTOOTH_M11 0x46
CPU_PART_ECORE_DONAN 0x52
CPU_PART_PCORE_DONAN 0x53
CPU_PART_ECORE_BRAVA_S 0x54
CPU_PART_PCORE_BRAVA_S 0x55
CPU_PART_ECORE_BRAVA_C 0x58
CPU_PART_PCORE_BRAVA_C 0x59
_ARM_CPUID_INTERNAL_H_ None
_ARM_CPU_AFFINITY_H_ None
_ARM_CPU_CAPABILITIES_H None
USER_TIMEBASE_NONE 0
USER_TIMEBASE_SPEC 1
USER_TIMEBASE_NOSPEC 2
USER_TIMEBASE_NOSPEC_APPLE 3
kHasFeatFP16 0x00000008
kCache32 0x00000010
kCache64 0x00000020
kCache128 0x00000040
kFastThreadLocalStorage 0x00000080
kHasAdvSIMD 0x00000100
kHasAdvSIMD_HPFPCvt 0x00000200
kHasVfp 0x00000400
kHasUCNormalMemory 0x00000800
kHasEvent 0x00001000
kHasFMA 0x00002000
kHasFeatFHM 0x00004000
kUP 0x00008000
kNumCPUs 0x00FF0000
kHasARMv8Crypto 0x01000000
kHasFeatLSE 0x02000000
kHasARMv8Crc32 0x04000000
kHasFeatSHA512 0x80000000
kHasFeatSHA3 0x0000000100000000
kHasFeatFCMA 0x0000000200000000
kHasFeatAFP 0x0000000400000000
kHasFEATFlagM 0x0000010000000000
kHasFEATFlagM2 0x0000020000000000
kHasFeatDotProd 0x0000040000000000
kHasFeatRDM 0x0000080000000000
kHasFeatSPECRES 0x0000100000000000
kHasFeatSB 0x0000200000000000
kHasFeatFRINTTS 0x0000400000000000
kHasArmv8GPI 0x0000800000000000
kHasFeatLRCPC 0x0001000000000000
kHasFeatLRCPC2 0x0002000000000000
kHasFeatJSCVT 0x0004000000000000
kHasFeatPAuth 0x0008000000000000
kHasFeatDPB 0x0010000000000000
kHasFeatDPB2 0x0020000000000000
kHasFeatLSE2 0x0040000000000000
kHasFeatCSV2 0x0080000000000000
kHasFeatCSV3 0x0100000000000000
kHasFeatDIT 0x0200000000000000
kHasFP_SyncExceptions 0x0400000000000000
kHasFeatSME 0x0800000000000000
kHasFeatSME2 0x1000000000000000
kHasFeatSHA256 kHasARMv8Crypto
kHasFeatSHA1 kHasARMv8Crypto
kHasFeatAES kHasARMv8Crypto
kHasFeatPMULL kHasARMv8Crypto
kHasNeonFP16 kHasFeatFP16
kHasNeon kHasAdvSIMD
kHasNeonHPFP kHasAdvSIMD_HPFPCvt
kHasARMv82FHM kHasFeatFHM
kHasARMv81Atomics kHasFeatLSE
kHasARMv82SHA512 kHasFeatSHA512
kHasARMv82SHA3 kHasFeatSHA3
kHasARMv83CompNum kHasFeatFCMA
kNumCPUsShift 16
kIsMultiUserDevice 0x80000000
kHasSecondaryUsers 0x40000000
kMultiUserCurrentUserMask 0x3fffffff
_COMM_PAGE32_OBJC_SIZE 0ULL
_COMM_PAGE32_OBJC_BASE 0ULL
_COMM_PAGE64_OBJC_SIZE 0ULL
_COMM_PAGE64_OBJC_BASE 0ULL
_COMM_PAGE_LAYOUT_VERSION 1
_COMM_PAGE_THIS_VERSION 3
_ARM_CPU_CAPABILITIES_PUBLIC_H None
HW_OPTIONAL_ARM_CAPS None
CAP_BIT_FEAT_FlagM 0
CAP_BIT_FEAT_FlagM2 1
CAP_BIT_FEAT_FHM 2
CAP_BIT_FEAT_DotProd 3
CAP_BIT_FEAT_SHA3 4
CAP_BIT_FEAT_RDM 5
CAP_BIT_FEAT_LSE 6
CAP_BIT_FEAT_SHA256 7
CAP_BIT_FEAT_SHA512 8
CAP_BIT_FEAT_SHA1 9
CAP_BIT_FEAT_AES 10
CAP_BIT_FEAT_PMULL 11
CAP_BIT_FEAT_SPECRES 12
CAP_BIT_FEAT_SB 13
CAP_BIT_FEAT_FRINTTS 14
CAP_BIT_FEAT_LRCPC 15
CAP_BIT_FEAT_LRCPC2 16
CAP_BIT_FEAT_FCMA 17
CAP_BIT_FEAT_JSCVT 18
CAP_BIT_FEAT_PAuth 19
CAP_BIT_FEAT_PAuth2 20
CAP_BIT_FEAT_FPAC 21
CAP_BIT_FEAT_DPB 22
CAP_BIT_FEAT_DPB2 23
CAP_BIT_FEAT_BF16 24
CAP_BIT_FEAT_I8MM 25
CAP_BIT_FEAT_WFxT 26
CAP_BIT_FEAT_RPRES 27
CAP_BIT_FEAT_ECV 28
CAP_BIT_FEAT_AFP 29
CAP_BIT_FEAT_LSE2 30
CAP_BIT_FEAT_CSV2 31
CAP_BIT_FEAT_CSV3 32
CAP_BIT_FEAT_DIT 33
CAP_BIT_FEAT_FP16 34
CAP_BIT_FEAT_SSBS 35
CAP_BIT_FEAT_BTI 36
CAP_BIT_FEAT_SME 40
CAP_BIT_FEAT_SME2 41
CAP_BIT_FEAT_SME_F64F64 42
CAP_BIT_FEAT_SME_I16I64 43
CAP_BIT_AdvSIMD 49
CAP_BIT_AdvSIMD_HPFPCvt 50
CAP_BIT_FEAT_CRC32 51
CAP_BIT_SME_F32F32 52
CAP_BIT_SME_BI32I32 53
CAP_BIT_SME_B16F32 54
CAP_BIT_SME_F16F32 55
CAP_BIT_SME_I8I32 56
CAP_BIT_SME_I16I32 57
CAP_BIT_FEAT_PACIMP 58
CAP_BIT_FEAT_HBC 64
CAP_BIT_FEAT_EBF16 65
CAP_BIT_FEAT_SPECRES2 66
CAP_BIT_FEAT_CSSC 67
CAP_BIT_FEAT_FPACCOMBINE 68
CAP_BIT_FP_SyncExceptions 73
CAP_BIT_CRC32 CAP_BIT_FEAT_CRC32
CAP_BIT_NB 74
ARM_CPU_DATA None
getCpuDatap() current_thread()->machine.CpuDatap
current_cpu_datap() getCpuDatap()
mp_disable_preemption() _disable_preemption()
mp_enable_preemption() _enable_preemption()
ARM_CPU_DATA_INTERNAL None
CPUWINDOWS_BASE_MASK 0xFFFFFFFFFFD00000UL
ARM_CPU_ON_SLEEP_PATH 0x50535553UL
BootCpuData __PERCPU_NAME(cpu_data)
_ARM_CPU_INTERNAL_H_ None
_ARM_CPU_NUMBER_H_ None
_ARM_CPU_TOPOLOGY_H_ None
CPU_TOPOLOGY_VERSION 1
_ARM_CPU_X86_64_CAPABILITIES_H None
x86_64_kHasMMX 0x00000001
x86_64_kHasSSE 0x00000002
x86_64_kHasSSE2 0x00000004
x86_64_kHasSSE3 0x00000008
x86_64_kCache32 0x00000010
x86_64_kCache64 0x00000020
x86_64_kCache128 0x00000040
x86_64_kFastThreadLocalStorage 0x00000080
x86_64_kHasSupplementalSSE3 0x00000100
x86_64_k64Bit 0x00000200
x86_64_kHasSSE4_1 0x00000400
x86_64_kHasSSE4_2 0x00000800
x86_64_kHasAES 0x00001000
x86_64_kInOrderPipeline 0x00002000
x86_64_kSlow 0x00004000
x86_64_kUP 0x00008000
x86_64_kNumCPUs 0x00FF0000
x86_64_kNumCPUsShift 16
x86_64_kHasAVX1_0 0x01000000
x86_64_kHasRDRAND 0x02000000
x86_64_kHasF16C 0x04000000
x86_64_kHasENFSTRG 0x08000000
x86_64_kHasFMA 0x10000000
x86_64_kHasAVX2_0 0x20000000
x86_64_kHasBMI1 0x40000000
x86_64_kHasBMI2 0x80000000
x86_64_kHasRTM 0x0000000100000000ULL
x86_64_kHasHLE 0x0000000200000000ULL
x86_64_kHasRDSEED 0x0000000800000000ULL
x86_64_kHasADX 0x0000000400000000ULL
x86_64_kHasMPX 0x0000001000000000ULL
x86_64_kHasSGX 0x0000002000000000ULL
x86_64_kHasAVX512F 0x0000004000000000ULL
x86_64_kHasAVX512CD 0x0000008000000000ULL
x86_64_kHasAVX512DQ 0x0000010000000000ULL
x86_64_kHasAVX512BW 0x0000020000000000ULL
x86_64_kHasAVX512IFMA 0x0000040000000000ULL
x86_64_kHasAVX512VBMI 0x0000080000000000ULL
x86_64_kHasAVX512VL 0x0000100000000000ULL
x86_64_kIsTranslated 0x4000000000000000ULL
x86_64_kVmPageShift 0xFFB
X86_64_COMM_PAGE_AREA_LENGTH 4096
X86_64_COMM_PAGE_VERSION 14
X86_64_MP_SPIN_TRIES 1000
_ARM_EXCEPTION_H_ None
VECT_RESET 0x0
VECT_UNDEF_INST 0x4
VECT_SWI 0x8
VECT_PREFECT_ABT 0xC
VECT_DATA_ABT 0x10
VECT_IRQ 0x18
VECT_FIQ 0x1C
_ARM_LOCK_H_ None
_ARM_LOCKS_H_ None
LCK_SPIN_IS_TICKET_LOCK 0
LOCK_PRIVATE 1
NOINLINE __attribute__((noinline))
MACHDEP_CALL_ROUTINE(func, args) 	{ { .args_ ## args = func }, args }
_ARM_MACHINE_CPU_H_ None
cpu_pause() do {} while (0)
_ARM_MACHINE_CPUID_H_ None
_MACHINE_ARM_KPC_H None
_ARM_MACHINE_ROUTINES_H_ None
CacheConfig 0x00000000UL
CacheControl 0x00000001UL
CacheClean 0x00000002UL
CacheCleanRegion 0x00000003UL
CacheCleanFlush 0x00000004UL
CacheCleanFlushRegion 0x00000005UL
CacheShutdown 0x00000006UL
CacheControlEnable 0x00000000UL
CacheConfigCCSIDR 0x00000001UL
CacheConfigSize 0x00000100UL
ML_MINOR_BADNESS_CONSOLE_BUFFER_FULL 0
ML_MINOR_BADNESS_MEMFAULT_REPORTING_NOT_ENABLED 1
ML_MINOR_BADNESS_PIO_WRITTEN_FROM_USERSPACE 2
MAX_CPUS_SET 0x1
MAX_CPUS_WAIT 0x2
_ARM_MEMORY_TYPES_H_ None
VM_MEM_INNER 0x10
VM_MEM_RT 0x10
VM_MEM_EARLY_ACK 0x20
_ARM_MISC_PROTOS_H_ None
PANICLOG_VERSION 14
MAX_PROCNAME_LEN 32
PANIC_HEADER_VERSION_FMT_STR "%.14s (%.14s)"
SANE_TASK_LIMIT 256
TOP_RUNNABLE_LIMIT 5
PANICLOG_UUID_BUF_SIZE 256
_ARM_PAL_ROUTINES_H None
pal_ast_check(thread) None
pal_thread_terminate_self(t) None
panic_display_pal_info() do { } while(0)
pal_kernel_announce() do { } while(0)
_ARM_PMAP_PUBLIC_H_ None
_ARM_PROC_REG_H_ None
MAX_TIMEBASE_TRIES 10
_ARM_RTCLOCK_H_ None
EndOfAllTime 0xFFFFFFFFFFFFFFFFULL
DECREMENTER_MAX 0x7FFFFFFFUL
DECREMENTER_MIN 0xAUL
rtclock_sec_divisor RTClockData.rtc_sec_divisor
rtclock_usec_divisor RTClockData.rtc_usec_divisor
rtclock_timebase_const RTClockData.rtc_timebase_const
rtclock_base_abstime RTClockData.rtc_base.abstime
rtclock_base_abstime_low RTClockData.rtc_base.abstime_val.low
rtclock_base_abstime_high RTClockData.rtc_base.abstime_val.high
rtclock_adj_abstime RTClockData.rtc_adj.abstime
rtclock_adj_abstime_low RTClockData.rtc_adj.abstime_val.low
rtclock_adj_abstime_high RTClockData.rtc_adj.abstime_val.high
rtclock_timebase_func RTClockData.rtc_timebase_func
rtclock_timebase_addr RTClockData.rtc_timebase_addr
rtclock_timebase_val RTClockData.rtc_timebase_val
_ARM_SCHED_PARAM_H_ None
_ARM_SETJMP_H_ None
_ARM_SIMPLE_LOCK_TYPES_H_ None
MACHINE_SIMPLE_LOCK None
simple_lock_init(l, t)   arm_usimple_lock_init(l,t)
simple_unlock(l) lck_spin_unlock(l)
simple_unlock_nopreempt(l) lck_spin_unlock_nopreempt(l)
simple_lock_try_lock_loop(l, grp)    simple_lock(l, grp)
simple_lock_assert(l, t) lck_spin_assert(l,t)
kdp_simple_lock_is_acquired(l) kdp_lck_spin_is_acquired(l)
_ARM_SMP_H_ None
__AMP__ __ARM_AMP__
_ARM_STRING_H_ None
__arch_bcopy 1
__arch_bzero 1
__arch_memcmp_zero_ptr_aligned 1
__arch_memcpy 1
__arch_memmove 1
__arch_memset 1
__arch_strlen 1
__arch_strncmp 1
__arch_strnlen 1
TASK_ADDITIONS_UEXC uint64_t uexc[4];
TASK_ADDITIONS_APT None
MACHINE_TASK void * XNU_PTRAUTH_SIGNED_PTR("task.task_debug") task_debug; 	TASK_ADDITIONS_PAC 	TASK_ADDITIONS_UEXC 	TASK_ADDITIONS_X18 	TASK_ADDITIONS_APT 	bool uses_1ghz_timebase;
_ARM_THREAD_H_ None
_ARM_TRAP_H_ None
T_RESET 0
T_UNDEF 1
T_SWI 2
T_PREFETCH_ABT 3
T_DATA_ABT 4
T_IRQ 6
T_FIQ 7
T_PMU 8
TRAP_NAMES "reset", "undefined instruction", "software interrupt", 	           "prefetch abort", "data abort", "irq interrupt", 	           "fast interrupt", "perfmon"
T_PF_PROT 0x1
T_PF_WRITE 0x2
T_PF_USER 0x4
_ARM_TRAP_INTERNAL_H_ None
GDB_TRAP_INSTR1 0xe7ffdefe
GDB_TRAP_INSTR2 0xe7ffdeff
ARM_GDB_INSTR1 GDB_TRAP_INSTR1
ARM_GDB_INSTR2 GDB_TRAP_INSTR2
ARM_STR 0x04000000
ARM_STRH 0x000000B0
ARM_STRH_MASK 0x0E1000F0
ARM_SDX_MASK 0x0C100000
ARM_SNGL_DX_MASK 0x0C000000
ARM_SDX 0x04000000
ARM_STM 0x08000000
ARM_BDX_MASK 0x0E100000
ARM_BLK_MASK 0x0E000000
ARM_BDX 0x08000000
ARM_WRITE_BACK 0x00200000
ARM_BASE_REG 0x000F0000
ARM_INCREMENT 0x00800000
ARM_STC 0x0C000000
ARM_CDX_MASK ARM_BDX_MASK
ARM_CBLK_MASK ARM_BLK_MASK
ARM_CDX 0x0C000000
ARM_SWP 0x01000090
ARM_SWP_MASK 0x0FB00FF0
ARM_POST_INDEXING 0x01000000
ARM_IMMEDIATE 0x02000000
ARM_LSL 0
ARM_LSR 1
ARM_ASR 2
ARM_ROR 3
MCR_MASK 0x0F100F10
MCR_CP15 0x0E000F10
MCRR_MASK 0x0FF00F00
MCRR_CP15 0x0C400F00
THUMB_LDR_1_MASK 0x8800
THUMB_STR_1_MASK 0xF800
THUMB_STR_2_MASK 0xFE00
THUMB_STR_3_MASK 0xF800
THUMB_PUSH_MASK 0xFE00
THUMB_LDRH_1 0x8800
THUMB_STMIA 0xC000
THUMB_STR_1 0x6000
THUMB_STR_2 0x5000
THUMB_STR_3 0x9000
THUMB_STRB_1 0x7000
THUMB_STRB_2 0x5400
THUMB_STRH_1 0x8000
THUMB_STRH_2 0x5200
THUMB_PUSH 0xB400
THUMB_LDMIA 0xC800
THUMB_POP 0xBC00
THUMB_STR_1_BASE_OFFSET 8
THUMB_PUSH_EXTRA_OFFSET 8
ARM_STM_BASE_OFFSET 16
ARM_STM_LOAD_OFFSET 20
ARM_STM_WBACK_OFFSET 21
ARM_STM_INCR_OFFSET 23
ARM_STM_BEFORE_OFFSET 24
ARM_REG_LIST_LR_OFFSET 14
ARM_REG_LIST_PC_OFFSET 15
THUMB_STR_REG_LIST_MASK 0x000000FF
THUMB_STR_1_BASE_MASK 0x00000700
THUMB_PUSH_EXTRA_MASK 0x00000100
ARM_STM_REG_LIST_MASK 0x0000FFFF
ARM_STM_BASE_MASK 0x000F0000
ARM_STM_LOAD_MASK 0x00100000
ARM_STM_WBACK_MASK 0x00200000
ARM_STM_INCR_MASK 0x00800000
ARM_STM_BEFORE_MASK 0x01000000
ARM_COND_MASK 0xF0000000
ARM_COND_UNCOND 0xF0000000
ARM_SIMD_MASK0 0xFE000000
ARM_SIMD_CODE0 0xF2000000
ARM_VFP_MASK0 0x0F000E10
ARM_VFP_CODE0 0x0E000A00
ARM_SIMD_VFP_MASK0 0x0E000E00
ARM_SIMD_VFP_CODE0 0x0C000A00
ARM_SIMD_VFP_MASK1 0xFF100000
ARM_SIMD_VFP_CODE1 0xF4000000
ARM_SIMD_VFP_MASK2 0x0F000E10
ARM_SIMD_VFP_CODE2 0x0E000A10
ARM_SIMD_VFP_MASK3 0x0FE00E00
ARM_SIMD_VFP_CODE3 0x0C400A00
THUMB_SIMD_MASK0 0xEF000000
THUMB_SIMD_CODE0 0xEF000000
THUMB_VFP_MASK0 0xEF000E10
THUMB_VFP_CODE0 0xEE000A00
THUMB_SIMD_VFP_MASK0 0xEE000E00
THUMB_SIMD_VFP_CODE0 0xEC000A00
THUMB_SIMD_VFP_MASK1 0xFF100000
THUMB_SIMD_VFP_CODE1 0xF9000000
THUMB_SIMD_VFP_MASK2 0xEF000E10
THUMB_SIMD_VFP_CODE2 0xEE000A10
THUMB_SIMD_VFP_MASK3 0xEFE00E00
THUMB_SIMD_VFP_CODE3 0xEC400A00
arm_fault_type(op, spsr, vaddr)        (((((op)&ARM_CDX_MASK) == ARM_STC) || 	 (((op)&ARM_STRH_MASK) == ARM_STRH) || 	 (((op)&ARM_BDX_MASK) == ARM_STM) || 	 (((op)&ARM_SDX_MASK) == ARM_STR)) ?  	                (VM_PROT_WRITE|VM_PROT_READ) : (VM_PROT_READ))
thumb_fault_type(op, spsr, vaddr) 	(((((op)&THUMB_STR_1_MASK) == THUMB_STMIA) || 	  (((op)&THUMB_STR_1_MASK) == THUMB_STR_1) || 	  (((op)&THUMB_STR_2_MASK) == THUMB_STR_2) || 	  (((op)&THUMB_STR_3_MASK) == THUMB_STR_3) || 	  (((op)&THUMB_STR_1_MASK) == THUMB_STRB_1) || 	  (((op)&THUMB_STR_2_MASK) == THUMB_STRB_2) || 	  (((op)&THUMB_STR_1_MASK) == THUMB_STRH_1) || 	  (((op)&THUMB_STR_2_MASK) == THUMB_STRH_2) || 	  (((op)&THUMB_PUSH_MASK) == THUMB_PUSH)) ? 	        (VM_PROT_WRITE|VM_PROT_READ) : (VM_PROT_READ))
_ARM_VM_TUNING_H_ None
_ALTERNATE_DEBUGGER_H_ None
_ARM64_AMCC_RORGN_H_ None
PTOV_TABLE_SIZE 8
_ARM_ASM_H_ None
FALIGN ALIGN
LB(x,n) n
String .asciz
Value .word
_BTI_TELEMETRY_H_ None
WRAP_COPYIO_PAN(_dir, _map, _op)                                        	({                                                                      	        int _ret;                                                       	        user_access_enable(_dir, (_map)->pmap);                         	        _ret = _op;                                                     	        user_access_disable(_dir, (_map)->pmap);                        	        _ret;                                                           	})
WRAP_COPYIO(_dir, _map, _op) WRAP_COPYIO_PAN(_dir, _map, _op)
CPUPM_IDLE_WFE 0x5310300
CPUPM_IDLE_TIMER_WFE 0x5310304
DBGWRAP_REG_OFFSET 0
EDDTRRX_REG_OFFSET 0x80
EDITR_REG_OFFSET 0x84
EDSCR_REG_OFFSET 0x88
EDDTRTX_REG_OFFSET 0x8C
EDRCR_REG_OFFSET 0x90
EDPRSR_REG_OFFSET 0x314
MAX_EDITR_RETRIES 16
_ARM64_DWARF_UNWIND_H_ None
DWARF_ARM64_X0 0
DWARF_ARM64_X1 1
DWARF_ARM64_X2 2
DWARF_ARM64_X3 3
DWARF_ARM64_X4 4
DWARF_ARM64_X5 5
DWARF_ARM64_X6 6
DWARF_ARM64_X7 7
DWARF_ARM64_X8 8
DWARF_ARM64_X9 9
DWARF_ARM64_X10 10
DWARF_ARM64_X11 11
DWARF_ARM64_X12 12
DWARF_ARM64_X13 13
DWARF_ARM64_X14 14
DWARF_ARM64_X15 15
DWARF_ARM64_X16 16
DWARF_ARM64_X17 17
DWARF_ARM64_X18 18
DWARF_ARM64_X19 19
DWARF_ARM64_X20 20
DWARF_ARM64_X21 21
DWARF_ARM64_X22 22
DWARF_ARM64_X23 23
DWARF_ARM64_X24 24
DWARF_ARM64_X25 25
DWARF_ARM64_X26 26
DWARF_ARM64_X27 27
DWARF_ARM64_X28 28
DWARF_ARM64_FP 29
DWARF_ARM64_LR 30
DWARF_ARM64_SP 31
DWARF_ARM64_PC 32
DWARF_ARM64_CPSR 33
DWARF_ARM64_X0_OFFSET 8
DWARF_ARM64_X1_OFFSET 16
DWARF_ARM64_X2_OFFSET 24
DWARF_ARM64_X3_OFFSET 32
DWARF_ARM64_X4_OFFSET 40
DWARF_ARM64_X5_OFFSET 48
DWARF_ARM64_X6_OFFSET 56
DWARF_ARM64_X7_OFFSET 0xc0, 0x00
DWARF_ARM64_X8_OFFSET 0xc8, 0x00
DWARF_ARM64_X9_OFFSET 0xd0, 0x00
DWARF_ARM64_X10_OFFSET 0xd8, 0x00
DWARF_ARM64_X11_OFFSET 0xe0, 0x00
DWARF_ARM64_X12_OFFSET 0xe8, 0x00
DWARF_ARM64_X13_OFFSET 0xf0, 0x00
DWARF_ARM64_X14_OFFSET 0xf8, 0x00
DWARF_ARM64_X15_OFFSET 0x80, 0x01
DWARF_ARM64_X16_OFFSET 0x88, 0x01
DWARF_ARM64_X17_OFFSET 0x90, 0x01
DWARF_ARM64_X18_OFFSET 0x98, 0x01
DWARF_ARM64_X19_OFFSET 0xa0, 0x01
DWARF_ARM64_X20_OFFSET 0xa8, 0x01
DWARF_ARM64_X21_OFFSET 0xb0, 0x01
DWARF_ARM64_X22_OFFSET 0xb8, 0x01
DWARF_ARM64_X23_OFFSET 0xc0, 0x01
DWARF_ARM64_X24_OFFSET 0xc8, 0x01
DWARF_ARM64_X25_OFFSET 0xd0, 0x01
DWARF_ARM64_X26_OFFSET 0xd8, 0x01
DWARF_ARM64_X27_OFFSET 0xe0, 0x01
DWARF_ARM64_X28_OFFSET 0xe8, 0x01
DWARF_ARM64_FP_OFFSET 0xf0, 0x01
DWARF_ARM64_LR_OFFSET 0xf8, 0x01
DWARF_ARM64_SP_OFFSET 0x80, 0x02
DWARF_ARM64_PC_OFFSET 0x88, 0x02
DWARF_ARM64_CPSR_OFFSET 0x90, 0x02
DW_CFA_register 0x09
DW_CFA_expression 0x10
DW_CFA_offset_extended_sf 0x11
DW_OP_breg21 0x85
DW_FORM_LEN_ONE_BYTE_SLEB 2
DW_FORM_LEN_TWO_BYTE_SLEB 3
UNWIND_PROLOGUE .cfi_sections .eh_frame %%.cfi_startproc          %%
TRAP_UNWIND_PROLOGUE UNWIND_PROLOGUE .cfi_signal_frame       %%
UNWIND_EPILOGUE .cfi_endproc
TRAP_UNWIND_DIRECTIVES .cfi_def_cfa w29, 0     %%.cfi_escape DW_CFA_expression, DWARF_ARM64_X0, DW_FORM_LEN_ONE_BYTE_SLEB, DW_OP_breg21, DWARF_ARM64_X0_OFFSET %%.cfi_escape DW_CFA_expression, DWARF_ARM64_X1, DW_FORM_LEN_ONE_BYTE_SLEB, DW_OP_breg21, DWARF_ARM64_X1_OFFSET %%.cfi_escape DW_CFA_expression, DWARF_ARM64_X2, DW_FORM_LEN_ONE_BYTE_SLEB, DW_OP_breg21, DWARF_ARM64_X2_OFFSET %%.cfi_escape DW_CFA_expression, DWARF_ARM64_X3, DW_FORM_LEN_ONE_BYTE_SLEB, DW_OP_breg21, DWARF_ARM64_X3_OFFSET %%.cfi_escape DW_CFA_expression, DWARF_ARM64_X4, DW_FORM_LEN_ONE_BYTE_SLEB, DW_OP_breg21, DWARF_ARM64_X4_OFFSET %%.cfi_escape DW_CFA_expression, DWARF_ARM64_X5, DW_FORM_LEN_ONE_BYTE_SLEB, DW_OP_breg21, DWARF_ARM64_X5_OFFSET %%.cfi_escape DW_CFA_expression, DWARF_ARM64_X6, DW_FORM_LEN_ONE_BYTE_SLEB, DW_OP_breg21, DWARF_ARM64_X6_OFFSET %%.cfi_escape DW_CFA_expression, DWARF_ARM64_X7, DW_FORM_LEN_TWO_BYTE_SLEB, DW_OP_breg21, DWARF_ARM64_X7_OFFSET %%.cfi_escape DW_CFA_expression, DWARF_ARM64_X8, DW_FORM_LEN_TWO_BYTE_SLEB, DW_OP_breg21, DWARF_ARM64_X8_OFFSET %%.cfi_escape DW_CFA_expression, DWARF_ARM64_X9, DW_FORM_LEN_TWO_BYTE_SLEB, DW_OP_breg21, DWARF_ARM64_X9_OFFSET %%.cfi_escape DW_CFA_expression, DWARF_ARM64_X10, DW_FORM_LEN_TWO_BYTE_SLEB, DW_OP_breg21, DWARF_ARM64_X10_OFFSET %%.cfi_escape DW_CFA_expression, DWARF_ARM64_X11, DW_FORM_LEN_TWO_BYTE_SLEB, DW_OP_breg21, DWARF_ARM64_X11_OFFSET %%.cfi_escape DW_CFA_expression, DWARF_ARM64_X12, DW_FORM_LEN_TWO_BYTE_SLEB, DW_OP_breg21, DWARF_ARM64_X12_OFFSET %%.cfi_escape DW_CFA_expression, DWARF_ARM64_X13, DW_FORM_LEN_TWO_BYTE_SLEB, DW_OP_breg21, DWARF_ARM64_X13_OFFSET %%.cfi_escape DW_CFA_expression, DWARF_ARM64_X14, DW_FORM_LEN_TWO_BYTE_SLEB, DW_OP_breg21, DWARF_ARM64_X14_OFFSET %%.cfi_escape DW_CFA_expression, DWARF_ARM64_X15, DW_FORM_LEN_TWO_BYTE_SLEB, DW_OP_breg21, DWARF_ARM64_X15_OFFSET %%.cfi_escape DW_CFA_expression, DWARF_ARM64_X16, DW_FORM_LEN_TWO_BYTE_SLEB, DW_OP_breg21, DWARF_ARM64_X16_OFFSET %%.cfi_escape DW_CFA_expression, DWARF_ARM64_X17, DW_FORM_LEN_TWO_BYTE_SLEB, DW_OP_breg21, DWARF_ARM64_X17_OFFSET %%.cfi_escape DW_CFA_expression, DWARF_ARM64_X18, DW_FORM_LEN_TWO_BYTE_SLEB, DW_OP_breg21, DWARF_ARM64_X18_OFFSET %%.cfi_escape DW_CFA_expression, DWARF_ARM64_X19, DW_FORM_LEN_TWO_BYTE_SLEB, DW_OP_breg21, DWARF_ARM64_X19_OFFSET %%.cfi_escape DW_CFA_expression, DWARF_ARM64_X20, DW_FORM_LEN_TWO_BYTE_SLEB, DW_OP_breg21, DWARF_ARM64_X20_OFFSET %%.cfi_escape DW_CFA_expression, DWARF_ARM64_X21, DW_FORM_LEN_TWO_BYTE_SLEB, DW_OP_breg21, DWARF_ARM64_X21_OFFSET %%.cfi_escape DW_CFA_expression, DWARF_ARM64_X22, DW_FORM_LEN_TWO_BYTE_SLEB, DW_OP_breg21, DWARF_ARM64_X22_OFFSET %%.cfi_escape DW_CFA_expression, DWARF_ARM64_X23, DW_FORM_LEN_TWO_BYTE_SLEB, DW_OP_breg21, DWARF_ARM64_X23_OFFSET %%.cfi_escape DW_CFA_expression, DWARF_ARM64_X24, DW_FORM_LEN_TWO_BYTE_SLEB, DW_OP_breg21, DWARF_ARM64_X24_OFFSET %%.cfi_escape DW_CFA_expression, DWARF_ARM64_X25, DW_FORM_LEN_TWO_BYTE_SLEB, DW_OP_breg21, DWARF_ARM64_X25_OFFSET %%.cfi_escape DW_CFA_expression, DWARF_ARM64_X26, DW_FORM_LEN_TWO_BYTE_SLEB, DW_OP_breg21, DWARF_ARM64_X26_OFFSET %%.cfi_escape DW_CFA_expression, DWARF_ARM64_X27, DW_FORM_LEN_TWO_BYTE_SLEB, DW_OP_breg21, DWARF_ARM64_X27_OFFSET %%.cfi_escape DW_CFA_expression, DWARF_ARM64_X28, DW_FORM_LEN_TWO_BYTE_SLEB, DW_OP_breg21, DWARF_ARM64_X28_OFFSET %%.cfi_escape DW_CFA_expression, DWARF_ARM64_FP, DW_FORM_LEN_TWO_BYTE_SLEB, DW_OP_breg21, DWARF_ARM64_FP_OFFSET %%.cfi_escape DW_CFA_expression, DWARF_ARM64_LR, DW_FORM_LEN_TWO_BYTE_SLEB, DW_OP_breg21, DWARF_ARM64_LR_OFFSET %%.cfi_escape DW_CFA_expression, DWARF_ARM64_SP, DW_FORM_LEN_TWO_BYTE_SLEB, DW_OP_breg21, DWARF_ARM64_SP_OFFSET %%.cfi_escape DW_CFA_expression, DWARF_ARM64_PC, DW_FORM_LEN_TWO_BYTE_SLEB, DW_OP_breg21, DWARF_ARM64_PC_OFFSET %%.cfi_escape DW_CFA_expression, DWARF_ARM64_CPSR, DW_FORM_LEN_TWO_BYTE_SLEB, DW_OP_breg21, DWARF_ARM64_CPSR_OFFSET %%
RETURN_TO_KERNEL_UNWIND .cfi_def_cfa w29, 16     %%.cfi_escape DW_CFA_offset_extended_sf, DWARF_ARM64_FP, 2 %%.cfi_escape DW_CFA_offset_extended_sf, DWARF_ARM64_LR, 1 %%.cfi_escape DW_CFA_register, DWARF_ARM64_X21, DWARF_ARM64_X21 %%
KERNEL_MODE 0
HIBERNATE_MODE 1
FLEH_DISPATCH64_OPTION_SYNC_EXCEPTION 0
FLEH_DISPATCH64_OPTION_NONE 0
DECLARE(SYM, VAL) 	__asm("DEFINITION__define__" SYM ":\t .ascii \"%0\"" : : "i"  ((u_long)(VAL)))
ARM_LPAE_NSTABLE 0x8000000000000000ULL
TOP_LEVEL 1
LAST_TABLE_LEVEL 3
PAGE_GRANULE_SHIFT 14
dockchannel_uart_base gHibernateGlobals.dockChannelRegPhysBase
HVC_FID_FAST_CALL 0x80000000
HVC_FID_HVC64 0x40000000
HVC_FID_CPU 0x01000000
HVC_FID_OEM 0x03000000
HVC_FID_SC_MASK 0xff000000
HVC_FID_NUM_MASK 0x0000ffff
HVC_FID_UID 0xff01
HVC_FID_REVISION 0xff03
HVC_FID_FEATURES 0xfeff
HVC32_FI(rng, num) (HVC_FID_FAST_CALL | (rng) | (num))
HVC32_OEM_MAJOR_VER 1
HVC32_OEM_MINOR_VER 0
VMAPPLE_HVC_UID "3B878185-AA62-4E1F-9DC9-D6799CBB6EBB"
_INSTRUCTIONS_H_ None
ARM64_INSTR_LDST_RN_MASK 0x1f
ARM64_INSTR_LDST_RN_SHIFT 5
ARM64_INSTR_CAS_SZ_MASK 0x3
ARM64_INSTR_CAS_SZ_SHIFT 30
ARM64_INSTR_CAS_A_MASK 0x1
ARM64_INSTR_CAS_A_SHIFT 22
ARM64_INSTR_CAS_RS_MASK 0x1f
ARM64_INSTR_CAS_RS_SHIFT 16
ARM64_INSTR_CAS_R_MASK 0x1
ARM64_INSTR_CAS_R_SHIFT 15
ARM64_INSTR_CAS_RN_GET(x) ARM64_INSTR_LDST_RN_GET(x)
ARM64_INSTR_CAS_RT_MASK 0x1f
ARM64_INSTR_CAS_RT_SHIFT 0
ARM64_INSTR_CASP_SZ_MASK 0x1
ARM64_INSTR_CASP_SZ_SHIFT 30
ARM64_INSTR_CASP_A_MASK 0x1
ARM64_INSTR_CASP_A_SHIFT 22
ARM64_INSTR_CASP_RS_MASK 0x1f
ARM64_INSTR_CASP_RS_SHIFT 16
ARM64_INSTR_CASP_R_MASK 0x1
ARM64_INSTR_CASP_R_SHIFT 15
ARM64_INSTR_CASP_RN_GET(x) ARM64_INSTR_LDST_RN_GET(x)
ARM64_INSTR_CASP_RT_MASK 0x1f
ARM64_INSTR_CASP_RT_SHIFT 0
ARM64_INSTR_ATOMIC_LDST_SZ_MASK 0x3
ARM64_INSTR_ATOMIC_LDST_SZ_SHIFT 30
ARM64_INSTR_ATOMIC_LDST_A_MASK 0x1
ARM64_INSTR_ATOMIC_LDST_A_SHIFT 23
ARM64_INSTR_ATOMIC_LDST_R_MASK 0x1
ARM64_INSTR_ATOMIC_LDST_R_SHIFT 22
ARM64_INSTR_ATOMIC_LDST_RS_MASK 0x1f
ARM64_INSTR_ATOMIC_LDST_RS_SHIFT 16
ARM64_INSTR_ATOMIC_LDST_OPC_ADD 0
ARM64_INSTR_ATOMIC_LDST_OPC_BIC 1
ARM64_INSTR_ATOMIC_LDST_OPC_EOR 2
ARM64_INSTR_ATOMIC_LDST_OPC_ORR 3
ARM64_INSTR_ATOMIC_LDST_OPC_SMAX 4
ARM64_INSTR_ATOMIC_LDST_OPC_SMIN 5
ARM64_INSTR_ATOMIC_LDST_OPC_UMAX 6
ARM64_INSTR_ATOMIC_LDST_OPC_UMIN 7
ARM64_INSTR_ATOMIC_LDST_OPC_MASK 0x7
ARM64_INSTR_ATOMIC_LDST_OPC_SHIFT 12
ARM64_INSTR_ATOMIC_LDST_RN_GET(x) ARM64_INSTR_LDST_RN_GET(x)
ARM64_INSTR_ATOMIC_LDST_RT_MASK 0x1f
ARM64_INSTR_ATOMIC_LDST_RT_SHIFT 0
ARM64_INSTR_SWP_SZ_MASK 0x3
ARM64_INSTR_SWP_SZ_SHIFT 30
ARM64_INSTR_SWP_A_MASK 0x1
ARM64_INSTR_SWP_A_SHIFT 23
ARM64_INSTR_SWP_R_MASK 0x1
ARM64_INSTR_SWP_R_SHIFT 22
ARM64_INSTR_SWP_RS_MASK 0x1f
ARM64_INSTR_SWP_RS_SHIFT 16
ARM64_INSTR_SWP_OPC_MASK 0x7
ARM64_INSTR_SWP_OPC_SHIFT 12
ARM64_INSTR_SWP_RN_GET(x) ARM64_INSTR_LDST_RN_GET(x)
ARM64_INSTR_SWP_RT_MASK 0x1f
ARM64_INSTR_SWP_RT_SHIFT 0
ARM64_INSTR_LDST_REG_OFFSET_RM_MASK 0x1f
ARM64_INSTR_LDST_REG_OFFSET_RM_SHIFT 16
ARM64_INSTR_LDST_REG_OFFSET_OPTION_MASK 0b111
ARM64_INSTR_LDST_REG_OFFSET_OPTION_SHIFT 13
ARM64_INSTR_LDST_REG_OFFSET_S_MASK 0b1
ARM64_INSTR_LDST_REG_OFFSET_S_SHIFT 12
ARM64_INSTR_AUTxx_RD_MASK 0x1f
ARM64_INSTR_AUTxx_RD_SHIFT 0
ARM64_INSTR_AUTIx_SYSTEM_CRM_OP2_MASK 0x7c
ARM64_INSTR_AUTIx_SYSTEM_CRM_OP2_SHIFT 0x5
ARM64_INSTR_AUTIx_SYSTEM_CRM_OP2_AUTIA1716 0xc
ARM64_INSTR_AUTIx_SYSTEM_CRM_OP2_AUTIB1716 0xe
ARM64_INSTR_BxRAx_RN_MASK 0x1f
ARM64_INSTR_BxRAx_RN_SHIFT 5
ATOMIC_PRIVATE 1
LOCK_PRIVATE 1
_LOW_MEMORY_GLOBALS_H_ None
LOWGLO_LAYOUT_MAGIC 0xC0DEC0DE
_ARM64_MACHINE_CPUID_H_ None
_MACHINE_ARM64_KPC_H None
_MACHDEP_INTERNAL_H_ None
MACHDEP_TPIDR_CPUNUM_SHIFT 0
MACHDEP_TPIDR_CPUNUM_MASK 0x0000000000000fff
MACHDEP_TPIDR_CLUSTERID_SHIFT 12
MACHDEP_TPIDR_CLUSTERID_MASK 0x00000000000ff000
ARM_MACHINE_THREAD_USES_1GHZ_TIMBASE_SHIFT 2
MACHINE_ARM64_REMOTE_TIME_H None
CPUPM_IDLE_WFE 0x5310300
ML_READPROP_MANDATORY UINT64_MAX
platform_syscall_kprintf(x...) None
ARM64_MONOTONIC_H None
CYCLES 0
INSTRS 1
_ARM64_PAC_ASM_H_ None
_ARM64_PAL_HIBERNATE_H None
machine_switch_context_kprintf(x...) None
_copyin_fn _copyin_atomic64
machine_thread_create_kprintf(x...) None
machine_stack_attach_kprintf(x...) None
call_continuation_kprintf(x...) None
SET_DBGBCRn(n, value, accum) 	__asm__ volatile( 	        "msr DBGBCR" #n "_EL1, %[val]\n" 	        "orr %[result], %[result], %[val]\n" 	        : [result] "+r"(accum) : [val] "r"((value)))
SET_DBGBVRn(n, value) 	__asm__ volatile("msr DBGBVR" #n "_EL1, %0" : : "r"(value))
SET_DBGWCRn(n, value, accum) 	__asm__ volatile( 	        "msr DBGWCR" #n "_EL1, %[val]\n" 	        "orr %[result], %[result], %[val]\n" 	        : [result] "+r"(accum) : [val] "r"((value)))
SET_DBGWVRn(n, value) 	__asm__ volatile("msr DBGWVR" #n "_EL1, %0" : : "r"(value))
_ARM64_PROC_REG_H_ None
MAX_PSETS MAX_CPU_CLUSTERS
CONFIG_THREAD_GROUPS 1
PSR_NF 0x80000000
PSR_ZF 0x40000000
PSR_CF 0x20000000
PSR_VF 0x10000000
PSR_TF 0x00000020
PSR_USER_MODE 0x00000010
PSR_MODE_MASK 0x0000001F
PSR_USERDFLT PSR_USER_MODE
ARM_DBG_VR_ADDRESS_MASK 0xFFFFFFFC
ARM_DBG_VR_ADDRESS_MASK64 0xFFFFFFFFFFFFFFFCull
ARM_DBG_CR_ADDRESS_MASK_MASK 0x1F000000
ARM_DBGWCR_BYTE_ADDRESS_SELECT_MASK 0x00001FE0
ARM_DBG_CR_BYTE_ADDRESS_SELECT_MASK 0x000001E0
ARM_DBG_LOCK_ACCESS_KEY 0xC5ACCE55
MIDR_REV_SHIFT 0
MIDR_VAR_SHIFT 20
PSR64_NZCV_SHIFT 28
PSR64_NZCV_WIDTH 4
PSR64_N_SHIFT 31
PSR64_Z_SHIFT 30
PSR64_C_SHIFT 29
PSR64_V_SHIFT 28
PSR64_TCO_SHIFT 25
PSR64_DIT_SHIFT 24
PSR64_UAO_SHIFT 23
PSR64_PAN_SHIFT 22
PSR64_SS_SHIFT 21
PSR64_IL_SHIFT 20
PSR64_SSBS_SHIFT_32 23
PSR64_SSBS_SHIFT_64 12
DAIF_DEBUG_SHIFT 9
DAIF_ASYNC_SHIFT 8
DAIF_IRQF_SHIFT 7
DAIF_FIQF_SHIFT 6
PSR64_CF 0x20000000
PSR64_MODE_MASK 0x1F
PSR64_USER_MASK PSR64_NZCV_MASK
PSR64_MODE_USER32_THUMB 0x20
PSR64_MODE_RW_SHIFT 4
PSR64_MODE_RW_64 0
PSR64_MODE_EL_SHIFT 2
PSR64_MODE_EL0 0
PSR64_MODE_SPX 0x1
PSR64_MODE_SP0 0
CPACR_TTA_SHIFT 28
CPACR_FPEN_SHIFT 20
FPSR_N_SHIFT 31
FPSR_Z_SHIFT 30
FPSR_C_SHIFT 29
FPSR_V_SHIFT 28
FPSR_QC_SHIFT 27
FPSR_IDC_SHIFT 7
FPSR_IXC_SHIFT 4
FPSR_UFC_SHIFT 3
FPSR_OFC_SHIFT 2
FPSR_DZC_SHIFT 1
FPSR_IOC_SHIFT 0
FPCR_AHP_SHIFT 26
FPCR_DN_SHIFT 25
FPCR_FZ_SHIFT 24
FPCR_RMODE_SHIFT 22
FPCR_STRIDE_SHIFT 20
FPCR_LEN_SHIFT 16
FPCR_IDE_SHIFT 15
FPCR_IXE_SHIFT 12
FPCR_UFE_SHIFT 11
FPCR_OFE_SHIFT 10
FPCR_DZE_SHIFT 9
FPCR_IOE_SHIFT 8
TCR_T0SZ_SHIFT 0ULL
TCR_TSZ_BITS 6ULL
TCR_IRGN0_SHIFT 8ULL
TCR_ORGN0_SHIFT 10ULL
TCR_SH0_SHIFT 12ULL
TCR_T1SZ_SHIFT 16ULL
TCR_IRGN1_SHIFT 24ULL
TCR_ORGN1_SHIFT 26ULL
TCR_SH1_SHIFT 28ULL
TCR_TG1_GRANULE_SHIFT 30ULL
TCR_IPS_SHIFT 32ULL
TCR_IPS_BITS 3ULL
TCR_EL1_EXTRA 0
MPIDR_AFF0_SHIFT 0
MPIDR_AFF0_WIDTH 8
MPIDR_AFF1_SHIFT 8
MPIDR_AFF1_WIDTH 8
MPIDR_AFF2_SHIFT 16
MPIDR_AFF2_WIDTH 8
MDSCR_TFO_SHIFT 31
MDSCR_RXFULL_SHIFT 30
MDSCR_TXFULL_SHIFT 29
MDSCR_RXO_SHIFT 27
MDSCR_TXU_SHIFT 26
MDSCR_INTDIS_SHIFT 22
MDSCR_TDA_SHIFT 21
MDSCR_SC2_SHIFT 19
MDSCR_MDE_SHIFT 15
MDSCR_HDE_SHIFT 14
MDSCR_KDE_SHIFT 13
MDSCR_TDCC_SHIFT 12
MDSCR_ERR_SHIFT 6
MDSCR_SS_SHIFT 0
TTBR_ASID_SHIFT 48
TTBR_ASID_MASK 0xffff000000000000
TTBR_BADDR_MASK 0x0000ffffffffffff
MAIR_OUTER_STRONGLY_ORDERED 0x0
MAIR_OUTER_DEVICE 0x0
MAIR_INNER_STRONGLY_ORDERED 0x0
MAIR_INNER_DEVICE 0x4
MAIR_OUTER_NON_CACHEABLE 0x40
MAIR_OUTER_WRITE_THROUGH 0x80
MAIR_OUTER_WRITE_BACK 0xc0
MAIR_INNER_NON_CACHEABLE 0x4
MAIR_INNER_WRITE_THROUGH 0x8
MAIR_INNER_WRITE_BACK 0xc
MAIR_OUTER_WRITE_ALLOCATE 0x10
MAIR_OUTER_READ_ALLOCATE 0x20
MAIR_INNER_WRITE_ALLOCATE 0x1
MAIR_INNER_READ_ALLOCATE 0x2
AP_RWNA 0x0
AP_RWRW 0x1
AP_RONA 0x2
AP_RORO 0x3
AP_MASK 0x3
SH_NONE 0x0
SH_NONE 0x0
SH_DEVICE 0x2
SH_OUTER_MEMORY 0x2
SH_INNER_MEMORY 0x3
ARM_16K_TT_L0_SIZE 0x0000800000000000ULL
ARM_16K_TT_L0_OFFMASK 0x00007fffffffffffULL
ARM_16K_TT_L0_SHIFT 47
ARM_16K_TT_L0_INDEX_MASK 0x0000800000000000ULL
ARM_4K_TT_L0_SIZE 0x0000008000000000ULL
ARM_4K_TT_L0_OFFMASK 0x0000007fffffffffULL
ARM_4K_TT_L0_SHIFT 39
ARM_4K_TT_L0_INDEX_MASK 0x0000ff8000000000ULL
ARM_16K_TT_L1_SIZE 0x0000001000000000ULL
ARM_16K_TT_L1_OFFMASK 0x0000000fffffffffULL
ARM_16K_TT_L1_SHIFT 36
ARM_4K_TT_L1_SIZE 0x0000000040000000ULL
ARM_4K_TT_L1_OFFMASK 0x000000003fffffffULL
ARM_4K_TT_L1_SHIFT 30
ARM_16K_TT_L2_SIZE 0x0000000002000000ULL
ARM_16K_TT_L2_OFFMASK 0x0000000001ffffffULL
ARM_16K_TT_L2_SHIFT 25
ARM_16K_TT_L2_INDEX_MASK 0x0000000ffe000000ULL
ARM_4K_TT_L2_SIZE 0x0000000000200000ULL
ARM_4K_TT_L2_OFFMASK 0x00000000001fffffULL
ARM_4K_TT_L2_SHIFT 21
ARM_4K_TT_L2_INDEX_MASK 0x000000003fe00000ULL
ARM_16K_TT_L3_SIZE 0x0000000000004000ULL
ARM_16K_TT_L3_OFFMASK 0x0000000000003fffULL
ARM_16K_TT_L3_SHIFT 14
ARM_16K_TT_L3_INDEX_MASK 0x0000000001ffc000ULL
ARM_4K_TT_L3_SIZE 0x0000000000001000ULL
ARM_4K_TT_L3_OFFMASK 0x0000000000000fffULL
ARM_4K_TT_L3_SHIFT 12
ARM_4K_TT_L3_INDEX_MASK 0x00000000001ff000ULL
ARM_TT_LEAF_SIZE ARM_TT_L3_SIZE
ARM_TT_LEAF_OFFMASK ARM_TT_L3_OFFMASK
ARM_TT_LEAF_SHIFT ARM_TT_L3_SHIFT
ARM_TT_LEAF_INDEX_MASK ARM_TT_L3_INDEX_MASK
ARM_TT_TWIG_SIZE ARM_TT_L2_SIZE
ARM_TT_TWIG_OFFMASK ARM_TT_L2_OFFMASK
ARM_TT_TWIG_SHIFT ARM_TT_L2_SHIFT
ARM_TT_TWIG_INDEX_MASK ARM_TT_L2_INDEX_MASK
ARM_TT_ROOT_SIZE ARM_TT_L1_SIZE
ARM_TT_ROOT_OFFMASK ARM_TT_L1_OFFMASK
ARM_TT_ROOT_SHIFT ARM_TT_L1_SHIFT
ARM_TT_ROOT_INDEX_MASK ARM_TT_L1_INDEX_MASK
TTE_SHIFT 3
ARM_TTE_EMPTY 0x0000000000000000ULL
ARM_TTE_TYPE_FAULT 0x0000000000000000ULL
ARM_TTE_VALID 0x0000000000000001ULL
ARM_TTE_TYPE_MASK 0x0000000000000002ULL
ARM_TTE_TYPE_TABLE 0x0000000000000002ULL
ARM_TTE_TYPE_BLOCK 0x0000000000000000ULL
ARM_TTE_TYPE_L3BLOCK 0x0000000000000002ULL
ARM_TTE_BLOCK_APSHIFT 6
ARM_TTE_BLOCK_AF 0x0000000000000400ULL
ARM_TTE_BLOCK_AFMASK 0x0000000000000400ULL
ARM_TTE_BLOCK_NG 0x0000000000000800ULL
ARM_TTE_BLOCK_NG_MASK 0x0000000000000800ULL
ARM_TTE_BLOCK_NS 0x0000000000000020ULL
ARM_TTE_BLOCK_NS_MASK 0x0000000000000020ULL
ARM_TTE_BLOCK_PNX 0x0020000000000000ULL
ARM_TTE_BLOCK_PNXMASK 0x0020000000000000ULL
ARM_TTE_BLOCK_NX 0x0040000000000000ULL
ARM_TTE_BLOCK_NXMASK 0x0040000000000000ULL
ARM_TTE_BLOCK_WIRED 0x0400000000000000ULL
ARM_TTE_BLOCK_WIREDMASK 0x0400000000000000ULL
ARM_TTE_BLOCK_WRITEABLE 0x0800000000000000ULL
ARM_TTE_BLOCK_WRITEABLEMASK 0x0800000000000000ULL
ARM_TTE_TABLE_MASK 0x0000fffffffff000ULL
ARM_TTE_TABLE_APSHIFT 61
ARM_TTE_TABLE_AP_NO_EFFECT 0x0ULL
ARM_TTE_TABLE_AP_USER_NA 0x1ULL
ARM_TTE_TABLE_AP_RO 0x2ULL
ARM_TTE_TABLE_AP_KERN_RO 0x3ULL
ARM_TTE_TABLE_NS 0x8000000000000020ULL
ARM_TTE_TABLE_NS_MASK 0x8000000000000020ULL
ARM_TTE_TABLE_XN 0x1000000000000000ULL
ARM_TTE_TABLE_XNMASK 0x1000000000000000ULL
ARM_TTE_TABLE_PXN 0x0800000000000000ULL
ARM_TTE_TABLE_PXNMASK 0x0800000000000000ULL
ARM_TTE_BOOT_BLOCK_UPPER ARM_TTE_BLOCK_NX
ARM_TTE_PA_MASK 0x0000fffffffff000ULL
PTE_SHIFT 3
ARM_PTE_EMPTY 0x0000000000000000ULL
ARM_PTE_COMPRESSED 0x8000000000000000ULL
ARM_PTE_COMPRESSED_ALT 0x4000000000000000ULL
ARM_PTE_COMPRESSED_MASK 0xC000000000000000ULL
ARM_PTE_TYPE_VALID 0x0000000000000003ULL
ARM_PTE_TYPE_FAULT 0x0000000000000000ULL
ARM_PTE_TYPE_MASK 0x0000000000000003ULL
ARM_PTE_PAGE_MASK 0x0000FFFFFFFFF000ULL
ARM_PTE_PAGE_SHIFT 12
ARM_PTE_AF 0x0000000000000400ULL
ARM_PTE_AFMASK 0x0000000000000400ULL
ARM_PTE_NG 0x0000000000000800ULL
ARM_PTE_NG_MASK 0x0000000000000800ULL
ARM_PTE_NS 0x0000000000000020ULL
ARM_PTE_NS_MASK 0x0000000000000020ULL
ARM_PTE_HINT 0x0010000000000000ULL
ARM_PTE_HINT_MASK 0x0010000000000000ULL
ARM_PTE_GP 0x0004000000000000ULL
ARM_PTE_GP_MASK 0x0004000000000000ULL
ARM_PTE_PNX 0x0020000000000000ULL
ARM_PTE_PXN ARM_PTE_PNX
ARM_PTE_PNXMASK 0x0020000000000000ULL
ARM_PTE_NX 0x0040000000000000ULL
ARM_PTE_XN ARM_PTE_NX
ARM_PTE_NXMASK 0x0040000000000000ULL
ARM_PTE_GUARDED 0x0004000000000000ULL
ARM_PTE_WIRED 0x0400000000000000ULL
ARM_PTE_WIRED_MASK 0x0400000000000000ULL
ARM_PTE_WRITEABLE 0x0800000000000000ULL
ARM_PTE_WRITABLE ARM_PTE_WRITEABLE
ARM_PTE_WRITEABLE_MASK 0x0800000000000000ULL
RTLBI_ADDR_SHIFT ARM_TT_L3_SHIFT
ESR_EC_SHIFT 26
ESR_EC_WIDTH 6
ESR_IL_SHIFT 25
ESR_ISS_MASK 0x01FFFFFF
ISS_SVC_IMM_MASK 0xffff
ISS_HVC_IMM_MASK 0xffff
ISS_SSDE_ISV_SHIFT 24
ISS_SSDE_EX_SHIFT 6
ISS_SSDE_FSC_MASK 0x3F
ISS_IA_FNV_SHIFT 10
ISS_IA_EA_SHIFT 9
ISS_IA_FSC_MASK 0x3F
ISS_DA_FNV_SHIFT 10
ISS_DA_EA_SHIFT 9
ISS_DA_CM_SHIFT 8
ISS_DA_WNR_SHIFT 6
ISS_DA_S1PTW_SHIFT 7
ISS_DA_FSC_MASK 0x3F
ISS_FP_TFV_SHIFT 23
ISS_FP_IDF_SHIFT 7
ISS_FP_IXF_SHIFT 4
ISS_FP_UFF_SHIFT 3
ISS_FP_OFF_SHIFT 2
ISS_FP_DZF_SHIFT 1
ISS_FP_IOF_SHIFT 0
ISS_BRK_COMMENT_MASK 0xFFFF
ISS_SEI_IDS_SHIFT 24
PAR_F_SHIFT 0
PLATFORM_SYSCALL_TRAP_NO 0x80000000
ARM64_CLINE_SHIFT 6
CNTP_CTL_EL0_ISTATUS CNTV_CTL_EL0_ISTATUS
CNTP_CTL_EL0_IMASKED CNTV_CTL_EL0_IMASKED
CNTP_CTL_EL0_ENABLE CNTV_CTL_EL0_ENABLE
MIDR_EL1_REV_SHIFT 0
MIDR_EL1_PNUM_SHIFT 4
MIDR_EL1_ARCH_SHIFT 16
MIDR_EL1_VAR_SHIFT 20
MIDR_EL1_IMP_SHIFT 24
CORESIGHT_ED 0
CORESIGHT_CTI 1
CORESIGHT_PMU 2
CORESIGHT_UTT 3
CORESIGHT_REGIONS 4
CORESIGHT_SIZE 0x1000
ID_AA64ISAR0_EL1_TS_OFFSET 52
ID_AA64ISAR0_EL1_FHM_OFFSET 48
ID_AA64ISAR0_EL1_DP_OFFSET 44
ID_AA64ISAR0_EL1_SHA3_OFFSET 32
ID_AA64ISAR0_EL1_RDM_OFFSET 28
ID_AA64ISAR0_EL1_ATOMIC_OFFSET 20
ID_AA64ISAR0_EL1_CRC32_OFFSET 16
ID_AA64ISAR0_EL1_SHA2_OFFSET 12
ID_AA64ISAR0_EL1_SHA1_OFFSET 8
ID_AA64ISAR0_EL1_AES_OFFSET 4
ID_AA64ISAR1_EL1_I8MM_OFFSET 52
ID_AA64ISAR1_EL1_DGH_OFFSET 48
ID_AA64ISAR1_EL1_BF16_OFFSET 44
ID_AA64ISAR1_EL1_SPECRES_OFFSET 40
ID_AA64ISAR1_EL1_SB_OFFSET 36
ID_AA64ISAR1_EL1_FRINTTS_OFFSET 32
ID_AA64ISAR1_EL1_GPI_OFFSET 28
ID_AA64ISAR1_EL1_GPA_OFFSET 24
ID_AA64ISAR1_EL1_LRCPC_OFFSET 20
ID_AA64ISAR1_EL1_FCMA_OFFSET 16
ID_AA64ISAR1_EL1_JSCVT_OFFSET 12
ID_AA64ISAR1_EL1_API_OFFSET 8
ID_AA64ISAR1_EL1_APA_OFFSET 4
ID_AA64ISAR1_EL1_DPB_OFFSET 0
ID_AA64ISAR2_EL1_CSSC_OFFSET 52
ID_AA64ISAR2_EL1_BC_OFFSET 20
ID_AA64ISAR2_EL1_RPRES_OFFSET 4
ID_AA64ISAR2_EL1_WFxT_OFFSET 0
ID_AA64MMFR0_EL1_ECV_OFFSET 60
ID_AA64MMFR2_EL1_AT_OFFSET 32
ID_AA64MMFR2_EL1_VARANGE_OFFSET 16
ID_AA64PFR0_EL1_CSV3_OFFSET 60
ID_AA64PFR0_EL1_CSV2_OFFSET 56
ID_AA64PFR0_EL1_DIT_OFFSET 48
ID_AA64PFR0_EL1_AdvSIMD_OFFSET 20
ID_AA64PFR1_EL1_SME_OFFSET 24
ID_AA64PFR1_EL1_CSV2_frac_OFFSET 32
ID_AA64PFR1_EL1_SSBS_OFFSET 4
ID_AA64PFR1_EL1_BT_OFFSET 0
ID_AA64MMFR1_EL1_AFP_OFFSET 44
ID_AA64MMFR1_EL1_HCX_OFFSET 40
ID_AA64SMFR0_EL1_SMEver_OFFSET 56
ID_AA64SMFR0_EL1_I16I64_OFFSET 52
ID_AA64SMFR0_EL1_F64F64_OFFSET 48
ID_AA64SMFR0_EL1_I16I32_OFFSET 44
ID_AA64SMFR0_EL1_I8I32_OFFSET 36
ID_AA64SMFR0_EL1_F16F32_OFFSET 35
ID_AA64SMFR0_EL1_B16F32_OFFSET 34
ID_AA64SMFR0_EL1_BI32I32_OFFSET 33
ID_AA64SMFR0_EL1_F32F32_OFFSET 32
CTR_EL0_L1Ip_OFFSET 14
MSR(reg, src)  __asm__ volatile ("msr " reg ", %0" :: "r" (src))
MRS(dest, reg) __asm__ volatile ("mrs %0, " reg : "=r" (dest))
ASSERT_CONTEXT_SANITY(context) assert(TEST_CONTEXT32_SANITY(context) || TEST_CONTEXT64_SANITY(context))
COPYIN(src, dst, size)                           	(PSR64_IS_KERNEL(get_saved_state_cpsr(state))) ? 	copyin_kern(src, dst, size) :                    	copyin(src, dst, size)
COPYOUT(src, dst, size)                          	(PSR64_IS_KERNEL(get_saved_state_cpsr(state))) ? 	copyout_kern(src, dst, size)                   : 	copyout(src, dst, size)
STR1(x) #x
STR(x) STR1(x)
FASTTRAP_ARM32_INSTR 0xe7ffdefc
FASTTRAP_THUMB32_INSTR 0xdefc
FASTTRAP_ARM64_INSTR 0xe7eeee7e
FASTTRAP_ARM32_RET_INSTR 0xe7ffdefb
FASTTRAP_THUMB32_RET_INSTR 0xdefb
FASTTRAP_ARM64_RET_INSTR 0xe7eeee7d
handle_svc_kprintf(x...) None
TRACE_SYSCALL 1
BTI_FAIL_PTR_FMT "%04x"
BTI_FAIL_MSG_FMT "Kernel BTI failure (BTYPE=0x" BTI_FAIL_PTR_FMT ")"
_ARM64_SMCCC_ASM_H_ None
_SPECULATION_H_ None
SPECULATION_GUARD_ZEROING_GEN(out, out_valid, value, cmp_1, cmp_2, cc, cmp_prefix, cs_prefix)     { 	__asm__ ( 	    "cmp       %" cmp_prefix "[_cmp_1], %" cmp_prefix "[_cmp_2]\n" 	    "csel      %" cs_prefix "[_out], %" cs_prefix "[_value], %" cs_prefix "[_zero], " cc "\n" 	    "cset      %w[_out_valid], " cc "\n" 	    "csdb\n" 	    : [_out] "=r" (out), [_out_valid] "=r" (out_valid) 	    : [_cmp_1] "r" (cmp_1), [_cmp_2] "r" (cmp_2), [_value] "r" (value), [_zero] "rz" (0ULL) 	    : "cc" 	);     }
SPECULATION_GUARD_ZEROING_XXX(out, out_valid, value, cmp_1, cmp_2, cc)     SPECULATION_GUARD_ZEROING_GEN(out, out_valid, value, cmp_1, cmp_2, cc, "", "")
SPECULATION_GUARD_ZEROING_XWW(out, out_valid, value, cmp_1, cmp_2, cc)     SPECULATION_GUARD_ZEROING_GEN(out, out_valid, value, cmp_1, cmp_2, cc, "w", "")
SPECULATION_GUARD_ZEROING_WXX(out, out_valid, value, cmp_1, cmp_2, cc)     SPECULATION_GUARD_ZEROING_GEN(out, out_valid, value, cmp_1, cmp_2, cc, "", "w")
SPECULATION_GUARD_ZEROING_WWW(out, out_valid, value, cmp_1, cmp_2, cc)     SPECULATION_GUARD_ZEROING_GEN(out, out_valid, value, cmp_1, cmp_2, cc, "w", "w")
SPECULATION_GUARD_SELECT_GEN(out, cmp_1, cmp_2, cc, sel_1, n_cc, sel_2, cmp_prefix, cs_prefix)     __asm__ ( 	"cmp       %" cmp_prefix "[_cmp_1], %" cmp_prefix "[_cmp_2]\n" 	"csel      %" cs_prefix "[_out], %" cs_prefix "[_sel_1], %" cs_prefix "[_sel_2], " cc "\n" 	"csdb\n" 	: [_out] "=r" (out) 	: [_cmp_1] "r" (cmp_1), [_cmp_2] "r" (cmp_2), [_sel_1] "r" (sel_1), [_sel_2] "r" (sel_2), [_zero] "rz" (0ULL) 	: "cc"     );
SPECULATION_GUARD_SELECT_XXX(out, cmp_1, cmp_2, cc, sel_1, n_cc, sel_2)     SPECULATION_GUARD_SELECT_GEN(out, cmp_1, cmp_2, cc, sel_1, n_cc, sel_2, "", "")
SPECULATION_GUARD_SELECT_XWW(out, cmp_1, cmp_2, cc, sel_1, n_cc, sel_2)     SPECULATION_GUARD_SELECT_GEN(out, cmp_1, cmp_2, cc, sel_1, n_cc, sel_2, "w", "")
SPECULATION_GUARD_SELECT_WXX(out, cmp_1, cmp_2, cc, sel_1, n_cc, sel_2)     SPECULATION_GUARD_SELECT_GEN(out, cmp_1, cmp_2, cc, sel_1, n_cc, sel_2, "", "w")
SPECULATION_GUARD_SELECT_WWW(out, cmp_1, cmp_2, cc, sel_1, n_cc, sel_2)     SPECULATION_GUARD_SELECT_GEN(out, cmp_1, cmp_2, cc, sel_1, n_cc, sel_2, "w", "w")
_ATM_ATM_INTERNAL_H_ None
_ATM_ATM_TYPES_H_ None
ATM_ACTION_DISCARD 0x1
ATM_ACTION_COLLECT 0x2
ATM_ACTION_LOGFAIL 0x3
ATM_FIND_MIN_SUB_AID 0x4
ATM_ACTION_UNREGISTER 0x5
ATM_ACTION_REGISTER 0x6
ATM_ACTION_GETSUBAID 0x7
global_bank_task_lock() lck_spin_lock_grp(&g_bank_task_lock_data, &bank_lock_grp)
global_bank_task_lock_try() lck_spin_try_lock_grp(&g_bank_task_lock_data, &bank_lock_grp)
global_bank_task_unlock() lck_spin_unlock(&g_bank_task_lock_data)
_BANK_BANK_INTERNAL_H_ None
BANK_DEFAULT_VALUE NULL
BANK_TASK 0
BANK_ACCOUNT 1
bt_type bt_elem.be_type
bt_voucher_ref bt_elem.be_voucher_ref
bt_refs bt_elem.be_refs
bt_made bt_elem.be_made
bt_flags bt_proc_persona.flags
bt_unique_pid bt_proc_persona.unique_pid
bt_pid bt_proc_persona.pid
bt_pidversion bt_proc_persona.pidversion
bt_persona_id bt_proc_persona.persona_id
bt_uid bt_proc_persona.uid
bt_gid bt_proc_persona.gid
bt_macho_uuid bt_proc_persona.macho_uuid
bank_task_made_release_num(elem, num)   	        (os_atomic_sub_orig(&(elem)->bt_made, (num), relaxed))
ba_type ba_elem.be_type
ba_voucher_ref ba_elem.be_voucher_ref
ba_refs ba_elem.be_refs
ba_made ba_elem.be_made
bank_account_made_release_num(elem, num)        	        (os_atomic_sub_orig(&(elem)->ba_made, (num), relaxed))
_BANK_BANK_TYPES_H_ None
BANK_ORIGINATOR_PID 0x1
BANK_PERSONA_TOKEN 0x2
BANK_PERSONA_ID 0x3
BANK_PERSONA_ADOPT_ANY 0x4
BANK_ORIGINATOR_PROXIMATE_PID 0x5
PROC_PERSONA_INFO_FLAG_ADOPTION_ALLOWED 0x1
ENTITLEMENT_PERSONA_MODIFY "com.apple.private.persona.modify"
ENTITLEMENT_PERSONA_NO_PROPAGATE "com.apple.private.personas.no.propagate"
ENTITLEMENT_PERSONA_ADOPT_ANY "com.apple.private.persona.adopt.any"
ISO_CHAR_MIN 0x00
ISO_CHAR_MAX 0xFF
ISO_CHAR_WIDTH 8
ISO_CHAR_HEIGHT 16
CPU_CONS_BUF_SIZE 256
KERN_CONSOLE_RING_SIZE vm_map_round_page(CPU_CONS_BUF_SIZE * (MAX_CPUS + 1), PAGE_SIZE - 1)
MAX_FLUSH_SIZE_LOCK_HELD 16
NMI_STRING_SIZE 32
_CONSOLE_SERIAL_PROTOS_H_ None
SERIALMODE_OUTPUT 0x01
SERIALMODE_INPUT 0x02
SERIALMODE_SYNCDRAIN 0x04
SERIALMODE_BASE_TTY 0x08
SERIALMODE_NO_IOLOG 0x10
SERIALMODE_DKLOG 0x20
SERIALMODE_ON_DEMAND 0x40
SERIAL_CONS_OPS 0
VC_CONS_OPS 1
SERIAL_CONS_BUF_SIZE 256
CONS_PB_WRITE_NEWLINE 0x1
CONS_PB_CANBLOCK 0x2
VCPUTC_LOCK_INIT() MACRO_BEGIN                                             	lck_ticket_init(&vcputc_lock, &vconsole_lck_grp);   MACRO_END
VCPUTC_LOCK_LOCK() MACRO_BEGIN                                             	lck_ticket_lock(&vcputc_lock, &vconsole_lck_grp);   MACRO_END
VCPUTC_LOCK_UNLOCK() MACRO_BEGIN                                             	lck_ticket_unlock(&vcputc_lock);                    MACRO_END
ATTR_NONE 0
ATTR_BOLD 1
ATTR_UNDER 2
ATTR_REVERSE 4
COLOR_BACKGROUND 0
COLOR_FOREGROUND 7
COLOR_CODE_GET(code, fore)        (((code) & ((fore) ? 0xF0 : 0x0F))            >> ((fore) ? 4 : 0))
COLOR_CODE_SET(code, color, fore) (((code) & ((fore) ? 0x0F : 0xF0)) | ((color) << ((fore) ? 4 : 0)))
MAXPARS 16
REN_MAX_DEPTH 32
CONFIG_VC_PROGRESS_METER_SUPPORT 1
CLUT_MASK_R 0xf8
CLUT_MASK_G 0xf8
CLUT_MASK_B 0xf8
CLUT_SHIFT_R << 7
CLUT_SHIFT_G << 2
CLUT_SHIFT_B >> 3
MASK_R 0x7c00
MASK_G 0x03e0
MASK_B 0x001f
MASK_R_8 0x3fc00
MASK_G_8 0x01fe0
MASK_B_8 0x000ff
N 4096
F 18
THRESHOLD 2
_VIDEO_CONSOLE_H_ None
kVCSysctlProgressOptions "kern.progressoptions"
kVCSysctlConsoleOptions "kern.consoleoptions"
kVCSysctlProgressMeterEnable "kern.progressmeterenable"
kVCSysctlProgressMeter "kern.progressmeter"
_CORECRYPTO_CCAES_VNG_GCM_H_ None
_CORECRYPTO_CCDIGEST_INTERNAL_H_ None
_CORECRYPTO_CCDRBG_INTERNAL_H_ None
CCDRBG_TRNG_VECTOR_LEN 48
DRBG_HMAC_MAX_OUTPUT_SIZE MAX_DIGEST_OUTPUT_SIZE
DRBG_NISTHMAC_DEBUG 0
_CORECRYPTO_CCMODE_GCM_INTERNAL_H_ None
CCGCM_IV_NBYTES 12
CCGCM_BLOCK_NBYTES 16
CCGCM_FLAGS_INIT_WITH_IV 1
CCMODE_GCM_STATE_IV 1
CCMODE_GCM_STATE_AAD 2
CCMODE_GCM_STATE_TEXT 3
CCMODE_GCM_STATE_FINAL 4
_CORECRYPTO_CCMODE_INTERNAL_H_ None
CCMODE_CBC_FACTORY(_cipher_, _dir_)                                     static CC_READ_ONLY_LATE(struct ccmode_cbc) cbc_##_cipher_##_##_dir_;                                                                                           const struct ccmode_cbc *cc##_cipher_##_cbc_##_dir_##_mode(void)                {                                                                                   if (!CC_CACHE_DESCRIPTORS || NULL == cbc_##_cipher_##_##_dir_.init) {        	const struct ccmode_ecb *ecb=cc##_cipher_##_ecb_##_dir_##_mode();       	ccmode_factory_cbc_##_dir_(&cbc_##_cipher_##_##_dir_, ecb);                 }                                                                               return &cbc_##_cipher_##_##_dir_;                                           }
CCMODE_CTR_FACTORY(_cipher_) static struct ccmode_ctr ctr_##_cipher_;                                                                                                                        const struct ccmode_ctr *cc##_cipher_##_ctr_crypt_mode(void)                    {                                                                                   const struct ccmode_ecb *ecb=cc##_cipher_##_ecb_encrypt_mode();                 ccmode_factory_ctr_crypt(&ctr_##_cipher_, ecb);                                 return &ctr_##_cipher_;                                                     }
CCMODE_OFB_FACTORY(_cipher_) static struct ccmode_ofb ofb_##_cipher_;                                                                                                                        const struct ccmode_ofb *cc##_cipher_##_ofb_crypt_mode(void)                    {                                                                                   const struct ccmode_ecb *ecb=cc##_cipher_##_ecb_encrypt_mode();                 ccmode_factory_ofb_crypt(&ofb_##_cipher_, ecb);                                 return &ofb_##_cipher_;                                                     }
CCMODE_CFB_FACTORY(_cipher_, _mode_, _dir_)                             static CC_READ_ONLY_LATE(struct ccmode_##_mode_) _mode_##_##_cipher_##_##_dir_;                                                                                 const struct ccmode_##_mode_ *cc##_cipher_##_##_mode_##_##_dir_##_mode(void)    {                                                                                   if (!CC_CACHE_DESCRIPTORS || NULL == _mode_##_##_cipher_##_##_dir_.init) {   	const struct ccmode_ecb *ecb=cc##_cipher_##_ecb_encrypt_mode();         	ccmode_factory_##_mode_##_##_dir_(&_mode_##_##_cipher_##_##_dir_, ecb);     }                                                                               return &_mode_##_##_cipher_##_##_dir_;                                      }
CCMODE_FACTORY_CBC_DECRYPT(ECB) { .size = ccn_sizeof_size(sizeof(struct _ccmode_cbc_key)) + ccn_sizeof_size((ECB)->block_size) + ccn_sizeof_size((ECB)->size), .block_size = (ECB)->block_size, .init = ccmode_cbc_init, .cbc = ccmode_cbc_decrypt, .custom = (ECB) }
CCMODE_FACTORY_CBC_ENCRYPT(ECB) { .size = ccn_sizeof_size(sizeof(struct _ccmode_cbc_key)) + ccn_sizeof_size((ECB)->block_size) + ccn_sizeof_size((ECB)->size), .block_size = (ECB)->block_size, .init = ccmode_cbc_init, .cbc = ccmode_cbc_encrypt, .custom = (ECB) }
CCMODE_FACTORY_CFB_DECRYPT(ECB) { .size = ccn_sizeof_size(sizeof(struct _ccmode_cfb_key)) + 2 * ccn_sizeof_size((ECB)->block_size) + ccn_sizeof_size((ECB)->size), .block_size = 1, .init = ccmode_cfb_init, .cfb = ccmode_cfb_decrypt, .custom = (ECB) }
CCMODE_FACTORY_CFB_ENCRYPT(ECB) { .size = ccn_sizeof_size(sizeof(struct _ccmode_cfb_key)) + 2 * ccn_sizeof_size((ECB)->block_size) + ccn_sizeof_size((ECB)->size), .block_size = 1, .init = ccmode_cfb_init, .cfb = ccmode_cfb_encrypt, .custom = (ECB) }
CCMODE_FACTORY_CFB8_DECRYPT(ECB) { .size = ccn_sizeof_size(sizeof(struct _ccmode_cfb8_key)) + 2 * ccn_sizeof_size((ECB)->block_size) + ccn_sizeof_size((ECB)->size), .block_size = 1, .init = ccmode_cfb8_init, .cfb8 = ccmode_cfb8_decrypt, .custom = (ECB) }
CCMODE_FACTORY_CFB8_ENCRYPT(ECB) { .size = ccn_sizeof_size(sizeof(struct _ccmode_cfb8_key)) + 2 * ccn_sizeof_size((ECB)->block_size) + ccn_sizeof_size((ECB)->size), .block_size = 1, .init = ccmode_cfb8_init, .cfb8 = ccmode_cfb8_encrypt, .custom = (ECB) }
CCMODE_FACTORY_CTR_CRYPT(ECB_ENCRYPT) { .size = ccn_sizeof_size(sizeof(struct _ccmode_ctr_key)) + 2 * ccn_sizeof_size((ECB_ENCRYPT)->block_size) + ccn_sizeof_size((ECB_ENCRYPT)->size), .block_size = 1, .ecb_block_size = (ECB_ENCRYPT)->block_size, .init = ccmode_ctr_init, .setctr = ccmode_ctr_setctr, .ctr = ccmode_ctr_crypt, .custom = (ECB_ENCRYPT) }
CCMODE_FACTORY_OFB_CRYPT(ECB) { .size = ccn_sizeof_size(sizeof(struct _ccmode_ofb_key)) + ccn_sizeof_size((ECB)->block_size) + ccn_sizeof_size((ECB)->size), .block_size = 1, .init = ccmode_ofb_init, .ofb = ccmode_ofb_crypt, .custom = (ECB) }
CCMODE_FACTORY_XTS_DECRYPT(ECB, ECB_ENCRYPT) { .size = ccn_sizeof_size(sizeof(struct _ccmode_xts_key)) + 2 * ccn_sizeof_size((ECB)->size), .tweak_size = ccn_sizeof_size(sizeof(struct _ccmode_xts_tweak)) + ccn_sizeof_size(ecb->block_size), .block_size = ecb->block_size, .init = ccmode_xts_init, .key_sched = ccmode_xts_key_sched, .set_tweak = ccmode_xts_set_tweak, .xts = ccmode_xts_crypt, .custom = (ECB), .custom1 = (ECB_ENCRYPT), .impl = CC_IMPL_AES_XTS_GENERIC, }
CCMODE_FACTORY_XTS_ENCRYPT(ECB, ECB_ENCRYPT) { .size = ccn_sizeof_size(sizeof(struct _ccmode_xts_key)) + 2 * ccn_sizeof_size((ECB)->size), .tweak_size = ccn_sizeof_size(sizeof(struct _ccmode_xts_tweak)) + ccn_sizeof_size(ecb->block_size), .block_size = ecb->block_size, .init = ccmode_xts_init, .key_sched = ccmode_xts_key_sched, .set_tweak = ccmode_xts_set_tweak, .xts = ccmode_xts_crypt, .custom = (ECB), .custom1 = (ECB_ENCRYPT), .impl = CC_IMPL_AES_XTS_GENERIC, }
CCMODE_XTS_TWEAK_BLOCK_PROCESSED(T)(_CCMODE_XTS_TWEAK(T)->blocks_processed) None
CCMODE_STATE_INIT 2
CCMODE_STATE_IV_START 3
CCMODE_STATE_IV_CONT CCMODE_STATE_IV_START
CCMODE_STATE_AAD 4
CCMODE_STATE_TEXT 5
CCMODE_STATE_NONCE 6
CCMODE_STATE_NONCE_NOADD 7
CCMODE_CCM_STATE_IV 1
CCMODE_STATE_INVALID 255
CCMODE_FACTORY_CCM_DECRYPT(ECB_ENCRYPT) { .size = ccn_sizeof_size(sizeof(struct _ccmode_ccm_key)) + ccn_sizeof_size((ECB_ENCRYPT)->block_size) + ccn_sizeof_size((ECB_ENCRYPT)->size), .nonce_size = ccn_sizeof_size(sizeof(struct _ccmode_ccm_nonce)), .block_size = 1, .init = ccmode_ccm_init, .set_iv = ccmode_ccm_set_iv, .cbcmac = ccmode_ccm_cbcmac, .ccm = ccmode_ccm_decrypt, .finalize = ccmode_ccm_finalize, .reset = ccmode_ccm_reset, .custom = (ECB_ENCRYPT), .enc_mode = false, }
CCMODE_FACTORY_CCM_ENCRYPT(ECB_ENCRYPT) { .size = ccn_sizeof_size(sizeof(struct _ccmode_ccm_key)) + ccn_sizeof_size((ECB_ENCRYPT)->block_size) + ccn_sizeof_size((ECB_ENCRYPT)->size), .nonce_size = ccn_sizeof_size(sizeof(struct _ccmode_ccm_nonce)), .block_size = 1, .init = ccmode_ccm_init, .set_iv = ccmode_ccm_set_iv, .cbcmac = ccmode_ccm_cbcmac, .ccm = ccmode_ccm_encrypt, .finalize = ccmode_ccm_finalize, .reset = ccmode_ccm_reset, .custom = (ECB_ENCRYPT), .enc_mode = true, }
CCMODE_FACTORY_OMAC_DECRYPT(ECB) { .size = ccn_sizeof_size(sizeof(struct _ccmode_omac_key)) + 2 * ccn_sizeof_size((ECB)->size), .block_size = (ECB)->block_size, .init = ccmode_omac_init, .omac = ccmode_omac_decrypt, .custom = (ECB) }
CCMODE_FACTORY_OMAC_ENCRYPT(ECB) { .size = ccn_sizeof_size(sizeof(struct _ccmode_omac_key)) + 2 * ccn_sizeof_size((ECB)->size), .block_size = (ECB)->block_size, .init = ccmode_omac_init, .omac = ccmode_omac_encrypt, .custom = (ECB) }
_CORECRYPTO_CCN_INTERNAL_H None
ccn_mod_ws(ws, na, a, n, r, d) ccn_divmod_ws(ws, na, a, 0, NULL, n, r, d)
ccn_mod(na, a, n, r, d) ccn_divmod(na, a, 0, NULL, n, r, d)
_CORECRYPTO_CCSHA2_INTERNAL_H_ None
CCSHA2_DISABLE_SHA512 0
_CORECRYPTO_CCN_DEBUG_H_ None
_CORECRYPTO_CC_INTERNAL_H_ None
cc_add_overflow __builtin_add_overflow
CC_HEAVISIDE_STEP(r, s) do {                                             cc_static_assert(sizeof(uint64_t) >= sizeof(s), "max type is uint64_t");     const uint64_t _s = (uint64_t)s;                                             const uint64_t _t = (_s & 0xffffffff) | (_s >> 32);                          r = (uint8_t)((_t + 0xffffffff) >> 32);                                  } while (0)
CC_MUXU(r, s, a, b) do {                cc_assert((s) == 0 || (s) == 1);            r = (~((s)-1) & (a)) | (((s)-1) & (b)); } while (0)
_CORECRYPTO_CC_MACROS_H_ None
__CC_DEBUG_ASSERT_COMPONENT_NAME_STRING ""
__CC_DEBUG_ASSERT_PRODUCTION_CODE !CORECRYPTO_DEBUG
_CORECRYPTO_CC_MEMORY_H_ None
CC_DECL_WORKSPACE_TEST(ws) int ws##_rv;                                                      CC_DECL_WORKSPACE_RV(ws, ccn_nof_size(1024 * 1024), ws##_rv);     cc_try_abort_if(ws##_rv != CCERR_OK, "alloc ws");
CC_DECL_WORKSPACE_NULL(ws) cc_ws ws##_ctx = { NULL, 0, 0, cc_ws_alloc, cc_ws_free_null };       cc_ws_t ws = &ws##_ctx;                                              cc_ws_alloc_debug(&ws, __FILE__, __LINE__, __func__);
CC_DECL_WORKSPACE_OR_FAIL(ws, n)      int ws##_rv;                              CC_DECL_WORKSPACE_RV(ws, n, ws##_rv);     if (ws##_rv != CCERR_OK)              	return ws##_rv;
CC_FREE_WORKSPACE(ws) cc_ws_free_debug(&ws);        ws->free(ws);
CC_CLEAR_AND_FREE_WORKSPACE CC_FREE_WORKSPACE
CC_DECL_BP_WS(ws, bp) cc_size _ws_offset = ws->offset;
CC_FREE_BP_WS(ws, bp) ws->offset = _ws_offset;
CC_CLEAR_BP_WS(ws, bp)     ccn_clear(ws->offset - _ws_offset, &((cc_unit *)ws->ctx)[_ws_offset]);
CC_ALLOC_WS(ws, n) ws->alloc(ws, n)
CORECRYPTO_CC_RUNTIME_CONFIG_H_ None
_CORECRYPTO_CC_WORKSPACES_H_ None
_CORECRYPTO_FIPSPOST_TRACE_H_ None
_TASK_CORPSE_H_ None
CRASHINFO_ITEM_TYPE(item) KCDATA_ITEM_TYPE(item)
CRASHINFO_ITEM_SIZE(item) KCDATA_ITEM_SIZE(item)
CRASHINFO_ITEM_DATA_PTR(item) KCDATA_ITEM_DATA_PTR(item)
CRASHINFO_ITEM_NEXT_HEADER(item) KCDATA_ITEM_NEXT_HEADER(item)
CRASHINFO_ITEM_FOREACH(head) KCDATA_ITEM_FOREACH(head)
TOTAL_USER_FAULTS_ALLOWED 1
_MACH_DEFAULT_PAGER_TYPES_H_ None
_DEVICE_DEVICE_PORT_H_ None
DEVICE_PAGER_GUARDED 0x1
DEVICE_PAGER_COHERENT 0x2
DEVICE_PAGER_CACHE_INHIB 0x4
DEVICE_PAGER_WRITE_THROUGH 0x8
DEVICE_PAGER_CONTIGUOUS 0x100
DEVICE_PAGER_NOPHYSCACHE 0x200
DEVICE_TYPES_H None
IOKIT_SERVER_VERSION 20210810
EXTERN None
MIGEXTERN None
_GSSD_MACH_TYPES_H_ None
MAX_DISPLAY_STR 128
MAX_PRINC_STR 1024
GSSD_DELEG_FLAG 1
GSSD_MUTUAL_FLAG 2
GSSD_REPLAY_FLAG 4
GSSD_SEQUENCE_FLAG 8
GSSD_CONF_FLAG 16
GSSD_INTEG_FLAG 32
GSSD_ANON_FLAG 64
GSSD_PROT_FLAG 128
GSSD_TRANS_FLAG 256
GSSD_DELEG_POLICY_FLAG 32768
GSSD_NO_DEFAULT 1
GSSD_NO_CANON 2
GSSD_HOME_ACCESS_OK 4
GSSD_GUEST_ONLY 8
GSSD_RESTART 16
GSSD_NFS_1DES 64
GSSD_WIN2K_HACK 128
GSSD_LUCID_CONTEXT 256
UINT64 uint64_t
UINT32 uint32_t
UINT16 uint16_t
UINT8 uint8_t
RSDP_VERSION_ACPI10 0
RSDP_VERSION_ACPI20 2
SEARCH_FOR_ACPI_TABLE(sdtp, signature, entry_type) {                                                                                               	uint32_t i, pointer_count;                                                                                                                                                              	          	pointer_count = ((sdtp)->Length - sizeof(ACPI_TABLE_HEADER)) / sizeof(entry_type);                                                                                                      	for (i = 0; i < pointer_count; i++) {                                                   	        ACPI_TABLE_HEADER *next_table =                                                 	                (ACPI_TABLE_HEADER *)PHYSMAP_PTOV(                                      	                        (uintptr_t)(sdtp)->TableOffsetEntry[i]);                        	        if (strncmp(&next_table->Signature[0], (signature), 4) == 0) {                  	                                                                                     	                if (cksum8((uint8_t *)next_table, next_table->Length) == 0) {           	                        return next_table;                                              	                } else {                                                                	                        DBG("Invalid checksum for table [%s]@0x%lx!\n", (signature),    	                            (unsigned long)(sdtp)->TableOffsetEntry[i]);                	                        return NULL;                                                    	                }                                                                       	        }                                                                               	}                                                                                                                                                                                       	return NULL;                                                                            }
_I386_ACPI_H_ None
PROT_MODE_START 0x800
REAL_MODE_BOOTSTRAP_OFFSET 0x2000
_I386_APIC_H_ None
IOAPIC_START 0xFEC00000
IOAPIC_SIZE 0x00000020
IOAPIC_RSELECT 0x00000000
IOAPIC_RWINDOW 0x00000010
IOA_R_ID 0x00
IOA_R_ID_SHIFT 24
IOA_R_VERSION 0x01
IOA_R_VERSION_MASK 0xFF
IOA_R_VERSION_ME_SHIFT 16
IOA_R_VERSION_ME_MASK 0xFF
IOA_R_REDIRECTION 0x10
IOA_R_R_VECTOR_MASK 0x000FF
IOA_R_R_DM_MASK 0x00700
IOA_R_R_DM_FIXED 0x00000
IOA_R_R_DM_LOWEST 0x00100
IOA_R_R_DM_NMI 0x00400
IOA_R_R_DM_RESET 0x00500
IOA_R_R_DM_EXTINT 0x00700
IOA_R_R_DEST_LOGICAL 0x00800
IOA_R_R_DS_PENDING 0x01000
IOA_R_R_IP_PLRITY_LOW 0x02000
IOA_R_R_TM_LEVEL 0x08000
IOA_R_R_MASKED 0x10000
_MACHINE_ARCH_TYPES_H_ None
_I386_ASM_H_ None
ENTER_64BIT_MODE() push	$KERNEL64_CS			;	call    1f				;1:	addl    $(2f-1b), (%esp)		;	lret					;2:	.code64
ENTER_COMPAT_MODE() call	3f				;3:	addq	$(4f-3b), (%rsp)		;	movl	$KERNEL32_CS, 4(%rsp)		;	lret					;4:	.code32
_I386_ATOMIC_H_ None
_I386_BIT_ROUTINES_H_ None
bit_lock(bit,l) __asm__ volatile("	jmp	1f	\n					 	0:	btl	%0, %1	\n							jb	0b	\n						1:	lock		\n							btsl	%0,%1	\n							jb	0b"			:									:				"r" (bit), "m" (*(volatile int *)(l))	:				"memory");
bit_unlock(bit,l) __asm__ volatile("	lock		\n							btrl	%0,%1"			:									:				"r" (bit), "m" (*(volatile int *)(l)));
i_bit_set(bit,l) __asm__ volatile("	lock		\n							btsl	%0,%1"			:									:				"r" (bit), "m" (*(volatile int *)(l)));
i_bit_clear(bit,l) __asm__ volatile("	lock		\n							btrl	%0,%1"			:									:				"r" (bit), "m" (*(volatile int *)(l)));
DBG(x...) do {                            	        if (cpuid_dbg)          	                kprintf(x);     	} while (0)
min(a, b) ((a) < (b) ? (a) : (b))
quad(hi, lo)     (((uint64_t)(hi)) << 32 | (lo))
_MACHINE_CPUID_H_ None
_I386_CPU_AFFINITY_H_ None
_I386_CPU_CAPABILITIES_H None
I386_CPU_DATA None
cpu_pd cpu_pal_data
HWINTCNT_SIZE 256
current_thread_fast() get_active_thread()
current_thread_volatile() get_active_thread_volatile()
cpu_mode_is64bit() TRUE
disable_preemption() disable_preemption_internal()
disable_preemption_without_measurements() disable_preemption_internal()
enable_preemption() enable_preemption_internal()
_I386_CPU_NUMBER_H_ None
DIVISOR_GUARD(denom) if ((denom) == 0) {                             	        kprintf("%s: %d Zero divisor: " #denom, 	                __FILE__, __LINE__);            	}
_I386_CPU_THREADS_H_ None
CPU_THREAD_MASK 0x00000001
cpu_is_same_core(cpu1, cpu2)     (cpu_to_core(cpu1) == cpu_to_core(cpu2))
cpu_is_same_die(cpu1, cpu2)      (cpu_to_die(cpu1) == cpu_to_die(cpu2))
cpu_is_same_package(cpu1, cpu2)  (cpu_to_package(cpu1) == cpu_to_package(cpu2))
cpus_share_cache(cpu1, cpu2, _cl) (cpu_to_lcpu(cpu1)->caches[_cl] == cpu_to_lcpu(cpu2)->caches[_cl])
TOPO_DBG(x...) do {                            	        if (topo_dbg)           	                kprintf(x);     	} while (0)
_I386_CPU_TOPOLOGY_H_ None
CPU_CACHE_TYPE_DATA 1
CPU_CACHE_TYPE_INST 2
CPU_CACHE_TYPE_UNIF 3
CPU_CACHE_DEPTH_L1 0
CPU_CACHE_DEPTH_L2 1
CPU_CACHE_DEPTH_L3 2
MAX_CACHE_DEPTH 3
X86CORE_FL_PRESENT 0x80000000
X86CORE_FL_READY 0x40000000
X86CORE_FL_HAS_HPET 0x10000000
X86CORE_FL_HALTED 0x00008000
X86CORE_FL_IDLE 0x00004000
X86DIE_FL_PRESENT 0x80000000
X86DIE_FL_READY 0x40000000
X86PKG_FL_PRESENT 0x80000000
X86PKG_FL_READY 0x40000000
X86PKG_FL_HAS_HPET 0x10000000
X86PKG_FL_HALTED 0x00008000
X86PKG_FL_IDLE 0x00004000
_DIAGNOSTICS_H_ None
diagSCnum 0x00006000
dgAdjTB 0
dgLRA 1
dgpcpy 2
dgreset 3
dgtest 4
dgBMphys 5
dgUnMap 6
dgBootScreen 7
dgFlush 8
dgAlign 9
dgGzallocTest 10
dgmck 11
dg64 12
dgProbeRead 13
dgCPNull 14
dgPerfMon 15
dgMapPage 16
dgPowerStat 17
dgBind 18
dgAcntg 20
dgKlra 21
dgEnaPMC 22
dgWar 23
dgNapStat 24
dgRuptStat 25
dgPermCheck 26
enaExpTrace 0x00000001
enaUsrFCall 0x00000002
enaUsrPhyMp 0x00000004
enaDiagSCs 0x00000008
enaDiagDM 0x00000010
enaDiagEM 0x00000020
enaDiagTrap 0x00000040
enaNotifyEM 0x00000080
_I386_EFLAGS_H_ None
_MACHINE_ENDIAN_H_ None
LITTLE_ENDIAN 1234
BIG_ENDIAN 4321
PDP_ENDIAN 3412
BYTE_ORDER LITTLE_ENDIAN
ENDIAN LITTLE
_EXEC_ 1
OMAGIC 0407
NMAGIC 0410
ZMAGIC 0413
ALIGNED(addr, size)      (((uintptr_t)(addr)&((size)-1))==0)
VERIFY_SAVEAREA_ALIGNED(p, a) 	assertf(!(((uintptr_t)(p)) & ((a) - 1)), 	    "FP save area component @ 0x%lx not 8-byte aligned", ((uintptr_t)(p)))
fninit() __asm__ volatile("fninit")
fnstcw(control) __asm__("fnstcw %0" : "=m" (*(unsigned short *)(control)))
fldcw(control) __asm__ volatile("fldcw %0" : : "m" (*(unsigned short *) &(control)) )
fnclex() __asm__ volatile("fnclex")
fnsave(state) __asm__ volatile("fnsave %0" : "=m" (*state))
frstor(state) __asm__ volatile("frstor %0" : : "m" (state))
fwait() __asm__("fwait");
AVX512_OFFSET offsetof(struct x86_avx512_thread_state, x_Opmask)
ASSERT_PACKED(t, m1, m2, n, mt)                 extern char assert_packed_ ## t ## _ ## m1 ## _ ## m2   	[(offsetof(t,m2) - offsetof(t,m1) == (n - 1)*sizeof(mt)) ? 1 : -1]
_I386_FPU_H_ None
STATE64_FULL 0x10
DECLARE(SYM, VAL) 	__asm("DEFINITION__define__" SYM ":\t .ascii \"%0\"" : : "n"  ((u_int)(VAL)))
DECLAREULL(SYM, VAL) 	__asm("DEFINITION__define__" SYM ":\t .ascii \"%0\"" : : "i"  ((unsigned long long)(VAL)))
R_(x) offsetof(x86_saved_state_t, ss_32.x)
R64_(x) offsetof(x86_saved_state_t, ss_64.x)
ISF64_(x) offsetof(x86_64_intr_stack_frame_t, x)
MAX_BANKS 32
_I386_HPET_H_ None
TIM_CONF 0
Tn_INT_ENB_CNF 4
TIM_COMP 8
HPET_REQFL_64BIT 0x00000001
hpetAddr 0xFED00000
hptcAE 0x80
_I386_HW_DEFS_H_ None
pmMwaitC1 0x00
pmMwaitC2 0x10
pmMwaitC3 0x20
pmMwaitC4 0x30
pmMwaitBrInt 0x1
pmBase 0x400
pmCtl1 0x04
pmCtl2 0x20
pmC3Res 0x54
pmStatus 0x00
msrTSC 0x10
cfgAdr 0xCF8
cfgDat 0xCFC
BOOT_TRAP_VECTOR(t) [t] = {                                         	        (uintptr_t) &vstart_trap_handler,       	        KERNEL64_CS,                            	        0,                                      	        ACC_P|ACC_PL_K|ACC_INTR_GATE,           	        0                                       	},
L0(x, n)  x(n)
L1(x, n)  L0(x,n-1)     L0(x,n)
L2(x, n)  L1(x,n-2)     L1(x,n)
L3(x, n)  L2(x,n-4)     L2(x,n)
L4(x, n)  L3(x,n-8)     L3(x,n)
L5(x, n)  L4(x,n-16)    L4(x,n)
FOR_0_TO_31(x) L5(x,31)
_I386_LOWMEM_H_ None
P2ROUNDUP(x, align)             (-(-(x) & -(align)))
FOURGIG 0x0000000100000000ULL
ONEGIG 0x0000000040000000ULL
_I386_IOPB_H_ None
iopb_howmany(a, b)       (((a)+(b)-1)/(b))
IOPB_MAX 0xffff
_I386_IO_PORT_H_ None
_I386_LAPIC_H_ None
LAPIC_START 0xFEE00000
LAPIC_SIZE 0x00000400
LAPIC_ID 0x00000020
LAPIC_ID_SHIFT 24
LAPIC_ID_MASK 0xFF
LAPIC_VERSION 0x00000030
LAPIC_VERSION_MASK 0xFF
LAPIC_TPR 0x00000080
LAPIC_TPR_MASK 0xFF
LAPIC_APR 0x00000090
LAPIC_APR_MASK 0xFF
LAPIC_PPR 0x000000A0
LAPIC_PPR_MASK 0xFF
LAPIC_EOI 0x000000B0
LAPIC_REMOTE_READ 0x000000C0
LAPIC_LDR 0x000000D0
LAPIC_LDR_SHIFT 24
LAPIC_DFR 0x000000E0
LAPIC_DFR_FLAT 0xFFFFFFFF
LAPIC_DFR_CLUSTER 0x0FFFFFFF
LAPIC_DFR_SHIFT 28
LAPIC_SVR 0x000000F0
LAPIC_SVR_MASK 0x0FF
LAPIC_SVR_ENABLE 0x100
LAPIC_SVR_FOCUS_OFF 0x200
LAPIC_ISR_BASE 0x00000100
LAPIC_TMR_BASE 0x00000180
LAPIC_IRR_BASE 0x00000200
LAPIC_ERROR_STATUS 0x00000280
LAPIC_LVT_CMCI 0x000002F0
LAPIC_ICR 0x00000300
LAPIC_ICR_VECTOR_MASK 0x000FF
LAPIC_ICR_DM_MASK 0x00700
LAPIC_ICR_DM_FIXED 0x00000
LAPIC_ICR_DM_LOWEST 0x00100
LAPIC_ICR_DM_SMI 0x00200
LAPIC_ICR_DM_REMOTE 0x00300
LAPIC_ICR_DM_NMI 0x00400
LAPIC_ICR_DM_INIT 0x00500
LAPIC_ICR_DM_STARTUP 0x00600
LAPIC_ICR_DM_LOGICAL 0x00800
LAPIC_ICR_DS_PENDING 0x01000
LAPIC_ICR_LEVEL_ASSERT 0x04000
LAPIC_ICR_TRIGGER_LEVEL 0x08000
LAPIC_ICR_RR_MASK 0x30000
LAPIC_ICR_RR_INVALID 0x00000
LAPIC_ICR_RR_INPROGRESS 0x10000
LAPIC_ICR_RR_VALID 0x20000
LAPIC_ICR_DSS_MASK 0xC0000
LAPIC_ICR_DSS_DEST 0x00000
LAPIC_ICR_DSS_SELF 0x40000
LAPIC_ICR_DSS_ALL 0x80000
LAPIC_ICR_DSS_OTHERS 0xC0000
LAPIC_ICRD 0x00000310
LAPIC_ICRD_DEST_SHIFT 24
LAPIC_LVT_TIMER 0x00000320
LAPIC_LVT_THERMAL 0x00000330
LAPIC_LVT_PERFCNT 0x00000340
LAPIC_LVT_LINT0 0x00000350
LAPIC_LVT_LINT1 0x00000360
LAPIC_LVT_ERROR 0x00000370
LAPIC_LVT_VECTOR_MASK 0x000FF
LAPIC_LVT_DM_SHIFT 8
LAPIC_LVT_DM_MASK 0x00007
LAPIC_LVT_DM_FIXED 0x00000
LAPIC_LVT_DM_NMI 0x00400
LAPIC_LVT_DM_EXTINT 0x00700
LAPIC_LVT_DS_PENDING 0x01000
LAPIC_LVT_IP_PLRITY_LOW 0x02000
LAPIC_LVT_REMOTE_IRR 0x04000
LAPIC_LVT_TM_LEVEL 0x08000
LAPIC_LVT_MASKED 0x10000
LAPIC_LVT_PERIODIC 0x20000
LAPIC_LVT_TSC_DEADLINE 0x40000
LAPIC_LVT_TMR_SHIFT 17
LAPIC_LVT_TMR_MASK 3
LAPIC_TIMER_INITIAL_COUNT 0x00000380
LAPIC_TIMER_CURRENT_COUNT 0x00000390
LAPIC_TIMER_DIVIDE_CONFIG 0x000003E0
LAPIC_TIMER_DIVIDE_MASK 0x0000000F
LAPIC_TIMER_DIVIDE_2 0x00000000
LAPIC_TIMER_DIVIDE_4 0x00000001
LAPIC_TIMER_DIVIDE_8 0x00000002
LAPIC_TIMER_DIVIDE_16 0x00000003
LAPIC_TIMER_DIVIDE_32 0x00000008
LAPIC_TIMER_DIVIDE_64 0x00000009
LAPIC_TIMER_DIVIDE_128 0x0000000A
LAPIC_TIMER_DIVIDE_1 0x0000000B
CPU_NUMBER(r) movl	%gs:CPU_NUMBER_GS,r
LAPIC_MMIO_PBASE 0xFEE00000
LAPIC_MMIO_VBASE lapic_vbase
LAPIC_MSR_BASE 0x800
LAPIC_INIT() lapic_ops->init();
LAPIC_WRITE(reg, val)           lapic_ops->write(reg, val)
LAPIC_READ(reg) lapic_ops->read(reg)
LAPIC_READ_OFFSET(reg, off)     LAPIC_READ((lapic_register_t)((reg)+(off)))
LAPIC_READ_ICR() lapic_ops->read_icr()
LAPIC_WRITE_ICR(dst, cmd)       lapic_ops->write_icr(dst, cmd)
LAPIC_DEFAULT_INTERRUPT_BASE 0xD0
LAPIC_REDUCED_INTERRUPT_BASE 0x50
LAPIC_PERFCNT_INTERRUPT 0xF
LAPIC_INTERPROCESSOR_INTERRUPT 0xE
LAPIC_TIMER_INTERRUPT 0xD
LAPIC_THERMAL_INTERRUPT 0xC
LAPIC_ERROR_INTERRUPT 0xB
LAPIC_SPURIOUS_INTERRUPT 0xA
LAPIC_CMCI_INTERRUPT 0x9
LAPIC_PMC_SW_INTERRUPT 0x8
LAPIC_PM_INTERRUPT 0x7
LAPIC_KICK_INTERRUPT 0x6
LAPIC_NMI_INTERRUPT 0x2
LAPIC_ISR_IS_SET(base, src) 	(LAPIC_READ_OFFSET(ISR_BASE,(base+LAPIC_##src##_INTERRUPT)/32) 	        & (1 <<((base + LAPIC_##src##_INTERRUPT)%32)))
VEC(lvt) LAPIC_READ(lvt)&LAPIC_LVT_VECTOR_MASK
DM(lvt) DM_str[(LAPIC_READ(lvt)>>LAPIC_LVT_DM_SHIFT)&LAPIC_LVT_DM_MASK]
MASK(lvt) BOOL(LAPIC_READ(lvt)&LAPIC_LVT_MASKED)
_I386_LBR_H_ None
LBR_MAGIC 0x5352424CULL
_I386_LOCK_H_ None
_I386_LOCKS_H_ None
LCK_SPIN_TAG_DESTROYED 0x00002007
LOCK_PRIVATE 1
_I386_LOCKS_I386_INLINES_H_ None
LOCK_PRIVATE 1
ATOMIC_PRIVATE 1
LOCK_PRIVATE 1
MACHDEP_MAX_ARGS 4
MACHDEP_CALL_ROUTINE(func, args)        	{ { .args_ ## args = func }, args, 0 }
MACHDEP_CALL_ROUTINE64(func, args)      	{ { .args64_ ## args = func }, args, 0 }
MACHDEP_BSD_CALL_ROUTINE(func, args)    	{ { .args_bsd_ ## args = func }, args, 1 }
MACHDEP_BSD_CALL_ROUTINE64(func, args)    	{ { .args64_bsd_ ## args = func }, args, 1 }
IF(bool, str)    ((bool) ? (str) : "")
_I386_MACHINE_CHECK_H_ None
BITS(n, m)       ((n)-(m)+1)
IA32_MC0_CTL IA32_MCi_CTL(0)
IA32_MC0_STATUS IA32_MCi_STATUS(0)
IA32_MC0_ADDR IA32_MCi_ADDR(0)
IA32_MC0_MISC IA32_MCi_MISC(0)
IA32_MC1_CTL IA32_MCi_CTL(1)
IA32_MC1_STATUS IA32_MCi_STATUS(1)
IA32_MC1_ADDR IA32_MCi_ADDR(1)
IA32_MC1_MISC IA32_MCi_MISC(1)
IA32_MC2_CTL IA32_MCi_CTL(2)
IA32_MC2_STATUS IA32_MCi_STATUS(2)
IA32_MC2_ADDR IA32_MCi_ADDR(2)
IA32_MC2_MISC IA32_MCi_MISC(2)
IA32_MC3_CTL IA32_MCi_CTL(3)
IA32_MC3_STATUS IA32_MCi_STATUS(3)
IA32_MC3_ADDR IA32_MCi_ADDR(3)
IA32_MC3_MISC IA32_MCi_MISC(3)
IA32_MC4_CTL IA32_MCi_CTL(4)
IA32_MC4_STATUS IA32_MCi_STATUS(4)
IA32_MC4_ADDR IA32_MCi_ADDR(4)
IA32_MC4_MISC IA32_MCi_MISC(4)
THRESHOLD_STATUS_NO_TRACKING 0
THRESHOLD_STATUS_GREEN 1
THRESHOLD_STATUS_YELLOW 2
THRESHOLD_STATUS_RESERVED 3
_I386_MACHINE_CPU_H_ None
MAX_CPUS_SET 0x1
MAX_CPUS_WAIT 0x2
VIRTUAL_TIMEOUT_INFLATE_ABS(_timeout) MACRO_BEGIN                                                	_timeout = virtual_timeout_inflate_abs(vti, _timeout); MACRO_END
VIRTUAL_TIMEOUT_INFLATE_TSC(_timeout) MACRO_BEGIN                                                	_timeout = virtual_timeout_inflate_tsc(vti, _timeout); MACRO_END
VIRTUAL_TIMEOUT_INFLATE_US(_timeout) MACRO_BEGIN                                                	_timeout = virtual_timeout_inflate_us(vti, _timeout);  MACRO_END
_I386_MACHINE_ROUTINES_H_ None
MACHINE_GROUP 0x00000001
MACHINE_NETWORK_GROUP 0x10000000
MACHINE_NETWORK_WORKLOOP 0x00000001
MACHINE_NETWORK_NETISR 0x00000002
ml_set_interrupts_enabled_with_debug(en, dbg) ml_set_interrupts_enabled(en);
_MACHINE_RPC_H_ None
_MACH_MACHLIMITS_H_ None
CHAR_BIT 8
SCHAR_MAX 127
UCHAR_MAX 255U
CHAR_MAX 127
USHRT_MAX 65535U
SHRT_MAX 32767
UINT_MAX 0xFFFFFFFFU
INT_MAX 2147483647
ULONG_MAX UINT_MAX
LONG_MAX INT_MAX
LONG_MIN INT_MIN
MB_LEN_MAX 4
_I386_MEMORY_TYPES_H_ None
VM_WIMG_COPYBACK VM_MEM_COHERENT
VM_WIMG_COPYBACKLW VM_WIMG_COPYBACK
VM_WIMG_DEFAULT VM_MEM_COHERENT
VM_WIMG_POSTED VM_WIMG_IO
VM_WIMG_POSTED_REORDERED VM_WIMG_IO
VM_WIMG_POSTED_COMBINED_REORDERED VM_WIMG_IO
VM_WIMG_INNERWBACK VM_MEM_COHERENT
VM_WIMG_RT VM_WIMG_WCOMB
_I386_MISC_PROTOS_H_ None
TRACE_MP_TLB_FLUSH MACHDBG_CODE(DBG_MACH_MP, 0)
TRACE_MP_CPUS_CALL MACHDBG_CODE(DBG_MACH_MP, 1)
TRACE_MP_CPUS_CALL_LOCAL MACHDBG_CODE(DBG_MACH_MP, 2)
TRACE_MP_CPUS_CALL_ACTION MACHDBG_CODE(DBG_MACH_MP, 3)
TRACE_MP_CPUS_CALL_NOBUF MACHDBG_CODE(DBG_MACH_MP, 4)
TRACE_MP_CPU_FAST_START MACHDBG_CODE(DBG_MACH_MP, 5)
TRACE_MP_CPU_START MACHDBG_CODE(DBG_MACH_MP, 6)
TRACE_MP_CPU_DEACTIVATE MACHDBG_CODE(DBG_MACH_MP, 7)
NUM_CPU_WARM_CALLS 20
MP_CPUS_CALL_BUFS_PER_CPU MAX_CPUS
_I386_MP_H_ None
MAX_CPUS 64
CPUMASK_ALL 0xffffffffffffffffULL
CPUMASK_SELF cpu_to_cpumask((cpu_t)cpu_number())
TRAP(n, name)           extern void *name ;
TRAP_ERR(n, name)       extern void *name ;
TRAP_SPC(n, name)       extern void *name ;
TRAP_IST1(n, name)      extern void *name ;
TRAP_IST2(n, name)      extern void *name ;
INTERRUPT(n) extern void *_intr_ ## n ;
USER_TRAP(n, name)      extern void *name ;
USER_TRAP_SPC(n, name)  extern void *name ;
TRAP(n, name)                   	[n] = {                         	        (uintptr_t)&name,       	        KERNEL64_CS,            	        0,                      	        K_INTR_GATE,            	        0                       	},
TRAP_ERR TRAP
TRAP_SPC TRAP
TRAP_IST1(n, name) 	[n] = {                         	        (uintptr_t)&name,       	        KERNEL64_CS,            	        1,                      	        K_INTR_GATE,            	        0                       	},
TRAP_IST2(n, name) 	[n] = {                         	        (uintptr_t)&name,       	        KERNEL64_CS,            	        2,                      	        K_INTR_GATE,            	        0                       	},
INTERRUPT(n) [n] = {                         	        (uintptr_t)&_intr_ ## n,	        KERNEL64_CS,            	        0,                      	        K_INTR_GATE,            	        0                       	},
USER_TRAP(n, name) 	[n] = {                         	        (uintptr_t)&name,       	        KERNEL64_CS,            	        0,                      	        U_INTR_GATE,            	        0                       	},
USER_TRAP_SPC USER_TRAP
_I386_MP_DESC_H_ None
__AT386_MP_EVENTS__ None
MP_EVENT_NAME_DECL() const char *mp_event_name[] = { 	"MP_TLB_FLUSH",         	"MP_KDP",               	"MP_KDB",               	"MP_AST",               	"MP_IDLE",              	"MP_UNIDLE",            	"MP_CALL",              	"MP_CALL_PM",           	"MP_LAST"               }
MTRR_LOCK() simple_lock(&mtrr_lock, LCK_GRP_NULL);
MTRR_UNLOCK() simple_unlock(&mtrr_lock);
IA32_MTRR_DEF_TYPE_MT 0x000000ff
IA32_MTRR_DEF_TYPE_FE 0x00000400
IA32_MTRR_DEF_TYPE_E 0x00000800
IA32_MTRRCAP_VCNT 0x000000ff
IA32_MTRRCAP_FIX 0x00000100
IA32_MTRRCAP_WC 0x00000400
IA32_MTRR_PHYMASK_VALID 0x0000000000000800ULL
IA32_MTRR_PHYSBASE_TYPE 0x00000000000000FFULL
_I386_MTRR_H_ None
_I386_PAL_HIBERNATE_H None
HIB_BASE segHIBB
HIB_ENTRYPOINT acpi_wake_prot_entry
_I386_PAL_LOCK_ASM_H None
PUSHF pushf
POPF popf
CLI cli
_I386_PAL_I386_H None
pal_dbg_page_fault(x, y, z)
pal_is_usable_memory(b, t)      (TRUE)
pal_hlt() __asm__ volatile ("sti; hlt")
pal_sti() __asm__ volatile ("sti")
pal_cli() __asm__ volatile ("cli")
pal_register_cache_state(t, v)
pal_execve_return(t) None
pal_thread_terminate_self(t) None
pal_ast_check(t) None
panic_display_pal_info() do { } while(0)
pal_kernel_announce() do { } while(0)
PAL_AICPM_PROPERTY_VALUE 0
pal_pmc_swi() __asm__ __volatile__("int %0"::"i"(LAPIC_PMC_SWI_VECTOR):"memory")
_I386_PAL_ROUTINES_H None
PAL_XCPM_PROPERTY_VALUE 3
PAL_VIRTUALIZED_PROPERTY_VALUE 4
PAL_AICPM_PROPERTY_NAME "intel_cpupm_matching"
_I386_PAL_RTCLOCK_ASM_H None
PANIC_HOOK_MAGIC1 0x4A1C400C
PANIC_HOOK_MAGIC2 0xC004C1A4
PANICHOOKS_H_ None
_I386_PANIC_NOTIFY_H None
ASSERT_IS_16BYTE_MULTIPLE_SIZEOF(_type_) extern char assert_is_16byte_multiple_sizeof_ ## _type_ 	        [(sizeof(_type_) % 16) == 0 ? 1 : -1]
I386_PIO_H None
_PMAP_MACHINE_ 1
INTEL_PGBYTES I386_PGBYTES
INTEL_PGSHIFT I386_PGSHIFT
intel_btop(x) i386_btop(x)
intel_ptob(x) i386_ptob(x)
intel_round_page(x) i386_round_page(x)
intel_trunc_page(x) i386_trunc_page(x)
NPGPTD 4ULL
PDESHIFT 21ULL
PTEMASK 0x1ffULL
PTEINDX 3ULL
PTESHIFT 12ULL
PDESIZE sizeof(pd_entry_t)
PTESIZE sizeof(pt_entry_t)
PG_FRAME 0x000FFFFFFFFFF000ULL
PTE_PER_PAGE 512
PML4SHIFT 39
PML4PGSHIFT 9
PDPTSHIFT 30
PDPTPGSHIFT 9
PDSHIFT 21
PDPGSHIFT 9
PTSHIFT 12
PTPGSHIFT 9
SUPERPAGE_NBASEPAGES 512
KERNEL_PML4_INDEX 511
KERNEL_PML4_COUNT 1
KVADDR(pmi, pdpi, pdi, pti)               	 ((vm_offset_t)                   	        ((uint64_t) -1    << 47)        | 	        ((uint64_t)(pmi)  << PML4SHIFT) | 	        ((uint64_t)(pdpi) << PDPTSHIFT) | 	        ((uint64_t)(pdi)  << PDESHIFT)  | 	        ((uint64_t)(pti)  << PTESHIFT))
NKPT 500
pdptnum(pmap, a) (((vm_offset_t)(a) >> PDPTSHIFT) & PDPTMASK)
pdenum(pmap, a) (((vm_offset_t)(a) >> PDESHIFT) & PDEMASK)
pdeidx(pmap, a)    (((a) >> PDSHIFT)   & ((1ULL<<(48 - PDSHIFT)) -1))
pdptidx(pmap, a)   (((a) >> PDPTSHIFT) & ((1ULL<<(48 - PDPTSHIFT)) -1))
pml4idx(pmap, a)   (((a) >> PML4SHIFT) & ((1ULL<<(48 - PML4SHIFT)) -1))
INTEL_PTE_VALID 0x00000001ULL
INTEL_PTE_WRITE 0x00000002ULL
INTEL_PTE_RW 0x00000002ULL
INTEL_PTE_USER 0x00000004ULL
INTEL_PTE_WTHRU 0x00000008ULL
INTEL_PTE_NCACHE 0x00000010ULL
INTEL_PTE_REF 0x00000020ULL
INTEL_PTE_MOD 0x00000040ULL
INTEL_PTE_PS 0x00000080ULL
INTEL_PTE_PAT 0x00000080ULL
INTEL_PTE_GLOBAL 0x00000100ULL
INTEL_PTE_PFN PG_FRAME
INTEL_PTE_INVALID 0
PTE_IS_COMPRESSED(x, ptep, pmap, vaddr)                            	((((x) & INTEL_PTE_VALID) == 0) &&        	 ((x) & INTEL_PTE_COMPRESSED) &&  	 ((!((x) & ~INTEL_PTE_COMPRESSED_MASK)) ||   	  pmap_compressed_pte_corruption_repair((x), &(x), (ptep), (pmap), (vaddr))))
PMAP_INVEPT_SINGLE_CONTEXT 1
INTEL_EPTP_AD 0x00000040ULL
INTEL_EPT_READ 0x00000001ULL
INTEL_EPT_WRITE 0x00000002ULL
INTEL_EPT_EX 0x00000004ULL
INTEL_EPT_IPAT 0x00000040ULL
INTEL_EPT_PS 0x00000080ULL
INTEL_EPT_REF 0x00000100ULL
INTEL_EPT_MOD 0x00000200ULL
INTEL_EPT_UEX 0x00000400ULL
INTEL_EPT_CACHE_MASK 0x00000038ULL
INTEL_EPT_NCACHE 0x00000000ULL
INTEL_EPT_WC 0x00000008ULL
INTEL_EPT_WTHRU 0x00000020ULL
INTEL_EPT_WP 0x00000028ULL
INTEL_EPT_WB 0x00000030ULL
PTE_IS_EXECUTABLE(is_ept, pte)  ((is_ept) ? (((pte) & (INTEL_EPT_EX | INTEL_EPT_UEX)) != 0) : (((pte) & INTEL_PTE_NX) == 0))
PTE_PS INTEL_PTE_PS
PTE_COMPRESSED INTEL_PTE_COMPRESSED
PTE_COMPRESSED_ALT INTEL_PTE_COMPRESSED_ALT
PTE_WIRED INTEL_PTE_WIRED
PMAP_DEFAULT_CACHE 0
PMAP_INHIBIT_CACHE 1
PMAP_GUARDED_CACHE 2
PMAP_ACTIVATE_CACHE 4
PMAP_NO_GUARD_CACHE 8
pmap_ledger_debit(p, e, a) ledger_debit((p)->ledger, e, a)
pmap_ledger_credit(p, e, a) ledger_credit((p)->ledger, e, a)
KERNEL_PMAP_HEAP_RANGE_START VM_MIN_KERNEL_AND_KEXT_ADDRESS
PMAP_PCID_MAX_CPUS MAX_CPUS
PMAP_MEMORY_REGIONS_SIZE 128
PMAP_ACTIVATE_MAP(map, thread, my_cpu)  {                               	pmap_t		tpmap;                                                                                                          	tpmap = vm_map_pmap(map);                                       	set_dirbase(tpmap, thread, my_cpu);                                     }
PMAP_SWITCH_USER(th, new_map, my_cpu) {                         	spl_t		spl;                                                                                                                    	spl = splhigh();                                                	PMAP_DEACTIVATE_MAP(th->map, th, my_cpu);                       	th->map = new_map;                                              	PMAP_ACTIVATE_MAP(th->map, th, my_cpu);                         	splx(spl);                                                      }
CPU_CR3_MARK_INACTIVE() current_cpu_datap()->cpu_active_cr3 |= 1
CPU_CR3_MARK_ACTIVE() current_cpu_datap()->cpu_active_cr3 &= ~1
MARK_CPU_IDLE(my_cpu) {                                       	assert(ml_get_interrupts_enabled() == FALSE);                   	CPU_CR3_MARK_INACTIVE();                                        	mfence();                                                                       }
MARK_CPU_ACTIVE(my_cpu) {                                       	assert(ml_get_interrupts_enabled() == FALSE);                   	                                                             	CPU_CR3_MARK_ACTIVE();                                          	mfence();                                                       	pmap_update_interrupt();                                        }
PMAP_CONTEXT(pmap, thread)
pmap_copy(dst_pmap, src_pmap, dst_addr, len, src_addr)
pmap_attribute(pmap, addr, size, attr, value) 	                                (KERN_INVALID_ADDRESS)
pmap_attribute_cache_sync(addr, size, attr, value) 	                                (KERN_INVALID_ADDRESS)
MACHINE_BOOTSTRAPPTD 1
_I386_PMAP_INTERNAL_ None
PMAP_TRACE_CONSTANT(...) KDBG_RELEASE(__VA_ARGS__)
PMAP_DELAY_TLB_FLUSH 0x01
PVE_IS_ALTACCT 0x001
PV_HASHED_LOW_WATER_MARK_DEFAULT 5000
PV_HASHED_KERN_LOW_WATER_MARK_DEFAULT 2000
PV_HASHED_ALLOC_CHUNK_INITIAL 2000
PV_HASHED_KERN_ALLOC_CHUNK_INITIAL 200
LOCK_PV_HASH(hash) lock_hash_hash(hash)
UNLOCK_PV_HASH(hash) unlock_hash_hash(hash)
lock_pvh_pai(pai) bit_lock(pai, (void *)pv_lock_table)
unlock_pvh_pai(pai) bit_unlock(pai, (void *)pv_lock_table)
lock_hash_hash(hash) bit_lock(hash, (void *)pv_hash_lock_table)
unlock_hash_hash(hash) bit_unlock(hash, (void *)pv_hash_lock_table)
IS_ALTACCT_PAGE(x, pve)                          	(IS_MANAGED_PAGE((x)) &&                        	 (PVE_IS_ALTACCT_PAGE((pve))))
PHYS_MODIFIED INTEL_PTE_MOD
PHYS_REFERENCED INTEL_PTE_REF
PHYS_MANAGED INTEL_PTE_VALID
PHYS_NOENCRYPT INTEL_PTE_USER
PHYS_NCACHE INTEL_PTE_NCACHE
PHYS_PAT INTEL_PTE_PAT
PHYS_INTERNAL INTEL_PTE_WTHRU
PHYS_REUSABLE INTEL_PTE_WRITE
LOCK_PVH(index) {               	mp_disable_preemption();        	lock_pvh_pai(index);            }
UNLOCK_PVH(index) {             	unlock_pvh_pai(index);          	mp_enable_preemption();         }
MAX_PREEMPTION_LATENCY_NS 20000
_PMAP_PCID_ 1
PTE_LOCK(EPT) INTEL_PTE_SWLOCK
DELAY_UNSET 0xFFFFFFFFFFFFFFFFULL
_I386_PMCPU_H_ None
PM_DISPATCH_VERSION 102
PM_HALT_NORMAL 0
PM_HALT_DEBUG 1
PM_HALT_PANIC 2
PM_HALT_SLEEP 3
PM_SAFE_FL_NORMAL 0x00000001
PM_SAFE_FL_SAFE 0x00000002
PM_SAFE_FL_PAUSE 0x00000010
PM_SAFE_FL_RESUME 0x00000020
_I386_POSTCODE_H_ None
POSTPORT 0x80
SPINCOUNT 300000000
CPU_PAUSE() rep; nop
PSTART_ENTRY 0xFF
PSTART_REBASE 0xFE
PSTART_BEFORE_PAGING 0xFE
PSTART_VSTART 0xFD
VSTART_ENTRY 0xFC
VSTART_IDT_INIT 0xFB
VSTART_IDLE_PTS_INIT 0xFA
VSTART_PHYSMAP_INIT 0xF9
VSTART_DESC_ALIAS_INIT 0xF8
VSTART_SET_CR3 0xF7
VSTART_CPU_DESC_INIT 0xF6
VSTART_CPU_MODE_INIT 0xF5
VSTART_EXIT 0xF4
I386_INIT_ENTRY 0xF3
CPU_INIT_D 0xF2
PE_INIT_PLATFORM_D 0xF1
SLAVE_STARTPROG_ENTRY 0xEF
SLAVE_PSTART 0xEE
I386_INIT_SLAVE 0xED
PANIC_DOUBLE_FAULT 0xDF
PANIC_MACHINE_CHECK 0xDC
MP_KDP_ENTER 0xDB
MP_KDP_EXIT 0xDE
PANIC_HLT 0xD1
BOOT_TRAP_HLT 0xD0
ACPI_WAKE_START_ENTRY 0xCF
ACPI_WAKE_PROT_ENTRY 0xCE
ACPI_WAKE_PAGED_ENTRY 0xCD
CPU_DESC_LOAD_ENTRY 0xBF
CPU_DESC_LOAD_GS_BASE 0xBE
CPU_DESC_LOAD_KERNEL_GS_BASE 0xBD
CPU_DESC_LOAD_GDT 0xBC
CPU_DESC_LOAD_IDT 0xBB
CPU_DESC_LOAD_LDT 0xBA
CPU_DESC_LOAD_TSS 0xB9
CPU_DESC_LOAD_EXIT 0xB7
_I386_PROC_REG_H_ None
MSR_P5_TSC 0x10
MSR_P5_CESR 0x11
MSR_P5_CTR0 0x12
MSR_P5_CTR1 0x13
MSR_P5_CESR_PC 0x0200
MSR_P5_CESR_CC 0x01C0
MSR_P5_CESR_ES 0x003F
MSR_P5_CESR_SHIFT 16
MSR_P5_CESR_CC_CLOCK 0x0100
MSR_P5_CESR_CC_DISABLE 0x0000
MSR_P5_CESR_CC_CPL012 0x0040
MSR_P5_CESR_CC_CPL3 0x0080
MSR_P5_CESR_CC_CPL 0x00C0
MSR_P5_CESR_ES_DATA_READ 0x000000
MSR_P5_CESR_ES_DATA_WRITE 0x000001
MSR_P5_CESR_ES_DATA_RW 0x101000
MSR_P5_CESR_ES_DATA_TLB_MISS 0x000010
MSR_P5_CESR_ES_DATA_READ_MISS 0x000011
MSR_P5_CESR_ES_DATA_WRITE_MISS 0x000100
MSR_P5_CESR_ES_DATA_RW_MISS 0x101001
MSR_P5_CESR_ES_HIT_EM 0x000101
MSR_P5_CESR_ES_DATA_CACHE_WB 0x000110
MSR_P5_CESR_ES_EXTERNAL_SNOOP 0x000111
MSR_P5_CESR_ES_CACHE_SNOOP_HIT 0x001000
MSR_P5_CESR_ES_MEM_ACCESS_PIPE 0x001001
MSR_P5_CESR_ES_BANK_CONFLICTS 0x001010
MSR_P5_CESR_ES_MISALIGNED 0x001011
MSR_P5_CESR_ES_CODE_READ 0x001100
MSR_P5_CESR_ES_CODE_TLB_MISS 0x001101
MSR_P5_CESR_ES_CODE_CACHE_MISS 0x001110
MSR_P5_CESR_ES_SEGMENT_LOADED 0x001111
MSR_P5_CESR_ES_BRANCHE 0x010010
MSR_P5_CESR_ES_BTB_HIT 0x010011
MSR_P5_CESR_ES_BRANCHE_BTB 0x010100
MSR_P5_CESR_ES_PIPELINE_FLUSH 0x010101
MSR_P5_CESR_ES_INSTRUCTION 0x010110
MSR_P5_CESR_ES_INSTRUCTION_V 0x010111
MSR_P5_CESR_ES_BUS_CYCLE 0x011000
MSR_P5_CESR_ES_FULL_WRITE_BUF 0x011001
MSR_P5_CESR_ES_DATA_MEM_READ 0x011010
MSR_P5_CESR_ES_WRITE_EM 0x011011
MSR_P5_CESR_ES_LOCKED_CYCLE 0x011100
MSR_P5_CESR_ES_IO_CYCLE 0x011101
MSR_P5_CESR_ES_NON_CACHEABLE 0x011110
MSR_P5_CESR_ES_AGI 0x011111
MSR_P5_CESR_ES_FLOP 0x100010
MSR_P5_CESR_ES_BREAK_DR0 0x100011
MSR_P5_CESR_ES_BREAK_DR1 0x100100
MSR_P5_CESR_ES_BREAK_DR2 0x100101
MSR_P5_CESR_ES_BREAK_DR3 0x100110
MSR_P5_CESR_ES_HARDWARE_IT 0x100111
CR0_PG 0x80000000
CR0_CD 0x40000000
CR0_NW 0x20000000
CR0_AM 0x00040000
CR0_WP 0x00010000
CR0_NE 0x00000020
CR0_ET 0x00000010
CR0_TS 0x00000008
CR0_EM 0x00000004
CR0_MP 0x00000002
CR0_PE 0x00000001
CR4_SEE 0x00008000
CR4_SMAP 0x00200000
CR4_SMEP 0x00100000
CR4_OSXSAVE 0x00040000
CR4_PCIDE 0x00020000
CR4_RDWRFSGS 0x00010000
CR4_SMXE 0x00004000
CR4_VMXE 0x00002000
CR4_OSXMM 0x00000400
CR4_OSFXS 0x00000200
CR4_PCE 0x00000100
CR4_PGE 0x00000080
CR4_MCE 0x00000040
CR4_PAE 0x00000020
CR4_PSE 0x00000010
CR4_DE 0x00000008
CR4_TSD 0x00000004
CR4_PVI 0x00000002
CR4_VME 0x00000001
XFEM_X87 XCR0_X87
XFEM_SSE XCR0_SSE
XFEM_YMM XCR0_YMM
XFEM_BNDREGS XCR0_BNDREGS
XFEM_BNDCSR XCR0_BNDCSR
XFEM_OPMASK XCR0_OPMASK
XFEM_ZMM_HI256 XCR0_ZMM_HI256
XFEM_HI16_ZMM XCR0_HI16_ZMM
XFEM_ZMM XFEM_ZMM_OPMASK
EARLY_GSBASE_MAGIC 0xffffdeadbeefee00
CONFIG_THREAD_GROUPS 0
MAX_CPUS 64
MAX_PSETS 64
set_ts() set_cr0(get_cr0() | CR0_TS)
rdmsr(msr, lo, hi) 	__asm__ volatile("rdmsr" : "=a" (lo), "=d" (hi) : "c" (msr))
wrmsr(msr, lo, hi) 	__asm__ volatile("wrmsr" : : "c" (msr), "a" (lo), "d" (hi))
rdtsc(lo, hi) 	__asm__ volatile("lfence; rdtsc" : "=a" (lo), "=d" (hi))
rdtsc_nofence(lo, hi) 	__asm__ volatile("rdtsc" : "=a" (lo), "=d" (hi))
write_tsc(lo, hi) wrmsr(0x10, lo, hi)
rdpmc(counter, lo, hi) 	__asm__ volatile("rdpmc" : "=a" (lo), "=d" (hi) : "c" (counter))
X86_MAX_LBRS 32
mfence() do_mfence()
MSR_IA32_P5_MC_ADDR 0
MSR_IA32_P5_MC_TYPE 1
MSR_IA32_PLATFORM_ID 0x17
MSR_IA32_EBL_CR_POWERON 0x2a
MSR_IA32_APIC_BASE 0x1b
MSR_CORE_THREAD_COUNT 0x35
MSR_IA32_FEATURE_CONTROL 0x3a
MSR_IA32_UPDT_TRIG 0x79
MSR_IA32_BIOS_SIGN_ID 0x8b
MSR_IA32_UCODE_WRITE MSR_IA32_UPDT_TRIG
MSR_IA32_UCODE_REV MSR_IA32_BIOS_SIGN_ID
MSR_IA32_PERFCTR0 0xc1
MSR_IA32_PERFCTR1 0xc2
MSR_IA32_PERFCTR3 0xc3
MSR_IA32_PERFCTR4 0xc4
MSR_PLATFORM_INFO 0xce
MSR_IA32_MPERF 0xE7
MSR_IA32_APERF 0xE8
MSR_IA32_ARCH_CAPABILITIES 0x10a
MSR_IA32_TSX_FORCE_ABORT 0x10f
MSR_IA32_BBL_CR_CTL 0x119
MSR_IA32_TSX_CTRL 0x122
MSR_IA32_MCU_OPT_CTRL 0x123
MSR_IA32_SYSENTER_CS 0x174
MSR_IA32_SYSENTER_ESP 0x175
MSR_IA32_SYSENTER_EIP 0x176
MSR_IA32_MCG_CAP 0x179
MSR_IA32_MCG_STATUS 0x17a
MSR_IA32_MCG_CTL 0x17b
MSR_IA32_EVNTSEL0 0x186
MSR_IA32_EVNTSEL1 0x187
MSR_IA32_EVNTSEL2 0x188
MSR_IA32_EVNTSEL3 0x189
MSR_FLEX_RATIO 0x194
MSR_IA32_PERF_STS 0x198
MSR_IA32_PERF_CTL 0x199
MSR_IA32_CLOCK_MODULATION 0x19a
MSR_IA32_MISC_ENABLE 0x1a0
MSR_IA32_PACKAGE_THERM_STATUS 0x1b1
MSR_IA32_PACKAGE_THERM_INTERRUPT 0x1b2
MSR_IA32_LBR_SELECT 0x1c8
MSR_IA32_LASTBRANCH_TOS 0x1c9
MSR_IA32_DEBUGCTLMSR 0x1d9
MSR_IA32_LASTBRANCHFROMIP 0x1db
MSR_IA32_LASTBRANCHTOIP 0x1dc
MSR_IA32_LASTINTFROMIP 0x1dd
MSR_IA32_LASTINTTOIP 0x1de
MSR_IA32_CR_PAT 0x277
MSR_IA32_MTRRCAP 0xfe
MSR_IA32_MTRR_DEF_TYPE 0x2ff
MSR_IA32_MTRR_FIX64K_00000 0x250
MSR_IA32_MTRR_FIX16K_80000 0x258
MSR_IA32_MTRR_FIX16K_A0000 0x259
MSR_IA32_MTRR_FIX4K_C0000 0x268
MSR_IA32_MTRR_FIX4K_C8000 0x269
MSR_IA32_MTRR_FIX4K_D0000 0x26a
MSR_IA32_MTRR_FIX4K_D8000 0x26b
MSR_IA32_MTRR_FIX4K_E0000 0x26c
MSR_IA32_MTRR_FIX4K_E8000 0x26d
MSR_IA32_MTRR_FIX4K_F0000 0x26e
MSR_IA32_MTRR_FIX4K_F8000 0x26f
MSR_IA32_PERF_FIXED_CTR0 0x309
MSR_IA32_PERF_CAPABILITIES 0x345
PERFCAP_LBR_TYPE_MISPRED 3
PERFCAP_LBR_TYPE_TSXINFO 4
PERFCAP_LBR_TYPE_EIP_WITH_LBRINFO 5
LBR_TYPE_EIP_WITH_LBRINFO_MISPREDICT(lbrinfo) LBR_TYPE_TSXINFO_MISPREDICT(lbrinfo)
LBR_TYPE_EIP_WITH_LBRINFO_TSX_ABORT(lbrinfo) LBR_TYPE_TSXINFO_TSX_ABORT(lbrinfo)
LBR_TYPE_EIP_WITH_LBRINFO_IN_TSX(lbrinfo) LBR_TYPE_TSXINFO_IN_TSX(lbrinfo)
MSR_IA32_PERF_FIXED_CTR_CTRL 0x38D
MSR_IA32_PERF_GLOBAL_STATUS 0x38E
MSR_IA32_PERF_GLOBAL_CTRL 0x38F
MSR_IA32_PERF_GLOBAL_OVF_CTRL 0x390
MSR_IA32_PKG_C3_RESIDENCY 0x3F8
MSR_IA32_PKG_C6_RESIDENCY 0x3F9
MSR_IA32_PKG_C7_RESIDENCY 0x3FA
MSR_IA32_CORE_C3_RESIDENCY 0x3FC
MSR_IA32_CORE_C6_RESIDENCY 0x3FD
MSR_IA32_CORE_C7_RESIDENCY 0x3FE
MSR_IA32_MC0_CTL 0x400
MSR_IA32_MC0_STATUS 0x401
MSR_IA32_MC0_ADDR 0x402
MSR_IA32_MC0_MISC 0x403
MSR_IA32_VMX_BASE 0x480
MSR_IA32_VMX_BASIC MSR_IA32_VMX_BASE
MSR_IA32_VMX_PINBASED_CTLS MSR_IA32_VMX_BASE+1
MSR_IA32_VMX_PROCBASED_CTLS MSR_IA32_VMX_BASE+2
MSR_IA32_VMX_EXIT_CTLS MSR_IA32_VMX_BASE+3
MSR_IA32_VMX_ENTRY_CTLS MSR_IA32_VMX_BASE+4
MSR_IA32_VMX_MISC MSR_IA32_VMX_BASE+5
MSR_IA32_VMX_CR0_FIXED0 MSR_IA32_VMX_BASE+6
MSR_IA32_VMX_CR0_FIXED1 MSR_IA32_VMX_BASE+7
MSR_IA32_VMX_CR4_FIXED0 MSR_IA32_VMX_BASE+8
MSR_IA32_VMX_CR4_FIXED1 MSR_IA32_VMX_BASE+9
MSR_IA32_VMX_VMCS_ENUM MSR_IA32_VMX_BASE+10
MSR_IA32_VMX_PROCBASED_CTLS2 MSR_IA32_VMX_BASE+11
MSR_IA32_VMX_EPT_VPID_CAP MSR_IA32_VMX_BASE+12
MSR_IA32_VMX_EPT_VPID_CAP_AD_SHIFT 21
MSR_IA32_VMX_TRUE_PINBASED_CTLS MSR_IA32_VMX_BASE+13
MSR_IA32_VMX_TRUE_PROCBASED_CTLS MSR_IA32_VMX_BASE+14
MSR_IA32_VMX_TRUE_VMEXIT_CTLS MSR_IA32_VMX_BASE+15
MSR_IA32_VMX_TRUE_VMENTRY_CTLS MSR_IA32_VMX_BASE+16
MSR_IA32_VMX_VMFUNC MSR_IA32_VMX_BASE+17
MSR_IA32_DS_AREA 0x600
MSR_IA32_PKG_POWER_SKU_UNIT 0x606
MSR_IA32_PKG_C2_RESIDENCY 0x60D
MSR_IA32_PKG_ENERGY_STATUS 0x611
MSR_IA32_DDR_ENERGY_STATUS 0x619
MSR_IA32_LLC_FLUSHED_RESIDENCY_TIMER 0x61D
MSR_IA32_RING_PERF_STATUS 0x621
MSR_IA32_PKG_C8_RESIDENCY 0x630
MSR_IA32_PKG_C9_RESIDENCY 0x631
MSR_IA32_PKG_C10_RESIDENCY 0x632
MSR_IA32_PP0_ENERGY_STATUS 0x639
MSR_IA32_PP1_ENERGY_STATUS 0x641
MSR_IA32_IA_PERF_LIMIT_REASONS_SKL 0x64F
MSR_IA32_IA_PERF_LIMIT_REASONS 0x690
MSR_IA32_GT_PERF_LIMIT_REASONS 0x6B0
MSR_IA32_TSC_DEADLINE 0x6e0
MSR_IA32_EFER 0xC0000080
MSR_IA32_EFER_SCE 0x00000001
MSR_IA32_EFER_LME 0x00000100
MSR_IA32_EFER_LMA 0x00000400
MSR_IA32_EFER_NXE 0x00000800
MSR_IA32_STAR 0xC0000081
MSR_IA32_LSTAR 0xC0000082
MSR_IA32_CSTAR 0xC0000083
MSR_IA32_FMASK 0xC0000084
MSR_IA32_FS_BASE 0xC0000100
MSR_IA32_GS_BASE 0xC0000101
MSR_IA32_KERNEL_GS_BASE 0xC0000102
MSR_IA32_TSC_AUX 0xC0000103
HV_VMX_EPTP_MEMORY_TYPE_UC 0x0
HV_VMX_EPTP_MEMORY_TYPE_WB 0x6
UI_CPUFREQ_ROUNDING_FACTOR 10000000
_I386_RTCLOCK_H_ None
TIME_TRAP_UENTRY CCALL(recount_leave_user)
TIME_TRAP_UEXIT CCALL(recount_enter_user)
NANOTIME movq	%gs:CPU_NANOTIME,%rdi					     ; 	PAL_RTC_NANOTIME_READ_FAST()
TASK_VTIMER_CHECK(task_reg,thread_reg) cmpl	$0,TASK_VTIMERS(task_reg)				     ; 	jz	1f							     ; 	orl	$(AST_BSD),%gs:CPU_PENDING_AST		     ; 	lock								     ; 	orl	$(AST_BSD),TH_AST(thread_reg)		     ; 1:									     ;
_PAL_RTCLOCK_ASM_NATIVE_H_ None
PAL_RTC_NANOTIME_READ_FAST() 0:	movl	RNT_GENERATION(%rdi),%esi				; 	test        %esi,%esi				;         jz        0b					; 	lfence								; 	rdtsc								; 	shlq	$32,%rdx						; 	movl    RNT_SHIFT(%rdi),%ecx					; 	orq	%rdx,%rax				; 	subq	RNT_TSC_BASE(%rdi),%rax			; 	shlq    %cl,%rax						; 	movl	RNT_SCALE(%rdi),%ecx					; 	mulq	%rcx					; 	shrdq	$32,%rdx,%rax				; 	addq	RNT_NS_BASE(%rdi),%rax			; 	cmpl	RNT_GENERATION(%rdi),%esi	 ; 	jne	0b
PAL_RTC_NANOTIME_READ_NOBARRIER() 0:	movl	RNT_GENERATION(%rdi),%esi				; 	test        %esi,%esi				;         jz        0b					; 	rdtsc								; 	shlq	$32,%rdx						; 	movl    RNT_SHIFT(%rdi),%ecx					; 	orq	%rdx,%rax				; 	subq	RNT_TSC_BASE(%rdi),%rax			; 	shlq    %cl,%rax						; 	movl	RNT_SCALE(%rdi),%ecx					; 	mulq	%rcx					; 	shrdq	$32,%rdx,%rax				; 	addq	RNT_NS_BASE(%rdi),%rax			; 	cmpl	RNT_GENERATION(%rdi),%esi	 ; 	jne	0b
_I386_RTCLOCK_PROTOS_H_ None
_I386_SCHED_PARAM_H_ None
_I386_SEG_H_ None
LDTSZ_MAX 8192
LDTSZ_MIN SEL_TO_INDEX(USER_SETTABLE)
GDTSZ 19
IDTSZ 256
MAKE_REAL_DESCRIPTOR(base, lim, gran, acc) {	.limit_low = lim & 0xffff, 	.limit_high = (lim >> 16) & 0xf, 	.base_low = base & 0xffff, 	.base_med = (base >> 16) & 0xff, 	.base_high = (base >> 24) & 0xff, 	.access = acc, 	.granularity = gran }
SZ_64 0x2
SZ_32 0x4
SZ_G 0x8
ACC_A 0x01
ACC_TYPE 0x1e
ACC_TYPE_SYSTEM 0x00
ACC_LDT 0x02
ACC_CALL_GATE_16 0x04
ACC_TASK_GATE 0x05
ACC_TSS 0x09
ACC_CALL_GATE 0x0c
ACC_INTR_GATE 0x0e
ACC_TRAP_GATE 0x0f
ACC_TSS_BUSY 0x02
ACC_TYPE_USER 0x10
ACC_DATA 0x10
ACC_DATA_W 0x12
ACC_DATA_E 0x14
ACC_DATA_EW 0x16
ACC_CODE 0x18
ACC_CODE_R 0x1a
ACC_CODE_C 0x1c
ACC_CODE_CR 0x1e
ACC_PL 0x60
ACC_PL_K 0x00
ACC_PL_U 0x60
ACC_P 0x80
SEL_LDTS 0x04
SEL_PL 0x03
SEL_PL_K 0x00
SEL_PL_U 0x03
NULL_SEG 0
KERNEL64_CS 0x08
SYSENTER_CS 0x0b
KERNEL64_SS 0x10
USER_CS 0x1b
USER_DS 0x23
USER64_CS 0x2b
USER64_DS USER_DS
KERNEL_LDT 0x30
KERNEL_TSS 0x40
KERNEL32_CS 0x50
USER_LDT 0x58
KERNEL_DS 0x68
SYSENTER_DS KERNEL64_SS
_I386_SERIAL_IO_H_ None
_I386_SETJMP_H_ None
_I386_SIMPLE_LOCK_TYPES_H_ None
_I386_SMP_H_ None
N_GSYM 0x20
N_FNAME 0x22
N_FUN 0x24
N_STSYM 0x26
N_LCSYM 0x28
N_MAIN 0x2a
N_PC 0x30
N_RSYM 0x40
N_SLINE 0x44
N_DSLINE 0x46
N_BSLINE 0x48
N_SSYM 0x60
N_SO 0x64
N_LSYM 0x80
N_BINCL 0x82
N_SOL 0x84
N_PSYM 0xa0
N_EINCL 0xa2
N_ENTRY 0xa4
N_LBRAC 0xc0
N_EXCL 0xc2
N_RBRAC 0xe0
N_BCOMM 0xe2
N_ECOMM 0xe4
N_ECOML 0xe8
N_LENG 0xfe
_I386_STRING_H_ None
__arch_bcopy 1
__arch_bzero 1
__arch_memcpy 1
__arch_memmove 1
__arch_memset 1
MACHINE_TASK struct user_ldt *       i386_ldt;       	void*                   task_debug;     	uint64_t	uexc_range_start;       	uint64_t	uexc_range_size;        	uint64_t	uexc_handler;           	xstate_t	xstate;
_I386_THREAD_H_ None
OnProc 0x1
CopyIOActive 0x2
MTHR_SEGCHK 1
MTHR_RSBST 2
_I386_TRAP_H_ None
T_DIVIDE_ERROR 0
T_DEBUG 1
T_NMI 2
T_INT3 3
T_OVERFLOW 4
T_OUT_OF_BOUNDS 5
T_INVALID_OPCODE 6
T_NO_FPU 7
T_DOUBLE_FAULT 8
T_FPU_FAULT 9
T_INVALID_TSS 10
T_SEGMENT_NOT_PRESENT 11
T_STACK_FAULT 12
T_GENERAL_PROTECTION 13
T_PAGE_FAULT 14
T_FLOATING_POINT_ERROR 16
T_WATCHPOINT 17
T_MACHINE_CHECK 18
T_SSE_FLOAT_ERROR 19
T_DTRACE_RET 127
T_SYSENTER 0x84
T_SYSCALL 0x85
T_PREEMPT 255
TRAP_NAMES "divide error", "debug trap", "NMI", "breakpoint", 	           "overflow", "bounds check", "invalid opcode", 	           "no coprocessor", "double fault", "coprocessor overrun", 	           "invalid TSS", "segment not present", "stack bounds", 	           "general protection", "page fault", "(reserved)", 	           "coprocessor error", "watchpoint", "machine check", "SSE floating point"
T_PF_PROT 0x1
T_PF_WRITE 0x2
T_PF_USER 0x4
T_PF_RSVD 0x8
T_PF_EXECUTE 0x10
_I386_TRAP_INTERNAL_H_ None
bitmask(h, l)    ((bit(h)|(bit(h)-1)) & ~(bit(l)-1))
bitfield(x, h, l) (((x) & bitmask(h,l)) >> l)
_I386_TSC_H_ None
BASE_NHM_CLOCK_SOURCE 133333333ULL
BASE_ART_CLOCK_SOURCE 24000000ULL
BASE_ART_CLOCK_SOURCE_SP 25000000ULL
IA32_PERF_STS 0x198
SLOW_TSC_THRESHOLD 1000067800
_I386_TSS_H_ None
_I386_USER_LDT_H_ None
_I386_VMX_H_ None
VMX_OK 0
VMX_UNSUPPORTED 1
VMX_INUSE 2
_I386_VM_TUNING_H_ None
_I386_X86_HYPERCALL_H_ None
HVG_HCALL_RETURN(rax) {	__asm__ __volatile__ goto (	                           "jnc 2f  \n\t" 	                           "jmp %l0 \n\t" 	                           "2:      \n\t" 	                          :  	                          :   	                          :  	                          : error);	return HVG_HCALL_SUCCESS;error:	return (hvg_hcall_return_t)rax;}
_IPC_FLIPC_H_ None
IPC_ENTRY_GROW_STATS 1
_IPC_IPC_ENTRY_H_ None
IPC_ENTRY_DIST_BITS 12
IPC_ENTRY_INDEX_BITS 32
IPC_ENTRY_TABLE_MIN 32
IPC_ENTRY_TABLE_PERIOD 16
IE_REQ_NONE 0
IE_BITS_UREFS_MASK 0x0000ffff
IE_BITS_TYPE_MASK 0x001f0000
IE_BITS_EXTYPE_MASK 0x00200000
IE_BITS_GEN_MASK 0xff000000
IE_BITS_GEN_ONE 0x04000000
IE_BITS_ROLL_POS 22
IE_BITS_ROLL_BITS 2
IE_BITS_RIGHT_MASK 0x007fffff
_IPC_IPC_EVENTLINK_H_ None
ipc_eventlink_active(eventlink) waitq_valid(&(eventlink)->el_base->elb_waitq)
ipc_eventlink_lock(eventlink) waitq_lock(&(eventlink)->el_base->elb_waitq)
ipc_eventlink_unlock(eventlink) waitq_unlock(&(eventlink)->el_base->elb_waitq)
IH_TABLE_HASH(obj, size)                                	        ((mach_port_index_t)(os_hash_kernel_pointer(obj) % (size)))
swap(a, b)  ({ typeof(a) _tmp = (b); (b) = (a); (a) = _tmp; })
_IPC_IPC_HASH_H_ None
ipc_importance_lock() lck_spin_lock_grp(&ipc_importance_lock_data, &ipc_lck_grp)
ipc_importance_lock_try() lck_spin_try_lock_grp(&ipc_importance_lock_data, &ipc_lck_grp)
ipc_importance_unlock() lck_spin_unlock(&ipc_importance_lock_data)
ipc_importance_assert_held() lck_spin_assert(&ipc_importance_lock_data, LCK_ASSERT_OWNED)
IMPORTANCE_ASSERT_KEY(key) assert(MACH_VOUCHER_ATTR_KEY_IMPORTANCE == (key))
IMPORTANCE_ASSERT_MANAGER(manager) assert(&ipc_importance_manager == (manager))
_IPC_IPC_IMPORTANCE_H_ None
IIE_REF_DEBUG 0
IIE_TYPE_BITS 1
IIE_TYPE_TASK 0x00000000
IIE_TYPE_INHERIT 0x00000001
iit_bits iit_elem.iie_bits
iit_made iit_elem.iie_made
iit_kmsgs iit_elem.iie_kmsgs
iit_externcnt iit_elem.iie_externcnt
iit_externdrop iit_elem.iie_externdrop
IIT_REFS(t) IIE_REFS(&(t)->iit_elem)
IIT_EXTERN(t) IIE_EXTERN(&(t)->iit_elem)
iii_bits iii_elem.iie_bits
iii_made iii_elem.iie_made
iii_kmsgs iii_elem.iie_kmsgs
iii_externcnt iii_elem.iie_externcnt
iii_externdrop iii_elem.iie_externdrop
III_REFS(i) IIE_REFS(&(i)->iii_elem)
III_EXTERN(i) IIE_EXTERN(&(i)->iii_elem)
III_DEPTH_RESET 0x80000000
III_DEPTH_MASK 0x000000FF
III_DEPTH_MAX 32
TASK_IMP_LIST_DONATING_PIDS 0x1
_IPC_IPC_INIT_H_ None
ICP_OPTIONS_3P_SHIFT 4
KERNEL_DESC_SIZE sizeof(mach_msg_kdescriptor_t)
USER_DESC_SIZE_MIN sizeof(mach_msg_type_descriptor_t)
USER_DESC_SIZE_MAX KERNEL_DESC_SIZE
mach_validate_desc_type(t, size) 	static_assert(sizeof(t) == (size))
ikm_require(kmsg) zone_id_require(ZONE_ID_IPC_KMSG, sizeof(struct ipc_kmsg), kmsg)
ikm_require_aligned(kmsg) zone_id_require_aligned(ZONE_ID_IPC_KMSG, kmsg)
ikm_udsc_type(addr) __IGNORE_WCASTALIGN(((const mach_msg_type_descriptor_t *)(addr))->type)
ikm_udsc_get(dst, addr)     __IGNORE_WCASTALIGN(*(dst) = *(const typeof(*(dst)) *)(addr))
ikm_kdsc_zero(addr, type)   ((type *)memset(addr, 0, sizeof(type)))
ipc_kmsg_deflate_put(udesc_end, value) 	memcpy((udesc_end) - sizeof(*(value)), (value), sizeof(*(value)))
trailer_assert_same_field(field) static_assert(offsetof(typeof(*out32), field) == 	    offsetof(typeof(*out64), field)); 	static_assert(sizeof(out32->field) == sizeof(out64->field))
KMSG_TRACE_FLAG_TRACED 0x000001
KMSG_TRACE_FLAG_COMPLEX 0x000002
KMSG_TRACE_FLAG_OOLMEM 0x000004
KMSG_TRACE_FLAG_VCPY 0x000008
KMSG_TRACE_FLAG_PCPY 0x000010
KMSG_TRACE_FLAG_SND64 0x000020
KMSG_TRACE_FLAG_RAISEIMP 0x000040
KMSG_TRACE_FLAG_APP_SRC 0x000080
KMSG_TRACE_FLAG_APP_DST 0x000100
KMSG_TRACE_FLAG_DAEMON_SRC 0x000200
KMSG_TRACE_FLAG_DAEMON_DST 0x000400
KMSG_TRACE_FLAG_DST_NDFLTQ 0x000800
KMSG_TRACE_FLAG_SRC_NDFLTQ 0x001000
KMSG_TRACE_FLAG_DST_SONCE 0x002000
KMSG_TRACE_FLAG_SRC_SONCE 0x004000
KMSG_TRACE_FLAG_CHECKIN 0x008000
KMSG_TRACE_FLAG_ONEWAY 0x010000
KMSG_TRACE_FLAG_IOKIT 0x020000
KMSG_TRACE_FLAG_SNDRCV 0x040000
KMSG_TRACE_FLAG_DSTQFULL 0x080000
KMSG_TRACE_FLAG_VOUCHER 0x100000
KMSG_TRACE_FLAG_TIMER 0x200000
KMSG_TRACE_FLAG_SEMA 0x400000
KMSG_TRACE_FLAG_DTMPOWNER 0x800000
KMSG_TRACE_FLAG_GUARDED_DESC 0x1000000
KMSG_TRACE_FLAGS_MASK 0x1ffffff
KMSG_TRACE_FLAGS_SHIFT 8
KMSG_TRACE_ID_SHIFT 32
KMSG_TRACE_PORTS_MASK 0xff
KMSG_TRACE_PORTS_SHIFT 0
_IPC_IPC_KMSG_H_ None
IKM_ALLOC_SIZE 256
IKM_SMALL_MSG_SIZE 168
IKM_BIG_MSG_SIZE 192
ipc_kmsg_queue_init(queue) circle_queue_init(queue)
ipc_kmsg_queue_empty(queue) circle_queue_empty(queue)
ipc_kmsg_queue_element(elem) cqe_element(elem, struct ipc_kmsg, ikm_link)
ipc_kmsg_queue_first(queue) cqe_queue_first(queue, struct ipc_kmsg, ikm_link)
ipc_kmsg_queue_next(queue, elt) 	cqe_queue_next(&(elt)->ikm_link, queue, struct ipc_kmsg, ikm_link)
ipc_kmsg_enqueue(queue, kmsg) 	circle_enqueue_tail(queue, &(kmsg)->ikm_link)
ipc_kmsg_rmqueue(queue, kmsg) 	circle_dequeue(queue, &(kmsg)->ikm_link)
moved_provisional_reply_port(port_type, port) 	(port_type == MACH_MSG_TYPE_MOVE_RECEIVE && IP_VALID(port) && ip_is_provisional_reply_port(port))
_IPC_IPC_MQUEUE_H_ None
IPC_MQUEUE_FULL CAST_EVENT64_T(&ipc_mqueue_full)
IPC_MQUEUE_RECEIVE NO_EVENT64
_IPC_IPC_NOTIFY_H_ None
_IPC_IPC_OBJECT_H_ None
IO_BITS_PORT_INFO 0x0000f000
IO_BITS_KOTYPE 0x000003ff
IO_BITS_KOLABEL 0x00000400
IO_BITS_OTYPE 0x7fff0000
IO_BITS_ACTIVE 0x80000000
io_bits(io) atomic_load_explicit(&(io)->io_bits, memory_order_relaxed)
IOT_PORT 0
IOT_PORT_SET 1
IOT_NUMBER 2
io_alloc(otype, flags) 	zalloc_flags(ipc_object_zones[otype], flags)
io_unlock(io) waitq_unlock(io_waitq(io))
io_lock_held(io) assert(waitq_held(io_waitq(io)))
io_lock_held_kdp(io) waitq_held(io_waitq(io))
io_lock_allow_invalid(io) ipc_object_lock_allow_invalid(io)
io_reference(io) ipc_object_reference(io)
io_release(io) ipc_object_release(io)
io_release_safe(io) ipc_object_release_safe(io)
io_release_live(io) ipc_object_release_live(io)
IPC_POLICY_VIOLATIONS_RB_SIZE 2
CA_MACH_SERVICE_PORT_NAME_LEN 86
_IPC_IPC_POLICY_H_ None
IPC_HAS_LEGACY_MACH_MSG_TRAP 1
IPC_KOBJECT_DESC_MAX 3
IPC_KOBJECT_RDESC_MAX 32
IPC_KMSG_MAX_AUX_DATA_SPACE 1024
IPC_KMSG_MAX_OOL_PORT_COUNT 16383
ipc_unreachable(reason) mach_assert_abort(reason)
ipc_release_assert(expr) release_assert(expr)
_IPC_IPC_PORT_H_ None
IPR_HOST_NOTIFY 0xfffffffeu
ip_receiver_name ip_messages.imq_receiver_name
ip_reply_context ip_messages.imq_context
ip_klist ip_messages.imq_klist
set_port_send_turnstile(port, value) MACRO_BEGIN                                  	(port)->ip_send_turnstile = (value); MACRO_END
ip_right_delta(port, field, delta)  ({     ipc_port_t __port = (port);                                      if (os_add_overflow(__port->field, delta, &__port->field)) { 	__ipc_right_delta_overflow_panic(__port, &__port->field, delta);      }                                                            })
ip_srights_inc(port) ip_right_delta(port, ip_srights, 1)
ip_srights_dec(port) ip_right_delta(port, ip_srights, -1)
ip_sorights_inc(port) ip_right_delta(port, ip_sorights, 1)
ip_sorights_dec(port) ip_right_delta(port, ip_sorights, -1)
IP_NULL IPC_PORT_NULL
IP_DEAD IPC_PORT_DEAD
IP_VALID(port) IPC_PORT_VALID(port)
ip_object_to_port(io) __container_of(io, struct ipc_port, ip_object)
ip_active(port) io_active(ip_to_object(port))
ip_mq_lock_held(port) io_lock_held(ip_to_object(port))
ip_mq_lock(port) ipc_port_lock(port)
ip_mq_lock_check_aligned(port) ipc_port_lock_check_aligned(port)
ip_mq_lock_try(port) ipc_port_lock_try(port)
ip_mq_lock_held_kdp(port) io_lock_held_kdp(ip_to_object(port))
ip_mq_unlock(port) io_unlock(ip_to_object(port))
ip_reference(port) io_reference(ip_to_object(port))
ip_release(port) io_release(ip_to_object(port))
ip_release_safe(port) io_release_safe(ip_to_object(port))
ip_release_live(port) io_release_live(ip_to_object(port))
ip_validate(port) zone_id_require(ZONE_ID_IPC_PORT, sizeof(struct ipc_port), port)
ip_from_waitq(wq) __container_of(wq, struct ipc_port, ip_waitq)
ip_from_mq(mq) __container_of(mq, struct ipc_port, ip_messages)
ip_kotype(port) io_kotype(ip_to_object(port))
ip_is_kobject(port) io_is_kobject(ip_to_object(port))
ip_is_kolabeled(port) io_is_kolabeled(ip_to_object(port))
ip_full_kernel(port) imq_full_kernel(&(port)->ip_messages)
ip_full(port) imq_full(&(port)->ip_messages)
PORT_MARK_REPLY_PORT 0x01
PORT_ENFORCE_REPLY_PORT_SEMANTICS 0x02
PORT_MARK_PROVISIONAL_REPLY_PORT 0x03
PORT_ENFORCE_RIGID_REPLY_PORT_SEMANTICS 0x04
PORT_MARK_EXCEPTION_PORT 0x05
IP_BIT_FILTER_MSG 0x00001000
IPR_SOR_SPBIT_MASK 3
IPR_SOR_MAKE(p, m)      ((ipc_port_t)((uintptr_t)(p) | (m)))
ipc_port_multiple_lock() lck_spin_lock_grp(&ipc_port_multiple_lock_data, &ipc_lck_grp)
ipc_port_multiple_unlock() lck_spin_unlock(&ipc_port_multiple_lock_data)
IP_TIMESTAMP_ORDER(one, two)    ((int) ((one) - (two)) < 0)
ipc_port_alloc_reply() ipc_port_alloc_special(ipc_space_reply, IPC_PORT_INIT_MESSAGE_QUEUE | IPC_PORT_INIT_SPECIAL_REPLY)
ipc_port_dealloc_reply(port) ipc_port_dealloc_special((port), ipc_space_reply)
_IPC_IPC_PSET_H_ None
ips_object_to_pset(io) __container_of(io, struct ipc_pset, ips_object)
ips_active(pset) io_active(ips_to_object(pset))
ips_mq_lock_held(pset) io_lock_held(ips_to_object(pset))
ips_mq_lock(pset) ipc_pset_lock(pset)
ips_mq_lock_held_kdp(pset) io_lock_held_kdp(ips_to_object(pset))
ips_mq_unlock(pset) io_unlock(ips_to_object(pset))
ips_reference(pset) io_reference(ips_to_object(pset))
ips_release(pset) io_release(ips_to_object(pset))
ips_validate(pset) zone_id_require(ZONE_ID_IPC_PORT_SET, sizeof(struct ipc_pset), pset)
_IPC_IPC_RIGHT_H_ None
ipc_right_lookup_two_read ipc_right_lookup_two_write
XPC_DOMAIN_PORT 7
_IPC_IPC_SERVICE_PORT_H_ None
CONFIG_SEMI_RANDOM_ENTRIES None
NUM_SEQ_ENTRIES 8
_IPC_IPC_SPACE_H_ None
_IPC_IPC_TYPES_H_ None
voucher_require(v) zone_id_require(ZONE_ID_IPC_VOUCHERS, sizeof(struct ipc_voucher), v)
IV_HASH_END UINT32_MAX
IV_HASH_VAL(sz, val) 	(((val) >> 3) % (sz))
ivace_reset_data(ivace_elem, next_index) {       	(ivace_elem)->ivace_value = 0xDEADC0DEDEADC0DE;  	(ivace_elem)->ivace_refs = 0;                    	(ivace_elem)->ivace_persist = 0;                 	(ivace_elem)->ivace_made = 0;                    	(ivace_elem)->ivace_free = TRUE;                 	(ivace_elem)->ivace_releasing = FALSE;           	(ivace_elem)->ivace_layered = 0;                 	(ivace_elem)->ivace_index = IV_HASH_END;         	(ivace_elem)->ivace_next = (next_index);         }
ivace_copy_data(ivace_src_elem, ivace_dst_elem) {  	(ivace_dst_elem)->ivace_value = (ivace_src_elem)->ivace_value; 	(ivace_dst_elem)->ivace_refs = (ivace_src_elem)->ivace_refs;   	(ivace_dst_elem)->ivace_persist = (ivace_src_elem)->ivace_persist; 	(ivace_dst_elem)->ivace_made = (ivace_src_elem)->ivace_made;   	(ivace_dst_elem)->ivace_free = (ivace_src_elem)->ivace_free;   	(ivace_dst_elem)->ivace_layered = (ivace_src_elem)->ivace_layered;   	(ivace_dst_elem)->ivace_releasing = (ivace_src_elem)->ivace_releasing; 	(ivace_dst_elem)->ivace_index = (ivace_src_elem)->ivace_index; 	(ivace_dst_elem)->ivace_next = (ivace_src_elem)->ivace_next; }
_IPC_IPC_VOUCHER_H_ None
IV_NULL IPC_VOUCHER_NULL
ivace_made ivace_u.ivaceu_made
ivace_layer ivace_u.ivaceu_layer
IVAC_ENTRIES_MIN 512
IVAC_ENTRIES_MAX 524288
IVAC_NULL IPC_VOUCHER_ATTR_CONTROL_NULL
ivac_lock_init(ivac) lck_spin_init(&(ivac)->ivac_lock_data, &ipc_lck_grp, &ipc_lck_attr)
ivac_lock_destroy(ivac) lck_spin_destroy(&(ivac)->ivac_lock_data, &ipc_lck_grp)
ivac_lock(ivac) lck_spin_lock_grp(&(ivac)->ivac_lock_data, &ipc_lck_grp)
ivac_lock_try(ivac) lck_spin_try_lock_grp(&(ivac)->ivac_lock_data, &ipc_lck_grp)
ivac_unlock(ivac) lck_spin_unlock(&(ivac)->ivac_lock_data)
ivac_sleep(ivac) lck_spin_sleep_grp(&(ivac)->ivac_lock_data,        	                                LCK_SLEEP_DEFAULT,              	                                (event_t)(ivac),                	                                THREAD_UNINT, &ipc_lck_grp)
ivac_wakeup(ivac) thread_wakeup((event_t)(ivac))
IVAM_NULL IPC_VOUCHER_ATTR_MANAGER_NULL
IVAM_FLAGS_NONE 0
IVAM_FLAGS_SUPPORT_SEND_PREPROCESS 0x1
IVAM_FLAGS_SUPPORT_RECEIVE_POSTPROCESS 0x2
MACH_PORT_INFO_STACK_LIMIT 80
offsetof(type, member)  ((size_t)(&((type *)0)->member))
mach_copyout_field(kaddr, uaddr, type_t, field) 	mach_copyout((kaddr), (uaddr) + offsetof(type_t, field), 	    sizeof(((type_t *)0)->field))
_IPC_PORT_H_ None
MACH_PORT_NGEN(name) MACH_PORT_MAKE(0, MACH_PORT_GEN(name))
MACH_PORT_UREFS_OVERFLOW(urefs, delta)                          	        (((delta) > 0) &&                                       	         ((((urefs) + (delta)) <= (urefs)) ||                   	          (((urefs) + (delta)) >= MACH_PORT_UREFS_MAX)))
MACH_PORT_UREFS_UNDERFLOW(urefs, delta)                         	        (((delta) < 0) && (((mach_port_urefs_t)-(delta)) > (urefs)))
_CORE_EXCLUDE_H_ None
_CORE_NOTES_H_ None
MAIN_BIN_SPEC_DATA_OWNER "main bin spec"
MAIN_BIN_SPEC_VERSION 1
MAIN_BIN_SPEC_TYPE_KERNEL 1
MAIN_BIN_SPEC_TYPE_USER 2
MAIN_BIN_SPEC_TYPE_STANDALONE 3
LOAD_BINARY_SPEC_DATA_OWNER "load binary"
LOAD_BINARY_NAME_BUF_SIZE 32
LOAD_BINARY_SPEC_VERSION 1
ADDRABLE_BITS_DATA_OWNER "addrable bits"
ADDRABLE_BITS_VER 3
PANIC_CONTEXT_DATA_OWNER "panic context"
DO_ALIGN 1
KDP_TEST_HARNESS 0
dprintf(x) kprintf x
MAX_BREAKPOINTS 100
KDP_VERSION 12
__KDP_COMMON_H None
__KDP_CORE_H None
KDP_RRQ 1
KDP_WRQ 2
KDP_DATA 3
KDP_ACK 4
KDP_ERROR 5
KDP_SEEK 6
KDP_EOF 7
KDP_FLUSH 8
KDP_FEATURE_MASK_STRING "features"
th_block th_u.tu_block
th_code th_u.tu_code
th_stuff th_u.tu_rpl
th_msg th_data
EUNDEF 0
ENOTFOUND 1
EACCESS 2
ENOSPACE 3
EBADOP 4
EBADID 5
EEXISTS 6
ENOUSER 7
CORE_REMOTE_PORT 1069
DYLD_ALL_IMAGE_INFOS_ADDRESS_MINIMUM_VERSION 9
DYLD_ALL_IMAGE_INFOS_TIMESTAMP_MINIMUM_VERSION 15
DYLD_ALL_IMAGE_INFOS_COMPACTINFO_MINIMUM_VERSION 16
DYLD_MAX_PROCESS_INFO_NOTIFY_COUNT 8
DYLD_PROCESS_INFO_NOTIFY_MAGIC 0x49414E46
KDP_READY 0x1
KDP_ARP 0x2
KDP_BP_DIS 0x4
KDP_GETC_ENA 0x8
KDP_PANIC_DUMP_ENABLED 0x10
PANIC_CORE_ON_NMI 0x20
DBG_POST_CORE 0x40
PANIC_LOG_DUMP 0x80
REBOOT_POST_CORE 0x100
SYSTEM_LOG_DUMP 0x200
MAX_BREAKINSN_BYTES 4
_KDP_PROTOCOL_H_ None
KDP_REXMIT_TRIES 8
KDP_MAX_ATTN_WAIT 30
KDP_REMOTE_PORT 41139
UDP_HOST_COMM_BASE 41140
UDP_HOST_EXCEP_BASE 41145
NUM_UDP_HOST_PORTS 5
KDP_FEATURE_BP 0x1
MAX_KDP_PKT_SIZE 1200
MAX_KDP_DATA_SIZE 1024
KDP_MANUAL_PACKET_SIZE 128
SKDP_START_CHAR 0xFA
SKDP_END_CHAR 0xFB
SKDP_ESC_CHAR 0xFE
_KDP_SERIAL_H_ None
KERNEL_PRIVATE None
__KDP_UDP_H None
ETHER_ADDR_LEN 6
ntohs(x) OSSwapBigToHostInt16(x)
ntohl(x) OSSwapBigToHostInt32(x)
htons(x) OSSwapHostToBigInt16(x)
htonl(x) OSSwapHostToBigInt32(x)
_PROCESSOR_CORE_H_ None
KERN_COREDUMP_MAX_CORES 64
KERN_COREDUMP_MIN_CONFIG_VERSION 1
KERN_COREDUMP_MIN_CONFIG_NOTES 2
KERN_COREDUMP_CONFIG_VERSION 2
KERN_COREDUMP_VERSIONSTRINGMAXSIZE 256
KERN_COREDUMP_MAXDEBUGLOGSIZE 16384
KERN_COREDUMP_BEGIN_FILEBYTES_ALIGN 4096
KERN_COREDUMP_THREADSIZE_MAX 1024
__SK_CORE_H None
_KERN_AFFINITY_H_ None
_KERN_ARCADE_H_ None
_ARITHMETIC_128_H_ None
_KERN_ASSERT_H_ None
__FILE_NAME__ __FILE__
__Panic(fmt, args...) (panic)(fmt, ##args)
APPLE_KEXT_ASSERTIONS 0
MACH_ASSERT_TRAP_CODE 0xbffc
MACH_ASSERT_SEGSECT "__DATA_CONST,__assert"
__assert_only None
assertf(ex, fmt, args...)  ({ 	if (mach_assert_enabled_expr(ex) && __builtin_expect(!(ex), 0L)) {      	        __Panic("%s:%d Assertion failed: %s : " fmt,                    	            __FILE_NAME__, __LINE__, # ex, ##args);                     	}                                                                       })
assert3u(a, op, b)  ({                                                  	if (mach_assert_enabled_expr((unsigned long long)(a) op                 	    (unsigned long long)(b))) {                                         	        const unsigned long long a_ = (a);                              	        const unsigned long long b_ = (b);                                                                                                              	        if (__builtin_expect(!(a_ op b_), 0L)) {                        	                __attribute__((used, section(MACH_ASSERT_SEGSECT)))     	                static const struct mach_assert_3x __desc3u = {         	                        { MACH_ASSERT_3U, __LINE__, __FILE_NAME__, },   	                        #a, #op, #b,                                    	                };                                                                                                                                      	                ml_fatal_trap_with_value3(MACH_ASSERT_TRAP_CODE,        	                    &__desc3u, a_, b_);                                 	        }                                                               	}                                                                       })
assert3s(a, op, b)  ({                                                  	if (mach_assert_enabled_expr((long long)(a) op ((long long)b))) {       	        const signed long long a_ = (a);                                	        const signed long long b_ = (b);                                                                                                                	        if (__builtin_expect(!(a_ op b_), 0L)) {                        	                __attribute__((used, section(MACH_ASSERT_SEGSECT)))     	                static const struct mach_assert_3x __desc3s = {         	                        { MACH_ASSERT_3S, __LINE__, __FILE_NAME__, },   	                        #a, #op, #b,                                    	                };                                                                                                                                      	                ml_fatal_trap_with_value3(MACH_ASSERT_TRAP_CODE,        	                    &__desc3s, a_, b_);                                 	        }                                                               	}                                                                       })
assert3p(a, op, b)  ({                                                  	if (mach_assert_enabled_expr((const void *)(a) op (const void *)(b))) { 	        const void *a_ = (a);                                           	        const void *b_ = (b);                                                                                                                           	        if (__builtin_expect(!(a_ op b_), 0L)) {                        	                __attribute__((used, section(MACH_ASSERT_SEGSECT)))     	                static const struct mach_assert_3x __desc3p = {         	                        { MACH_ASSERT_3P, __LINE__, __FILE_NAME__, },   	                        #a, #op, #b,                                    	                };                                                                                                                                      	                ml_fatal_trap_with_value3(MACH_ASSERT_TRAP_CODE,        	                    &__desc3p, a_, b_);                                 	        }                                                               	}                                                                       })
_KERN_AST_H_ None
AST_NONE 0x00
thread_ast_set(act, reason)     ((void)os_atomic_or(&(act)->ast, (reason), relaxed))
thread_ast_clear(act, reason)   ((void)os_atomic_andnot(&(act)->ast, (reason), relaxed))
thread_ast_peek(act, reason)    (os_atomic_load(&(act)->ast, relaxed) & (reason))
thread_ast_get(act) os_atomic_load(&(act)->ast, relaxed)
AST_KEVENT_RETURN_TO_KERNEL 0x0001
AST_KEVENT_REDRIVE_THREADREQ 0x0002
AST_KEVENT_WORKQ_QUANTUM_EXPIRED 0x0004
_KERN_AUDIT_SESSIONPORT_H_ None
KERN_BACKTRACE_H None
__BITS_H__ None
__DARWIN_UINT None
extract(x, shift, width)        ((((uint64_t)(x)) >> (shift)) & mask(width))
bits(x, hi, lo)                 extract((x), (lo), (hi) - (lo) + 1)
bit_set(x, b)                   ((x) |= BIT(b))
bit_clear(x, b)                 ((x) &= ~BIT(b))
bit_test(x, b)                  ((bool)((x) & BIT(b)))
bit_clear_if_set(bitmap, bit) ({ 	int _n = (bit); 	__auto_type _map = &(bitmap); 	bool _bit_is_set = bit_test(*_map, _n); 	bit_clear(*_map, _n); 	_bit_is_set; })
bit_set_if_clear(bitmap, bit) ({ 	int _n = (bit); 	__auto_type _map = &(bitmap); 	bool _bit_is_set = bit_test(*_map, _n); 	bit_set(*_map, _n); 	!_bit_is_set; })
bit_log2(n) bit_floor((uint64_t)(n))
bitmap_bit(n) bits(n, 5, 0)
bitmap_index(n) bits(n, 63, 6)
_KERN_BLOCK_HINT_H_ None
BOOTPROFILE_LOCK() do { lck_mtx_lock(&bootprofile_mtx); } while(0)
BOOTPROFILE_TRY_SPIN_LOCK() lck_mtx_try_lock_spin(&bootprofile_mtx)
BOOTPROFILE_UNLOCK() do { lck_mtx_unlock(&bootprofile_mtx); } while(0)
BTS_FRAMES_MAX 13
BTS_FRAMES_REF_MASK 0xfffffff0
BTS_FRAMES_REF_INC 0x00000010
BTS_FRAMES_LEN_MASK 0x0000000f
BTREF_PERMANENT_BIT 0x80000000u
BTREF_OP_MASK 0x0000003fu
BTREF_VALID_MASK 0xc000003fu
BTL_SLABS 9
BTL_PARAM_INIT 0x00000020u
BTL_PARAM_IDX(p, h)     ((uint64_t)(h) >> ((p) & 0x3f))
BTL_HASH_SHIFT 8
BTL_SAMPLE_LIMIT 0x007fffffu
btll_count btll_hdr.btl_count
BT_HASH_END_MARKER UINT32_MAX
btlh_count btlh_hdr.btl_count
_KERN_BTLOG_H_ None
BTLOG_MAX_DEPTH 15
_KERN_BUILD_CONFIG_H None
KERN_CAMBRIA_LAYOUT_H None
_KERN_CIRCLE_QUEUE_H_ None
cqe_element(qe, type, field) __container_of(qe, type, field)
cqe_foreach(qe, head) 	for (qe = circle_queue_first(head); qe; qe = circle_queue_next(head, qe))
cqe_foreach_safe(qe, head) 	for (queue_entry_t _ne, _qe = circle_queue_first(head); 	     (qe = _qe) && (_ne = circle_queue_next(head, _qe), 1); 	     _qe = _ne)
cqe_foreach_element(elt, head, field) 	for (queue_entry_t _qe = circle_queue_first(head); 	     _qe && (elt = cqe_element(_qe, typeof(*(elt)), field), 1); 	     _qe = circle_queue_next(head, _qe))
cqe_foreach_element_safe(elt, head, field) 	for (queue_entry_t _ne, _qe = circle_queue_first(head); 	     _qe && (elt = cqe_element(_qe, typeof(*(elt)), field), 	     _ne = circle_queue_next(head, _qe), 1); 	     _qe = _ne)
cqe_dequeue_head(head, type, field) ({ 	queue_entry_t _tmp_entry = circle_dequeue_head((head)); 	type *_tmp_element = (type*) NULL; 	if (_tmp_entry != (queue_entry_t) NULL) 	        _tmp_element = cqe_element(_tmp_entry, type, field); 	_tmp_element; })
cqe_dequeue_tail(head, type, field) ({ 	queue_entry_t _tmp_entry = circle_dequeue_tail((head)); 	type *_tmp_element = (type*) NULL; 	if (_tmp_entry != (queue_entry_t) NULL) 	        _tmp_element = cqe_element(_tmp_entry, type, field); 	_tmp_element; })
cqe_queue_first(head, type, field) ({ 	queue_entry_t _tmp_entry = circle_queue_first((head)); 	type *_tmp_element = (type*) NULL; 	if (_tmp_entry != (queue_entry_t) NULL) 	        _tmp_element = cqe_element(_tmp_entry, type, field); 	_tmp_element; })
cqe_queue_next(elt, head, type, field) ({ 	queue_entry_t _tmp_entry = circle_queue_next((head), (elt)); 	type *_tmp_element = (type*) NULL; 	if (_tmp_entry != (queue_entry_t) NULL) 	        _tmp_element = cqe_element(_tmp_entry, type, field); 	_tmp_element; })
cqe_queue_last(head, type, field) ({ 	queue_entry_t _tmp_entry = circle_queue_last((head)); 	type *_tmp_element = (type*) NULL; 	if (_tmp_entry != (queue_entry_t) NULL) 	        _tmp_element = cqe_element(_tmp_entry, type, field); 	_tmp_element; })
circle_queue_init(q) MACRO_BEGIN             	(q)->head = NULL; MACRO_END
clock_lock() lck_ticket_lock(&clock_lock, &clock_lock_grp)
clock_unlock() lck_ticket_unlock(&clock_lock)
TIME_ADD(rsecs, secs, rfrac, frac, unit)        MACRO_BEGIN                                                                                     	if (((rfrac) += (frac)) >= (unit)) {                    	        (rfrac) -= (unit);                                                      	        (rsecs) += 1;                                                           	}                                                                                               	(rsecs) += (secs);                                                              MACRO_END
TIME_SUB(rsecs, secs, rfrac, frac, unit)        MACRO_BEGIN                                                                                     	if ((int)((rfrac) -= (frac)) < 0) {                             	        (rfrac) += (unit);                                                      	        (rsecs) -= 1;                                                           	}                                                                                               	(rsecs) -= (secs);                                                              MACRO_END
_KERN_CLOCK_H_ None
al_type al_alrm.type
al_port al_alrm.port
al_port_type al_alrm.port_type
al_clock al_alrm.clock
al_data al_alrm.data
ALARM_FREE 0
ALARM_SLEEP 1
ALARM_CLOCK 2
ALARM_DONE 4
LOCK_ALARM(s) s = splclock();                 	simple_lock(&alarm_lock, LCK_GRP_NULL);
UNLOCK_ALARM(s) simple_unlock(&alarm_lock);     	splx(s);
CONFIG_COALITION_MAX CONFIG_TASK_MAX
COALITION_CHUNK TASK_CHUNK
coal_ref_init(coal, c)      os_ref_init_count_raw(&(coal)->ref_count, &coal_ref_grp, c)
coal_ref_count(coal) os_ref_get_count_raw(&(coal)->ref_count)
coal_ref_try_retain(coal) os_ref_retain_try_raw(&(coal)->ref_count, &coal_ref_grp)
coal_ref_retain(coal) os_ref_retain_raw(&(coal)->ref_count, &coal_ref_grp)
coal_ref_release(coal) os_ref_release_raw(&(coal)->ref_count, &coal_ref_grp)
coal_ref_release_live(coal) os_ref_release_live_raw(&(coal)->ref_count, &coal_ref_grp)
COALITION_HASH_SIZE_MIN 16
coal_call(coal, func, ...) 	(s_coalition_types[(coal)->type].func)(coal, ## __VA_ARGS__)
coalition_lock(c) lck_mtx_lock(&(c)->lock)
coalition_unlock(c) lck_mtx_unlock(&(c)->lock)
MAX_SORTED_PIDS 80
_KERN_COALITION_H_ None
compact_id_table_sleep(table) lck_mtx_sleep_with_inheritor(&(table)->cidt_lock, 	    LCK_SLEEP_DEFAULT, (event_t)(table), (table)->cidt_allocator, 	    THREAD_UNINT, TIMEOUT_WAIT_FOREVER)
compact_id_table_wake(table) wakeup_all_with_inheritor((event_t)(table), THREAD_AWAKENED)
_KERN_COMPACT_ID_H_ None
COMPACT_ID_TABLE_DEFINE(class, var) 	static void *var##_array0[COMPACT_ID_COUNT_BASE];                       	static bitmap_t var##_bits0[BITMAP_LEN(COMPACT_ID_COUNT_BASE)] = {      	        [0 ... BITMAP_LEN(COMPACT_ID_COUNT_BASE) - 1] = ~0ull,          	};                                                                      	class struct compact_id_table var = {                                   	        .cidt_bitmap[0] = var##_bits0,                                  	        .cidt_array[0]  = var##_array0,                                 	};                                                                      	STARTUP_ARG(LOCKS, STARTUP_RANK_THIRD, compact_id_table_init, &var)
__COPYOUT_SHIM_X86_64_H__ None
CO_SRC_NORMAL 1
unregister_copyout_shim() register_copyout_shim(NULL,0)
CORE_ANALYTICS_EVENT_QUEUE_PRIORITY MAXPRI_USER
_KERN_COUNTER_H None
SCALABLE_COUNTER_DECLARE(name) extern scalable_counter_t name;
SCALABLE_COUNTER_DEFINE(name) __startup_data uint64_t __ ##name##_early_storage = 0;                                   	scalable_counter_t name = {&__##name##_early_storage};                                   	STARTUP_ARG(TUNABLES, STARTUP_RANK_MIDDLE, scalable_counter_static_boot_mangle, &name);  	STARTUP_ARG(PERCPU, STARTUP_RANK_SECOND, scalable_counter_static_init, &name);
COUNTER_MAKE_PROTOTYPES(counter_t) OS_OVERLOADABLE                                                            extern void counter_alloc(counter_t *);                                                                                                               OS_OVERLOADABLE                                                            extern void counter_free(counter_t *);                                                                                                                OS_OVERLOADABLE                                                            extern void counter_add(counter_t *, uint64_t amount);                                                                                                OS_OVERLOADABLE                                                            extern void counter_inc(counter_t *);                                                                                                                 OS_OVERLOADABLE                                                            extern void counter_dec(counter_t *);                                                                                                                 OS_OVERLOADABLE                                                            extern void counter_add_preemption_disabled(counter_t *, uint64_t amount);                                                                            OS_OVERLOADABLE                                                            extern void counter_inc_preemption_disabled(counter_t *);                                                                                             OS_OVERLOADABLE                                                            extern void counter_dec_preemption_disabled(counter_t *);                                                                                             OS_OVERLOADABLE                                                            extern uint64_t counter_load(counter_t *);
_KERN_CPU_DATA_H_ None
disable_preemption() _disable_preemption()
disable_preemption_without_measurements() _disable_preemption_without_measurements()
enable_preemption() _enable_preemption()
_KERN_CPU_NUMBER_H_ None
_KERN_CODESIGN_H_ None
CS_VALID 0x00000001
CS_ADHOC 0x00000002
CS_GET_TASK_ALLOW 0x00000004
CS_INSTALLER 0x00000008
CS_FORCED_LV 0x00000010
CS_INVALID_ALLOWED 0x00000020
CS_HARD 0x00000100
CS_KILL 0x00000200
CS_CHECK_EXPIRATION 0x00000400
CS_RESTRICT 0x00000800
CS_ENFORCEMENT 0x00001000
CS_REQUIRE_LV 0x00002000
CS_ENTITLEMENTS_VALIDATED 0x00004000
CS_NVRAM_UNRESTRICTED 0x00008000
CS_RUNTIME 0x00010000
CS_LINKER_SIGNED 0x00020000
CS_EXEC_SET_HARD 0x00100000
CS_EXEC_SET_KILL 0x00200000
CS_EXEC_SET_ENFORCEMENT 0x00400000
CS_EXEC_INHERIT_SIP 0x00800000
CS_KILLED 0x01000000
CS_NO_UNTRUSTED_HELPERS 0x02000000
CS_DYLD_PLATFORM CS_NO_UNTRUSTED_HELPERS
CS_PLATFORM_BINARY 0x04000000
CS_PLATFORM_PATH 0x08000000
CS_DEBUGGED 0x10000000
CS_SIGNED 0x20000000
CS_DEV_CODE 0x40000000
CS_DATAVAULT_CONTROLLER 0x80000000
CS_EXECSEG_MAIN_BINARY 0x1
CS_EXECSEG_ALLOW_UNSIGNED 0x10
CS_EXECSEG_DEBUGGER 0x20
CS_EXECSEG_JIT 0x40
CS_EXECSEG_SKIP_LV 0x80
CS_EXECSEG_CAN_LOAD_CDHASH 0x100
CS_EXECSEG_CAN_EXEC_CDHASH 0x200
KERNEL_HAVE_CS_CODEDIRECTORY 1
KERNEL_CS_CODEDIRECTORY_HAVE_PLATFORM 1
KERNEL_HAVE_CS_GENERICBLOB 1
TRAP_DEBUGGER __asm__ volatile(".long 0xe7ffdeff")
CPUDEBUGGEROP current_debugger_state()->db_current_op
CPUDEBUGGERMSG current_debugger_state()->db_message
CPUPANICSTR current_debugger_state()->db_panic_str
CPUPANICARGS current_debugger_state()->db_panic_args
CPUPANICOPTS current_debugger_state()->db_panic_options
CPUPANICDATAPTR current_debugger_state()->db_panic_data_ptr
CPUDEBUGGERSYNC current_debugger_state()->db_proceed_on_sync_failure
CPUDEBUGGERCOUNT current_debugger_state()->db_entry_count
CPUDEBUGGERRET current_debugger_state()->db_op_return
CPUPANICCALLER current_debugger_state()->db_panic_caller
CPUPANICINITIATOR current_debugger_state()->db_panic_initiator
NESTEDDEBUGGERENTRYMAX 5
KDBG_TRACE_PANIC_FILENAME "/var/tmp/panic.trace"
WATCHDOG_DIAG0 "S3_5_c15_c2_6"
_KERN_DEBUG_H_ None
DEBUG_KPRINT_SYSCALL_PREDICATE(mask) DEBUG_KPRINT_SYSCALL_PREDICATE_INTERNAL(mask, NULL)
DEBUG_KPRINT_SYSCALL_UNIX(fmt, args...)                         	DEBUG_KPRINT_SYSCALL_MASK(DEBUG_KPRINT_SYSCALL_UNIX_MASK,fmt,args)
DEBUG_KPRINT_SYSCALL_MACH(fmt, args...)                         	DEBUG_KPRINT_SYSCALL_MASK(DEBUG_KPRINT_SYSCALL_MACH_MASK,fmt,args)
DEBUG_KPRINT_SYSCALL_MDEP(fmt, args...)                         	DEBUG_KPRINT_SYSCALL_MASK(DEBUG_KPRINT_SYSCALL_MDEP_MASK,fmt,args)
DEBUG_KPRINT_SYSCALL_IPC(fmt, args...)                          	DEBUG_KPRINT_SYSCALL_MASK(DEBUG_KPRINT_SYSCALL_IPC_MASK,fmt,args)
DB_HALT 0x1
DB_PRT 0x2
DB_NMI 0x4
DB_KPRT 0x8
DB_KDB 0x10
DB_ARP 0x40
DB_KDP_BP_DIS 0x80
DB_KDP_GETC_ENA 0x200
DB_KERN_DUMP_ON_PANIC 0x400
DB_KERN_DUMP_ON_NMI 0x800
DB_DBG_POST_CORE 0x1000
DB_PANICLOG_DUMP 0x2000
DB_REBOOT_POST_CORE 0x4000
DB_NMI_BTN_ENA 0x8000
DB_DISABLE_LOCAL_CORE 0x20000
DB_DISABLE_GZIP_CORE 0x40000
DB_DISABLE_CROSS_PANIC 0x80000
DB_REBOOT_ALWAYS 0x100000
DB_DISABLE_STACKSHOT_TO_DISK 0x200000
DB_DEBUG_IP_INIT 0x400000
DB_SOC_HALT_ENABLE 0x800000
DEBUGGER_OPTION_NONE 0x0ULL
DEBUGGER_OPTION_PANICLOGANDREBOOT 0x1ULL
DEBUGGER_OPTION_INITPROC_PANIC 0x20ULL
DEBUGGER_OPTION_COMPANION_PROC_INITIATED_PANIC 0x40ULL
DEBUGGER_OPTION_SKIP_LOCAL_COREDUMP 0x80ULL
DEBUGGER_OPTION_ATTEMPTCOREDUMPANDREBOOT 0x100ULL
DEBUGGER_INTERNAL_OPTION_THREAD_BACKTRACE 0x200ULL
DEBUGGER_OPTION_PRINT_CPU_USAGE_PANICLOG 0x400ULL
DEBUGGER_OPTION_SKIP_PANICEND_CALLOUTS 0x800ULL
DEBUGGER_OPTION_SYNC_ON_PANIC_UNSAFE 0x1000ULL
DEBUGGER_OPTION_USERSPACE_INITIATED_PANIC 0x2000ULL
DEBUGGER_OPTION_INTEGRATED_COPROC_INITIATED_PANIC 0x4000ULL
DEBUGGER_OPTION_USER_WATCHDOG 0x8000ULL
__STRINGIFY(x) #x
LINE_NUMBER(x) __STRINGIFY(x)
PANIC_VALIDATE_PTR(expr) panic_validate_ptr(expr, sizeof(*(expr)), #expr)
ADDITIONAL_PANIC_DATA_BUFFER_MAX_LEN 64
NO_CUR_DB 0x0
KDP_CUR_DB 0x1
DEBUGGER_NO_CPU -1
ECC_EVENT_INFO_DATA_ENTRIES 8
ECC_PANIC_PAGE_MAGIC 0xEC
_KERN_ENERGY_PERF_H_ None
SUPPORT_ENERGY_ID_REPORT_ENERGY 1
ES_INVALID_ID UINT64_MAX
ES_UNIQUE_ID(space, id) ({                                        	assert3u(id >> 56, ==, 0);  	(id | ((uint64_t)space << 56));                                   })
NBUCKETS_QUEUE 512
NBUCKETS_THREAD 64
_KERN_EXCEPTION_H_ None
BT_EXC_PORTS_COUNT 3
_EXC_GUARD_H_ None
GUARD_TYPE_NONE 0x0
GUARD_TYPE_MACH_PORT 0x1
GUARD_TYPE_FD 0x2
GUARD_TYPE_USER 0x3
GUARD_TYPE_VN 0x4
GUARD_TYPE_VIRT_MEMORY 0x5
GUARD_TYPE_REJECTED_SC 0x6
EXC_GUARD_ENCODE_TYPE(code, type) 	((code) |= (((uint64_t)(type) & 0x7ull) << 61))
EXC_GUARD_ENCODE_FLAVOR(code, flavor) 	((code) |= (((uint64_t)(flavor) & 0x1fffffffull) << 32))
EXC_GUARD_ENCODE_TARGET(code, target) 	((code) |= (((uint64_t)(target) & 0xffffffffull)))
_EXC_RESOURCE_H_ None
RESOURCE_TYPE_CPU 1
RESOURCE_TYPE_WAKEUPS 2
RESOURCE_TYPE_MEMORY 3
RESOURCE_TYPE_IO 4
RESOURCE_TYPE_THREADS 5
RESOURCE_TYPE_PORTS 6
FLAVOR_CPU_MONITOR 1
FLAVOR_CPU_MONITOR_FATAL 2
FLAVOR_WAKEUPS_MONITOR 1
FLAVOR_HIGH_WATERMARK 1
FLAVOR_DIAG_MEMLIMIT 2
FLAVOR_IO_PHYSICAL_WRITES 1
FLAVOR_IO_LOGICAL_WRITES 2
FLAVOR_THREADS_HIGH_WATERMARK 1
FLAVOR_PORT_SPACE_FULL 1
EXC_RESOURCE_ENCODE_TYPE(code, type) 	((code) |= (((uint64_t)(type) & 0x7ULL) << 61))
EXC_RESOURCE_ENCODE_FLAVOR(code, flavor) 	((code) |= (((uint64_t)(flavor) & 0x7ULL) << 58))
EXC_RESOURCE_CPUMONITOR_ENCODE_INTERVAL(code, interval) 	((code) |= (((uint64_t)(interval) & 0x1FFFFFFULL) << 7))
EXC_RESOURCE_CPUMONITOR_ENCODE_PERCENTAGE(code, percentage) 	((code) |= (((uint64_t)(percentage) & 0x7FULL)))
EXC_RESOURCE_CPUMONITOR_ENCODE_WAKEUPS_PERMITTED(code, num) 	((code) |= ((uint64_t)(num) & 0xFFFFFULL))
EXC_RESOURCE_CPUMONITOR_ENCODE_OBSERVATION_INTERVAL(code, num) 	((code) |= (((uint64_t)(num) & 0xFFFULL) << 20))
EXC_RESOURCE_CPUMONITOR_ENCODE_WAKEUPS_OBSERVED(subcode, num) 	((subcode) |= ((uint64_t)(num) & 0xFFFFFULL))
EXC_RESOURCE_HWM_ENCODE_LIMIT(code, num) 	((code) |= ((uint64_t)(num) & 0x1FFFULL))
EXC_RESOURCE_IO_ENCODE_INTERVAL(code, interval) 	((code) |= (((uint64_t)(interval) & 0x1FFFFULL) << 15))
EXC_RESOURCE_IO_ENCODE_LIMIT(code, limit) 	((code) |= (((uint64_t)(limit) & 0x7FFFULL)))
EXC_RESOURCE_IO_ENCODE_OBSERVED(subcode, num) 	((subcode) |= (((uint64_t)(num) & 0x7FFFULL)))
EXC_RESOURCE_THREADS_ENCODE_THREADS(code, threads) 	((code) |= (((uint64_t)(threads) & 0x7FFFULL)))
EXC_RESOURCE_PORTS_ENCODE_PORTS(code, num) 	((code) |= ((uint64_t)(num) & 0xFFFFFFULL))
_KERN_EXTMOD_STATISTICS_H_ None
_KERN_EXT_PANICLOG_H_ None
EXT_PANICLOG_ENABLE 1
EXT_PANICLOG_VERSION 2
MAX_DATA_ID_SIZE 32
MAX_EXT_PANICLOG_SIZE 32 * 1024
MAX_EXT_PANICLOG_LOGS 100
PANIC_WITH_DATA_UUID "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"
PANIC_WITH_DATA_MAX_LEN 2048
PANIC_WITH_DATA_DATA_ID "Panic with Data Buffer"
EXTPANICLOG_ENTITLEMENT "com.apple.private.allow-ext_paniclog"
GET_TICKS_VALUE(state, ticks)                                                      	MACRO_BEGIN cpu_load_info->cpu_ticks[(state)] += (uint32_t)(ticks / hz_tick_interval); 	MACRO_END
GET_TICKS_VALUE_FROM_TIMER(processor, state, timer)                            	MACRO_BEGIN GET_TICKS_VALUE(state, timer_grab(&(processor)->timer)); 	MACRO_END
HOST_STATISTICS_TIME_WINDOW 1
HOST_STATISTICS_MAX_REQUESTS 10
HOST_STATISTICS_MIN_REQUESTS 2
HOST_VM_INFO64_REV0 0
HOST_VM_INFO64_REV1 1
HOST_EXTMOD_INFO64_REV0 2
HOST_LOAD_INFO_REV0 3
HOST_VM_INFO_REV0 4
HOST_VM_INFO_REV1 5
HOST_VM_INFO_REV2 6
HOST_CPU_LOAD_INFO_REV0 7
HOST_EXPIRED_TASK_INFO_REV0 8
HOST_EXPIRED_TASK_INFO_REV1 9
HOST_VM_COMPRESSOR_Q_LEN_REV0 10
NUM_HOST_INFO_DATA_TYPES 11
_KERN_HOST_H_ None
host_lock(host) lck_mtx_lock(&(host)->lock)
host_unlock(host) lck_mtx_unlock(&(host)->lock)
_KERN_HOST_NOTIFY_H_ None
_KERN_HOST_STATISTICS_H_ None
_KERN_HVG_HYPERCALL_H_ None
_KERN_HV_SUPPORT_H_ None
HV_TRAP_DISPATCH(type, index, target, argument) 	((__probable(index < hv_trap_table[type].trap_count)) ? 	        hv_trap_table[type].traps[index](target, argument) 	                : KERN_INVALID_ARGUMENT)
_KERN_HV_SUPPORT_KEXT_H_ None
HV_CALLBACKS_RESUME_DEFINED 1
__APPLE_API_PRIVATE 1
__APPLE_API_UNSTABLE 1
_KERN_IPC_HOST_H_ None
MAX_MIG_ENTRIES 1031
_KERN_IPC_KOBJECT_H_ None
IPC_KOBJECT_DEFINE(type, ...) 	__startup_data 	static struct ipc_kobject_ops ipc_kobject_ops_##type = { 	    .iko_op_type = type, 	    .iko_op_name = #type, 	    __VA_ARGS__ 	}; 	STARTUP_ARG(MACH_IPC, STARTUP_RANK_FIRST, ipc_kobject_register_startup, 	    &ipc_kobject_ops_##type)
KERNEL_DESC_SIZE sizeof(mach_msg_kdescriptor_t)
_KERN_IPC_MIG_H_ None
_MIG_MSGID_INVALID(msgid) KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE,                     	    MACHDBG_CODE(DBG_MACH_MSGID_INVALID, (msgid)), 0u, 0u, 0u, 0u, 0u)
_KERN_IPC_MISC_H_ None
SET_EXCEPTION_ENTITLEMENT "com.apple.private.set-exception-port"
IPC_ONLY_ONE_EXCEPTION_PORT "com.apple.security.only-one-exception-port"
_KERN_IPC_TT_H_ None
KEXT_ALIGN_SHIFT 6
kalloc_type_var(type, var)              	((type) == KTV_FIXED?                       	(vm_offset_t) kalloc_type_##var##_fixed:    	(vm_offset_t) kalloc_type_##var##_var)
kalloc_type_func(type, func, ...)       	((type) == KTV_FIXED?                       	kalloc_type_##func##_fixed(__VA_ARGS__):    	kalloc_type_##func##_var(__VA_ARGS__))
_KERN_KALLOC_H_ None
KALLOC_HEAP_DECLARE(var) extern struct kalloc_heap var[1]
KALLOC_HEAP_DEFINE(var, name, heap_id) 	SECURITY_READ_ONLY_LATE(struct kalloc_heap) var[1] = { { 	    .kh_name = (name), 	    .kh_heap_id = (heap_id), 	} }; 	STARTUP_ARG(ZALLOC, STARTUP_RANK_MIDDLE, kheap_startup_init, var)
KHEAP_SONAME KHEAP_DEFAULT
KHEAP_START_SIZE 32
KHEAP_STEP_WIDTH 2
KHEAP_STEP_START 16
KHEAP_START_IDX kalloc_log2down(KHEAP_START_SIZE)
KALLOC_TYPE_DECLARE(var) extern struct kalloc_type_view var[1]
KALLOC_TYPE_DEFINE(var, type, flags) 	_KALLOC_TYPE_DEFINE(var, type, flags); 	__ZONE_DECLARE_TYPE(var, type)
KALLOC_TYPE_VAR_DECLARE(var) extern struct kalloc_type_var_view var[1]
KALLOC_TYPE_VAR_DEFINE(...) KALLOC_DISPATCH(KALLOC_TYPE_VAR_DEFINE, ##__VA_ARGS__)
kheap_alloc_tag(kalloc_heap, size, flags, itag) 	__kheap_alloc(kalloc_heap, size, __zone_flags_mix_tag(flags, itag), NULL)
kheap_alloc(kalloc_heap, size, flags) 	kheap_alloc_tag(kalloc_heap, size, flags, VM_ALLOC_SITE_TAG())
kalloc_data_tag(size, flags, itag) 	kheap_alloc_tag(KHEAP_DATA_BUFFERS, size, flags, itag)
kalloc_data(size, flags) 	kheap_alloc(KHEAP_DATA_BUFFERS, size, flags)
krealloc_data_tag(elem, old_size, new_size, flags, itag) 	__kheap_realloc(KHEAP_DATA_BUFFERS, elem, old_size, new_size, 	    __zone_flags_mix_tag(flags, itag), NULL)
krealloc_data(elem, old_size, new_size, flags) 	krealloc_data_tag(elem, old_size, new_size, flags, 	    VM_ALLOC_SITE_TAG())
kfree_data(elem, size) 	kheap_free(KHEAP_DATA_BUFFERS, elem, size);
kfree_data_addr(elem) kheap_free_addr(KHEAP_DATA_BUFFERS, elem);
kalloc_type(...) KALLOC_DISPATCH(kalloc_type, ##__VA_ARGS__)
kfree_type(...) KALLOC_DISPATCH(kfree_type, ##__VA_ARGS__)
kfree_type_counted_by(type, count, elem) 	kfree_type_counted_by_3(type, count, elem)
kalloc_type_tag(...) KALLOC_DISPATCH(kalloc_type_tag, ##__VA_ARGS__)
krealloc_type_tag(...) KALLOC_DISPATCH(krealloc_type_tag, ##__VA_ARGS__)
krealloc_type(...) KALLOC_DISPATCH(krealloc_type, ##__VA_ARGS__)
kalloc_type_require(type, value) ({                                    	static _KALLOC_TYPE_DEFINE(kt_view_var, type, KT_SHARED_ACCT);         	zone_require(kt_view_var->kt_zv.zv_zone, value);                       })
KALLOC_TYPE_SIG_CHECK(mask, type) 	((KT_SUMMARY_GRANULES(type) & ~(mask)) == 0)
KALLOC_TYPE_IS_DATA_ONLY(type) KALLOC_TYPE_SIG_CHECK(KT_SUMMARY_MASK_DATA, type)
KALLOC_TYPE_IS_COMPATIBLE_PTR(ptr, type)                         	(__builtin_xnu_types_compatible(os_get_pointee_type(ptr), type) ||   	    __builtin_xnu_types_compatible(os_get_pointee_type(ptr), void))
KALLOC_TYPE_ASSERT_COMPATIBLE_POINTER(ptr, type) 	_Static_assert(KALLOC_TYPE_IS_COMPATIBLE_PTR(ptr, type), 	    "Pointer type is not compatible with specified type")
KALLOC_ARRAY_TYPE_DECL(...) KALLOC_DISPATCH(KALLOC_ARRAY_TYPE_DECL, ##__VA_ARGS__)
KALLOC_ARRAY_TYPE_DECL_(name, h_type_t, h_sz, e_type_t, e_sz) 	KALLOC_TYPE_VAR_DECLARE(name ## _kt_view);                              	typedef struct name * __unsafe_indexable name ## _t;                                                                                                    	__pure2                                                                 	static inline uint32_t                                                  	name ## _count_to_size(uint32_t count)                                  	{                                                                       	        return (uint32_t)((h_sz) + (e_sz) * count);                     	}                                                                                                                                                       	__pure2                                                                 	static inline uint32_t                                                  	name ## _size_to_count(vm_size_t size)                                  	{                                                                       	        return (uint32_t)((size - (h_sz)) / (e_sz));                    	}                                                                                                                                                       	__pure2                                                                 	static inline uint32_t                                                  	name ## _size(name ## _t array)                                         	{                                                                       	        return __kalloc_array_size((vm_address_t)array);                	}                                                                                                                                                       	__pure2                                                                 	static inline uint32_t                                                  	name ## _next_size(                                                     	        uint32_t                min_count,                              	        vm_size_t               cur_size,                               	        uint32_t                vm_period)                              	{                                                                       	        vm_size_t size;                                                                                                                                 	        if (cur_size) {                                                 	                size = cur_size + (e_sz) - 1;                           	        } else {                                                        	                size = kt_size(h_sz, e_sz, min_count) - 1;              	        }                                                               	        size  = kalloc_next_good_size(size, vm_period);                 	        if (size <= KALLOC_ARRAY_SIZE_MAX) {                            	               return (uint32_t)size;                                   	        }                                                               	        return 2 * KALLOC_ARRAY_SIZE_MAX;                	}                                                                                                                                                       	__pure2                                                                 	static inline uint32_t                                                  	name ## _count(name ## _t array)                                        	{                                                                       	        return name ## _size_to_count(name ## _size(array));            	}                                                                                                                                                       	__pure2                                                                 	static inline h_type_t *__header_bidi_indexable                         	name ## _base(name ## _t array)                                         	{                                                                       	        vm_address_t base = __kalloc_array_base((vm_address_t)array);   	        uint32_t     size = __kalloc_array_size((vm_address_t)array);                                                                                   	        (void)size;                                                     	        return __unsafe_forge_bidi_indexable(h_type_t *, base, size);   	}                                                                                                                                                       	__pure2                                                                 	static inline e_type_t *__header_bidi_indexable                         	name ## _begin(name ## _t array)                                        	{                                                                       	        vm_address_t base = __kalloc_array_base((vm_address_t)array);   	        uint32_t     size = __kalloc_array_size((vm_address_t)array);                                                                                   	        (void)size;                                                     	        return __unsafe_forge_bidi_indexable(e_type_t *, base, size);   	}                                                                                                                                                       	__pure2                                                                 	static inline e_type_t *                                                	name ## _next_elem(name ## _t array, e_type_t *e)                       	{                                                                       	        vm_address_t end = __kalloc_array_end((vm_address_t)array);     	        vm_address_t ptr = (vm_address_t)e + sizeof(e_type_t);                                                                                          	        if (ptr + sizeof(e_type_t) <= end) {                            	                return __unsafe_forge_single(e_type_t *, ptr);          	        }                                                               	        return NULL;                                                    	}                                                                                                                                                       	__pure2                                                                 	static inline bool                                                      	name ## _contains(name ## _t array, vm_size_t i)                        	{                                                                       	        vm_size_t offs = (e_sz) + (h_sz);                               	        vm_size_t s;                                                                                                                                    	        if (__improbable(os_mul_and_add_overflow(i, e_sz, offs, &s))) { 	                return false;                                           	        }                                                               	        if (__improbable(s > name ## _size(array))) {                   	                return false;                                           	        }                                                               	        return true;                                                    	}                                                                                                                                                       	__pure2                                                                 	static inline e_type_t * __single                                       	name ## _get_nocheck(name ## _t array, vm_size_t i)                     	{                                                                       	        return name ## _begin(array) + i;                               	}                                                                                                                                                       	__pure2                                                                 	static inline e_type_t * __single                                       	name ## _get(name ## _t array, vm_size_t i)                             	{                                                                       	        if (__probable(name ## _contains(array, i))) {                  	            return name ## _get_nocheck(array, i);                      	        }                                                               	        return NULL;                                                    	}                                                                                                                                                       	static inline name ## _t                                                	name ## _alloc_by_size(vm_size_t size, zalloc_flags_t fl)               	{                                                                       	        fl |= Z_KALLOC_ARRAY;                                           	        fl = __zone_flags_mix_tag(fl, VM_ALLOC_SITE_TAG());             	        return (name ## _t)kalloc_type_var_impl(name ## _kt_view,       	                        size, fl, NULL);                                	}                                                                                                                                                       	static inline name ## _t                                                	name ## _alloc_by_count(uint32_t count, zalloc_flags_t fl)              	{                                                                       	        return name ## _alloc_by_size(kt_size(h_sz, e_sz, count), fl);  	}                                                                                                                                                       	static inline name ## _t                                                	name ## _realloc_by_size(                                               	        name ## _t              array,                                  	        vm_size_t               new_size,                               	        zalloc_flags_t          fl)                                     	{                                                                       	        vm_address_t base = __kalloc_array_base((vm_address_t)array);   	        vm_size_t    size = __kalloc_array_size((vm_address_t)array);                                                                                   	        fl |= Z_KALLOC_ARRAY;                                           	        fl = __zone_flags_mix_tag(fl, VM_ALLOC_SITE_TAG());             	        return (name ## _t)(krealloc_ext)(                              	                        kt_mangle_var_view(name ## _kt_view),           	                        (void *)base, size, new_size, fl, NULL).addr;   	}                                                                                                                                                       	static inline name ## _t                                                	name ## _realloc_by_count(                                              	        name ## _t              array,                                  	        uint32_t                new_count,                              	        zalloc_flags_t          fl)                                     	{                                                                       	        vm_size_t new_size = kt_size(h_sz, e_sz, new_count);                                                                                            	        return name ## _realloc_by_size(array, new_size, fl);           	}                                                                                                                                                       	static inline void                                                      	name ## _free_noclear(name ## _t array)                                 	{                                                                       	        kfree_type_var_impl(name ## _kt_view,                           	            name ## _base(array), name ## _size(array));                	}                                                                                                                                                       	static inline void                                                      	name ## _free(name ## _t *arrayp)                                       	{                                                                       	        name ## _t array = *arrayp;                                                                                                                     	        *arrayp = NULL;                                                 	        kfree_type_var_impl(name ## _kt_view,                           	            name ## _base(array), name ## _size(array));                	}
KALLOC_ARRAY_TYPE_DEFINE(...) KALLOC_DISPATCH(KALLOC_ARRAY_TYPE_DEFINE, ##__VA_ARGS__)
KALLOC_ARRAY_TYPE_DECL_2(name, e_type_t) 	KALLOC_ARRAY_TYPE_DECL_(name, e_type_t, 0, e_type_t, sizeof(e_type_t))
KALLOC_ARRAY_TYPE_DECL_3(name, h_type_t, e_type_t) 	KALLOC_ARRAY_TYPE_DECL_(name,                                           	    h_type_t, kt_realign_sizeof(h_type_t, e_type_t),                    	    e_type_t, sizeof(e_type_t))
KALLOC_ARRAY_TYPE_DEFINE_3(name, e_type_t, flags) 	KALLOC_TYPE_VAR_DEFINE_3(name ## _kt_view, e_type_t, flags)
KALLOC_ARRAY_TYPE_DEFINE_4(name, h_type_t, e_type_t, flags) 	KALLOC_TYPE_VAR_DEFINE_4(name ## _kt_view, h_type_t, e_type_t, flags)
kt_realign_sizeof(h_ty, e_ty) 	((sizeof(h_ty) + _Alignof(e_ty) - 1) & -_Alignof(e_ty))
kalloc_type_2(type, flags) ({                                          	static _KALLOC_TYPE_DEFINE(kt_view_var, type, KT_SHARED_ACCT);         	__unsafe_forge_single(type *, kalloc_type_impl(kt_view_var, flags));   })
kfree_type_2(type, elem) ({                                            	KALLOC_TYPE_ASSERT_COMPATIBLE_POINTER(elem, type);                     	static _KALLOC_TYPE_DEFINE(kt_view_var, type, KT_SHARED_ACCT);         	kfree_type_impl(kt_view_var, os_ptr_load_and_erase(elem));             })
kfree_type_3(type, count, elem) ({                                     	KALLOC_TYPE_ASSERT_COMPATIBLE_POINTER(elem, type);                     	static KALLOC_TYPE_VAR_DEFINE_3(kt_view_var, type, KT_SHARED_ACCT);    	__auto_type __kfree_count = (count);                                   	kfree_type_var_impl(kt_view_var, os_ptr_load_and_erase(elem),          	    kt_size(0, sizeof(type), __kfree_count));                          })
kfree_type_counted_by_3(type, count_var, elem_var) ({                  	void *__header_bidi_indexable __elem_copy = (elem_var);                	__auto_type __kfree_count = (count_var);                               	(elem_var) = 0;                                                        	(count_var) = 0;                                                       	KALLOC_TYPE_ASSERT_COMPATIBLE_POINTER(                                 	    (os_get_pointee_type(elem_var) *)NULL, type);                      	static KALLOC_TYPE_VAR_DEFINE_3(kt_view_var, type, KT_SHARED_ACCT);    	kfree_type_var_impl(kt_view_var, __elem_copy,                          	    kt_size(0, sizeof(type), __kfree_count));                          })
kfree_type_4(hdr_ty, e_ty, count, elem) ({                             	KALLOC_TYPE_ASSERT_COMPATIBLE_POINTER(elem, hdr_ty);                   	static KALLOC_TYPE_VAR_DEFINE_4(kt_view_var, hdr_ty, e_ty,             	    KT_SHARED_ACCT);                                                   	__auto_type __kfree_count = (count);                                   	kfree_type_var_impl(kt_view_var,                                       	    os_ptr_load_and_erase(elem),                                       	    kt_size(kt_realign_sizeof(hdr_ty, e_ty), sizeof(e_ty),             	    __kfree_count));                                                   })
kalloc_type_tag_3(type, flags, tag) ({                                 	static _KALLOC_TYPE_DEFINE(kt_view_var, type, KT_SHARED_ACCT);         	__unsafe_forge_single(type *, kalloc_type_impl(kt_view_var,            	    Z_VM_TAG(flags, tag)));                                            })
kalloc_type_tag_4(type, count, flags, tag) ({                          	static KALLOC_TYPE_VAR_DEFINE_3(kt_view_var, type, KT_SHARED_ACCT);    	(type *)kalloc_type_var_impl(kt_view_var,                              	    kt_size(0, sizeof(type), count),                                   	    __zone_flags_mix_tag(flags, tag), NULL);                           })
kalloc_type_3(type, count, flags)  	kalloc_type_tag_4(type, count, flags, VM_ALLOC_SITE_TAG())
kalloc_type_tag_5(hdr_ty, e_ty, count, flags, tag) ({                  	static KALLOC_TYPE_VAR_DEFINE_4(kt_view_var, hdr_ty, e_ty,             	    KT_SHARED_ACCT);                                                   	(hdr_ty *)kalloc_type_var_impl(kt_view_var,                            	    kt_size(kt_realign_sizeof(hdr_ty, e_ty), sizeof(e_ty), count),     	    __zone_flags_mix_tag(flags, tag), NULL);                           })
kalloc_type_4(hdr_ty, e_ty, count, flags) 	kalloc_type_tag_5(hdr_ty, e_ty, count, flags, VM_ALLOC_SITE_TAG())
krealloc_type_tag_6(type, old_count, new_count, elem, flags, tag) ({   	static KALLOC_TYPE_VAR_DEFINE_3(kt_view_var, type, KT_SHARED_ACCT);    	KALLOC_TYPE_ASSERT_COMPATIBLE_POINTER(elem, type);                     	(type *)__krealloc_type(kt_view_var, elem,                             	    kt_size(0, sizeof(type), old_count),                               	    kt_size(0, sizeof(type), new_count),                               	    __zone_flags_mix_tag(flags, tag), NULL);                           })
krealloc_type_5(type, old_count, new_count, elem, flags) 	krealloc_type_tag_6(type, old_count, new_count, elem, flags, 	    VM_ALLOC_SITE_TAG())
krealloc_type_tag_7(hdr_ty, e_ty, old_count, new_count, elem,          	    flags, tag) ({                                                     	static KALLOC_TYPE_VAR_DEFINE_4(kt_view_var, hdr_ty, e_ty,             	    KT_SHARED_ACCT);                                                   	KALLOC_TYPE_ASSERT_COMPATIBLE_POINTER(elem, hdr_ty);                   	(hdr_ty *)__krealloc_type(kt_view_var, elem,                           	    kt_size(kt_realign_sizeof(hdr_ty, e_ty), sizeof(e_ty), old_count), 	    kt_size(kt_realign_sizeof(hdr_ty, e_ty), sizeof(e_ty), new_count), 	    __zone_flags_mix_tag(flags, tag), NULL);                           })
krealloc_type_6(hdr_ty, e_ty, old_count, new_count, elem, flags) 	krealloc_type_tag_7(hdr_ty, e_ty, old_count, new_count, elem, flags,   	    VM_ALLOC_SITE_TAG())
kheap_free(heap, elem, size) ({                                        	kalloc_heap_t __kfree_heap = (heap);                                   	__auto_type __kfree_size = (size);                                     	__builtin_assume(!kt_is_var_view(__kfree_heap));                       	kfree_ext((void *)__kfree_heap,                                        	    (void *)os_ptr_load_and_erase(elem), __kfree_size);                })
kheap_free_addr(heap, elem) ({                                         	kalloc_heap_t __kfree_heap = (heap);                                   	kfree_addr_ext(__kfree_heap, (void *)os_ptr_load_and_erase(elem));     })
kheap_free_bounded(heap, elem, min_sz, max_sz) ({                      	static_assert(max_sz <= KALLOC_SAFE_ALLOC_SIZE);                       	kalloc_heap_t __kfree_heap = (heap);                                   	__auto_type __kfree_min_sz = (min_sz);                                 	__auto_type __kfree_max_sz = (max_sz);                                 	(kheap_free_bounded)(__kfree_heap,                                     	    (void *)os_ptr_load_and_erase(elem),                               	    __kfree_min_sz, __kfree_max_sz);                                   })
__kfree_data_elem_count_size(elem_var, count_var, size) ({              	void *__header_bidi_indexable __elem_copy = (elem_var);                 	(elem_var) = 0;                                                         	(count_var) = 0;                                                        	kfree_data(__elem_copy, size);                                          })
__kfree_data_addr_count_size(addr_var, count_var) ({                    	void *__header_bidi_indexable __addr_copy = (addr_var);                 	(addr_var) = 0;                                                         	(count_var) = 0;                                                        	kfree_data_addr(__addr_copy);                                           })
kfree_data_sized_by(elem, size) ({                                      	__auto_type __size = (size);                                            	__kfree_data_elem_count_size(elem, size, __size);                       })
kfree_data_addr_sized_by(addr, size) ({                                 	__kfree_data_addr_count_size(addr, size);                               })
kfree_data_counted_by(elem, count) ({                                  	__auto_type __size = (count) * sizeof(*(elem));                        	__kfree_data_elem_count_size(elem, count, __size);                     })
KALLOC_CONCAT(x, y) __CONCAT(x,y)
KALLOC_COUNT_ARGS1(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, N, ...) N
KALLOC_COUNT_ARGS(...) KALLOC_COUNT_ARGS1(, ##__VA_ARGS__, _9, _8, _7, _6, _5, _4, _3, _2, _1, _0)
KALLOC_DISPATCH1(base, N, ...) __CONCAT(base, N)(__VA_ARGS__)
KALLOC_DISPATCH(base, ...) 	KALLOC_DISPATCH1(base, KALLOC_COUNT_ARGS(__VA_ARGS__), ##__VA_ARGS__)
KALLOC_DISPATCH1_R(base, N, ...) __CONCAT(base, N)(__VA_ARGS__)
KALLOC_DISPATCH_R(base, ...) 	KALLOC_DISPATCH1_R(base, KALLOC_COUNT_ARGS(__VA_ARGS__), ##__VA_ARGS__)
kt_view_var KALLOC_CONCAT(kalloc_type_view_, __LINE__)
KALLOC_TYPE_SEGMENT "__DATA_CONST"
KALLOC_TYPE_SIZE_CHECK(size) _Static_assert(size <= KALLOC_SAFE_ALLOC_SIZE,             	"type is too large");
KALLOC_TYPE_CHECK_2(check, type) 	(KALLOC_TYPE_SIG_CHECK(check, type))
KALLOC_TYPE_CHECK_3(check, type1, type2) 	(KALLOC_TYPE_SIG_CHECK(check, type1) && 	    KALLOC_TYPE_SIG_CHECK(check, type2))
KALLOC_TYPE_CHECK(...) KALLOC_DISPATCH_R(KALLOC_TYPE_CHECK, ##__VA_ARGS__)
KALLOC_TYPE_VM_SIZE_CHECK_2(type1, type2) 	(sizeof(type1) + sizeof(type2) > KHEAP_MAX_SIZE)
KALLOC_TYPE_VM_SIZE_CHECK(...) KALLOC_DISPATCH_R(KALLOC_TYPE_VM_SIZE_CHECK, ##__VA_ARGS__)
KALLOC_TYPE_TRAILING_DATA_CHECK(hdr_ty, elem_ty)     	_Static_assert((KALLOC_TYPE_IS_DATA_ONLY(hdr_ty) ||  	    !KALLOC_TYPE_IS_DATA_ONLY(elem_ty)),             	"cannot allocate data-only array of " #elem_ty       	" contiguously to " #hdr_ty)
KALLOC_TYPE_EMIT_SIG(sig_type, ...)                              	(KALLOC_TYPE_CHECK(KT_SUMMARY_MASK_DATA, sig_type, ##__VA_ARGS__) || 	KALLOC_TYPE_VM_SIZE_CHECK(sig_type, ##__VA_ARGS__))?                 	"" : __builtin_xnu_type_signature(sig_type)
KALLOC_TYPE_ADJUST_FLAGS(flags, ...)                                 	KALLOC_TYPE_CAST_FLAGS((flags | KT_CHANGED | KT_CHANGED2 |               	(KALLOC_TYPE_CHECK(KT_SUMMARY_MASK_DATA, __VA_ARGS__)? KT_DATA_ONLY: 0) |	(KALLOC_TYPE_CHECK(KT_SUMMARY_MASK_PTR, __VA_ARGS__)? KT_PTR_ARRAY: 0) | 	(KALLOC_TYPE_VM_SIZE_CHECK(__VA_ARGS__)? KT_VM : 0)))
_KALLOC_TYPE_DEFINE(var, type, flags)                       	__kalloc_no_kasan                                               	__PLACE_IN_SECTION(KALLOC_TYPE_SEGMENT ", __kalloc_type, "      	    "regular, live_support")                                    	struct kalloc_type_view var[1] = { {                            	    .kt_zv.zv_name = "site." #type,                             	    .kt_flags = KALLOC_TYPE_ADJUST_FLAGS(flags, type),          	    .kt_size = sizeof(type),                                    	    .kt_signature = KALLOC_TYPE_EMIT_SIG(type),                 	} };                                                            	KALLOC_TYPE_SIZE_CHECK(sizeof(type));
KALLOC_TYPE_VAR_DEFINE_3(var, type, flags)                  	__kalloc_no_kasan                                               	__PLACE_IN_SECTION(KALLOC_TYPE_SEGMENT ", __kalloc_var, "       	    "regular, live_support")                                    	struct kalloc_type_var_view var[1] = { {                        	    .kt_version = KT_V1,                                        	    .kt_name = "site." #type,                                   	    .kt_flags = KALLOC_TYPE_ADJUST_FLAGS(flags, type),          	    .kt_size_type = sizeof(type),                               	    .kt_sig_type = KALLOC_TYPE_EMIT_SIG(type),                  	} };                                                            	KALLOC_TYPE_SIZE_CHECK(sizeof(type));
KALLOC_TYPE_VAR_DEFINE_4(var, hdr, type, flags)             	__kalloc_no_kasan                                               	__PLACE_IN_SECTION(KALLOC_TYPE_SEGMENT ", __kalloc_var, "       	    "regular, live_support")                                    	struct kalloc_type_var_view var[1] = { {                        	    .kt_version = KT_V1,                                        	    .kt_name = "site." #hdr "." #type,                          	    .kt_flags = KALLOC_TYPE_ADJUST_FLAGS(flags, hdr, type),     	    .kt_size_hdr = sizeof(hdr),                                 	    .kt_size_type = sizeof(type),                               	    .kt_sig_hdr = KALLOC_TYPE_EMIT_SIG(hdr, type),              	    .kt_sig_type = KALLOC_TYPE_EMIT_SIG(type, hdr),             	} };                                                            	KALLOC_TYPE_SIZE_CHECK(sizeof(hdr));                            	KALLOC_TYPE_SIZE_CHECK(sizeof(type));                           	KALLOC_TYPE_TRAILING_DATA_CHECK(hdr, type);
kalloc_ext(hov, size, fl, site) __kalloc_ext(hov, size, fl, site)
kalloc_type_var_impl(ktv, size, fl, site) 	__kalloc_type_var_impl(ktv, size, fl, site)
KALLOC_TYPE_SIZE_MASK 0xffffff
KALLOC_TYPE_IDX_SHIFT 24
KALLOC_TYPE_IDX_MASK 0xff
krealloc_ext(hov, addr, old_size, new_size, fl, site) 	__krealloc_ext(hov, addr, old_size, new_size, fl, site)
_KCDATA_H_ None
KCDATA_DESC_MAXLEN 32
KCDATA_FLAGS_STRUCT_PADDING_MASK 0xf
KCDATA_FLAGS_STRUCT_HAS_PADDING 0x80
KCDATA_ALIGNMENT_SIZE 0x10
KCS_SUBTYPE_FLAGS_NONE 0x0
KCS_SUBTYPE_FLAGS_ARRAY 0x1
KCS_SUBTYPE_FLAGS_STRUCT 0x2
KCS_SUBTYPE_FLAGS_MERGE 0x4
KCS_SUBTYPE_PACK_SIZE(e_count, e_size) (((e_count)&0xffffu) << 16 | ((e_size)&0xffffu))
KCDATA_TYPE_INVALID 0x0u
KCDATA_TYPE_STRING_DESC 0x1u
KCDATA_TYPE_UINT32_DESC 0x2u
KCDATA_TYPE_UINT64_DESC 0x3u
KCDATA_TYPE_INT32_DESC 0x4u
KCDATA_TYPE_INT64_DESC 0x5u
KCDATA_TYPE_BINDATA_DESC 0x6u
KCDATA_TYPE_ARRAY 0x11u
KCDATA_TYPE_TYPEDEFINTION 0x12u
KCDATA_TYPE_CONTAINER_BEGIN 0x13u
KCDATA_TYPE_CONTAINER_END 0x14u
KCDATA_TYPE_ARRAY_PAD0 0x20u
KCDATA_TYPE_ARRAY_PAD1 0x21u
KCDATA_TYPE_ARRAY_PAD2 0x22u
KCDATA_TYPE_ARRAY_PAD3 0x23u
KCDATA_TYPE_ARRAY_PAD4 0x24u
KCDATA_TYPE_ARRAY_PAD5 0x25u
KCDATA_TYPE_ARRAY_PAD6 0x26u
KCDATA_TYPE_ARRAY_PAD7 0x27u
KCDATA_TYPE_ARRAY_PAD8 0x28u
KCDATA_TYPE_ARRAY_PAD9 0x29u
KCDATA_TYPE_ARRAY_PADa 0x2au
KCDATA_TYPE_ARRAY_PADb 0x2bu
KCDATA_TYPE_ARRAY_PADc 0x2cu
KCDATA_TYPE_ARRAY_PADd 0x2du
KCDATA_TYPE_ARRAY_PADe 0x2eu
KCDATA_TYPE_ARRAY_PADf 0x2fu
KCDATA_TYPE_LIBRARY_LOADINFO 0x30u
KCDATA_TYPE_LIBRARY_LOADINFO64 0x31u
KCDATA_TYPE_TIMEBASE 0x32u
KCDATA_TYPE_MACH_ABSOLUTE_TIME 0x33u
KCDATA_TYPE_TIMEVAL 0x34u
KCDATA_TYPE_USECS_SINCE_EPOCH 0x35u
KCDATA_TYPE_PID 0x36u
KCDATA_TYPE_PROCNAME 0x37u
KCDATA_TYPE_NESTED_KCDATA 0x38u
KCDATA_TYPE_LIBRARY_AOTINFO 0x39u
KCDATA_TYPE_BUFFER_END 0xF19158EDu
KCDATA_BUFFER_BEGIN_CRASHINFO 0xDEADF157u
KCDATA_BUFFER_BEGIN_STACKSHOT 0x59a25807u
KCDATA_BUFFER_BEGIN_COMPRESSED 0x434f4d50u
KCDATA_BUFFER_BEGIN_DELTA_STACKSHOT 0xDE17A59Au
KCDATA_BUFFER_BEGIN_BTINFO 0x46414E47u
KCDATA_BUFFER_BEGIN_OS_REASON 0x53A20900u
KCDATA_BUFFER_BEGIN_XNUPOST_CONFIG 0x1e21c09fu
XNUPOST_KCTYPE_TESTCONFIG 0x1040
STACKSHOT_IO_NUM_PRIORITIES 4
STACKSHOT_MAX_THREAD_NAME_SIZE 64
STACKSHOT_KCTYPE_IOSTATS 0x901u
STACKSHOT_KCTYPE_GLOBAL_MEM_STATS 0x902u
STACKSHOT_KCCONTAINER_TASK 0x903u
STACKSHOT_KCCONTAINER_THREAD 0x904u
STACKSHOT_KCTYPE_TASK_SNAPSHOT 0x905u
STACKSHOT_KCTYPE_THREAD_SNAPSHOT 0x906u
STACKSHOT_KCTYPE_DONATING_PIDS 0x907u
STACKSHOT_KCTYPE_SHAREDCACHE_LOADINFO 0x908u
STACKSHOT_KCTYPE_THREAD_NAME 0x909u
STACKSHOT_KCTYPE_KERN_STACKFRAME 0x90Au
STACKSHOT_KCTYPE_KERN_STACKFRAME64 0x90Bu
STACKSHOT_KCTYPE_USER_STACKFRAME 0x90Cu
STACKSHOT_KCTYPE_USER_STACKFRAME64 0x90Du
STACKSHOT_KCTYPE_BOOTARGS 0x90Eu
STACKSHOT_KCTYPE_OSVERSION 0x90Fu
STACKSHOT_KCTYPE_KERN_PAGE_SIZE 0x910u
STACKSHOT_KCTYPE_JETSAM_LEVEL 0x911u
STACKSHOT_KCTYPE_DELTA_SINCE_TIMESTAMP 0x912u
STACKSHOT_KCTYPE_KERN_STACKLR 0x913u
STACKSHOT_KCTYPE_KERN_STACKLR64 0x914u
STACKSHOT_KCTYPE_USER_STACKLR 0x915u
STACKSHOT_KCTYPE_USER_STACKLR64 0x916u
STACKSHOT_KCTYPE_NONRUNNABLE_TIDS 0x917u
STACKSHOT_KCTYPE_NONRUNNABLE_TASKS 0x918u
STACKSHOT_KCTYPE_CPU_TIMES 0x919u
STACKSHOT_KCTYPE_STACKSHOT_DURATION 0x91au
STACKSHOT_KCTYPE_STACKSHOT_FAULT_STATS 0x91bu
STACKSHOT_KCTYPE_KERNELCACHE_LOADINFO 0x91cu
STACKSHOT_KCTYPE_THREAD_WAITINFO 0x91du
STACKSHOT_KCTYPE_THREAD_GROUP_SNAPSHOT 0x91eu
STACKSHOT_KCTYPE_THREAD_GROUP 0x91fu
STACKSHOT_KCTYPE_JETSAM_COALITION_SNAPSHOT 0x920u
STACKSHOT_KCTYPE_JETSAM_COALITION 0x921u
STACKSHOT_KCTYPE_THREAD_POLICY_VERSION 0x922u
STACKSHOT_KCTYPE_INSTRS_CYCLES 0x923u
STACKSHOT_KCTYPE_USER_STACKTOP 0x924u
STACKSHOT_KCTYPE_ASID 0x925u
STACKSHOT_KCTYPE_PAGE_TABLES 0x926u
STACKSHOT_KCTYPE_SYS_SHAREDCACHE_LAYOUT 0x927u
STACKSHOT_KCTYPE_THREAD_DISPATCH_QUEUE_LABEL 0x928u
STACKSHOT_KCTYPE_THREAD_TURNSTILEINFO 0x929u
STACKSHOT_KCTYPE_TASK_CPU_ARCHITECTURE 0x92au
STACKSHOT_KCTYPE_LATENCY_INFO 0x92bu
STACKSHOT_KCTYPE_LATENCY_INFO_TASK 0x92cu
STACKSHOT_KCTYPE_LATENCY_INFO_THREAD 0x92du
STACKSHOT_KCTYPE_LOADINFO64_TEXT_EXEC 0x92eu
STACKSHOT_KCTYPE_AOTCACHE_LOADINFO 0x92fu
STACKSHOT_KCTYPE_TRANSITIONING_TASK_SNAPSHOT 0x930u
STACKSHOT_KCCONTAINER_TRANSITIONING_TASK 0x931u
STACKSHOT_KCTYPE_USER_ASYNC_START_INDEX 0x932u
STACKSHOT_KCTYPE_USER_ASYNC_STACKLR64 0x933u
STACKSHOT_KCCONTAINER_PORTLABEL 0x934u
STACKSHOT_KCTYPE_PORTLABEL 0x935u
STACKSHOT_KCTYPE_PORTLABEL_NAME 0x936u
STACKSHOT_KCTYPE_DYLD_COMPACTINFO 0x937u
STACKSHOT_KCTYPE_SUSPENSION_INFO 0x938u
STACKSHOT_KCTYPE_SUSPENSION_SOURCE 0x939u
STACKSHOT_KCTYPE_TASK_DELTA_SNAPSHOT 0x940u
STACKSHOT_KCTYPE_THREAD_DELTA_SNAPSHOT 0x941u
STACKSHOT_KCCONTAINER_SHAREDCACHE 0x942u
STACKSHOT_KCTYPE_SHAREDCACHE_INFO 0x943u
STACKSHOT_KCTYPE_SHAREDCACHE_AOTINFO 0x944u
STACKSHOT_KCTYPE_SHAREDCACHE_ID 0x945u
STACKSHOT_KCTYPE_CODESIGNING_INFO 0x946u
STACKSHOT_KCTYPE_OS_BUILD_VERSION 0x947u
STACKSHOT_KCTYPE_KERN_EXCLAVES_THREADINFO 0x948u
STACKSHOT_KCCONTAINER_EXCLAVES 0x949u
STACKSHOT_KCCONTAINER_EXCLAVE_SCRESULT 0x94au
STACKSHOT_KCTYPE_EXCLAVE_SCRESULT_INFO 0x94bu
STACKSHOT_KCCONTAINER_EXCLAVE_IPCSTACKENTRY 0x94cu
STACKSHOT_KCTYPE_EXCLAVE_IPCSTACKENTRY_INFO 0x94du
STACKSHOT_KCTYPE_EXCLAVE_IPCSTACKENTRY_ECSTACK 0x94eu
STACKSHOT_KCCONTAINER_EXCLAVE_ADDRESSSPACE 0x94fu
STACKSHOT_KCTYPE_EXCLAVE_ADDRESSSPACE_INFO 0x950u
STACKSHOT_KCTYPE_EXCLAVE_ADDRESSSPACE_NAME 0x951u
STACKSHOT_KCCONTAINER_EXCLAVE_TEXTLAYOUT 0x952u
STACKSHOT_KCTYPE_EXCLAVE_TEXTLAYOUT_INFO 0x953u
STACKSHOT_KCTYPE_EXCLAVE_TEXTLAYOUT_SEGMENTS 0x954u
STACKSHOT_KCTYPE_KERN_EXCLAVES_CRASH_THREADINFO 0x955u
STACKSHOT_KCTYPE_LATENCY_INFO_CPU 0x956u
DYLD_AOT_IMAGE_KEY_SIZE 32
SS_TH_WAIT 0x01
SS_TH_SUSP 0x02
SS_TH_RUN 0x04
SS_TH_UNINT 0x08
SS_TH_TERMINATE 0x10
SS_TH_TERMINATE2 0x20
SS_TH_IDLE 0x80
KCDATA_INVALID_CS_TRUST_LEVEL 0xffffffff
STACKSHOT_WAITINFO_FLAGS_SPECIALREPLY 0x1
STACKSHOT_TURNSTILE_STATUS_UNKNOWN 0x01
STACKSHOT_TURNSTILE_STATUS_LOCKED_WAITQ 0x02
STACKSHOT_TURNSTILE_STATUS_WORKQUEUE 0x04
STACKSHOT_TURNSTILE_STATUS_THREAD 0x08
STACKSHOT_TURNSTILE_STATUS_BLOCKED_ON_TASK 0x10
STACKSHOT_TURNSTILE_STATUS_HELD_IPLOCK 0x20
STACKSHOT_TURNSTILE_STATUS_SENDPORT 0x40
STACKSHOT_TURNSTILE_STATUS_RECEIVEPORT 0x80
STACKSHOT_PORTLABEL_READFAILED 0x1
STACKSHOT_PORTLABEL_THROTTLED 0x2
MAX_CRASHINFO_SIGNING_ID_LEN 64
MAX_CRASHINFO_TEAM_ID_LEN 32
TASK_CRASHINFO_BEGIN KCDATA_BUFFER_BEGIN_CRASHINFO
TASK_CRASHINFO_STRING_DESC KCDATA_TYPE_STRING_DESC
TASK_CRASHINFO_UINT32_DESC KCDATA_TYPE_UINT32_DESC
TASK_CRASHINFO_UINT64_DESC KCDATA_TYPE_UINT64_DESC
TASK_CRASHINFO_EXTMODINFO 0x801
TASK_CRASHINFO_BSDINFOWITHUNIQID 0x802
TASK_CRASHINFO_TASKDYLD_INFO 0x803
TASK_CRASHINFO_UUID 0x804
TASK_CRASHINFO_PID 0x805
TASK_CRASHINFO_PPID 0x806
TASK_CRASHINFO_RUSAGE 0x807
TASK_CRASHINFO_RUSAGE_INFO 0x808
TASK_CRASHINFO_PROC_NAME 0x809
TASK_CRASHINFO_PROC_STARTTIME 0x80B
TASK_CRASHINFO_USERSTACK 0x80C
TASK_CRASHINFO_ARGSLEN 0x80D
TASK_CRASHINFO_EXCEPTION_CODES 0x80E
TASK_CRASHINFO_PROC_PATH 0x80F
TASK_CRASHINFO_PROC_CSFLAGS 0x810
TASK_CRASHINFO_PROC_STATUS 0x811
TASK_CRASHINFO_UID 0x812
TASK_CRASHINFO_GID 0x813
TASK_CRASHINFO_PROC_ARGC 0x814
TASK_CRASHINFO_PROC_FLAGS 0x815
TASK_CRASHINFO_CPUTYPE 0x816
TASK_CRASHINFO_WORKQUEUEINFO 0x817
TASK_CRASHINFO_RESPONSIBLE_PID 0x818
TASK_CRASHINFO_DIRTY_FLAGS 0x819
TASK_CRASHINFO_CRASHED_THREADID 0x81A
TASK_CRASHINFO_COALITION_ID 0x81B
TASK_CRASHINFO_UDATA_PTRS 0x81C
TASK_CRASHINFO_MEMORY_LIMIT 0x81D
TASK_CRASHINFO_LEDGER_INTERNAL 0x81E
TASK_CRASHINFO_LEDGER_INTERNAL_COMPRESSED 0x81F
TASK_CRASHINFO_LEDGER_IOKIT_MAPPED 0x820
TASK_CRASHINFO_LEDGER_ALTERNATE_ACCOUNTING 0x821
TASK_CRASHINFO_LEDGER_ALTERNATE_ACCOUNTING_COMPRESSED 0x822
TASK_CRASHINFO_LEDGER_PURGEABLE_NONVOLATILE 0x823
TASK_CRASHINFO_LEDGER_PURGEABLE_NONVOLATILE_COMPRESSED 0x824
TASK_CRASHINFO_LEDGER_PAGE_TABLE 0x825
TASK_CRASHINFO_LEDGER_PHYS_FOOTPRINT 0x826
TASK_CRASHINFO_LEDGER_PHYS_FOOTPRINT_LIFETIME_MAX 0x827
TASK_CRASHINFO_LEDGER_NETWORK_NONVOLATILE 0x828
TASK_CRASHINFO_LEDGER_NETWORK_NONVOLATILE_COMPRESSED 0x829
TASK_CRASHINFO_LEDGER_WIRED_MEM 0x82A
TASK_CRASHINFO_PROC_PERSONA_ID 0x82B
TASK_CRASHINFO_MEMORY_LIMIT_INCREASE 0x82C
TASK_CRASHINFO_LEDGER_TAGGED_FOOTPRINT 0x82D
TASK_CRASHINFO_LEDGER_TAGGED_FOOTPRINT_COMPRESSED 0x82E
TASK_CRASHINFO_LEDGER_MEDIA_FOOTPRINT 0x82F
TASK_CRASHINFO_LEDGER_MEDIA_FOOTPRINT_COMPRESSED 0x830
TASK_CRASHINFO_LEDGER_GRAPHICS_FOOTPRINT 0x831
TASK_CRASHINFO_LEDGER_GRAPHICS_FOOTPRINT_COMPRESSED 0x832
TASK_CRASHINFO_LEDGER_NEURAL_FOOTPRINT 0x833
TASK_CRASHINFO_LEDGER_NEURAL_FOOTPRINT_COMPRESSED 0x834
TASK_CRASHINFO_MEMORYSTATUS_EFFECTIVE_PRIORITY 0x835
TASK_CRASHINFO_KERNEL_TRIAGE_INFO_V1 0x836
TASK_CRASHINFO_TASK_IS_CORPSE_FORK 0x837
TASK_CRASHINFO_EXCEPTION_TYPE 0x838
TASK_CRASHINFO_CRASH_COUNT 0x839
TASK_CRASHINFO_THROTTLE_TIMEOUT 0x83A
TASK_CRASHINFO_CS_SIGNING_ID 0x83B
TASK_CRASHINFO_CS_TEAM_ID 0x83C
TASK_CRASHINFO_CS_VALIDATION_CATEGORY 0x83D
TASK_CRASHINFO_CS_TRUST_LEVEL 0x83E
TASK_CRASHINFO_PROC_CPUTYPE 0x83F
TASK_CRASHINFO_JIT_ADDRESS_RANGE 0x840
TASK_CRASHINFO_MB 0x841
TASK_CRASHINFO_CS_AUXILIARY_INFO 0x842
TASK_CRASHINFO_END KCDATA_TYPE_BUFFER_END
TASK_BTINFO_BEGIN KCDATA_BUFFER_BEGIN_BTINFO
TASK_BTINFO_PID 0xA01
TASK_BTINFO_PPID 0xA02
TASK_BTINFO_PROC_NAME 0xA03
TASK_BTINFO_PROC_PATH 0xA04
TASK_BTINFO_UID 0xA05
TASK_BTINFO_GID 0xA06
TASK_BTINFO_PROC_FLAGS 0xA07
TASK_BTINFO_CPUTYPE 0xA08
TASK_BTINFO_EXCEPTION_CODES 0xA09
TASK_BTINFO_EXCEPTION_TYPE 0xA0A
TASK_BTINFO_RUSAGE_INFO 0xA0B
TASK_BTINFO_COALITION_ID 0xA0C
TASK_BTINFO_CRASH_COUNT 0xA0D
TASK_BTINFO_THROTTLE_TIMEOUT 0xA0E
TASK_BTINFO_THREAD_ID 0xA20
TASK_BTINFO_THREAD_NAME 0xA21
TASK_BTINFO_THREAD_STATE 0xA22
TASK_BTINFO_THREAD_EXCEPTION_STATE 0xA23
TASK_BTINFO_BACKTRACE 0xA24
TASK_BTINFO_BACKTRACE64 0xA25
TASK_BTINFO_ASYNC_BACKTRACE64 0xA26
TASK_BTINFO_ASYNC_START_INDEX 0xA27
TASK_BTINFO_PLATFORM 0xA28
TASK_BTINFO_SC_LOADINFO 0xA29
TASK_BTINFO_SC_LOADINFO64 0xA2A
TASK_BTINFO_DYLD_LOADINFO KCDATA_TYPE_LIBRARY_LOADINFO
TASK_BTINFO_DYLD_LOADINFO64 KCDATA_TYPE_LIBRARY_LOADINFO64
TASK_BTINFO_FLAGS 0xAFF
TASK_BTINFO_FLAG_BT_TRUNCATED 0x1
TASK_BTINFO_FLAG_ASYNC_BT_TRUNCATED 0x2
TASK_BTINFO_FLAG_TASK_TERMINATED 0x4
TASK_BTINFO_FLAG_KCDATA_INCOMPLETE 0x8
TASK_BTINFO_END KCDATA_TYPE_BUFFER_END
EXIT_REASON_SNAPSHOT 0x1001
EXIT_REASON_USER_DESC 0x1002
EXIT_REASON_USER_PAYLOAD 0x1003
EXIT_REASON_CODESIGNING_INFO 0x1004
EXIT_REASON_WORKLOOP_ID 0x1005
EXIT_REASON_DISPATCH_QUEUE_NO 0x1006
EXIT_REASON_CODESIG_PATH_MAX 1024
EXIT_REASON_USER_DESC_MAX_LEN 1024
EXIT_REASON_PAYLOAD_MAX_LEN 2048
_KERN_APFS_REFLOCK_H_ None
KERN_APFS_REFLOCK_WAITERS_BIT 16
kern_apfs_reflock_data(class, name)   class struct kern_apfs_reflock name
ROUNDUP(x, y)            ((((x)+(y)-1)/(y))*(y))
ZLIB_METADATA_SIZE 1440
kcdata_debug_printf(...) ;
_KERN_CDATA_H_ None
KCDATA_ITEM_ITER(item) kcdata_iter_unsafe((void*)(item))
KCDATA_ITEM_TYPE(item) kcdata_iter_type(KCDATA_ITEM_ITER(item))
KCDATA_ITEM_SIZE(item) kcdata_iter_size(KCDATA_ITEM_ITER(item))
KCDATA_ITEM_FLAGS(item) kcdata_iter_flags(KCDATA_ITEM_ITER(item))
KCDATA_ITEM_ARRAY_GET_EL_TYPE(item) kcdata_iter_array_elem_type(KCDATA_ITEM_ITER(item))
KCDATA_ITEM_ARRAY_GET_EL_COUNT(item) kcdata_iter_array_elem_count(KCDATA_ITEM_ITER(item))
KCDATA_ITEM_ARRAY_GET_EL_SIZE(item) kcdata_iter_array_elem_size(KCDATA_ITEM_ITER(item))
KCDATA_CONTAINER_ID(item) kcdata_iter_container_id(KCDATA_ITEM_ITER(item))
KCDATA_ITEM_FOREACH(head) for (; KCDATA_ITEM_TYPE(head) != KCDATA_TYPE_BUFFER_END; (head) = KCDATA_ITEM_NEXT_HEADER(head))
KCDATA_ITEM_DATA_PTR(item) kcdata_iter_payload(KCDATA_ITEM_ITER(item))
KCDATA_ITEM_FIND_TYPE(itemx, type) (kcdata_iter_find_type(KCDATA_ITEM_ITER(itemx), type).item)
kcdata_get_container_type(buffer) kcdata_iter_container_type(KCDATA_ITEM_ITER(buffer))
kcdata_get_data_with_desc(buf, desc, data) kcdata_iter_get_data_with_desc(KCDATA_ITEM_ITER(buf),desc,data,NULL)
KCFLAG_USE_MEMCOPY 0x0
KCFLAG_USE_COPYOUT 0x1
KCFLAG_NO_AUTO_ENDBUFFER 0x2
KCFLAG_USE_COMPRESSION 0x4
KCFLAG_ALLOC_CALLBACK 0x8
MAX_INFLIGHT_KCOBJECT_LW_CORPSE 15
MT_KDBG_INSTRS_CYCLES(CODE) KDBG_EVENTID(DBG_MONOTONIC, DBG_MT_INSTRS_CYCLES, CODE)
STACKSHOT_COLLECTS_RDAR_126582377_DATA 0
STACKSHOT_NUM_BUFFERS MAX_CPU_CLUSTERS
STACKSHOT_HARDEST_THREADCOUNT 10
plh_lock(plh) while(!os_atomic_cmpxchg(&(plh)->plh_lock, 0, 1, acquire)) { loop_wait(); }
plh_unlock(plh) os_atomic_store(&(plh)->plh_lock, 0, release);
STACKSHOT_PLH_SHIFT 7
STASKSHOT_PLH_SIZE(x) MIN((x), STACKSHOT_PLH_SIZE_MAX)
STACKSHOT_DEBUG_TRACEBUF_SIZE 16
STACKSHOT_CTX_IDX_NORMAL 0
STACKSHOT_CTX_IDX_PANIC 1
MAX_FRAMES 1000
STACKSHOT_PAGETABLE_BUFSZ 4000
MAX_LOADINFOS 500
TASK_IMP_WALK_LIMIT 20
STACKSHOT_SUBSYS_LOCK() lck_mtx_lock(&stackshot_subsys_mutex)
STACKSHOT_SUBSYS_TRY_LOCK() lck_mtx_try_lock(&stackshot_subsys_mutex)
STACKSHOT_SUBSYS_UNLOCK() lck_mtx_unlock(&stackshot_subsys_mutex)
STACKSHOT_SUBSYS_ASSERT_LOCKED() lck_mtx_assert(&stackshot_subsys_mutex, LCK_MTX_ASSERT_OWNED);
ROUNDUP(x, y)            ((((x)+(y)-1)/(y))*(y))
STACKSHOT_QUEUE_LABEL_MAXSIZE 64
kcd_exit_on_error(action) do {                                               	    if (KERN_SUCCESS != (error = (action))) {      	        STACKSHOT_TRACE(error);                    	        if (error == KERN_RESOURCE_SHORTAGE) {     	            error = KERN_INSUFFICIENT_BUFFER_SIZE; 	        }                                          	        goto error_exit;                           	    }                                              	} while (0);
loop_wait_noguard() __builtin_arm_wfe()
loop_wait() { loop_wait_noguard(); stackshot_panic_guard(); }
freelist_lock(buffer) while(!os_atomic_cmpxchg(&buffer->ssb_freelist_lock, 0, 1, acquire)) { loop_wait(); }
freelist_unlock(buffer) os_atomic_store(&buffer->ssb_freelist_lock, 0, release);
calc_num_linked_kcdata_frames(size, kcdata_size) (1 + ((size) - 1) / (kcdata_size))
calc_linked_kcdata_size(size, kcdata_size) (calc_num_linked_kcdata_frames((size), (kcdata_size)) * ((kcdata_size) + sizeof(struct linked_kcdata_descriptor)))
sizeof_if_traceflag(a, flag) (((trace_flags & (flag)) != 0) ? sizeof(a) : 0)
FUDGED_SIZE(size, adj) (((size) * ((adj) + 100)) / 100)
SIZE_EST(x) ROUNDUP((x), sizeof (uintptr_t))
PLH_HASH_STEP(ptr, x) 	    ((((x) * STACKSHOT_PLH_SHIFT) < (sizeof(ispl) * CHAR_BIT)) ? ((ptr) >> ((x) * STACKSHOT_PLH_SHIFT)) : 0)
STACKLR_WORDS STACKSHOT_KCTYPE_USER_STACKLR64
UNIQUEIDSPERFLUSH 12
_KERN_STACKSHOT_H_ None
stackshot_alloc_arr(type, count, err) stackshot_alloc_with_size(sizeof(type) * (count), err)
stackshot_alloc(type, err) stackshot_alloc_with_size(sizeof(type), err)
_KERN_KERN_TYPES_H_ None
SIZEOF_WAITQUEUE sizeof(struct wait_queue)
THREAD_WAITING -1
THREAD_AWAKENED 0
THREAD_TIMED_OUT 1
THREAD_INTERRUPTED 2
THREAD_RESTART 3
THREAD_NOT_WAITING 10
THREAD_UNINT 0x00000000
THREAD_INTERRUPTIBLE 0x00000001
THREAD_ABORTSAFE 0x00000002
THREAD_WAIT_NOREPORT_KERNEL 0x80000000
THREAD_WAIT_NOREPORT_USER 0x40000000
TIMEOUT_URGENCY_SYS_NORMAL 0x00
TIMEOUT_URGENCY_SYS_CRITICAL 0x01
TIMEOUT_URGENCY_SYS_BACKGROUND 0x02
TIMEOUT_URGENCY_USER_MASK 0x10
TIMEOUT_URGENCY_USER_NORMAL 0x10
TIMEOUT_URGENCY_USER_CRITICAL 0x11
TIMEOUT_URGENCY_USER_BACKGROUND 0x12
TIMEOUT_URGENCY_MASK 0x13
TIMEOUT_URGENCY_LEEWAY 0x20
TIMEOUT_URGENCY_FIRST_AVAIL 0x40
TIMEOUT_URGENCY_RATELIMITED 0x80
SIZEOF_WAITQUEUE_SET wait_queue_set_size()
SIZEOF_WAITQUEUE_LINK wait_queue_link_size()
KASLR_IOREG_DEBUG 0
_KEXT_ALLOC_H_ None
NOT_SUPPORTED_USER64() do { 	char procname[64] = "unknown";  	proc_selfname(procname, sizeof(procname));  	printf("%s is not supported for 64-bit clients (called from %s)\n",  	    __FUNCTION__, procname);      } while (0)
NOT_SUPPORTED_KERNEL() do { 	char procname[64] = "unknown";  	proc_selfname(procname, sizeof(procname));  	printf("%s is not supported on this kernel architecture (called from %s)\n",  	    __FUNCTION__, procname);      } while (0)
KMOD_MIG_UNUSED __unused
KERN_KPC_H None
FIXED_RELOAD_CPU(cpu, ctr)              (cpu_datap(cpu)->cpu_kpc_reload[(ctr)])
CONFIGURABLE_RELOAD_CPU(cpu, ctr)       (cpu_datap(cpu)->cpu_kpc_reload[(ctr) + kpc_fixed_count()])
FIXED_SHADOW_CPU(cpu, ctr)              (cpu_datap(cpu)->cpu_kpc_shadow[(ctr)])
CONFIGURABLE_SHADOW_CPU(cpu, ctr)       (cpu_datap(cpu)->cpu_kpc_shadow[(ctr) + kpc_fixed_count()])
LF_ENTRY_ACTIVE 0x0001
LF_WAKE_NEEDED 0x0100
LF_WAKE_INPROGRESS 0x0200
LF_REFILL_SCHEDULED 0x0400
LF_REFILL_INPROGRESS 0x0800
LF_CALLED_BACK 0x1000
LF_WARNED 0x2000
LF_TRACKING_MAX 0x4000
LF_PANIC_ON_NEGATIVE 0x8000
LF_TRACK_CREDIT_ONLY 0x10000
LF_DIAG_WARNED 0x20000
LF_DIAG_DISABLED 0x40000
ENTRY_ID_SIZE_SHIFT 16
LEDGER_DIAG_MEM_THRESHOLD_SHIFT 20
ASSERT(a) assert(a)
template_lock(template) lck_mtx_lock(&(template)->lt_lock)
template_unlock(template) lck_mtx_unlock(&(template)->lt_lock)
TEMPLATE_INUSE(s, t) {                                  	s = splsched();                                         	while (OSCompareAndSwap(0, 1, &((t)->lt_inuse)))        	        ;                                               }
TEMPLATE_IDLE(s, t) {                                   	(t)->lt_inuse = 0;                                      	splx(s);                                                }
_KERN_LEDGER_H_ None
LEDGER_INFO 0
LEDGER_ENTRY_INFO 1
LEDGER_TEMPLATE_INFO 2
LEDGER_LIMIT 3
LEDGER_MAX_CMD LEDGER_LIMIT
LEDGER_NAME_MAX 32
LEDGER_PERCENT_NONE UINT16_MAX
LEDGER_ACTION_IGNORE 0x0000
LEDGER_ACTION_BLOCK 0x0010
LEDGER_ACTION_CALLBACK 0x0020
LEDGER_ACTION_MASK 0x00f0
LEDGER_WARNING_ROSE_ABOVE 1
LEDGER_WARNING_DIPPED_BELOW 2
LEDGER_WARNING_DIAG_MEM_THRESHOLD 3
LEDGER_CREATE_ACTIVE_ENTRIES 0
LEDGER_CREATE_INACTIVE_ENTRIES 1
_KERN_LOCK_H_ None
LOCK_PRIVATE 1
LCK_MTX_SLEEP_CODE 0
LCK_MTX_SLEEP_DEADLINE_CODE 1
LCK_MTX_LCK_WAIT_CODE 2
LCK_MTX_UNLCK_WAKEUP_CODE 3
NOINLINE __attribute__((noinline))
ordered_load_hw(lock) os_atomic_load(&(lock)->lock_data, compiler_acq_rel)
ordered_store_hw(lock, value)  os_atomic_store(&(lock)->lock_data, (value), compiler_acq_rel)
GATE_TYPE 3
GATE_ILOCK_BIT 0
GATE_WAITERS_BIT 1
gate_ilock(gate) hw_lock_bit((hw_lock_bit_t*)(&(gate)->gt_data), GATE_ILOCK_BIT, LCK_GRP_NULL)
gate_iunlock(gate) hw_unlock_bit((hw_lock_bit_t*)(&(gate)->gt_data), GATE_ILOCK_BIT)
ordered_load_gate(gate) os_atomic_load(&(gate)->gt_data, compiler_acq_rel)
ordered_store_gate(gate, value)  os_atomic_store(&(gate)->gt_data, value, compiler_acq_rel)
GATE_DESTROYED GATE_STATE_MASKED(0xdeadbeefdeadbeef)
_KERN_LOCKS_H_ None
decl_lck_spin_data(class, name)     class lck_spin_t name
SWI_COND_OWNER_BITS 20
decl_lck_rw_gate_data(class, name)                              class gate_t name
decl_lck_mtx_gate_data(class, name)                             class gate_t name
LCK_ASSERT_OWNED 1
LCK_ASSERT_NOTOWNED 2
LCK_ATTR_DECLARE(var, set_flags, clear_flags) 	SECURITY_READ_ONLY_LATE(lck_attr_t) var; 	static __startup_data struct lck_attr_startup_spec 	__startup_lck_attr_spec_ ## var = { &var, set_flags, clear_flags }; 	STARTUP_ARG(LOCKS, STARTUP_RANK_SECOND, lck_attr_startup_init, 	    &__startup_lck_attr_spec_ ## var)
LCK_SPIN_DECLARE_ATTR(var, grp, attr) 	lck_spin_t var; 	static __startup_data struct lck_spin_startup_spec 	__startup_lck_spin_spec_ ## var = { &var, grp, attr }; 	STARTUP_ARG(LOCKS, STARTUP_RANK_FOURTH, lck_spin_startup_init, 	    &__startup_lck_spin_spec_ ## var)
LCK_SPIN_DECLARE(var, grp) 	LCK_SPIN_DECLARE_ATTR(var, grp, LCK_ATTR_NULL)
LCK_TICKET_DECLARE(var, grp) 	lck_ticket_t var; 	static __startup_data struct lck_ticket_startup_spec 	__startup_lck_ticket_spec_ ## var = { &var, grp }; 	STARTUP_ARG(LOCKS, STARTUP_RANK_FOURTH, lck_ticket_startup_init, 	    &__startup_lck_ticket_spec_ ## var)
_KERN_LOCKS_INTERNAL_H_ None
LOCK_PRIVATE 1
hw_spin_wait_until_n(count, ptr, load_var, cond_expr)  ({ 	typeof((cond_expr)) __cond_result;                                                                                                                      	for (uint32_t __cond_init = (count), __cond_count = __cond_init;        	    __probable(__cond_count-- > 0);) {                                  	        __hw_spin_wait_load(ptr, load_var, __cond_result, cond_expr);   	        if (__probable(__cond_result)) {                                	                break;                                                  	        }                                                               	}                                                                                                                                                       	__cond_result;                                                          })
hw_spin_wait_until(ptr, load_var, cond_expr) 	hw_spin_wait_until_n(LOCK_SNOOP_SPINS, ptr, load_var, cond_expr)
lock_cmpxchg(p, e, v, m)  ({ 	__auto_type _p = (p);                                          	__auto_type _e = (e);                                          	lck_pretest(_p, _e) && os_atomic_cmpxchg(_p, _e, v, m);        })
lock_cmpxchgv(p, e, v, g, m)  ({ 	__auto_type _p = (p);                                           	__auto_type _e = (e);                                           	lck_pretestv(_p, _e, g) && os_atomic_cmpxchgv(_p, _e, v, g, m); })
LCK_MCS_ID_CPU_MASK 0x3fff
LCK_MCS_ID_SLOT_SHIFT 14
LCK_MCS_ID_SLOT_MASK 0xc000
LCK_MCS_SLOT_0 0
LCK_MCS_SLOT_1 1
_KERN_LOCK_ATTR_H_ None
LCK_ATTR_NONE 0
LCK_ATTR_DEBUG 0x00000001
LCK_ATTR_RW_SHARED_PRIORITY 0x00010000
LOCK_PRIVATE 1
_KERN_LOCK_GROUP_H None
LCK_GRP_MAX_NAME 64
LCK_GRP_DECLARE_ATTR(var, name, flags) 	__PLACE_IN_SECTION("__DATA,__lock_grp") lck_grp_t var; 	static __startup_data struct lck_grp_spec 	__startup_lck_grp_spec_ ## var = { &var, name, flags }; 	STARTUP_ARG(LOCKS, STARTUP_RANK_SECOND, lck_grp_startup_init, 	    &__startup_lck_grp_spec_ ## var)
LCK_GRP_DECLARE(var, name) 	LCK_GRP_DECLARE_ATTR(var, name, LCK_GRP_ATTR_NONE);
LCK_GRP_ASSERT_ID(...) MACH_ASSERT_DO(lck_grp_assert_id(__VA_ARGS__))
LOCK_PRIVATE 1
MAX_COLLISION_COUNTS 32
MAX_COLLISION 8
_KERN_LOCK_MTX_H_ None
decl_lck_mtx_data(class, name)     class lck_mtx_t name
LCK_MTX_ASSERT_OWNED LCK_ASSERT_OWNED
LCK_MTX_ASSERT_NOTOWNED LCK_ASSERT_NOTOWNED
lck_mtx_unlock_always(l) lck_mtx_unlock(l)
LCK_MTX_DECLARE_ATTR(var, grp, attr) 	lck_mtx_t var; 	static __startup_data struct lck_mtx_startup_spec 	__startup_lck_mtx_spec_ ## var = { &var, grp, attr }; 	STARTUP_ARG(LOCKS, STARTUP_RANK_FOURTH, lck_mtx_startup_init, 	    &__startup_lck_mtx_spec_ ## var)
LCK_MTX_DECLARE(var, grp) 	LCK_MTX_DECLARE_ATTR(var, grp, LCK_ATTR_NULL)
LOCK_PRIVATE 1
_KERN_LOCK_PTR_H_ None
LOCK_PRIVATE 1
DTRACE_RW_SHARED 0x0
DTRACE_RW_EXCL 0x1
DTRACE_NO_FLAG 0x0
LCK_RW_LCK_EXCLUSIVE_CODE 0x100
LCK_RW_LCK_EXCLUSIVE1_CODE 0x101
LCK_RW_LCK_SHARED_CODE 0x102
LCK_RW_LCK_SH_TO_EX_CODE 0x103
LCK_RW_LCK_SH_TO_EX1_CODE 0x104
LCK_RW_LCK_EX_TO_SH_CODE 0x105
lck_rw_ilk_lock(lock) hw_lock_bit  ((hw_lock_bit_t*)(&(lock)->lck_rw_tag), LCK_RW_INTERLOCK_BIT, LCK_GRP_NULL)
lck_rw_ilk_unlock(lock) hw_unlock_bit((hw_lock_bit_t*)(&(lock)->lck_rw_tag), LCK_RW_INTERLOCK_BIT)
ordered_load_rw(lock) os_atomic_load(&(lock)->lck_rw_data, compiler_acq_rel)
ordered_store_rw(lock, value)           os_atomic_store(&(lock)->lck_rw_data, (value), compiler_acq_rel)
ordered_store_rw_owner(lock, value)     os_atomic_store(&(lock)->lck_rw_owner, (value), compiler_acq_rel)
LCK_RW_GRAB_WANT 0
LCK_RW_GRAB_SHARED 1
_KERN_RW_LOCK_H_ None
lck_rw_shared_count lck_rw.shared_count
lck_rw_interlock lck_rw.interlock
lck_rw_priv_excl lck_rw.priv_excl
lck_rw_want_upgrade lck_rw.want_upgrade
lck_rw_want_excl lck_rw.want_excl
lck_r_waiting lck_rw.r_waiting
lck_w_waiting lck_rw.w_waiting
lck_rw_can_sleep lck_rw.can_sleep
lck_rw_data lck_rw.data
lck_rw_tag_valid lck_rw.tag_valid
lck_rw_tag lck_rw.data
LCK_RW_SHARED_READER_OFFSET 0
LCK_RW_INTERLOCK_BIT 16
LCK_RW_PRIV_EXCL_BIT 17
LCK_RW_WANT_UPGRADE_BIT 18
LCK_RW_WANT_EXCL_BIT 19
LCK_RW_R_WAITING_BIT 20
LCK_RW_W_WAITING_BIT 21
LCK_RW_CAN_SLEEP_BIT 22
LCK_RW_TAG_VALID_BIT 31
LCK_RW_TYPE_SHARED 0x01
LCK_RW_TYPE_EXCLUSIVE 0x02
decl_lck_rw_data(class, name)   class lck_rw_t name
LCK_RW_DECLARE_ATTR(var, grp, attr) 	lck_rw_t var; 	static __startup_data struct lck_rw_startup_spec 	__startup_lck_rw_spec_ ## var = { &var, grp, attr }; 	STARTUP_ARG(LOCKS, STARTUP_RANK_FOURTH, lck_rw_startup_init, 	    &__startup_lck_rw_spec_ ## var)
LCK_RW_DECLARE(var, grp) 	LCK_RW_DECLARE_ATTR(var, grp, LCK_ATTR_NULL)
LCK_RW_ASSERT_SHARED 0x01
LCK_RW_ASSERT_EXCLUSIVE 0x02
LCK_RW_ASSERT_HELD 0x03
LCK_RW_ASSERT_NOTHELD 0x04
_KERN_LOCK_SLEEP_H_ None
_KERN_LOCKSTAT_H None
LOCKSTAT_RECORD_(probe, lp, arg0, arg1, arg2, arg3, ...) 	lockstat_probe(probe, lp, arg0, arg1, arg2, arg3)
LOCKSTAT_RECORD__(probe, lp, arg0, arg1, arg2, arg3, ...) 	LOCKSTAT_RECORD_(probe, lp, arg0, arg1, arg2, arg3)
LOCKSTAT_RECORD(probe, lp, ...) 	LOCKSTAT_RECORD__(probe, lp, ##__VA_ARGS__, 0, 0, 0, 0)
LCK_MTX_LOCK_FIRST_MISS_ONLY 0
LCK_MTX_ACQUIRED(mtx, grp, spin, profile) 	lck_mtx_prof_probe(lck_mtx_acquire_probe(spin, false), mtx, grp, profile)
LCK_MTX_TRY_ACQUIRED(mtx, grp, spin, profile) 	lck_mtx_prof_probe(lck_mtx_acquire_probe(spin, true), mtx, grp, profile)
LCK_MTX_RELEASED(mtx, grp, profile) 	lck_mtx_prof_probe(LS_LCK_MTX_UNLOCK_RELEASE, mtx, grp, profile)
LCK_MTX_BLOCK_BEGIN() lck_mtx_time_stat_begin(LS_LCK_MTX_LOCK_BLOCK)
LCK_MTX_BLOCK_END(mtx, grp, start) 	lck_mtx_time_stat_record(LS_LCK_MTX_LOCK_BLOCK, mtx, grp, start)
LCK_MTX_ADAPTIVE_SPIN_BEGIN() lck_mtx_time_stat_begin(LS_LCK_MTX_LOCK_ADAPTIVE_SPIN)
LCK_MTX_ADAPTIVE_SPIN_END(mtx, grp, start) 	lck_mtx_time_stat_record(LS_LCK_MTX_LOCK_ADAPTIVE_SPIN, mtx, grp, start)
LCK_MTX_SPIN_SPIN_BEGIN() lck_mtx_time_stat_begin(LS_LCK_MTX_LOCK_SPIN_SPIN)
LCK_MTX_SPIN_SPIN_END(mtx, grp, start) 	lck_mtx_time_stat_record(LS_LCK_MTX_LOCK_SPIN_SPIN, mtx, grp, start)
LOCK_PRIVATE 1
TICKET_LOCK_PANIC_TIMEOUT TLockTimeOut
_KERN_LOCK_TYPES_H None
LCK_SLEEP_MASK 0x3f
HW_SPIN_TIMEOUT_FMT "timeout after %llu ticks"
HW_SPIN_TIMEOUT_ARG(to, st) 	((st).hwss_now - (st).hwss_start)
HW_SPIN_TIMEOUT_DETAILS_FMT "start time: %llu, now: %llu, timeout: %llu" 	HW_SPIN_TIMEOUT_SCHED_HYGIENE_FMT
HW_SPIN_TIMEOUT_DETAILS_ARG(to, st) 	(st).hwss_start, (st).hwss_now, (to).hwst_timeout 	HW_SPIN_TIMEOUT_SCHED_HYGIENE_ARG(to, st)
_KERN_MACHINE_H_ None
_KERN_MACH_FILTER_H_ None
MACH_MSG_FILTER_CALLBACKS_CURRENT MACH_MSG_FILTER_CALLBACKS_VERSION_1
_KERN_MACH_NODE_H_ None
_KERN_MACH_NODE_LINK_H_ None
_KERN_MACH_PARAM_H_ None
THREAD_CHUNK 64
TASK_CHUNK 64
_KERN_MACRO_HELP_H_ None
MACRO_BEGIN do {
MACRO_END } while (NEVER)
MACRO_RETURN if (ALWAYS) return
_MISC_PROTOS_H_ None
MIN(a, b) (((a)<(b))?(a):(b))
MAX(a, b) (((a)>(b))?(a):(b))
KERN_MONOTONIC_H None
_KERN_MPQUEUE_H None
mpqueue_init(q, lck_grp, lck_attr)              MACRO_BEGIN                                             	queue_init(&(q)->head);                         	lck_ticket_init(&(q)->lock_data, lck_grp);      	priority_queue_init(&(q)->mpq_pqhead);          MACRO_END
mpenqueue_tail(q, elt)                          MACRO_BEGIN                                             	lck_ticket_lock(&(q)->lock_data, LCK_GRP_NULL); 	enqueue_tail(&(q)->head, elt);                  	lck_ticket_unlock(&(q)->lock_data);             MACRO_END
mpdequeue_head(q, elt)                          MACRO_BEGIN                                             	lck_ticket_lock(&(q)->lock_data, LCK_GRP_NULL); 	if (queue_empty(&(q)->head))                    	        *(elt) = 0;                             	else                                            	        *(elt) = dequeue_head(&(q)->head);      	lck_ticket_unlock(&(q)->lock_data);             MACRO_END
_KERN_MPSC_QUEUE_H_ None
MPSC_QUEUE_INITIALIZER(head) { .mpqh_tail = &(head).mpqh_head }
mpsc_queue_element(ptr, type, field) __container_of(ptr, type, field)
mpsc_queue_batch_foreach_safe(item, head, tail) 	for (mpsc_queue_chain_t __tmp, __item = (head), __tail = (tail); 	    __tmp = mpsc_queue_batch_next(__item, __tail), (item) = __item; 	    __item = __tmp)
KERN_MPSC_RING_H None
_KERN_PAGE_DECRYPT_H None
panic(ex, ...)  ({ 	__asm__("" ::: "memory"); 	(panic)(ex " @%s:%d", ## __VA_ARGS__, __FILE_NAME__, __LINE__); })
panic_plain(ex, ...)  (panic)(ex, ## __VA_ARGS__)
_KERN_PERCPU_H_ None
PERCPU_DECL(type_t, name) 	extern type_t __PERCPU_NAME(name)
PERCPU_DATA(name) __percpu __PERCPU_NAME(name) = {0}
PERCPU_DATA_HACK_78750602(name) __percpu __PERCPU_NAME(name) = 0
PERCPU_GET(name) __PERCPU_CAST(name, current_percpu_base() + __PERCPU_ADDR(name))
PERCPU_GET_WITH_BASE(base, name) 	__PERCPU_CAST(name, (vm_address_t)base + __PERCPU_ADDR(name))
PERCPU_GET_RELATIVE(name, other, ptr) ({ 	__PERCPU_TYPE(other) __other_ptr = (ptr);  	vm_offset_t __offs = __PERCPU_ADDR(name) - __PERCPU_ADDR(other); 	__PERCPU_CAST(name, (vm_address_t)__other_ptr + __offs); })
percpu_foreach_base(it) for (vm_offset_t it = 0, 	    __next_ ## it = percpu_base.start, 	    __end_ ## it = percpu_base.end;         	    it <= __end_ ## it;         	    it = __next_ ## it, 	    __next_ ## it += percpu_section_size())
percpu_foreach(it, name) 	for (__PERCPU_TYPE(name) it, 	    __unsafe_indexable __base_ ## it = NULL, 	    __unsafe_indexable __next_ ## it = __PERCPU_CAST(name, percpu_base.start), 	    __unsafe_indexable __end_ ## it = __PERCPU_CAST(name, percpu_base.end);         	    (it = __PERCPU_CAST(name, __PERCPU_ADDR(name) + (vm_address_t)__base_ ## it), 	    __base_ ## it <= __end_ ## it);         	    __base_ ## it = __next_ ## it, 	    __next_ ## it = __PERCPU_CAST(name, (vm_address_t)__base_ ## it + percpu_section_size()))
percpu_foreach_secondary_base(it) for (vm_offset_t it = percpu_base.start, __end_ ## it = percpu_base.end; 	    it <= __end_ ## it; it += percpu_section_size())
percpu_foreach_secondary(it, name) 	for (__PERCPU_TYPE(name) it, 	    __unsafe_indexable __base_ ## it = __PERCPU_CAST(name, percpu_base.start), 	    __unsafe_indexable __end_ ## it = __PERCPU_CAST(name, percpu_base.end);         	    (it = __PERCPU_CAST(name, __PERCPU_ADDR(name) + (vm_address_t)__base_ ## it), 	    __base_ ## it <= __end_ ## it);         	    __base_ ## it = __PERCPU_CAST(name, (vm_address_t)__base_ ## it + percpu_section_size()))
__percpu __attribute__((section("__DATA, __percpu")))
__PERCPU_NAME(name) percpu_slot_ ## name
__PERCPU_TYPE(name) typeof(&__PERCPU_NAME(name))
__PERCPU_CAST(name, expr)       __unsafe_forge_bidi_indexable(__PERCPU_TYPE(name), (vm_address_t)(expr), sizeof(__PERCPU_NAME(name)))
_KERN_PMS_H_ None
pmsMaxStates 64
HalfwayToForever 0x7FFFFFFFFFFFFFFFULL
century 790560000000000ULL
pmsCngXClk 0x80000000
pmsXUnk 0x7F
pmsXClk 0x7F000000
pmsCngCPU 0x00800000
pmsSync 0x00400000
pmsMustCmp 0x00200000
pmsCPU 0x001F0000
pmsCPUUnk 0x1F
pmsCngVolt 0x00008000
pmsVoltage 0x00007F00
pmsVoltUnk 0x7F
pmsPowerID 0x000000FF
pmsDelay 0xFFFFFFFD
pmsParkIt 0xFFFFFFFF
pmsSetFuncMax 32
_KERN_POLICY_INTERNAL_H_ None
TASK_POLICY_DISABLE 0x0
TASK_POLICY_ENABLE 0x1
TASK_POLICY_INTERNAL 0x0
TASK_POLICY_EXTERNAL 0x1
TASK_POLICY_ATTRIBUTE 0x2
TASK_POLICY_TASK 0x4
TASK_POLICY_THREAD 0x8
TASK_POLICY_COALITION 0x10
TASK_POLICY_DARWIN_BG IMP_TASK_POLICY_DARWIN_BG
TASK_POLICY_IOPOL IMP_TASK_POLICY_IOPOL
TASK_POLICY_IO IMP_TASK_POLICY_IO
TASK_POLICY_PASSIVE_IO IMP_TASK_POLICY_PASSIVE_IO
TASK_POLICY_DARWIN_BG_IOPOL IMP_TASK_POLICY_DARWIN_BG_IOPOL
TASK_POLICY_BOOST IMP_TASK_POLICY_BOOST
TASK_POLICY_ROLE IMP_TASK_POLICY_ROLE
TASK_POLICY_TERMINATED IMP_TASK_POLICY_TERMINATED
TASK_POLICY_NEW_SOCKETS_BG IMP_TASK_POLICY_NEW_SOCKETS_BG
TASK_POLICY_SUP_ACTIVE IMP_TASK_POLICY_SUP_ACTIVE
TASK_POLICY_LATENCY_QOS IMP_TASK_POLICY_LATENCY_QOS
TASK_POLICY_THROUGH_QOS IMP_TASK_POLICY_THROUGH_QOS
TASK_POLICY_WATCHERS_BG IMP_TASK_POLICY_WATCHERS_BG
TASK_POLICY_SFI_MANAGED IMP_TASK_POLICY_SFI_MANAGED
TASK_POLICY_ALL_SOCKETS_BG IMP_TASK_POLICY_ALL_SOCKETS_BG
TASK_POLICY_BASE_LATENCY_AND_THROUGHPUT_QOS IMP_TASK_POLICY_BASE_LATENCY_AND_THROUGHPUT_QOS
TASK_POLICY_OVERRIDE_LATENCY_AND_THROUGHPUT_QOS IMP_TASK_POLICY_OVERRIDE_LATENCY_AND_THROUGHPUT_QOS
TASK_POLICY_PIDBIND_BG IMP_TASK_POLICY_PIDBIND_BG
TASK_POLICY_QOS 0x35
TASK_POLICY_QOS_OVERRIDE IMP_TASK_POLICY_QOS_OVERRIDE
TASK_POLICY_QOS_AND_RELPRIO IMP_TASK_POLICY_QOS_AND_RELPRIO
TASK_POLICY_QOS_WORKQ_OVERRIDE IMP_TASK_POLICY_QOS_WORKQ_OVERRIDE
TASK_POLICY_QOS_PROMOTE IMP_TASK_POLICY_QOS_PROMOTE
TASK_POLICY_QOS_KEVENT_OVERRIDE IMP_TASK_POLICY_QOS_KEVENT_OVERRIDE
TASK_POLICY_QOS_SERVICER_OVERRIDE IMP_TASK_POLICY_QOS_SERVICER_OVERRIDE
TASK_POLICY_IOTIER_KEVENT_OVERRIDE IMP_TASK_POLICY_IOTIER_KEVENT_OVERRIDE
TASK_POLICY_WI_DRIVEN IMP_TASK_POLICY_WI_DRIVEN
TASK_POLICY_MAX 0x41
THROTTLE_LEVEL_NONE -1
THROTTLE_LEVEL_TIER0 0
THROTTLE_LEVEL_THROTTLED 1
THROTTLE_LEVEL_TIER1 1
THROTTLE_LEVEL_TIER2 2
THROTTLE_LEVEL_TIER3 3
THROTTLE_LEVEL_START 0
THROTTLE_LEVEL_END 3
THROTTLE_LEVEL_COMPRESSOR_TIER0 THROTTLE_LEVEL_TIER0
THROTTLE_LEVEL_COMPRESSOR_TIER1 THROTTLE_LEVEL_TIER1
THROTTLE_LEVEL_COMPRESSOR_TIER2 THROTTLE_LEVEL_TIER2
THROTTLE_LEVEL_PAGEOUT_THROTTLED THROTTLE_LEVEL_TIER2
THROTTLE_LEVEL_PAGEOUT_UNTHROTTLED THROTTLE_LEVEL_TIER1
TASK_POLICY_RESOURCE_ATTRIBUTE_NONE 0x00
TASK_POLICY_RESOURCE_ATTRIBUTE_THROTTLE 0x01
TASK_POLICY_RESOURCE_ATTRIBUTE_SUSPEND 0x02
TASK_POLICY_RESOURCE_ATTRIBUTE_TERMINATE 0x03
TASK_POLICY_RESOURCE_ATTRIBUTE_NOTIFY_KQ 0x04
TASK_POLICY_RESOURCE_ATTRIBUTE_NOTIFY_EXC 0x05
TASK_POLICY_RESOURCE_ATTRIBUTE_DEFAULT TASK_POLICY_RESOURCE_ATTRIBUTE_NONE
TASK_RUSECPU_FLAGS_PROC_LIMIT 0x01
TASK_RUSECPU_FLAGS_PERTHR_LIMIT 0x02
TASK_RUSECPU_FLAGS_DEADLINE 0x04
TASK_RUSECPU_FLAGS_FATAL_CPUMON 0x08
TASK_RUSECPU_FLAGS_FATAL_WAKEUPSMON 0x10
_KERN_PRIORITY_QUEUE_H_ None
PRIORITY_QUEUE_KEY_NONE 0
priority_heap_compare_ints(a, b) ((a) < (b) ? 1 : -1)
priority_heap_make_comparator(name1, name2, type, field, ...) 	(^int(priority_queue_entry_t __e1, priority_queue_entry_t __e2){        	    type *name1 = pqe_element_fast(__e1, type, field);                  	    type *name2 = pqe_element_fast(__e2, type, field);                  	    __VA_ARGS__;                                                        	})
PRIORITY_QUEUE_INITIALIZER { .pq_root = NULL }
__pqueue_overloadable __attribute__((overloadable))
priority_queue_is_min_heap(pq) _Generic(pq, 	struct priority_queue_min *: true, 	struct priority_queue_max *: false, 	struct priority_queue_deadline_min *: true, 	struct priority_queue_deadline_max *: false, 	struct priority_queue_sched_min *: true, 	struct priority_queue_sched_max *: false, 	struct priority_queue_sched_stable_min *: true, 	struct priority_queue_sched_stable_max *: false)
pqe_element_fast(qe, type, field)  __container_of(qe, type, field)
pqe_element(qe, type, field)  ({                                        	__auto_type _tmp_entry = (qe);                                          	_tmp_entry ? pqe_element_fast(_tmp_entry, type, field) : ((type *)NULL);})
priority_queue_entry_init(qe) __builtin_bzero(qe, sizeof(*(qe)))
priority_queue_destroy(pq, type, field, callback)                       MACRO_BEGIN                                                                     	void (^__callback)(type *) = (callback);                	_priority_queue_destroy(pq, offsetof(type, field),                      	    (void (^)(void *))(__callback));                                    MACRO_END
priority_queue_min(pq, type, field) ({                                  	static_assert(priority_queue_is_min_heap(pq), "queue is min heap");     	pqe_element((pq)->pq_root, type, field);                                })
priority_queue_max(pq, type, field) ({                                  	static_assert(priority_queue_is_max_heap(pq), "queue is max heap");     	pqe_element((pq)->pq_root, type, field);                                })
priority_queue_remove_min(pq, type, field) ({                           	static_assert(priority_queue_is_min_heap(pq), "queue is min heap");     	pqe_element(_priority_queue_remove_root(pq), type, field);              })
priority_queue_remove_max(pq, type, field) ({                           	static_assert(priority_queue_is_max_heap(pq), "queue is max heap");     	pqe_element(_priority_queue_remove_root(pq), type, field);              })
priority_queue_is_sched_heap(pq) _Generic(pq, 	struct priority_queue_sched_min *: true, 	struct priority_queue_sched_max *: true, 	struct priority_queue_sched_stable_min *: true, 	struct priority_queue_sched_stable_max *: true, 	default: false)
priority_queue_entry_set_sched_pri(pq, elt, pri, modifier)              MACRO_BEGIN                                                                     	static_assert(priority_queue_is_sched_heap(pq), "is a sched heap");     	(elt)->key = (priority_queue_key_t)(((pri) << 8) + (modifier));         MACRO_END
priority_queue_entry_sched_pri(pq, elt) ({                              	static_assert(priority_queue_is_sched_heap(pq), "is a sched heap");     	(priority_queue_key_t)((elt)->key >> 8);                                })
priority_queue_entry_sched_modifier(pq, elt) ({                         	static_assert(priority_queue_is_sched_heap(pq), "is a sched heap");     	(priority_queue_entry_sched_modifier_t)(elt)->key;                      })
PRIORITY_QUEUE_MAKE_BASE(pqueue_t, pqelem_t)                                                                                 __pqueue_overloadable extern void                                               _priority_queue_destroy(pqueue_t pq, uintptr_t offset, void (^cb)(void *));                                                                                     __pqueue_overloadable extern bool                                               priority_queue_insert(pqueue_t que, pqelem_t elt);                                                                                                              __pqueue_overloadable extern pqelem_t                                           _priority_queue_remove_root(pqueue_t que);                                                                                                                      __pqueue_overloadable extern bool                                               priority_queue_remove(pqueue_t que, pqelem_t elt);                                                                                                              __pqueue_overloadable extern bool                                               priority_queue_entry_decreased(pqueue_t que, pqelem_t elt);                                                                                                     __pqueue_overloadable extern bool                                               priority_queue_entry_increased(pqueue_t que, pqelem_t elt)
PRIORITY_QUEUE_MAKE(pqueue_t, pqelem_t) __pqueue_overloadable                                                           static inline void                                                              priority_queue_init(pqueue_t que)                                               {                                                                               	__builtin_bzero(que, sizeof(*que));                                     }                                                                                                                                                               PRIORITY_QUEUE_MAKE_BASE(pqueue_t, pqelem_t)
PRIORITY_QUEUE_MAKE_CB(pqueue_t, pqelem_t) __pqueue_overloadable                                                           static inline void                                                              priority_queue_init(pqueue_t pq, priority_queue_compare_fn_t cmp_fn)            {                                                                               	pq->pq_root = NULL;                                                     	pq->pq_cmp_fn = cmp_fn;                                                 }                                                                                                                                                               PRIORITY_QUEUE_MAKE_BASE(pqueue_t, pqelem_t)
_KERN_PROCESSOR_H_ None
MAX_SCHED_CPUS 64
PSET_THING_TASK 0
PSET_THING_THREAD 1
PSET_LOAD_NUMERATOR_SHIFT 16
PSET_LOAD_FRACTIONAL_SHIFT 4
_KERN_QUEUE_H_ None
__queue_element_linkage_invalid(e) ml_fatal_trap_invalid_list_linkage((unsigned long)(e))
qe_element(qe, type, field) __container_of(qe, type, field)
qe_foreach(qe, head) 	for (qe = (head)->next; qe != (head); qe = (qe)->next)
qe_foreach_safe(qe, head) 	for (queue_entry_t _ne = ((head)->next)->next, 	         __ ## qe ## _unused_shadow __unused = (qe = (head)->next); 	     qe != (head); 	     qe = _ne, _ne = (qe)->next)
qe_foreach_element(elt, head, field) 	for (elt = qe_element((head)->next, typeof(*(elt)), field); 	     &((elt)->field) != (head); 	     elt = qe_element((elt)->field.next, typeof(*(elt)), field))
qe_foreach_element_safe(elt, head, field) 	for (typeof(*(elt)) *_nelt = qe_element(((head)->next)->next, typeof(*(elt)), field), 	     *__ ## elt ## _unused_shadow __unused = 	         (elt = qe_element((head)->next, typeof(*(elt)), field)); 	     &((elt)->field) != (head); 	     elt = _nelt, _nelt = qe_element((elt)->field.next, typeof(*(elt)), field))
qe_dequeue_head(head, type, field) ({ 	queue_entry_t _tmp_entry = dequeue_head((head)); 	type *_tmp_element = (type*) NULL; 	if (_tmp_entry != (queue_entry_t) NULL) 	        _tmp_element = qe_element(_tmp_entry, type, field); 	_tmp_element; })
qe_dequeue_tail(head, type, field) ({ 	queue_entry_t _tmp_entry = dequeue_tail((head)); 	type *_tmp_element = (type*) NULL; 	if (_tmp_entry != (queue_entry_t) NULL) 	        _tmp_element = qe_element(_tmp_entry, type, field); 	_tmp_element; })
qe_queue_first(head, type, field) ({ 	queue_entry_t _tmp_entry = queue_first((head)); 	type *_tmp_element = (type*) NULL; 	if (_tmp_entry != (queue_entry_t) head) 	        _tmp_element = qe_element(_tmp_entry, type, field); 	_tmp_element; })
qe_queue_last(head, type, field) ({ 	queue_entry_t _tmp_entry = queue_last((head)); 	type *_tmp_element = (type*) NULL; 	if (_tmp_entry != (queue_entry_t) head) 	        _tmp_element = qe_element(_tmp_entry, type, field); 	_tmp_element; })
qe_queue_next(head, element, type, field) ({ 	queue_entry_t _tmp_entry = queue_next(&(element)->field); 	type *_tmp_element = (type*) NULL; 	if (_tmp_entry != (queue_entry_t) head) 	        _tmp_element = qe_element(_tmp_entry, type, field); 	_tmp_element; })
qe_queue_prev(head, element, type, field) ({ 	queue_entry_t _tmp_entry = queue_prev(&(element)->field); 	type *_tmp_element = (type*) NULL; 	if (_tmp_entry != (queue_entry_t) head) 	        _tmp_element = qe_element(_tmp_entry, type, field); 	_tmp_element; })
QUEUE_HEAD_INITIALIZER(name) { &name, &name }
queue_init(q) MACRO_BEGIN             	(q)->next = (q);	(q)->prev = (q);MACRO_END
queue_head_init(q) queue_init(&(q))
queue_chain_init(q) queue_init(&(q))
queue_end(q, qe)        ((q) == (qe))
queue_empty(q) queue_end((q), queue_first(q))
__QUEUE2_CHECK_NEXT(__fail, __elt, __prev, __head, type, field)         MACRO_BEGIN                                                                     	if (__prev == __head) {                                                 	        __fail |= __head->next != (queue_entry_t)__elt;                 	} else {                                                                	        __fail |= ((type)(void *)__prev)->field.next !=                 	            (queue_entry_t)__elt;                                       	}                                                                       MACRO_END
__QUEUE2_CHECK_PREV(__fail, __elt, __next, __head, type, field)         MACRO_BEGIN                                                                     	if (__next == __head) {                                                 	        __fail |= __head->prev != (queue_entry_t)__elt;                 	} else {                                                                	        __fail |= ((type)(void *)__next)->field.prev !=                 	            (queue_entry_t)__elt;                                       	}                                                                       MACRO_END
__QUEUE2_CHECK_FAIL(__fail, __elt)                                      MACRO_BEGIN                                                                     	if (__improbable(__fail)) {                                             	        __queue_element_linkage_invalid(__elt);                         	}                                                                       MACRO_END
__QUEUE2_SET_NEXT(__prev, __elt, __head, type, field)                   MACRO_BEGIN                                                                     	if (__head == __prev) {                                                 	        __head->next = (queue_entry_t)__elt;                            	} else {                                                                	        ((type)(void *)__prev)->field.next = (queue_entry_t)__elt;      	}                                                                       MACRO_END
__QUEUE2_SET_PREV(__next, __elt, __head, type, field)                   MACRO_BEGIN                                                                     	if (__head == __next) {                                                 	        __head->prev = (queue_entry_t)__elt;                            	} else {                                                                	        ((type)(void *)__next)->field.prev = (queue_entry_t)__elt;      	}                                                                       MACRO_END
queue_enter(head, elt, type, field)                                     MACRO_BEGIN                                                                     	queue_entry_t __head, __prev;                                           	type __elt;                                                             	int __fail = 0;                                                                                                                                         	__elt  = (elt);                                                         	__head = (head);                                                        	__prev = __head->prev;                                                                                                                                  	__QUEUE2_CHECK_NEXT(__fail, __head, __prev, __head, type, field);       	__QUEUE2_CHECK_FAIL(__fail, __head);                                                                                                                    	__elt->field.prev = __prev;                                             	__elt->field.next = __head;                                             	__compiler_barrier();                                                   	__QUEUE2_SET_NEXT(__prev, __elt, __head, type, field);                  	__head->prev = (queue_entry_t)__elt;                                    MACRO_END
queue_enter_first(head, elt, type, field)                               MACRO_BEGIN                                                                     	queue_entry_t __head, __next;                                           	type __elt;                                                             	int __fail = 0;                                                                                                                                         	__elt  = (elt);                                                         	__head = (head);                                                        	__next = __head->next;                                                                                                                                  	__QUEUE2_CHECK_PREV(__fail, __head, __next, __head, type, field);       	__QUEUE2_CHECK_FAIL(__fail, __head);                                                                                                                    	__elt->field.next = __next;                                             	__elt->field.prev = __head;                                             	__compiler_barrier();                                                   	__QUEUE2_SET_PREV(__next, __elt, __head, type, field);                  	__head->next = (queue_entry_t)__elt;                                    MACRO_END
queue_insert_before(head, elt, cur, type, field)                        MACRO_BEGIN                                                                     	queue_entry_t __head, __cur, __prev;                                    	type __elt;                                                             	int __fail = 0;                                                                                                                                         	__elt  = (elt);                                                         	__cur  = (queue_entry_t)(cur);                                          	__head = (head);                                                                                                                                        	if (__head == __cur) {                                                  	        __prev = __head->prev;                                          	} else {                                                                	        __prev = ((type)(void *)__cur)->field.prev;                     	}                                                                                                                                                       	__QUEUE2_CHECK_NEXT(__fail, __cur, __prev, __head, type, field);        	__QUEUE2_CHECK_FAIL(__fail, __head);                                                                                                                    	__elt->field.prev = __prev;                                             	__elt->field.next = __cur;                                              	__compiler_barrier();                                                   	__QUEUE2_SET_NEXT(__prev, __elt, __head, type, field);                  	__QUEUE2_SET_PREV(__cur, __elt, __head, type, field);                   MACRO_END
queue_insert_after(head, elt, cur, type, field)                         MACRO_BEGIN                                                                     	queue_entry_t __head, __cur, __next;                                    	type __elt;                                                             	int __fail = 0;                                                                                                                                         	__elt  = (elt);                                                         	__cur  = (queue_entry_t)(cur);                                          	__head = (head);                                                                                                                                        	if (__head == __cur) {                                                  	        __next = __head->next;                                          	} else {                                                                	        __next = ((type)(void *)__cur)->field.next;                     	}                                                                                                                                                       	__QUEUE2_CHECK_PREV(__fail, __cur, __next, __head, type, field);        	__QUEUE2_CHECK_FAIL(__fail, __head);                                                                                                                    	__elt->field.prev = __cur;                                              	__elt->field.next = __next;                                             	__compiler_barrier();                                                   	__QUEUE2_SET_NEXT(__cur, __elt, __head, type, field);                   	__QUEUE2_SET_PREV(__next, __elt, __head, type, field);                  MACRO_END
queue_field(head, thing, type, field)                   	        (((head) == (thing)) ? (head) : &((type)(void *)(thing))->field)
queue_remove(head, elt, type, field)                                    MACRO_BEGIN                                                                     	queue_entry_t __head, __next, __prev;                                   	type __elt;                                                             	int __fail = 0;                                                                                                                                         	__elt  = (elt);                                                         	__head = (head);                                                        	__next = __elt->field.next;                                             	__prev = __elt->field.prev;                                                                                                                             	__QUEUE2_CHECK_PREV(__fail, __elt, __next, __head, type, field);        	__QUEUE2_CHECK_NEXT(__fail, __elt, __prev, __head, type, field);        	__QUEUE2_CHECK_FAIL(__fail, __head);                                                                                                                    	__QUEUE2_SET_PREV(__next, __prev, __head, type, field);                 	__QUEUE2_SET_NEXT(__prev, __next, __head, type, field);                 	__compiler_barrier();                                                   	__elt->field.next = NULL;                                               	__elt->field.prev = NULL;                                               MACRO_END
queue_remove_first(head, entry, type, field)            MACRO_BEGIN                                                     	queue_entry_t __hd;                                     	type __entry;                                                                                                           	__hd    = (head);                                       	__entry = (type)(void *)__hd->next;                                                                                     	if ((queue_entry_t)__entry != __hd) {                   	        queue_remove(__hd, __entry, type, field);       	}                                                       	(entry) = __entry;                                      MACRO_END
queue_remove_last(head, entry, type, field)             MACRO_BEGIN                                                     	queue_entry_t __hd;                                     	type __entry;                                                                                                           	__hd    = (head);                                       	__entry = (type)(void *)__hd->prev;                                                                                     	if ((queue_entry_t)__entry != __hd) {                   	        queue_remove(__hd, __entry, type, field);       	}                                                       	(entry) = __entry;                                      MACRO_END
queue_assign(to, from, type, field)                     MACRO_BEGIN                                                     	((type)(void *)((from)->prev))->field.next = (to);      	((type)(void *)((from)->next))->field.prev = (to);      	*to = *from;                                            MACRO_END
queue_new_head(old, new, type, field)                   MACRO_BEGIN                                                     	if (!queue_empty(old)) {                                	        *(new) = *(old);                                	        ((type)(void *)((new)->next))->field.prev =     	                (new);                                  	        ((type)(void *)((new)->prev))->field.next =     	                (new);                                  	} else {                                                	        queue_init(new);                                	}                                                       MACRO_END
queue_iterate(head, elt, type, field)                   	for ((elt) = (type)(void *) queue_first(head);          	     !queue_end((head), (queue_entry_t)(elt));          	     (elt) = (type)(void *) queue_next(&(elt)->field))
PRECISE_USER_KERNEL_PMCS PRECISE_USER_KERNEL_TIME
MT_KDBG_IC_CPU_CSWITCH KDBG_EVENTID(DBG_MONOTONIC, DBG_MT_INSTRS_CYCLES, 1)
MT_KDBG_IC_CPU_CSWITCH_ON KDBG_EVENTID(DBG_MONOTONIC, DBG_MT_INSTRS_CYCLES_ON_CPU, 1)
KERN_RECOUNT_H None
RECOUNT_THREAD_BASED_LEVEL 1
RECOUNT_PLAN_DECLARE(_name) extern const struct recount_plan _name;
RECOUNT_PLAN_DEFINE(_name, _topo) 	const struct recount_plan _name = { 	        .rpl_name = #_name, 	        .rpl_topo = _topo, 	}
REMOTE_TIME_H None
RR_RANGES_MAX 64
rr_lock() lck_spin_lock_grp(&rr_spinlock, &rr_lock_grp)
rr_unlock() lck_spin_unlock(&rr_spinlock);
_KERN_RESTARTABLE_H_ None
TASK_RESTARTABLE_OFFSET_MAX 4096u
_KERN_SCHED_H_ None
MINPRI 0
IDLEPRI MINPRI
NOPRI -1
MINPRI_USER MINPRI
RT_CONSTRAINT_NONE UINT32_MAX
RT_DEADLINE_NONE UINT64_MAX
SCHED_DECAY_TICKS 32
sched_tick_delta(thread, delta) MACRO_BEGIN     uint64_t _total = recount_thread_time_mach(thread);     (delta) = (typeof(delta))(_total - thread->sched_time_save);     thread->sched_time_save = _total; MACRO_END
SCHED_MAX_BACKUP_PROCESSORS 7
_KERN_SCHED_AMP_COMMON_H_ None
SCHED_LOAD_EWMA_ALPHA_OLD 6
SCHED_LOAD_EWMA_ALPHA_NEW 10
SCHED_LOAD_EWMA_ALPHA_SHIFT 4
_KERN_SCHED_CLUTCH_H_ None
KERN_SCHED_HYGIENE_DEBUG None
DEFAULT_PREEMPTION_RATE 100
DEFAULT_BG_PREEMPTION_RATE 400
MAX_UNSAFE_FIXED_QUANTA 100
SAFE_FIXED_MULTIPLIER SAFE_RT_MULTIPLIER
MAX_POLL_QUANTA 2
SCHED_POLL_YIELD_SHIFT 4
cpumap_foreach(cpu_id, cpumap) 	for (int cpu_id = lsb_first(cpumap); 	    (cpu_id) >= 0; 	     cpu_id = lsb_next((cpumap), cpu_id))
foreach_node(node) for (pset_node_t node = &pset_node0; node != NULL; node = node->node_list)
foreach_pset_id(pset_id, node) 	for (int pset_id = lsb_first((node)->pset_map); 	    pset_id >= 0; 	    pset_id = lsb_next((node)->pset_map, pset_id))
CHOOSE_PROCESSOR_MAX_RETRIES 3
FAILSAFE_NAME_LEN 33
_KERN_SCHED_PRIM_H_ None
SCHED_STATS_INC(field) MACRO_BEGIN                                                                     	if (__improbable(sched_stats_active)) {                                 	        PERCPU_GET(sched_stats)->field++;                               	}                                                                       MACRO_END
SCHED_DEBUG_FLAG_PLATFORM_TRACEPOINTS 0x00000001
SCHED_DEBUG_FLAG_CHOOSE_PROCESSOR_TRACEPOINTS 0x00000002
SCHED_DEBUG_FLAG_AST_CHECK_TRACEPOINTS 0x00000004
SCHED_DEBUG_PLATFORM_KERNEL_DEBUG_CONSTANT(...) MACRO_BEGIN                                                                     	if (__improbable(sched_debug_flags &                                    	    SCHED_DEBUG_FLAG_PLATFORM_TRACEPOINTS)) {                           	        KERNEL_DEBUG_CONSTANT(__VA_ARGS__);                             	}                                                                       MACRO_END
SCHED_DEBUG_CHOOSE_PROCESSOR_KERNEL_DEBUG_CONSTANT_IST(...) MACRO_BEGIN                                                                     	if (__improbable(sched_debug_flags &                                    	    SCHED_DEBUG_FLAG_CHOOSE_PROCESSOR_TRACEPOINTS)) {                   	        KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE, __VA_ARGS__);           	}                                                                       MACRO_END
SCHED_DEBUG_AST_CHECK_KDBG_RELEASE(...) MACRO_BEGIN                                                                     	if (__improbable(sched_debug_flags &                                    	    SCHED_DEBUG_FLAG_AST_CHECK_TRACEPOINTS)) {                          	        KDBG_RELEASE(__VA_ARGS__);                                      	}                                                                       MACRO_END
QOS_PARALLELISM_COUNT_LOGICAL 0x1
QOS_PARALLELISM_REALTIME 0x2
QOS_PARALLELISM_CLUSTER_SHARED_RESOURCE 0x4
thread_wakeup(x) thread_wakeup_prim((x), FALSE, THREAD_AWAKENED)
thread_wakeup_with_result(x, z)         	                thread_wakeup_prim((x), FALSE, (z))
thread_wakeup_one(x) thread_wakeup_prim((x), TRUE, THREAD_AWAKENED)
thread_wakeup_nthreads(x, nthreads) 	                thread_wakeup_nthreads_prim((x), (nthreads), THREAD_AWAKENED)
thread_wakeup_nthreads_with_result(x, nthreads, z) 	                thread_wakeup_nthreads_prim((x), (nthreads), (z))
_KERN_SCHED_URGENCY_H_ None
_KERN_SFI_H_ None
_KERN_SIMPLE_LOCK_H_ None
SIMPLE_LOCK_DECLARE(var, arg) 	decl_simple_lock_data(, var); 	static __startup_data struct usimple_lock_startup_spec 	__startup_usimple_lock_spec_ ## var = { &var, arg }; 	STARTUP_ARG(LOCKS, STARTUP_RANK_FOURTH, usimple_lock_startup_init, 	    &__startup_usimple_lock_spec_ ## var)
hw_wait_while_equals_long(ptr, cur) ({ 	static_assert(sizeof(*(ptr)) == sizeof(long)); 	(typeof(cur))hw_wait_while_equals64(__DEVOLATILE(uint64_t *, ptr), (uint64_t)(cur)); })
hw_lock_bit_held(l, b) 	(((*(l)) & (1 << (b))) != 0)
_KERN_SMP_H_ None
CPU_CHECKIN_MIN_INTERVAL_US 5000
CPU_CHECKIN_MIN_INTERVAL_MAX_US USEC_PER_SEC
SMR_BARRIER_SIZE 24
_KERN_SMR_H_ None
smr_entered_load_assert(ptr, smr)  ({ 	assert(smr_entered(smr)); 	(ptr)->__smr_ptr; })
smr_entered_load_acquire(ptr) os_atomic_load(&(ptr)->__smr_ptr, acquire)
smr_entered_load_acquire_assert(ptr, smr)  ({ 	assert(smr_entered(smr)); 	os_atomic_load(&(ptr)->__smr_ptr, acquire); })
smr_serialized_load_assert(ptr, held_cond)  ({ 	assertf(held_cond, "smr_serialized_load: lock not held"); 	(ptr)->__smr_ptr; })
smr_serialized_load(ptr) smr_serialized_load_assert(ptr, true)
smr_init_store(ptr, value) 	({ (ptr)->__smr_ptr = value; })
smr_clear_store(ptr) smr_init_store(ptr, 0)
smr_serialized_store_assert(ptr, value, held_cond)  ({ 	assertf(held_cond, "smr_serialized_store: lock not held"); 	os_atomic_thread_fence(release); 	(ptr)->__smr_ptr = value; })
smr_serialized_store(ptr, value) 	smr_serialized_store_assert(ptr, value, true)
smr_serialized_store_relaxed_assert(ptr, value, held_cond)  ({ 	assertf(held_cond, "smr_serialized_store_relaxed: lock not held"); 	(ptr)->__smr_ptr = value; })
smr_serialized_store_relaxed(ptr, value) 	smr_serialized_store_relaxed_assert(ptr, value, true)
smr_serialized_swap_assert(ptr, value, held_cond)  ({ 	assertf(held_cond, "smr_serialized_store: lock not held"); 	os_atomic_xchg(&(ptr)->__smr_ptr, value, release); })
smr_serialized_swap(ptr, value) 	smr_serialized_swap_assert(ptr, value, true)
smr_unserialized_store(ptr, value) 	({ (ptr)->__smr_ptr = value; })
smrq_entered_first(head, type_t, field) 	__container_of_safe(smr_entered_load(&(head)->first), type_t, field)
smrq_entered_next(elem, field) 	__container_of_safe(smr_entered_load(&(elem)->field.next), 	    typeof(*(elem)), field)
smrq_entered_foreach(it, head, field) 	for (__auto_type __it = smr_entered_load(&(head)->first);               	    ((it) = __container_of_safe(__it, typeof(*(it)), field));           	    __it = smr_entered_load(&__it->next))
smrq_serialized_first(head, type_t, link) 	__container_of_safe(smr_serialized_load(&(head)->first), type_t, link)
smrq_serialized_next(elem, field) 	__container_of_safe(smr_serialized_load(&(elem)->field.next), 	    typeof(*(elem)), field)
smrq_serialized_foreach(it, head, field) 	for (__auto_type __it = smr_serialized_load(&(head)->first);            	    ((it) = __container_of_safe(__it, typeof(*(it)), field));           	    __it = smr_serialized_load(&__it->next))
smrq_serialized_foreach_safe(it, head, field) 	for (__auto_type __it = smr_serialized_load(&(head)->first),            	    __next_it = __it;                                                   	    ((it) = __container_of_safe(__it, typeof(*(it)), field)) &&         	    ((__next_it = smr_serialized_load(&__it->next)), 1);                	    __it = __next_it)
smrq_serialized_insert_head(head, elem)  ({ 	__auto_type __head = (head);                                                                                                                            	__smrq_serialized_insert(&__head->first, (elem),                        	   smr_serialized_load(&__head->first), __smrq_lastp(__head));          })
smrq_serialized_insert_tail(head, elem)  ({ 	__auto_type __head = (head);                                                                                                                            	__smrq_serialized_insert(__head->last, (elem),                          	   NULL, &__head->last);                                                })
smrq_serialized_insert_head_relaxed(head, elem)  ({ 	__auto_type __head = (head);                                                                                                                            	__smrq_serialized_insert_relaxed(&__head->first, (elem),                	   smr_serialized_load(&__head->first), __smrq_lastp(__head));          })
smrq_serialized_insert_tail_relaxed(head, elem)  ({ 	__auto_type __head = (head);                                                                                                                            	__smrq_serialized_insert_relaxed(__head->last, (elem),                  	   NULL, &__head->last);                                                })
smrq_serialized_remove(head, elem)  ({ 	__auto_type __head = (head);                                                                                                                            	__smrq_serialized_remove(&__head->first, (elem), __smrq_lastp(__head)); })
smrq_serialized_replace(head, old_elem, new_elem)  ({ 	__auto_type __head = (head);                                                                                                                            	__smrq_serialized_replace(&__head->first,                               	    (old_elem), (new_elem), __smrq_lastp(__head));                      })
smrq_serialized_iter(it, head, field) 	for (__smrq_slink_t *__prev_##it = &(head)->first,                      	    *__chk_##it = __prev_##it;                                          	    ((it) = __container_of_safe(smr_serialized_load(__prev_##it),       	    typeof(*(it)), field));                                             	    assert(__chk_##it), __chk_##it = __prev_##it)
smrq_serialized_iter_next(it, field)  ({ 	assert(__chk_##it == __prev_##it);                                      	__chk_##it = NULL;                                                      	__prev_##it = &(it)->field.next;                                        })
smrq_serialized_iter_erase(it, field)  ({ 	assert(__chk_##it == __prev_##it);                                      	__chk_##it = NULL;                                                      	__smrq_serialized_remove_one(__prev_##it, &(it)->field, NULL);          })
smrq_serialized_append(dst, src)  ({ 	__auto_type __src = (src);                                              	__auto_type __dst = (dst);                                                                                                                              	__smrq_serialized_append(&__dst->first, __smrq_lastp(__dst),            	    &__src->first, __smrq_lastp(__src));                                })
SMR_SEQ_DELTA(a, b)     ((smr_delta_t)((a) - (b)))
SMR_SEQ_CMP(a, op, b)   (SMR_SEQ_DELTA(a, b) op 0)
SMR_NAME_MAX 24
SMR_DEFINE_FLAGS(var, name, flags) 	struct smr var = { 	        .smr_clock.s_rd_seq = SMR_SEQ_INIT, 	        .smr_clock.s_wr_seq = SMR_SEQ_INIT, 	        .smr_flags = (flags), 	        .smr_name  = "" name, 	}; 	STARTUP_ARG(TUNABLES, STARTUP_RANK_LAST, __smr_domain_init, &(var)); 	STARTUP_ARG(ZALLOC, STARTUP_RANK_LAST, __smr_domain_init, &(var))
SMR_DEFINE(var, name) 	SMR_DEFINE_FLAGS(var, name, SMR_NONE)
SMR_DEFINE_SLEEPABLE(var, name) 	SMR_DEFINE_FLAGS(var, name, SMR_SLEEPABLE)
smr_ipc smr_system
smr_ipc_entered() smr_entered(&smr_ipc)
smr_ipc_enter() smr_enter(&smr_ipc)
smr_ipc_leave() smr_leave(&smr_ipc)
smr_ipc_call(n, sz, cb)         smr_call(&smr_ipc, n, sz, cb)
smr_ipc_synchronize() smr_synchronize(&smr_ipc)
smr_ipc_barrier() smr_barrier(&smr_ipc)
smr_proc_task smr_system
smr_proc_task_entered() smr_entered(&smr_proc_task)
smr_proc_task_enter() smr_enter(&smr_proc_task)
smr_proc_task_leave() smr_leave(&smr_proc_task)
smr_proc_task_call(n, sz, cb)   smr_call(&smr_proc_task, n, sz, cb)
smr_proc_task_synchronize() smr_synchronize(&smr_proc_task)
smr_proc_task_barrier() smr_barrier(&smr_proc_task)
smr_iokit smr_system
smr_iokit_entered() smr_entered(&smr_iokit)
smr_iokit_enter() smr_enter(&smr_iokit)
smr_iokit_leave() smr_leave(&smr_iokit)
smr_iokit_call(n, sz, cb)       smr_call(&smr_iokit, n, sz, cb)
smr_iokit_synchronize() smr_synchronize(&smr_iokit)
smr_iokit_barrier() smr_barrier(&smr_iokit)
smr_oslog smr_system
smr_oslog_entered() smr_entered(&smr_oslog)
smr_oslog_enter() smr_enter(&smr_oslog)
smr_oslog_leave() smr_leave(&smr_oslog)
smr_oslog_call(n, sz, cb)       smr_call(&smr_oslog, n, sz, cb)
smr_oslog_synchronize() smr_synchronize(&smr_oslog)
smr_oslog_barrier() smr_barrier(&smr_oslog)
_KERN_SMR_HASH_H_ None
SMRH_TRAITS_DEFINE(name, type_t, link_field, ...) 	__smrh_traits_storage struct name {                                     	        type_t *smrht_obj_type[0];                                      	        struct smrh_traits smrht;                                       	} name = { .smrht = {                                                   	        .link_offset = offsetof(type_t, link_field),                    	        __VA_ARGS__                                                     	} }
SMRH_TRAITS_DEFINE_SCALAR(name, type_t, key_field, link_field, ...) 	static uint32_t                                                         	name ## _obj_hash(const struct smrq_slink *link, uint32_t seed)         	{                                                                       	        __auto_type o = __container_of(link, const type_t, link_field); 	        smrh_key_t  k = SMRH_SCALAR_KEY(o->key_field);                                                                                                  	        if (k.smrk_len > sizeof(uint32_t)) {                            	                return smrh_key_hash_u64(k, seed);                      	        } else {                                                        	                return smrh_key_hash_u32(k, seed);                      	        }                                                               	}                                                                                                                                                       	static bool                                                             	name ## _obj_equ(const struct smrq_slink *link, smrh_key_t key)         	{                                                                       	        __auto_type o = __container_of(link, const type_t, link_field);                                                                                 	        return smrh_key_equ_scalar(SMRH_SCALAR_KEY(o->key_field), key); 	}                                                                                                                                                       	SMRH_TRAITS_DEFINE(name, type_t, link_field,                            	        .key_hash    = sizeof(((type_t *)NULL)->key_field) > 4          	            ? smrh_key_hash_u64 : smrh_key_hash_u32,                    	        .key_equ     = smrh_key_equ_scalar,                             	        .obj_hash    = name ## _obj_hash,                               	        .obj_equ     = name ## _obj_equ,                                	        __VA_ARGS__                                                     	)
SMRH_TRAITS_DEFINE_STR(name, type_t, link_field, ...) 	SMRH_TRAITS_DEFINE(name, type_t, link_field,                            	        .key_hash = smrh_key_hash_str,                                  	        .key_equ  = smrh_key_equ_str,                                   	        __VA_ARGS__                                                     	)
SMRH_TRAITS_DEFINE_MEM(name, type_t, link_field, ...) 	SMRH_TRAITS_DEFINE(name, type_t, link_field,                            	        .key_hash = smrh_key_hash_mem,                                  	        .key_equ  = smrh_key_equ_mem,                                   	        __VA_ARGS__                                                     	)
smrht_enter(traits) smr_enter((traits)->smrht.domain)
smrht_leave(traits) smr_leave((traits)->smrht.domain)
smr_hash_get(smrh, key, traits)  ({ 	(smrht_obj_t(traits))__smr_hash_get(smrh, key, &(traits)->smrht);       })
smr_hash_contains(smrh, key, traits)  ({ 	smrh_traits_t __smrht = &(traits)->smrht;                               	struct smrq_slist_head *__hd;                                           	bool __contains;                                                                                                                                        	smr_enter(__smrht->domain);                                             	__hd = __smr_hash_bucket(smrh, key, __smrht);                           	__contains = (__smr_hash_entered_find(__hd, key, __smrht) != NULL);     	smr_leave(__smrht->domain);                                                                                                                             	__contains;                                                             })
smr_hash_entered_find(smrh, key, traits)  ({ 	smrh_traits_t __smrht = &(traits)->smrht;                               	struct smrq_slist_head *__hd = __smr_hash_bucket(smrh, key, __smrht);                                                                                   	(smrht_obj_t(traits))__smr_hash_entered_find(__hd, key, __smrht);       })
smr_hash_serialized_find(smrh, key, traits)  ({ 	smrh_traits_t __smrht = &(traits)->smrht;                               	struct smrq_slist_head *__hd = __smr_hash_bucket(smrh, key, __smrht);                                                                                   	(smrht_obj_t(traits))__smr_hash_serialized_find(__hd, key, __smrht);    })
smr_hash_serialized_insert(smrh, link, traits)  ({ 	smrh_traits_t __smrht = &(traits)->smrht;                               	struct smr_hash *__h = (smrh);                                          	struct smrq_slink *__link = (link);                                     	struct smrq_slist_head *__hd;                                                                                                                           	__hd = __smr_hash_bucket(__h, __link, __smrht);                         	__h->smrh_count++;                                                      	smrq_serialized_insert_head(__hd, __link);                              })
smr_hash_serialized_get_or_insert(smrh, key, link, traits)  ({ 	(smrht_obj_t(traits))__smr_hash_serialized_get_or_insert(smrh, key,     	    link, &(traits)->smrht);                                            })
smr_hash_serialized_remove(smrh, link, traits)  ({ 	smrh_traits_t __smrht = &(traits)->smrht;                               	struct smr_hash *__h = (smrh);                                          	struct smrq_slink *__link = (link);                                     	struct smrq_slist_head *__hd;                                                                                                                           	__hd = __smr_hash_bucket(__h, __link, __smrht);                         	__h->smrh_count--;                                                      	smrq_serialized_remove(__hd, __link);                                   })
smr_hash_serialized_replace(smrh, old_link, new_link, traits)  ({ 	smrh_traits_t __smrht = &(traits)->smrht;                               	struct smrq_slink *__link = (old_link);                                 	struct smrq_slist_head *__hd;                                                                                                                           	__hd = __smr_hash_bucket(smrh, __link, __smrht);                        	smrq_serialized_replace(__hd, __link, (new_link));                      })
smr_hash_serialized_clear(smrh, traits, free...) 	__smr_hash_serialized_clear(smrh, &(traits)->smrht, free)
smr_hash_shrink_and_unlock(smrh, mutex, traits) 	__smr_hash_shrink_and_unlock(smrh, mutex, &(traits)->smrht)
smr_hash_grow_and_unlock(smrh, mutex, traits) 	__smr_hash_grow_and_unlock(smrh, mutex, &(traits)->smrht)
smr_hash_iter_get(it, traits)  ({ 	struct smr_hash_iterator __smrh_it = (it);                              	void *__obj = NULL;                                                                                                                                     	if (__smrh_it.link) {                                                   	        __obj = __smrht_link_to_obj(&(traits)->smrht, __smrh_it.link);  	}                                                                                                                                                       	(smrht_obj_t(traits))__obj;                                             })
smr_hash_foreach(obj, smrh, traits) 	for (struct smr_hash_iterator __it = smr_hash_iter_begin(smrh);         	    ((obj) = smr_hash_iter_get(__it, traits));                          	    smr_hash_iter_advance(&__it))
SMRSH_BUCKET_STOP_BIT 0x1ul
smr_shash_destroy(smrh, traits, free...) 	__smr_shash_destroy(smrh, &(traits)->smrht, free)
smr_shash_entered_find(smrh, key, traits)  ({ 	void *__obj;                                                                                                                                            	__obj = __smr_shash_entered_find(smrh, key, &(traits)->smrht);                                                                                          	(smrht_obj_t(traits))__obj;                                             })
smr_shash_entered_get(smrh, key, traits)  ({ 	void *__obj;                                                                                                                                            	__obj = __smr_shash_entered_get(smrh, key, &(traits)->smrht);                                                                                           	(smrht_obj_t(traits))__obj;                                             })
smr_shash_get(smrh, key, traits)  ({ 	void *__obj;                                                                                                                                            	smrht_enter(traits);                                                    	__obj = __smr_shash_entered_get(smrh, key, &(traits)->smrht);           	smrht_leave(traits);                                                                                                                                    	(smrht_obj_t(traits))__obj;                                             })
smr_shash_entered_get_or_insert(smrh, key, link, traits)  ({ 	smrh_traits_t __smrht = &(traits)->smrht;                               	void *__obj;                                                                                                                                            	__obj = __smr_shash_entered_get_or_insert(smrh, key, link,              	    &(traits)->smrht);                                                                                                                                  	(smrht_obj_t(traits))__obj;                                             })
smr_shash_get_or_insert(smrh, key, link, traits)  ({ 	void *__obj;                                                                                                                                            	smrht_enter(traits);                                                    	__obj = __smr_shash_entered_get_or_insert(smrh, key, link,              	    &(traits)->smrht);                                                  	smrht_leave(traits);                                                                                                                                    	(smrht_obj_t(traits))__obj;                                             })
smr_shash_entered_remove(smrh, link, traits)  ({ 	smr_shash_mut_cursor_t __cursor;                                        	struct smrq_slink *__link = (link);                                     	struct smr_shash *__smrh = (smrh);                                                                                                                      	__cursor = smr_shash_entered_mut_begin(__smrh, __link, traits);         	smr_shash_entered_mut_erase(__smrh, __cursor, __link, traits);          })
smr_shash_remove(smrh, link, traits)  ({ 	smrht_enter(traits);                                                    	smr_shash_entered_remove(smrh, link, traits);                           	smrht_leave(traits);                                                    })
smr_shash_entered_replace(smrh, old_link, new_link, traits)  ({ 	smr_shash_mut_cursor_t __cursor;                                        	struct smrq_slink *__link = (old_link);                                                                                                                 	__cursor = smr_shash_entered_mut_begin(smrh, __link, traits);           	smr_shash_entered_mut_replace(__cursor, __link, new_link);              })
smr_shash_replace(smrh, old_link, new_link, traits)  ({ 	smrht_enter(traits);                                                    	smr_shash_entered_replace(smrh, old_link, new_link, traits);            	smrht_leave(traits);                                                    })
smr_shash_entered_mut_begin(smrh, link, traits) 	__smr_shash_entered_mut_begin(smrh, link, &(traits)->smrht)
smr_shash_entered_mut_erase(smrh, cursor, link, traits) 	__smr_shash_entered_mut_erase(smrh, cursor, link, &(traits)->smrht)
smr_shash_entered_mut_replace(cursor, old_link, new_link, traits) 	__smr_shash_entered_mut_replace(cursor, old_link, new_link, &(traits)->smrht)
smr_shash_entered_mut_abort(cursor) __smr_shash_entered_mut_abort(cursor)
smrht_obj_t(traits) typeof((traits)->smrht_obj_type[0])
_KERN_SMR_TYPES_H_ None
SMR_POINTER_DECL(name, type_t) 	struct name { type_t volatile __smr_ptr; }
SMR_POINTER(type_t) SMR_POINTER_DECL(, type_t)
SMRQ_SLIST_INITIALIZER(name) { .first = { NULL } }
SMRQ_LIST_INITIALIZER(name) { .first = { NULL } }
SMRQ_STAILQ_INITIALIZER(name) { .first = { NULL }, .last = &(name).first }
SMRQ_TAILQ_INITIALIZER(name) { .first = { NULL }, .last = &(name).first }
SOCD_CLIENT_HDR_VERSION 0x2
_KERN_SOCD_CLIENT_H_ None
SOCD_TRACE_MODE_NONE 0x0
SOCD_TRACE_MODE_STICKY_TRACEPOINT 0x1
SOCD_TRACE_EVENTID(class, mode, code) 	(((unsigned)((mode)  &  SOCD_TRACE_MODE_SMASK) << SOCD_TRACE_MODE_OFFSET) | 	((unsigned)((class)  &  SOCD_TRACE_CLASS_SMASK) << SOCD_TRACE_CLASS_OFFSET) | 	 ((unsigned)((code)   &  SOCD_TRACE_CODE_SMASK) << SOCD_TRACE_CODE_OFFSET))
SOCD_TRACE_GEN_STR(entry) #entry,
SOCD_TRACE_GEN_CLASS_ENUM(entry) SOCD_TRACE_CLASS_##entry,
SOCD_TRACE_GEN_CODE_ENUM(entry) SOCD_TRACE_CODE_##entry,
SOCD_TRACE_FOR_EACH_CLASS(iter) iter(XNU) 	iter(WDT)
SOCD_TRACE_FOR_EACH_XNU_CODE(iter) iter(XNU_PANIC) 	iter(XNU_START_IOKIT) 	iter(XNU_PLATFORM_ACTION) 	iter(XNU_PM_SET_POWER_STATE) 	iter(XNU_PM_INFORM_POWER_CHANGE) 	iter(XNU_STACKSHOT) 	iter(XNU_PM_SET_POWER_STATE_ACK) 	iter(XNU_PM_INFORM_POWER_CHANGE_ACK) 	iter(XNU_KERNEL_STATE_PANIC)
_KERN_SOCD_CLIENT_KERN_H_ None
SOCD_TRACE(x, ...) SOCD_TRACE_(x, ## __VA_ARGS__, 4, 3, 2, 1, 0)
SOCD_TRACE_(x, a, b, c, d, n, ...) SOCD_TRACE##n(x, a, b, c, d)
SOCD_TRACE0(x, a, b, c, d)         SOCD_TRACE_IMPL(x,        0,        0,        0,        0)
SOCD_TRACE1(x, a, b, c, d)         SOCD_TRACE_IMPL(x, SOCD_##a,        0,        0,        0)
SOCD_TRACE2(x, a, b, c, d)         SOCD_TRACE_IMPL(x, SOCD_##a, SOCD_##b,        0,        0)
SOCD_TRACE3(x, a, b, c, d)         SOCD_TRACE_IMPL(x, SOCD_##a, SOCD_##b, SOCD_##c,        0)
SOCD_TRACE4(x, a, b, c, d)         SOCD_TRACE_IMPL(x, SOCD_##a, SOCD_##b, SOCD_##c, SOCD_##d)
SOCD_PACK_2X32(h, l) ((((uint64_t)(SOCD_##h) & 0xffffffff) << 32) | ((uint64_t)(SOCD_##l) & 0xffffffff))
SOCD_PACK_LSB(h, lsb) ((((uint64_t)(SOCD_##h)) & 0xfffffffffffffffe) | ((uint64_t)(SOCD_##lsb) & 0x1))
_SOCD_TRACE_XNU(cls, mode, func, ...)    SOCD_TRACE(KDBG_EVENTID(DBG_DRIVERS, DBG_SOCDIAGS, SOCD_TRACE_EVENTID(SOCD_TRACE_CLASS_XNU, mode, SOCD_TRACE_CODE_XNU_##cls)) | (func), ## __VA_ARGS__)
SOCD_TRACE_XNU(c, m, ...) _SOCD_TRACE_XNU(c, m, DBG_FUNC_NONE, ## __VA_ARGS__)
SOCD_TRACE_XNU_START(c, ...) _SOCD_TRACE_XNU(c, SOCD_TRACE_MODE_NONE, DBG_FUNC_START, ## __VA_ARGS__)
SOCD_TRACE_XNU_END(c, ...) _SOCD_TRACE_XNU(c, SOCD_TRACE_MODE_NONE, DBG_FUNC_END, ## __VA_ARGS__)
_KERN_SPL_H_ None
stack_lock() simple_lock(&stack_lock_data, LCK_GRP_NULL)
stack_unlock() simple_unlock(&stack_lock_data)
STACK_CACHE_SIZE 2
load_context_kprintf(x...) None
_KERN_STARTUP_H_ None
__startup_func __PLACE_IN_SECTION(STARTUP_CODE_SEGSECT) 	__attribute__((cold, visibility("hidden")))
__startup_data __PLACE_IN_SECTION(STARTUP_DATA_SEGSECT)
__startup_const __PLACE_IN_SECTION(STARTUP_CONST_SEGSECT) const
STARTUP(subsystem, rank, func) 	__STARTUP(func, __LINE__, subsystem, rank, func)
STARTUP_ARG(subsystem, rank, func, arg) 	__STARTUP_ARG(func, __LINE__, subsystem, rank, func, arg)
TUNABLE(type_t, var, boot_arg, default_value) 	SECURITY_READ_ONLY_LATE(type_t) var = default_value; 	__TUNABLE(type_t, var, boot_arg)
TUNABLE_WRITEABLE(type_t, var, boot_arg, default_value) 	type_t var = default_value; 	__TUNABLE(type_t, var, boot_arg)
TUNABLE_STR(var, count, boot_arg, default_value) 	char __security_const_late var[count] = default_value; 	__TUNABLE_STR(var, boot_arg)
TUNABLE_DT(type_t, var, dt_base, dt_name, boot_arg, default_value, flags) 	SECURITY_READ_ONLY_LATE(type_t) var = default_value; 	__TUNABLE_DT(type_t, var, dt_base, dt_name, boot_arg, flags)
TUNABLE_DT_WRITEABLE(type_t, var, dt_base, dt_name, boot_arg, default_value, flags) 	type_t var = default_value; 	__TUNABLE_DT(type_t, var, dt_base, dt_name, boot_arg, flags)
TUNABLE_DT_WRITEABLE_SOURCE(type_t, var, source_var, dt_base, dt_name, boot_arg, default_value, flags) 	type_t var = default_value;     startup_source_t source_var; 	__TUNABLE_DT_SOURCE(type_t, var, source_var, dt_base, dt_name, boot_arg, flags)
MACHINE_TIMEOUT_UNIT_PSEC 1
MACHINE_TIMEOUT_UNIT_NSEC 1000
MACHINE_TIMEOUT_UNIT_TIMEBASE 0
MACHINE_TIMEOUT_MAX_NAME_LEN 25
_MACHINE_TIMEOUT(var, timeout_name, timeout_default, var_unit, skip_pred) 	struct machine_timeout_spec 	__machine_timeout_spec_ ## var = { 	        .ptr = &var, 	        .default_value = timeout_default, 	        .unit_scale = var_unit, 	        .name = timeout_name, 	        .skip_predicate = skip_pred, 	}; 	__STARTUP_ARG(var, __LINE__, TIMEOUTS, STARTUP_RANK_FIRST, 	    machine_timeout_init, &__machine_timeout_spec_ ## var)
MACHINE_TIMEOUT(var, name, default, unit, skip_predicate)       	SECURITY_READ_ONLY_LATE(machine_timeout_t) var = 0;                                     	_MACHINE_TIMEOUT(var, name, default, unit, skip_predicate)
MACHINE_TIMEOUT_SPEC_DECL(var) extern struct machine_timeout_spec __machine_timeout_spec_ ## var
EVENT_DECLARE(name, cb_type_t) 	struct name##_event {                                                   	        struct event_hdr        evt_link;                               	        cb_type_t              *evt_cb;                                 	};                                                                      	extern struct event_hdr name##_HEAD
EVENT_DEFINE(name) __security_const_late struct event_hdr name##_HEAD
EVENT_REGISTER_HANDLER(name, handler) 	__EVENT_REGISTER(name, __LINE__, handler)
EVENT_INVOKE(name, ...) 	for (struct event_hdr *__e = &name##_HEAD; (__e = __e->next);) {        	        __container_of(__e, struct name##_event,                        	            evt_link)->evt_cb(__VA_ARGS__);                             	}
__TUNABLE(type_t, var, key) 	static __startup_const char __startup_TUNABLES_name_ ## var[] = key; 	static __startup_const struct startup_tunable_spec 	__startup_TUNABLES_spec_ ## var = { 	        .name = __startup_TUNABLES_name_ ## var, 	        .var_addr = (void *)&var, 	        .var_len = sizeof(type_t), 	        .var_is_bool = __startup_type_is_bool(type_t), 	}; 	__STARTUP_ARG(var, __LINE__, TUNABLES, STARTUP_RANK_FIRST, 	    kernel_startup_tunable_init, &__startup_TUNABLES_spec_ ## var)
__TUNABLE_STR(var, key) 	static __startup_const char __startup_TUNABLES_name_ ## var[] = key; 	static __startup_const struct startup_tunable_spec 	__startup_TUNABLES_spec_ ## var = { 	        .name = __startup_TUNABLES_name_ ## var, 	        .var_addr = (void *)&var, 	        .var_len = sizeof(var), 	        .var_is_str = true, 	}; 	__STARTUP_ARG(var, __LINE__, TUNABLES, STARTUP_RANK_FIRST, 	    kernel_startup_tunable_init, &__startup_TUNABLES_spec_ ## var)
__TUNABLE_DT(type_t, var, dt_base_key, dt_name_key, boot_arg_key, flags) 	static __startup_const char __startup_TUNABLES_dt_base_ ## var[] = dt_base_key; 	static __startup_const char __startup_TUNABLES_dt_name_ ## var[] = dt_name_key; 	static __startup_const char __startup_TUNABLES_name_ ## var[] = boot_arg_key; 	static __startup_const struct startup_tunable_dt_spec 	__startup_TUNABLES_DT_spec_ ## var = { 	        .dt_base = __startup_TUNABLES_dt_base_ ## var, 	        .dt_name = __startup_TUNABLES_dt_name_ ## var, 	        .dt_chosen_override = (bool)((flags) & TUNABLE_DT_CHECK_CHOSEN), 	        .boot_arg_name = __startup_TUNABLES_name_ ## var, 	        .var_addr = (void *)&var, 	        .var_len = sizeof(type_t), 	        .var_is_bool = __startup_type_is_bool(type_t), 	}; 	__STARTUP_ARG(var, __LINE__, TUNABLES, STARTUP_RANK_FIRST, 	    kernel_startup_tunable_dt_init, &__startup_TUNABLES_DT_spec_ ## var)
__TUNABLE_DT_SOURCE(type_t, var, source_var, dt_base_key, dt_name_key, boot_arg_key, flags) 	static __startup_const char __startup_TUNABLES_dt_base_ ## var[] = dt_base_key; 	static __startup_const char __startup_TUNABLES_dt_name_ ## var[] = dt_name_key; 	static __startup_const char __startup_TUNABLES_name_ ## var[] = boot_arg_key; 	static __startup_const struct startup_tunable_dt_source_spec 	__startup_TUNABLES_DT_spec_ ## var = { 	        .dt_base = __startup_TUNABLES_dt_base_ ## var, 	        .dt_name = __startup_TUNABLES_dt_name_ ## var, 	        .dt_chosen_override = (bool)((flags) & TUNABLE_DT_CHECK_CHOSEN), 	        .boot_arg_name = __startup_TUNABLES_name_ ## var, 	        .var_addr = (void *)&var, 	        .var_len = sizeof(type_t), 	        .var_is_bool = __startup_type_is_bool(type_t), 	    .source_addr = &source_var, 	}; 	__STARTUP_ARG(var, __LINE__, TUNABLES, STARTUP_RANK_FIRST, 	    kernel_startup_tunable_dt_source_init, &__startup_TUNABLES_DT_spec_ ## var)
__STARTUP1(name, line, subsystem, rank, func, a, b) 	__PLACE_IN_SECTION(STARTUP_HOOK_SEGMENT "," STARTUP_HOOK_SECTION) 	static const struct startup_entry 	__startup_ ## subsystem ## _entry_ ## name ## _ ## line = { 	    STARTUP_SUB_ ## subsystem, 	    rank, __STARTUP_FUNC_CAST(func, a), b, 	}
__STARTUP(name, line, subsystem, rank, func) 	__STARTUP1(name, line, subsystem, rank, func, , NULL)
__STARTUP_ARG(name, line, subsystem, rank, func, arg) 	__STARTUP1(name, line, subsystem, rank, func, arg, arg)
__EVENT_REGISTER(name, lno, handler) 	static __security_const_late struct name##_event name##_event_##lno = { 	        .evt_link.next = &name##_HEAD,                                  	        .evt_cb = (handler),                                            	};                                                                      	__STARTUP_ARG(name, lno, EVENT, STARTUP_RANK_FIRST,                     	    event_register_handler, &name##_event_##lno.evt_link)
SEMAPHORE_EVENT CAST_EVENT64_T(&semaphore_event)
_KERN_SYNC_SEMA_H_ None
semaphore_lock(semaphore) waitq_lock(&(semaphore)->waitq)
semaphore_unlock(semaphore) waitq_unlock(&(semaphore)->waitq)
_KERN_SYSCALL_SUBR_H_ None
_KERN_SYSCALL_SW_H_ None
MACH_TRAP_TABLE_COUNT 128
MACH_TRAP(name, arg_count, u32_arg_words, munge32, ...)  { 	.mach_trap_arg_count = arg_count, 	.mach_trap_u32_words = u32_arg_words, 	.mach_trap_function = (kern_return_t (*)(void *)) (name), 	MACH_TRAP_MUNGE(munge32) 	MACH_TRAP_NAME(name) 	__VA_ARGS__ }
PHYS_FOOTPRINT_WARNING_LEVEL 80
TASK_WAKEUPS_MONITOR_DEFAULT_LIMIT 150
TASK_WAKEUPS_MONITOR_DEFAULT_INTERVAL 300
TASK_WAKEUPS_MONITOR_DEFAULT_USTACKSHOTS_TRIGGER 70
TASK_MAX_THREAD_LIMIT 256
TASK_HOLD_NORMAL 0
TASK_HOLD_PIDSUSPEND 1
TASK_HOLD_LEGACY 2
TASK_HOLD_LEGACY_ALL 3
TASK_LEGACY_DYLD_INFO_COUNT offsetof(struct task_dyld_info, all_image_info_format)/sizeof(natural_t)
HWM_USERCORE_MINSPACE 250
FATAL_EXCEPTION_ENTITLEMENT "com.apple.security.fatal-exceptions"
FATAL_EXCEPTION_ENTITLEMENT_JIT "jit"
_KERN_TASK_H_ None
task_is_immovable(task) !!(task_get_control_port_options(task) & TASK_CONTROL_PORT_IMMOVABLE)
task_is_pinned(task) !!(task_get_control_port_options(task) & TASK_CONTROL_PORT_PINNED)
VM_BACKING_STORE_PRIV 0x1
TF_NONE 0
TF_64B_ADDR 0x00000001
TF_64B_DATA 0x00000002
TF_CPUMON_WARNING 0x00000004
TF_WAKEMON_WARNING 0x00000008
TF_GPU_DENIED 0x00000010
TF_PENDING_CORPSE 0x00000040
TF_CORPSE_FORK 0x00000080
TF_CA_CLIENT_WI 0x00000800
TF_DARKWAKE_MODE 0x00001000
TF_NO_SMT 0x00002000
TF_SYS_VERSION_COMPAT 0x00008000
TF_TECS 0x00020000
TF_COALITION_MEMBER 0x00080000
TF_NO_CORPSE_FORKING 0x00100000
TF_USE_PSET_HINT_CLUSTER_TYPE 0x00200000
TF_DYLD_ALL_IMAGE_FINAL 0x00400000
TF_HASPROC 0x00800000
TF_HAS_REPLY_PORT_TELEMETRY 0x10000000
TF_HAS_PROVISIONAL_REPLY_PORT_TELEMETRY 0x20000000
TF_GAME_MODE 0x40000000
TF_CARPLAY_MODE 0x80000000
TFRO_CORPSE 0x00000020
TFRO_HARDENED 0x00000100
TFRO_MACH_HARDENING_OPT_OUT 0x00000200
TFRO_PLATFORM 0x00000400
TFRO_FILTER_MSG 0x00004000
TFRO_PAC_EXC_FATAL 0x00010000
TFRO_JIT_EXC_FATAL 0x00020000
TFRO_PAC_ENFORCE_USER_STATE 0x01000000
TFRO_FREEZE_EXCEPTION_PORTS 0x04000000
TPF_NONE 0
TPF_DID_EXEC 0x00000001
TPF_EXEC_COPY 0x00000002
TWF_NONE 0
TRW_LRETURNWAIT 0x01
TRW_LRETURNWAITER 0x02
TRW_LEXEC_COMPLETE 0x04
task_lock(task) lck_mtx_lock(&(task)->lock)
task_lock_assert_owned(task) LCK_MTX_ASSERT(&(task)->lock, LCK_MTX_ASSERT_OWNED)
task_lock_try(task) lck_mtx_try_lock(&(task)->lock)
task_unlock(task) lck_mtx_unlock(&(task)->lock)
task_objq_lock_init(task) lck_mtx_init(&(task)->task_objq_lock, &vm_object_lck_grp, &vm_object_lck_attr)
task_objq_lock_destroy(task) lck_mtx_destroy(&(task)->task_objq_lock, &vm_object_lck_grp)
task_objq_lock(task) lck_mtx_lock(&(task)->task_objq_lock)
task_objq_lock_assert_owned(task) LCK_MTX_ASSERT(&(task)->task_objq_lock, LCK_MTX_ASSERT_OWNED)
task_objq_lock_try(task) lck_mtx_try_lock(&(task)->task_objq_lock)
task_objq_unlock(task) lck_mtx_unlock(&(task)->task_objq_lock)
itk_lock_init(task) lck_mtx_init(&(task)->itk_lock_data, &ipc_lck_grp, &ipc_lck_attr)
itk_lock_destroy(task) lck_mtx_destroy(&(task)->itk_lock_data, &ipc_lck_grp)
itk_lock(task) lck_mtx_lock(&(task)->itk_lock_data)
itk_unlock(task) lck_mtx_unlock(&(task)->itk_lock_data)
TCRW_CLEAR_INITIAL_WAIT 0x1
TCRW_CLEAR_FINAL_WAIT 0x2
TCRW_CLEAR_EXEC_COMPLETE 0x4
task_watchport_elem_init(elem, task, port) do {                                               	(elem)->twe_task = (task);                 	(elem)->twe_port = (port);                 	(elem)->twe_pdrequest = IP_NULL;           } while(0)
task_watchport_elem_clear(elem) task_watchport_elem_init((elem), NULL, NULL)
TASK_VTIMER_USER 0x01
TASK_VTIMER_PROF 0x02
TASK_VTIMER_RLIM 0x04
TASK_LEDGER_NUM_SMALL_INDICES 33
TASK_WRITE_IMMEDIATE 0x1
TASK_WRITE_DEFERRED 0x2
TASK_WRITE_INVALIDATED 0x4
TASK_WRITE_METADATA 0x8
_KERN_TASK_IDENT_H None
TASK_IDENTITY_TOKEN_KPI_VERSION 1
DEFAULT_CPUMON_PERCENTAGE 50
TASK_POLICY_SUPPRESSION_DISABLE 0x1
TASK_POLICY_SUPPRESSION_IOTIER2 0x2
TASK_POLICY_SUPPRESSION_NONDONOR 0x4
TASK_POLICY_CPU_RESOURCE_USAGE 0
TASK_POLICY_WIREDMEM_RESOURCE_USAGE 1
TASK_POLICY_VIRTUALMEM_RESOURCE_USAGE 2
TASK_POLICY_DISK_RESOURCE_USAGE 3
TASK_POLICY_NETWORK_RESOURCE_USAGE 4
TASK_POLICY_POWER_RESOURCE_USAGE 5
TASK_POLICY_RESOURCE_USAGE_COUNT 6
PROC_POLICY_CPUMON_DISABLE 0xFF
PROC_POLICY_CPUMON_DEFAULTS 0xFE
TASK_IMPORTANCE_FOREGROUND 4
TASK_IMPORTANCE_NOTDARWINBG 1
_KERN_TASK_REF_H_ None
task_reference_mig(task) task_reference_grp(task, TASK_GRP_MIG)
task_deallocate_mig(task) task_deallocate_grp(task, TASK_GRP_MIG)
task_reference(task) task_reference_grp(task, TASK_GRP_KERNEL)
task_deallocate(task) task_deallocate_grp(task, TASK_GRP_KERNEL)
convert_task_to_port(task) convert_task_to_port_kernel(task)
convert_task_read_to_port(task) convert_task_read_to_port_kernel(task)
port_name_to_task(name) port_name_to_task_kernel(name)
convert_port_to_task_suspension_token(port) convert_port_to_task_suspension_token_kernel(port)
convert_task_suspension_token_to_port(token) convert_task_suspension_token_to_port_kernel(token)
task_resume2(token) task_resume2_kernel(token)
task_suspend2(task, token) task_suspend2_kernel(task, token)
TELEMETRY_LOCK() do { lck_mtx_lock(&telemetry_mtx); } while (0)
TELEMETRY_TRY_SPIN_LOCK() lck_mtx_try_lock_spin(&telemetry_mtx)
TELEMETRY_UNLOCK() do { lck_mtx_unlock(&telemetry_mtx); } while (0)
TELEMETRY_PMI_LOCK() do { lck_mtx_lock(&telemetry_pmi_mtx); } while (0)
TELEMETRY_PMI_UNLOCK() do { lck_mtx_unlock(&telemetry_pmi_mtx); } while (0)
TELEMETRY_MACF_LOCK() do { lck_mtx_lock(&telemetry_macf_mtx); } while (0)
TELEMETRY_MACF_UNLOCK() do { lck_mtx_unlock(&telemetry_macf_mtx); } while (0)
_KERNEL_TELEMETRY_H_ None
TELEMETRY_CMD_TIMER_EVENT 1
TELEMETRY_CMD_VOUCHER_NAME 2
TELEMETRY_CMD_VOUCHER_STAIN TELEMETRY_CMD_VOUCHER_NAME
TELEMETRY_CMD_PMI_SETUP 3
CTID_SIZE_BIT 20
CPUMON_USTACKSHOTS_TRIGGER_DEFAULT_PCT 70
MINIMUM_CPULIMIT_INTERVAL_MS 1
_KERN_THREAD_H_ None
CTID_SIZE_BIT 20
TRR_FAULT_NONE 0
TRR_FAULT_PENDING 1
TRR_FAULT_OBSERVED 2
TH_OPT_INTMASK 0x0003
TH_OPT_VMPRIV 0x0004
TH_OPT_SYSTEM_CRITICAL 0x0010
TH_OPT_PROC_CPULIMIT 0x0020
TH_OPT_PRVT_CPULIMIT 0x0040
TH_OPT_IDLE_THREAD 0x0080
TH_OPT_GLOBAL_FORCED_IDLE 0x0100
TH_OPT_SCHED_VM_GROUP 0x0200
TH_OPT_HONOR_QLIMIT 0x0400
TH_OPT_SEND_IMPORTANCE 0x0800
TH_OPT_ZONE_PRIV 0x1000
TH_OPT_IPC_TG_BLOCKED 0x2000
TH_OPT_FORCED_LEDGER 0x4000
TH_IN_MACH_EXCEPTION 0x8000
TH_WAIT 0x01
TH_SUSP 0x02
TH_RUN 0x04
TH_UNINT 0x08
TH_TERMINATE 0x10
TH_TERMINATE2 0x20
TH_WAIT_REPORT 0x40
TH_IDLE 0x80
TH_WAKING 0x100
TH_SFLAG_FAILSAFE 0x0002
TH_SFLAG_THROTTLED 0x0004
TH_SFLAG_ABORT 0x0010
TH_SFLAG_ABORTSAFELY 0x0020
TH_SFLAG_DEPRESS 0x0040
TH_SFLAG_POLLDEPRESS 0x0080
TH_SFLAG_EAGERPREEMPT 0x0200
TH_SFLAG_RW_PROMOTED 0x0400
TH_SFLAG_BASE_PRI_FROZEN 0x0800
TH_SFLAG_WAITQ_PROMOTED 0x1000
TH_SFLAG_EXEC_PROMOTED 0x8000
TH_SFLAG_THREAD_GROUP_AUTO_JOIN 0x10000
TH_SFLAG_FLOOR_PROMOTED 0x80000
TH_SFLAG_RT_DISALLOWED 0x100000
TH_SFLAG_RT_CPULIMIT 0x200000
TH_SFLAG_FAILSAFE_REPORTED 0x400000
THREAD_SAVE_IOKIT_TLS_COUNT 8
TH_DTRACE_EXECSUCCESS 0x01
T_KPERF_AST_CALLSTACK 0x1
T_KPERF_AST_DISPATCH 0x2
T_KPC_ALLOC 0x4
ith_receive saved.receive
ith_recv_bufs saved.receive.recv_bufs
ith_object saved.receive.object
ith_option saved.receive.option
ith_state saved.receive.state
ith_seqno saved.receive.seqno
ith_msize saved.receive.msize
ith_asize saved.receive.asize
ith_receiver_name saved.receive.receiver_name
ith_kmsg saved.receive.kmsg
sth_waitsemaphore saved.sema.waitsemaphore
sth_signalsemaphore saved.sema.signalsemaphore
sth_options saved.sema.options
sth_result saved.sema.result
sth_continuation saved.sema.continuation
ITH_KNOTE_VALID(kn, msgt_name) 	        (((kn) != ITH_KNOTE_NULL && (kn) != ITH_KNOTE_PSEUDO) && 	         ((msgt_name) == MACH_MSG_TYPE_PORT_RECEIVE || 	         (msgt_name) == MACH_MSG_TYPE_PORT_SEND_ONCE))
thread_lock_init(th) simple_lock_init(&(th)->sched_lock, 0)
thread_lock(th) simple_lock(&(th)->sched_lock, &thread_lck_grp)
thread_unlock(th) simple_unlock(&(th)->sched_lock)
thread_lock_assert(th, x)       simple_lock_assert(&(th)->sched_lock, (x))
wake_lock_init(th) simple_lock_init(&(th)->wake_lock, 0)
wake_lock(th) simple_lock(&(th)->wake_lock, &thread_lck_grp)
wake_unlock(th) simple_unlock(&(th)->wake_lock)
thread_mtx_try(thread) lck_mtx_try_lock(&(thread)->mutex)
thread_mtx_held(thread) lck_mtx_assert(&(thread)->mutex, LCK_MTX_ASSERT_OWNED)
THREAD_CPULIMIT_BLOCK 0x1
THREAD_CPULIMIT_EXCEPTION 0x2
THREAD_CPULIMIT_DISABLE 0x3
SCHED_CALL_BLOCK 0x1
SCHED_CALL_UNBLOCK 0x2
thread_is_64bit_addr(thd) task_has_64Bit_addr(get_threadtask(thd))
thread_is_64bit_data(thd) task_has_64Bit_data(get_threadtask(thd))
dtrace_get_kernel_stack thread_get_kernel_stack
INTERNAL_CALL_COUNT 768
THREAD_CALL_ADD_RATIO 4
THREAD_CALL_MACH_FACTOR_CAP 3
THREAD_CALL_GROUP_MAX_THREADS 500
_KERN_THREAD_CALL_H_ None
THREAD_CALL_DELAY_SYS_NORMAL TIMEOUT_URGENCY_SYS_NORMAL
THREAD_CALL_DELAY_SYS_CRITICAL TIMEOUT_URGENCY_SYS_CRITICAL
THREAD_CALL_DELAY_SYS_BACKGROUND TIMEOUT_URGENCY_SYS_BACKGROUND
THREAD_CALL_DELAY_USER_MASK TIMEOUT_URGENCY_USER_MASK
THREAD_CALL_DELAY_USER_NORMAL TIMEOUT_URGENCY_USER_NORMAL
THREAD_CALL_DELAY_USER_CRITICAL TIMEOUT_URGENCY_USER_CRITICAL
THREAD_CALL_DELAY_USER_BACKGROUND TIMEOUT_URGENCY_USER_BACKGROUND
THREAD_CALL_DELAY_URGENCY_MASK TIMEOUT_URGENCY_MASK
THREAD_CALL_DELAY_LEEWAY TIMEOUT_URGENCY_LEEWAY
THREAD_CALL_CONTINUOUS 0x100
_KERN_THREAD_GROUP_H_ None
thread_initialize_kernel_state(thread) thread_get_kernel_state((thread))->allocation_name = NULL;
QOS_OVERRIDE_MODE_OVERHANG_PEAK 0
QOS_OVERRIDE_MODE_IGNORE_OVERRIDE 1
QOS_OVERRIDE_MODE_FINE_GRAINED_OVERRIDE 2
QOS_OVERRIDE_MODE_FINE_GRAINED_OVERRIDE_BUT_SINGLE_MUTEX_OVERRIDE 3
_KERN_TICKET_LOCK_H_ None
LCK_TICKET_ASSERT_OWNED(tlock) MACH_ASSERT_DO(lck_ticket_assert_owned(tlock))
LCK_TICKET_ASSERT_NOT_OWNED(tlock) MACH_ASSERT_DO(lck_ticket_assert_not_owned(tlock))
HW_LCK_TICKET_LOCK_VALID_BIT 8
_KERN_TIMER_H_ None
TIMER_ALIGNMENT None
timer_queue_lock_spin(queue) lck_ticket_lock(&(queue)->lock_data, &timer_queue_lck_grp)
timer_queue_unlock(queue) lck_ticket_unlock(&(queue)->lock_data)
TIMER_LONGTERM_NONE EndOfAllTime
TIMER_LONGTERM_SCAN_AGAIN 0
_KERN_TIMER_CALL_H_ None
TIMER_TRACE 1
EndOfAllTime 0xFFFFFFFFFFFFFFFFULL
TIMER_CALL_SYS_NORMAL TIMEOUT_URGENCY_SYS_NORMAL
TIMER_CALL_SYS_CRITICAL TIMEOUT_URGENCY_SYS_CRITICAL
TIMER_CALL_SYS_BACKGROUND TIMEOUT_URGENCY_SYS_BACKGROUND
TIMER_CALL_USER_MASK TIMEOUT_URGENCY_USER_MASK
TIMER_CALL_USER_NORMAL TIMEOUT_URGENCY_USER_NORMAL
TIMER_CALL_USER_CRITICAL TIMEOUT_URGENCY_USER_CRITICAL
TIMER_CALL_USER_BACKGROUND TIMEOUT_URGENCY_USER_BACKGROUND
TIMER_CALL_URGENCY_MASK TIMEOUT_URGENCY_MASK
TIMER_CALL_LEEWAY TIMEOUT_URGENCY_LEEWAY
TIMER_CALL_LOCAL TIMEOUT_URGENCY_FIRST_AVAIL
TIMER_CALL_RATELIMITED TIMEOUT_URGENCY_RATELIMITED
_KERN_TIMER_QUEUE_H_ None
TAG "[trap_telemetry] "
TRAP_TELEMETRY_BT_STR_LEN CA_UBSANBUF_LEN
_TRAP_TELEMETRY_H_ None
KERNEL_BRK_DESCRIPTOR_DEFINE(name, ...) __PLACE_IN_SECTION("__DATA_CONST,__brk_desc") static const struct kernel_brk_descriptor name = { __VA_ARGS__ };
_KERN_TRUSTCACHE_H_ None
CS_TRUST_CACHE_AMFID 0x1
TC_LOOKUP_HASH_TYPE_SHIFT 16
TC_LOOKUP_HASH_TYPE_MASK 0xff0000L;
TC_LOOKUP_FLAGS_SHIFT 8
TC_LOOKUP_FLAGS_MASK 0xff00L
TC_LOOKUP_RESULT_SHIFT 0
TC_LOOKUP_RESULT_MASK 0xffL
TC_LOOKUP_FOUND 1
max(a, b)        (((a) > (b)) ? (a) : (b))
TURNSTILE_HTABLE_BUCKETS_DEFAULT 32
TURNSTILE_HTABLE_BUCKETS_MAX 1024
turnstile_bucket_lock_init(bucket) lck_spin_init(&bucket->ts_ht_bucket_lock, &turnstiles_htable_lock_grp, LCK_ATTR_NULL)
turnstile_bucket_lock(bucket) lck_spin_lock_grp(&bucket->ts_ht_bucket_lock, &turnstiles_htable_lock_grp)
turnstile_bucket_unlock(bucket) lck_spin_unlock(&bucket->ts_ht_bucket_lock)
kdp_turnstile_bucket_is_locked(bucket) kdp_lck_spin_is_acquired(&bucket->ts_ht_bucket_lock)
STACKSHOT_TURNSTILE_FLAGS_WITHPORT(flags, port)      (STACKSHOT_TURNSTILE_FLAGS_MODE(flags) | STACKSHOT_TURNSTILE_FLAGS_PORT(port))
_TURNSTILE_H_ None
TURNSTILE_STATE_THREAD 0x1
TURNSTILE_STATE_FREELIST 0x2
TURNSTILE_STATE_HASHTABLE 0x4
TURNSTILE_STATE_PROPRIETOR 0x8
TURNSTILE_INHERITOR_NULL NULL
CTSID_BITS 20
ts_inheritor ts_waitq.waitq_inheritor
waitq_to_turnstile(waitq) __container_of(waitq, struct turnstile, ts_waitq)
TURNSTILE_PROPRIETOR_NULL 0ul
_KERN_UX_HANDLER_H_ None
WQL_PREPOST_MARKER 1ul
__wql_list_foreach(it, head, end) 	for (struct waitq_link_list_entry *__it = (head)->next, *__end = end; 	    ((it) = wql_list_elem(__it)); wql_list_next(&__it, __end))
wql_list_foreach(it, head) 	__wql_list_foreach(it, head, NULL)
wql_list_foreach_safe(it, head) 	for (struct waitq_link_list_entry *__it = (head)->next;                	    ((it) = wql_list_elem(__it)) && wql_list_next(&__it, NULL); )
waitq_link_foreach(link, waitq) 	__wql_list_foreach((link).wqls, &(waitq).wq_q->waitq_sellinks, __it)
_WAITQ_H_ None
WQ_OPAQUE_ALIGN __BIGGEST_ALIGNMENT__
WAITQ_FLAGS_BITS 5
WAITQ_FLAGS(prefix, ...) 	struct {                                                               	    waitq_type_t prefix##_type:3;                                      	    waitq_flags_t                                                      	        prefix##_fifo:1,                      	        prefix##_preposted:1                  	            - 2 * WAITQ_FLAGS_OVERFLOWS(__VA_ARGS__),                  	        __VA_ARGS__;                                                   	}
WAITQ_HDR(prefix, ...) 	WAITQ_FLAGS(prefix, __VA_ARGS__);                                      	hw_lck_ticket_t         prefix##_interlock;                            	uint8_t                 prefix##_padding[sizeof(waitq_flags_t) -       	                                         sizeof(hw_lck_ticket_t)];     	union {                                                                	        circle_queue_head_t             prefix##_queue;                	        struct priority_queue_sched_max prefix##_prio_queue;           	        struct turnstile               *prefix##_ts;                   	};                                                                     	union {                                                                	        circle_queue_head_t             prefix##_links;                	        waitq_link_list_t               prefix##_sellinks;             	        void                           *prefix##_inheritor;            	        struct mpsc_queue_chain         prefix##_defer;                	}
global_eventq(event) _global_eventq((char *)&(event), sizeof(event))
WORKLOAD_CONFIG_PHASE_NAME_MAX 32
WORKLOAD_CONFIG_ID_NAME_MAX WORK_INTERVAL_WORKLOAD_ID_NAME_MAX
_KERN_WORK_INTERVAL_H_ None
ZALLOC_ALLOW_DEPRECATED 1
ZBA_CHUNK_SIZE PAGE_MAX_SIZE
ZBA_GRANULE sizeof(uint64_t)
ZBA_MAX_ALLOC_ORDER 7
ZBA_PTR_MASK 0x0fffffff
ZBA_ORDER_SHIFT 29
ZBA_HAS_EXTRA_BIT 0x10000000
zba_map_index(type, n)    (n / (8 * sizeof(type)))
zba_map_bit(type, n)      ((type)1 << (n % (8 * sizeof(type))))
zba_map_mask_lt(type, n)  (zba_map_bit(type, n) - 1)
zba_map_mask_ge(type, n)  ((type)-zba_map_bit(type, n))
_KERN_ZALLOC_H_ None
__zpercpu __unsafe_indexable
Z_VM_TAG_SHIFT 16
Z_VM_TAG(fl, tag)     ((zalloc_flags_t)((fl) | ((tag) << Z_VM_TAG_SHIFT)))
Z_VM_TAG_BT(fl, tag)  ((zalloc_flags_t)(Z_VM_TAG(fl, tag) | Z_VM_TAG_BT_BIT))
kfree_type_impl(kt_view, ptr) 	kfree_type_impl_internal(kt_view, (ptr))
zalloc_id(zid, flags) __zalloc_cast(zid, (__zalloc_id)(zid, flags))
zalloc_ro(zid, fl) __zalloc_cast(zid, (__zalloc_ro)(zid, fl))
zalloc_ro_update_elem(zone_id, elem, new_data)  ({ 	const typeof(*(elem)) *__new_data = (new_data);                        	zalloc_ro_mut(zone_id, elem, 0, __new_data, sizeof(*__new_data));      })
zalloc_ro_update_field(zone_id, elem, field, value)  ({ 	const typeof((elem)->field) *__value = (value);                        	zalloc_ro_mut(zone_id, elem, offsetof(typeof(*(elem)), field),         	    __value, sizeof((elem)->field));                                   })
ZRO_ATOMIC_LONG(op) ZRO_ATOMIC_##op##_64
zalloc_ro_update_field_atomic(zone_id, elem, field, op, value)  ({ 	const typeof((elem)->field) __value = (value);                         	static_assert(sizeof(__value) == (op & 0xf));                          	(os_atomic_basetypeof(&(elem)->field))zalloc_ro_mut_atomic(zone_id,    	    elem, offsetof(typeof(*(elem)), field), op, (uint64_t)__value);    })
zalloc_ro_clear_field(zone_id, elem, field) 	zalloc_ro_clear(zone_id, elem, offsetof(typeof(*(elem)), field), 	    sizeof((elem)->field))
zfree_id(zid, elem) ({ 	zone_id_t __zfree_zid = (zid); 	(zfree_id)(__zfree_zid, (void *)os_ptr_load_and_erase(elem)); })
zfree_ro(zid, elem) ({ 	zone_id_t __zfree_zid = (zid); 	(zfree_ro)(__zfree_zid, (void *)os_ptr_load_and_erase(elem)); })
zfree(zone, elem) ({ 	__auto_type __zfree_zone = (zone); 	(zfree)(__zfree_zone, (void *)os_ptr_load_and_erase(elem)); })
__ZONE_DECLARE_TYPE(var, type_t) __ZONE_DECLARE_TYPE2(var, type_t)
__ZONE_DECLARE_TYPE2(var, type_t) 	__attribute__((visibility("hidden"))) 	extern type_t *__single __zalloc__##var##__type_name
zalloc_permanent(size, align) 	zalloc_permanent_tag(size, align, VM_KERN_MEMORY_KALLOC)
zalloc_permanent_type(type_t) __unsafe_forge_single(type_t *, 	    zalloc_permanent(sizeof(type_t), ZALIGN(type_t)))
zpercpu_get_cpu(ptr, cpu) 	__zpcpu_cast(ptr, __zpcpu_addr(ptr) + ptoa((unsigned)(cpu)))
zpercpu_get(ptr) zpercpu_get_cpu(ptr, cpu_number())
zpercpu_foreach(it, ptr) 	for (typeof(ptr) it = zpercpu_get_cpu(ptr, 0), 	    __end_##it = zpercpu_get_cpu(ptr, zpercpu_count()); 	    it < __end_##it; it = __zpcpu_next(it))
zpercpu_foreach_cpu(cpu) for (unsigned cpu = 0; cpu < zpercpu_count(); cpu++)
zalloc_percpu(zov, fl) __zalloc_percpu(zov, fl)
zone_id_enable_smr(zone_id, smr, free_cb)  ({ 	void (*__cb)(typeof(__zalloc__##zone_id##__type_name), vm_size_t);                                                                                      	__cb = (free_cb);                                                       	zone_enable_smr(zone_by_id(zone_id), smr, (zone_smr_free_cb_t)__cb);    })
zalloc_smr(zone, flags) 	zalloc_flags(zone, flags)
zalloc_id_smr(zid, flags) 	zalloc_id(zid, flags)
zfree_smr(zone, elem) ({ 	__auto_type __zfree_zone = (zone); 	(zfree_smr)(__zfree_zone, (void *)os_ptr_load_and_erase(elem)); })
zfree_id_smr(zid, elem) ({ 	zone_id_t __zfree_zid = (zid); 	(zfree_id_smr)(__zfree_zid, (void *)os_ptr_load_and_erase(elem)); })
zfree_smr_noclear(zone, elem) 	(zfree_smr)(zone, (void *)smr_unsafe_load(&(elem)))
zfree_id_smr_noclear(zone, elem) 	(zfree_id_smr)(zone, (void *)smr_unsafe_load(&(elem)))
ZONE_DECLARE(var, type_t) 	extern zone_t var; 	__ZONE_DECLARE_TYPE(var, type_t)
ZONE_DECLARE_ID(id, type_t) 	__ZONE_DECLARE_TYPE(id, type_t)
ZONE_DEFINE(var, name, size, flags) 	SECURITY_READ_ONLY_LATE(zone_t) var; 	static_assert(((flags) & ZC_DESTRUCTIBLE) == 0); 	static __startup_data struct zone_create_startup_spec 	__startup_zone_spec_ ## var = { &var, name, size, flags, 	    ZONE_ID_ANY, NULL }; 	STARTUP_ARG(ZALLOC, STARTUP_RANK_FOURTH, zone_create_startup, 	    &__startup_zone_spec_ ## var)
ZONE_DEFINE_TYPE(var, name, type_t, flags) 	ZONE_DEFINE(var, name, sizeof(type_t), flags); 	__ZONE_DECLARE_TYPE(var, type_t)
ZONE_DEFINE_ID(zid, name, type_t, flags) 	ZONE_DECLARE_ID(zid, type_t); 	ZONE_INIT(NULL, name, sizeof(type_t), flags, zid, NULL)
ZONE_INIT(var, name, size, flags, desired_zid, extra_setup) 	__ZONE_INIT(__LINE__, var, name, size, flags, desired_zid, extra_setup)
ZONE_VIEW_DECLARE(var) extern struct zone_view var[1]
ZONE_VIEW_DEFINE(var, name, heap_or_zone, size) 	SECURITY_READ_ONLY_LATE(struct zone_view) var[1] = { { 	    .zv_name = (name), 	} }; 	static __startup_data struct zone_view_startup_spec 	__startup_zone_view_spec_ ## var = { var, { heap_or_zone }, size }; 	STARTUP_ARG(ZALLOC, STARTUP_RANK_MIDDLE, zone_view_startup_init, 	    &__startup_zone_view_spec_ ## var)
zfree_nozero(zone_id, elem) ({ 	zone_id_t __zfree_zid = (zone_id); 	(zfree_nozero)(__zfree_zid, (void *)os_ptr_load_and_erase(elem)); })
zfree_n(zone_id, stack) ({ 	zone_id_t __zfree_zid = (zone_id); 	(zfree_n)(__zfree_zid, zstack_load_and_erase(&(stack))); })
zfree_nozero_n(zone_id, stack) ({ 	zone_id_t __zfree_zid = (zone_id); 	(zfree_nozero_n)(__zfree_zid, zstack_load_and_erase(&(stack))); })
zcache_alloc(zone_id, fl) 	__zalloc_cast(zone_id, zcache_alloc_n(zone_id, 1, fl).z_head)
zcache_alloc_n(zone_id, count, flags) 	(zcache_alloc_n)(zone_id, count, flags, __zcache_##zone_id##_ops)
zcache_free(zone_id, elem) 	(zcache_free)(zone_id, (void *)os_ptr_load_and_erase(elem), 	    __zcache_##zone_id##_ops)
zcache_free_n(zone_id, stack) 	(zcache_free_n)(zone_id, zstack_load_and_erase(&(stack)), 	    __zcache_##zone_id##_ops)
ZCACHE_DECLARE(id, type_t) 	__ZONE_DECLARE_TYPE(id, type_t); 	__attribute__((visibility("hidden"))) 	extern const zone_cache_ops_t __zcache_##id##_ops
ZCACHE_DEFINE(zid, name, type_t, size, ops) 	ZCACHE_DECLARE(zid, type_t);                                            	ZONE_DECLARE_ID(zid, type_t);                                           	const zone_cache_ops_t __zcache_##zid##_ops = (ops);                    	ZONE_INIT(NULL, name, size, ZC_OBJ_CACHE, zid, ^(zone_t z __unused) {   	        zcache_ops[zid] = (ops);                                        	})
__ZONE_INIT1(ns, var, name, size, flags, zid, setup) 	static __startup_data struct zone_create_startup_spec 	__startup_zone_spec_ ## ns = { var, name, size, flags, zid, setup }; 	STARTUP_ARG(ZALLOC, STARTUP_RANK_FOURTH, zone_create_startup, 	    &__startup_zone_spec_ ## ns)
__ZONE_INIT(ns, var, name, size, flags, zid, setup) 	__ZONE_INIT1(ns, var, name, size, flags, zid, setup)
__zalloc_cast(namespace, expr) 	((typeof(__zalloc__##namespace##__type_name))__unsafe_forge_single(void *, expr))
__zpcpu_cast(ptr, e)    __unsafe_forge_single(typeof(*(ptr)) *, e)
__zpcpu_next(ptr) __zpcpu_cast(ptr, __zpcpu_addr(ptr) + PAGE_SIZE)
__zalloc_ptr_load_and_erase(elem) os_ptr_load_and_erase(elem)
_KERN_ZALLOC_INTERNAL_H_ None
Z_WMA_MIX(base, e)  ((3 * (base) + (e) * Z_WMA_UNIT) / 4)
KT_VAR_MAX_HEAPS 8
MAX_ZONES 690
zone_index_foreach(i) for (zone_id_t i = 1, num_zones_##i = os_atomic_load(&num_zones, acquire); 	    i < num_zones_##i; i++)
zone_foreach(z) for (zone_t z = &zone_array[1], 	    last_zone_##z = &zone_array[os_atomic_load(&num_zones, acquire)]; 	    z < last_zone_##z; z++)
ZONE_WSS_UPDATE_PERIOD 15
__ZALLOC_RO_MUT_OP(op, op2) 	case ZRO_ATOMIC_##op##_8: 	        return os_atomic_##op2((uint8_t *)dst, (uint8_t)value, seq_cst); 	case ZRO_ATOMIC_##op##_16: 	        return os_atomic_##op2((uint16_t *)dst, (uint16_t)value, seq_cst); 	case ZRO_ATOMIC_##op##_32: 	        return os_atomic_##op2((uint32_t *)dst, (uint32_t)value, seq_cst); 	case ZRO_ATOMIC_##op##_64: 	        return os_atomic_##op2((uint64_t *)dst, (uint64_t)value, seq_cst)
MAX_ZONE_NAME 32
_KERN_ZALLOC_RO_SHIM_ None
KPERF_ACTION_H None
PERF_CODE(SubClass, code) KDBG_CODE(DBG_PERF, SubClass, code)
PERF_GEN_CODE(code) PERF_CODE(PERF_GENERIC, code)
PERF_GEN_EVENT PERF_GEN_CODE(0)
PERF_TI_CODE(code) PERF_CODE(PERF_THREADINFO, code)
PERF_TI_SAMPLE PERF_TI_CODE(0)
PERF_TI_DATA PERF_TI_CODE(1)
PERF_TI_XSAMPLE PERF_TI_CODE(2)
PERF_TI_XPEND PERF_TI_CODE(3)
PERF_TI_XDATA PERF_TI_CODE(4)
PERF_TI_CSWITCH PERF_TI_CODE(5)
PERF_TI_SCHEDSAMPLE PERF_TI_CODE(6)
PERF_TI_SCHEDDATA PERF_TI_CODE(7)
PERF_TI_SNAPSAMPLE PERF_TI_CODE(8)
PERF_TI_SNAPDATA PERF_TI_CODE(9)
PERF_TI_DISPSAMPLE PERF_TI_CODE(10)
PERF_TI_DISPDATA PERF_TI_CODE(11)
PERF_TI_DISPPEND PERF_TI_CODE(12)
PERF_TI_SNAPDATA_32 PERF_TI_CODE(13)
PERF_TI_DISPDATA_32 PERF_TI_CODE(14)
PERF_TI_SCHEDDATA1_32 PERF_TI_CODE(15)
PERF_TI_SCHEDDATA2_32 PERF_TI_CODE(16)
PERF_TI_INSCYCDATA PERF_TI_CODE(17)
PERF_TI_INSCYCDATA_32 PERF_TI_CODE(18)
PERF_TI_SCHEDDATA_2 PERF_TI_CODE(19)
PERF_TI_SCHEDDATA2_32_2 PERF_TI_CODE(20)
PERF_TI_SCHEDDATA3_32 PERF_TI_CODE(21)
PERF_TI_SCHEDDATA_3 PERF_TI_CODE(22)
PERF_TI_DISPLABEL PERF_TI_CODE(23)
PERF_CS_CODE(code) PERF_CODE(PERF_CALLSTACK, code)
PERF_CS_KSAMPLE PERF_CS_CODE(0)
PERF_CS_UPEND PERF_CS_CODE(1)
PERF_CS_USAMPLE PERF_CS_CODE(2)
PERF_CS_KDATA PERF_CS_CODE(3)
PERF_CS_UDATA PERF_CS_CODE(4)
PERF_CS_KHDR PERF_CS_CODE(5)
PERF_CS_UHDR PERF_CS_CODE(6)
PERF_CS_ERROR PERF_CS_CODE(7)
PERF_CS_BACKTRACE PERF_CS_CODE(8)
PERF_CS_LOG PERF_CS_CODE(9)
PERF_CS_EXHDR PERF_CS_CODE(10)
PERF_CS_EXDATA PERF_CS_CODE(11)
PERF_CS_EXSTACKHDR PERF_CS_CODE(12)
PERF_CS_EXSTACK PERF_CS_CODE(13)
PERF_CS_KEXOFFSET PERF_CS_CODE(14)
PERF_TM_CODE(code) PERF_CODE(PERF_TIMER, code)
PERF_TM_FIRE PERF_TM_CODE(0)
PERF_TM_SCHED PERF_TM_CODE(1)
PERF_TM_HNDLR PERF_TM_CODE(2)
PERF_TM_PENDING PERF_TM_CODE(3)
PERF_TM_SKIPPED PERF_TM_CODE(4)
PERF_PET_CODE(code) PERF_CODE(PERF_PET, code)
PERF_PET_THREAD PERF_PET_CODE(0)
PERF_PET_ERROR PERF_PET_CODE(1)
PERF_PET_RUN PERF_PET_CODE(2)
PERF_PET_PAUSE PERF_PET_CODE(3)
PERF_PET_IDLE PERF_PET_CODE(4)
PERF_PET_SAMPLE PERF_PET_CODE(5)
PERF_PET_SCHED PERF_PET_CODE(6)
PERF_PET_END PERF_PET_CODE(7)
PERF_PET_SAMPLE_TASK PERF_PET_CODE(8)
PERF_PET_SAMPLE_THREAD PERF_PET_CODE(9)
PERF_AST_CODE(code) PERF_CODE(PERF_AST, code)
PERF_AST_HNDLR PERF_AST_CODE(0)
PERF_AST_ERROR PERF_AST_CODE(1)
PERF_AST_EXCLAVES PERF_AST_CODE(2)
PERF_KPC_CODE(code) PERF_CODE(PERF_KPC, code)
PERF_KPC_HNDLR PERF_KPC_CODE(0)
PERF_KPC_FCOUNTER PERF_KPC_CODE(1)
PERF_KPC_COUNTER PERF_KPC_CODE(2)
PERF_KPC_DATA PERF_KPC_CODE(3)
PERF_KPC_CONFIG PERF_KPC_CODE(4)
PERF_KPC_CFG_REG PERF_KPC_CODE(5)
PERF_KPC_DATA32 PERF_KPC_CODE(6)
PERF_KPC_CFG_REG32 PERF_KPC_CODE(7)
PERF_KPC_DATA_THREAD PERF_KPC_CODE(8)
PERF_KPC_DATA_THREAD32 PERF_KPC_CODE(9)
PERF_KPC_CPU_SAMPLE PERF_KPC_CODE(10)
PERF_KPC_THREAD_SAMPLE PERF_KPC_CODE(11)
PERF_KDBG_CODE(code) PERF_CODE(PERF_KDBG, code)
PERF_KDBG_HNDLR PERF_KDBG_CODE(0)
PERF_TK_CODE(code) PERF_CODE(PERF_TASK, code)
PERF_TK_SNAP_SAMPLE PERF_TK_CODE(0)
PERF_TK_SNAP_DATA PERF_TK_CODE(1)
PERF_TK_SNAP_DATA1_32 PERF_TK_CODE(2)
PERF_TK_SNAP_DATA2_32 PERF_TK_CODE(3)
PERF_TK_INFO_DATA PERF_TK_CODE(4)
PERF_LZ_CODE(code) PERF_CODE(PERF_LAZY, code)
PERF_LZ_MKRUNNABLE PERF_LZ_CODE(0)
PERF_LZ_WAITSAMPLE PERF_LZ_CODE(1)
PERF_LZ_CPUSAMPLE PERF_LZ_CODE(2)
PERF_MI_CODE(code) PERF_CODE(PERF_MEMINFO, code)
PERF_MI_SAMPLE PERF_MI_CODE(0)
PERF_MI_DATA PERF_MI_CODE(1)
PERF_MI_SYS_DATA PERF_MI_CODE(2)
PERF_MI_SYS_DATA_2 PERF_MI_CODE(3)
PERF_MI_SYS_DATA_3 PERF_MI_CODE(4)
KPERF_DEBUG_DATA 0
KPERF_DEBUG_INFO 1
KPERF_DEBUG_VERBOSE 2
BUF_DATA(EVENTID, ...) KDBG_RELEASE(EVENTID, ## __VA_ARGS__)
BUF_INFO(EVENTID, ...)                          BUF_INFO_(EVENTID, ## __VA_ARGS__, 4, 3, 2, 1, 0)
BUF_INFO_(EVENTID, A1, A2, A3, A4, N_ARGS, ...) BUF_INFO##N_ARGS(EVENTID, A1, A2, A3, A4)
BUF_INFO0(EVENTID, A1, A2, A3, A4)              BUF_INFO_INT(EVENTID, 0, 0, 0, 0)
BUF_INFO1(EVENTID, A1, A2, A3, A4)              BUF_INFO_INT(EVENTID, A1, 0, 0, 0)
BUF_INFO2(EVENTID, A1, A2, A3, A4)              BUF_INFO_INT(EVENTID, A1, A2, 0, 0)
BUF_INFO3(EVENTID, A1, A2, A3, A4)              BUF_INFO_INT(EVENTID, A1, A2, A3, 0)
BUF_INFO4(EVENTID, A1, A2, A3, A4)              BUF_INFO_INT(EVENTID, A1, A2, A3, A4)
BUF_VERB(EVENTID, ...)                          BUF_VERB_(EVENTID, ## __VA_ARGS__, 4, 3, 2, 1, 0)
BUF_VERB_(EVENTID, A1, A2, A3, A4, N_ARGS, ...) BUF_VERB##N_ARGS(EVENTID, A1, A2, A3, A4)
BUF_VERB0(EVENTID, A1, A2, A3, A4)              BUF_VERB_INT(EVENTID, 0, 0, 0, 0)
BUF_VERB1(EVENTID, A1, A2, A3, A4)              BUF_VERB_INT(EVENTID, A1, 0, 0, 0)
BUF_VERB2(EVENTID, A1, A2, A3, A4)              BUF_VERB_INT(EVENTID, A1, A2, 0, 0)
BUF_VERB3(EVENTID, A1, A2, A3, A4)              BUF_VERB_INT(EVENTID, A1, A2, A3, 0)
BUF_VERB4(EVENTID, A1, A2, A3, A4)              BUF_VERB_INT(EVENTID, A1, A2, A3, A4)
CS_FLAG_EXTRASP 1
KPERF_CALLSTACK_H None
KPERF_CONTEXT_H None
DECODE_TYPE(TYPES, I) ((((uint8_t *)(TYPES))[(I) / 2] >> ((I) % 2) * 4) & 0xf)
KPERF_KDEBUG_TRIGGER_H None
KPERF_H None
__KPERF_BSD_H__ None
__KPERF_KPC_H__ None
KPERF_KPTIMER_H None
KPERF_LAZY_H None
__KPERF_MEMINFO_H__ None
KPERF_PET_DEFAULT_IDLE_RATE 15
KPERF_SAMPLE_H None
KPERF_TASK_SAMPLERS_H None
KPERF_THREAD_SAMPLERS_H None
kpthsc_requested_qos_ipc_override kpthsc_requested_qos_kevent_override
_MACH_STDLIB_H_ None
_MACH_TYPES_H_ None
_SIZE_T None
makedev(i, j)    ((((i) & 0xFF) << 8) | ((j) & 0xFF))
_LOCKD_MACH_TYPES_H_ None
NFSV3_MAX_FH_SIZE 64
_MACH_BOOLEAN_H_ None
TRUE 1
FALSE 0
_MACH_BOOTSTRAP_H_ None
_MACH_CLOCK_TYPES_H_ None
SYSTEM_CLOCK 0
CALENDAR_CLOCK 1
REALTIME_CLOCK 0
CLOCK_GET_TIME_RES 1
CLOCK_ALARM_CURRES 3
CLOCK_ALARM_MINRES 4
CLOCK_ALARM_MAXRES 5
NSEC_PER_USEC 1000ull
USEC_PER_SEC 1000000ull
NSEC_PER_SEC 1000000000ull
NSEC_PER_MSEC 1000000ull
CMP_MACH_TIMESPEC(t1, t2)                                  	((t1)->tv_sec > (t2)->tv_sec ? (long) +NSEC_PER_SEC :          	((t1)->tv_sec < (t2)->tv_sec ? (long) -NSEC_PER_SEC :          	                (t1)->tv_nsec - (t2)->tv_nsec))
ADD_MACH_TIMESPEC(t1, t2)                                    do {                                                             	if (((t1)->tv_nsec += (t2)->tv_nsec) >= (long) NSEC_PER_SEC) { 	        (t1)->tv_nsec -= (long) NSEC_PER_SEC;                  	        (t1)->tv_sec  += 1;                                    	}                                                              	(t1)->tv_sec += (t2)->tv_sec;                                    } while (0)
SUB_MACH_TIMESPEC(t1, t2)                                    do {                                                             	if (((t1)->tv_nsec -= (t2)->tv_nsec) < 0) {                    	        (t1)->tv_nsec += (long) NSEC_PER_SEC;                  	        (t1)->tv_sec  -= 1;                                    	}                                                              	(t1)->tv_sec -= (t2)->tv_sec;                                    } while (0)
ALRMTYPE 0xff
TIME_ABSOLUTE 0x00
TIME_RELATIVE 0x01
_MACH_COALITION_H_ None
COALITION_SPAWN_ENTITLEMENT "com.apple.private.coalition-spawn"
COALITION_CREATE_FLAGS_SET_TYPE(flags, type) 	do { 	        flags &= ~COALITION_CREATE_FLAGS_TYPE_MASK; 	        flags |= (((type) << COALITION_CREATE_FLAGS_TYPE_SHIFT) 	                   & COALITION_CREATE_FLAGS_TYPE_MASK); 	} while (0)
COALITION_CREATE_FLAGS_SET_ROLE(flags, role)     do { 	flags &= ~COALITION_CREATE_FLAGS_ROLE_MASK; 	flags |= (((role) << COALITION_CREATE_FLAGS_ROLE_SHIFT) 	       & COALITION_CREATE_FLAGS_ROLE_MASK);     } while (0)
COALITION_NUM_THREAD_QOS_TYPES 7
COALITION_ID_KERNEL 1
COALITION_OP_CREATE 1
COALITION_OP_TERMINATE 2
COALITION_OP_REAP 3
COALITION_INFO_RESOURCE_USAGE 1
COALITION_INFO_SET_NAME 2
COALITION_INFO_SET_EFFICIENCY 3
COALITION_INFO_GET_DEBUG_INFO 4
COALITION_LEDGER_SET_LOGICAL_WRITES_LIMIT 1
_DOUBLEAGENT_TYPES_H_ None
DA_XATTR_MAXNAMELEN 127
DA_XATTR_FINDERINFO_NAME "com.apple.FinderInfo"
DA_XATTR_RESOURCEFORK_NAME "com.apple.ResourceFork"
MAX_NUM_OF_XATTRS 256
_MACH_DYLIB_INFO_H_ None
dyldLogFunc(msg, ...) kprintf(msg, ## __VA_ARGS__)
LogFixups 0
_MACH_DYLD_PAGER_H_ None
MWL_INFO_VERS 7
MWL_MAX_REGION_COUNT 5
_MACH_ERROR_H_ None
err_kern err_system(0x0)
err_us err_system(0x1)
err_server err_system(0x2)
err_ipc err_system(0x3)
err_mach_ipc err_system(0x4)
err_dipc err_system(0x7)
err_vm err_system(0x8)
err_local err_system(0x3e)
err_ipc_compat err_system(0x3f)
err_max_system 0x3f
_MACH_EVENTS_INFO_H_ None
_MACH_EXCEPTION_H_ None
_MACH_EXCEPTION_TYPES_H_ None
EXC_BAD_ACCESS 1
EXC_BAD_INSTRUCTION 2
EXC_ARITHMETIC 3
EXC_EMULATION 4
EXC_SOFTWARE 5
EXC_BREAKPOINT 6
EXC_SYSCALL 7
EXC_MACH_SYSCALL 8
EXC_RPC_ALERT 9
EXC_CRASH 10
EXC_RESOURCE 11
EXC_GUARD 12
EXC_CORPSE_NOTIFY 13
EXCEPTION_DEFAULT 1
EXCEPTION_STATE 2
EXCEPTION_STATE_IDENTITY 3
EXCEPTION_IDENTITY_PROTECTED 4
EXCEPTION_STATE_IDENTITY_PROTECTED 5
MACH_EXCEPTION_BACKTRACE_PREFERRED 0x20000000
MACH_EXCEPTION_ERRORS 0x40000000
MACH_EXCEPTION_CODES 0x80000000
FIRST_EXCEPTION 1
EXC_SOFT_SIGNAL 0x10003
EXC_MACF_MIN 0x20000
EXC_MACF_MAX 0x2FFFF
_MACH_EXCLAVES_H None
MAX_CONCLAVE_RESOURCE_NUM 50
EXCLAVES_CTL_OP_AND_FLAGS(op, flags) 	((uint32_t)EXCLAVES_CTL_OP_##op << 24 | 	((uint32_t)(flags) & EXCLAVES_CTL_FLAGS_MASK))
_MACH_EXCLAVES_L4_H None
__Exclaves_L4_Packed __attribute__ ((__packed__))
Exclaves_L4_BfmW(base, bits)     (((~Exclaves_L4_Word(0)) >> (Exclaves_L4_WordBits - (bits))) << (base))
Exclaves_L4_BfxW(bitfield, base, bits)     (((bitfield) & Exclaves_L4_BfmW((base), (bits))) >> (base))
Exclaves_L4_BfiW(bitfield, base, bits, value)     (((bitfield) & (~Exclaves_L4_BfmW((base), (bits)))) | 	(((Exclaves_L4_Word(value)) << (base)) & Exclaves_L4_BfmW((base), (bits))))
Exclaves_L4_BfW(base, bits, value)     (Exclaves_L4_BfiW(Exclaves_L4_Word(0), (base), (bits), (value)))
Exclaves_L4_Error(code, value) (((Exclaves_L4_Word(value)) << 8) | (Exclaves_L4_Word(code)))
Exclaves_L4_Success Exclaves_L4_Error(Exclaves_L4_ErrorCodeSuccess, Exclaves_L4_Nil)
Exclaves_L4_Preempted Exclaves_L4_Error(Exclaves_L4_ErrorCodePreempted, Exclaves_L4_Nil)
Exclaves_L4_ErrorCanceled(reason) Exclaves_L4_Error(Exclaves_L4_ErrorCodeCanceled, reason)
Exclaves_L4_ErrorTruncated Exclaves_L4_Error(Exclaves_L4_ErrorCodeTruncated, Exclaves_L4_Nil)
Exclaves_L4_ErrorCapInvalid Exclaves_L4_Error(Exclaves_L4_ErrorCodeCapInvalid, Exclaves_L4_Nil)
Exclaves_L4_ErrorSlotInvalid Exclaves_L4_Error(Exclaves_L4_ErrorCodeSlotInvalid, Exclaves_L4_Nil)
Exclaves_L4_ErrorMethodInvalid Exclaves_L4_Error(Exclaves_L4_ErrorCodeMethodInvalid, Exclaves_L4_Nil)
Exclaves_L4_ErrorArgumentInvalid(argument) Exclaves_L4_Error(Exclaves_L4_ErrorCodeArgumentInvalid, argument)
Exclaves_L4_ErrorOperationInvalid Exclaves_L4_Error(Exclaves_L4_ErrorCodeOperationInvalid, Exclaves_L4_Nil)
Exclaves_L4_ErrorPermissionInvalid Exclaves_L4_Error(Exclaves_L4_ErrorCodePermissionInvalid, Exclaves_L4_Nil)
Exclaves_L4_MessageTag_Mrs_Base 0
Exclaves_L4_MessageTag_Mrs_Bits 6
Exclaves_L4_MessageTag_Crs_Base 6
Exclaves_L4_MessageTag_Crs_Bits 3
Exclaves_L4_MessageTag_Unwrapped_Base 9
Exclaves_L4_MessageTag_Unwrapped_Bits 3
Exclaves_L4_MessageTag_NonBlocking_Base 12
Exclaves_L4_MessageTag_NonBlocking_Bits 1
Exclaves_L4_MessageTag_Label_Base 16
Exclaves_L4_MessageTag_Label_Bits 16
Exclaves_L4_IpcBuffer_Mrs 56
Exclaves_L4_IpcBuffer_Crs 4
_MACH_HOST_INFO_H_ None
HOST_BASIC_INFO 1
HOST_SCHED_INFO 3
HOST_RESOURCE_SIZES 4
HOST_PRIORITY_INFO 5
HOST_SEMAPHORE_TRAPS 7
HOST_MACH_MSG_TRAP 8
HOST_VM_PURGABLE 9
HOST_DEBUG_INFO_INTERNAL 10
HOST_CAN_HAS_DEBUGGER 11
HOST_PREFERRED_USER_ARCH 12
HOST_LOAD_INFO 1
HOST_VM_INFO 2
HOST_CPU_LOAD_INFO 3
HOST_VM_INFO64 4
HOST_EXTMOD_INFO64 5
HOST_EXPIRED_TASK_INFO 6
HOST_VM_COMPRESSOR_Q_LENS 7
VM_COMPRESSOR_Q_LENS_COUNT sizeof(struct vm_compressor_q_lens)/sizeof(integer_t)
HOST_VM_INFO64_LATEST_COUNT HOST_VM_INFO64_COUNT
HOST_VM_INFO64_REV1_COUNT HOST_VM_INFO64_LATEST_COUNT
HOST_EXTMOD_INFO64_LATEST_COUNT HOST_EXTMOD_INFO64_COUNT
HOST_VM_INFO_LATEST_COUNT HOST_VM_INFO_COUNT
HOST_VM_INFO_REV2_COUNT HOST_VM_INFO_LATEST_COUNT
_MACH_HOST_NOTIFY_H_ None
HOST_NOTIFY_CALENDAR_CHANGE 0
HOST_NOTIFY_CALENDAR_SET 1
HOST_NOTIFY_TYPE_MAX 1
HOST_CALENDAR_CHANGED_REPLYID 950
HOST_CALENDAR_SET_REPLYID 951
_MACH_HOST_REBOOT_ None
HOST_REBOOT_HALT 0x0008
HOST_REBOOT_UPSDELAY 0x0100
HOST_REBOOT_DEBUGGER 0x1000
_MACH_HOST_SPECIAL_PORTS_H_ None
HOST_SECURITY_PORT 0
HOST_MIN_SPECIAL_PORT HOST_SECURITY_PORT
HOST_PORT 1
HOST_PRIV_PORT 2
HOST_IO_MAIN_PORT 3
HOST_MAX_SPECIAL_KERNEL_PORT 7
HOST_LAST_SPECIAL_KERNEL_PORT HOST_IO_MAIN_PORT
HOST_MAX_SPECIAL_PORT HOST_DOUBLEAGENTD_PORT
HOST_CHUD_PORT HOST_LAUNCHCTL_PORT
HOST_LOCAL_NODE -1
host_get_host_port(host, port)  	(host_get_special_port((host),  	HOST_LOCAL_NODE, HOST_PORT, (port)))
host_set_host_port(host, port) (KERN_INVALID_ARGUMENT)
host_get_host_priv_port(host, port)     	(host_get_special_port((host),          	HOST_LOCAL_NODE, HOST_PRIV_PORT, (port)))
host_set_host_priv_port(host, port) (KERN_INVALID_ARGUMENT)
host_get_io_main_port(host, port)     	(host_get_special_port((host),          	HOST_LOCAL_NODE, HOST_IO_MAIN_PORT, (port)))
host_set_io_main_port(host, port) (KERN_INVALID_ARGUMENT)
host_get_dynamic_pager_port(host, port) 	(host_get_special_port((host),                  	HOST_LOCAL_NODE, HOST_DYNAMIC_PAGER_PORT, (port)))
host_set_dynamic_pager_port(host, port) 	(host_set_special_port((host), HOST_DYNAMIC_PAGER_PORT, (port)))
host_get_audit_control_port(host, port) 	(host_get_special_port((host),          	HOST_LOCAL_NODE, HOST_AUDIT_CONTROL_PORT, (port)))
host_set_audit_control_port(host, port) 	(host_set_special_port((host), HOST_AUDIT_CONTROL_PORT, (port)))
host_get_user_notification_port(host, port)     	(host_get_special_port((host),                  	HOST_LOCAL_NODE, HOST_USER_NOTIFICATION_PORT, (port)))
host_set_user_notification_port(host, port)     	(host_set_special_port((host), HOST_USER_NOTIFICATION_PORT, (port)))
host_get_automountd_port(host, port)    	(host_get_special_port((host),          	HOST_LOCAL_NODE, HOST_AUTOMOUNTD_PORT, (port)))
host_set_automountd_port(host, port)    	(host_set_special_port((host), HOST_AUTOMOUNTD_PORT, (port)))
host_get_lockd_port(host, port) 	(host_get_special_port((host),                  	HOST_LOCAL_NODE, HOST_LOCKD_PORT, (port)))
host_set_lockd_port(host, port) 	(host_set_special_port((host), HOST_LOCKD_PORT, (port)))
host_get_ktrace_background_port(host, port)     	(host_get_special_port((host),                  	HOST_LOCAL_NODE, HOST_KTRACE_BACKGROUND_PORT, (port)))
host_set_ktrace_background_port(host, port)     	(host_set_special_port((host), HOST_KTRACE_BACKGROUND_PORT, (port)))
host_get_kextd_port(host, port) 	(host_get_special_port((host),                  	HOST_LOCAL_NODE, HOST_KEXTD_PORT, (port)))
host_set_kextd_port(host, port) 	(host_set_special_port((host), HOST_KEXTD_PORT, (port)))
host_get_launchctl_port(host, port) 	(host_get_special_port((host), HOST_LOCAL_NODE, HOST_LAUNCHCTL_PORT, 	(port)))
host_set_launchctl_port(host, port) 	(host_set_special_port((host), HOST_LAUNCHCTL_PORT, (port)))
host_get_chud_port(host, port) host_get_launchctl_port(host, port)
host_set_chud_port(host, port) host_set_launchctl_port(host, port)
host_get_unfreed_port(host, port)       	(host_get_special_port((host),                  	HOST_LOCAL_NODE, HOST_UNFREED_PORT, (port)))
host_set_unfreed_port(host, port)       	(host_set_special_port((host), HOST_UNFREED_PORT, (port)))
host_get_amfid_port(host, port) 	(host_get_special_port((host),                  	HOST_LOCAL_NODE, HOST_AMFID_PORT, (port)))
host_set_amfid_port(host, port) 	(host_set_special_port((host), HOST_AMFID_PORT, (port)))
host_get_gssd_port(host, port)  	(host_get_special_port((host),                  	HOST_LOCAL_NODE, HOST_GSSD_PORT, (port)))
host_set_gssd_port(host, port)  	(host_set_special_port((host), HOST_GSSD_PORT, (port)))
host_get_telemetry_port(host, port)     	(host_get_special_port((host),                  	HOST_LOCAL_NODE, HOST_TELEMETRY_PORT, (port)))
host_set_telemetry_port(host, port)     	(host_set_special_port((host), HOST_TELEMETRY_PORT, (port)))
host_get_atm_notification_port(host, port)      	(host_get_special_port((host),                  	HOST_LOCAL_NODE, HOST_ATM_NOTIFICATION_PORT, (port)))
host_set_atm_notification_port(host, port)      	(host_set_special_port((host), HOST_ATM_NOTIFICATION_PORT, (port)))
host_get_coalition_port(host, port)     	(host_get_special_port((host),                  	HOST_LOCAL_NODE, HOST_COALITION_PORT, (port)))
host_set_coalition_port(host, port)     	(host_set_special_port((host), HOST_COALITION_PORT, (port)))
host_get_sysdiagnose_port(host, port)   	(host_get_special_port((host),                  	HOST_LOCAL_NODE, HOST_SYSDIAGNOSE_PORT, (port)))
host_set_sysdiagnose_port(host, port)   	(host_set_special_port((host), HOST_SYSDIAGNOSE_PORT, (port)))
host_get_container_port(host, port)     	(host_get_special_port((host),                  	HOST_LOCAL_NODE, HOST_CONTAINERD_PORT, (port)))
host_set_container_port(host, port)     	(host_set_special_port((host), HOST_CONTAINERD_PORT, (port)))
host_get_node_port(host, port)  	(host_get_special_port((host),                  	HOST_LOCAL_NODE, HOST_NODE_PORT, (port)))
host_set_node_port(host, port)  	(host_set_special_port((host), HOST_NODE_PORT, (port)))
host_get_closured_port(host, port)      	(host_get_special_port((host),                  	HOST_LOCAL_NODE, HOST_CLOSURED_PORT, (port)))
host_set_closured_port(host, port)      	(host_set_special_port((host), HOST_CLOSURED_PORT, (port)))
host_get_syspolicyd_port(host, port)    	(host_get_special_port((host),                          	HOST_LOCAL_NODE, HOST_SYSPOLICYD_PORT, (port)))
host_set_syspolicyd_port(host, port)    	(host_set_special_port((host), HOST_SYSPOLICYD_PORT, (port)))
host_get_filecoordinationd_port(host, port)     	(host_get_special_port((host),                  	HOST_LOCAL_NODE, HOST_FILECOORDINATIOND_PORT, (port)))
host_set_filecoordinationd_port(host, port)     	(host_set_special_port((host), HOST_FILECOORDINATIOND_PORT, (port)))
host_get_fairplayd_port(host, port)     	(host_get_special_port((host),                  	HOST_LOCAL_NODE, HOST_FAIRPLAYD_PORT, (port)))
host_set_fairplayd_port(host, port)     	(host_set_special_port((host), HOST_FAIRPLAYD_PORT, (port)))
host_get_iocompressionstats_port(host, port)     	(host_get_special_port((host),                  	HOST_LOCAL_NODE, HOST_IOCOMPRESSIONSTATS_PORT, (port)))
host_set_iocompressionstats_port(host, port)     	(host_set_special_port((host), HOST_IOCOMPRESSIONSTATS_PORT, (port)))
host_get_memory_error_port(host, port)     	(host_get_special_port((host),                  	HOST_LOCAL_NODE, HOST_MEMORY_ERROR_PORT, (port)))
host_set_memory_error_port(host, port)     	(host_set_special_port((host), HOST_MEMORY_ERROR_PORT, (port)))
host_get_managedappdistd_port(host, port)     	(host_get_special_port((host),                  	HOST_LOCAL_NODE, HOST_MANAGEDAPPDISTD_PORT, (port)))
host_set_managedappdistd_port(host, port)     	(host_set_special_port((host), HOST_MANAGEDAPPDISTD_PORT, (port)))
host_get_doubleagentd_port(host, port)     	(host_get_special_port((host),                  	HOST_LOCAL_NODE, HOST_DOUBLEAGENTD_PORT, (port)))
host_set_doubleagentd_port(host, port)     	(host_set_special_port((host), HOST_DOUBLEAGENTD_PORT, (port)))
_MACH_KERN_RETURN_H_ None
KERN_SUCCESS 0
KERN_INVALID_ADDRESS 1
KERN_PROTECTION_FAILURE 2
KERN_NO_SPACE 3
KERN_INVALID_ARGUMENT 4
KERN_FAILURE 5
KERN_RESOURCE_SHORTAGE 6
KERN_NOT_RECEIVER 7
KERN_NO_ACCESS 8
KERN_MEMORY_FAILURE 9
KERN_MEMORY_ERROR 10
KERN_ALREADY_IN_SET 11
KERN_NOT_IN_SET 12
KERN_NAME_EXISTS 13
KERN_ABORTED 14
KERN_INVALID_NAME 15
KERN_INVALID_TASK 16
KERN_INVALID_RIGHT 17
KERN_INVALID_VALUE 18
KERN_UREFS_OVERFLOW 19
KERN_INVALID_CAPABILITY 20
KERN_RIGHT_EXISTS 21
KERN_INVALID_HOST 22
KERN_MEMORY_PRESENT 23
KERN_MEMORY_DATA_MOVED 24
KERN_MEMORY_RESTART_COPY 25
KERN_INVALID_PROCESSOR_SET 26
KERN_POLICY_LIMIT 27
KERN_INVALID_POLICY 28
KERN_INVALID_OBJECT 29
KERN_ALREADY_WAITING 30
KERN_DEFAULT_SET 31
KERN_EXCEPTION_PROTECTED 32
KERN_INVALID_LEDGER 33
KERN_INVALID_MEMORY_CONTROL 34
KERN_INVALID_SECURITY 35
KERN_NOT_DEPRESSED 36
KERN_TERMINATED 37
KERN_LOCK_SET_DESTROYED 38
KERN_LOCK_UNSTABLE 39
KERN_LOCK_OWNED 40
KERN_LOCK_OWNED_SELF 41
KERN_SEMAPHORE_DESTROYED 42
KERN_RPC_SERVER_TERMINATED 43
KERN_RPC_TERMINATE_ORPHAN 44
KERN_RPC_CONTINUE_ORPHAN 45
KERN_NOT_SUPPORTED 46
KERN_NODE_DOWN 47
KERN_NOT_WAITING 48
KERN_OPERATION_TIMED_OUT 49
KERN_CODESIGN_ERROR 50
KERN_POLICY_STATIC 51
KERN_INSUFFICIENT_BUFFER_SIZE 52
KERN_DENIED 53
KERN_MISSING_KC 54
KERN_INVALID_KC 55
KERN_NOT_FOUND 56
KERN_RETURN_MAX 0x100
_MACH_KMOD_H_ None
KMOD_MAX_NAME 64
KMOD_RETURN_SUCCESS KERN_SUCCESS
KMOD_RETURN_FAILURE KERN_FAILURE
KMOD_INFO_NAME kmod_info
KMOD_INFO_VERSION 1
KMOD_DECL(name, version)                                      static kmod_start_func_t name ## _module_start;                   static kmod_stop_func_t  name ## _module_stop;                    kmod_info_t KMOD_INFO_NAME = { 0, KMOD_INFO_VERSION, -1U,      	               { #name }, { version }, -1, 0, 0, 0, 0,    	                   name ## _module_start,                 	                   name ## _module_stop };
KMOD_EXPLICIT_DECL(name, version, start, stop)                kmod_info_t KMOD_INFO_NAME = { 0, KMOD_INFO_VERSION, -1U,      	               { #name }, { version }, -1, 0, 0, 0, 0,    	                   start, stop };
KMOD_DTRACE_FORCE_INIT 0x01
KMOD_DTRACE_STATIC_KEXT 0x02
KMOD_DTRACE_NO_KERNEL_SYMS 0x04
_MACH_H_ None
_MACH_MACHINE_H_ None
CPU_STATE_MAX 4
CPU_STATE_USER 0
CPU_STATE_SYSTEM 1
CPU_STATE_IDLE 2
CPU_STATE_NICE 3
CPU_ARCH_MASK 0xff000000
CPU_ARCH_ABI64 0x01000000
CPU_ARCH_ABI64_32 0x02000000
CPU_TYPE_I386 CPU_TYPE_X86
CPU_SUBTYPE_MASK 0xff000000
CPU_SUBTYPE_LIB64 0x80000000
CPU_SUBTYPE_PTRAUTH_ABI 0x80000000
CPU_SUBTYPE_INTEL(f, m) ((cpu_subtype_t) (f) + ((m) << 4))
CPU_SUBTYPE_I386_ALL CPU_SUBTYPE_INTEL(3, 0)
CPU_SUBTYPE_386 CPU_SUBTYPE_INTEL(3, 0)
CPU_SUBTYPE_486 CPU_SUBTYPE_INTEL(4, 0)
CPU_SUBTYPE_486SX CPU_SUBTYPE_INTEL(4, 8)
CPU_SUBTYPE_586 CPU_SUBTYPE_INTEL(5, 0)
CPU_SUBTYPE_PENT CPU_SUBTYPE_INTEL(5, 0)
CPU_SUBTYPE_PENTPRO CPU_SUBTYPE_INTEL(6, 1)
CPU_SUBTYPE_PENTII_M3 CPU_SUBTYPE_INTEL(6, 3)
CPU_SUBTYPE_PENTII_M5 CPU_SUBTYPE_INTEL(6, 5)
CPU_SUBTYPE_CELERON CPU_SUBTYPE_INTEL(7, 6)
CPU_SUBTYPE_CELERON_MOBILE CPU_SUBTYPE_INTEL(7, 7)
CPU_SUBTYPE_PENTIUM_3 CPU_SUBTYPE_INTEL(8, 0)
CPU_SUBTYPE_PENTIUM_3_M CPU_SUBTYPE_INTEL(8, 1)
CPU_SUBTYPE_PENTIUM_3_XEON CPU_SUBTYPE_INTEL(8, 2)
CPU_SUBTYPE_PENTIUM_M CPU_SUBTYPE_INTEL(9, 0)
CPU_SUBTYPE_PENTIUM_4 CPU_SUBTYPE_INTEL(10, 0)
CPU_SUBTYPE_PENTIUM_4_M CPU_SUBTYPE_INTEL(10, 1)
CPU_SUBTYPE_ITANIUM CPU_SUBTYPE_INTEL(11, 0)
CPU_SUBTYPE_ITANIUM_2 CPU_SUBTYPE_INTEL(11, 1)
CPU_SUBTYPE_XEON CPU_SUBTYPE_INTEL(12, 0)
CPU_SUBTYPE_XEON_MP CPU_SUBTYPE_INTEL(12, 1)
CPU_SUBTYPE_INTEL_FAMILY_MAX 15
CPU_SUBTYPE_INTEL_MODEL_ALL 0
CPU_SUBTYPE_ARM64_PTR_AUTH_MASK 0x0f000000
CPU_SUBTYPE_ARM64_PTR_AUTH_CURRENT_VERSION 0
CPUFAMILY_UNKNOWN 0
CPUFAMILY_POWERPC_G3 0xcee41549
CPUFAMILY_POWERPC_G4 0x77c184ae
CPUFAMILY_POWERPC_G5 0xed76d8aa
CPUFAMILY_INTEL_6_13 0xaa33392b
CPUFAMILY_INTEL_PENRYN 0x78ea4fbc
CPUFAMILY_INTEL_NEHALEM 0x6b5a4cd2
CPUFAMILY_INTEL_WESTMERE 0x573b5eec
CPUFAMILY_INTEL_SANDYBRIDGE 0x5490b78c
CPUFAMILY_INTEL_IVYBRIDGE 0x1f65e835
CPUFAMILY_INTEL_HASWELL 0x10b282dc
CPUFAMILY_INTEL_BROADWELL 0x582ed09c
CPUFAMILY_INTEL_SKYLAKE 0x37fc219f
CPUFAMILY_INTEL_KABYLAKE 0x0f817246
CPUFAMILY_INTEL_ICELAKE 0x38435547
CPUFAMILY_INTEL_COMETLAKE 0x1cf8a03e
CPUFAMILY_ARM_9 0xe73283ae
CPUFAMILY_ARM_11 0x8ff620d8
CPUFAMILY_ARM_XSCALE 0x53b005f5
CPUFAMILY_ARM_12 0xbd1b0ae9
CPUFAMILY_ARM_13 0x0cc90e64
CPUFAMILY_ARM_14 0x96077ef1
CPUFAMILY_ARM_15 0xa8511bca
CPUFAMILY_ARM_SWIFT 0x1e2d6381
CPUFAMILY_ARM_CYCLONE 0x37a09642
CPUFAMILY_ARM_TYPHOON 0x2c91a47e
CPUFAMILY_ARM_TWISTER 0x92fb37c8
CPUFAMILY_ARM_HURRICANE 0x67ceee93
CPUFAMILY_ARM_MONSOON_MISTRAL 0xe81e7ef6
CPUFAMILY_ARM_VORTEX_TEMPEST 0x07d34b9f
CPUFAMILY_ARM_LIGHTNING_THUNDER 0x462504d2
CPUFAMILY_ARM_FIRESTORM_ICESTORM 0x1b588bb3
CPUFAMILY_ARM_BLIZZARD_AVALANCHE 0xda33d83d
CPUFAMILY_ARM_EVEREST_SAWTOOTH 0x8765edea
CPUFAMILY_ARM_IBIZA 0xfa33415e
CPUFAMILY_ARM_PALMA 0x72015832
CPUFAMILY_ARM_COLL 0x2876f5b5
CPUFAMILY_ARM_LOBOS 0x5f4dea93
CPUFAMILY_ARM_DONAN 0x6f5129ac
CPUFAMILY_ARM_BRAVA 0x17d5b93a
CPUSUBFAMILY_UNKNOWN 0
CPUSUBFAMILY_ARM_HP 1
CPUSUBFAMILY_ARM_HG 2
CPUSUBFAMILY_ARM_M 3
CPUSUBFAMILY_ARM_HS 4
CPUSUBFAMILY_ARM_HC_HD 5
CPUSUBFAMILY_ARM_HA 6
CPUFAMILY_INTEL_6_23 CPUFAMILY_INTEL_PENRYN
CPUFAMILY_INTEL_6_26 CPUFAMILY_INTEL_NEHALEM
_MACH_EVENTLINK_TYPES_H_ None
EVENTLINK_SIGNAL_COUNT_MASK 0xffffffffffffff
EVENTLINK_SIGNAL_ERROR_MASK 0xff
EVENTLINK_SIGNAL_ERROR_SHIFT 56
encode_eventlink_count_and_error(count, error) 	(((count) & EVENTLINK_SIGNAL_COUNT_MASK) | ((((uint64_t)error) & EVENTLINK_SIGNAL_ERROR_MASK) << EVENTLINK_SIGNAL_ERROR_SHIFT))
_MACH_INTERFACE_H_ None
_MACH_MACH_PARAM_H_ None
TASK_PORT_REGISTER_MAX 3
TASK_MAX_WATCHPORT_COUNT 128
TASK_MAX_EXCEPTION_PORT_COUNT EXC_TYPES_COUNT
TASK_SELF_PORT_COUNT 4
THREAD_SELF_PORT_COUNT 3
MAXCONCLAVENAME 128
_MACH_MACH_SYSCALLS_H_ None
_MACH_MACH_TIME_H_ None
_MACH_MACH_TIME_PRIVATE_H_ None
_MACH_MACH_TRAPS_H_ None
_MACH_MACH_TYPES_H_ None
TASK_FLAVOR_CONTROL 0
TASK_FLAVOR_READ 1
TASK_FLAVOR_INSPECT 2
TASK_FLAVOR_NAME 3
TASK_FLAVOR_MAX TASK_FLAVOR_NAME
THREAD_FLAVOR_CONTROL 0
THREAD_FLAVOR_READ 1
THREAD_FLAVOR_INSPECT 2
THREAD_FLAVOR_MAX THREAD_FLAVOR_INSPECT
_MACH_VOUCHER_TYPES_H_ None
MACH_VOUCHER_ATTR_KEY_BITS MACH_VOUCHER_ATTR_KEY_USER_DATA
MACH_VOUCHER_ATTR_KEY_NUM_WELL_KNOWN MACH_VOUCHER_ATTR_KEY_TEST
MACH_VOUCHER_ATTR_BITS_STORE MACH_VOUCHER_ATTR_USER_DATA_STORE
MACH_VOUCHER_ATTR_TEST_STORE MACH_VOUCHER_ATTR_USER_DATA_STORE
MACH_VOUCHER_ATTR_MAX_RAW_RECIPE_ARRAY_SIZE 5120
MACH_VOUCHER_TRAP_STACK_LIMIT 256
MACH_VOUCHER_IMPORTANCE_ATTR_ADD_EXTERNAL 1
MACH_VOUCHER_IMPORTANCE_ATTR_DROP_EXTERNAL 2
MACH_ACTIVITY_ID_COUNT_MAX 16
_MACH_MEMORY_OBJECT_H_ None
_MACH_MEMORY_OBJECT_CONTROL_ None
_MACH_MEMORY_OBJECT_TYPES_H_ None
MEMORY_OBJECT_HAS_REFCOUNT 1
VM_64_BIT_DATA_OBJECTS None
MEMORY_OBJECT_COPY_NONE 0
MEMORY_OBJECT_COPY_CALL 1
MEMORY_OBJECT_COPY_DELAY 2
MEMORY_OBJECT_COPY_TEMPORARY 3
MEMORY_OBJECT_COPY_SYMMETRIC 4
MEMORY_OBJECT_COPY_INVALID 5
MEMORY_OBJECT_COPY_DELAY_FORK 6
MEMORY_OBJECT_RETURN_NONE 0
MEMORY_OBJECT_RETURN_DIRTY 1
MEMORY_OBJECT_RETURN_ALL 2
MEMORY_OBJECT_RETURN_ANYTHING 3
MEMORY_OBJECT_DATA_FLUSH 0x1
MEMORY_OBJECT_DATA_NO_CHANGE 0x2
MEMORY_OBJECT_DATA_PURGE 0x4
MEMORY_OBJECT_COPY_SYNC 0x8
MEMORY_OBJECT_DATA_SYNC 0x10
MEMORY_OBJECT_IO_SYNC 0x20
MEMORY_OBJECT_DATA_FLUSH_ALL 0x40
MEMORY_OBJECT_PERFORMANCE_INFO 11
MEMORY_OBJECT_ATTRIBUTE_INFO 14
MEMORY_OBJECT_BEHAVIOR_INFO 15
OLD_MEMORY_OBJECT_BEHAVIOR_INFO 10
OLD_MEMORY_OBJECT_ATTRIBUTE_INFO 12
MEMORY_OBJECT_TERMINATE_IDLE 0x1
MEMORY_OBJECT_RESPECT_CACHE 0x2
MEMORY_OBJECT_RELEASE_NO_OP 0x4
MAP_MEM_NOOP 0
MAP_MEM_COPYBACK 1
MAP_MEM_IO 2
MAP_MEM_WTHRU 3
MAP_MEM_WCOMB 4
MAP_MEM_INNERWBACK 5
MAP_MEM_POSTED 6
MAP_MEM_RT 7
MAP_MEM_POSTED_REORDERED 8
MAP_MEM_POSTED_COMBINED_REORDERED 9
SET_MAP_MEM(caching, flags)     	((flags) = ((((unsigned int)(caching)) << 24) 	                & 0xFF000000) | ((flags) & 0xFFFFFF));
MAP_MEM_PROT_MASK 0xFF
MAP_MEM_LEDGER_TAGGED 0x002000
MAP_MEM_PURGABLE_KERNEL_ONLY 0x004000
MAP_MEM_GRAB_SECLUDED 0x008000
MAP_MEM_ONLY 0x010000
MAP_MEM_NAMED_CREATE 0x020000
MAP_MEM_PURGABLE 0x040000
MAP_MEM_NAMED_REUSE 0x080000
MAP_MEM_USE_DATA_ADDR 0x100000
MAP_MEM_VM_COPY 0x200000
MAP_MEM_VM_SHARE 0x400000
MAP_MEM_4K_DATA_ADDR 0x800000
MAP_MEM_FLAGS_MASK 0x00FFFF00
VMP_CS_BITS 4
VMP_CS_ALL_FALSE 0x0
VMP_CS_ALL_TRUE 0xF
UPL_FLAGS_NONE 0x00000000ULL
UPL_COPYOUT_FROM 0x00000001ULL
UPL_PRECIOUS 0x00000002ULL
UPL_NO_SYNC 0x00000004ULL
UPL_CLEAN_IN_PLACE 0x00000008ULL
UPL_NOBLOCK 0x00000010ULL
UPL_RET_ONLY_DIRTY 0x00000020ULL
UPL_SET_INTERNAL 0x00000040ULL
UPL_QUERY_OBJECT_TYPE 0x00000080ULL
UPL_RET_ONLY_ABSENT 0x00000100ULL
UPL_FILE_IO 0x00000200ULL
UPL_SET_LITE 0x00000400ULL
UPL_SET_INTERRUPTIBLE 0x00000800ULL
UPL_SET_IO_WIRE 0x00001000ULL
UPL_FOR_PAGEOUT 0x00002000ULL
UPL_WILL_BE_DUMPED 0x00004000ULL
UPL_FORCE_DATA_SYNC 0x00008000ULL
UPL_PAGE_TICKET_MASK 0x000F0000ULL
UPL_PAGE_TICKET_SHIFT 16
UPL_BLOCK_ACCESS 0x00100000ULL
UPL_ENCRYPT 0x00200000ULL
UPL_NOZEROFILL 0x00400000ULL
UPL_WILL_MODIFY 0x00800000ULL
UPL_NEED_32BIT_ADDR 0x01000000ULL
UPL_UBC_MSYNC 0x02000000ULL
UPL_UBC_PAGEOUT 0x04000000ULL
UPL_UBC_PAGEIN 0x08000000ULL
UPL_REQUEST_SET_DIRTY 0x10000000ULL
UPL_REQUEST_NO_FAULT 0x20000000ULL
UPL_NOZEROFILLIO 0x40000000ULL
UPL_REQUEST_FORCE_COHERENCY 0x80000000ULL
UPL_VALID_FLAGS 0xFFFFFFFFFFULL
UPL_ABORT_RESTART 0x1
UPL_ABORT_UNAVAILABLE 0x2
UPL_ABORT_ERROR 0x4
UPL_ABORT_FREE_ON_EMPTY 0x8
UPL_ABORT_DUMP_PAGES 0x10
UPL_ABORT_NOTIFY_EMPTY 0x20
UPL_ABORT_REFERENCE 0x80
UPL_CHECK_DIRTY 0x1
UPL_IOSYNC 0x1
UPL_NOCOMMIT 0x2
UPL_NORDAHEAD 0x4
UPL_VNODE_PAGER 0x8
UPL_MSYNC 0x10
UPL_PAGING_ENCRYPTED 0x20
UPL_KEEPCACHED 0x40
UPL_NESTED_PAGEOUT 0x80
UPL_IOSTREAMING 0x100
UPL_IGNORE_VALID_PAGE_CHECK 0x200
UPL_COMMIT_FREE_ON_EMPTY 0x1
UPL_COMMIT_CLEAR_DIRTY 0x2
UPL_COMMIT_SET_DIRTY 0x4
UPL_COMMIT_INACTIVATE 0x8
UPL_COMMIT_NOTIFY_EMPTY 0x10
UPL_COMMIT_CS_VALIDATED 0x40
UPL_COMMIT_CLEAR_PRECIOUS 0x80
UPL_COMMIT_SPECULATE 0x100
UPL_COMMIT_FREE_ABSENT 0x200
UPL_COMMIT_WRITTEN_BY_KERNEL 0x400
UPL_DEV_MEMORY 0x1
UPL_PHYS_CONTIG 0x2
UPL_POP_DIRTY 0x1
UPL_POP_PAGEOUT 0x2
UPL_POP_PRECIOUS 0x4
UPL_POP_ABSENT 0x8
UPL_POP_BUSY 0x10
UPL_POP_PHYSICAL 0x10000000
UPL_POP_DUMP 0x20000000
UPL_POP_SET 0x40000000
UPL_POP_CLR 0x80000000
UPL_ROP_ABSENT 0x01
UPL_ROP_PRESENT 0x02
UPL_ROP_DUMP 0x04
UPL_REPRIO_INFO_SHIFT 32
UPL_PAGE_PRESENT(upl, index) 	((upl)[(index)].phys_addr != 0)
UPL_PHYS_PAGE(upl, index) 	((upl)[(index)].phys_addr)
UPL_SPECULATIVE_PAGE(upl, index) 	(((upl)[(index)].phys_addr != 0) ? ((upl)[(index)].speculative) : FALSE)
UPL_DIRTY_PAGE(upl, index) 	(((upl)[(index)].phys_addr != 0) ? ((upl)[(index)].dirty) : FALSE)
UPL_PRECIOUS_PAGE(upl, index) 	(((upl)[(index)].phys_addr != 0) ? ((upl)[(index)].precious) : FALSE)
UPL_VALID_PAGE(upl, index) 	(((upl)[(index)].phys_addr != 0) ? (!((upl)[(index)].absent)) : FALSE)
UPL_PAGEOUT_PAGE(upl, index) 	(((upl)[(index)].phys_addr != 0) ? ((upl)[(index)].free_when_done) : FALSE)
UPL_SET_PAGE_FREE_ON_COMMIT(upl, index) 	(((upl)[(index)].phys_addr != 0) ?            	 ((upl)[(index)].free_when_done = TRUE) : FALSE)
UPL_CLR_PAGE_FREE_ON_COMMIT(upl, index) 	(((upl)[(index)].phys_addr != 0) ?       	 ((upl)[(index)].free_when_done = FALSE) : FALSE)
UPL_REPRIO_INFO_BLKNO(upl, index) 	(((upl)->upl_reprio_info[(index)]) & UPL_REPRIO_INFO_MASK)
UPL_REPRIO_INFO_LEN(upl, index) 	((((upl)->upl_reprio_info[(index)]) >> UPL_REPRIO_INFO_SHIFT) & UPL_REPRIO_INFO_MASK)
UPL_SET_CS_VALIDATED(upl, index, value) 	((upl)[(index)].cs_validated = (value))
UPL_SET_CS_TAINTED(upl, index, value) 	((upl)[(index)].cs_tainted = (value))
UPL_SET_CS_NX(upl, index, value) 	((upl)[(index)].cs_nx = (value))
UPL_SET_REPRIO_INFO(upl, index, blkno, len) 	((upl)->upl_reprio_info[(index)]) = (((uint64_t)(blkno) & UPL_REPRIO_INFO_MASK) | 	(((uint64_t)(len) & UPL_REPRIO_INFO_MASK) << UPL_REPRIO_INFO_SHIFT))
UPL_GET_INTERNAL_PAGE_LIST(upl) upl_get_internal_page_list(upl)
_MACH_MESSAGE_H_ None
MACH_MSGH_BITS_ZERO 0x00000000
MACH_MSGH_BITS_REMOTE_MASK 0x0000001f
MACH_MSGH_BITS_LOCAL_MASK 0x00001f00
MACH_MSGH_BITS_VOUCHER_MASK 0x001f0000
MACH_MSGH_BITS_COMPLEX 0x80000000U
MACH_MSGH_BITS_USER 0x801f1f1fU
MACH_MSGH_BITS_RAISEIMP 0x20000000U
MACH_MSGH_BITS_DENAP MACH_MSGH_BITS_RAISEIMP
MACH_MSGH_BITS_IMPHOLDASRT 0x10000000U
MACH_MSGH_BITS_DENAPHOLDASRT MACH_MSGH_BITS_IMPHOLDASRT
MACH_MSGH_BITS_CIRCULAR 0x10000000U
MACH_MSGH_BITS_USED 0xb01f1f1fU
MACH_MSGH_BITS(remote, local)               	        ((remote) | ((local) << 8))
MACH_MSGH_BITS_SET_PORTS(remote, local, voucher)        	(((remote) & MACH_MSGH_BITS_REMOTE_MASK) |              	 (((local) << 8) & MACH_MSGH_BITS_LOCAL_MASK) |         	 (((voucher) << 16) & MACH_MSGH_BITS_VOUCHER_MASK))
MACH_MSGH_BITS_SET(remote, local, voucher, other)       	(MACH_MSGH_BITS_SET_PORTS((remote), (local), (voucher)) 	 | ((other) &~ MACH_MSGH_BITS_PORTS_MASK))
MACH_MSG_QOS_UNSPECIFIED 0
MACH_MSG_QOS_MAINTENANCE 1
MACH_MSG_QOS_BACKGROUND 2
MACH_MSG_QOS_UTILITY 3
MACH_MSG_QOS_DEFAULT 4
MACH_MSG_QOS_USER_INITIATED 5
MACH_MSG_QOS_USER_INTERACTIVE 6
MACH_MSG_QOS_LAST 6
MACH_MSG_PHYSICAL_COPY 0
MACH_MSG_VIRTUAL_COPY 1
MACH_MSG_ALLOCATE 2
MACH_MSG_OVERWRITE 3
MACH_MSG_GUARD_FLAGS_NONE 0x0000
MACH_MSG_GUARD_FLAGS_IMMOVABLE_RECEIVE 0x0001
MACH_MSG_GUARD_FLAGS_UNGUARDED_ON_SEND 0x0002
MACH_MSG_GUARD_FLAGS_MASK 0x0003
MACH_MSG_PORT_DESCRIPTOR 0
MACH_MSG_OOL_DESCRIPTOR 1
MACH_MSG_OOL_PORTS_DESCRIPTOR 2
MACH_MSG_OOL_VOLATILE_DESCRIPTOR 3
MACH_MSG_GUARDED_PORT_DESCRIPTOR 4
MACH_MSG_DESCRIPTOR_MAX MACH_MSG_GUARDED_PORT_DESCRIPTOR
LIBSYSCALL_MSGV_AUX_MAX_SIZE 128
msgh_reserved msgh_voucher_port
mach_port_array_alloc(count, flags) 	kalloc_type(mach_port_ool_t, count, flags)
mach_port_array_free(ptr, count) 	kfree_type(mach_port_ool_t, count, ptr)
MACH_MSG_TRAILER_FORMAT_0 0
INVALID_AUDIT_TOKEN_VALUE {{ 	UINT_MAX, UINT_MAX, UINT_MAX, UINT_MAX, 	UINT_MAX, UINT_MAX, UINT_MAX, UINT_MAX }}
MACH_MSG_TRAILER_MINIMUM_SIZE sizeof(mach_msg_trailer_t)
MACH_MSG_TRAILER_FORMAT_0_SIZE sizeof(mach_msg_format_0_trailer_t)
KERNEL_SECURITY_TOKEN_VALUE { {0, 1} }
KERNEL_AUDIT_TOKEN_VALUE { {0, 0, 0, 0, 0, 0, 0, 0} }
round_msg_overflow(in, out) __os_warn_unused(({ 	        bool __ovr = os_add_overflow(in, (__typeof__(*out))(sizeof(natural_t) - 1), out); 	        *out &= ~((__typeof__(*out))(sizeof(natural_t) - 1)); 	        __ovr; 	}))
MACH_MSGH_KIND_NORMAL 0x00000000
MACH_MSGH_KIND_NOTIFICATION 0x00000001
msgh_kind msgh_seqno
mach_msg_kind_t mach_port_seqno_t
MACH_MSG_TYPE_PORT_NONE 0
MACH_MSG_TYPE_PORT_NAME 15
MACH_MSG_TYPE_PORT_RECEIVE MACH_MSG_TYPE_MOVE_RECEIVE
MACH_MSG_TYPE_PORT_SEND MACH_MSG_TYPE_MOVE_SEND
MACH_MSG_TYPE_PORT_SEND_ONCE MACH_MSG_TYPE_MOVE_SEND_ONCE
MACH_MSG_TYPE_LAST 22
MACH_MSG_OPTION_NONE 0x00000000
MACH_SEND_MSG 0x00000001
MACH_RCV_MSG 0x00000002
MACH_RCV_LARGE 0x00000004
MACH_RCV_LARGE_IDENTITY 0x00000008
MACH_SEND_TIMEOUT 0x00000010
MACH_SEND_OVERRIDE 0x00000020
MACH_SEND_INTERRUPT 0x00000040
MACH_SEND_NOTIFY 0x00000080
MACH_SEND_ALWAYS 0x00010000
MACH_SEND_FILTER_NONFATAL 0x00010000
MACH_SEND_TRAILER 0x00020000
MACH_SEND_NOIMPORTANCE 0x00040000
MACH_SEND_NODENAP MACH_SEND_NOIMPORTANCE
MACH_SEND_IMPORTANCE 0x00080000
MACH_SEND_SYNC_OVERRIDE 0x00100000
MACH_SEND_PROPAGATE_QOS 0x00200000
MACH_SEND_SYNC_USE_THRPRI MACH_SEND_PROPAGATE_QOS
MACH_SEND_KERNEL 0x00400000
MACH_SEND_SYNC_BOOTSTRAP_CHECKIN 0x00800000
MACH_RCV_TIMEOUT 0x00000100
MACH_RCV_NOTIFY 0x00000000
MACH_RCV_INTERRUPT 0x00000400
MACH_RCV_VOUCHER 0x00000800
MACH_RCV_OVERWRITE 0x00000000
MACH_RCV_GUARDED_DESC 0x00001000
MACH_RCV_SYNC_WAIT 0x00004000
MACH_RCV_SYNC_PEEK 0x00008000
MACH_MSG_STRICT_REPLY 0x00000200
MACH64_SEND_USER_CALL MACH64_SEND_MQ_CALL
MACH_RCV_TRAILER_NULL 0
MACH_RCV_TRAILER_SEQNO 1
MACH_RCV_TRAILER_SENDER 2
MACH_RCV_TRAILER_AUDIT 3
MACH_RCV_TRAILER_CTX 4
MACH_RCV_TRAILER_AV 7
MACH_RCV_TRAILER_LABELS 8
REQUESTED_TRAILER_SIZE(is64, y)                                 	((mach_msg_trailer_size_t)                              	 ((GET_RCV_ELEMENTS(y) == MACH_RCV_TRAILER_NULL) ?      	  sizeof(mach_msg_trailer_t) :                          	  ((GET_RCV_ELEMENTS(y) == MACH_RCV_TRAILER_SEQNO) ?    	   sizeof(mach_msg_seqno_trailer_t) :                   	  ((GET_RCV_ELEMENTS(y) == MACH_RCV_TRAILER_SENDER) ?   	   sizeof(mach_msg_security_trailer_t) :                	   ((GET_RCV_ELEMENTS(y) == MACH_RCV_TRAILER_AUDIT) ?   	    sizeof(mach_msg_audit_trailer_t) :                  	    ((GET_RCV_ELEMENTS(y) == MACH_RCV_TRAILER_CTX) ?    	     ((is64) ? sizeof(mach_msg_context_trailer64_t) : sizeof(mach_msg_context_trailer32_t)) : 	     ((GET_RCV_ELEMENTS(y) == MACH_RCV_TRAILER_AV) ?    	      ((is64) ? sizeof(mach_msg_mac_trailer64_t) : sizeof(mach_msg_mac_trailer32_t)) : 	       sizeof(mach_msg_max_trailer_t))))))))
MACH_MSG_SUCCESS 0x00000000
MACH_MSG_MASK 0x00003e00
MACH_MSG_IPC_SPACE 0x00002000
MACH_MSG_VM_SPACE 0x00001000
MACH_MSG_IPC_KERNEL 0x00000800
MACH_MSG_VM_KERNEL 0x00000400
MACH_SEND_IN_PROGRESS 0x10000001
MACH_SEND_INVALID_DATA 0x10000002
MACH_SEND_INVALID_DEST 0x10000003
MACH_SEND_TIMED_OUT 0x10000004
MACH_SEND_INVALID_VOUCHER 0x10000005
MACH_SEND_INTERRUPTED 0x10000007
MACH_SEND_MSG_TOO_SMALL 0x10000008
MACH_SEND_INVALID_REPLY 0x10000009
MACH_SEND_INVALID_RIGHT 0x1000000a
MACH_SEND_INVALID_NOTIFY 0x1000000b
MACH_SEND_INVALID_MEMORY 0x1000000c
MACH_SEND_NO_BUFFER 0x1000000d
MACH_SEND_TOO_LARGE 0x1000000e
MACH_SEND_INVALID_TYPE 0x1000000f
MACH_SEND_INVALID_HEADER 0x10000010
MACH_SEND_INVALID_TRAILER 0x10000011
MACH_SEND_INVALID_CONTEXT 0x10000012
MACH_SEND_INVALID_OPTIONS 0x10000013
MACH_SEND_INVALID_RT_OOL_SIZE 0x10000015
MACH_SEND_NO_GRANT_DEST 0x10000016
MACH_SEND_MSG_FILTERED 0x10000017
MACH_SEND_AUX_TOO_SMALL 0x10000018
MACH_SEND_AUX_TOO_LARGE 0x10000019
MACH_RCV_IN_PROGRESS 0x10004001
MACH_RCV_INVALID_NAME 0x10004002
MACH_RCV_TIMED_OUT 0x10004003
MACH_RCV_TOO_LARGE 0x10004004
MACH_RCV_INTERRUPTED 0x10004005
MACH_RCV_PORT_CHANGED 0x10004006
MACH_RCV_INVALID_NOTIFY 0x10004007
MACH_RCV_INVALID_DATA 0x10004008
MACH_RCV_PORT_DIED 0x10004009
MACH_RCV_IN_SET 0x1000400a
MACH_RCV_HEADER_ERROR 0x1000400b
MACH_RCV_BODY_ERROR 0x1000400c
MACH_RCV_INVALID_TYPE 0x1000400d
MACH_RCV_SCATTER_SMALL 0x1000400e
MACH_RCV_INVALID_TRAILER 0x1000400f
MACH_RCV_IN_PROGRESS_TIMED 0x10004011
MACH_RCV_INVALID_REPLY 0x10004012
MACH_RCV_INVALID_ARGUMENTS 0x10004013
_MACH_MIG_H_ None
__MigPackStructs 1
_MACH_MIG_ERRORS_H_ None
MIG_TYPE_ERROR -300
MIG_REPLY_MISMATCH -301
MIG_REMOTE_ERROR -302
MIG_BAD_ID -303
MIG_BAD_ARGUMENTS -304
MIG_NO_REPLY -305
MIG_EXCEPTION -306
MIG_ARRAY_TOO_LARGE -307
MIG_SERVER_DIED -308
MIG_TRAILER_ERROR -309
_mig_log_ None
__MACH_MIG_STRNCPY_ZEROFILL_SUPPORT__ None
__MACH_MIG_VOUCHER_SUPPORT__ None
_MACH_MK_TIMER_H_ None
_MACH_MK_TRAPS_H_ None
MSG_TYPE_H_ None
_MACH_NDR_H_ None
NDR_PROTOCOL_2_0 0
NDR_INT_BIG_ENDIAN 0
NDR_INT_LITTLE_ENDIAN 1
NDR_FLOAT_IEEE 0
NDR_FLOAT_VAX 1
NDR_FLOAT_CRAY 2
NDR_FLOAT_IBM 3
NDR_CHAR_ASCII 0
NDR_CHAR_EBCDIC 1
__NDR_convert__int_rep__ __NDR_convert__
__NDR_convert__char_rep__ 0
__NDR_convert__float_rep__ 0
_MACH_NOTIFY_H_ None
MACH_NOTIFY_FIRST 0100
_MACH_POLICY_H_ None
POLICY_NULL 0
POLICY_TIMESHARE 1
POLICY_RR 2
POLICY_FIFO 4
__NEW_SCHEDULING_FRAMEWORK__ None
_MACH_PORT_H_ None
IPC_PORT_NULL __unsafe_forge_single(ipc_port_t, NULL)
IPC_PORT_DEAD __unsafe_forge_single(ipc_port_t, ~0UL)
IPC_PORT_VALID(port) ipc_port_valid(port)
MACH_PORT_MAKE(index, gen)      	        (((index) << 8) | (gen) >> 24)
MACH_PORT_SRIGHTS_NONE 0
MACH_PORT_SRIGHTS_PRESENT 1
MACH_PORT_QLIMIT_MIN MACH_PORT_QLIMIT_ZERO
MACH_PORT_QLIMIT_DEFAULT MACH_PORT_QLIMIT_BASIC
MACH_PORT_QLIMIT_MAX MACH_PORT_QLIMIT_LARGE
MACH_PORT_STATUS_FLAG_TEMPOWNER 0x01
MACH_PORT_STATUS_FLAG_GUARDED 0x02
MACH_PORT_STATUS_FLAG_STRICT_GUARD 0x04
MACH_PORT_STATUS_FLAG_IMP_DONATION 0x08
MACH_PORT_STATUS_FLAG_REVIVE 0x10
MACH_PORT_STATUS_FLAG_TASKPTR 0x20
MACH_PORT_STATUS_FLAG_GUARD_IMMOVABLE_RECEIVE 0x40
MACH_PORT_STATUS_FLAG_NO_GRANT 0x80
MACH_PORT_LIMITS_INFO 1
MACH_PORT_RECEIVE_STATUS 2
MACH_PORT_DNREQUESTS_SIZE 3
MACH_PORT_TEMPOWNER 4
MACH_PORT_IMPORTANCE_RECEIVER 5
MACH_PORT_DENAP_RECEIVER 6
MACH_PORT_INFO_EXT 7
MACH_PORT_GUARD_INFO 8
MACH_PORT_SERVICE_THROTTLED 9
MACH_PORT_DNREQUESTS_SIZE_COUNT 1
MACH_PORT_SERVICE_THROTTLED_COUNT 1
MACH_SERVICE_PORT_INFO_STRING_NAME_MAX_BUF_LEN 255
MPO_CONTEXT_AS_GUARD 0x01
MPO_QLIMIT 0x02
MPO_TEMPOWNER 0x04
MPO_IMPORTANCE_RECEIVER 0x08
MPO_INSERT_SEND_RIGHT 0x10
MPO_STRICT 0x20
MPO_DENAP_RECEIVER 0x40
MPO_IMMOVABLE_RECEIVE 0x80
MPO_FILTER_MSG 0x100
MPO_TG_BLOCK_TRACKING 0x200
MPO_SERVICE_PORT 0x400
MPO_CONNECTION_PORT 0x800
MPO_REPLY_PORT 0x1000
MPO_ENFORCE_REPLY_PORT_SEMANTICS 0x2000
MPO_PROVISIONAL_REPLY_PORT 0x4000
MPO_EXCEPTION_PORT 0x8000
GUARD_TYPE_MACH_PORT 0x1
MAX_FATAL_kGUARD_EXC_CODE kGUARD_EXC_MSG_FILTERED
MAX_OPTIONAL_kGUARD_EXC_CODE kGUARD_EXC_RCV_INVALID_NAME
MPG_STRICT 0x01
MPG_IMMOVABLE_RECEIVE 0x02
_MACH_PROCESSOR_INFO_H_ None
PROCESSOR_BASIC_INFO 1
PROCESSOR_CPU_LOAD_INFO 2
PROCESSOR_PM_REGS_INFO 0x10000001
PROCESSOR_TEMPERATURE 0x10000002
LOAD_SCALE 1000
PROCESSOR_SET_BASIC_INFO 5
PROCESSOR_SET_LOAD_INFO 4
PROCESSOR_SET_ENABLED_POLICIES 3
PROCESSOR_SET_TIMESHARE_DEFAULT 10
PROCESSOR_SET_TIMESHARE_LIMITS 11
PROCESSOR_SET_RR_DEFAULT 20
PROCESSOR_SET_RR_LIMITS 21
PROCESSOR_SET_FIFO_DEFAULT 30
PROCESSOR_SET_FIFO_LIMITS 31
_MACH_PROF_TYPES_H None
SAMPLE_MAX 256
_MACH_RESOURCE_MONITORS_H_ None
kRNFlagsNone 0
kCPUTriggerFatalFlag kRNFatalLimitFlag
MAXCOMLEN 16
_MACH_RPC_H_ None
RPC_SIGBUF_SIZE 8
_MACH_SDT_H None
_MACH_SEMAPHORE_H_ None
SEMAPHORE_OPTION_NONE 0x00000000
SEMAPHORE_SIGNAL 0x00000001
SEMAPHORE_WAIT 0x00000002
SEMAPHORE_WAIT_ON_SIGNAL 0x00000008
SEMAPHORE_SIGNAL_TIMEOUT 0x00000010
SEMAPHORE_SIGNAL_ALL 0x00000020
SEMAPHORE_SIGNAL_INTERRUPT 0x00000040
SEMAPHORE_SIGNAL_PREPOST 0x00000080
SEMAPHORE_WAIT_TIMEOUT 0x00000100
SEMAPHORE_WAIT_INTERRUPT 0x00000400
SEMAPHORE_TIMEOUT_NOBLOCK 0x00100000
SEMAPHORE_TIMEOUT_RELATIVE 0x00200000
SEMAPHORE_USE_SAVED_RESULT 0x01000000
SEMAPHORE_SIGNAL_RELEASE 0x02000000
SEMAPHORE_THREAD_HANDOFF 0x04000000
_MACH_SFI_CLASS_H_ None
SFI_CLASS_DEFINITIONS 20140526
MAX_SFI_CLASS_ID 0x00000011
SFI_CLASS_UNSPECIFIED 0x00000000
SFI_CLASS_DARWIN_BG 0x00000001
SFI_CLASS_APP_NAP 0x00000002
SFI_CLASS_MANAGED_FOCAL 0x00000003
SFI_CLASS_MANAGED_NONFOCAL 0x00000004
SFI_CLASS_MANAGED SFI_CLASS_MANAGED_FOCAL
SFI_CLASS_DEFAULT_FOCAL 0x00000005
SFI_CLASS_DEFAULT_NONFOCAL 0x00000006
SFI_CLASS_DEFAULT SFI_CLASS_DEFAULT_FOCAL
SFI_CLASS_KERNEL 0x00000007
SFI_CLASS_OPTED_OUT 0x00000008
SFI_CLASS_UTILITY 0x00000009
SFI_CLASS_LEGACY_FOCAL 0x0000000A
SFI_CLASS_LEGACY_NONFOCAL 0x0000000B
SFI_CLASS_USER_INITIATED_FOCAL 0x0000000C
SFI_CLASS_USER_INITIATED_NONFOCAL 0x0000000D
SFI_CLASS_USER_INTERACTIVE_FOCAL 0x0000000E
SFI_CLASS_USER_INTERACTIVE_NONFOCAL 0x0000000F
SFI_CLASS_MAINTENANCE 0x00000010
MIN_SFI_WINDOW_USEC 500
_MACH_SHARED_MEMORY_SERVER_H_ None
VM_PROT_COW 0x8
VM_PROT_ZF 0x10
_MACH_SHARED_REGION_H_ None
SHARED_REGION_BASE_I386 0x90000000ULL
SHARED_REGION_SIZE_I386 0x20000000ULL
SHARED_REGION_NESTING_BASE_I386 0x90000000ULL
SHARED_REGION_NESTING_SIZE_I386 0x20000000ULL
SHARED_REGION_NESTING_MIN_I386 0x00200000ULL
SHARED_REGION_NESTING_MAX_I386 0xFFE00000ULL
SHARED_REGION_BASE_X86_64 0x00007FF800000000ULL
SHARED_REGION_SIZE_X86_64 0x00000007FE000000ULL
SHARED_REGION_NESTING_BASE_X86_64 0x00007FF800000000ULL
SHARED_REGION_NESTING_SIZE_X86_64 0x00000007FE000000ULL
SHARED_REGION_NESTING_MIN_X86_64 0x0000000000200000ULL
SHARED_REGION_NESTING_MAX_X86_64 0xFFFFFFFFFFE00000ULL
SHARED_REGION_BASE_PPC 0x90000000ULL
SHARED_REGION_SIZE_PPC 0x20000000ULL
SHARED_REGION_NESTING_BASE_PPC 0x90000000ULL
SHARED_REGION_NESTING_SIZE_PPC 0x10000000ULL
SHARED_REGION_NESTING_MIN_PPC 0x10000000ULL
SHARED_REGION_NESTING_MAX_PPC 0x10000000ULL
SHARED_REGION_BASE_PPC64 0x00007FFF60000000ULL
SHARED_REGION_SIZE_PPC64 0x00000000A0000000ULL
SHARED_REGION_NESTING_BASE_PPC64 0x00007FFF60000000ULL
SHARED_REGION_NESTING_SIZE_PPC64 0x00000000A0000000ULL
SHARED_REGION_NESTING_MIN_PPC64 0x0000000010000000ULL
SHARED_REGION_NESTING_MAX_PPC64 0x0000000010000000ULL
SHARED_REGION_BASE_ARM 0x40000000ULL
SHARED_REGION_SIZE_ARM 0x40000000ULL
SHARED_REGION_NESTING_BASE_ARM 0x40000000ULL
SHARED_REGION_NESTING_SIZE_ARM 0x40000000ULL
SHARED_REGION_NESTING_MIN_ARM ?
SHARED_REGION_NESTING_MAX_ARM ?
SHARED_REGION_BASE_ARM64_32 0x1A000000ULL
SHARED_REGION_SIZE_ARM64_32 0x88000000ULL
SHARED_REGION_NESTING_BASE_ARM64_32 0x1A000000ULL
SHARED_REGION_NESTING_SIZE_ARM64_32 0x88000000ULL
SHARED_REGION_NESTING_MIN_ARM64_32 ?
SHARED_REGION_NESTING_MAX_ARM64_32 ?
SHARED_REGION_BASE_ARM64 0x180000000ULL
SHARED_REGION_SIZE_ARM64 0x180000000ULL
SHARED_REGION_NESTING_BASE_ARM64 SHARED_REGION_BASE_ARM64
SHARED_REGION_NESTING_SIZE_ARM64 SHARED_REGION_SIZE_ARM64
SHARED_REGION_NESTING_MIN_ARM64 ?
SHARED_REGION_NESTING_MAX_ARM64 ?
VM_PROT_COW 0x08
VM_PROT_ZF 0x10
VM_PROT_SLIDE 0x20
VM_PROT_NOAUTH 0x40
VM_PROT_TRANSLATED_ALLOW_EXECUTE 0x80
_MACH_STD_TYPES_H_ None
_MACH_SYNC_POLICY_H_ None
SYNC_POLICY_FIFO 0x0
SYNC_POLICY_FIXED_PRIORITY 0x1
SYNC_POLICY_REVERSED 0x2
SYNC_POLICY_ORDER_MASK 0x3
SYNC_POLICY_PREPOST 0x4
SYNC_POLICY_INIT_LOCKED 0x08
_MACH_SYSCALL_SW_H_ None
_MACH_TASK_INFO_H_ None
TASK_BASIC_INFO_32 4
TASK_BASIC2_INFO_32 6
TASK_BASIC_INFO_64 5
TASK_EVENTS_INFO 2
TASK_THREAD_TIMES_INFO 3
TASK_ABSOLUTETIME_INFO 1
TASK_KERNELMEMORY_INFO 7
TASK_SECURITY_TOKEN 13
TASK_AUDIT_TOKEN 15
TASK_AFFINITY_TAG_INFO 16
TASK_DYLD_INFO 17
TASK_DYLD_ALL_IMAGE_INFO_32 0
TASK_DYLD_ALL_IMAGE_INFO_64 1
TASK_BASIC_INFO_64_2 18
TASK_EXTMOD_INFO 19
MACH_TASK_BASIC_INFO 20
TASK_POWER_INFO 21
TASK_VM_INFO 22
TASK_VM_INFO_PURGEABLE 23
TASK_VM_INFO_REV7_COUNT TASK_VM_INFO_COUNT
TASK_TRACE_MEMORY_INFO 24
TASK_WAIT_STATE_INFO 25
TASK_POWER_INFO_V2 26
TASK_VM_INFO_PURGEABLE_ACCOUNT 27
TASK_FLAGS_INFO 28
TF_LP64 0x00000001
TF_64B_DATA 0x00000002
TASK_DEBUG_INFO_INTERNAL 29
TASK_SUSPEND_STATS_INFO 30
TASK_SUSPEND_SOURCES_MAX 4
TASK_SUSPEND_SOURCES_INFO 31
TASK_EXC_GUARD_NONE 0x00
TASK_EXC_GUARD_VM_DELIVER 0x01
TASK_EXC_GUARD_VM_ONCE 0x02
TASK_EXC_GUARD_VM_CORPSE 0x04
TASK_EXC_GUARD_VM_FATAL 0x08
TASK_EXC_GUARD_VM_ALL 0x0f
TASK_EXC_GUARD_MP_DELIVER 0x10
TASK_EXC_GUARD_MP_ONCE 0x20
TASK_EXC_GUARD_MP_CORPSE 0x40
TASK_EXC_GUARD_MP_FATAL 0x80
TASK_EXC_GUARD_MP_ALL 0xf0
TASK_EXC_GUARD_ALL 0xff
TASK_EXC_GUARD_THIRD_PARTY_DEFAULT_SHIFT 0x8
TASK_EXC_GUARD_HONOR_NAMED_DEFAULTS 0x10000
TASK_CORPSE_FORKING_DISABLED_MEM_DIAG 0x01
TASK_SCHED_TIMESHARE_INFO 10
TASK_SCHED_RR_INFO 11
TASK_SCHED_FIFO_INFO 12
TASK_SCHED_INFO 14
MACH_TASK_INSPECT_H None
_MACH_TASK_LEDGER_H_ None
ITEM_THREADS 0
ITEM_TASKS 1
ITEM_VM 2
LEDGER_N_ITEMS 3
LEDGER_UNLIMITED 0
_MACH_TASK_POLICY_H_ None
TASK_CATEGORY_POLICY 1
TASK_SUPPRESSION_POLICY 3
TASK_POLICY_STATE 4
TASK_BASE_QOS_POLICY 8
TASK_OVERRIDE_QOS_POLICY 9
TASK_BASE_LATENCY_QOS_POLICY 10
TASK_BASE_THROUGHPUT_QOS_POLICY 11
LATENCY_QOS_LAUNCH_DEFAULT_TIER LATENCY_QOS_TIER_3
THROUGHPUT_QOS_LAUNCH_DEFAULT_TIER THROUGHPUT_QOS_TIER_3
PROC_FLAG_DARWINBG 0x8000
PROC_FLAG_EXT_DARWINBG 0x10000
PROC_FLAG_IOS_APPLEDAEMON 0x20000
PROC_FLAG_IOS_IMPPROMOTION 0x80000
PROC_FLAG_ADAPTIVE 0x100000
PROC_FLAG_ADAPTIVE_IMPORTANT 0x200000
PROC_FLAG_IMPORTANCE_DONOR 0x400000
PROC_FLAG_SUPPRESSED 0x800000
PROC_FLAG_APPLICATION 0x1000000
PROC_FLAG_IOS_APPLICATION PROC_FLAG_APPLICATION
_MACH_TASK_POLICY_PRIVATE_H_ None
TASK_POLICY_INTERNAL_STRUCT_VERSION 4
trp_tal_enabled trp_reserved
TASK_APPTYPE_NONE 0
TASK_APPTYPE_DAEMON_INTERACTIVE 1
TASK_APPTYPE_DAEMON_STANDARD 2
TASK_APPTYPE_DAEMON_ADAPTIVE 3
TASK_APPTYPE_DAEMON_BACKGROUND 4
TASK_APPTYPE_APP_DEFAULT 5
TASK_APPTYPE_APP_TAL 6
TASK_APPTYPE_DRIVER 7
TASK_IMP_RECEIVER 0x00000001
TASK_IMP_DONOR 0x00000002
TASK_IMP_LIVE_DONOR 0x00000004
TASK_DENAP_RECEIVER 0x00000008
TASK_IS_PIDSUSPENDED 0x00000010
POLICY_REQ_INT_DARWIN_BG 0x00000001
POLICY_REQ_EXT_DARWIN_BG 0x00000002
POLICY_REQ_INT_IO_TIER_MASK 0x0000000c
POLICY_REQ_INT_IO_TIER_SHIFT 2
POLICY_REQ_EXT_IO_TIER_MASK 0x00000030
POLICY_REQ_EXT_IO_TIER_SHIFT 4
POLICY_REQ_INT_PASSIVE_IO 0x00000040
POLICY_REQ_EXT_PASSIVE_IO 0x00000080
POLICY_REQ_BG_IOTIER_MASK 0x00000300
POLICY_REQ_BG_IOTIER_SHIFT 8
POLICY_REQ_PIDBIND_BG 0x00000400
POLICY_REQ_WORKQ_BG 0x00000800
POLICY_REQ_TH_QOS_MASK 0x07000000
POLICY_REQ_TH_QOS_SHIFT 24
POLICY_REQ_TH_QOS_OVER_MASK 0x70000000
POLICY_REQ_TH_QOS_OVER_SHIFT 28
POLICY_REQ_TERMINATED 0x00001000
POLICY_REQ_BOOSTED 0x00002000
POLICY_REQ_INT_GPU_DENY 0x00004000
POLICY_REQ_EXT_GPU_DENY 0x00008000
POLICY_REQ_APPTYPE_MASK 0x00070000
POLICY_REQ_APPTYPE_SHIFT 16
POLICY_REQ_BASE_LATENCY_QOS_MASK 0x00700000
POLICY_REQ_BASE_LATENCY_QOS_SHIFT 20
POLICY_REQ_ROLE_MASK 0x07000000
POLICY_REQ_ROLE_SHIFT 24
POLICY_REQ_TAL_ENABLED 0x40000000
POLICY_REQ_SFI_MANAGED 0x80000000
POLICY_REQ_SUP_ACTIVE 0x0000000100000000
POLICY_REQ_SUP_LOWPRI_CPU 0x0000000200000000
POLICY_REQ_SUP_CPU 0x0000000400000000
POLICY_REQ_SUP_DISK_THROTTLE 0x0000003000000000
POLICY_REQ_SUP_CPU_LIMIT 0x0000004000000000
POLICY_REQ_SUP_SUSPEND 0x0000008000000000
POLICY_REQ_OVER_LATENCY_QOS_MASK 0x0000070000000000
POLICY_REQ_OVER_LATENCY_QOS_SHIFT 40
POLICY_REQ_BASE_THROUGH_QOS_MASK 0x0000700000000000
POLICY_REQ_BASE_THROUGH_QOS_SHIFT 44
POLICY_REQ_OVER_THROUGH_QOS_MASK 0x0007000000000000
POLICY_REQ_OVER_THROUGH_QOS_SHIFT 48
POLICY_REQ_SUP_TIMER_THROTTLE_MASK 0x0070000000000000
POLICY_REQ_SUP_TIMER_THROTTLE_SHIFT 52
POLICY_REQ_SUP_THROUGHPUT_MASK 0x0700000000000000
POLICY_REQ_SUP_THROUGHPUT_SHIFT 56
POLICY_REQ_SUP_BG_SOCKETS 0x0800008000000000
POLICY_REQ_QOS_CLAMP_MASK 0x7000000000000000
POLICY_REQ_QOS_CLAMP_SHIFT 60
POLICY_EFF_IO_TIER_MASK 0x00000003
POLICY_EFF_IO_TIER_SHIFT 0
POLICY_EFF_IO_PASSIVE 0x00000008
POLICY_EFF_DARWIN_BG 0x00000010
POLICY_EFF_LOWPRI_CPU 0x00000020
POLICY_EFF_ALL_SOCKETS_BG 0x00000040
POLICY_EFF_NEW_SOCKETS_BG 0x00000080
POLICY_EFF_BG_IOTIER_MASK 0x00000300
POLICY_EFF_BG_IOTIER_SHIFT 8
POLICY_EFF_TERMINATED 0x00000400
POLICY_EFF_QOS_UI_IS_URGENT 0x80000000
POLICY_EFF_TH_QOS_MASK 0x00700000
POLICY_EFF_TH_QOS_SHIFT 20
POLICY_EFF_LATENCY_QOS_MASK 0x00070000
POLICY_EFF_LATENCY_QOS_SHIFT 16
POLICY_EFF_THROUGH_QOS_MASK 0x07000000
POLICY_EFF_THROUGH_QOS_SHIFT 24
POLICY_EFF_GPU_DENY 0x00001000
POLICY_EFF_TAL_ENGAGED 0x00002000
POLICY_EFF_SUSPENDED 0x00004000
POLICY_EFF_WATCHERS_BG 0x00008000
POLICY_EFF_SUP_ACTIVE 0x00080000
POLICY_EFF_ROLE_MASK 0x00700000
POLICY_EFF_ROLE_SHIFT 20
POLICY_EFF_SUP_CPU 0x00800000
POLICY_EFF_SFI_MANAGED 0x08000000
POLICY_EFF_QOS_CEILING_MASK 0x70000000
POLICY_EFF_QOS_CEILING_SHIFT 28
POLICY_PEND_UPDATING 0x00000001
POLICY_PEND_SOCKETS 0x00000002
POLICY_PEND_TIMERS 0x00000004
POLICY_PEND_WATCHERS 0x00000008
_MACH_TASK_SPECIAL_PORTS_H_ None
TASK_KERNEL_PORT 1
TASK_HOST_PORT 2
TASK_NAME_PORT 3
TASK_BOOTSTRAP_PORT 4
TASK_INSPECT_PORT 5
TASK_READ_PORT 6
TASK_ACCESS_PORT 9
TASK_DEBUG_CONTROL_PORT 10
TASK_RESOURCE_NOTIFY_PORT 11
TASK_MAX_SPECIAL_PORT TASK_RESOURCE_NOTIFY_PORT
task_get_kernel_port(task, port)        	        (task_get_special_port((task), TASK_KERNEL_PORT, (port)))
task_set_kernel_port(task, port)        	        (task_set_special_port((task), TASK_KERNEL_PORT, (port)))
task_get_host_port(task, port)          	        (task_get_special_port((task), TASK_HOST_PORT, (port)))
task_set_host_port(task, port)  	        (task_set_special_port((task), TASK_HOST_PORT, (port)))
task_get_bootstrap_port(task, port)     	        (task_get_special_port((task), TASK_BOOTSTRAP_PORT, (port)))
task_get_debug_control_port(task, port) 	        (task_get_special_port((task), TASK_DEBUG_CONTROL_PORT, (port)))
task_set_bootstrap_port(task, port)     	        (task_set_special_port((task), TASK_BOOTSTRAP_PORT, (port)))
task_get_task_access_port(task, port)   	        (task_get_special_port((task), TASK_ACCESS_PORT, (port)))
task_set_task_access_port(task, port)   	        (task_set_special_port((task), TASK_ACCESS_PORT, (port)))
task_set_task_debug_control_port(task, port) 	        (task_set_special_port((task), TASK_DEBUG_CONTROL_PORT, (port)))
DEBUG_PORT_ENTITLEMENT "com.apple.private.debug_port"
_MACH_THREAD_INFO_H_ None
THREAD_BASIC_INFO 3
THREAD_IDENTIFIER_INFO 4
TH_USAGE_SCALE 1000
TH_STATE_RUNNING 1
TH_STATE_STOPPED 2
TH_STATE_WAITING 3
TH_STATE_UNINTERRUPTIBLE 4
TH_STATE_HALTED 5
TH_FLAGS_SWAPPED 0x1
TH_FLAGS_IDLE 0x2
TH_FLAGS_GLOBAL_FORCED_IDLE 0x4
THREAD_EXTENDED_INFO 5
MAXTHREADNAMESIZE 64
THREAD_DEBUG_INFO_INTERNAL 6
IO_NUM_PRIORITIES 4
UPDATE_IO_STATS(info, size)                             {                                                               	info.count++;                                           	info.size += size;                                      }
UPDATE_IO_STATS_ATOMIC(info, io_size)                   {                                                               	OSIncrementAtomic64((SInt64 *)&(info.count));           	OSAddAtomic64(io_size, (SInt64 *)&(info.size));         }
THREAD_SCHED_TIMESHARE_INFO 10
THREAD_SCHED_RR_INFO 11
THREAD_SCHED_FIFO_INFO 12
_MACH_THREAD_POLICY_H_ None
THREAD_STANDARD_POLICY 1
THREAD_STANDARD_POLICY_COUNT 0
THREAD_EXTENDED_POLICY 1
THREAD_TIME_CONSTRAINT_POLICY 2
THREAD_PRECEDENCE_POLICY 3
THREAD_AFFINITY_POLICY 4
THREAD_AFFINITY_TAG_NULL 0
THREAD_BACKGROUND_POLICY 5
THREAD_BACKGROUND_POLICY_DARWIN_BG 0x1000
THREAD_LATENCY_QOS_POLICY 7
THREAD_THROUGHPUT_QOS_POLICY 8
_MACH_THREAD_POLICY_PRIVATE_H_ None
THREAD_POLICY_STATE 6
THREAD_POLICY_STATE_FLAG_STATIC_PARAM 0x1
THREAD_QOS_POLICY 9
THREAD_QOS_UNSPECIFIED 0
THREAD_QOS_DEFAULT THREAD_QOS_UNSPECIFIED
THREAD_QOS_MAINTENANCE 1
THREAD_QOS_BACKGROUND 2
THREAD_QOS_UTILITY 3
THREAD_QOS_LEGACY 4
THREAD_QOS_USER_INITIATED 5
THREAD_QOS_USER_INTERACTIVE 6
THREAD_QOS_LAST 7
THREAD_TIME_CONSTRAINT_WITH_PRIORITY_POLICY 10
TIME_CONSTRAINT_POLICY_DEFAULT_PRIORITY 97
TIME_CONSTRAINT_POLICY_MAXIMUM_PRIORITY 127
THREAD_REQUESTED_STATE_POLICY 11
THREAD_POLICY_INTERNAL_STRUCT_VERSION 7
_MACH_THREAD_SPECIAL_PORTS_H_ None
THREAD_KERNEL_PORT 1
THREAD_INSPECT_PORT 2
THREAD_READ_PORT 3
THREAD_MAX_SPECIAL_PORT THREAD_READ_PORT
thread_get_kernel_port(thread, port)    	        (thread_get_special_port((thread), THREAD_KERNEL_PORT, (port)))
thread_set_kernel_port(thread, port)    	        (thread_set_special_port((thread), THREAD_KERNEL_PORT, (port)))
_MACH_THREAD_STATUS_H_ None
THREAD_STATE_FLAVOR_LIST 0
THREAD_STATE_FLAVOR_LIST_NEW 128
THREAD_STATE_FLAVOR_LIST_10_9 129
THREAD_STATE_FLAVOR_LIST_10_13 130
THREAD_STATE_FLAVOR_LIST_10_15 131
THREAD_CONVERT_THREAD_STATE_TO_SELF 1
THREAD_CONVERT_THREAD_STATE_FROM_SELF 2
_MACH_THREAD_SWITCH_H_ None
SWITCH_OPTION_NONE 0
SWITCH_OPTION_DEPRESS 1
SWITCH_OPTION_WAIT 2
SWITCH_OPTION_DISPATCH_CONTENTION 3
SWITCH_OPTION_OSLOCK_DEPRESS 4
SWITCH_OPTION_OSLOCK_WAIT 5
_MACH_TIME_VALUE_H_ None
time_value_add_usec(val, micros)        {       	if (((val)->microseconds += (micros))           	        >= TIME_MICROS_MAX) {                   	    (val)->microseconds -= TIME_MICROS_MAX;     	    (val)->seconds++;                           	}                                               }
time_value_add(result, addend)          {               	(result)->microseconds += (addend)->microseconds;       	(result)->seconds += (addend)->seconds;                 	if ((result)->microseconds >= TIME_MICROS_MAX) {        	    (result)->microseconds -= TIME_MICROS_MAX;          	    (result)->seconds++;                                	}                                                       }
_MACH_VM_ATTRIBUTES_H_ None
MATTR_CACHE 1
MATTR_MIGRATE 2
MATTR_REPLICATE 4
MATTR_VAL_OFF 0
MATTR_VAL_ON 1
MATTR_VAL_GET 2
MATTR_VAL_CACHE_FLUSH 6
MATTR_VAL_DCACHE_FLUSH 7
MATTR_VAL_ICACHE_FLUSH 8
MATTR_VAL_CACHE_SYNC 9
MATTR_VAL_CACHE_SYNC 9
MATTR_VAL_GET_INFO 10
_MACH_VM_BEHAVIOR_H_ None
_MACH_VM_INHERIT_H_ None
VM_INHERIT_DEFAULT VM_INHERIT_COPY
VM_INHERIT_LAST_VALID VM_INHERIT_NONE
_MACH_VM_PARAM_H_ None
round_page_overflow(in, out) __os_warn_unused(({ 	        bool __ovr = os_add_overflow(in, (__typeof__(*out))PAGE_MASK, out); 	        *out &= ~((__typeof__(*out))PAGE_MASK); 	        __ovr; 	}))
round_page_mask_32(x, mask) (((uint32_t)(x) + (mask)) & ~((uint32_t)(mask)))
trunc_page_mask_32(x, mask) ((uint32_t)(x) & ~((uint32_t)(mask)))
round_page_mask_64(x, mask) (((uint64_t)(x) + (mask)) & ~((uint64_t)(mask)))
trunc_page_mask_64(x, mask) ((uint64_t)(x) & ~((uint64_t)(mask)))
ANON_MAX_PAGES 0xFFFFFFFFULL
VM_KERNEL_ADDRHASH(_v) vm_kernel_addrhash((vm_offset_t)(_v))
VM_KERNEL_ADDRPERM(_v) VM_KERNEL_UNSLIDE_OR_PERM(_v)
VM_PACK_POINTER(ptr, ns) 	vm_pack_pointer(ptr, VM_PACKING_PARAMS(ns))
VM_UNPACK_POINTER(packed, ns) 	vm_unpack_pointer(packed, VM_PACKING_PARAMS(ns))
VM_PACKING_MAX_PACKABLE(ns) vm_packing_max_packable(VM_PACKING_PARAMS(ns))
VM_VERIFY_POINTER_PACKABLE(ptr, ns) 	vm_verify_pointer_packable(ptr, VM_PACKING_PARAMS(ns))
__CAST_DOWN_CHECK None
_MACH_VM_PROT_H_ None
_MACH_VM_PURGABLE_H_ None
VM_PURGABLE_NO_AGING_SHIFT 16
VM_PURGABLE_DEBUG_SHIFT 12
VM_VOLATILE_GROUP_SHIFT 8
VM_VOLATILE_GROUP_DEFAULT VM_VOLATILE_GROUP_0
VM_PURGABLE_BEHAVIOR_SHIFT 6
VM_PURGABLE_ORDERING_SHIFT 5
VM_VOLATILE_ORDER_SHIFT 4
VM_PURGABLE_STATE_MIN 0
VM_PURGABLE_STATE_MAX 3
VM_PURGABLE_STATE_MASK 3
VM_PURGABLE_NONVOLATILE 0
VM_PURGABLE_VOLATILE 1
VM_PURGABLE_EMPTY 2
VM_PURGABLE_DENY 3
_VM_RECLAIM_H_ None
_MACH_VM_REGION_H_ None
VM_REGION_INFO_FLAGS_NO_ALIASED 0x1
VM_REGION_BASIC_INFO_64 9
VM_REGION_BASIC_INFO 10
SM_COW 1
SM_PRIVATE 2
SM_EMPTY 3
SM_SHARED 4
SM_TRUESHARED 5
SM_PRIVATE_ALIASED 6
SM_SHARED_ALIASED 7
SM_LARGE_PAGE 8
VM_REGION_EXTENDED_INFO__legacy 11
VM_REGION_EXTENDED_INFO 13
VM_REGION_TOP_INFO 12
VM_REGION_SUBMAP_INFO_COUNT_64 VM_REGION_SUBMAP_INFO_V2_COUNT_64
VM_PAGE_INFO_MAX None
VM_PAGE_INFO_BASIC 1
_MACH_VM_STATISTICS_H_ None
VM_PAGE_QUERY_PAGE_PRESENT 0x1
VM_PAGE_QUERY_PAGE_FICTITIOUS 0x2
VM_PAGE_QUERY_PAGE_REF 0x4
VM_PAGE_QUERY_PAGE_DIRTY 0x8
VM_PAGE_QUERY_PAGE_PAGED_OUT 0x10
VM_PAGE_QUERY_PAGE_COPIED 0x20
VM_PAGE_QUERY_PAGE_SPECULATIVE 0x40
VM_PAGE_QUERY_PAGE_EXTERNAL 0x80
VM_PAGE_QUERY_PAGE_CS_VALIDATED 0x100
VM_PAGE_QUERY_PAGE_CS_TAINTED 0x200
VM_PAGE_QUERY_PAGE_CS_NX 0x400
VM_PAGE_QUERY_PAGE_REUSABLE 0x800
VM_FLAGS_FIXED 0x00000000
VM_FLAGS_ANYWHERE 0x00000001
VM_FLAGS_PURGABLE 0x00000002
VM_FLAGS_4GB_CHUNK 0x00000004
VM_FLAGS_RANDOM_ADDR 0x00000008
VM_FLAGS_NO_CACHE 0x00000010
VM_FLAGS_RESILIENT_CODESIGN 0x00000020
VM_FLAGS_RESILIENT_MEDIA 0x00000040
VM_FLAGS_PERMANENT 0x00000080
VM_FLAGS_TPRO 0x00001000
VM_FLAGS_OVERWRITE 0x00004000
VM_FLAGS_SUPERPAGE_MASK 0x00070000
VM_FLAGS_RETURN_DATA_ADDR 0x00100000
VM_FLAGS_RETURN_4K_DATA_ADDR 0x00800000
VM_FLAGS_ALIAS_MASK 0xFF000000
VM_GET_FLAGS_ALIAS(flags, alias)                        	        (alias) = (((flags) >> 24) & 0xff)
VM_FLAGS_SUPERPAGE_SHIFT 16
SUPERPAGE_NONE 0
SUPERPAGE_SIZE_ANY 1
GUARD_TYPE_VIRT_MEMORY 0x5
KMEM_RANGE_BITS kmem_log2down(2 * KMEM_RANGE_MAX - 1)
VM_MAP_KERNEL_FLAGS_FIXED_PERMANENT(...) VM_MAP_KERNEL_FLAGS_FIXED(.vmf_permanent = true, __VA_ARGS__)
VM_MAP_KERNEL_FLAGS_ANYWHERE_PERMANENT(...) VM_MAP_KERNEL_FLAGS_ANYWHERE(.vmf_permanent = true, __VA_ARGS__)
VM_MAP_KERNEL_FLAGS_DATA_ANYWHERE(...) VM_MAP_KERNEL_FLAGS_ANYWHERE(.vmkf_range_id = KMEM_RANGE_ID_DATA, __VA_ARGS__)
__VM_LEDGER_ACCOUNTING_POSTMARK 2019032600
VM_LEDGER_TAG_NONE 0x00000000
VM_LEDGER_TAG_DEFAULT 0x00000001
VM_LEDGER_TAG_NETWORK 0x00000002
VM_LEDGER_TAG_MEDIA 0x00000003
VM_LEDGER_TAG_GRAPHICS 0x00000004
VM_LEDGER_TAG_NEURAL 0x00000005
VM_LEDGER_TAG_MAX 0x00000005
VM_MEMORY_MALLOC 1
VM_MEMORY_MALLOC_SMALL 2
VM_MEMORY_MALLOC_LARGE 3
VM_MEMORY_MALLOC_HUGE 4
VM_MEMORY_SBRK 5
VM_MEMORY_REALLOC 6
VM_MEMORY_MALLOC_TINY 7
VM_MEMORY_MALLOC_LARGE_REUSABLE 8
VM_MEMORY_MALLOC_LARGE_REUSED 9
VM_MEMORY_ANALYSIS_TOOL 10
VM_MEMORY_MALLOC_NANO 11
VM_MEMORY_MALLOC_MEDIUM 12
VM_MEMORY_MALLOC_PROB_GUARD 13
VM_MEMORY_MACH_MSG 20
VM_MEMORY_IOKIT 21
VM_MEMORY_STACK 30
VM_MEMORY_GUARD 31
VM_MEMORY_SHARED_PMAP 32
VM_MEMORY_DYLIB 33
VM_MEMORY_OBJC_DISPATCHERS 34
VM_MEMORY_UNSHARED_PMAP 35
VM_MEMORY_APPKIT 40
VM_MEMORY_FOUNDATION 41
VM_MEMORY_COREGRAPHICS 42
VM_MEMORY_CORESERVICES 43
VM_MEMORY_CARBON VM_MEMORY_CORESERVICES
VM_MEMORY_JAVA 44
VM_MEMORY_COREDATA 45
VM_MEMORY_COREDATA_OBJECTIDS 46
VM_MEMORY_ATS 50
VM_MEMORY_LAYERKIT 51
VM_MEMORY_CGIMAGE 52
VM_MEMORY_TCMALLOC 53
VM_MEMORY_COREGRAPHICS_DATA 54
VM_MEMORY_COREGRAPHICS_SHARED 55
VM_MEMORY_COREGRAPHICS_FRAMEBUFFERS 56
VM_MEMORY_COREGRAPHICS_BACKINGSTORES 57
VM_MEMORY_COREGRAPHICS_XALLOC 58
VM_MEMORY_COREGRAPHICS_MISC VM_MEMORY_COREGRAPHICS
VM_MEMORY_DYLD 60
VM_MEMORY_DYLD_MALLOC 61
VM_MEMORY_SQLITE 62
VM_MEMORY_JAVASCRIPT_CORE 63
VM_MEMORY_WEBASSEMBLY VM_MEMORY_JAVASCRIPT_CORE
VM_MEMORY_JAVASCRIPT_JIT_EXECUTABLE_ALLOCATOR 64
VM_MEMORY_JAVASCRIPT_JIT_REGISTER_FILE 65
VM_MEMORY_GLSL 66
VM_MEMORY_OPENCL 67
VM_MEMORY_COREIMAGE 68
VM_MEMORY_WEBCORE_PURGEABLE_BUFFERS 69
VM_MEMORY_IMAGEIO 70
VM_MEMORY_COREPROFILE 71
VM_MEMORY_ASSETSD 72
VM_MEMORY_OS_ALLOC_ONCE 73
VM_MEMORY_LIBDISPATCH 74
VM_MEMORY_ACCELERATE 75
VM_MEMORY_COREUI 76
VM_MEMORY_COREUIFILE 77
VM_MEMORY_GENEALOGY 78
VM_MEMORY_RAWCAMERA 79
VM_MEMORY_CORPSEINFO 80
VM_MEMORY_ASL 81
VM_MEMORY_SWIFT_RUNTIME 82
VM_MEMORY_SWIFT_METADATA 83
VM_MEMORY_DHMM 84
VM_MEMORY_SCENEKIT 86
VM_MEMORY_SKYWALK 87
VM_MEMORY_IOSURFACE 88
VM_MEMORY_LIBNETWORK 89
VM_MEMORY_AUDIO 90
VM_MEMORY_VIDEOBITSTREAM 91
VM_MEMORY_CM_XPC 92
VM_MEMORY_CM_RPC 93
VM_MEMORY_CM_MEMORYPOOL 94
VM_MEMORY_CM_READCACHE 95
VM_MEMORY_CM_CRABS 96
VM_MEMORY_QUICKLOOK_THUMBNAILS 97
VM_MEMORY_ACCOUNTS 98
VM_MEMORY_SANITIZER 99
VM_MEMORY_IOACCELERATOR 100
VM_MEMORY_CM_REGWARP 101
VM_MEMORY_EAR_DECODER 102
VM_MEMORY_COREUI_CACHED_IMAGE_DATA 103
VM_MEMORY_COLORSYNC 104
VM_MEMORY_BTINFO 105
VM_MEMORY_CM_HLS 106
VM_MEMORY_ROSETTA 230
VM_MEMORY_ROSETTA_THREAD_CONTEXT 231
VM_MEMORY_ROSETTA_INDIRECT_BRANCH_MAP 232
VM_MEMORY_ROSETTA_RETURN_STACK 233
VM_MEMORY_ROSETTA_EXECUTABLE_HEAP 234
VM_MEMORY_ROSETTA_USER_LDT 235
VM_MEMORY_ROSETTA_ARENA 236
VM_MEMORY_ROSETTA_10 239
VM_MEMORY_APPLICATION_SPECIFIC_1 240
VM_MEMORY_APPLICATION_SPECIFIC_16 255
VM_MEMORY_COUNT 256
VM_KERN_MEMORY_NONE 0
VM_KERN_MEMORY_OSFMK 1
VM_KERN_MEMORY_BSD 2
VM_KERN_MEMORY_IOKIT 3
VM_KERN_MEMORY_LIBKERN 4
VM_KERN_MEMORY_OSKEXT 5
VM_KERN_MEMORY_KEXT 6
VM_KERN_MEMORY_IPC 7
VM_KERN_MEMORY_STACK 8
VM_KERN_MEMORY_CPU 9
VM_KERN_MEMORY_PMAP 10
VM_KERN_MEMORY_PTE 11
VM_KERN_MEMORY_ZONE 12
VM_KERN_MEMORY_KALLOC 13
VM_KERN_MEMORY_COMPRESSOR 14
VM_KERN_MEMORY_COMPRESSED_DATA 15
VM_KERN_MEMORY_PHANTOM_CACHE 16
VM_KERN_MEMORY_WAITQ 17
VM_KERN_MEMORY_DIAG 18
VM_KERN_MEMORY_LOG 19
VM_KERN_MEMORY_FILE 20
VM_KERN_MEMORY_MBUF 21
VM_KERN_MEMORY_UBC 22
VM_KERN_MEMORY_SECURITY 23
VM_KERN_MEMORY_MLOCK 24
VM_KERN_MEMORY_REASON 25
VM_KERN_MEMORY_SKYWALK 26
VM_KERN_MEMORY_LTABLE 27
VM_KERN_MEMORY_HV 28
VM_KERN_MEMORY_KALLOC_DATA 29
VM_KERN_MEMORY_RETIRED 30
VM_KERN_MEMORY_KALLOC_TYPE 31
VM_KERN_MEMORY_TRIAGE 32
VM_KERN_MEMORY_RECOUNT 33
VM_KERN_MEMORY_EXCLAVES 35
VM_KERN_MEMORY_EXCLAVES_SHARED 36
VM_KERN_MEMORY_KALLOC_SHARED 37
VM_KERN_MEMORY_FIRST_DYNAMIC 38
VM_KERN_MEMORY_ANY 255
VM_KERN_MEMORY_COUNT 256
VM_KERN_SITE_TYPE 0x000000FF
VM_KERN_SITE_TAG 0x00000000
VM_KERN_SITE_KMOD 0x00000001
VM_KERN_SITE_KERNEL 0x00000002
VM_KERN_SITE_COUNTER 0x00000003
VM_KERN_SITE_WIRED 0x00000100
VM_KERN_SITE_HIDE 0x00000200
VM_KERN_SITE_NAMED 0x00000400
VM_KERN_SITE_ZONE 0x00000800
VM_KERN_SITE_ZONE_VIEW 0x00001000
VM_KERN_SITE_KALLOC 0x00002000
VM_KERN_COUNT_MANAGED 0
VM_KERN_COUNT_RESERVED 1
VM_KERN_COUNT_WIRED 2
VM_KERN_COUNT_WIRED_MANAGED 3
VM_KERN_COUNT_STOLEN 4
VM_KERN_COUNT_LOPAGE 5
VM_KERN_COUNT_MAP_KERNEL 6
VM_KERN_COUNT_MAP_ZONE 7
VM_KERN_COUNT_MAP_KALLOC 8
VM_KERN_COUNT_WIRED_BOOT 9
VM_KERN_COUNT_BOOT_STOLEN 10
VM_KERN_COUNT_WIRED_STATIC_KERNELCACHE 11
VM_KERN_COUNT_MAP_KALLOC_LARGE VM_KERN_COUNT_MAP_KALLOC
VM_KERN_COUNT_MAP_KALLOC_LARGE_DATA 12
VM_KERN_COUNT_MAP_KERNEL_DATA 13
VM_KERN_COUNT_EXCLAVES_CARVEOUT 14
VM_KERN_COUNTER_COUNT 15
_MACH_VM_SYNC_H_ None
_MACH_VM_TYPES_H_ None
PPNUM_MAX UINT32_MAX
MACH_VM_RANGE_FLAVOR_DEFAULT MACH_VM_RANGE_FLAVOR_V1
VM_TAG_ACTIVE_UPDATE 1
VM_TAG_NAME_LEN_MAX 0x7F
VM_TAG_NAME_LEN_SHIFT 0
VM_TAG_UNLOAD 0x0100
VM_TAG_KMOD 0x0200
_VM_UNSAFE_TYPES_H_ None
_MACHINE_ASM_H None
_MACHINE_ATOMIC_H None
_MACHINE_COMMPAGE_H None
_MACHINE_CONFIG_H None
_MACHINE_CPU_AFFINITY_H None
_MACHINE_CPU_CAPABILITIES_H None
_MACHINE_CPU_DATA_H None
_MACHINE_CPU_NUMBER_H None
_MACHINE_ENDIAN_H None
_MACHINE_LOCK_H_ None
_MACHINE_LOCKS_H_ None
_MACHINE_LOWGLOBALS_H None
_MACHINE_MACHINE_CPU_H None
_MACHINE_CPUID_H None
_MACHINE_MACHINE_KPC_H None
MACHINE_REMOTE_TIME_H None
_MACHINE_MACHINE_ROUTINES_H None
_MACHINE_MACHINE_RPC_H None
_MACHINE_MACHLIMITS_H None
_MACHINE_MACHPARAM_H None
_MACHINE_MEMORY_TYPES_H None
MACHINE_MONOTONIC_H None
_MACHINE_PAL_HIBERNATE_H None
_MACHINE_PAL_ROUTINES_H None
_MACHINE_PMAP_H None
_MACHINE_SCHED_PARAM_H None
_MACHINE_SETJMP_H None
_MACHINE_SIMPLE_LOCK_H_ None
_MACHINE_SMP_H None
_MACHINE_STATIC_IF_H None
STATIC_IF_KEY_DECLARE_TRUE(name) extern struct static_if_key_true name##_jump_key
STATIC_IF_KEY_DEFINE_TRUE(name) __used struct static_if_key_true name##_jump_key = { 	        .key.sik_init_value = 0, 	        .key.sik_enable_count = 0, 	}
STATIC_IF_KEY_DECLARE_FALSE(name) extern struct static_if_key_false name##_jump_key
STATIC_IF_KEY_DEFINE_FALSE(name) __used struct static_if_key_false name##_jump_key = { 	        .key.sik_init_value = -1, 	        .key.sik_enable_count = -1, 	}
probable_static_if(n) __probable(({                    	__label__ __l;                                          	int __result = 0;                                       	if (__static_if_key_init_value(n)) {                    	        STATIC_IF_NOP(n, __l);                          	} else {                                                	        STATIC_IF_BRANCH(n, __l);                       	}                                                       	__result = 1;                                           __l:                                                            	__result;                                               }))
improbable_static_if(n) __improbable(({                	__label__ __l;                                          	int __result = 1;                                       	if (__static_if_key_init_value(n)) {                    	        STATIC_IF_BRANCH(n, __l);                       	} else {                                                	        STATIC_IF_NOP(n, __l);                          	}                                                       	__result = 0;                                           __l:                                                            	__result;                                               }))
static_if_key_enable(n) __static_if_key_delta(&n##_jump_key.key, 1)
static_if_key_disable(n) __static_if_key_delta(&n##_jump_key.key, -1)
__static_if_init_func MARK_AS_FIXUP_TEXT
STATIC_IF_INIT(func) __PLACE_IN_SECTION(STATIC_IF_SEGMENT "," STATIC_IFINIT_SECTION) 	static static_if_initializer __static_if__ ## func = func
STATIC_IF_SECTION "__static_if"
STATIC_IFINIT_SECTION "__static_ifinit"
STATIC_IF_SEGSECT STATIC_IF_SEGMENT "," STATIC_IF_SECTION
_MACHINE_STRING_H_ None
_MACHINE_TASK_H None
_MACHINE_THREAD_H None
_MACHINE_TRAP_H None
ml_trap_pin_value_2(a, b) ({ 	register long _a __asm__(ML_TRAP_REGISTER_1) = (long)(a);               	register long _b __asm__(ML_TRAP_REGISTER_2) = (long)(b);                                                                                               	__asm__ __volatile__ ("" : "+r"(_a), "+r"(_b));                         })
ml_trap_pin_value_3(a, b, c) ({ 	register long _a __asm__(ML_TRAP_REGISTER_1) = (long)(a);               	register long _b __asm__(ML_TRAP_REGISTER_2) = (long)(b);               	register long _c __asm__(ML_TRAP_REGISTER_3) = (long)(c);                                                                                               	__asm__ __volatile__ ("" : "+r"(_a), "+r"(_b), "+r"(_c));               })
ml_fatal_trap_with_value(code, a)  ({ 	ml_trap_pin_value_1(a); 	ml_fatal_trap(code); })
ml_fatal_trap_with_value2(code, a, b)  ({ 	ml_trap_pin_value_2(a, b); 	ml_fatal_trap(code); })
ml_fatal_trap_with_value3(code, a, b, c)  ({ 	ml_trap_pin_value_3(a, b, c); 	ml_fatal_trap(code); })
_MACHINE_TRAP_INTERNAL_H None
_MACHINE_VM_TUNING_H None
_MACH_DEBUG_HASH_INFO_H_ None
_MACH_DEBUG_IPC_INFO_H_ None
_MACH_DEBUG_LOCKGROUP_INFO_H_ None
LOCKGROUP_MAX_NAME 64
LOCKGROUP_ATTR_STAT 0x01ULL
_MACH_DEBUG_MACH_DEBUG_H_ None
_MACH_DEBUG_MACH_DEBUG_TYPES_H_ None
MACH_CORE_FILEHEADER_SIGNATURE 0x0063614d20646152ULL
MACH_CORE_FILEHEADER_V2_SIGNATURE 0x63614d2073736f42ULL
MACH_CORE_FILEHEADER_MAXFILES 16
MACH_CORE_FILEHEADER_NAMELEN 16
KOBJECT_DESCRIPTION_LENGTH 512
MACH_DEBUG_PAGE_INFO_H None
_MACH_DEBUG_VM_INFO_H_ None
_MACH_DEBUG_ZONE_INFO_H_ None
ZONE_NAME_MAX_LEN 80
MACH_ZONE_NAME_MAX_LEN 80
SET_MZI_COLLECTABLE_BYTES(val, size)    	(val) = ((val) & 1) | ((size) << 1)
SET_MZI_COLLECTABLE_FLAG(val, flag)             	(val) = (flag) ? ((val) | 1) : (val)
MACH_MEMORY_INFO_NAME_MAX_LEN 80
MAX_ZTRACE_DEPTH 15
ZOP_ALLOC 1
ZOP_FREE 0
_PRNG_ENTROPY_H_ None
ENTROPY_ANALYSIS_BOOTARG "entropy-analysis-sample-count"
_PRNG_RANDOM_H_ None
RANDOM_BOOL_GEN_SEED_COUNT 4
__USERNOTIFICATION_KUNCUSERNOTIFICATIONS_H None
kOpenApplicationPath 0
kOpenPreferencePanel 1
kOpenApplication 2
kOpenAppAsRoot 0
kOpenAppAsConsoleUser 1
__USERNOTIFICATION_UNDTYPES_H None
CLUSTER_SHIFT 1
MAX_RUN 32
_VM_CPM_H_ None
device_pager_lock_init(pager) lck_mtx_init(&(pager)->lock, &device_pager_lck_grp, LCK_ATTR_NULL)
device_pager_lock_destroy(pager) lck_mtx_destroy(&(pager)->lock, &device_pager_lck_grp)
device_pager_lock(pager) lck_mtx_lock(&(pager)->lock)
device_pager_unlock(pager) lck_mtx_unlock(&(pager)->lock)
MAX_DNODE 10000
UTIL_FUNCTION static inline __attribute__((__always_inline__)) __attribute__((__overloadable__))
LZ4_ENABLE_ASSEMBLY_ENCODE_ARM64 1
LZ4_ENABLE_ASSEMBLY_DECODE_ARM64 1
LZ4_COMPRESS_HASH_BITS 10
LZ4_COMPRESS_HASH_MULTIPLY 2654435761U
LZ4_GOFAST_SAFETY_MARGIN 128
LZ4_DISTANCE_BOUND 65536
memory_object_should_return_page(m, should_return)     (should_return != MEMORY_OBJECT_RETURN_NONE &&      (((m)->vmp_dirty || ((m)->vmp_dirty = pmap_is_modified(VM_PAGE_GET_PHYS_PAGE(m)))) ||       ((m)->vmp_precious && (should_return) == MEMORY_OBJECT_RETURN_ALL) ||       (should_return) == MEMORY_OBJECT_RETURN_ANYTHING))
MEMORY_OBJECT_LOCK_RESULT_DONE 0
MEMORY_OBJECT_LOCK_RESULT_MUST_BLOCK 1
MEMORY_OBJECT_LOCK_RESULT_MUST_RETURN 2
MEMORY_OBJECT_LOCK_RESULT_MUST_FREE 3
LIST_REQ_PAGEOUT_PAGES(object, data_cnt, po, ro, ioerr, iosync)    MACRO_BEGIN                                                                                                                                     	int			upl_flags;                              	memory_object_t		pager;                                                                                                          	if ((pager = (object)->pager) != MEMORY_OBJECT_NULL) {          	        vm_object_paging_begin(object);                         	        vm_object_unlock(object);                                                                                                       	        if (iosync)                                             	                upl_flags = UPL_MSYNC | UPL_IOSYNC;             	        else                                                    	                upl_flags = UPL_MSYNC;                                                                                                  	        (void) memory_object_data_return(pager,                 	                po,                                             	                (memory_object_cluster_size_t)data_cnt,         	                ro,                                             	                ioerr,                                          	                FALSE,                                          	                FALSE,                                          	                upl_flags);                                                                                                             	        vm_object_lock(object);                                 	        vm_object_paging_end(object);                           	}                                                               MACRO_END
MAX_EXTENTS 8
_VM_MEMORY_OBJECT_H_ None
_VM_MEMORY_OBJECT_INTERNAL_H_ None
_VM_MEMORY_OBJECT_XNU_H_ None
_VM_MEMORY_TYPES_H_ None
VM_MEM_GUARDED 0x1
VM_MEM_COHERENT 0x2
VM_MEM_NOT_CACHEABLE 0x4
VM_MEM_WRITE_THROUGH 0x8
VM_WIMG_USE_DEFAULT 0x80
VM_WIMG_MASK 0xFF
_VM_PMAP_H_ None
cppvPsnk 0x000000001
cppvPsnkb 31
cppvPsrc 0x000000002
cppvPsrcb 30
cppvFsnk 0x000000004
cppvFsnkb 29
cppvFsrc 0x000000008
cppvFsrcb 28
cppvNoModSnk 0x000000010
cppvNoModSnkb 27
cppvNoRefSrc 0x000000020
cppvNoRefSrcb 26
cppvKmap 0x000000040
cppvKmapb 25
PMAP_ACTIVATE_USER(thr, cpu)
PMAP_DEACTIVATE_USER(thr, cpu)
PMAP_ACTIVATE_KERNEL(cpu) None
PMAP_DEACTIVATE_KERNEL(cpu) None
PMAP_SET_CACHE_ATTR(mem, object, cache_attr, batch_pmap_op)             	MACRO_BEGIN                                                             	        if (!batch_pmap_op) {                                           	                pmap_set_cache_attributes(VM_PAGE_GET_PHYS_PAGE(mem), cache_attr); 	                (object)->set_cache_attr = TRUE;                        	        }                                                               	MACRO_END
PMAP_BATCH_SET_CACHE_ATTR(object, user_page_list,                   	    cache_attr, num_pages, batch_pmap_op)                               	MACRO_BEGIN                                                             	        if ((batch_pmap_op)) {                                          	                const unified_page_list_t __pmap_batch_list = {         	                        .upl = {.upl_info = (user_page_list),           	                                .upl_size = (num_pages),},              	                        .type = UNIFIED_PAGE_LIST_TYPE_UPL_ARRAY,       	                };                                                      	                pmap_batch_set_cache_attributes(                        	                                &__pmap_batch_list,                     	                                (cache_attr));                          	                (object)->set_cache_attr = TRUE;                        	        }                                                               	MACRO_END
VM_MEM_MODIFIED 0x01
VM_MEM_REFERENCED 0x02
PMAP_UNNEST_CLEAN 1
VM_MEM_SUPERPAGE 0x100
VM_MEM_STACK 0x200
PMAP_CREATE_64BIT 0x1
PMAP_OPTIONS_NOWAIT 0x1
PMAP_OPTIONS_NOENTER 0x2
PMAP_OPTIONS_COMPRESSOR 0x4
PMAP_OPTIONS_INTERNAL 0x8
PMAP_OPTIONS_REUSABLE 0x10
PMAP_OPTIONS_NOFLUSH 0x20
PMAP_OPTIONS_NOREFMOD 0x40
PMAP_OPTIONS_ALT_ACCT 0x80
PMAP_OPTIONS_REMOVE 0x100
PMAP_OPTIONS_SET_REUSABLE 0x200
PMAP_OPTIONS_CLEAR_REUSABLE 0x400
PMAP_OPTIONS_COMPRESSOR_IFF_MODIFIED 0x800
PMAP_OPTIONS_PROTECT_IMMEDIATE 0x1000
PMAP_OPTIONS_CLEAR_WRITE 0x2000
PMAP_OPTIONS_TRANSLATED_ALLOW_EXECUTE 0x4000
PMAP_OPTIONS_FF_LOCKED 0x8000
PMAP_OPTIONS_FF_WIRED 0x10000
PMAP_OPTIONS_XNU_USER_DEBUG 0x20000
PMAP_OPTIONS_NOPREEMPT 0x80000
PMAP_OPTIONS_MAP_TPRO 0x40000
PMAP_OPTIONS_RESERVED_MASK 0xFF000000
PMAP_QUERY_PAGE_PRESENT 0x01
PMAP_QUERY_PAGE_REUSABLE 0x02
PMAP_QUERY_PAGE_INTERNAL 0x04
PMAP_QUERY_PAGE_ALTACCT 0x08
PMAP_QUERY_PAGE_COMPRESSED 0x10
PMAP_QUERY_PAGE_COMPRESSED_ALTACCT 0x20
_VM_PMAP_CS_H_ None
CRYPT_INFO_DEBUG 0
C_SEG_BUFSIZE_DEFAULT C_SEG_BUFSIZE_ARM_SWAP
PACK_C_SIZE(cs, size)   (cs->c_size = ((size == PAGE_SIZE) ? PAGE_SIZE - 1 : size))
he_ref c_sv_he_un.c_sv_he.c_sv_he_ref
he_data c_sv_he_un.c_sv_he.c_sv_he_data
he_record c_sv_he_un.c_sv_he_record
C_SV_HASH_MAX_MISS 32
C_SLOT_ASSERT_PACKABLE(ptr) VM_ASSERT_POINTER_PACKABLE((vm_offset_t)(ptr), C_SLOT_PACKED_PTR);
C_SLOT_PACK_PTR(ptr) VM_PACK_POINTER((vm_offset_t)(ptr), C_SLOT_PACKED_PTR)
BSD_HOST 1
C_SWAPOUT_LIMIT 4
DELAYED_COMPACTIONS_PER_PASS 30
TIME_SUB(rsecs, secs, rfrac, frac, unit)                        	MACRO_BEGIN                                                     	if ((int)((rfrac) -= (frac)) < 0) {                             	        (rfrac) += (unit);                                      	        (rsecs) -= 1;                                           	}                                                               	(rsecs) -= (secs);                                              	MACRO_END
C_SEGMENT_SWAPPEDIN_AGE_LIMIT 10
_VM_COMPRESSOR_ALGORITHMS_INTERNAL_H_ None
SWAP_READY 0x1
SWAP_RECLAIM 0x2
SWAP_WANTED 0x4
SWAP_REUSE 0x8
SWAP_PINNED 0x10
VM_SWAPOUT_LIMIT_T2P 4
VM_SWAPOUT_LIMIT_T1P 4
VM_SWAPOUT_LIMIT_T0P 6
VM_SWAPOUT_LIMIT_T0 8
VM_SWAPOUT_LIMIT_MAX 8
VM_SWAPOUT_START 0
VM_SWAPOUT_T2_PASSIVE 1
VM_SWAPOUT_T1_PASSIVE 2
VM_SWAPOUT_T0_PASSIVE 3
VM_SWAPOUT_T0 4
_VM_VM_COMPRESSOR_BACKING_STORE_H_ None
SWAP_VOLUME_NAME "/System/Volumes"
SWAP_FILE_NAME SWAP_VOLUME_NAME "/VM/swapfile"
SWAP_SLOT_MASK 0x1FFFFFFFF
SWAP_DEVICE_SHIFT 33
_VM_VM_COMPRESSOR_BACKING_STORE_XNU_H_ None
VM_C_SEGMENT_INFO_MAGIC 'C002'
VM_MAP_ENTRY_INFO_MAGIC 'S001'
_VM_VM_COMPRESSOR_INTERNAL_H_ None
compressor_pager_lookup(_mem_obj_, _cpgr_)                      	MACRO_BEGIN                                                     	if (_mem_obj_ == NULL ||                                        	    _mem_obj_->mo_pager_ops != &compressor_pager_ops) {         	        _cpgr_ = NULL;                                          	} else {                                                        	        _cpgr_ = (compressor_pager_t) _mem_obj_;                	}                                                               	MACRO_END
compressor_pager_lock(_cpgr_) lck_mtx_lock(&(_cpgr_)->cpgr_lock)
compressor_pager_unlock(_cpgr_) lck_mtx_unlock(&(_cpgr_)->cpgr_lock)
compressor_pager_lock_init(_cpgr_) lck_mtx_init(&(_cpgr_)->cpgr_lock, &compressor_pager_lck_grp, LCK_ATTR_NULL)
compressor_pager_lock_destroy(_cpgr_) lck_mtx_destroy(&(_cpgr_)->cpgr_lock, &compressor_pager_lck_grp)
NUM_SLOTS_ZONES 3
_VM_VM_COMPRESSOR_PAGER_INTERNAL_H_ None
_VM_VM_COMPRESSOR_PAGER_XNU_H_ None
_VM_VM_COMPRESSOR_XNU_H_ None
C_SEG_OFFSET_BITS 16
CHECKSUM_THE_SWAP ENABLE_SWAP_CHECKS
CHECKSUM_THE_DATA ENABLE_COMPRESSOR_CHECKS
CHECKSUM_THE_COMPRESSED_DATA ENABLE_COMPRESSOR_CHECKS
VALIDATE_C_SEGMENTS ENABLE_COMPRESSOR_CHECKS
RECORD_THE_COMPRESSED_DATA 0
TRACK_C_SEGMENT_UTILIZATION 0
C_IS_EMPTY 0
C_IS_FREE 1
C_IS_FILLING 2
C_ON_AGE_Q 3
C_ON_SWAPOUT_Q 4
C_ON_SWAPPEDOUT_Q 5
C_ON_SWAPPEDOUTSPARSE_Q 6
C_ON_SWAPPEDIN_Q 7
C_ON_MAJORCOMPACT_Q 8
C_ON_BAD_Q 9
C_ON_SWAPIO_Q 10
C_SEG_SLOT_FROM_INDEX(cseg, index)      (index < c_seg_fixed_array_len ? &(cseg->c_slot_fixed_array[index]) : &(cseg->c_slot_var_array[index - c_seg_fixed_array_len]))
C_SEG_OFFSET_ALIGNMENT_MASK 0x3ULL
C_SEG_OFFSET_ALIGNMENT_BOUNDARY 0x4
C_SEG_WAKEUP_DONE(cseg) MACRO_BEGIN                                     	assert((cseg)->c_busy);                         	(cseg)->c_busy = 0;                             	assert((cseg)->c_busy_for_thread != NULL);      	(cseg)->c_busy_for_thread = NULL;               	if ((cseg)->c_wanted) {                         	        (cseg)->c_wanted = 0;                   	        thread_wakeup((event_t) (cseg));        	}                                               	MACRO_END
C_SEG_BUSY(cseg) MACRO_BEGIN                                     	assert((cseg)->c_busy == 0);                    	(cseg)->c_busy = 1;                             	assert((cseg)->c_busy_for_thread == NULL);      	(cseg)->c_busy_for_thread = current_thread();   	MACRO_END
COMPRESSOR_SCRATCH_BUF_SIZE vm_compressor_get_encode_scratch_size()
HIBERNATE_FLUSHING_SECS_TO_COMPLETE 120
VM_VM_DEBUG_H None
_VM_DYLD_PAGER_H_ None
MWL_MIN_LINK_INFO_SIZE sizeof(struct mwl_info_hdr)
_VM_DYLD_PAGER_INTERNAL_H_ None
VM_VM_EXTERNAL_H_ None
VM_EXTERNAL_STATE_EXISTS 1
VM_EXTERNAL_STATE_UNKNOWN 2
VM_EXTERNAL_STATE_ABSENT 3
VM_FAR_ACCESSOR None
VM_FAR_ADD_PTR_UNBOUNDED(ptr, idx) 	((__typeof__((ptr))) vm_far_add_ptr_internal( 	        (ptr), (idx), sizeof(__typeof__(*(ptr))), sizeof((idx)) <= 4))
VM_FAR_ADD_PTR_BOUNDED_FATAL_UNSIGNED(ptr, idx, count) 	((__typeof__((ptr))) vm_far_add_ptr_bounded_fatal_unsigned_internal( 	        (ptr), (idx), (count), sizeof(__typeof__(*(ptr))), 	        sizeof((idx)) <= 4))
VM_FAR_ADD_PTR_BOUNDED_POISON_UNSIGNED(ptr, idx, count) 	((__typeof__((ptr))) vm_far_add_ptr_bounded_poison_unsigned_internal( 	        (ptr), (idx), (count), sizeof(__typeof__(*(ptr))), 	        sizeof((idx)) <= 4))
VM_FAULT_CLASSIFY 0
TRACEFAULTPAGE 0
HARD_THROTTLE_DELAY 10000
SOFT_THROTTLE_DELAY 200
VM_PAGE_CREATION_THROTTLE_PERIOD_SECS 6
VM_PAGE_CREATION_THROTTLE_RATE_PER_SEC 20000
VM_STAT_DECOMPRESSIONS() MACRO_BEGIN                             	counter_inc(&vm_statistics_decompressions); 	current_thread()->decompressions++; MACRO_END
VM_DEFAULT_DEACTIVATE_BEHIND_WINDOW 128
VM_DEFAULT_DEACTIVATE_BEHIND_CLUSTER 16
MUST_ASK_PAGER(o, f, s)                                 	((s = vm_object_compressor_pager_state_get((o), (f))) != VM_EXTERNAL_STATE_ABSENT)
PAGED_OUT(o, f) 	(vm_object_compressor_pager_state_get((o), (f)) == VM_EXTERNAL_STATE_EXISTS)
__PATH_MAX 1024
__VM_PAGE_LOCKSPIN_QUEUES_IF_NEEDED() MACRO_BEGIN                                     	if (! page_queues_locked) {             	        page_queues_locked = TRUE;      	        vm_page_lockspin_queues();      	}                                       MACRO_END
__VM_PAGE_UNLOCK_QUEUES_IF_NEEDED() MACRO_BEGIN                                     	if (page_queues_locked) {               	        page_queues_locked = FALSE;     	        vm_page_unlock_queues();        	}                                       MACRO_END
RELEASE_PAGE(m) MACRO_BEGIN                                     	vm_page_wakeup_done(VM_PAGE_OBJECT(m), m);                            	if ( !VM_PAGE_PAGEABLE(m)) {                    	        vm_page_lockspin_queues();              	        if ( !VM_PAGE_PAGEABLE(m))              	                vm_page_activate(m);            	        vm_page_unlock_queues();                	}                                               	MACRO_END
RELEASE_PAGE(m) {                               	vm_page_wakeup_done(VM_PAGE_OBJECT(m), m);                            	vm_page_lockspin_queues();                      	vm_page_unwire(m, TRUE);                        	vm_page_unlock_queues();                        }
UNLOCK_THINGS {                               	vm_object_paging_end(object);                      	vm_object_unlock(object);                          }
UNLOCK_AND_DEALLOCATE {                       	UNLOCK_THINGS;                                  	vm_object_deallocate(object);                   }
GIVE_UP {                                       	UNLOCK_AND_DEALLOCATE;                          	return(KERN_FAILURE);                           }
RETURN(x) MACRO_BEGIN                                     	*copy_size -= amount_left;                      	MACRO_RETURN(x);                                	MACRO_END
VM_FAULT_TYPES_MAX 5
VM_FAULT_LEVEL_MAX 8
VM_FAULT_TYPE_ZERO_FILL 0
VM_FAULT_TYPE_MAP_IN 1
VM_FAULT_TYPE_PAGER 2
VM_FAULT_TYPE_COPY 3
VM_FAULT_TYPE_OTHER 4
_VM_VM_FAULT_H_ None
_VM_VM_FAULT_INTERNAL_H_ None
_VM_VM_FAULT_XNU_H_ None
VM_INIT_XNU_H None
_VM_VM_IOKIT_H_ None
mach_vm_range_load(r, rmin, rmax) 	({ (rmin) = (r)->min_address; (rmax) = (r)->max_address; })
KMEM_META_PRIMARY UINT8_MAX
KMEM_NUM_GUARDS 2
kmem_meta_lock() lck_mtx_lock(&kmem_meta_region_lck)
kmem_meta_unlock() lck_mtx_unlock(&kmem_meta_region_lck)
VM_USER_WIREABLE_MIN_CONFIG 32
VM_USER_SERVERPERF_WIRE_LIMIT_PERCENT 95
VM_USER_SERVERPERF_WIREABLE_MIN_CONFIG 35
KMEM_MAX_CLAIMS 50
_VM_VM_KERN_H_ None
_VM_VM_KERN_INTERNAL_H_ None
KMEM_RANGE_MASK 0x3fff
KMEM_HASH_SET 0x4000
KMEM_DIRECTION_MASK 0x8000
_VM_VM_KERN_XNU_H_ None
ZSECURITY_NOT_A_COMPILE_TIME_CONFIG__OFF() 0
ZSECURITY_NOT_A_COMPILE_TIME_CONFIG__ON() 1
ZSECURITY_CONFIG2(v) ZSECURITY_NOT_A_COMPILE_TIME_CONFIG__##v()
ZSECURITY_CONFIG1(v) ZSECURITY_CONFIG2(v)
ZSECURITY_CONFIG(opt) ZSECURITY_CONFIG1(ZSECURITY_CONFIG_##opt)
KMEM_RANGE_REGISTER_STATIC(name, range, size)                    	static __startup_data struct kmem_range_startup_spec                       	__startup_kmem_range_spec_ ## name = { #name, range, size, NULL, KC_NONE}; 	STARTUP_ARG(KMEM, STARTUP_RANK_SECOND, kmem_range_startup_init,            	    &__startup_kmem_range_spec_ ## name)
KMEM_RANGE_REGISTER_DYNAMIC(name, range, calculate_sz)           	static __startup_data struct kmem_range_startup_spec                       	__startup_kmem_range_spec_ ## name = { #name, range, 0, calculate_sz,      	    KC_NONE};                                                              	STARTUP_ARG(KMEM, STARTUP_RANK_SECOND, kmem_range_startup_init,            	    &__startup_kmem_range_spec_ ## name)
VM_MAP_ZAP_DECLARE(zap) struct vm_map_zap zap = { .vmz_tail = &zap.vmz_head }
VM_MAP_ZONE_NAME "maps"
VM_MAP_ENTRY_ZONE_NAME "VM map entries"
VM_MAP_HOLES_ZONE_NAME "VM map holes"
VM_MAP_EARLY_COUNT_MAX 16
MALLOC_NO_COW_DEFAULT 1
MALLOC_NO_COW_EXCEPT_FORK_DEFAULT 1
relocate(type_t, field)  ({ 	typeof(((type_t)NULL)->field) *__field = &((type_t)new_addr)->field;   	if (*__field) {                                                        	        *__field = (typeof(*__field))((vm_offset_t)*__field + delta);  	}                                                                      })
vm_map_entry_create(map) _vm_map_entry_create(&(map)->hdr)
vm_map_copy_entry_create(copy) _vm_map_entry_create(&(copy)->cpy_hdr)
vm_map_copy_entry_dispose(copy_entry) vm_map_entry_dispose(copy_entry)
vm_map_copy_entry_link(copy, after_where, entry)                	_vm_map_store_entry_link(&(copy)->cpy_hdr, after_where, (entry))
vm_map_copy_entry_unlink(copy, entry)                           	_vm_map_store_entry_unlink(&(copy)->cpy_hdr, (entry), false)
MAX_TRIES_TO_GET_RANDOM_ADDRESS 1000
RETURN(value) { result = value; goto BailOut; }
vm_map_copy_clip_start(copy, entry, startaddr) 	MACRO_BEGIN 	if ((startaddr) > (entry)->vme_start) 	        _vm_map_clip_start(&(copy)->cpy_hdr,(entry),(startaddr)); 	MACRO_END
vm_map_copy_clip_end(copy, entry, endaddr) 	MACRO_BEGIN 	if ((endaddr) < (entry)->vme_end) 	        _vm_map_clip_end(&(copy)->cpy_hdr,(entry),(endaddr)); 	MACRO_END
VM_MAP_RANGE_CHECK(map, start, end)     	MACRO_BEGIN                             	if (start < vm_map_min(map))            	        start = vm_map_min(map);        	if (end > vm_map_max(map))              	        end = vm_map_max(map);          	if (start > end)                        	        start = end;                    	MACRO_END
RETURN(x) MACRO_BEGIN                                             	vm_map_unlock(src_map);                                 	if(src_map != base_map)                                 	        vm_map_deallocate(src_map);                     	if (new_entry != VM_MAP_ENTRY_NULL)                     	        vm_map_copy_entry_dispose(new_entry);           	vm_map_copy_discard(copy);                              	{                                                       	        submap_map_t	*_ptr;                                                                                          	        for(_ptr = parent_maps; _ptr != NULL; _ptr = parent_maps) { 	                parent_maps=parent_maps->next;          	                if (_ptr->parent_map != base_map)       	                        vm_map_deallocate(_ptr->parent_map);    	                kfree_type(submap_map_t, _ptr);         	        }                                               	}                                                       	MACRO_RETURN(x);                                        	MACRO_END
OBJ_RESIDENT_COUNT(obj, entry_size)                             	MIN((entry_size),                                               	    ((obj)->all_reusable ?                                      	     (obj)->wired_page_count :                                  	     (obj)->resident_page_count - (obj)->reusable_page_count))
cf_last_zeroes cfu.cfu_last_zeroes
cf_hint_region cfu.cfu_hint_region
_VM_VM_MAP_H_ None
vm_map_round_page(x, pgmask) 	(((vm_map_offset_t)(x) + (pgmask)) & ~((signed)(pgmask)))
vm_map_trunc_page(offset, pgmask) 	((vm_map_offset_t)(offset) & ~((signed)(pgmask)))
_VM_VM_MAP_INTERNAL_H_ None
VM_ABI_32 0x1
VM_ABI_64 0x2
VM_MAP_COPYIN_SRC_DESTROY 0x00000001
VM_MAP_COPYIN_USE_MAXPROT 0x00000002
VM_MAP_COPYIN_ENTRY_LIST 0x00000004
VM_MAP_COPYIN_PRESERVE_PURGEABLE 0x00000008
VM_MAP_COPYIN_FORK 0x00000010
VM_MAP_COPYIN_ALL_FLAGS 0x0000001F
_VM_VM_MAP_STORE_H None
VM_MAP_STORE_USE_RB None
SAVE_HINT_MAP_WRITE(map, value) 	MACRO_BEGIN                    	(map)->hint = (value);         	MACRO_END
SAVE_HINT_HOLE_WRITE(map, value) 	MACRO_BEGIN                    	(map)->hole_hint = (value);     	MACRO_END
SKIP_RB_TREE 0xBAADC0D1
_VM_VM_MAP_STORE_LL_H None
VME_FOR_STORE(ptr) __container_of(ptr, struct vm_map_entry, store)
_VM_VM_MAP_STORE_H_RB None
_VM_VM_MAP_XNU_H_ None
named_entry_lock_init(object) lck_mtx_init(&(object)->Lock, &vm_object_lck_grp, &vm_object_lck_attr)
named_entry_lock_destroy(object) lck_mtx_destroy(&(object)->Lock, &vm_object_lck_grp)
named_entry_lock(object) lck_mtx_lock(&(object)->Lock)
named_entry_unlock(object) lck_mtx_unlock(&(object)->Lock)
VME_ALIAS_BITS 12
VME_OFFSET_SHIFT VME_ALIAS_BITS
VME_SUBMAP_SHIFT 2
vme_prev links.prev
vme_next links.next
vme_start links.start
vme_end links.end
MAX_WIRE_COUNT 65535
min_offset hdr.links.start
max_offset hdr.links.end
highest_entry_end vmu1.vmu1_highest_entry_end
lowest_unnestable_start vmu1.vmu1_lowest_unnestable_start
hole_hint vmmap_u_1.vmmap_hole_hint
vmmap_corpse_footprint vmmap_u_1.vmmap_corpse_footprint
first_free f_s._first_free
holes_list f_s._holes
vm_map_to_entry(map) CAST_TO_VM_MAP_ENTRY(&(map)->hdr.links)
VM_MAP_COPY_ENTRY_LIST 1
VM_MAP_COPY_KERNEL_BUFFER 2
cpy_hdr c_u.hdr
cpy_kdata c_u.kdata
vm_map_copy_to_entry(copy) CAST_TO_VM_MAP_ENTRY(&(copy)->cpy_hdr.links)
vm_map_lock(map) MACRO_BEGIN                          	DTRACE_VM(vm_map_lock_w);            	lck_rw_lock_exclusive(&(map)->lock); 	MACRO_END
vm_map_unlock(map) MACRO_BEGIN                 	DTRACE_VM(vm_map_unlock_w); 	(map)->timestamp++;         	lck_rw_done(&(map)->lock);  	MACRO_END
vm_map_lock_read(map) MACRO_BEGIN                       	DTRACE_VM(vm_map_lock_r);         	lck_rw_lock_shared(&(map)->lock); 	MACRO_END
vm_map_unlock_read(map) MACRO_BEGIN                 	DTRACE_VM(vm_map_unlock_r); 	lck_rw_done(&(map)->lock);  	MACRO_END
vm_map_lock_write_to_read(map) MACRO_BEGIN                                    	DTRACE_VM(vm_map_lock_downgrade);              	(map)->timestamp++;                            	lck_rw_lock_exclusive_to_shared(&(map)->lock); 	MACRO_END
vm_map_lock_assert_held(map) LCK_RW_ASSERT(&(map)->lock, LCK_RW_ASSERT_HELD)
vm_map_lock_assert_shared(map) LCK_RW_ASSERT(&(map)->lock, LCK_RW_ASSERT_SHARED)
vm_map_lock_assert_exclusive(map) LCK_RW_ASSERT(&(map)->lock, LCK_RW_ASSERT_EXCLUSIVE)
vm_map_lock_assert_notheld(map) LCK_RW_ASSERT(&(map)->lock, LCK_RW_ASSERT_NOTHELD)
vm_map_entry_wait(map, interruptible)           	((map)->timestamp++ ,                           	 lck_rw_sleep(&(map)->lock, LCK_SLEEP_EXCLUSIVE|LCK_SLEEP_PROMOTED_PRI, 	                          (event_t)&(map)->hdr,	interruptible))
vm_map_entry_wakeup(map) thread_wakeup((event_t)(&(map)->hdr))
VM_MAP_FORK_SHARE_IF_INHERIT_NONE 0x00000001
VM_MAP_FORK_PRESERVE_PURGEABLE 0x00000002
VM_MAP_FORK_CORPSE_FOOTPRINT 0x00000004
VM_MAP_FORK_SHARE_IF_OWNED 0x00000008
VM_MAP_ROUND_PAGE(x, pgmask) (((vm_map_offset_t)(x) + (pgmask)) & ~((signed)(pgmask)))
VM_MAP_TRUNC_PAGE(x, pgmask) ((vm_map_offset_t)(x) & ~((signed)(pgmask)))
VM_MAP_PAGE_ALIGNED(x, pgmask) (((x) & (pgmask)) == 0)
VM_OBJECT_ID_FAKE(map, ledger_id) ((uint32_t)(uintptr_t)VM_KERNEL_ADDRHASH((int*)((map)->pmap->ledger)+(ledger_id)))
TRANSFER_ENTITLEMENT_MAX_LENGTH 1024
_MACH_MEMORY_ENTRY_ None
_VM_VM_MEMORY_ENTRY_XNU_H_ None
_MACH_VM_MEMTAG_H_ None
vm_object_cache_lock_spin() lck_mtx_lock_spin(&vm_object_cached_lock_data)
vm_object_cache_unlock() lck_mtx_unlock(&vm_object_cached_lock_data)
vm_object_reaper_lock() lck_mtx_lock(&vm_object_reaper_lock_data)
vm_object_reaper_lock_spin() lck_mtx_lock_spin(&vm_object_reaper_lock_data)
vm_object_reaper_unlock() lck_mtx_unlock(&vm_object_reaper_lock_data)
EVICT_PREPARE_LIMIT 64
EVICT_AGE 10
V_O_R_MAX_BATCH 128
PAGES_IN_A_CHUNK 64
CHUNK_INIT(c, len)                                              	MACRO_BEGIN                                                     	uint64_t p;                                                                                                                             	(c) = 0xffffffffffffffffLL;                                                                                                             	for (p = (len) / PAGE_SIZE_64; p < PAGES_IN_A_CHUNK; p++)       	        MARK_PAGE_HANDLED(c, p);                                	MACRO_END
PAGE_ALREADY_HANDLED(c, p)      (((c) & (1ULL << (p))) == 0)
MARK_PAGE_HANDLED(c, p) MACRO_BEGIN 	(c) = (c) & ~(1ULL << (p)); MACRO_END
VM_OBJECT_REUSE_PAGE(object, m, reused)                         	MACRO_BEGIN                                                     	        if ((m) != VM_PAGE_NULL &&                              	            (m)->vmp_reusable) {                                	                assert((object)->reusable_page_count <=         	                       (object)->resident_page_count);          	                assert((object)->reusable_page_count > 0);      	                (object)->reusable_page_count--;                	                (m)->vmp_reusable = FALSE;                      	                (reused)++;                                     	                                                             	                pmap_clear_refmod_options(VM_PAGE_GET_PHYS_PAGE((m)), 	                                          0,        	                                          (PMAP_OPTIONS_CLEAR_REUSABLE 	                                           | PMAP_OPTIONS_NOFLUSH), 	                                          NULL);                	        }                                                       	MACRO_END
EXISTS_IN_OBJECT(obj, off, rc)                  	((vm_object_compressor_pager_state_get((obj), (off))   	  == VM_EXTERNAL_STATE_EXISTS) ||               	 ((rc) && vm_page_lookup((obj), (off)) != VM_PAGE_NULL && (rc)--))
__TRANSPOSE_FIELD(field) MACRO_BEGIN                                                     	tmp_object->field = object1->field;                     	object1->field = object2->field;                        	object2->field = tmp_object->field;                     MACRO_END
MAX_FREE_BATCH 32
FREEZER_DUTY_CYCLE_ON_MS 5
FREEZER_DUTY_CYCLE_OFF_MS 5
_VM_VM_OBJECT_INTERNAL_H_ None
vm_object_lock_init(object) lck_rw_init(&(object)->Lock, &vm_object_lck_grp,                	            (is_kernel_object(object) ?                         	             &kernel_object_lck_attr :                          	             (((object) == compressor_object) ?                 	             &compressor_object_lck_attr :                      	              &vm_object_lck_attr)))
vm_object_lock_destroy(object) lck_rw_destroy(&(object)->Lock, &vm_object_lck_grp)
vm_object_lock_try_scan(object) _vm_object_lock_try(object)
vm_object_lock_assert_held(object) LCK_RW_ASSERT(&(object)->Lock, LCK_RW_ASSERT_HELD)
vm_object_lock_assert_shared(object) LCK_RW_ASSERT(&(object)->Lock, LCK_RW_ASSERT_SHARED)
vm_object_lock_assert_exclusive(object) LCK_RW_ASSERT(&(object)->Lock, LCK_RW_ASSERT_EXCLUSIVE)
vm_object_lock_assert_notheld(object) LCK_RW_ASSERT(&(object)->Lock, LCK_RW_ASSERT_NOTHELD)
REAP_REAP 0
REAP_TERMINATE 1
REAP_PURGEABLE 2
REAP_DATA_FLUSH 3
VM_OBJECT_EVENT_MAX VM_OBJECT_EVENT_PAGEIN_THROTTLE
_VM_VM_OBJECT_XNU_H_ None
vo_size vo_un1.vou_size
vo_cache_pages_to_scan vo_un1.vou_cache_pages_to_scan
vo_shadow_offset vo_un2.vou_shadow_offset
vo_cache_ts vo_un2.vou_cache_ts
vo_owner vo_un2.vou_owner
VM_OBJECT_WIRED(object, tag)                                        MACRO_BEGIN                                                             assert(VM_KERN_MEMORY_NONE != (tag));                                   assert(VM_KERN_MEMORY_NONE == (object)->wire_tag);                      (object)->wire_tag = (tag);                                             if (!VM_TAG_ACTIVE_UPDATE) {                                        	VM_OBJECT_WIRED_ENQUEUE((object));                                  }                                                                       MACRO_END
VM_OBJECT_UNWIRED(object) MACRO_BEGIN                                                                             if (!VM_TAG_ACTIVE_UPDATE) {                                                        	    VM_OBJECT_WIRED_DEQUEUE((object));                                              }                                                                                       if (VM_KERN_MEMORY_NONE != (object)->wire_tag) {                                    	vm_tag_update_size((object)->wire_tag, -ptoa_64((object)->wired_page_count), (object));   	(object)->wire_tag = VM_KERN_MEMORY_NONE;                                           }                                                                                       MACRO_END
VM_OBJECT_WIRED_PAGE_UPDATE_START(object) MACRO_BEGIN                                                                             {                                                                                   	int64_t __wireddelta = 0; vm_tag_t __waswired = (object)->wire_tag;
VM_OBJECT_WIRED_PAGE_UPDATE_END(object, tag)                                    	if (__wireddelta) {                                                             	    boolean_t __overflow __assert_only =                                        	    os_add_overflow((object)->wired_page_count, __wireddelta,                   	                    &(object)->wired_page_count);                               	    assert(!__overflow);                                                        	    if (!(object)->internal &&                                  	        (object)->vo_ledger_tag &&                              	        VM_OBJECT_OWNER((object)) != NULL) {                    	            vm_object_wired_page_update_ledgers(object, __wireddelta); 	    }                                                           	    if (!(object)->pageout && !(object)->no_tag_update) {                       	        if (__wireddelta > 0) {                                                 	            assert (VM_KERN_MEMORY_NONE != (tag));                              	            if (VM_KERN_MEMORY_NONE == __waswired) {                            	                VM_OBJECT_WIRED((object), (tag));                               	            }                                                                   	            vm_tag_update_size((object)->wire_tag, ptoa_64(__wireddelta), (object));      	        } else if (VM_KERN_MEMORY_NONE != __waswired) {                         	            assert (VM_KERN_MEMORY_NONE != (object)->wire_tag);                 	            vm_tag_update_size((object)->wire_tag, ptoa_64(__wireddelta), (object));      	            if (!(object)->wired_page_count) {                                  	                VM_OBJECT_UNWIRED((object));                                    	            }                                                                   	        }                                                                       	    }                                                                           	}                                                                                   }                                                                                       MACRO_END
VM_OBJECT_WIRED_PAGE_COUNT(object, delta)                   __wireddelta += delta;
VM_OBJECT_WIRED_PAGE_ADD(object, m)                         if (vm_page_is_canonical(m)) __wireddelta++;
VM_OBJECT_WIRED_PAGE_REMOVE(object, m)                      if (vm_page_is_canonical(m)) __wireddelta--;
OBJECT_LOCK_SHARED 0
OBJECT_LOCK_EXCLUSIVE 1
__VM_VM_OPTIONS_H__ None
VM_PAGE_BUCKETS_CHECK DEBUG
VM_PAGE_FAKE_BUCKETS 1
VM_OBJECT_TRACKING 0
_VM_VM_PAGE_H_ None
VM_PAGE_COMPRESSOR_COUNT os_atomic_load(&compressor_object->resident_page_count, relaxed)
VM_PAGE_NOT_ON_Q 0
VM_PAGE_IS_WIRED 1
VM_PAGE_USED_BY_COMPRESSOR 2
VM_PAGE_ON_FREE_Q 3
VM_PAGE_ON_FREE_LOCAL_Q 4
VM_PAGE_ON_FREE_LOPAGE_Q 5
VM_PAGE_ON_THROTTLED_Q 6
VM_PAGE_ON_PAGEOUT_Q 7
VM_PAGE_ON_SPECULATIVE_Q 8
VM_PAGE_ON_ACTIVE_LOCAL_Q 9
VM_PAGE_ON_ACTIVE_Q 10
VM_PAGE_ON_INACTIVE_INTERNAL_Q 11
VM_PAGE_ON_INACTIVE_EXTERNAL_Q 12
VM_PAGE_ON_INACTIVE_CLEANED_Q 13
VM_PAGE_ON_SECLUDED_Q 14
VM_PAGE_Q_STATE_LAST_VALID_VALUE 14
vmp_pageq vmp_q_un.vmp_q_pageq
vmp_snext vmp_q_un.vmp_q_snext
vmp_local_id vmp_wire_count
VM_VPLQ_ALIGNMENT 128
VM_PAGE_PACKED_PTR_ALIGNMENT 64
VM_PAGE_PACKED_ALIGNED __attribute__((aligned(VM_PAGE_PACKED_PTR_ALIGNMENT)))
VM_PAGE_PACKED_PTR_BITS 31
VM_PAGE_PACKED_PTR_SHIFT 6
VM_PAGE_PACKED_FROM_ARRAY 0x80000000
VM_PAGE_PACK_PTR(p) vm_page_pack_ptr((uintptr_t)(p))
VM_PAGE_UNPACK_PTR(p) vm_page_unpack_ptr((uintptr_t)(p))
VM_PAGE_OBJECT(p) VM_OBJECT_UNPACK((p)->vmp_object)
VM_PAGE_PACK_OBJECT(o) VM_OBJECT_PACK(o)
VM_PAGE_ZERO_PAGEQ_ENTRY(p) MACRO_BEGIN                             	(p)->vmp_snext = 0;             MACRO_END
VM_PAGE_CONVERT_TO_QUEUE_ENTRY(p) VM_PAGE_PACK_PTR(p)
vm_page_queue_init(q) MACRO_BEGIN                                 	VM_ASSERT_POINTER_PACKABLE((vm_offset_t)(q), VM_PAGE_PACKED_PTR); 	(q)->next = VM_PAGE_PACK_PTR(q);        	(q)->prev = VM_PAGE_PACK_PTR(q);        MACRO_END
vm_page_queue_enter(head, elt, field)                       MACRO_BEGIN                                                         	vm_page_packed_t __pck_elt = VM_PAGE_PACK_PTR(elt);         	vm_page_packed_t __pck_head = VM_PAGE_PACK_PTR(head);       	vm_page_packed_t __pck_prev = (head)->prev;                                                                                     	if (__pck_head == __pck_prev) {                             	        (head)->next = __pck_elt;                           	} else {                                                    	        vm_page_t __prev;                                   	        __prev = (vm_page_t)VM_PAGE_UNPACK_PTR(__pck_prev); 	        __prev->field.next = __pck_elt;                     	}                                                           	(elt)->field.prev = __pck_prev;                             	(elt)->field.next = __pck_head;                             	(head)->prev = __pck_elt;                                   MACRO_END
vm_page_queue_enter_first(head, elt, field)                 MACRO_BEGIN                                                         	vm_page_packed_t __pck_next = (head)->next;                 	vm_page_packed_t __pck_head = VM_PAGE_PACK_PTR(head);       	vm_page_packed_t __pck_elt = VM_PAGE_PACK_PTR(elt);                                                                             	if (__pck_head == __pck_next) {                             	        (head)->prev = __pck_elt;                           	} else {                                                    	        vm_page_t __next;                                   	        __next = (vm_page_t)VM_PAGE_UNPACK_PTR(__pck_next); 	        __next->field.prev = __pck_elt;                     	}                                                                                                                               	(elt)->field.next = __pck_next;                             	(elt)->field.prev = __pck_head;                             	(head)->next = __pck_elt;                                   MACRO_END
vm_page_queue_remove(head, elt, field)                          MACRO_BEGIN                                                             	vm_page_packed_t __pck_next = (elt)->field.next;                	vm_page_packed_t __pck_prev = (elt)->field.prev;                	vm_page_t        __next = (vm_page_t)VM_PAGE_UNPACK_PTR(__pck_next); 	vm_page_t        __prev = (vm_page_t)VM_PAGE_UNPACK_PTR(__pck_prev);                                                                         	if ((void *)(head) == (void *)__next) {                         	        (head)->prev = __pck_prev;                              	} else {                                                        	        __next->field.prev = __pck_prev;                        	}                                                                                                                                       	if ((void *)(head) == (void *)__prev) {                         	        (head)->next = __pck_next;                              	} else {                                                        	        __prev->field.next = __pck_next;                        	}                                                                                                                                       	(elt)->field.next = 0;                                          	(elt)->field.prev = 0;                                          MACRO_END
vm_page_queue_remove_first(head, entry, field)            MACRO_BEGIN                                                       	vm_page_packed_t __pck_head = VM_PAGE_PACK_PTR(head);     	vm_page_packed_t __pck_next;                              	vm_page_t        __next;                                                                                                    	(entry) = (vm_page_t)VM_PAGE_UNPACK_PTR((head)->next);    	__pck_next = (entry)->field.next;                         	__next = (vm_page_t)VM_PAGE_UNPACK_PTR(__pck_next);                                                                         	if (__pck_head == __pck_next) {                           	        (head)->prev = __pck_head;                        	} else {                                                  	        __next->field.prev = __pck_head;                  	}                                                                                                                           	(head)->next = __pck_next;                                	(entry)->field.next = 0;                                  	(entry)->field.prev = 0;                                  MACRO_END
vm_page_queue_end(q, qe)        ((q) == (qe))
vm_page_queue_empty(q) vm_page_queue_end((q), ((vm_page_queue_entry_t)vm_page_queue_first(q)))
vm_page_queue_iterate(head, elt, field)                       	for ((elt) = (vm_page_t)vm_page_queue_first(head);            	    !vm_page_queue_end((head), (vm_page_queue_entry_t)(elt)); 	    (elt) = (vm_page_t)vm_page_queue_next(&(elt)->field))
VM_PAGE_RESERVED_SPECULATIVE_AGE_Q 40
VM_PAGE_DEFAULT_MAX_SPECULATIVE_AGE_Q 10
VM_PAGE_MIN_SPECULATIVE_AGE_Q 1
VM_PAGE_SPECULATIVE_AGED_Q 0
VM_PAGE_SPECULATIVE_Q_AGE_MS 500
vm_page_list_foreach(m, list) 	for ((m) = (list); (m); (m) = (m)->vmp_snext)
vm_page_list_foreach_consume(it, list) 	while (((it) = vm_page_list_pop((list))))
VM_PAGE_CHECK(mem) MACRO_BEGIN                             	MACRO_END
MAX_COLORS 128
DEFAULT_COLORS 32
VPL_LOCK_SPIN 1
VM_PAGE_DONATE_DISABLED 0
VM_PAGE_DONATE_ENABLED 1
VM_PAGE_BACKGROUND_TARGET_MAX 50000
VM_PAGE_BG_DISABLED 0
VM_PAGE_BG_ENABLED 1
MEMORYSTATUS_SUSPENDED_THRESHOLD 4
VM_PAGEOUT_DEADLOCK_RELIEF 100
VM_PAGE_LAUNDRY_MAX 128UL
VM_PAGEOUT_BURST_WAIT 1
VM_PAGEOUT_EMPTY_WAIT 50
VM_PAGEOUT_DEADLOCK_WAIT 100
VM_PAGEOUT_IDLE_WAIT 10
VM_PAGEOUT_SWAP_WAIT 10
VM_PAGE_REACTIVATE_LIMIT_MAX 20000
VM_PAGEOUT_INACTIVE_FORCE_RECLAIM 1000
VM_PAGEOUT_SCAN_HANDLE_REUSABLE_PAGE(m, obj)                    	MACRO_BEGIN                                                     	                                                             	assert(VM_PAGE_OBJECT((m)) == (obj));                           	if ((m)->vmp_reusable ||                                        	    (obj)->all_reusable) {                                      	        vm_object_reuse_pages((obj),                            	                              (m)->vmp_offset,                  	                              (m)->vmp_offset + PAGE_SIZE_64,   	                              FALSE);                           	}                                                               	MACRO_END
VM_PAGEOUT_DELAYED_UNLOCK_LIMIT 64
VM_PAGEOUT_DELAYED_UNLOCK_LIMIT_MAX 1024
FCS_IDLE 0
FCS_DELAYED 1
FCS_DEADLOCK_DETECTED 2
ANONS_GRABBED_LIMIT 2
VM_PAGEOUT_PB_NO_ACTION 0
VM_PAGEOUT_PB_CONSIDER_WAKING_COMPACTOR_SWAPPER 1
VM_PAGEOUT_PB_THREAD_YIELD 2
DELAY_SPECULATIVE_AGE 1000
MAX_FREE_BATCH 32
BSD_HOST 1
VM_PAGING_NUM_PAGES 64
VECTOR_UPL_ELEMENTS_UPPER_LIMIT 64
_VM_VM_PAGEOUT_H_ None
VM_DEBUG_EVENT(name, event, control, ...)    	MACRO_BEGIN                                             	if (__improbable(vm_debug_events)) {                    	        KDBG_FILTERED((VMDBG_CODE(event)) | control, __VA_ARGS__); 	}                                                       	MACRO_END
VM_DEBUG_CONSTANT_EVENT(name, event, control, ...)   	MACRO_BEGIN                                             	        KDBG((VMDBG_CODE(event)) | control, __VA_ARGS__); 	MACRO_END
VM_PAGER_NOT_CONFIGURED 0x0
VM_PAGER_DEFAULT 0x1
VM_PAGER_COMPRESSOR_NO_SWAP 0x2
VM_PAGER_COMPRESSOR_WITH_SWAP 0x4
VM_PAGER_FREEZER_DEFAULT 0x8
VM_PAGER_FREEZER_COMPRESSOR_NO_SWAP 0x10
VM_PAGER_COMPRESSOR_NO_SWAP_PLUS_FREEZER_COMPRESSOR_WITH_SWAP 0x20
VM_PAGER_MAX_MODES 6
_VM_VM_PAGEOUT_INTERNAL_H_ None
upl_lock_init(object) lck_mtx_init(&(object)->Lock, &vm_object_lck_grp, &vm_object_lck_attr)
upl_lock_destroy(object) lck_mtx_destroy(&(object)->Lock, &vm_object_lck_grp)
upl_lock(object) lck_mtx_lock(&(object)->Lock)
upl_unlock(object) lck_mtx_unlock(&(object)->Lock)
upl_try_lock(object) lck_mtx_try_lock(&(object)->Lock)
upl_lock_sleep(object, event, thread)                           	lck_mtx_sleep_with_inheritor(&(object)->Lock,                   	              LCK_SLEEP_DEFAULT,                                	              (event_t) (event),                                	              (thread),                                         	              THREAD_UNINT,                                     	              TIMEOUT_WAIT_FOREVER)
upl_wakeup(event) wakeup_all_with_inheritor((event), THREAD_AWAKENED)
_VM_VM_PAGEOUT_XNU_H_ None
UPL_PAGE_LIST_MAPPED 0x1
UPL_KERNEL_MAPPED 0x2
UPL_CLEAR_DIRTY 0x4
UPL_COMPOSITE_LIST 0x8
UPL_INTERNAL 0x10
UPL_PAGE_SYNC_DONE 0x20
UPL_DEVICE_MEMORY 0x40
UPL_PAGEOUT 0x80
UPL_LITE 0x100
UPL_IO_WIRE 0x200
UPL_ACCESS_BLOCKED 0x400
UPL_SHADOWED 0x1000
UPL_KERNEL_OBJECT 0x2000
UPL_VECTOR 0x4000
UPL_SET_DIRTY 0x8000
UPL_HAS_BUSY 0x10000
UPL_TRACKED_BY_OBJECT 0x20000
UPL_EXPEDITE_SUPPORTED 0x40000
UPL_DECMP_REQ 0x80000
UPL_DECMP_REAL_IO 0x100000
UPL_MAP_EXCLUSIVE_WAIT 0x200000
UPL_HAS_WIRED 0x400000
UPL_CREATE_EXTERNAL 0
UPL_CREATE_INTERNAL 0x1
UPL_CREATE_LITE 0x2
UPL_CREATE_IO_TRACKING 0x4
UPL_CREATE_EXPEDITE_SUP 0x8
MAX_COMPRESSOR_THREAD_COUNT 8
_VM_VM_PAGE_INTERNAL_H_ None
VM_PAGE_GRAB_OPTIONS_NONE 0x00000000
VM_PAGE_GRAB_Q_LOCK_HELD 0x00000002
VM_PAGE_FREE(p) MACRO_BEGIN                     	        vm_page_free_unlocked(p, TRUE); 	        MACRO_END
vm_page_lockconvert_queues() lck_mtx_convert_spin(&vm_page_queue_lock)
VM_PAGE_CONSUME_CLUSTERED(mem) MACRO_BEGIN                                             	ppnum_t	__phys_page;                                    	__phys_page = VM_PAGE_GET_PHYS_PAGE(mem);               	pmap_lock_phys_page(__phys_page);                       	if (mem->vmp_clustered) {                               	        vm_object_t o;                                  	        o = VM_PAGE_OBJECT(mem);                        	        assert(o);                                      	        o->pages_used++;                                	        mem->vmp_clustered = FALSE;                     	        VM_PAGE_SPECULATIVE_USED_ADD();                 	}                                                       	pmap_unlock_phys_page(__phys_page);                     	MACRO_END
VM_PAGE_COUNT_AS_PAGEIN(mem) MACRO_BEGIN                                             	{                                                       	vm_object_t o;                                          	o = VM_PAGE_OBJECT(mem);                                	DTRACE_VM2(pgin, int, 1, (uint64_t *), NULL);           	counter_inc(&current_task()->pageins);                  	if (o->internal) {                                      	        DTRACE_VM2(anonpgin, int, 1, (uint64_t *), NULL);       	} else {                                                	        DTRACE_VM2(fspgin, int, 1, (uint64_t *), NULL); 	}                                                       	}                                                       	MACRO_END
VM_PAGE_MOVE_STOLEN(page_count) MACRO_BEGIN                                             	vm_page_stolen_count -=	(page_count);                   	vm_page_wire_count_initial -= (page_count);             	MACRO_END
DW_vm_page_unwire 0x01
DW_vm_page_wire 0x02
DW_vm_page_free 0x04
DW_vm_page_activate 0x08
DW_vm_page_deactivate_internal 0x10
DW_vm_page_speculate 0x20
DW_vm_page_lru 0x40
DW_vm_pageout_throttle_up 0x80
DW_PAGE_WAKEUP 0x100
DW_clear_busy 0x200
DW_clear_reference 0x400
DW_set_reference 0x800
DW_move_page 0x1000
DW_VM_PAGE_QUEUES_REMOVE 0x2000
DW_enqueue_cleaned 0x4000
DW_vm_phantom_cache_update 0x8000
DEFAULT_DELAYED_WORK_LIMIT 32
VM_PAGE_ADD_DELAYED_WORK(dwp, mem, dw_cnt)              	MACRO_BEGIN                                             	if (mem->vmp_busy == FALSE) {                           	        mem->vmp_busy = TRUE;                           	        if ( !(dwp->dw_mask & DW_vm_page_free))         	                dwp->dw_mask |= (DW_clear_busy | DW_PAGE_WAKEUP); 	}                                                       	dwp->dw_m = mem;                                        	dwp++;                                                  	dw_cnt++;                                               	MACRO_END
VM_PHANTOM_OBJECT_ID_AFTER_WRAP 1000000
vm_phantom_hash(obj_id, offset) (	        ( (natural_t)((uintptr_t)obj_id * vm_ghost_bucket_hash) + (offset ^ vm_ghost_bucket_hash)) & vm_ghost_hash_mask)
PHANTOM_CACHE_DEBUG 1
VM_GHOST_OFFSET_BITS 39
VM_GHOST_OFFSET_MASK 0x7FFFFFFFFF
VM_GHOST_PAGES_PER_ENTRY 4
VM_GHOST_PAGE_MASK 0x3
VM_GHOST_PAGE_SHIFT 2
_VM_VM_PROTOS_H_ None
port_name_to_task(name) port_name_to_task_kernel(name)
SIXTEENK_PAGE_SIZE 0x4000
SIXTEENK_PAGE_MASK 0x3FFF
SIXTEENK_PAGE_SHIFT 14
FOURK_PAGE_SIZE 0x1000
FOURK_PAGE_MASK 0xFFF
FOURK_PAGE_SHIFT 12
CS_VALIDATE_TAINTED 0x00000001
CS_VALIDATE_NX 0x00000002
VM_TOGGLE_CLEAR 0
VM_TOGGLE_SET 1
VM_TOGGLE_GETVALUE 999
SWAP_WRITE 0x00000000
SWAP_READ 0x00000001
SWAP_ASYNC 0x00000002
MAX_SWAPFILENAME_LEN 1024
SWAPFILENAME_INDEX_LEN 2
roundup(x, y)   ((((x) % (y)) == 0) ? 	                (x) : ((x) + ((y) - ((x) % (y)))))
rounddown(x, y) (((x)/(y))*(y))
VM_SWAP_FLAGS_NONE 0
VM_SWAP_FLAGS_FORCE_DEFRAG 1
VM_SWAP_FLAGS_FORCE_RECLAIM 2
_VM_VM_PROTOS_INTERNAL_H_ None
__VM_PURGEABLE_INTERNAL__ None
TOKEN_COUNT_MAX UINT32_MAX
NUM_VOLATILE_GROUPS 8
TOKEN_NEW_PAGECOUNT_MAX INT32_MAX
PURGEABLE_LOOP_MAX 64
__VM_PURGEABLE_XNU__ None
_vmdr_log_type(type, fmt, ...) os_log_with_type(vm_reclaim_log_handle, type, "vm_reclaim: " fmt, ##__VA_ARGS__)
vmdr_log(fmt, ...) _vmdr_log_type(OS_LOG_TYPE_DEFAULT, fmt, ##__VA_ARGS__)
vmdr_log_info(fmt, ...) _vmdr_log_type(OS_LOG_TYPE_INFO, fmt, ##__VA_ARGS__)
vmdr_log_error(fmt, ...) _vmdr_log_type(OS_LOG_TYPE_ERROR, fmt, ##__VA_ARGS__)
__VM_RECLAIM_INTERNAL__ None
__VM_RECLAIM_XNU__ None
BUCKETS_PER_LOCK 16
VM_PAGE_WIRE_COUNT_WARNING 0
VM_PAGE_GOBBLE_COUNT_WARNING 0
DONATE_TO_WAITERS(count, waiters_count)  ({ 	uint32_t __n = MIN(waiters_count, vmpr.count); 	waiters_count -= __n;                          	vmpr.count    -= __n;                          	__n;                                           })
COLOR_GROUPS_TO_STEAL 4
vm_page_hash(object, offset) (	( (natural_t)((uintptr_t)object * vm_page_bucket_hash) + ((uint32_t)atop_64(offset) ^ vm_page_bucket_hash))	 & vm_page_hash_mask)
VM_PAGE_HASH_LOOKUP_THRESHOLD 10
KDP_VM_PAGE_WALK_MAX 1000
PMAP_ZERO_PART_PAGE_IMPLEMENTED None
MAX_CONSIDERED_BEFORE_YIELD 1000
RESET_STATE_OF_RUN() MACRO_BEGIN             	prevcontaddr = -2;      	start_pnum = -1;        	free_considered = 0;    	substitute_needed = 0;  	npages = 0;             	MACRO_END
VM_PAGE_FIND_CONTIGUOUS_CAN_STEAL 1
KA_SIZE(namelen, subtotalscount)        	(sizeof(struct vm_allocation_site) + (namelen) + 1 + ((subtotalscount) * sizeof(struct vm_allocation_total)))
SET_COUNT(xcount, xsize, xflags)                            counts[xcount].tag   = VM_MAX_TAG_VALUE + xcount;       counts[xcount].site  = (xcount);                                counts[xcount].size  = (xsize);                                     counts[xcount].mapped  = (xsize);                               counts[xcount].flags = VM_KERN_SITE_COUNTER | xflags;
SET_MAP(xcount, xsize, xfree, xlargest)     counts[xcount].site    = (xcount);                      counts[xcount].size    = (xsize);                       counts[xcount].mapped  = (xsize);                       counts[xcount].free    = (xfree);                       counts[xcount].largest = (xlargest);                    counts[xcount].flags   = VM_KERN_SITE_COUNTER;
vm_add_no_ubsan(a, b) ({ typeof(a+b) TMP; (void) os_add_overflow(a, b, &TMP); TMP; })
vm_sub_no_ubsan(a, b) ({ typeof(a+b) TMP; (void) os_sub_overflow(a, b, &TMP); TMP; })
EINVAL DONT_USE_EINVAL
EAGAIN DONT_USE_EAGAIN
EACCESS DONT_USE_EACCESS
ENOMEM DONT_USE_ENOMEM
EPERM DONT_USE_EPERM
KERN_SUCCESS DONT_USE_KERN_SUCCESS
VM_SANITIZE_FALLTHROUGH 0
NO_SANITIZE_UNSIGNED_OVERFLOW __attribute__((no_sanitize("unsigned-integer-overflow")))
_VM_SANITIZE_INTERNAL_H_ None
__vm_sanitize_assert_one_of(arg, mask) 	__attribute__((diagnose_if(!__vm_sanitize_bits_one_of((arg) & (mask)), 	    "`" #arg "` must have one of these flags `" #mask "`", "error")))
__vm_sanitize_require_size_zero_flag(arg) __vm_sanitize_assert_one_of(arg,          	    VM_SANITIZE_FLAGS_SIZE_ZERO_SUCCEEDS | VM_SANITIZE_FLAGS_SIZE_ZERO_FAILS | VM_SANITIZE_FLAGS_SIZE_ZERO_FALLTHROUGH)
VM_SANITIZE_DECL_CALLER(name) extern vm_sanitize_caller_t const VM_SANITIZE_CALLER_ ## name;
VM_SANITIZE_DEFINE_CALLER(name, ... )       	static const struct vm_sanitize_caller vm_sanitize_caller_storage_ ## name = { 	    .vmsc_caller_id = VM_SANITIZE_CALLER_ID_ ## name,        	    .vmsc_caller_name = #name,                       	    .vmsc_telemetry_id = VM_SANITIZE_METHOD_ ## name,     	    .vmsc_ktriage_id = KDBG_TRIAGE_VM_SANITIZE_ ## name,  	    __VA_ARGS__                                     	}; 	vm_sanitize_caller_t const VM_SANITIZE_CALLER_ ## name = &vm_sanitize_caller_storage_ ## name
VM_SANITIZE_UNSAFE_IS_EQUAL(_var, _val) ((_var).UNSAFE == (_val))
VM_SANITIZE_UNSAFE_IS_ZERO(_var) VM_SANITIZE_UNSAFE_IS_EQUAL(_var, 0)
VM_SANITIZE_UNSAFE_FITS(_var, type_t) ({ 	__auto_type __tmp = (_var).UNSAFE; 	__tmp == (type_t)__tmp;            })
VM_SANITIZE_UT_SET(_var, _val) ((_var).UNSAFE) = (_val)
vm_sanitize_wrap_addr_ref(var) _Generic(var, 	mach_vm_address_t *: (vm_addr_struct_t *)(var), 	vm_address_t *:      (vm_addr_struct_t *)(var), 	default:             (var))
CA_VM_PROCESS_NAME_LEN 33
CA_VM_BACKTRACE_AND_SYM_LEN 340
CA_VM_PACK(method, checker, checker_count) (               	((method) << CA_VM_PACKING_METHOD_OFFSET)                  	| ((checker) << CA_VM_PACKING_CHECKER_OFFSET)              	| ((checker_count) << CA_VM_PACKING_CHECKER_COUNT_OFFSET))
_VM_SANITIZE_TELEMETRY_H_ None
PROCESS_SHARED_CACHE_LAYOUT 0x00
vm_shared_region_lock() lck_mtx_lock(&vm_shared_region_lock)
vm_shared_region_unlock() lck_mtx_unlock(&vm_shared_region_lock)
vm_shared_region_sleep(event, interruptible)                    	lck_mtx_sleep_with_inheritor(&vm_shared_region_lock,            	              LCK_SLEEP_DEFAULT,                                	              (event_t) (event),                                	              *(event),                                         	              (interruptible) | THREAD_WAIT_NOREPORT,           	              TIMEOUT_WAIT_FOREVER)
vm_shared_region_wakeup(event) wakeup_all_with_inheritor((event), THREAD_AWAKENED)
_VM_SHARED_REGION_H_ None
SHARED_REGION_TRACE_NONE_LVL 0
SHARED_REGION_TRACE_ERROR_LVL 1
SHARED_REGION_TRACE_INFO_LVL 2
SHARED_REGION_TRACE_DEBUG_LVL 3
SHARED_REGION_TRACE(level, args)                	MACRO_BEGIN                                     	if (shared_region_trace_level >= level) {       	        printf args;                            	}                                               	MACRO_END
SHARED_REGION_TRACE_NONE(args) None
SHARED_REGION_TRACE_ERROR(args) MACRO_BEGIN                                             	SHARED_REGION_TRACE(SHARED_REGION_TRACE_ERROR_LVL,      	                    args);                              	MACRO_END
SHARED_REGION_TRACE_INFO(args) MACRO_BEGIN                                             	SHARED_REGION_TRACE(SHARED_REGION_TRACE_INFO_LVL,       	                    args);                              	MACRO_END
SHARED_REGION_TRACE_DEBUG(args) MACRO_BEGIN                                             	SHARED_REGION_TRACE(SHARED_REGION_TRACE_DEBUG_LVL,      	                    args);                              	MACRO_END
_VM_SHARED_REGION_INTERNAL_H_ None
_VM_SHARED_REGION_XNU_H_ None
PAGE_SIZE_FOR_SR_SLIDE 4096
PAGE_SIZE_FOR_SR_SLIDE_16KB 16384
DYLD_CACHE_SLIDE_PAGE_ATTRS 0xC000
DYLD_CACHE_SLIDE_PAGE_ATTR_EXTRA 0x8000
DYLD_CACHE_SLIDE_PAGE_ATTR_NO_REBASE 0x4000
DYLD_CACHE_SLIDE_PAGE_ATTR_END 0x8000
DYLD_CACHE_SLIDE_PAGE_VALUE 0x3FFF
DYLD_CACHE_SLIDE_PAGE_OFFSET_SHIFT 2
DYLD_CACHE_SLIDE_V3_PAGE_ATTR_NO_REBASE 0xFFFF
DYLD_CACHE_SLIDE4_PAGE_NO_REBASE 0xFFFF
DYLD_CACHE_SLIDE4_PAGE_INDEX 0x7FFF
DYLD_CACHE_SLIDE4_PAGE_USE_EXTRA 0x8000
DYLD_CACHE_SLIDE4_PAGE_EXTRA_END 0x8000
DYLD_CACHE_SLIDE_V5_PAGE_ATTR_NO_REBASE 0xFFFF
MIN_SLIDE_INFO_SIZE MIN(sizeof(struct vm_shared_region_slide_info_entry_v1),     MIN(sizeof(struct vm_shared_region_slide_info_entry_v2),     MIN(sizeof(struct vm_shared_region_slide_info_entry_v3),     MIN(sizeof(struct vm_shared_region_slide_info_entry_v4),     sizeof(struct vm_shared_region_slide_info_entry_v5)))))
_VM_VM_UBC_H_ None
_VM_UPL_ None
WKdm_SCRATCH_BUF_SIZE_INTERNAL PAGE_SIZE
_VOUCHER_IPC_PTHREAD_PRIORITY_TYPES_H_ None
COPYIN 0
COPYOUT 1
COPYINSTR 2
COPYINPHYS 3
COPYOUTPHYS 4
COPYINATOMIC32 5
COPYINATOMIC64 6
COPYOUTATOMIC32 7
COPYOUTATOMIC64 8
_X86_64_DWARF_UNWIND_H_ None
DWARF_RAX 0
DWARF_RDX 1
DWARF_RCX 2
DWARF_RBX 3
DWARF_RSI 4
DWARF_RDI 5
DWARF_RBP 6
DWARF_RSP 7
DWARF_R8 8
DWARF_R9 9
DWARF_R10 10
DWARF_R11 11
DWARF_R12 12
DWARF_R13 13
DWARF_R14 14
DWARF_R15 15
DWARF_RIP 16
DW_OP_breg15 0x7f
DW_CFA_expression 0x10
DW_FORM_LEN_TWO_BYTE_SLEB 3
DW_FORM_LEN_ONE_BYTE_SLEB 2
R64_RAX_SLEB128 0x88, 0x01
R64_RCX_SLEB128 0x80, 0x01
R64_RBX_SLEB128 0xf8, 0x00
R64_RBP_SLEB128 0xf0, 0x00
R64_RSP_SLEB128 0xd0, 0x01
R64_R11_SLEB128 0xe8, 0x00
R64_R12_SLEB128 0xe0, 0x00
R64_R13_SLEB128 0xd8, 0x00
R64_R14_SLEB128 0xd0, 0x00
R64_R15_SLEB128 0xc8, 0x00
R64_RIP_SLEB128 0xb8, 0x01
UNWIND_PROLOGUE .cfi_sections .eh_frame ;.cfi_startproc;        ;.cfi_signal_frame       ;
UNWIND_EPILOGUE .cfi_endproc
UNWIND_DIRECTIVES .cfi_escape DW_CFA_expression, DWARF_RAX, DW_FORM_LEN_TWO_BYTE_SLEB, DW_OP_breg15, R64_RAX_SLEB128 ;.cfi_escape DW_CFA_expression, DWARF_RDX, DW_FORM_LEN_ONE_BYTE_SLEB, DW_OP_breg15, R64_RDX         ;.cfi_escape DW_CFA_expression, DWARF_RCX, DW_FORM_LEN_TWO_BYTE_SLEB, DW_OP_breg15, R64_RCX_SLEB128 ;.cfi_escape DW_CFA_expression, DWARF_RBX, DW_FORM_LEN_TWO_BYTE_SLEB, DW_OP_breg15, R64_RBX_SLEB128 ;.cfi_escape DW_CFA_expression, DWARF_RSI, DW_FORM_LEN_ONE_BYTE_SLEB, DW_OP_breg15, R64_RSI         ;.cfi_escape DW_CFA_expression, DWARF_RDI, DW_FORM_LEN_ONE_BYTE_SLEB, DW_OP_breg15, R64_RDI         ;.cfi_escape DW_CFA_expression, DWARF_RBP, DW_FORM_LEN_TWO_BYTE_SLEB, DW_OP_breg15, R64_RBP_SLEB128 ;.cfi_escape DW_CFA_expression, DWARF_RSP, DW_FORM_LEN_TWO_BYTE_SLEB, DW_OP_breg15, R64_RSP_SLEB128 ;.cfi_escape DW_CFA_expression, DWARF_R8,  DW_FORM_LEN_ONE_BYTE_SLEB, DW_OP_breg15, R64_R8          ;.cfi_escape DW_CFA_expression, DWARF_R9,  DW_FORM_LEN_ONE_BYTE_SLEB, DW_OP_breg15, R64_R9          ;.cfi_escape DW_CFA_expression, DWARF_R10, DW_FORM_LEN_ONE_BYTE_SLEB, DW_OP_breg15, R64_R10         ;.cfi_escape DW_CFA_expression, DWARF_R11, DW_FORM_LEN_TWO_BYTE_SLEB, DW_OP_breg15, R64_R11_SLEB128 ;.cfi_escape DW_CFA_expression, DWARF_R12, DW_FORM_LEN_TWO_BYTE_SLEB, DW_OP_breg15, R64_R12_SLEB128 ;.cfi_escape DW_CFA_expression, DWARF_R13, DW_FORM_LEN_TWO_BYTE_SLEB, DW_OP_breg15, R64_R13_SLEB128 ;.cfi_escape DW_CFA_expression, DWARF_R14, DW_FORM_LEN_TWO_BYTE_SLEB, DW_OP_breg15, R64_R14_SLEB128 ;.cfi_escape DW_CFA_expression, DWARF_R15, DW_FORM_LEN_TWO_BYTE_SLEB, DW_OP_breg15, R64_R15_SLEB128 ;.cfi_escape DW_CFA_expression, DWARF_RIP, DW_FORM_LEN_TWO_BYTE_SLEB, DW_OP_breg15, R64_RIP_SLEB128 ;
USE_RDPMC None
_LOW_MEMORY_GLOBALS_H_ None
_MACHINE_X86_64_KPC_H None
MACHINE_X86_64_REMOTE_TIME_H None
X86_64_MONOTONIC_H None
MT_NDEVS 1
MT_CORE_NFIXED 4
MT_CORE_INSTRS 0
MT_CORE_CYCLES 1
MT_CORE_REFCYCLES 2
__has_builtin(x) 0
S3_2_C15_C0_0_RD PMC_FIXED_RD(0)
S3_2_C15_C0_0_WR PMC_FIXED_WR(0)
S3_2_C15_C1_0_RD PMC_FIXED_RD(1)
S3_2_C15_C1_0_WR PMC_FIXED_WR(1)
S3_2_C15_C2_0_RD PMC_FIXED_RD(2)
S3_2_C15_C2_0_WR PMC_FIXED_WR(2)
S3_2_C15_C3_0_RD PMC_FIXED_RD(3)
S3_2_C15_C3_0_WR PMC_FIXED_WR(3)
GLOBAL_CTRL 0x38f
GLOBAL_STATUS 0x38e
GLOBAL_OVF 0x390
_MACH_ARM_BOOLEAN_H_ None
_MACH_ARM_EXCEPTION_H_ None
EXC_TYPES_COUNT 14
EXC_MASK_MACHINE 0
EXCEPTION_CODE_MAX 2
EXC_ARM_UNDEFINED 1
EXC_ARM_SME_DISALLOWED 2
EXC_ARM_FP_UNDEFINED 0
EXC_ARM_FP_IO 1
EXC_ARM_FP_DZ 2
EXC_ARM_FP_OF 3
EXC_ARM_FP_UF 4
EXC_ARM_FP_IX 5
EXC_ARM_FP_ID 6
EXC_ARM_DA_ALIGN 0x101
EXC_ARM_DA_DEBUG 0x102
EXC_ARM_SP_ALIGN 0x103
EXC_ARM_SWP 0x104
EXC_ARM_PAC_FAIL 0x105
EXC_ARM_BREAKPOINT 1
_MACH_ARM_KERN_RETURN_H_ None
_MACH_ARM_PROCESSOR_INFO_H_ None
PROCESSOR_CPU_STAT 0x10000003
PROCESSOR_CPU_STAT64 0x10000004
_MACH_ARM_RPC_H_ None
_MACH_ARM_SDT_ISA_H None
DTRACE_STRINGIFY(s) #s
DTRACE_TOSTRING(s) DTRACE_STRINGIFY(s)
DTRACE_PROBE(provider, name)                                                        	do {                                                                                    	        asm volatile (                                                                  	                DTRACE_CALL(provider, name)                                             	                :                                                                       	                :                                                                       	                : "memory"                                                              	        );                                                                              	} while(0)
DTRACE_PROBE1(provider, name, arg0)                                                 	do {                                                                                    	        register uintptr_t __dtrace_a0 asm("x0") = (uintptr_t) arg0;                    	        asm volatile (                                                                  	                DTRACE_CALL(provider, name)                                             	                :                                                                       	                : "r" (__dtrace_a0)                                                     	                : "memory"                                                              	        );                                                                              	} while(0)
DTRACE_PROBE2(provider, name, arg0, arg1)                                           	do {                                                                                    	        register uintptr_t __dtrace_a0 asm("x0") = (uintptr_t) arg0;                    	        register uintptr_t __dtrace_a1 asm("x1") = (uintptr_t) arg1;                    	        asm volatile (                                                                  	                DTRACE_CALL(provider, name)                                             	                :                                                                       	                : "r" (__dtrace_a0), "r" (__dtrace_a1)                                  	                : "memory"                                                              	        );                                                                              	} while(0)
DTRACE_PROBE3(provider, name, arg0, arg1, arg2)                                     	do {                                                                                    	        register uintptr_t __dtrace_a0 asm("x0") = (uintptr_t) arg0;                    	        register uintptr_t __dtrace_a1 asm("x1") = (uintptr_t) arg1;                    	        register uintptr_t __dtrace_a2 asm("x2") = (uintptr_t) arg2;                    	        asm volatile (                                                                  	                DTRACE_CALL(provider, name)                                             	                :                                                                       	                : "r" (__dtrace_a0), "r" (__dtrace_a1), "r" (__dtrace_a2)               	                : "memory"                                                              	        );                                                                              	} while(0)
DTRACE_PROBE4(provider, name, arg0, arg1, arg2, arg3)                               	do {                                                                                    	        register uintptr_t __dtrace_a0 asm("x0") = (uintptr_t) arg0;                    	        register uintptr_t __dtrace_a1 asm("x1") = (uintptr_t) arg1;                    	        register uintptr_t __dtrace_a2 asm("x2") = (uintptr_t) arg2;                    	        register uintptr_t __dtrace_a3 asm("x3") = (uintptr_t) arg3;                    	        asm volatile (                                                                  	                DTRACE_CALL(provider, name)                                             	                :                                                                       	                : "r" (__dtrace_a0), "r" (__dtrace_a1), "r" (__dtrace_a2),              	                  "r" (__dtrace_a3)                                                     	                : "memory"                                                              	        );                                                                              	} while(0)
DTRACE_PROBE5(provider, name, arg0, arg1, arg2, arg3, arg4)                         	do {                                                                                    	        register uintptr_t __dtrace_a0 asm("x0") = (uintptr_t) arg0;                    	        register uintptr_t __dtrace_a1 asm("x1") = (uintptr_t) arg1;                    	        register uintptr_t __dtrace_a2 asm("x2") = (uintptr_t) arg2;                    	        register uintptr_t __dtrace_a3 asm("x3") = (uintptr_t) arg3;                    	        register uintptr_t __dtrace_a4 asm("x4") = (uintptr_t) arg4;                    	        asm volatile (                                                                  	                DTRACE_CALL(provider, name)                                             	                :                                                                       	                : "r" (__dtrace_a0), "r" (__dtrace_a1), "r" (__dtrace_a2),              	                  "r" (__dtrace_a3), "r" (__dtrace_a4)                                  	                : "memory"                                                              	        );                                                                              	} while(0)
DTRACE_PROBE6(provider, name, arg0, arg1, arg2, arg3, arg4, arg5)                   	do {                                                                                    	        register uintptr_t __dtrace_a0 asm("x0") = (uintptr_t) arg0;                    	        register uintptr_t __dtrace_a1 asm("x1") = (uintptr_t) arg1;                    	        register uintptr_t __dtrace_a2 asm("x2") = (uintptr_t) arg2;                    	        register uintptr_t __dtrace_a3 asm("x3") = (uintptr_t) arg3;                    	        register uintptr_t __dtrace_a4 asm("x4") = (uintptr_t) arg4;                    	        register uintptr_t __dtrace_a5 asm("x5") = (uintptr_t) arg5;                    	        asm volatile (                                                                  	                DTRACE_CALL(provider, name)                                             	                :                                                                       	                : "r" (__dtrace_a0), "r" (__dtrace_a1), "r" (__dtrace_a2),              	                  "r" (__dtrace_a3), "r" (__dtrace_a4), "r" (__dtrace_a5)               	                : "memory"                                                              	        );                                                                              	} while(0)
DTRACE_PROBE7(provider, name, arg0, arg1, arg2, arg3, arg4, arg5, arg6)             	do {                                                                                    	        register uintptr_t __dtrace_a0 asm("x0") = (uintptr_t) arg0;                    	        register uintptr_t __dtrace_a1 asm("x1") = (uintptr_t) arg1;                    	        register uintptr_t __dtrace_a2 asm("x2") = (uintptr_t) arg2;                    	        register uintptr_t __dtrace_a3 asm("x3") = (uintptr_t) arg3;                    	        register uintptr_t __dtrace_a4 asm("x4") = (uintptr_t) arg4;                    	        register uintptr_t __dtrace_a5 asm("x5") = (uintptr_t) arg5;                    	        register uintptr_t __dtrace_a6 asm("x6") = (uintptr_t) arg6;                    	        asm volatile (                                                                  	                DTRACE_CALL(provider, name)                                             	                :                                                                       	                : "r" (__dtrace_a0), "r" (__dtrace_a1), "r" (__dtrace_a2),              	                  "r" (__dtrace_a3), "r" (__dtrace_a4), "r" (__dtrace_a5),              	                  "r" (__dtrace_a6)                                                     	                : "memory"                                                              	        );                                                                              	} while(0)
DTRACE_PROBE8(provider, name, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7)       	do {                                                                                    	        register uintptr_t __dtrace_a0 asm("x0") = (uintptr_t) arg0;                    	        register uintptr_t __dtrace_a1 asm("x1") = (uintptr_t) arg1;                    	        register uintptr_t __dtrace_a2 asm("x2") = (uintptr_t) arg2;                    	        register uintptr_t __dtrace_a3 asm("x3") = (uintptr_t) arg3;                    	        register uintptr_t __dtrace_a4 asm("x4") = (uintptr_t) arg4;                    	        register uintptr_t __dtrace_a5 asm("x5") = (uintptr_t) arg5;                    	        register uintptr_t __dtrace_a6 asm("x6") = (uintptr_t) arg6;                    	        register uintptr_t __dtrace_a7 asm("x7") = (uintptr_t) arg7;                    	        asm volatile (                                                                  	                DTRACE_CALL(provider, name)                                             	                :                                                                       	                : "r" (__dtrace_a0), "r" (__dtrace_a1), "r" (__dtrace_a2),              	                  "r" (__dtrace_a3), "r" (__dtrace_a4), "r" (__dtrace_a5),              	                  "r" (__dtrace_a6), "r" (__dtrace_a7)                                  	                : "memory"                                                              	        );                                                                              	} while(0)
_MACH_ARM_SYSCALL_SW_H_ None
_MACH_ARM_THREAD_STATE_H_ None
_ARM_THREAD_STATUS_H_ None
ARM_THREAD_STATE 1
ARM_UNIFIED_THREAD_STATE ARM_THREAD_STATE
ARM_VFP_STATE 2
ARM_EXCEPTION_STATE 3
ARM_DEBUG_STATE 4
THREAD_STATE_NONE 5
ARM_THREAD_STATE64 6
ARM_EXCEPTION_STATE64 7
ARM_THREAD_STATE32 9
ARM_EXCEPTION_STATE64_V2 10
X86_THREAD_STATE_NONE 13
ARM_DEBUG_STATE32 14
ARM_DEBUG_STATE64 15
ARM_NEON_STATE 16
ARM_NEON_STATE64 17
ARM_CPMU_STATE64 18
ARM_SAVED_STATE32 20
ARM_SAVED_STATE64 21
ARM_NEON_SAVED_STATE32 22
ARM_NEON_SAVED_STATE64 23
ARM_PAGEIN_STATE 27
ARM_SME_STATE 28
ARM_SVE_Z_STATE1 29
ARM_SVE_Z_STATE2 30
ARM_SVE_P_STATE 31
ARM_SME_ZA_STATE1 32
ARM_SME_ZA_STATE2 33
ARM_SME_ZA_STATE3 34
ARM_SME_ZA_STATE4 35
ARM_SME_ZA_STATE5 36
ARM_SME_ZA_STATE6 37
ARM_SME_ZA_STATE7 38
ARM_SME_ZA_STATE8 39
ARM_SME_ZA_STATE9 40
ARM_SME_ZA_STATE10 41
ARM_SME_ZA_STATE11 42
ARM_SME_ZA_STATE12 42
ARM_SME_ZA_STATE13 44
ARM_SME_ZA_STATE14 45
ARM_SME_ZA_STATE15 46
ARM_SME_ZA_STATE16 47
ARM_SME2_STATE 48
ARM_SME_SAVED_STATE 49
THREAD_STATE_FLAVORS 50
ARM_STATE_FLAVOR_IS_OTHER_VALID(_flavor_) 0
ts_32 uts.ts_32
ts_64 uts.ts_64
MACHINE_THREAD_STATE ARM_THREAD_STATE
MACHINE_THREAD_STATE_COUNT ARM_UNIFIED_THREAD_STATE_COUNT
THREAD_MACHINE_STATE_MAX THREAD_STATE_MAX
HAS_ADD_SAVED_STATE_PC 1
HAS_SET_SAVED_STATE_PC 1
HAS_SET_SAVED_STATE_LR 1
HAS_SET_SAVED_STATE_REG 1
HAS_MASK_SAVED_STATE_CPSR 1
CAST_ASSERT_SAFE(type, val) (assert((val) == ((type)(val))), (type)(val))
ss_32 uss.ss_32
ss_64 uss.ss_64
ns_32 uns.ns_32
ns_64 uns.ns_64
_MACH_ARM_TRAPS_H_ None
MACH_ARM_TRAP_ABSTIME -3
MACH_ARM_TRAP_CONTTIME -4
_MACH_ARM_VM_PARAM_H_ None
BYTE_SIZE 8
VM_PAGE_SIZE PAGE_SIZE
PAGE_MAX_SHIFT 14
PAGE_MIN_SHIFT 12
VM_MAX_PAGE_ADDRESS MACH_VM_MAX_ADDRESS
VM32_SUPPORT 1
VM_MAP_MIN_ADDRESS VM_MIN_ADDRESS
VM_MAP_MAX_ADDRESS VM_MAX_ADDRESS
VM_MIN_KERNEL_AND_KEXT_ADDRESS VM_MIN_KERNEL_ADDRESS
physmap_enclosed(a) isphysmem(a)
SWI_SYSCALL 0x80
_MACH_ARM_VM_TYPES_H_ None
MACH_MSG_TYPE_INTEGER_T MACH_MSG_TYPE_INTEGER_32
_MACH_ARM__STRUCTS_H_ None
__DARWIN_OPAQUE_ARM_THREAD_STATE64 0
__DARWIN_ARM_THREAD_STATE64_FLAGS_NO_PTRAUTH 0x1
__DARWIN_ARM_THREAD_STATE64_FLAGS_IB_SIGNED_LR 0x2
__DARWIN_ARM_THREAD_STATE64_FLAGS_KERNEL_SIGNED_PC 0x4
__DARWIN_ARM_THREAD_STATE64_FLAGS_KERNEL_SIGNED_LR 0x8
__DARWIN_ARM_THREAD_STATE64_USER_DIVERSIFIER_MASK 0xff000000
__DARWIN_ARM_THREAD_STATE64_SIGRETURN_PC_MASK 0x000f0000
__DARWIN_ARM_THREAD_STATE64_SIGRETURN_LR_MASK 0x00f00000
__DARWIN_ARM_THREAD_STATE64_SET_SIGRETURN_TOKEN(ts, token, mask)     ((ts)->flags |= (((uint32_t)(token)) & (mask)))
__DARWIN_ARM_THREAD_STATE64_CHECK_SIGRETURN_TOKEN(ts, token, mask)     (((ts)->flags & (mask)) ==     (((uint32_t)(token)) & (mask)))
_STRUCT_ARM_THREAD_STATE64 struct arm_thread_state64
_STRUCT_ARM_PAGEIN_STATE struct __arm_pagein_state
_MACH_I386_BOOLEAN_H_ None
_MACH_I386_EXCEPTION_H_ None
_I386_FP_SAVE_H_ None
_MACH_I386_KERN_RETURN_H_ None
_MACH_I386_PROCESSOR_INFO_H_ None
_MACH_I386_RPC_H_ None
_MACH_I386_SDT_ISA_H None
_MACH_I386_SYSCALL_SW_H_ None
UNIX_INT 0x80
MACH_INT 0x81
MACHDEP_INT 0x82
DIAG_INT 0x83
SYSCALL_CLASS_SHIFT 24
I386_SYSCALL_CLASS_MASK SYSCALL_CLASS_MASK
SYSCALL_CLASS_NONE 0
SYSCALL_CLASS_MACH 1
SYSCALL_CLASS_UNIX 2
SYSCALL_CLASS_MDEP 3
SYSCALL_CLASS_DIAG 4
SYSCALL_CLASS_IPC 5
_MACH_I386_THREAD_STATE_H_ None
_MACH_I386_THREAD_STATUS_H_ None
_MACH_I386_VM_PARAM_H_ None
_MACH_I386_VM_TYPES_H_ None
_MACH_I386__STRUCTS_H_ None
_MACH_MACHINE_ASM_H None
_MACH_MACHINE_BOOLEAN_H_ None
_MACH_MACHINE_EXCEPTION_H_ None
_MACH_MACHINE_KERN_RETURN_H_ None
_MACH_MACHINE_NDR_DEF_H None
_MACH_MACHINE_PROCESSOR_INFO_H_ None
_MACH_MACHINE_RPC_H_ None
_MACH_MACHINE_SYS_SDT_H None
DTRACE_SCHED(name) DTRACE_PROBE(__sched_, name);
DTRACE_SCHED1(name, type1, arg1)                                	DTRACE_PROBE1(__sched_, name, arg1);
DTRACE_SCHED2(name, type1, arg1, type2, arg2)                   	DTRACE_PROBE2(__sched_, name, arg1, arg2);
DTRACE_SCHED3(name, type1, arg1, type2, arg2, type3, arg3)      	DTRACE_PROBE3(__sched_, name, arg1, arg2, arg3);
DTRACE_SCHED4(name, type1, arg1, type2, arg2,                   	    type3, arg3, type4, arg4)                                           	DTRACE_PROBE4(__sched_, name, arg1, arg2, arg3, arg4);
DTRACE_SCHED5(name, type1, arg1, type2, arg2,                   	    type3, arg3, type4, arg4, type5, arg5)                              	DTRACE_PROBE5(__sched_, name, arg1, arg2, arg3, arg4, arg5, arg6);
DTRACE_SCHED6(name, type1, arg1, type2, arg2,                   	    type3, arg3, type4, arg4, type5, arg5, type6, arg6)                 	DTRACE_PROBE6(__sched_, name, arg1, arg2, arg3, arg4, arg5, arg6);
DTRACE_PROC(name) DTRACE_PROBE(__proc_, name);
DTRACE_PROC1(name, type1, arg1)                                 	DTRACE_PROBE1(__proc_, name, arg1);
DTRACE_PROC2(name, type1, arg1, type2, arg2)                    	DTRACE_PROBE2(__proc_, name, arg1, arg2);
DTRACE_PROC3(name, type1, arg1, type2, arg2, type3, arg3)       	DTRACE_PROBE3(__proc_, name, arg1, arg2, arg3);
DTRACE_PROC4(name, type1, arg1, type2, arg2,                    	    type3, arg3, type4, arg4)                                           	DTRACE_PROBE4(__proc_, name, arg1, arg2, arg3, arg4);
DTRACE_IO(name) DTRACE_PROBE(__io_, name);
DTRACE_IO1(name, type1, arg1)                                   	DTRACE_PROBE1(__io_, name, arg1);
DTRACE_IO2(name, type1, arg1, type2, arg2)                      	DTRACE_PROBE2(__io_, name, arg1, arg2);
DTRACE_IO3(name, type1, arg1, type2, arg2, type3, arg3)         	DTRACE_PROBE3(__io_, name, arg1, arg2, arg3);
DTRACE_IO4(name, type1, arg1, type2, arg2,                      	    type3, arg3, type4, arg4)                                           	DTRACE_PROBE4(__io_, name, arg1, arg2, arg3, arg4);
DTRACE_INT5(name, type1, arg1, type2, arg2,                     	    type3, arg3, type4, arg4, type5, arg5)                                              	DTRACE_PROBE5(__sdt_, name, arg1, arg2, arg3, arg4, arg5);
DTRACE_MEMORYSTATUS2(name, type1, arg1, type2, arg2)            	DTRACE_PROBE2(__sdt_, name, arg1, arg2);
DTRACE_MEMORYSTATUS3(name, type1, arg1, type2, arg2, type3, arg3)               	DTRACE_PROBE3(__sdt_, name, arg1, arg2, arg3);
DTRACE_MEMORYSTATUS4(name, type1, arg1, type2, arg2, type3, arg3, type4, arg4)  	DTRACE_PROBE4(__sdt_, name, arg1, arg2, arg3, arg4);
DTRACE_MEMORYSTATUS6(name, type1, arg1, type2, arg2,                    	    type3, arg3, type4, arg4, type5, arg5, type6, arg6) 	DTRACE_PROBE6(__vminfo_, name, arg1, arg2, arg3, arg4, arg5, arg6)
DTRACE_TMR3(name, type1, arg1, type2, arg2, type3, arg3)                	DTRACE_PROBE3(__sdt_, name, arg1, arg2, arg3);
DTRACE_TMR4(name, type1, arg1, arg2, arg3, arg4)                        	DTRACE_PROBE4(__sdt_, name, arg1, arg2, arg3, arg4);
DTRACE_TMR5(name, type1, arg1, type2, arg2, type3, arg3, arg4, arg5)    	DTRACE_PROBE5(__sdt_, name, arg1, arg2, arg3, arg4, arg5);
DTRACE_TMR6(name, type1, arg1, type2, arg2, type3, arg3, arg4, arg5, arg6) 	DTRACE_PROBE6(__sdt_, name, arg1, arg2, arg3, arg4, arg5, arg6);
DTRACE_TMR7(name, type1, arg1, type2, arg2, type3, arg3, arg4, arg5, arg6, arg7) 	DTRACE_PROBE7(__sdt_, name, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
DTRACE_PHYSLAT3(name, type1, arg1, type2, arg2, type3, arg3)            	DTRACE_PROBE3(__sdt_, name, arg1, arg2, arg3);
DTRACE_PHYSLAT4(name, type1, arg1, type2, arg2, type3, arg3, type4, arg4)        	DTRACE_PROBE4(__sdt_, name, arg1, arg2, arg3, arg4);
DTRACE_PHYSLAT5(name, type1, arg1, type2, arg2, type3, arg3, type4, arg4, type5, arg5)  	DTRACE_PROBE5(__sdt_, name, arg1, arg2, arg3, arg4, arg5);
DTRACE_MACF(name) DTRACE_PROBE(__sdt_, name);
DTRACE_MACF1(name, type1, arg1)                         	DTRACE_PROBE1(__sdt_, name, arg1);
DTRACE_MACF2(name, type1, arg1, type2, arg2)            	DTRACE_PROBE2(__sdt_, name, arg1, arg2);
DTRACE_MACF3(name, type1, arg1, type2, arg2, type3, arg3)            	DTRACE_PROBE3(__sdt_, name, arg1, arg2, arg3);
DTRACE_VM(name) DTRACE_PROBE(__vminfo_, name)
DTRACE_VM1(name, type1, arg1)                                   	DTRACE_PROBE1(__vminfo_, name, arg1)
DTRACE_VM2(name, type1, arg1, type2, arg2)                      	DTRACE_PROBE2(__vminfo_, name, arg1, arg2)
DTRACE_VM3(name, type1, arg1, type2, arg2, type3, arg3)         	DTRACE_PROBE3(__vminfo_, name, arg1, arg2, arg3)
DTRACE_VM4(name, type1, arg1, type2, arg2,                      	    type3, arg3, type4, arg4)                                           	DTRACE_PROBE4(__vminfo_, name, arg1, arg2, arg3, arg4)
DTRACE_VM5(name, type1, arg1, type2, arg2,                      	    type3, arg3, type4, arg4, type5, arg5)                              	DTRACE_PROBE5(__vminfo_, name, arg1, arg2, arg3, arg4, arg5)
DTRACE_VM6(name, type1, arg1, type2, arg2,                      	    type3, arg3, type4, arg4, type5, arg5, type6, arg6) 	DTRACE_PROBE6(__vminfo_, name, arg1, arg2, arg3, arg4, arg5, arg6)
DTRACE_VM7(name, type1, arg1, type2, arg2,                      	    type3, arg3, type4, arg4, type5, arg5, type6, arg6, type7, arg7) 	DTRACE_PROBE7(__vminfo_, name, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
DTRACE_VM8(name, type1, arg1, type2, arg2,                      	    type3, arg3, type4, arg4, type5, arg5, type6, arg6, type7, arg7, type8, arg8) 	DTRACE_PROBE8(__vminfo_, name, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
DTRACE_IP(name) DTRACE_PROBE(__ip_, name)
DTRACE_IP1(name, type1, arg1)                                   	DTRACE_PROBE1(__ip_, name, arg1)
DTRACE_IP2(name, type1, arg1, type2, arg2)                      	DTRACE_PROBE2(__ip_, name, arg1, arg2)
DTRACE_IP3(name, type1, arg1, type2, arg2, type3, arg3)         	DTRACE_PROBE3(__ip_, name, arg1, arg2, arg3)
DTRACE_IP4(name, type1, arg1, type2, arg2,                      	    type3, arg3, type4, arg4)                                           	DTRACE_PROBE4(__ip_, name, arg1, arg2, arg3, arg4)
DTRACE_IP5(name, typ1, arg1, type2, arg2, type3, arg3,          	    type4, arg4, type5, arg5)                                           	DTRACE_PROBE5(__ip_, name, arg1, arg2, arg3, arg4, arg5)
DTRACE_IP6(name, type1, arg1, type2, arg2, type3, arg3,         	    type4, arg4, type5, arg5, type6, arg6)                               	DTRACE_PROBE6(__ip_, name, arg1, arg2, arg3, arg4, arg5, arg6)
DTRACE_IP7(name, type1, arg1, type2, arg2, type3, arg3,         	    type4, arg4, type5, arg5, type6, arg6, type7, arg7)                 	DTRACE_PROBE7(__ip_, name, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
DTRACE_ROUTE(name) DTRACE_PROBE(__route_, name)
DTRACE_ROUTE1(name, type1, arg1)                                	DTRACE_PROBE1(__route_, name, arg1)
DTRACE_ROUTE2(name, type1, arg1, type2, arg2)                   	DTRACE_PROBE2(__route_, name, arg1, arg2)
DTRACE_ROUTE3(name, type1, arg1, type2, arg2, type3, arg3)      	DTRACE_PROBE3(__route_, name, arg1, arg2, arg3)
DTRACE_ROUTE4(name, type1, arg1, type2, arg2,                   	    type3, arg3, type4, arg4)                                           	DTRACE_PROBE4(__route_, name, arg1, arg2, arg3, arg4)
DTRACE_ROUTE5(name, typ1, arg1, type2, arg2, type3, arg3,       	    type4, arg4, type5, arg5)                                           	DTRACE_PROBE5(__route_, name, arg1, arg2, arg3, arg4, arg5)
DTRACE_ROUTE6(name, type1, arg1, type2, arg2, type3, arg3,      	    type4, arg4, type5, arg5, type6, arg6)                               	DTRACE_PROBE6(__route_, name, arg1, arg2, arg3, arg4, arg5, arg6)
DTRACE_ROUTE7(name, type1, arg1, type2, arg2, type3, arg3,      	    type4, arg4, type5, arg5, type6, arg6, type7, arg7)                 	DTRACE_PROBE7(__route_, name, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
DTRACE_TCP(name) DTRACE_PROBE(__tcp_, name)
DTRACE_TCP1(name, type1, arg1)                                   	DTRACE_PROBE1(__tcp_, name, arg1)
DTRACE_TCP2(name, type1, arg1, type2, arg2)                      	DTRACE_PROBE2(__tcp_, name, arg1, arg2)
DTRACE_TCP3(name, type1, arg1, type2, arg2, type3, arg3)         	DTRACE_PROBE3(__tcp_, name, arg1, arg2, arg3)
DTRACE_TCP4(name, type1, arg1, type2, arg2,                      	    type3, arg3, type4, arg4)                                           	DTRACE_PROBE4(__tcp_, name, arg1, arg2, arg3, arg4)
DTRACE_TCP5(name, typ1, arg1, type2, arg2, type3, arg3,          	    type4, arg4, type5, arg5)                                           	DTRACE_PROBE5(__tcp_, name, arg1, arg2, arg3, arg4, arg5)
DTRACE_MPTCP(name) DTRACE_PROBE(__mptcp_, name)
DTRACE_MPTCP1(name, type1, arg1)                                	DTRACE_PROBE1(__mptcp_, name, arg1)
DTRACE_MPTCP2(name, type1, arg1, type2, arg2)                   	DTRACE_PROBE2(__mptcp_, name, arg1, arg2)
DTRACE_MPTCP3(name, type1, arg1, type2, arg2, type3, arg3)      	DTRACE_PROBE3(__mptcp_, name, arg1, arg2, arg3)
DTRACE_MPTCP4(name, type1, arg1, type2, arg2,                   	    type3, arg3, type4, arg4)                          	DTRACE_PROBE4(__mptcp_, name, arg1, arg2, arg3, arg4)
DTRACE_MPTCP5(name, typ1, arg1, type2, arg2, type3, arg3,       	    type4, arg4, type5, arg5)                         	DTRACE_PROBE5(__mptcp_, name, arg1, arg2, arg3, arg4, arg5)
DTRACE_MPTCP6(name, typ1, arg1, type2, arg2, type3, arg3,       	    type4, arg4, type5, arg5, type6, arg6)            	DTRACE_PROBE6(__mptcp_, name, arg1, arg2, arg3, arg4, arg5, arg6)
DTRACE_MPTCP7(name, typ1, arg1, type2, arg2, type3, arg3,       	    type4, arg4, type5, arg5, type6, arg6,            	    type7, arg7)                                      	DTRACE_PROBE7(__mptcp_, name, arg1, arg2, arg3, arg4, arg5,     	              arg6, arg7)
DTRACE_FSINFO(name, type, vp)                                   	DTRACE_PROBE1(__fsinfo_, name, vp)
DTRACE_FSINFO_IO(name, type1, vp, type2, size)                  	DTRACE_PROBE2(__fsinfo_, name, vp, size)
DTRACE_BOOST(name) DTRACE_PROBE(__boost_, name);
DTRACE_BOOST1(name, type1, arg1)                                	DTRACE_PROBE1(__boost_, name, arg1);
DTRACE_BOOST2(name, type1, arg1, type2, arg2)                   	DTRACE_PROBE2(__boost_, name, arg1, arg2);
DTRACE_BOOST3(name, type1, arg1, type2, arg2, type3, arg3)      	DTRACE_PROBE3(__boost_, name, arg1, arg2, arg3);
DTRACE_BOOST4(name, type1, arg1, type2, arg2,                   	    type3, arg3, type4, arg4)                                           	DTRACE_PROBE4(__boost_, name, arg1, arg2, arg3, arg4);
DTRACE_BOOST5(name, type1, arg1, type2, arg2,                   	    type3, arg3, type4, arg4, type5, arg5)                                              	DTRACE_PROBE5(__boost_, name, arg1, arg2, arg3, arg4, arg5);
DTRACE_BOOST6(name, type1, arg1, type2, arg2,                   	    type3, arg3, type4, arg4, type5, arg5, type6, arg6)                 	DTRACE_PROBE6(__boost_, name, arg1, arg2, arg3, arg4, arg5, arg6);
DTRACE_SKYWALK(name) DTRACE_PROBE(__skywalk_, name)
DTRACE_SKYWALK1(name, type1, arg1)                              	DTRACE_PROBE1(__skywalk_, name, arg1)
DTRACE_SKYWALK2(name, type1, arg1, type2, arg2)                 	DTRACE_PROBE2(__skywalk_, name, arg1, arg2)
DTRACE_SKYWALK3(name, type1, arg1, type2, arg2, type3, arg3)    	DTRACE_PROBE3(__skywalk_, name, arg1, arg2, arg3)
DTRACE_SKYWALK4(name, type1, arg1, type2, arg2, type3, arg3,    	    type4, arg4)                                                	DTRACE_PROBE4(__skywalk_, name, arg1, arg2, arg3, arg4)
DTRACE_SKYWALK5(name, type1, arg1, type2, arg2, type3, arg3,    	    type4, arg4, type5, arg5)                                   	DTRACE_PROBE5(__skywalk_, name, arg1, arg2, arg3, arg4, arg5)
DTRACE_SKYWALK6(name, type1, arg1, type2, arg2, type3, arg3,    	    type4, arg4, type5, arg5, type6, arg6)                      	DTRACE_PROBE6(__skywalk_, name, arg1, arg2, arg3, arg4, arg5, arg6)
DTRACE_SKYWALK7(name, type1, arg1, type2, arg2, type3, arg3,    	    type4, arg4, type5, arg5, type6, arg6, type7, arg7)         	DTRACE_PROBE7(__skywalk_, name, arg1, arg2, arg3, arg4, arg5, arg6, arg7)
DTRACE_SKYWALK8(name, type1, arg1, type2, arg2, type3, arg3,         	    type4, arg4, type5, arg5, type6, arg6, type7, arg7, type8, arg8) 	DTRACE_PROBE8(__skywalk_, name, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
DTRACE_KCOV1(name, type1, arg1)                            	DTRACE_PROBE1(__kcov_, name, arg1)
DTRACE_HV(name) DTRACE_PROBE(__hv_, name)
DTRACE_HV1(name, type1, arg1)                              	DTRACE_PROBE1(__hv_, name, arg1)
DTRACE_HV2(name, type1, arg1, type2, arg2)                 	DTRACE_PROBE2(__hv_, name, arg1, arg2)
DTRACE_HV3(name, type1, arg1, type2, arg2, type3, arg3)    	DTRACE_PROBE3(__hv_, name, arg1, arg2, arg3)
DTRACE_HV4(name, type1, arg1, type2, arg2, type3, arg3,    	    type4, arg4)                                                	DTRACE_PROBE4(__hv_, name, arg1, arg2, arg3, arg4)
DTRACE_HV5(name, type1, arg1, type2, arg2, type3, arg3,    	    type4, arg4, type5, arg5)                                   	DTRACE_PROBE5(__hv_, name, arg1, arg2, arg3, arg4, arg5)
DTRACE_HV6(name, type1, arg1, type2, arg2, type3, arg3,    	    type4, arg4, type5, arg5, type6, arg6)                      	DTRACE_PROBE6(__hv_, name, arg1, arg2, arg3, arg4, arg5, arg6)
_MACH_MACHINE_SDT_ISA_H_ None
_MACH_MACHINE_SYSCALL_SW_H_ None
_MACH_MACHINE_THREAD_STATE_H_ None
THREAD_STATE_MAX 1296
_MACH_MACHINE_THREAD_STATUS_H_ None
_MACH_MACHINE_VM_PARAM_H_ None
_MACH_MACHINE_VM_TYPES_H_ None
_MACH_MACHINE__STRUCTS_H_ None
_MACH_MACHINE_TYPES_H_ 1
_SIG64_BITS __val[0]
_MACH_MACHINE_TYPES_H_ 1
_SIG64_BITS __val[0]
_MACH_MACHINE_TYPES_H None
_SYS_TIMERS_H_ None
TIMEOFDAY 1
KDP_TEST_HARNESS 0
dprintf(x) kprintf x
ARM32_LR_OFFSET 4
ARM64_LR_OFFSET 8
IS_PHYS_ADDR(addr) IS_USERADDR64_CANONICAL(addr)
_KDP_X86_COMMON_H_ None
KDP_JTAG_COREDUMP_SIGNATURE 0x434f524544554d50
KDP_JTAG_COREDUMP_VERSION_1 1
KDP_TEST_HARNESS 0
dprintf(x) printf x
RETURN_OFFSET64 8
__APPLE_API_PRIVATE 1
__APPLE_API_UNSTABLE 1
ROUNDUP(a, b) (((a) + ((b) - 1)) & (~((b) - 1)))
ROUNDDOWN(x, y) (((x)/(y))*(y))
MAX_PROCNAME_LEN 32
PRINT_ARGS_FROM_STACK_FRAME 0
DUMPFRAMES 32
PANICLOG_UUID_BUF_SIZE 256
ACPI_RSDP_GUID { 0xeb9d2d30, 0x2d88, 0x11d3, {0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d} }
ACPI_20_RSDP_GUID { 0x8868e871, 0xe4f1, 0x11d3, {0xbc, 0x22, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81} }
setif(_bits, _bit, _condition) 	if (_condition) _bits |= _bit
_I386_COMMPAGE_H None
_I386_VMX_ASM_H_ None
VMX_FAIL_INVALID -1
VMX_FAIL_VALID -2
VMX_SUCCEED 0
VMX_VCR_VMCS_MEM_TYPE_BIT 50
VMX_VCR_VMCS_MEM_TYPE_MASK 0xF
VMX_VCR_VMCS_SIZE_BIT 32
VMX_VCR_VMCS_SIZE_MASK 0x01FFF
VMX_VCR_VMCS_REV_ID 0x00000000FFFFFFFFLL
VMX_VCR_ACT_HLT_BIT 6
VMX_VCR_ACT_HLT_MASK 0x1
VMX_VCR_ACT_SHUTDOWN_BIT 7
VMX_VCR_ACT_SHUTDOWN_MASK 0x1
VMX_VCR_ACT_SIPI_BIT 8
VMX_VCR_ACT_SIPI_MASK 0x1
VMX_VCR_ACT_CSTATE_BIT 9
VMX_VCR_ACT_CSTATE_MASK 0x1
VMX_VCR_CR3_TARGS_BIT 16
VMX_VCR_CR3_TARGS_MASK 0xFF
VMX_VCR_MAX_MSRS_BIT 25
VMX_VCR_MAX_MSRS_MASK 0x7
VMX_VCR_MSEG_ID_BIT 32
VMX_VCR_MSEG_ID_MASK 0xFFFFFFFF
VMX_KPRINTF(x...) None
rdmsr_mask(msr, mask) (uint32_t)(rdmsr64(msr) & (mask))
CHK(msr, shift, mask) if (!VMX_CAP(msr, shift, mask)) return FALSE;
_I386_VMX_CPU_H_ None
VMX_CAP(msr, shift, mask) (rdmsr64(msr) & ((mask) << (shift)))
_I386_VMX_SHIMS_H_ None
_CORECRYPTO_CCARM_PAC_BTI_MACROS_H_ None
__arm64e__ 0
dyldLogFunc(msg, ...)
NUM_BOOTKC_RANGES 5
PMAP_TT_ALLOCATE_NOWAIT 0x1
SPTM_PTE_IN_FLIGHT_MARKER 0x80U
pte_set_was_writeable(pte, was_writeable) 	do {                                         	        if ((was_writeable)) {               	                (pte) |= ARM_PTE_WRITEABLE;  	        } else {                             	                (pte) &= ~ARM_PTE_WRITEABLE; 	        }                                    	} while(0)
FLUSH_PTE() __builtin_arm_dmb(DMB_ISH);
FLUSH_PTE_STRONG() __builtin_arm_dsb(DSB_ISHST);
PMAP_OPTIONS_PPO_PENDING_RETYPE 0x80000000
PPO_PERCPU_INIT() do { 	        disable_preemption(); 	        pmap_cpu_data = pmap_get_cpu_data(); 	        sptm_pcpu = PERCPU_GET(pmap_sptm_percpu); 	        sptm_ops = sptm_pcpu->sptm_ops; 	        sptm_ptds = sptm_pcpu->sptm_ptds; 	        sptm_ptd_info = sptm_pcpu->sptm_ptd_info; 	        if (remove) { 	                os_atomic_store(&pmap_cpu_data->inflight_disconnect, true, relaxed); 			 	                os_atomic_thread_fence(release); 	        } 	} while (0)
FFF_PERCPU_INIT() do { 	        disable_preemption(); 	        sptm_pcpu = PERCPU_GET(pmap_sptm_percpu); 	        sptm_ops = sptm_pcpu->sptm_ops; 	} while (0)
_ARM_PMAP_H_ None
CPUWINDOWS_MAX 4
PTE_PER_PVE 2
SUPERPAGE_NBASEPAGES 1
pmap_cs_log(level, fmt, args...)
pmap_cs_log_debug(fmt, args...)
pmap_cs_log_info(fmt, args...)
pmap_cs_log_error(fmt, args...)
pmap_cs_log_force(level, fmt, args...)
PMAP_TYPE_USER 0
PMAP_TYPE_KERNEL 1
PMAP_TYPE_COMMPAGE 2
PMAP_TYPE_NESTED 3
PMAP_CONTEXT(pmap, thread)
PMAP_SWITCH_USER(th, new_map, my_cpu) pmap_switch_user((th), (new_map))
pmap_attribute(pmap, addr, size, attr, value) (KERN_INVALID_ADDRESS)
copyinmsg(from, to, cnt) copyin(from, to, cnt)
copyoutmsg(from, to, cnt) copyout(from, to, cnt)
MACRO_NOOP None
pmap_copy(dst_pmap, src_pmap, dst_addr, len, src_addr) MACRO_NOOP
pmap_pageable(pmap, start, end, pageable) MACRO_NOOP
PMAP_MAP_BD_DEVICE 0x0
PMAP_MAP_BD_WCOMB 0x1
PMAP_MAP_BD_POSTED 0x2
PMAP_MAP_BD_POSTED_REORDERED 0x3
PMAP_MAP_BD_POSTED_COMBINED_REORDERED 0x4
PMAP_MAP_BD_MASK 0x7
ARM_PMAP_MAX_OFFSET_DEFAULT 0x01
ARM_PMAP_MAX_OFFSET_MIN 0x02
ARM_PMAP_MAX_OFFSET_MAX 0x04
ARM_PMAP_MAX_OFFSET_DEVICE 0x08
ARM_PMAP_MAX_OFFSET_JUMBO 0x10
ARM_FAST_FAULT_INDEX 0
ARM_FORCE_FAST_FAULT_INDEX 1
MAPPING_FREE_PRIME_INDEX 2
MAPPING_REPLENISH_INDEX 3
PHYS_ATTRIBUTE_CLEAR_INDEX 4
PHYS_ATTRIBUTE_SET_INDEX 5
PMAP_BATCH_SET_CACHE_ATTRIBUTES_INDEX 6
PMAP_CHANGE_WIRING_INDEX 7
PMAP_CREATE_INDEX 8
PMAP_DESTROY_INDEX 9
PMAP_ENTER_OPTIONS_INDEX 10
PMAP_FIND_PA_INDEX 12
PMAP_INSERT_COMMPAGE_INDEX 13
PMAP_IS_EMPTY_INDEX 14
PMAP_MAP_CPU_WINDOWS_COPY_INDEX 15
PMAP_MARK_PAGE_AS_PMAP_PAGE_INDEX 16
PMAP_NEST_INDEX 17
PMAP_PAGE_PROTECT_OPTIONS_INDEX 18
PMAP_PROTECT_OPTIONS_INDEX 19
PMAP_QUERY_PAGE_INFO_INDEX 20
PMAP_QUERY_RESIDENT_INDEX 21
PMAP_REFERENCE_INDEX 22
PMAP_REMOVE_OPTIONS_INDEX 23
PMAP_SET_CACHE_ATTRIBUTES_INDEX 25
PMAP_SET_NESTED_INDEX 26
PMAP_SET_PROCESS_INDEX 27
PMAP_SWITCH_INDEX 28
PMAP_SWITCH_USER_TTB_INDEX 29
PMAP_CLEAR_USER_TTB_INDEX 30
PMAP_UNMAP_CPU_WINDOWS_COPY_INDEX 31
PMAP_UNNEST_OPTIONS_INDEX 32
PMAP_FOOTPRINT_SUSPEND_INDEX 33
PMAP_CPU_DATA_INIT_INDEX 34
PMAP_RELEASE_PAGES_TO_KERNEL_INDEX 35
PMAP_SET_JIT_ENTITLED_INDEX 36
PMAP_UPDATE_COMPRESSOR_PAGE_INDEX 55
PMAP_TRIM_INDEX 56
PMAP_LEDGER_VERIFY_SIZE_INDEX 57
PMAP_LEDGER_ALLOC_INDEX 58
PMAP_LEDGER_FREE_INDEX 59
PHYS_ATTRIBUTE_CLEAR_RANGE_INDEX 66
PMAP_SET_VM_MAP_CS_ENFORCED_INDEX 72
PMAP_SET_COMPILATION_SERVICE_CDHASH_INDEX 73
PMAP_MATCH_COMPILATION_SERVICE_CDHASH_INDEX 74
PMAP_NOP_INDEX 75
PMAP_RO_ZONE_MEMCPY_INDEX 76
PMAP_RO_ZONE_ATOMIC_OP_INDEX 77
PMAP_SET_LOCAL_SIGNING_PUBLIC_KEY_INDEX 84
PMAP_UNRESTRICT_LOCAL_SIGNING_INDEX 85
PMAP_RO_ZONE_BZERO_INDEX 90
PMAP_SET_TPRO_INDEX 98
PMAP_COUNT 99
PMAP_MAX_PV_LIST_CHUNK_SIZE 64
PMAP_DEFAULT_PREEMPTION_CHECK_PAGE_INTERVAL 64
MARK_AS_PMAP_TEXT None
MARK_AS_PMAP_DATA None
MARK_AS_PMAP_RODATA None
pmap_force_dcache_clean(va, sz) CleanPoC_DcacheRegion_Force(va, sz)
pmap_simple_lock(l) simple_lock(l, &pmap_lck_grp)
pmap_simple_unlock(l) simple_unlock(l)
pmap_simple_lock_try(l) simple_lock_try(l, &pmap_lck_grp)
pmap_simple_lock_assert(l, t)   simple_lock_assert(l, t)
PMAP_HIB_STATE_REACHED(states) false
PMAP_ASSERT_NOT_WRITING_HIB() None
PMAP_IS_HIBERNATING() false
INVALID_PAI UINT_MAX
PVH_TYPE_NULL 0x0UL
PVH_TYPE_PVEP 0x1UL
PVH_TYPE_PTEP 0x2UL
PVH_TYPE_PTDP 0x3UL
PVH_FLAG_IOMMU 0x4UL
PVH_LOCK_BIT 61
PVH_LOCK_WORD 1
IOMMU_ID_SHIFT 8U
IOMMU_ID_MASK 0x000000000000FF00ULL
IOMMU_TOKEN_SHIFT 16U
IOMMU_TOKEN_MASK 0x0000FFFFFFFF0000ULL
IOMMU_INSTANCE_DEFAULT 0xFFFF000000000000ULL
IOMMU_INSTANCE_NULL 0xFFFFFFFFFFFFFF00ULL
PP_ATTR_WIMG_MASK 0x003F
PP_ATTR_REFERENCED 0x0040
PP_ATTR_MODIFIED 0x0080
PP_ATTR_INTERNAL 0x0100
PP_ATTR_REUSABLE 0x0200
PP_ATTR_ALTACCT 0x0400
PP_ATTR_NOENCRYPT 0x0800
PP_ATTR_REFFAULT 0x1000
PP_ATTR_MODFAULT 0x2000
PMAP_MIN_FREE_PPL_PAGES 8
PMAP_PAGE_ALLOCATE_NONE 0x0
PMAP_PAGE_ALLOCATE_NOWAIT 0x1
PMAP_PAGE_RECLAIM_NOWAIT 0x2
PMAP_PAGE_NOZEROFILL 0x4
validate_pmap(x) validate_pmap_internal(x, __func__)
validate_pmap_mutable(x) validate_pmap_mutable_internal(x, __func__)
PMAP_SUPPORT_PROTOTYPES(__return_type, __function_name, __function_args, __function_index) 	extern __return_type __function_name##_internal __function_args
PMAP_ALIGN(addr, align) ((addr) + ((align) - 1) & ~((align) - 1))
_ARM_PMAP_PMAP_PT_GEOMETRY_H_ None
PMAP_TT_L0_LEVEL 0x0
PMAP_TT_L1_LEVEL 0x1
PMAP_TT_L2_LEVEL 0x2
PMAP_TT_L3_LEVEL 0x3
_ARM_PMAP_PUBLIC_H_ None
ARM_FEATURE_FLAG(x) extern int gARM_ ## x;
COMMPAGE_TEXT_SEGMENT "__TEXT_EXEC"
COMMPAGE_TEXT_SECTION "__commpage_text"
BRK_666_OPCODE 0xD4205340
_test_sys_bits(name, mask) ({ 	const uint64_t src = __builtin_arm_rsr64(#name);     uint64_t test = src | mask;     if (test != src) { 	__builtin_arm_wsr64(#name, test); 	test = __builtin_arm_rsr64(#name); 	if (test != src) { 	    __builtin_arm_wsr64(#name, src); 	}    }     mask & test; })
_ARM_COMMPAGE_H None
commpage_disable_timestamp() commpage_set_timestamp( 0, 0, 0, 0, 0 );
FREE_PAGE_SIZE_TT_MAX 4
ARM_PTE_IS_COMPRESSED(x, p) 	((((x) & 0x3) == 0) &&                       	 ((x) & ARM_PTE_COMPRESSED) &&       	 ((!((x) & ~ARM_PTE_COMPRESSED_MASK)) ||        	 (panic("compressed PTE %p 0x%llx has extra bits 0x%llx: corrupted?", 	        (p), (x), (x) & ~ARM_PTE_COMPRESSED_MASK), FALSE)))
pte_set_was_writeable(pte, was_writeable) 	do {                                         	        if ((was_writeable)) {               	                (pte) |= ARM_PTE_WRITEABLE;  	        } else {                             	                (pte) &= ~ARM_PTE_WRITEABLE; 	        }                                    	} while(0)
PMAP_UPDATE_TLBS(pmap, s, e, strong, last_level_only) {                                               	pmap_get_pt_ops(pmap)->flush_tlb_region_async(s, (size_t)((e) - (s)), pmap, last_level_only, strong); 	arm64_sync_tlb(strong);                                                                               }
FLUSH_PTE() __builtin_arm_dmb(DMB_ISH);
FLUSH_PTE_STRONG() __builtin_arm_dsb(DSB_ISHST);
PMAP_TT_ALLOCATE_NOWAIT 0x1
PMAP_TT_DEALLOCATE_NOBLOCK 0x1
PMAP_TT_ALLOCATE_NOWAIT 0x1
PMAP_TT_DEALLOCATE_NOBLOCK 0x1
PMAP_BATCH_SET_CACHE_ATTRIBUTES_UPDATE_PASS 1
PMAP_BATCH_SET_CACHE_ATTRIBUTES_TLBFLUSH_PASS 2
PMAP_BATCH_SET_CACHE_ATTRIBUTES_CACHEFLUSH_PASS 3
PMAP_BATCH_SET_CACHE_ATTRIBUTES_DONE 4
ARM_PTE_FF_MARKER ARM_PTE_COMPRESSED
_ARM_PMAP_H_ None
CPUWINDOWS_MAX 4
PTE_PER_PVE 2
SUPERPAGE_NBASEPAGES 1
pmap_cs_log(level, fmt, args...)
pmap_cs_log_debug(fmt, args...)
pmap_cs_log_info(fmt, args...)
pmap_cs_log_error(fmt, args...)
pmap_cs_log_force(level, fmt, args...)
PMAP_TYPE_USER 0
PMAP_TYPE_KERNEL 1
PMAP_TYPE_COMMPAGE 2
PMAP_TYPE_NESTED 3
PMAP_CONTEXT(pmap, thread)
PMAP_SWITCH_USER(th, new_map, my_cpu) pmap_switch_user((th), (new_map))
pmap_attribute(pmap, addr, size, attr, value) (KERN_INVALID_ADDRESS)
copyinmsg(from, to, cnt) copyin(from, to, cnt)
copyoutmsg(from, to, cnt) copyout(from, to, cnt)
MACRO_NOOP None
pmap_copy(dst_pmap, src_pmap, dst_addr, len, src_addr) MACRO_NOOP
pmap_pageable(pmap, start, end, pageable) MACRO_NOOP
PMAP_MAP_BD_DEVICE 0x0
PMAP_MAP_BD_WCOMB 0x1
PMAP_MAP_BD_POSTED 0x2
PMAP_MAP_BD_POSTED_REORDERED 0x3
PMAP_MAP_BD_POSTED_COMBINED_REORDERED 0x4
PMAP_MAP_BD_MASK 0x7
ARM_PMAP_MAX_OFFSET_DEFAULT 0x01
ARM_PMAP_MAX_OFFSET_MIN 0x02
ARM_PMAP_MAX_OFFSET_MAX 0x04
ARM_PMAP_MAX_OFFSET_DEVICE 0x08
ARM_PMAP_MAX_OFFSET_JUMBO 0x10
ARM_FAST_FAULT_INDEX 0
ARM_FORCE_FAST_FAULT_INDEX 1
MAPPING_FREE_PRIME_INDEX 2
MAPPING_REPLENISH_INDEX 3
PHYS_ATTRIBUTE_CLEAR_INDEX 4
PHYS_ATTRIBUTE_SET_INDEX 5
PMAP_BATCH_SET_CACHE_ATTRIBUTES_INDEX 6
PMAP_CHANGE_WIRING_INDEX 7
PMAP_CREATE_INDEX 8
PMAP_DESTROY_INDEX 9
PMAP_ENTER_OPTIONS_INDEX 10
PMAP_FIND_PA_INDEX 12
PMAP_INSERT_COMMPAGE_INDEX 13
PMAP_IS_EMPTY_INDEX 14
PMAP_MAP_CPU_WINDOWS_COPY_INDEX 15
PMAP_MARK_PAGE_AS_PMAP_PAGE_INDEX 16
PMAP_NEST_INDEX 17
PMAP_PAGE_PROTECT_OPTIONS_INDEX 18
PMAP_PROTECT_OPTIONS_INDEX 19
PMAP_QUERY_PAGE_INFO_INDEX 20
PMAP_QUERY_RESIDENT_INDEX 21
PMAP_REFERENCE_INDEX 22
PMAP_REMOVE_OPTIONS_INDEX 23
PMAP_SET_CACHE_ATTRIBUTES_INDEX 25
PMAP_SET_NESTED_INDEX 26
PMAP_SET_PROCESS_INDEX 27
PMAP_SWITCH_INDEX 28
PMAP_SWITCH_USER_TTB_INDEX 29
PMAP_CLEAR_USER_TTB_INDEX 30
PMAP_UNMAP_CPU_WINDOWS_COPY_INDEX 31
PMAP_UNNEST_OPTIONS_INDEX 32
PMAP_FOOTPRINT_SUSPEND_INDEX 33
PMAP_CPU_DATA_INIT_INDEX 34
PMAP_RELEASE_PAGES_TO_KERNEL_INDEX 35
PMAP_SET_JIT_ENTITLED_INDEX 36
PMAP_UPDATE_COMPRESSOR_PAGE_INDEX 55
PMAP_TRIM_INDEX 56
PMAP_LEDGER_VERIFY_SIZE_INDEX 57
PMAP_LEDGER_ALLOC_INDEX 58
PMAP_LEDGER_FREE_INDEX 59
PHYS_ATTRIBUTE_CLEAR_RANGE_INDEX 66
PMAP_SET_VM_MAP_CS_ENFORCED_INDEX 72
PMAP_SET_COMPILATION_SERVICE_CDHASH_INDEX 73
PMAP_MATCH_COMPILATION_SERVICE_CDHASH_INDEX 74
PMAP_NOP_INDEX 75
PMAP_RO_ZONE_MEMCPY_INDEX 76
PMAP_RO_ZONE_ATOMIC_OP_INDEX 77
PMAP_SET_LOCAL_SIGNING_PUBLIC_KEY_INDEX 84
PMAP_UNRESTRICT_LOCAL_SIGNING_INDEX 85
PMAP_RO_ZONE_BZERO_INDEX 90
PMAP_LOAD_TRUST_CACHE_WITH_TYPE_INDEX 98
PMAP_QUERY_TRUST_CACHE_INDEX 99
PMAP_TOGGLE_DEVELOPER_MODE_INDEX 100
PMAP_REGISTER_PROVISIONING_PROFILE_INDEX 101
PMAP_UNREGISTER_PROVISIONING_PROFILE_INDEX 102
PMAP_ASSOCIATE_PROVISIONING_PROFILE_INDEX 103
PMAP_DISASSOCIATE_PROVISIONING_PROFILE_INDEX 104
PMAP_SET_TPRO_INDEX 105
PMAP_ASSOCIATE_KERNEL_ENTITLEMENTS_INDEX 106
PMAP_RESOLVE_KERNEL_ENTITLEMENTS_INDEX 107
PMAP_ACCELERATE_ENTITLEMENTS_INDEX 108
PMAP_CHECK_TRUST_CACHE_RUNTIME_FOR_UUID_INDEX 109
PMAP_IMAGE4_MONITOR_TRAP_INDEX 110
PMAP_COUNT 111
PMAP_MAX_PV_LIST_CHUNK_SIZE 64
PMAP_DEFAULT_PREEMPTION_CHECK_PAGE_INTERVAL 64
_ARM_PMAP_PMAP_DATA_H_ None
PVH_TYPE_NULL 0x0UL
PVH_TYPE_PVEP 0x1UL
PVH_TYPE_PTEP 0x2UL
PVH_TYPE_PTDP 0x3UL
PVH_FLAG_IOMMU 0x4UL
PVH_LOCK_BIT 61
PVH_LOCK_WORD 1
PT_DESC_REFCOUNT 0x4000U
PT_DESC_IOMMU_GRANTED_REFCOUNT 0x8000U
PT_DESC_IOMMU_ACCEPTED_REFCOUNT 0x8001U
PP_ATTR_WIMG_MASK 0x003F
PP_ATTR_REFERENCED 0x0040
PP_ATTR_MODIFIED 0x0080
PP_ATTR_INTERNAL 0x0100
PP_ATTR_REUSABLE 0x0200
PP_ATTR_ALTACCT 0x0400
PP_ATTR_NOENCRYPT 0x0800
PP_ATTR_REFFAULT 0x1000
PP_ATTR_MODFAULT 0x2000
PMAP_MIN_FREE_PPL_PAGES 8
PMAP_PAGES_ALLOCATE_NOWAIT 0x1
PMAP_PAGE_RECLAIM_NOWAIT 0x2
validate_pmap(x) validate_pmap_internal(x, __func__)
validate_pmap_mutable(x) validate_pmap_mutable_internal(x, __func__)
_ARM_PMAP_PMAP_INTERNAL_H_ None
PMAP_ALIGN(addr, align) ((addr) + ((align) - 1) & ~((align) - 1))
_ARM_PMAP_PMAP_PT_GEOMETRY_H_ None
PMAP_TT_L0_LEVEL 0x0
PMAP_TT_L1_LEVEL 0x1
PMAP_TT_L2_LEVEL 0x2
PMAP_TT_L3_LEVEL 0x3
__SIGABRT 6
__STDERR_FILENO 2
NO_SUCH_ERROR "unknown error code"
err_sub_map_entry(start, end)  { err_get_sub(start),  err_get_sub(end) }
err_code_map_entry(start, end) { err_get_code(start), err_get_code(end) }
errorlib_system_null { NULL, 0, NULL, NULL, 0 }
errorlib_sub_null { 0, NULL, NULL, NULL, 0 }
__EXC_CATCHER_H None
_MACH_EXTERNS_H_ None
__STDERR_FILENO 2
_mach_assert(__op, __kr) 	do { 	        if (kr != KERN_SUCCESS) { 	                __builtin_trap(); 	        } 	} while (0)
_vm_map_user_ None
_mach_vm_user_ None
_mach_assert(__op, __kr) 	do { 	        if (kr != KERN_SUCCESS) { 	                __builtin_trap(); 	        } 	} while (0)
RB_DEBUGGER 0x1000
SP_ENTRY(id) [id] = #id
stack_logging_type_vm_allocate 16
stack_logging_type_vm_deallocate 32
stack_logging_type_mapped_file_or_shared_mem 128
_STRING_H_ None
_assert(__op, __condition, __cause) 	do { 	        if (!(__condition)) { 	                __builtin_trap(); 	        } 	} while (false)
_abort(__op, __cause) 	do { 	        __builtin_trap(); 	} while(false)
OS_ALLOC_ONCE_KEY_MAX 100
__OS_PROC__ None
OS_THREAD_SELF_RESTRICT_H None
OS_TSD_H None
__TSD_RESERVED_BASE 0
__TSD_RESERVED_MAX 9
__TSD_THREAD_SELF 0
__TSD_ERRNO 1
__TSD_MIG_REPLY 2
__TSD_MACH_THREAD_SELF 3
__TSD_THREAD_QOS_CLASS 4
__TSD_RETURN_TO_KERNEL 5
__TSD_PTR_MUNGE 7
__TSD_MACH_SPECIAL_REPLY 8
__TSD_SEMAPHORE_CACHE 9
__TSD_MACH_MSG_AUX 123
__TPIDR_CPU_NUM_SHIFT 0
__TPIDR_CPU_NUM_MASK 0x0000000000000fff
__TPIDR_CPU_CLUSTER_ID_SHIFT 12
__TPIDR_CPU_CLUSTER_ID_MASK 0x00000000000ff000
_OS_PTR_MUNGE(_ptr) _os_ptr_munge((uintptr_t)(_ptr))
_OS_PTR_UNMUNGE(_ptr) _os_ptr_munge((uintptr_t)(_ptr))
EXCLAVES_CTL_TRAP _exclaves_ctl_trap
__GETHOSTUUID_H None
__GETHOSTUUID_PRIVATE_H None
__APPLE_API_PRIVATE None
s_left_shift(x, n) ((n) < 0 ? ((x) >> -(n)) : ((x) << (n)))
CNTVCTSS_EL0 "S3_3_c14_c0_6"
ACNTVCT_EL0 "S3_4_c15_c10_6"
ISB_SY 0xf
__SYSTEM_VERSION_COMPAT_SUPPORT_H None
push_register_value(p) do {     if ((uintptr_t)p > PAGE_SIZE) { 	if (out_length < in_length && values) 	    values[out_length] = p; 	out_length++;     } } while (0)
__LIBKERNEL_INIT_H None
VARIANT_CANCELABLE None
VARIANT_CANCELABLE None
VARIANT_DARWIN_EXTSN None
__DARWIN_NON_CANCELABLE 1
VARIANT_DARWIN_EXTSN None
VARIANT_CANCELABLE None
__DARWIN_NON_CANCELABLE 1
__SIGSUSPEND __sigsuspend
__DARWIN_NON_CANCELABLE 1
__SIGSUSPEND __sigsuspend_nocancel
_NONSTD_SOURCE None
__DARWIN_UNIX03 1
_NONSTD_SOURCE None
__DARWIN_UNIX03 1
_NONSTD_SOURCE None
__DARWIN_UNIX03 1
_NONSTD_SOURCE None
__DARWIN_UNIX03 1
_NONSTD_SOURCE None
__DARWIN_UNIX03 1
_NONSTD_SOURCE None
__DARWIN_UNIX03 1
_NONSTD_SOURCE None
_NONSTD_SOURCE None
__DARWIN_UNIX03 1
_NONSTD_SOURCE None
__DARWIN_UNIX03 1
_NONSTD_SOURCE None
_NONSTD_SOURCE None
_NONSTD_SOURCE None
_NONSTD_SOURCE None
__DARWIN_UNIX03 1
_NONSTD_SOURCE None
__DARWIN_UNIX03 1
_NONSTD_SOURCE None
VARIANT_LEGACY None
_NONSTD_SOURCE None
__DARWIN_UNIX03 1
_NONSTD_SOURCE None
__DARWIN_UNIX03 1
_NONSTD_SOURCE None
__DARWIN_UNIX03 1
_NONSTD_SOURCE None
__SIGSUSPEND __sigsuspend_nocancel
_NONSTD_SOURCE None
__DARWIN_UNIX03 1
WAKEMON_GET_PARAMS 0x4
WAKEMON_SET_DEFAULTS 0x8
_LIBPROC_H_ None
PROC_LISTPIDSPATH_PATH_IS_VOLUME 1
PROC_LISTPIDSPATH_EXCLUDE_EVTONLY 2
PROC_SETPC_NONE 0
PROC_SETPC_THROTTLEMEM 1
PROC_SETPC_SUSPEND 2
PROC_SETPC_TERMINATE 3
PROC_CSM_ALL 0x0001
PROC_CSM_NOSMT 0x0002
PROC_CSM_TECS 0x0004
_LIBPROC_INTERNALH_ None
PROC_SETCPU_ACTION_NONE 0
PROC_SETCPU_ACTION_THROTTLE 1
_LIBPROC_PRIVATE_H_ None
UUID_COMPARE(a, b)                                                  	(a[0] == b[0] && a[1] == b[1] && a[2] == b[2] && a[3] == b[3] &&    	a[4] == b[4] && a[5] == b[5] && a[6] == b[6] && a[7] == b[7] &&     	a[8] == b[8] && a[9] == b[9] && a[10] == b[10] && a[11] == b[11] && 	a[12] == b[12] && a[13] == b[13] && a[14] == b[14] && a[15] == b[15])
_SLOT_INDEX(_chrd, _slot)                                       	((slot_idx_t)((_slot - (_chrd)->chrd_slot_desc)))
_SLOT_DESC(_chrd, _idx)                                         	(SLOT_DESC_USD(&(_chrd)->chrd_slot_desc[_idx]))
_METADATA(_chrd, _ring, _midx)                                  	((void *)((_chrd)->chrd_md_base_addr +                          	((_midx) * (_ring)->ring_md_size) + METADATA_PREAMBLE_SZ))
_SLOT_METADATA(_chrd, _ring, _idx)                              	_METADATA(_chrd, _ring, _SLOT_DESC(_chrd, _idx)->sd_md_idx)
_SLOT_METADATA_IDX_VERIFY(_chrd, _md, _midx)    do {            	if (__improbable((_md) != _METADATA((_chrd), (_chrd)->chrd_ring, 	    (_midx))) && !_CHANNEL_RING_IS_DEFUNCT(_chrd)) {            	        SK_ABORT_WITH_CAUSE("bad packet handle", (_midx));      	                                                	        __builtin_unreachable();                                	}                                                               } while (0)
_BFT_INDEX(_chrd, _bft) (_bft)->buf_bft_idx_reg
_SLOT_BFT_METADATA(_chrd, _ring, _idx)                          	_CHANNEL_RING_BFT(_chrd, _ring, _SLOT_DESC(_chrd, _idx)->sd_md_idx)
_SLOT_BFT_METADATA_IDX_VERIFY(_chrd, _md, _midx)    do {        	if (__improbable((mach_vm_address_t)(_md) !=                    	    _CHANNEL_RING_BFT((_chrd), (_chrd)->chrd_ring, (_midx))) && 	    !_CHANNEL_RING_IS_DEFUNCT(_chrd)) {                         	        SK_ABORT_WITH_CAUSE("bad buflet handle", (_midx));      	                                                	        __builtin_unreachable();                                	}                                                               } while (0)
_SLOT_DESC_VERIFY(_chrd, _sdp) do {                             	if (__improbable(!SD_VALID_METADATA(_sdp)) &&                   	    !_CHANNEL_RING_IS_DEFUNCT(_chrd)) {                         	        SK_ABORT("Slot descriptor has no metadata");            	                                        	        __builtin_unreachable();                                	}                                                               } while (0)
_METADATA_VERIFY(_chrd, _md) do {                               	if (__improbable(METADATA_PREAMBLE(_md)->mdp_redzone !=         	    (((mach_vm_address_t)(_md) - (_chrd)->chrd_md_base_addr) ^  	    __os_ch_md_redzone_cookie)) &&                              	    !_CHANNEL_RING_IS_DEFUNCT(_chrd)) {                         	        SK_ABORT_WITH_CAUSE("Metadata redzone corrupted",       	            METADATA_PREAMBLE(_md)->mdp_redzone);               	                                        	        __builtin_unreachable();                                	}                                                               } while (0)
_PKT_BUFCNT_VERIFY(_chrd, _bcnt, _bmax) do {                    	if (__improbable((_chrd)->chrd_max_bufs < (_bmax))) {           	        SK_ABORT_WITH_CAUSE("Invalid max bufcnt", (_bmax));     	                                                	        __builtin_unreachable();                                	}                                                               	if (__improbable((_bcnt) > (_bmax))) {                          	        SK_ABORT_WITH_CAUSE("Invalid bufcnt", (_bcnt));         	                                                	        __builtin_unreachable();                                	}                                                               } while (0)
_ABORT_MSGSZ 1024
_SCHEMA_VER_VERIFY(_chd) do {                                   	                    	os_atomic_thread_fence(seq_cst);                                                  	if (CHD_SCHEMA(_chd)->csm_ver != CSM_CURRENT_VERSION)	{       	        char *_msg = malloc(_ABORT_MSGSZ);                      	        uint32_t _ver = (uint32_t)CHD_SCHEMA(_chd)->csm_ver;    	             	        (void) _mach_snprintf(_msg, _ABORT_MSGSZ,               	            "Schema region version mismatch: 0x%x != 0x%x\n"    	            "Kernel version: %s - did you forget to install "   	            "a matching libsystem_kernel.dylib?\n"              	            "Kernel UUID: %x%x%x%x-%x%x-%x%x-%x%x-%x%x%x%x%x%x", 	            _ver, (uint32_t)CSM_CURRENT_VERSION,                	            CHD_SCHEMA(_chd)->csm_kern_name,                    	            CHD_SCHEMA(_chd)->csm_kern_uuid[0],                 	            CHD_SCHEMA(_chd)->csm_kern_uuid[1],                 	            CHD_SCHEMA(_chd)->csm_kern_uuid[2],                 	            CHD_SCHEMA(_chd)->csm_kern_uuid[3],                 	            CHD_SCHEMA(_chd)->csm_kern_uuid[4],                 	            CHD_SCHEMA(_chd)->csm_kern_uuid[5],                 	            CHD_SCHEMA(_chd)->csm_kern_uuid[6],                 	            CHD_SCHEMA(_chd)->csm_kern_uuid[7],                 	            CHD_SCHEMA(_chd)->csm_kern_uuid[8],                 	            CHD_SCHEMA(_chd)->csm_kern_uuid[9],                 	            CHD_SCHEMA(_chd)->csm_kern_uuid[10],                	            CHD_SCHEMA(_chd)->csm_kern_uuid[11],                	            CHD_SCHEMA(_chd)->csm_kern_uuid[12],                	            CHD_SCHEMA(_chd)->csm_kern_uuid[13],                	            CHD_SCHEMA(_chd)->csm_kern_uuid[14],                	            CHD_SCHEMA(_chd)->csm_kern_uuid[15]);               	        SK_ABORT_DYNAMIC(_msg);                                 	                                        	        __builtin_unreachable();                                	}                                                               } while (0)
_SLOT_ATTACH_METADATA(_usd, _md_idx) do {                       	(_usd)->sd_md_idx = (_md_idx);                                  	(_usd)->sd_flags |= SD_IDX_VALID;                               } while (0)
_SLOT_DETACH_METADATA(_usd) do	{                               	(_usd)->sd_md_idx = OBJ_IDX_NONE;                               	(_usd)->sd_flags &= ~SD_IDX_VALID;                              } while (0)
_CHANNEL_OFFSET(_type, _ptr, _offset)                           	((_type)(void *)((uintptr_t)(_ptr) + (_offset)))
_CHANNEL_SCHEMA(_base, _off)                                    	_CHANNEL_OFFSET(struct __user_channel_schema *, _base, _off)
_CHANNEL_RING_DEF_BUF(_chrd, _ring, _idx)                       	((_chrd)->chrd_def_buf_base_addr +                              	((_idx) * (_ring)->ring_def_buf_size))
_CHANNEL_RING_LARGE_BUF(_chrd, _ring, _idx)                     	((_chrd)->chrd_large_buf_base_addr +                            	((_idx) * (_ring)->ring_large_buf_size))
_CHANNEL_RING_BUF(_chrd, _ring, _bft)                           	BUFLET_HAS_LARGE_BUF(_bft) ?                                    	_CHANNEL_RING_LARGE_BUF(_chrd, _ring, (_bft)->buf_idx) :        	_CHANNEL_RING_DEF_BUF(_chrd, _ring, (_bft)->buf_idx)
_CHANNEL_RING_BFT(_chrd, _ring, _idx)                           	((_chrd)->chrd_bft_base_addr + ((_idx) * (_ring)->ring_bft_size))
_CHANNEL_RING_NEXT(_ring, _cur)                                 	(__improbable((_cur) + 1 == (_ring)->ring_num_slots) ? 0 : (_cur) + 1)
_CH_PKT_GET_FIRST_BUFLET(_pkt, _bft, _chrd, _ring) do {         	if (__probable((_pkt)->pkt_qum_buf.buf_idx != OBJ_IDX_NONE)) {  	        (_bft) = &(_pkt)->pkt_qum_buf;                          	} else if ((_pkt)->pkt_qum_buf.buf_nbft_idx != OBJ_IDX_NONE) {  	        (_bft) = _CHANNEL_RING_BFT(_chrd, _ring,                	            (_pkt)->pkt_qum_buf.buf_nbft_idx);                  	} else {                                                        	        (_bft) = NULL;                                          	}                                                               } while (0)
NTRDEFAULTCOUNT 512
CONFIG_MEMORYSTATUS 1
_SPAWN_H_ None
__SPAWN_FILTERING_H None
_SPAWN_PRIVATE_H_ None
POSIX_SPAWN_IMPORTANCE_PORT_COUNT 128
POSIX_SPAWN_MACPOLICYINFO_WITHSIZE 1
wsize sizeof(word)
TLOOP(s) if (t) TLOOP1(s)
TLOOP1(s) do { s; } while (--t)
wsize sizeof(u_int)
RETURN return (dst0)
VAL c0
WIDEVAL c
_STRINGS_H_ None
testbyte(x) do {                                    	        if (p[x] == '\0')               	            return (p - str + x);       	} while (0)
NO_SUCH_ERROR "unknown error code"
_MACH_H_ None
__MACH30__ None
MACH_IPC_FLAVOR UNTYPED
VOUCHER_MACH_MSG_API_VERSION 20140205
_MACH_ERROR_ 1
_MACH_INIT_ 1
mach_task_self() mach_task_self_
current_task() mach_task_self()
NAME_SERVER_SLOT 0
ENVIRONMENT_SLOT 1
SERVICE_SLOT 2
MACH_PORTS_SLOTS_USED 3
_MACH_INTERFACE_H_ None
__MACH_RIGHT_H None
__MACH_RIGHT_PRIVATE_H None
_MACH_SYNC_IPC_H_ None
_MACH_PORT_DESCRIPTIONS_ None
PORT_OBJ_H None
port_set_obj_value_type(pname, value, type)     do {                                                    	int ndx;                                                                                                	if (!port_obj_table)                            	        port_obj_init(port_obj_table_size);     	ndx = MACH_PORT_INDEX(pname);                   	port_obj_table[ndx].pos_value = (value);        	port_obj_table[ndx].pos_type = (type);          } while (0)
_MACH_THREAD_STATE_H_ None
_VM_PAGE_SIZE_H_ None
round_page(x) trunc_page((x) + (vm_page_size - 1))
round_page_kernel(x) trunc_page_kernel((x) + vm_kernel_page_mask)
_KEY_DEFS_ None
KEY_EQUAL(key1, key2)                                       ((key1.key_longs[0] == key2.key_longs[0])                   	&& (key1.key_longs[1] == key2.key_longs[1])             	&& (key1.key_longs[2] == key2.key_longs[2])             	&& (key1.key_longs[3] == key2.key_longs[3]))
NTOH_KEY(key) {                                                     (key).key_longs[0] = ntohl((key).key_longs[0]);                         (key).key_longs[1] = ntohl((key).key_longs[1]);                         (key).key_longs[2] = ntohl((key).key_longs[2]);                         (key).key_longs[3] = ntohl((key).key_longs[3]);                     }
HTON_KEY(key) {                                                     (key).key_longs[0] = htonl((key).key_longs[0]);                         (key).key_longs[1] = htonl((key).key_longs[1]);                         (key).key_longs[2] = htonl((key).key_longs[2]);                         (key).key_longs[3] = htonl((key).key_longs[3]);                     }
PORT_NOT_SECURE 0
MESSAGE_NOT_SECURE 0
_LS_DEFS_ None
LS_PRINT_NEVER 5
LS_PRINT_LOG 3
LS_PRINT_ALWAYS 0
_NETNAME_DEFS_ None
_NM_DEFS_ None
IOKIT_ENABLE_SHARED_PTR None
super OSCollection
super OSObject
IOKIT_ENABLE_SHARED_PTR None
super OSObject
IOKIT_ENABLE_SHARED_PTR None
super OSIterator
IOKIT_ENABLE_SHARED_PTR None
super OSObject
IOKIT_ENABLE_SHARED_PTR None
super OSCollection
EXT_CAST(obj) reinterpret_cast<OSObject *>(const_cast<OSMetaClassBase *>(obj))
OBJECT_WRAP_1(cmd, k)                                           {                                                                           OSSharedPtr<const OSSymbol> tmpKey = k;                                             OSObject *retObj = NULL;                                                if (tmpKey) {                                                       	retObj = cmd(tmpKey.get());                                               }                                                                       return retObj;                                                      }
OBJECT_WRAP_2(cmd, k, o)                                        {                                                                           OSSharedPtr<const OSSymbol> tmpKey = k;                                             bool ret = cmd(tmpKey.get(), o);                                                                                                                      return ret;                                                         }
OBJECT_WRAP_3(cmd, k)                                           {                                                                           OSSharedPtr<const OSSymbol> tmpKey = k;                                             if (tmpKey) {                                                       	cmd(tmpKey.get());                                                        }                                                                   }
IOKIT_ENABLE_SHARED_PTR None
APPLE_KEXT_PREFIX "com.apple."
KERNEL_LIB "com.apple.kernel"
PRIVATE_KPI "com.apple.kpi.private"
KERNEL6_LIB "com.apple.kernel.6.0"
KERNEL6_VERSION "7.9.9"
KERNEL_LIB_PREFIX "com.apple.kernel."
KPI_LIB_PREFIX "com.apple.kpi."
STRING_HAS_PREFIX(s, p)      (strncmp((s), (p), strlen(p)) == 0)
_kOSKextExecutableKey "_OSKextExecutable"
_kOSKextMkextExecutableReferenceKey "_OSKextMkextExecutableReference"
_kOSKextExecutableExternalDataKey "_OSKextExecutableExternalData"
OS_LOG_HDR_VERSION 1
NUM_OS_LOG_SECTIONS 3
OS_LOG_SECT_IDX 0
CSTRING_SECT_IDX 1
ASAN_CSTRING_SECT_IDX 2
super OSObject
BOOTER_KEXT_PREFIX "Driver-"
ARCH_SEPARATOR_CHAR '_'
VTRESET "\033[0m"
VTBOLD "\033[1m"
VTUNDER "\033[4m"
VTRED "\033[31m"
VTGREEN "\033[32m"
VTYELLOW "\033[33m"
VTBLUE "\033[34m"
VTMAGENTA "\033[35m"
VTCYAN "\033[36m"
IOKIT_ENABLE_SHARED_PTR None
super OSObject
IOKIT_ENABLE_SHARED_PTR None
super OSCollection
EXT_CAST(obj) reinterpret_cast<OSObject *>(const_cast<OSMetaClassBase *>(obj))
ORDER(obj1, obj2)     (ordering ? ((*ordering)( (const OSObject *) obj1, (const OSObject *) obj2, orderingRef)) : 0)
OSRuntimeLog(kext, flags, format, args ...)                do {                                                      	if (gKernelCPPInitialized) {                          	    OSKextLog((kext), (flags), (format), ## args);  	} else {                                              	    printf((format), ## args);                        	}                                                         } while (0)
IOKIT_ENABLE_SHARED_PTR None
super OSObject
setAtIndex(v, idx, o)                                                  	ok = idx < v##Capacity;                                                	if (!ok && v##Capacity < v##CapacityMax) {                             	    uint32_t ncap = v##Capacity + 64;                                  	    typeof(v##Array) nbuf = kreallocp_type_container(OSObject *,       	        v##Array, v##Capacity, &ncap, Z_WAITOK_ZERO);                  	    if (nbuf) {                                                        	        ok = true;                                                     	        v##Array    = nbuf;                                            	        v##Capacity = ncap;                                            	    }                                                                  	}                                                                      	if (ok) v##Array[idx] = o
IOKIT_ENABLE_SHARED_PTR None
super OSCollection
EXT_CAST(obj) reinterpret_cast<OSObject *>(const_cast<OSMetaClassBase *>(obj))
IOKIT_ENABLE_SHARED_PTR None
super OSObject
IOKIT_ENABLE_SHARED_PTR None
super OSString
YYBISON 1
YYBISON_VERSION "2.3"
YYSKELETON_NAME "yacc.c"
YYPURE 0
YYLSP_NEEDED 0
yyparse OSUnserializeparse
yylex OSUnserializelex
yyerror OSUnserializeerror
yylval OSUnserializelval
yychar OSUnserializechar
yydebug OSUnserializedebug
yynerrs OSUnserializenerrs
NUMBER 258
STRING 259
DATA 260
BOOLEAN 261
SYNTAX_ERROR 262
YYSTYPE object_t *
malloc(size) malloc_impl(size)
malloc_type(type) kalloc_type(type, Z_SET_NOTEARLY)
free(addr) free_impl(addr)
free_type(type, addr)  kfree_type(type, addr)
realloc(addr, osize, nsize) realloc_impl(addr, osize, nsize)
YYFINAL 30
YYLAST 80
YYNTOKENS 19
YYNNTS 13
YYNRULES 28
YYNSTATES 43
YYUNDEFTOK 2
YYMAXUTOK 262
YYPACT_NINF -14
YYTABLE_NINF -1
YYEOF 0
YYACCEPT goto yyacceptlab
YYABORT goto yyabortlab
YYERROR goto yyerrorlab
YYFAIL goto yyerrlab
YYBACKUP(Token, Value)                                  do                                                                if (yychar == YYEMPTY && yylen == 1)                              {                                                                 yychar = (Token);                                               yylval = (Value);                                               yytoken = YYTRANSLATE (yychar);                                 YYPOPSTACK (1);                                                 goto yybackup;                                                }                                                             else                                                              {                                                                 yyerror (YY_("syntax error: cannot back up"));       YYERROR;                                                      }                                                           while (YYID (0))
YYTERROR 1
YYERRCODE 256
YYRHSLOC(Rhs, K) ((Rhs)[K])
OSDATA_ALLOC_SIZE 4096
IOKIT_ENABLE_SHARED_PTR None
PRIORITY_QUEUE_MAKE_IMPL(pqueue_t, queue_t, entry_t)                                                                                                    using pqueue_t = pqueue<queue_t, entry_t>;                                                                                                                      extern "C" {                                                                                                                                                    __pqueue_overloadable void                                                      _priority_queue_destroy(queue_t que, uintptr_t offset, void (^cb)(void *e))     {                                                                               	pqueue_t::destroy(que, offset, cb);                                     }                                                                                                                                                               __pqueue_overloadable extern bool                                               priority_queue_insert(queue_t que, entry_t elt)                                 {                                                                               	return pqueue_t::insert(que, elt);                                      }                                                                                                                                                               __pqueue_overloadable extern entry_t                                            _priority_queue_remove_root(queue_t que)                                        {                                                                               	return pqueue_t::remove_root(que, que->pq_root);                        }                                                                                                                                                               __pqueue_overloadable extern bool                                               priority_queue_remove(queue_t que, entry_t elt)                                 {                                                                               	return pqueue_t::remove(que, elt);                                      }                                                                                                                                                               __pqueue_overloadable extern bool                                               priority_queue_entry_decreased(queue_t que, entry_t elt)                        {                                                                               	return pqueue_t::entry_decreased(que, elt);                             }                                                                                                                                                               __pqueue_overloadable extern bool                                               priority_queue_entry_increased(queue_t que, entry_t elt)                        {                                                                               	return pqueue_t::entry_increased(que, elt);                             }                                                                                                                                                               }
IOKIT_ENABLE_SHARED_PTR None
__FIREHOSE_CHUNK_PRIVATE__ None
FIREHOSE_CHUNK_SIZE 4096ul
FIREHOSE_CHUNK_POS_USABLE_FOR_STREAM(pos, stream) 	        ((((pos).fcp_pos >> 48) & 0x1ff) == (uint16_t)stream)
__FIREHOSE_TYPES_PRIVATE__ None
FIREHOSE_ACTIVITY_ID_FLAGS_SHIFT 56
FIREHOSE_ACTIVITY_ID_MERGE_FLAGS(aid, flags) (	        ((firehose_activity_id_t)(aid)) | 	        ((firehose_activity_id_t)(flags) << FIREHOSE_ACTIVITY_ID_FLAGS_SHIFT))
FIREHOSE_TRACEPOINT_PC_DYNAMIC_BIT 0x80000000
FIREHOSE_TRACEPOINT_PC_KERNEL_MASK 0xffff000000000000
__FIREHOSE_IOCTL_PRIVATE__ None
LOGFLUSHED _IOW('t', 81, firehose_push_reply_t)
LOGREGISTER _IOR('t', 80, int)
LOGBUFFERMAP _IOR('t', 79, firehose_buffer_map_info_t)
__FIREHOSE_FIREHOSE_PRIVATE__ None
FIREHOSE_SPI_VERSION 20180416
__FIREHOSE_ACTIVITY__ None
FIREHOSE_TRACE_ID_MAKE(ns, type, flags, code) 	(((firehose_tracepoint_id_u){ .ftid = { 	        ._namespace = ns, 	        ._type = type, 	        ._flags = flags, 	        ._code = code, 	} }).ftid_value)
FIREHOSE_TRACE_ID_SET_NS(tid, ns) 	((tid).ftid._namespace = firehose_tracepoint_namespace_##ns)
FIREHOSE_TRACE_ID_SET_TYPE(tid, ns, type) 	((tid).ftid._type = _firehose_tracepoint_type_##ns##_##type)
FIREHOSE_TRACE_ID_SET_PC_STYLE(tid, flag) ({ 	        firehose_tracepoint_id_u _tmp_tid = (tid); 	        _tmp_tid.ftid._flags &= ~_firehose_tracepoint_flags_pc_style_mask; 	        _tmp_tid.ftid._flags |= _firehose_tracepoint_flags_pc_style_##flag; })
FIREHOSE_TRACE_ID_HAS_FLAG(tid, ns, flag) 	((tid).ftid._flags & _firehose_tracepoint_flags_##ns##_##flag)
FIREHOSE_TRACE_ID_SET_FLAG(tid, ns, flag) 	((void)((tid).ftid._flags |= _firehose_tracepoint_flags_##ns##_##flag))
FIREHOSE_TRACE_ID_CLEAR_FLAG(tid, ns, flag) 	((void)((tid).ftid._flags &= ~_firehose_tracepoint_flags_##ns##_##flag))
FIREHOSE_TRACE_ID_SET_CODE(tid, code) 	((tid).ftid._code = code)
FIREHOSE_LOSS_COUNT_WIDTH 6
ATOMIC_DEBUG DEBUG
ALIGN_TEST(p, t) do{if((uintptr_t)p&(sizeof(t)-1)) panic("Unaligned atomic pointer %p",p);}while(0)
DEBUG_ASSERT_COMPONENT_NAME_STRING "kxld"
__KXLD_KERNEL_UNUSED __unused
DEBUG_ASSERT_COMPONENT_NAME_STRING "kxld"
_KXLD_ARRAY_H_ None
kCopyrightToken "Copyright  "
kRightsToken " Apple Inc. All rights reserved."
kYearLen 5
kYearRangeLen 10
_KXLD_DEMANGLE_H_ None
DEBUG_ASSERT_COMPONENT_NAME_STRING "kxld"
RESIZE_NUMER 7
RESIZE_DENOM 10
DEFAULT_DICT_SIZE 89
_KXLD_DICT_H_ None
DEBUG_ASSERT_COMPONENT_NAME_STRING "kxld"
kOSMetaClassVTableName "__ZTV11OSMetaClass"
_KXLD_KEXT_H_ None
DEBUG_ASSERT_COMPONENT_NAME_STRING "kxld"
_KXLD_OBJECT_H_ None
DEBUG_ASSERT_COMPONENT_NAME_STRING "kxld"
HADISP 0x00010000
BR14_LIMIT 0x00008000
BR24_LIMIT 0x02000000
FLIP_PREDICT_BIT(x) x ^= 0x00200000
SIGN_EXTEND(x, n) (((x) ^ SIGN_EXTEND_MASK(n)) - SIGN_EXTEND_MASK(n))
BR14_NBITS_DISPLACEMENT 16
BR24_NBITS_DISPLACEMENT 26
X86_64_RIP_RELATIVE_LIMIT 0x80000000UL
_KXLD_RELOC_H None
DEBUG_ASSERT_COMPONENT_NAME_STRING "kxld"
_KXLD_SECT_H_ None
DEBUG_ASSERT_COMPONENT_NAME_STRING "kxld"
MAX_SEGS 20
_KXLD_SEG_H_ None
DEBUG_ASSERT_COMPONENT_NAME_STRING "kxld"
_KXLD_SPLITINFOLC_H_ None
DEBUG_ASSERT_COMPONENT_NAME_STRING "kxld"
_KXLD_SRCVERSION_H_ None
DEBUG_ASSERT_COMPONENT_NAME_STRING "kxld"
CXX_PREFIX "__Z"
VTABLE_PREFIX CXX_PREFIX "TV"
OSOBJ_PREFIX CXX_PREFIX "N"
RESERVED_TOKEN "_RESERVED"
METACLASS_TOKEN "10gMetaClassE"
SUPER_METACLASS_POINTER_TOKEN "10superClassE"
METACLASS_VTABLE_PREFIX VTABLE_PREFIX "N"
METACLASS_VTABLE_SUFFIX "9MetaClassE"
CXX_PURE_VIRTUAL "___cxa_pure_virtual"
FINAL_CLASS_TOKEN "14__OSFinalClassEv"
_KXLD_SYMBOL_H_ None
DEBUG_ASSERT_COMPONENT_NAME_STRING "kxld"
_KXLD_SYMTAB_H_ None
DEBUG_ASSERT_COMPONENT_NAME_STRING "kxld"
KALLOC_MAX 16 * 1024
_KXLD_UTIL_H_ None
streq(str1, str2) (((str1) && (str2)) ? !strcmp((str1), (str2)) : 0)
streq_safe(str1, str2, len) (((str1) && (str2)) ?     !strncmp((str1), (str2), (len)) : 0)
const_array_len(array) sizeof(array) / sizeof(*array)
DECL_TIMER() struct timeval start, end;
START_TIMER() gettimeofday(&start, NULL);
END_TIMER() gettimeofday(&end, NULL);
PRINT_TIMER(msg) kxld_log("%s: %ds, %dus\n", (msg), 	(end.tv_sec - start.tv_sec), (end.tv_usec - start.tv_usec));
KXLD_MAX_NAME_LEN 256
KXLD_SEG_GOT "__DATA"
KXLD_SECT_GOT "__kxld_got"
KXLD_KMOD_INFO_SYMBOL "_kmod_info"
KXLD_WEAK_TEST_SYMBOL "_gOSKextUnresolved"
KXLD_OPERATOR_NEW_SYMBOL "__Znwm"
KXLD_OPERATOR_NEW_ARRAY_SYMBOL "__Znam"
KXLD_OPERATOR_DELETE_SYMBOL "__ZdlPv"
KXLD_OPERATOR_DELETE_ARRAY_SYMBOL "__ZdaPv"
kKxldLogArchNotSupported "The target architecture (cputype 0x%x) is not supported by kxld."
kKxldLogArchNotFound "The kext does not contain a fat slice for the target architecture."
kKxldLogFiletypeNotSupported "The Mach-O filetype 0x%x is not supported on the target architecture."
kKxldLogTruncatedMachO "The Mach-O file has been truncated. Make sure the Mach-O header structures are correct."
kKxldLogMalformedMachO "The Mach-O file is malformed: "
kKxldLogMalformedVTable "The vtable '%s' is malformed. Make sure your kext has been built against the correct headers."
kKxldLogMissingVtable "Cannot find the vtable '%s' for class '%s'. This vtable symbol is required for binary compatibility, and it may have been stripped."
kKxldLogDirectPureVirtualCall "This kext calls a pure virtual function. Make sure your kext's OSObject-derived classes implement all pure virtual functions."
kKxldLogParentOutOfDate "The super class vtable '%s' for vtable '%s' is out of date. Make sure your kext has been built against the correct headers."
kKxldLogNoKmodInfo "The kext is missing its kmod_info structure."
kKxldLogRelocationOverflow "A relocation entry has overflowed. The kext may be too far from one "     "of its dependencies. Check your kext's load address."
kKxldLogRelocatingPatchedSym "Warning: relocation failed because some class in this kext "        "didn't use the OSDeclareDefaultStructors and OSDefineMetaClassAndStructors, "      "or didn't export all vtable symbols, so it still "      "references %s, which has been patched with another symbol for binary compatibility. "          "Please make sure all classes that inherit from OSObject use these macros."
DEBUG_ASSERT_COMPONENT_NAME_STRING "kxld"
_KXLD_UUID_H_ None
DEBUG_ASSERT_COMPONENT_NAME_STRING "kxld"
_KXLD_VERSIONMIN_H_ None
MACH_ASSERT 1
DEBUG_ASSERT_COMPONENT_NAME_STRING "kxld"
VTABLE_ENTRY_SIZE_32 4
VTABLE_HEADER_LEN_32 2
VTABLE_ENTRY_SIZE_64 8
VTABLE_HEADER_LEN_64 2
_KXLD_VTABLE_H_ None
os_assert(_x) assert(_x)
__ERRNO_H__ None
__STDIO_H__ None
__STDLIB_H__ None
_Block_H_ None
Block_release(...) _Block_release((const void *)(__VA_ARGS__))
_BLOCK_PRIVATE_H_ None
_Block_descriptor_ptrauth_discriminator 0xC0BB
BLOCK_DESCRIPTOR_1 1
BLOCK_DESCRIPTOR_2 1
BLOCK_DESCRIPTOR_3 1
_LIBKERN_CRC_H_ None
_KERNEL_MACH_HEADER_ None
MH_MAGIC_KERNEL MH_MAGIC_64
LC_SEGMENT_KERNEL LC_SEGMENT_64
SECT_MODINITFUNC "__mod_init_func"
SECT_MODTERMFUNC "__mod_term_func"
_KEXT_PANIC_REPORT_H_ None
_LIBKERN_KEXT_REQUEST_KEYS_H None
kKextRequestPredicateKey "Kext Request Predicate"
kKextRequestArgumentsKey "Kext Request Arguments"
kKextRequestPredicateGetLoaded "Get Loaded Kext Info"
kKextRequestPredicateGetLoadedByUUID "Get Loaded Kext Info By UUID"
kKextRequestPredicateGetUUIDByAddress "Get Kext UUID by Address"
kKextRequestPredicateGetAllLoadRequests "Get All Load Requests"
kKextRequestPredicateGetKextsInCollection "Get Kexts in Collection"
kKextRequestPredicateGetDexts "Get Dexts"
kKextRequestPredicateGetKernelRequests "Get Kernel Requests"
kKextRequestPredicateLoad "Load"
kKextRequestPredicateLoadFromKC "LoadFromKC"
kKextRequestPredicateLoadCodeless "LoadCodelessKext"
kKextRequestPredicateStart "Start"
kKextRequestPredicateStop "Stop"
kKextRequestPredicateUnload "Unload"
kKextRequestPredicateLoadFileSetKC "loadfilesetkc"
kKextRequestPredicateMissingAuxKCBundles "MissingAuxKCBundles"
kKextRequestPredicateAuxKCBundleAvailable "AuxKCBundleAvailable"
kKextRequestPredicateDaemonReady "DaemonReady"
kKextRequestPredicateSendResource "Send Resource"
kKextRequestPredicateRequestLoad "Kext Load Request"
kKextRequestPredicateLoadNotification "Kext Load Notification"
kKextRequestPredicateUnloadNotification "Kext Unload Notification"
kKextRequestPredicateRequestPrelink "Kext Prelinked Kernel Request"
kKextRequestPredicateRequestResource "Kext Resource Request"
kKextRequestPredicateRequestDaemonExit "IOKit Daemon Exit"
kKextRequestPredicateRequestKextdExit kKextRequestPredicateRequestDaemonExit
kKextRequestPredicateRequestDaemonLaunch "Dext Daemon Launch"
kKextRequestPredicateRequestDaemonUpgradeNotification "Dext Daemon Upgrade"
kKextRequestArgumentLoadRequestsKey "Kext Load Requests"
kKextRequestArgumentBundleIdentifierKey "CFBundleIdentifier"
kKextRequestArgumentInfoKeysKey "Kext Request Info Keys"
kKextRequestArgumentResultKey "Kext Request Result Code"
kKextRequestArgumentLookupAddressKey "Kext Request Lookup Address"
kKextRequestArgumentValueKey "Value"
kKextRequestArgumentNameKey "Name"
kKextRequestArgumentFileContentsKey "File Contents"
kKextRequestArgumentDelayAutounloadKey "Delay Autounload"
kKextRequestArgumentStartExcludeKey "Start Exclude Level"
kKextRequestArgumentStartMatchingExcludeKey "Start Matching Exclude Level"
kKextRequestArgumentPersonalityNamesKey "Personality Names"
kKextRequestArgumentCodelessInfoKey "Codeless Kext Info"
kKextRequestArgumentCodelessInfoBundlePathKey "_CodelessKextBundlePath"
kKextRequestArgumentTerminateIOServicesKey "Terminate IOServices"
kKextRequestArgumentDriverExtensionServerTag "Driver Extension Server Tag"
kKextRequestArgumentDriverExtensionServerName "Driver Extension Server Name"
kKextRequestArgumentDriverExtensionReslideSharedCache "DriverKit Reslide Shared Cache"
kKextRequestArgumentDriverUniqueIdentifier kOSBundleDextUniqueIdentifierKey
kKextRequestArgumentMissingBundleIDs "Missing Bundle IDs"
kKextRequestArgumentBundleAvailability "Bundle Availability"
kKextRequestArgumentRequestTagKey "Request Tag"
kKextRequestArgumentCallbackKey "Request Callback"
kKextRequestArgumentContextKey "Context"
kKextRequestStaleKey "Request Stale"
kKextRequestArgumentCheckInToken "Check In Token"
kKextRequestArgumentPageableKCFilename "PageableKCName"
kKextRequestArgumentAuxKCFilename "AuxKCName"
kKextRequestArgumentCodelessPersonalities "Codeless Personalities"
kKextRequestArgumentCollectionTypeKey "Collection Type"
kKextRequestArgumentLoadedStateKey "Loaded State"
_KXLD_H None
_KXLD_TYPES_H None
KXLD_USER_OR_STRICT_PATCHING 1
KXLD_USER_OR_BUNDLE 1
KXLD_USER_OR_GOT 0
LIBKERN_LOCKS_H None
_MKEXT_H_ 1
MKEXT_MAGIC 0x4D4B5854
MKEXT_SIGN 0x4D4F5358
MKEXT_EXTN ".mkext"
MKEXT_HEADER_CORE uint32_t      magic;           uint32_t      signature;       uint32_t      length;          uint32_t      adler32;         uint32_t      version;         uint32_t      numkexts;        cpu_type_t    cputype;         cpu_subtype_t cpusubtype;
MKEXT_SWAP(num) OSSwapBigToHostInt32((uint32_t)(num))
kMKEXTInfoDictionariesKey "_MKEXTInfoDictionaries"
kMKEXTBundlePathKey "_MKEXTBundlePath"
kMKEXTExecutableRelativePathKey "_MKEXTExecutableRelativePath"
kMKEXTExecutableKey "_MKEXTExecutable"
kMKEXTLoadRequestKey "_MKEXTLoadRequest"
kMKEXTLoadRequestLoadKey "Load Kext"
kMKEXTLoadRequestStartKey "Start Kext"
kMKEXTLoadRequestAddPersonalitiesKey "Add Personalities"
kMKEXTLoadRequestDisableAutounloadKey "Disable Autounload"
MKEXT2_GET_ENTRY_COMPSIZE(ptr) MKEXT_SWAP((ptr)->compressed_size)
MKEXT2_GET_ENTRY_FULLSIZE(ptr) MKEXT_SWAP((ptr)->full_size)
MKEXT2_GET_PLIST(hdr) MKEXT_SWAP(MKEXT2_HDR_CAST(hdr)->plist_offset)
MKEXT2_GET_PLIST_COMPSIZE(hdr) MKEXT_SWAP(MKEXT2_HDR_CAST(hdr)->plist_compressed_size)
MKEXT2_GET_PLIST_FULLSIZE(hdr) MKEXT_SWAP(MKEXT2_HDR_CAST(hdr)->plist_full_size)
MKEXT1_GET_KEXT(hdr, i)          ((mkext_kext *)&(MKEXT1_HDR_CAST(hdr)->kext[(i)]))
MKEXT1_GET_KEXT_PLIST(hdr, i)    (MKEXT1_ENTRY_CAST(&(MKEXT1_GET_KEXT((hdr), (i))->plist)))
MKEXT1_GET_KEXT_EXEC(hdr, i)     (MKEXT1_ENTRY_CAST(&(MKEXT1_GET_KEXT((hdr), (i))->module)
_OS_OSATOMIC_H None
__SAFE_CAST_PTR(type, var) 	({ _Static_assert(sizeof(*(var)) == sizeof(*(type)NULL), "size mismatch"); ((type)(var)); })
OSCompareAndSwap64(a, b, c) 	(OSCompareAndSwap64(a, b, __SAFE_CAST_PTR(volatile UInt64*,c)))
OSAddAtomic64(a, b) 	(OSAddAtomic64(a, __SAFE_CAST_PTR(volatile SInt64*,b)))
OSAddAtomicLong(a, b) 	(OSAddAtomicLong(a, __SAFE_CAST_PTR(volatile long*,b)))
OSCompareAndSwap8(a, b, c) 	(OSCompareAndSwap8(a, b, __SAFE_CAST_PTR(volatile UInt8*,c)))
OSCompareAndSwap16(a, b, c) 	(OSCompareAndSwap16(a, b, __SAFE_CAST_PTR(volatile UInt16*,c)))
OSCompareAndSwap(a, b, c) 	(OSCompareAndSwap(a, b, __SAFE_CAST_PTR(volatile UInt32*,c)))
OSCompareAndSwapPtr(a, b, c) 	(OSCompareAndSwapPtr(a, b, __SAFE_CAST_PTR(void * volatile *,c)))
OSAddAtomic(a, b) 	(OSAddAtomic(a, __SAFE_CAST_PTR(volatile SInt32*,b)))
OSBitAndAtomic(a, b) 	(OSBitAndAtomic(a, __SAFE_CAST_PTR(volatile UInt32*,b)))
OSBitOrAtomic(a, b) 	(OSBitOrAtomic(a, __SAFE_CAST_PTR(volatile UInt32*,b)))
OSBitXorAtomic(a, b) 	(OSBitXorAtomic(a, __SAFE_CAST_PTR(volatile UInt32*,b)))
OS_SPINLOCK_INIT 0
_OS_OSBASE_H None
CMP_ABSOLUTETIME(t1, t2)                                	(AbsoluteTime_to_scalar(t1) >                           	        AbsoluteTime_to_scalar(t2)? (int)+1 :   	 (AbsoluteTime_to_scalar(t1) <                          	        AbsoluteTime_to_scalar(t2)? (int)-1 : 0))
ADD_ABSOLUTETIME(t1, t2)                                	(AbsoluteTime_to_scalar(t1) +=                          	                        AbsoluteTime_to_scalar(t2))
SUB_ABSOLUTETIME(t1, t2)                                	(AbsoluteTime_to_scalar(t1) -=                          	                        AbsoluteTime_to_scalar(t2))
ADD_ABSOLUTETIME_TICKS(t1, ticks)               	(AbsoluteTime_to_scalar(t1) +=                          	                                        (int32_t)(ticks))
_OS_OSBYTEORDER_H None
OSSwapConstInt16(x) __DARWIN_OSSwapConstInt16(x)
OSSwapConstInt32(x) __DARWIN_OSSwapConstInt32(x)
OSSwapConstInt64(x) __DARWIN_OSSwapConstInt64(x)
OSSwapInt16(x) __DARWIN_OSSwapInt16(x)
OSSwapInt32(x) __DARWIN_OSSwapInt32(x)
OSSwapInt64(x) __DARWIN_OSSwapInt64(x)
OSReadBigInt(x, y)              OSReadBigInt32(x, y)
OSWriteBigInt(x, y, z)          OSWriteBigInt32(x, y, z)
OSSwapBigToHostInt(x) OSSwapBigToHostInt32(x)
OSSwapHostToBigInt(x) OSSwapHostToBigInt32(x)
OSReadLittleInt(x, y)           OSReadLittleInt32(x, y)
OSWriteLittleInt(x, y, z)       OSWriteLittleInt32(x, y, z)
OSSwapHostToLittleInt(x) OSSwapHostToLittleInt32(x)
OSSwapLittleToHostInt(x) OSSwapLittleToHostInt32(x)
_LIBKERN_OSCROSSENDIAN_H None
IF_ROSETTA() if (__builtin_expect(_OSRosettaCheck(), 0) )
ROSETTA_ONLY(exprs) do {                                IF_ROSETTA() {              	exprs                       }                           } while(0)
_OS_OSDEBBUG_H None
_LIBKERN_OSKEXTLIB_H None
sub_libkern_kext err_sub(2)
kOSKextReturnInternalError libkern_kext_err(0x1)
kOSKextReturnNoMemory libkern_kext_err(0x2)
kOSKextReturnNoResources libkern_kext_err(0x3)
kOSKextReturnNotPrivileged libkern_kext_err(0x4)
kOSKextReturnInvalidArgument libkern_kext_err(0x5)
kOSKextReturnNotFound libkern_kext_err(0x6)
kOSKextReturnBadData libkern_kext_err(0x7)
kOSKextReturnSerialization libkern_kext_err(0x8)
kOSKextReturnUnsupported libkern_kext_err(0x9)
kOSKextReturnDisabled libkern_kext_err(0xa)
kOSKextReturnNotAKext libkern_kext_err(0xb)
kOSKextReturnValidation libkern_kext_err(0xc)
kOSKextReturnAuthentication libkern_kext_err(0xd)
kOSKextReturnDependencies libkern_kext_err(0xe)
kOSKextReturnArchNotFound libkern_kext_err(0xf)
kOSKextReturnCache libkern_kext_err(0x10)
kOSKextReturnDeferred libkern_kext_err(0x11)
kOSKextReturnBootLevel libkern_kext_err(0x12)
kOSKextReturnNotLoadable libkern_kext_err(0x13)
kOSKextReturnLoadedVersionDiffers libkern_kext_err(0x14)
kOSKextReturnDependencyLoadError libkern_kext_err(0x15)
kOSKextReturnLinkError libkern_kext_err(0x16)
kOSKextReturnStartStopError libkern_kext_err(0x17)
kOSKextReturnInUse libkern_kext_err(0x18)
kOSKextReturnTimeout libkern_kext_err(0x19)
kOSKextReturnStopping libkern_kext_err(0x1a)
kOSKextReturnSystemPolicy libkern_kext_err(0x1b)
kOSKextReturnKCLoadFailure libkern_kext_err(0x1c)
kOSKextReturnKCLoadFailureSystemKC libkern_kext_err(0x1d)
kOSKextReturnKCLoadFailureAuxKC libkern_kext_err(0x1e)
kCFBundleIdentifierKey "CFBundleIdentifier"
kCFBundleIdentifierKernelKey "CFBundleIdentifierKernel"
kCFBundleVersionKey "CFBundleVersion"
kCFBundleNameKey "CFBundleName"
kCFBundleExecutableKey "CFBundleExecutable"
kCFBundlePackageTypeKey "CFBundlePackageType"
kCFBundleDriverKitUUIDKey "CFBundleDriverKitUUID"
kCFBundleDriverKitExecutableKey "CFBundleUEXTExecutable"
kOSBundleCompatibleVersionKey "OSBundleCompatibleVersion"
kOSBundleEnableKextLoggingKey "OSBundleEnableKextLogging"
kOSBundleIsInterfaceKey "OSBundleIsInterface"
kOSBundleLibrariesKey "OSBundleLibraries"
kOSBundleRequiredKey "OSBundleRequired"
kOSBundleRequireExplicitLoadKey "OSBundleRequireExplicitLoad"
kOSBundleAllowUserLoadKey "OSBundleAllowUserLoad"
kOSBundleAllowUserTerminateKey "OSBundleAllowUserTerminate"
kOSKernelResourceKey "OSKernelResource"
kOSKextVariantOverrideKey "OSKextVariantOverride"
kIOKitPersonalitiesKey "IOKitPersonalities"
kIOPersonalityPublisherKey "IOPersonalityPublisher"
kOSMutableSegmentCopy "OSMutableSegmentCopy"
kOSBundleDebugLevelKey "OSBundleDebugLevel"
kOSBundleSharedExecutableIdentifierKey "OSBundleSharedExecutableIdentifier"
kOSKextKernelIdentifier "__kernel__"
kOSKextBundlePackageTypeKext "KEXT"
kOSKextBundlePackageTypeDriverKit "DEXT"
kOSBundleRequiredRoot "Root"
kOSBundleRequiredLocalRoot "Local-Root"
kOSBundleRequiredNetworkRoot "Network-Root"
kOSBundleRequiredSafeBoot "Safe Boot"
kOSBundleRequiredConsole "Console"
kOSBundleRequiredDriverKit "DriverKit"
_LIBKERN_OSKEXTLIBPRIVATE_H None
kIOCatalogManagementEntitlement "com.apple.private.security.iocatalog-management"
kOSKextCollectionManagementEntitlement "com.apple.private.security.kext-collection-management"
kOSKextOnlyBootKCManagementEntitlement "com.apple.private.security.only-bootkc-management"
kIOKitDaemonName "kernelmanagerd"
kOSBundleHelperKey "OSBundleHelper"
kOSBundleDeveloperOnlyKey "OSBundleDeveloperOnly"
kOSBundleRamDiskOnlyKey "OSBundleRamDiskOnly"
kAppleSecurityExtensionKey "AppleSecurityExtension"
kAppleKernelExternalComponentKey "AppleKernelExternalComponent"
kOSKextInfoPlistDigestKey "_InfoPlistDigest"
kOSKextBundleCollectionTypeKey "_BundleCollectionType"
kOSKextAuxKCAvailabilityKey "_AuxKCAvailability"
kOSKernelCPUTypeKey "OSKernelCPUType"
kOSKernelCPUSubtypeKey "OSKernelCPUSubtype"
kOSStartupMkextCRC "OSStartupMkextCRC"
kOSPrelinkKextCountKey "OSPrelinkKextCount"
kOSPrelinkPersonalityCountKey "OSPrelinkPersonalityCount"
kOSBundleMachOHeadersKey "OSBundleMachOHeaders"
kOSBundleLogStringsKey "OSBundleLogStrings"
kOSBundleCPUTypeKey "OSBundleCPUType"
kOSBundleCPUSubtypeKey "OSBundleCPUSubtype"
kOSBundlePathKey "OSBundlePath"
kOSBundleExecutablePathKey "OSBundleExecutablePath"
kOSBundleUUIDKey "OSBundleUUID"
kOSBundleTextUUIDKey "OSBundleTextUUID"
kOSBundleStartedKey "OSBundleStarted"
kOSBundlePrelinkedKey "OSBundlePrelinked"
kOSBundleLoadTagKey "OSBundleLoadTag"
kOSBundleLoadAddressKey "OSBundleLoadAddress"
kOSBundleLoadSizeKey "OSBundleLoadSize"
kOSBundleExecLoadAddressKey "OSBundleExecLoadAddress"
kOSBundleExecLoadSizeKey "OSBundleExecLoadSize"
kOSBundleWiredSizeKey "OSBundleWiredSize"
kOSBundleDependenciesKey "OSBundleDependencies"
kOSBundleRetainCountKey "OSBundleRetainCount"
kOSBundleCacheLoadAddressKey "OSBundleCacheLoadAddress"
kOSBundleKextsInKernelTextKey "OSBundleKextsInKernelText"
kOSBundleAllPrelinkedKey "OSBundleAllPrelinked"
kOSBundleDextStateKey "OSBundleDextState"
kOSBundleDextStateActiveKey "OSBundleDextStateActive"
kOSBundleDextStateActiveLoadedKey "OSBundleDextStateActiveLoaded"
kOSBundleDextStateActiveUnloadedKey "OSBundleDextStateActiveUnloaded"
kOSBundleDextStatePendingUpgradeKey "OSBundleDextStatePendingUpgrade"
kOSBundleClassesKey "OSBundleClasses"
kOSBundleDextUniqueIdentifierKey "kOSBundleDextUniqueIdentifier"
kOSMetaClassNameKey "OSMetaClassName"
kOSMetaClassSuperclassNameKey "OSMetaClassSuperclassName"
kOSMetaClassTrackingCountKey "OSMetaClassTrackingCount"
kKCTypePrimary "Primary"
kKCTypeSystem "System"
kKCTypeAuxiliary "Auxiliary"
kKCTypeCodeless "Codeless"
kKCTypeAny "Any"
kOSKextReceiptQueried "OSKextReceiptQueried"
kOSKextLoadedKextSummaryVersion 2
LIBKERN_OSMALLOC_h None
OSMallocDeprecatedMsg(msg) __deprecated_msg(msg)
__LIBKERN_OSRETURN_H None
sys_libkern err_system(0x37)
sub_libkern_common err_sub(0)
sub_libkern_metaclass err_sub(1)
sub_libkern_reserved err_sub(-1)
libkern_common_err(return )    (sys_libkern|sub_libkern_common|(return))
libkern_metaclass_err(return ) (sys_libkern|sub_libkern_metaclass|(return))
kOSReturnSuccess KERN_SUCCESS
kOSReturnError libkern_common_err(1)
kOSMetaClassInternal libkern_metaclass_err(1)
kOSMetaClassHasInstances libkern_metaclass_err(2)
kOSMetaClassNoInit libkern_metaclass_err(3)
kOSMetaClassNoTempData libkern_metaclass_err(4)
kOSMetaClassNoDicts libkern_metaclass_err(5)
kOSMetaClassNoKModSet libkern_metaclass_err(6)
kOSMetaClassNoInsKModSet libkern_metaclass_err(7)
kOSMetaClassNoSuper libkern_metaclass_err(8)
kOSMetaClassInstNoSuper libkern_metaclass_err(9)
kOSMetaClassDuplicateClass libkern_metaclass_err(10)
kOSMetaClassNoKext libkern_metaclass_err(11)
_OS_OSSERIALIZEBINARY_H None
kOSSerializeBinarySignature "\323\0\0"
kOSSerializeIndexedBinarySignature 0x000000D4
_OS_OSTYPES_H None
OSTYPES_K64_REV 2
ABSOLUTETIME_SCALAR_TYPE 1
_PRELINK_H_ None
kPrelinkTextSegment "__PRELINK_TEXT"
kPrelinkTextSection "__text"
kPrelinkDataSegment "__PRELINK_DATA"
kPrelinkDataSection "__data"
kPrelinkInfoSegment "__PRELINK_INFO"
kPrelinkInfoSection "__info"
kBuiltinInfoSection "__kmod_info"
kBuiltinStartSection "__kmod_start"
kReceiptInfoSegment "__RECEIPT_INFO"
kAuxKCReceiptSection "__aux_kc_receipt"
kBuiltinInitSection "__kmod_init"
kBuiltinTermSection "__kmod_term"
kPrelinkBundlePathKey "_PrelinkBundlePath"
kPrelinkExecutableRelativePathKey "_PrelinkExecutableRelativePath"
kPrelinkExecutableLoadKey "_PrelinkExecutableLoadAddr"
kPrelinkExecutableSourceKey "_PrelinkExecutableSourceAddr"
kPrelinkExecutableSizeKey "_PrelinkExecutableSize"
kPrelinkInfoDictionaryKey "_PrelinkInfoDictionary"
kPrelinkInterfaceUUIDKey "_PrelinkInterfaceUUID"
kPrelinkKmodInfoKey "_PrelinkKmodInfo"
kPrelinkLinkStateKey "_PrelinkLinkState"
kPrelinkLinkStateSizeKey "_PrelinkLinkStateSize"
kPrelinkLinkKASLROffsetsKey "_PrelinkLinkKASLROffsets"
kPrelinkInfoKCIDKey "_PrelinkKCID"
kPrelinkInfoBootKCIDKey "_BootKCID"
kPrelinkInfoPageableKCIDKey "_PageableKCID"
kKCBranchStubs "__BRANCH_STUBS"
kKCBranchGots "__BRANCH_GOTS"
__PTRAUTH_UTILS_H None
PTRAUTH_ADDR_DIVERSIFY 0x0001
PTRAUTH_NON_NULL 0x0002
_SECTION_KEYWORDS_H None
__PLACE_IN_SECTION(__segment__section) __attribute__((used, section(__segment__section)))
__SEGMENT_START_SYM(seg) asm("segment$start$" seg)
__SEGMENT_END_SYM(seg) asm("segment$end$" seg)
__SECTION_START_SYM(seg, sect) asm("section$start$" seg "$" sect)
__SECTION_END_SYM(seg, sect)   asm("section$end$" seg "$" sect)
SECURITY_SEGMENT_NAME "__DATA"
SECURITY_SECTION_NAME "__const"
SECURITY_SEGMENT_SECTION_NAME "__DATA,__const"
__security_const_early const
__security_const_late __attribute__((section(SECURITY_SEGMENT_SECTION_NAME)))
__security_read_write None
MARK_AS_HIBERNATE_TEXT None
MARK_AS_HIBERNATE_DATA None
MARK_AS_HIBERNATE_DATA_CONST_LATE None
SECURITY_READ_ONLY_EARLY(_t) _t __security_const_early __attribute__((used))
SECURITY_READ_ONLY_LATE(_t) _t __security_const_late  __attribute__((used))
SECURITY_READ_WRITE(_t) _t __security_read_write  __attribute__((used))
_STACK_PROTECTOR_H None
LIBKERN_SYSCTL_H None
_LIBKERN_TREE_H_ None
SPLAY_HEAD(name, type)                                          struct name {                                                           	struct type *sph_root;                    }
SPLAY_INITIALIZER(root) { NULL }
SPLAY_INIT(root) do {                                           	(root)->sph_root = NULL;                                        } while (  0)
SPLAY_ENTRY(type) struct {                                                                	struct type *spe_left;                        	struct type *spe_right;                      }
SPLAY_LEFT(elm, field)          (elm)->field.spe_left
SPLAY_RIGHT(elm, field)         (elm)->field.spe_right
SPLAY_ROTATE_RIGHT(head, tmp, field) do {                       	SPLAY_LEFT((head)->sph_root, field) = SPLAY_RIGHT(tmp, field);  	SPLAY_RIGHT(tmp, field) = (head)->sph_root;                     	(head)->sph_root = tmp;                                         } while (  0)
SPLAY_ROTATE_LEFT(head, tmp, field) do {                        	SPLAY_RIGHT((head)->sph_root, field) = SPLAY_LEFT(tmp, field);  	SPLAY_LEFT(tmp, field) = (head)->sph_root;                      	(head)->sph_root = tmp;                                         } while (  0)
SPLAY_LINKLEFT(head, tmp, field) do {                           	SPLAY_LEFT(tmp, field) = (head)->sph_root;                      	tmp = (head)->sph_root;                                         	(head)->sph_root = SPLAY_LEFT((head)->sph_root, field);         } while (  0)
SPLAY_LINKRIGHT(head, tmp, field) do {                          	SPLAY_RIGHT(tmp, field) = (head)->sph_root;                     	tmp = (head)->sph_root;                                         	(head)->sph_root = SPLAY_RIGHT((head)->sph_root, field);        } while (  0)
SPLAY_ASSEMBLE(head, node, left, right, field) do {             	SPLAY_RIGHT(left, field) = SPLAY_LEFT((head)->sph_root, field); 	SPLAY_LEFT(right, field) = SPLAY_RIGHT((head)->sph_root, field);	SPLAY_LEFT((head)->sph_root, field) = SPLAY_RIGHT(node, field); 	SPLAY_RIGHT((head)->sph_root, field) = SPLAY_LEFT(node, field); } while (  0)
SPLAY_PROTOTYPE(name, type, field, cmp)                         void name##_SPLAY(struct name *, struct type *);                        void name##_SPLAY_MINMAX(struct name *, int);                           struct type *name##_SPLAY_INSERT(struct name *, struct type *);         struct type *name##_SPLAY_REMOVE(struct name *, struct type *);                                                                                                            static __inline struct type *                                           name##_SPLAY_FIND(struct name *head, struct type *elm)                  {                                                                       	if (SPLAY_EMPTY(head))                                          	        return(NULL);                                           	name##_SPLAY(head, elm);                                        	if ((cmp)(elm, (head)->sph_root) == 0)                          	        return (head->sph_root);                                	return (NULL);                                                  }                                                                                                                                               static __inline struct type *                                           name##_SPLAY_NEXT(struct name *head, struct type *elm)                  {                                                                       	name##_SPLAY(head, elm);                                        	if (SPLAY_RIGHT(elm, field) != NULL) {                          	        elm = SPLAY_RIGHT(elm, field);                          	        while (SPLAY_LEFT(elm, field) != NULL) {                	                elm = SPLAY_LEFT(elm, field);                   	        }                                                       	} else                                                          	        elm = NULL;                                             	return (elm);                                                   }                                                                                                                                               static __inline struct type *                                           name##_SPLAY_MIN_MAX(struct name *head, int val)                        {                                                                       	name##_SPLAY_MINMAX(head, val);                                 	return (SPLAY_ROOT(head));                                      }
SPLAY_GENERATE(name, type, field, cmp)                          struct type *                                                           name##_SPLAY_INSERT(struct name *head, struct type *elm)                {                                                                           if (SPLAY_EMPTY(head)) {                                            	    SPLAY_LEFT(elm, field) = SPLAY_RIGHT(elm, field) = NULL;        } else {                                                            	    int __comp;                                                 	    name##_SPLAY(head, elm);                                    	    __comp = (cmp)(elm, (head)->sph_root);                      	    if(__comp < 0) {                                            	            SPLAY_LEFT(elm, field) = SPLAY_LEFT((head)->sph_root, field);	            SPLAY_RIGHT(elm, field) = (head)->sph_root;         	            SPLAY_LEFT((head)->sph_root, field) = NULL;         	    } else if (__comp > 0) {                                    	            SPLAY_RIGHT(elm, field) = SPLAY_RIGHT((head)->sph_root, field);	            SPLAY_LEFT(elm, field) = (head)->sph_root;          	            SPLAY_RIGHT((head)->sph_root, field) = NULL;        	    } else                                                      	            return ((head)->sph_root);                              }                                                                       (head)->sph_root = (elm);                                               return (NULL);                                                      }                                                                                                                                               struct type *                                                           name##_SPLAY_REMOVE(struct name *head, struct type *elm)                {                                                                       	struct type *__tmp;                                             	if (SPLAY_EMPTY(head))                                          	        return (NULL);                                          	name##_SPLAY(head, elm);                                        	if ((cmp)(elm, (head)->sph_root) == 0) {                        	        if (SPLAY_LEFT((head)->sph_root, field) == NULL) {      	                (head)->sph_root = SPLAY_RIGHT((head)->sph_root, field);	        } else {                                                	                __tmp = SPLAY_RIGHT((head)->sph_root, field);   	                (head)->sph_root = SPLAY_LEFT((head)->sph_root, field);	                name##_SPLAY(head, elm);                        	                SPLAY_RIGHT((head)->sph_root, field) = __tmp;   	        }                                                       	        return (elm);                                           	}                                                               	return (NULL);                                                  }                                                                                                                                               void                                                                    name##_SPLAY(struct name *head, struct type *elm)                       {                                                                       	struct type __node, *__left, *__right, *__tmp;                  	int __comp;                                                     	SPLAY_LEFT(&__node, field) = SPLAY_RIGHT(&__node, field) = NULL;	__left = __right = &__node;                                     	while ((__comp = (cmp)(elm, (head)->sph_root)) != 0) {          	        if (__comp < 0) {                                       	                __tmp = SPLAY_LEFT((head)->sph_root, field);    	                if (__tmp == NULL)                              	                        break;                                  	                if ((cmp)(elm, __tmp) < 0){                     	                        SPLAY_ROTATE_RIGHT(head, __tmp, field); 	                        if (SPLAY_LEFT((head)->sph_root, field) == NULL)	                                break;                          	                }                                               	                SPLAY_LINKLEFT(head, __right, field);           	        } else if (__comp > 0) {                                	                __tmp = SPLAY_RIGHT((head)->sph_root, field);   	                if (__tmp == NULL)                              	                        break;                                  	                if ((cmp)(elm, __tmp) > 0){                     	                        SPLAY_ROTATE_LEFT(head, __tmp, field);  	                        if (SPLAY_RIGHT((head)->sph_root, field) == NULL)	                                break;                          	                }                                               	                SPLAY_LINKRIGHT(head, __left, field);           	        }                                                       	}                                                               	SPLAY_ASSEMBLE(head, &__node, __left, __right, field);          }                                                                                                                                                                   static __inline struct type *                                           name##_SPLAY_SEARCH(struct name *head, struct type *elm)                {                                                                       	struct type *__tmp = NULL;                                      	int __comp;                                                                                                                             	__tmp = (head)->sph_root;                                       	while ((__tmp != NULL) && ((__comp = (cmp)(elm, __tmp)) != 0)) { 	        if (__comp < 0) {                                       	                __tmp = SPLAY_LEFT(__tmp, field);               	        } else {                                                	                __tmp = SPLAY_RIGHT(__tmp, field);              	        }                                                       	}                                                               	return __tmp;                                                   }                                                                                                                                                                                                                    void name##_SPLAY_MINMAX(struct name *head, int __comp) {                                                                       	struct type __node, *__left, *__right, *__tmp;                  	SPLAY_LEFT(&__node, field) = SPLAY_RIGHT(&__node, field) = NULL;	__left = __right = &__node;                                     	while (1) {                                                     	        if (__comp < 0) {                                       	                __tmp = SPLAY_LEFT((head)->sph_root, field);    	                if (__tmp == NULL)                              	                        break;                                  	                if (__comp < 0){                                	                        SPLAY_ROTATE_RIGHT(head, __tmp, field); 	                        if (SPLAY_LEFT((head)->sph_root, field) == NULL)	                                break;                          	                }                                               	                SPLAY_LINKLEFT(head, __right, field);           	        } else if (__comp > 0) {                                	                __tmp = SPLAY_RIGHT((head)->sph_root, field);   	                if (__tmp == NULL)                              	                        break;                                  	                if (__comp > 0) {                               	                        SPLAY_ROTATE_LEFT(head, __tmp, field);  	                        if (SPLAY_RIGHT((head)->sph_root, field) == NULL)	                                break;                          	                }                                               	                SPLAY_LINKRIGHT(head, __left, field);           	        }                                                       	}                                                               	SPLAY_ASSEMBLE(head, &__node, __left, __right, field);          }
SPLAY_NEGINF -1
SPLAY_INF 1
SPLAY_INSERT(name, x, y)        name##_SPLAY_INSERT(x, y)
SPLAY_REMOVE(name, x, y)        name##_SPLAY_REMOVE(x, y)
SPLAY_FIND(name, x, y)          name##_SPLAY_FIND(x, y)
SPLAY_SEARCH(name, x, y)        name##_SPLAY_SEARCH(x, y)
SPLAY_NEXT(name, x, y)          name##_SPLAY_NEXT(x, y)
SPLAY_MIN(name, x)              (SPLAY_EMPTY(x) ? NULL  	                                : name##_SPLAY_MIN_MAX(x, SPLAY_NEGINF))
SPLAY_MAX(name, x)              (SPLAY_EMPTY(x) ? NULL  	                                : name##_SPLAY_MIN_MAX(x, SPLAY_INF))
SPLAY_FOREACH(x, name, head)                                    	for ((x) = SPLAY_MIN(name, head);                               	     (x) != NULL;                                               	     (x) = SPLAY_NEXT(name, head, x))
RB_HEAD(name, type)                                             struct name {                                                           	struct type *rbh_root;                    }
RB_INITIALIZER(root) { NULL }
RB_INIT(root) do {                                              	(root)->rbh_root = NULL;                                        } while (  0)
RB_BLACK 0
RB_RED 1
RB_PLACEHOLDER NULL
RB_ENTRY(type) struct {                                                                	struct type *rbe_left;                        	struct type *rbe_right;                      	struct type *rbe_parent;                    }
RB_LEFT(elm, field)             (elm)->field.rbe_left
RB_RIGHT(elm, field)            (elm)->field.rbe_right
_RB_PARENT(elm, field)          (elm)->field.rbe_parent
RB_SET(name, elm, parent, field) do {                                   	name##_RB_SETPARENT(elm, parent);                                       	RB_LEFT(elm, field) = RB_RIGHT(elm, field) = NULL;              	name##_RB_SETCOLOR(elm, RB_RED);                                } while (  0)
RB_SET_BLACKRED(name, black, red, field) do {                           	name##_RB_SETCOLOR(black,  RB_BLACK);                           	name##_RB_SETCOLOR(red, RB_RED);                                        } while (  0)
RB_ROTATE_LEFT(name, head, elm, tmp, field) do {                        	(tmp) = RB_RIGHT(elm, field);                                   	if ((RB_RIGHT(elm, field) = RB_LEFT(tmp, field)) != NULL) {     	        name##_RB_SETPARENT(RB_LEFT(tmp, field),(elm));         	}                                                               	RB_AUGMENT(elm);                                                	if (name##_RB_SETPARENT(tmp, name##_RB_GETPARENT(elm)) != NULL) {       	        if ((elm) == RB_LEFT(name##_RB_GETPARENT(elm), field))  	                RB_LEFT(name##_RB_GETPARENT(elm), field) = (tmp);       	        else                                                    	                RB_RIGHT(name##_RB_GETPARENT(elm), field) = (tmp);      	} else                                                          	        (head)->rbh_root = (tmp);                               	RB_LEFT(tmp, field) = (elm);                                    	name##_RB_SETPARENT(elm, (tmp));                                        	RB_AUGMENT(tmp);                                                	if ((name##_RB_GETPARENT(tmp)))                                 	        RB_AUGMENT(name##_RB_GETPARENT(tmp));                   } while (  0)
RB_ROTATE_RIGHT(name, head, elm, tmp, field) do {                       	(tmp) = RB_LEFT(elm, field);                                    	if ((RB_LEFT(elm, field) = RB_RIGHT(tmp, field)) != NULL) {     	        name##_RB_SETPARENT(RB_RIGHT(tmp, field), (elm));               	}                                                               	RB_AUGMENT(elm);                                                	if (name##_RB_SETPARENT(tmp, name##_RB_GETPARENT(elm)) != NULL) {       	        if ((elm) == RB_LEFT(name##_RB_GETPARENT(elm), field))  	                RB_LEFT(name##_RB_GETPARENT(elm), field) = (tmp);       	        else                                                    	                RB_RIGHT(name##_RB_GETPARENT(elm), field) = (tmp);      	} else                                                          	        (head)->rbh_root = (tmp);                               	RB_RIGHT(tmp, field) = (elm);                                   	name##_RB_SETPARENT(elm, tmp);                                  	RB_AUGMENT(tmp);                                                	if ((name##_RB_GETPARENT(tmp)))                                 	        RB_AUGMENT(name##_RB_GETPARENT(tmp));                   } while (  0)
RB_PROTOTYPE(name, type, field, cmp)                            void name##_RB_INSERT_COLOR(struct name *, struct type *);      void name##_RB_REMOVE_COLOR(struct name *, struct type *, struct type *);struct type *name##_RB_REMOVE(struct name *, struct type *);            struct type *name##_RB_INSERT(struct name *, struct type *);            struct type *name##_RB_FIND(struct name *, struct type *);              struct type *name##_RB_NFIND(struct name *, struct type *);             struct type *name##_RB_NEXT(struct type *);                             struct type *name##_RB_MINMAX(struct name *, int);                      struct type *name##_RB_GETPARENT(struct type*);                         struct type *name##_RB_SETPARENT(struct type*, struct type*);           int name##_RB_GETCOLOR(struct type*);                                   void name##_RB_SETCOLOR(struct type*,int);
RB_PROTOTYPE_SC(_sc_, name, type, field, cmp)                   _sc_ void name##_RB_INSERT_COLOR(struct name *, struct type *);         _sc_ void name##_RB_REMOVE_COLOR(struct name *, struct type *, struct type *); _sc_ struct type *name##_RB_REMOVE(struct name *, struct type *);       _sc_ struct type *name##_RB_INSERT(struct name *, struct type *);       _sc_ struct type *name##_RB_FIND(struct name *, struct type *);         _sc_ struct type *name##_RB_NFIND(struct name *, struct type *);        _sc_ struct type *name##_RB_NEXT(struct type *);                        _sc_ struct type *name##_RB_MINMAX(struct name *, int);                 _sc_ struct type *name##_RB_GETPARENT(struct type*);                    _sc_ struct type *name##_RB_SETPARENT(struct type*, struct type*);                      _sc_ int name##_RB_GETCOLOR(struct type*);                      _sc_ void name##_RB_SETCOLOR(struct type*,int)
RB_GENERATE(name, type, field, cmp)                         struct type *name##_RB_GETPARENT(struct type *elm) {                	struct type *__single parent = _RB_PARENT(elm, field);          	if( parent == NULL || parent == (struct type*)RB_PLACEHOLDER) { 	        return __unsafe_forge_single(struct type*, NULL);       	}                                                               	return __unsafe_forge_single(struct type*,                      	                (uintptr_t)parent & ~RB_COLOR_MASK);            }                                                                   int name##_RB_GETCOLOR(struct type *elm) {                          	int color = 0;                                                  	color = (int)((uintptr_t)_RB_PARENT(elm,field) & RB_COLOR_MASK);	return(color);                                                  }                                                                   void name##_RB_SETCOLOR(struct type *elm,int color) {               	struct type *__single parent = name##_RB_GETPARENT(elm);        	if(parent == (struct type*)NULL) {                              	        parent = (struct type*) RB_PLACEHOLDER;                 	}                                                               	_RB_PARENT(elm, field) = __unsafe_forge_single(struct type*,    	                (uintptr_t)parent | (unsigned int)color);       }                                                                   struct type *name##_RB_SETPARENT(struct type *elm, struct type *parent) {       	int color = name##_RB_GETCOLOR(elm);                            	_RB_PARENT(elm, field) = parent;                                	if(color) name##_RB_SETCOLOR(elm, color);                       	return(name##_RB_GETPARENT(elm));                               }                                                                                                                                       void                                                                name##_RB_INSERT_COLOR(struct name *head, struct type *elm)         {                                                                   	struct type *__single parent, *__single gparent, *__single tmp; 	while ((parent = name##_RB_GETPARENT(elm)) != NULL &&           	    name##_RB_GETCOLOR(parent) == RB_RED) {                     	        gparent = name##_RB_GETPARENT(parent);                  	        if (parent == RB_LEFT(gparent, field)) {                	                tmp = RB_RIGHT(gparent, field);                 	                if (tmp && name##_RB_GETCOLOR(tmp) == RB_RED) { 	                        name##_RB_SETCOLOR(tmp,  RB_BLACK);     	                        RB_SET_BLACKRED(name, parent, gparent, field);	                        elm = gparent;                          	                        continue;                               	                }                                               	                if (RB_RIGHT(parent, field) == elm) {           	                        RB_ROTATE_LEFT(name, head, parent, tmp, field);	                        tmp = parent;                           	                        parent = elm;                           	                        elm = tmp;                              	                }                                               	                RB_SET_BLACKRED(name, parent, gparent, field);  	                RB_ROTATE_RIGHT(name,head, gparent, tmp, field);        	        } else {                                                	                tmp = RB_LEFT(gparent, field);                  	                if (tmp && name##_RB_GETCOLOR(tmp) == RB_RED) { 	                        name##_RB_SETCOLOR(tmp,  RB_BLACK);     	                        RB_SET_BLACKRED(name, parent, gparent, field);	                        elm = gparent;                          	                        continue;                               	                }                                               	                if (RB_LEFT(parent, field) == elm) {            	                        RB_ROTATE_RIGHT(name, head, parent, tmp, field);	                        tmp = parent;                           	                        parent = elm;                           	                        elm = tmp;                              	                }                                               	                RB_SET_BLACKRED(name, parent, gparent, field);  	                RB_ROTATE_LEFT(name, head, gparent, tmp, field);        	        }                                                       	}                                                               	name##_RB_SETCOLOR(head->rbh_root,  RB_BLACK);                  }                                                                                                                                               void                                                                    name##_RB_REMOVE_COLOR(struct name *head, struct type *parent, struct type *elm) {                                                                       	struct type *__single tmp;                                      	while ((elm == NULL || name##_RB_GETCOLOR(elm) == RB_BLACK) &&  	    elm != RB_ROOT(head)) {                                     	        if (RB_LEFT(parent, field) == elm) {                    	                tmp = RB_RIGHT(parent, field);                  	                if (name##_RB_GETCOLOR(tmp) == RB_RED) {                	                        RB_SET_BLACKRED(name, tmp, parent, field);      	                        RB_ROTATE_LEFT(name, head, parent, tmp, field);	                        tmp = RB_RIGHT(parent, field);          	                }                                               	                if ((RB_LEFT(tmp, field) == NULL ||             	                    name##_RB_GETCOLOR(RB_LEFT(tmp, field)) == RB_BLACK) &&	                    (RB_RIGHT(tmp, field) == NULL ||            	                    name##_RB_GETCOLOR(RB_RIGHT(tmp, field)) == RB_BLACK)) {	                        name##_RB_SETCOLOR(tmp,  RB_RED);               	                        elm = parent;                           	                        parent = name##_RB_GETPARENT(elm);              	                } else {                                        	                        if (RB_RIGHT(tmp, field) == NULL ||     	                            name##_RB_GETCOLOR(RB_RIGHT(tmp, field)) == RB_BLACK) {	                                struct type *__single oleft;      	                                if ((oleft = RB_LEFT(tmp, field)) 	                                    != NULL)                    	                                        name##_RB_SETCOLOR(oleft,  RB_BLACK);	                                name##_RB_SETCOLOR(tmp, RB_RED);        	                                RB_ROTATE_RIGHT(name, head, tmp, oleft, field);	                                tmp = RB_RIGHT(parent, field);  	                        }                                       	                        name##_RB_SETCOLOR(tmp, (name##_RB_GETCOLOR(parent)));	                        name##_RB_SETCOLOR(parent, RB_BLACK);   	                        if (RB_RIGHT(tmp, field))               	                                name##_RB_SETCOLOR(RB_RIGHT(tmp, field),RB_BLACK);	                        RB_ROTATE_LEFT(name, head, parent, tmp, field);	                        elm = RB_ROOT(head);                    	                        break;                                  	                }                                               	        } else {                                                	                tmp = RB_LEFT(parent, field);                   	                if (name##_RB_GETCOLOR(tmp) == RB_RED) {                	                        RB_SET_BLACKRED(name, tmp, parent, field);      	                        RB_ROTATE_RIGHT(name, head, parent, tmp, field);	                        tmp = RB_LEFT(parent, field);           	                }                                               	                if ((RB_LEFT(tmp, field) == NULL ||             	                    name##_RB_GETCOLOR(RB_LEFT(tmp, field)) == RB_BLACK) &&	                    (RB_RIGHT(tmp, field) == NULL ||            	                    name##_RB_GETCOLOR(RB_RIGHT(tmp, field)) == RB_BLACK)) {	                        name##_RB_SETCOLOR(tmp, RB_RED);                	                        elm = parent;                           	                        parent = name##_RB_GETPARENT(elm);              	                } else {                                        	                        if (RB_LEFT(tmp, field) == NULL ||      	                            name##_RB_GETCOLOR(RB_LEFT(tmp, field)) == RB_BLACK) {	                                struct type *__single oright;       	                                if ((oright = RB_RIGHT(tmp, field)) 	                                    != NULL)                    	                                        name##_RB_SETCOLOR(oright,  RB_BLACK);	                                name##_RB_SETCOLOR(tmp,  RB_RED);       	                                RB_ROTATE_LEFT(name, head, tmp, oright, field);	                                tmp = RB_LEFT(parent, field);   	                        }                                       	                        name##_RB_SETCOLOR(tmp,(name##_RB_GETCOLOR(parent)));	                        name##_RB_SETCOLOR(parent, RB_BLACK);   	                        if (RB_LEFT(tmp, field))                	                                name##_RB_SETCOLOR(RB_LEFT(tmp, field), RB_BLACK);	                        RB_ROTATE_RIGHT(name, head, parent, tmp, field);	                        elm = RB_ROOT(head);                    	                        break;                                  	                }                                               	        }                                                       	}                                                               	if (elm)                                                        	        name##_RB_SETCOLOR(elm,  RB_BLACK);                     }                                                                                                                                               struct type *                                                           name##_RB_REMOVE(struct name *head, struct type *elm)                   {                                                                       	struct type *__single child, *__single parent, *__single old = elm; 	int color;                                                      	if (RB_LEFT(elm, field) == NULL)                                	        child = RB_RIGHT(elm, field);                           	else if (RB_RIGHT(elm, field) == NULL)                          	        child = RB_LEFT(elm, field);                            	else {                                                          	        struct type *__single left;                             	        elm = RB_RIGHT(elm, field);                             	        while ((left = RB_LEFT(elm, field)) != NULL)            	                elm = left;                                     	        child = RB_RIGHT(elm, field);                           	        parent = name##_RB_GETPARENT(elm);                              	        color = name##_RB_GETCOLOR(elm);                                	        if (child)                                              	                name##_RB_SETPARENT(child, parent);             	        if (parent) {                                           	                if (RB_LEFT(parent, field) == elm)              	                        RB_LEFT(parent, field) = child;         	                else                                            	                        RB_RIGHT(parent, field) = child;        	                RB_AUGMENT(parent);                             	        } else                                                  	                RB_ROOT(head) = child;                          	        if (name##_RB_GETPARENT(elm) == old)                    	                parent = elm;                                   	        (elm)->field = (old)->field;                            	        if (name##_RB_GETPARENT(old)) {                         	                if (RB_LEFT(name##_RB_GETPARENT(old), field) == old)	                        RB_LEFT(name##_RB_GETPARENT(old), field) = elm;	                else                                            	                        RB_RIGHT(name##_RB_GETPARENT(old), field) = elm;	                RB_AUGMENT(name##_RB_GETPARENT(old));           	        } else                                                  	                RB_ROOT(head) = elm;                            	        name##_RB_SETPARENT(RB_LEFT(old, field), elm);          	        if (RB_RIGHT(old, field))                               	                name##_RB_SETPARENT(RB_RIGHT(old, field), elm); 	        if (parent) {                                           	                left = parent;                                  	                do {                                            	                        RB_AUGMENT(left);                       	                } while ((left = name##_RB_GETPARENT(left)) != NULL); 	        }                                                       	        goto color;                                             	}                                                               	parent = name##_RB_GETPARENT(elm);                                      	color = name##_RB_GETCOLOR(elm);                                        	if (child)                                                      	        name##_RB_SETPARENT(child, parent);                     	if (parent) {                                                   	        if (RB_LEFT(parent, field) == elm)                      	                RB_LEFT(parent, field) = child;                 	        else                                                    	                RB_RIGHT(parent, field) = child;                	        RB_AUGMENT(parent);                                     	} else                                                          	        RB_ROOT(head) = child;                                  color:                                                                  	if (color == RB_BLACK)                                          	        name##_RB_REMOVE_COLOR(head, parent, child);            	return (old);                                                   }                                                                                                                                                                                  struct type *                                                           name##_RB_INSERT(struct name *head, struct type *elm)                   {                                                                       	struct type *tmp;                                               	struct type *parent = NULL;                                     	int comp = 0;                                                   	tmp = RB_ROOT(head);                                            	while (tmp) {                                                   	        parent = tmp;                                           	        comp = (cmp)(elm, parent);                              	        if (comp < 0)                                           	                tmp = RB_LEFT(tmp, field);                      	        else if (comp > 0)                                      	                tmp = RB_RIGHT(tmp, field);                     	        else                                                    	                return (tmp);                                   	}                                                               	RB_SET(name, elm, parent, field);                                       	if (parent != NULL) {                                           	        if (comp < 0)                                           	                RB_LEFT(parent, field) = elm;                   	        else                                                    	                RB_RIGHT(parent, field) = elm;                  	        RB_AUGMENT(parent);                                     	} else                                                          	        RB_ROOT(head) = elm;                                    	name##_RB_INSERT_COLOR(head, elm);                              	return (NULL);                                                  }                                                                                                                                                                          struct type *                                                           name##_RB_FIND(struct name *head, struct type *elm)                     {                                                                       	struct type *tmp = RB_ROOT(head);                               	int comp;                                                       	while (tmp) {                                                   	        comp = cmp(elm, tmp);                                   	        if (comp < 0)                                           	                tmp = RB_LEFT(tmp, field);                      	        else if (comp > 0)                                      	                tmp = RB_RIGHT(tmp, field);                     	        else                                                    	                return (tmp);                                   	}                                                               	return (NULL);                                                  }                                                                                                                                                     __attribute__((unused))                                                 struct type *                                                           name##_RB_NFIND(struct name *head, struct type *elm)                    {                                                                       	struct type *__single tmp = RB_ROOT(head);                          	struct type *__single res = NULL;                                   	int comp;                                                       	while (tmp) {                                                   	        comp = cmp(elm, tmp);                                   	        if (comp < 0) {                                         	                res = tmp;                                      	                tmp = RB_LEFT(tmp, field);                      	        }                                                       	        else if (comp > 0)                                      	                tmp = RB_RIGHT(tmp, field);                     	        else                                                    	                return (tmp);                                   	}                                                               	return (res);                                                   }                                                                                                                                                                                                         struct type *                                                           name##_RB_NEXT(struct type *elm)                                        {                                                                       	if (RB_RIGHT(elm, field)) {                                     	        elm = RB_RIGHT(elm, field);                             	        while (RB_LEFT(elm, field))                             	                elm = RB_LEFT(elm, field);                      	} else {                                                        	        if (name##_RB_GETPARENT(elm) &&                         	            (elm == RB_LEFT(name##_RB_GETPARENT(elm), field)))  	                elm = name##_RB_GETPARENT(elm);                 	        else {                                                  	                while (name##_RB_GETPARENT(elm) &&                      	                    (elm == RB_RIGHT(name##_RB_GETPARENT(elm), field)))	                        elm = name##_RB_GETPARENT(elm);         	                elm = name##_RB_GETPARENT(elm);                 	        }                                                       	}                                                               	return (elm);                                                   }                                                                                                                                               struct type *                                                           name##_RB_MINMAX(struct name *head, int val)                            {                                                                       	struct type *tmp = RB_ROOT(head);                               	struct type *parent = NULL;                                     	while (tmp) {                                                   	        parent = tmp;                                           	        if (val < 0)                                            	                tmp = RB_LEFT(tmp, field);                      	        else                                                    	                tmp = RB_RIGHT(tmp, field);                     	}                                                               	return (parent);                                                }
RB_PROTOTYPE_PREV(name, type, field, cmp)                       	RB_PROTOTYPE(name, type, field, cmp)                            struct type *name##_RB_PREV(struct type *);
RB_PROTOTYPE_SC_PREV(_sc_, name, type, field, cmp)              	RB_PROTOTYPE_SC(_sc_, name, type, field, cmp);                  _sc_ struct type *name##_RB_PREV(struct type *)
RB_GENERATE_PREV(name, type, field, cmp)                        	RB_GENERATE(name, type, field, cmp);                            struct type *                                                           name##_RB_PREV(struct type *elm)                                        {                                                                       	if (RB_LEFT(elm, field)) {                                      	        elm = RB_LEFT(elm, field);                              	        while (RB_RIGHT(elm, field))                            	                elm = RB_RIGHT(elm, field);                     	} else {                                                        	        if (name##_RB_GETPARENT(elm) &&                         	            (elm == RB_RIGHT(name##_RB_GETPARENT(elm), field))) 	                elm = name##_RB_GETPARENT(elm);                 	        else {                                                  	                while (name##_RB_GETPARENT(elm) &&              	                    (elm == RB_LEFT(name##_RB_GETPARENT(elm), field)))	                        elm = name##_RB_GETPARENT(elm);         	                elm = name##_RB_GETPARENT(elm);                 	        }                                                       	}                                                               	return (elm);                                                   }
RB_NEGINF -1
RB_INF 1
RB_INSERT(name, x, y)   name##_RB_INSERT(x, y)
RB_REMOVE(name, x, y)   name##_RB_REMOVE(x, y)
RB_FIND(name, x, y)     name##_RB_FIND(x, y)
RB_NFIND(name, x, y)    name##_RB_NFIND(x, y)
RB_NEXT(name, x, y)     name##_RB_NEXT(y)
RB_PREV(name, x, y)     name##_RB_PREV(y)
RB_MIN(name, x)         name##_RB_MINMAX(x, RB_NEGINF)
RB_MAX(name, x)         name##_RB_MINMAX(x, RB_INF)
RB_FOREACH(x, name, head)                                       	for ((x) = RB_MIN(name, head);                                  	     (x) != NULL;                                               	     (x) = name##_RB_NEXT(x))
RB_FOREACH_FROM(x, name, y)                                     	for ((x) = (y);                                                 	    ((x) != NULL) && ((y) = name##_RB_NEXT(x), (x) != NULL);    	    (x) = (y))
RB_FOREACH_REVERSE_FROM(x, name, y)                             	for ((x) = (y);                                                 	    ((x) != NULL) && ((y) = name##_RB_PREV(x), (x) != NULL);    	     (x) = (y))
RB_FOREACH_SAFE(x, name, head, y)                               	for ((x) = RB_MIN(name, head);                                  	    ((x) != NULL) && ((y) = name##_RB_NEXT(x), (x) != NULL);    	     (x) = (y))
LIBKERN_VERSION_H None
VERSION_MAJOR ###KERNEL_VERSION_MAJOR###
VERSION_MINOR ###KERNEL_VERSION_MINOR###
VERSION_VARIANT "###KERNEL_VERSION_VARIANT###"
VERSION_REVISION ###KERNEL_VERSION_REVISION###
VERSION_STAGE_DEV 0x20
VERSION_STAGE_ALPHA 0x40
VERSION_STAGE_BETA 0x60
VERSION_STAGE_RELEASE 0x80
VERSION_STAGE ###KERNEL_VERSION_STAGE###
VERSION_PRERELEASE_LEVEL ###KERNEL_VERSION_PRERELEASE_LEVEL###
OSBUILD_CONFIG "###KERNEL_BUILD_CONFIG###"
OSTYPE "Darwin"
OSRELEASE "###KERNEL_VERSION_LONG###"
OSVERSIZE 256
ZCONF_H None
ZLIB_H None
ZLIB_VERSION "1.2.3"
ZLIB_VERNUM 0x1230
Z_NO_FLUSH 0
Z_PARTIAL_FLUSH 1
Z_SYNC_FLUSH 3
Z_FULL_FLUSH 4
Z_FINISH 5
Z_BLOCK 6
Z_OK 0
Z_STREAM_END 1
Z_NEED_DICT 2
Z_NO_COMPRESSION 0
Z_BEST_SPEED 1
Z_BEST_COMPRESSION 9
Z_FILTERED 1
Z_HUFFMAN_ONLY 2
Z_RLE 3
Z_FIXED 4
Z_DEFAULT_STRATEGY 0
Z_BINARY 0
Z_TEXT 1
Z_ASCII Z_TEXT
Z_UNKNOWN 2
Z_DEFLATED 8
Z_NULL 0
zlib_version zlibVersion()
deflateInit(strm, level) 	deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
inflateInit(strm) inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))
deflateInit2(strm, level, method, windowBits, memLevel, strategy) 	deflateInit2_((strm),(level),(method),(windowBits),(memLevel),	              (strategy),           ZLIB_VERSION, sizeof(z_stream))
inflateInit2(strm, windowBits) 	inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))
inflateBackInit(strm, windowBits, window) 	inflateBackInit_((strm), (windowBits), (window), 	ZLIB_VERSION, sizeof(z_stream))
_OS__OSBYTEORDER_H None
NS_IN6ADDRSZ 16
NS_INT16SZ 2
NS_INADDRSZ 4
NS_IN6ADDRSZ 16
NS_INT16SZ 2
_OS_ALLOC_UTIL_H None
__OS_ATOMIC_H__ None
OS_ATOMIC_USES_CXX 0
OS_ATOMIC_STD std::
os_atomic_std(op) std::op
os_atomic(type) std::atomic<type> volatile
os_cast_to_atomic_pointer(p) os::cast_to_atomic_pointer(p)
os_atomic_basetypeof(p) decltype(os_cast_to_atomic_pointer(p)->load())
os_cast_to_nonatomic_pointer(p) os::cast_to_nonatomic_pointer(p)
__OS_ATOMIC_PRIVATE_H__ None
OS_ATOMIC_CONFIG_SMP 1
OS_ATOMIC_CONFIG_STARVATION_FREE_ONLY 0
OS_ATOMIC_CONFIG_MEMORY_ORDER_DEPENDENCY 1
os_compiler_barrier(b...) os_atomic_std(atomic_signal_fence)(_os_compiler_barrier_##b)
os_atomic_init(p, v) 	os_atomic_std(atomic_init)(os_cast_to_atomic_pointer(p), v)
os_atomic_store_is_plain(p) os_atomic_load_is_plain(p)
os_atomic_load(p, m)  ({ 	_Static_assert(os_atomic_load_is_plain(p), "Load is wide"); 	_os_compiler_barrier_before_atomic(m); 	__auto_type _r = os_atomic_std(atomic_load_explicit)( 	    os_cast_to_atomic_pointer(p), _os_atomic_mo_##m##_smp); 	_os_compiler_barrier_after_atomic(m); 	_r; })
os_atomic_store(p, v, m)  ({ 	_Static_assert(os_atomic_store_is_plain(p), "Store is wide"); 	__auto_type _v = (v); 	_os_compiler_barrier_before_atomic(m); 	os_atomic_std(atomic_store_explicit)(os_cast_to_atomic_pointer(p), _v, 	    _os_atomic_mo_##m##_smp); 	_os_compiler_barrier_after_atomic(m); 	_v; })
os_atomic_load_wide(p, m)  ({ 	_os_compiler_barrier_before_atomic(m); 	__auto_type _r = os_atomic_std(atomic_load_explicit)( 	    os_cast_to_atomic_pointer(p), _os_atomic_mo_##m##_smp); 	_os_compiler_barrier_after_atomic(m); 	_r; })
os_atomic_store_wide(p, v, m)  ({ 	__auto_type _v = (v); 	_os_compiler_barrier_before_atomic(m); 	os_atomic_std(atomic_store_explicit)(os_cast_to_atomic_pointer(p), _v, 	    _os_atomic_mo_##m##_smp); 	_os_compiler_barrier_after_atomic(m); 	_v; })
os_atomic_add_orig(p, v, m) _os_atomic_c11_op_orig(p, v, m, fetch_add)
os_atomic_add(p, v, m)      _os_atomic_c11_op(p, v, m, fetch_add, +)
os_atomic_inc_orig(p, m)    _os_atomic_c11_op_orig(p, 1, m, fetch_add)
os_atomic_inc(p, m)         _os_atomic_c11_op(p, 1, m, fetch_add, +)
os_atomic_sub_orig(p, v, m) _os_atomic_c11_op_orig(p, v, m, fetch_sub)
os_atomic_sub(p, v, m)      _os_atomic_c11_op(p, v, m, fetch_sub, -)
os_atomic_dec_orig(p, m)    _os_atomic_c11_op_orig(p, 1, m, fetch_sub)
os_atomic_dec(p, m)         _os_atomic_c11_op(p, 1, m, fetch_sub, -)
os_atomic_and_orig(p, v, m) _os_atomic_c11_op_orig(p, v, m, fetch_and)
os_atomic_and(p, v, m)      _os_atomic_c11_op(p, v, m, fetch_and, &)
os_atomic_andnot_orig(p, v, m) _os_atomic_c11_op_orig(p, (typeof(v))~(v), m, fetch_and)
os_atomic_andnot(p, v, m)      _os_atomic_c11_op(p, (typeof(v))~(v), m, fetch_and, &)
os_atomic_or_orig(p, v, m)  _os_atomic_c11_op_orig(p, v, m, fetch_or)
os_atomic_or(p, v, m)       _os_atomic_c11_op(p, v, m, fetch_or, |)
os_atomic_xor_orig(p, v, m) _os_atomic_c11_op_orig(p, v, m, fetch_xor)
os_atomic_xor(p, v, m)      _os_atomic_c11_op(p, v, m, fetch_xor, ^)
os_atomic_min_orig(p, v, m) _os_atomic_clang_op_orig(p, v, m, fetch_min)
os_atomic_min(p, v, m)      _os_atomic_clang_op(p, v, m, fetch_min, MIN)
os_atomic_max_orig(p, v, m) _os_atomic_clang_op_orig(p, v, m, fetch_max)
os_atomic_max(p, v, m)      _os_atomic_clang_op(p, v, m, fetch_max, MAX)
os_atomic_xchg(p, v, m)     _os_atomic_c11_op_orig(p, v, m, exchange)
os_atomic_cmpxchg(p, e, v, m)  ({ 	os_atomic_basetypeof(p) _r = (e); int _b; 	_os_compiler_barrier_before_atomic(m); 	_b = os_atomic_std(atomic_compare_exchange_strong_explicit)( 	    os_cast_to_atomic_pointer(p), &_r, 	    _os_atomic_value_cast(p, v), 	    _os_atomic_mo_##m##_smp, _os_atomic_mo_relaxed); 	_os_compiler_barrier_after_atomic(m); 	_b; })
os_atomic_cmpxchgv(p, e, v, g, m)  ({ 	os_atomic_basetypeof(p) _r = (e); int _b; 	_os_compiler_barrier_before_atomic(m); 	_b = os_atomic_std(atomic_compare_exchange_strong_explicit)( 	    os_cast_to_atomic_pointer(p), &_r, 	    _os_atomic_value_cast(p, v), 	    _os_atomic_mo_##m##_smp, _os_atomic_mo_relaxed); 	_os_compiler_barrier_after_atomic(m); 	*(g) = _r; _b; })
os_atomic_rmw_loop(p, ov, nv, m, ...)  ({ 	int _result = 0; 	__auto_type _p = os_cast_to_nonatomic_pointer(p); 	_os_compiler_barrier_before_atomic(m); 	ov = *_p; 	do { 	    __VA_ARGS__; 	    _result = os_atomic_std(atomic_compare_exchange_weak_explicit)( 	        os_cast_to_atomic_pointer(_p), &ov, nv, 	        _os_atomic_mo_##m##_smp, _os_atomic_mo_relaxed); 	} while (__builtin_expect(!_result, 0)); 	_os_compiler_barrier_after_atomic(m); 	_result; })
os_atomic_inject_dependency(p, e) 	((typeof(*(p)) *)((p) + _os_atomic_auto_dependency(e).__opaque_zero))
os_atomic_load_with_dependency_on(p, e) 	os_atomic_load(os_atomic_inject_dependency(p, e), dependency)
__OS_ATOMIC_PRIVATE_ARCH_H__ None
os_atomic_clear_exclusive() __builtin_arm_clrex()
os_atomic_load_exclusive(p, m)  ({ 	os_atomic_basetypeof(p) _r = _os_atomic_mo_has_acquire(_os_atomic_mo_##m##_smp) 	    ? __builtin_arm_ldaex(os_cast_to_nonatomic_pointer(p)) 	    : __builtin_arm_ldrex(os_cast_to_nonatomic_pointer(p)); 	_os_compiler_barrier_after_atomic(m); 	_r; })
os_atomic_store_exclusive(p, v, m)  ({ 	_os_compiler_barrier_before_atomic(m); 	(_os_atomic_mo_has_release(_os_atomic_mo_##m##_smp) 	    ? !__builtin_arm_stlex(v, os_cast_to_nonatomic_pointer(p)) 	        : !__builtin_arm_strex(v, os_cast_to_nonatomic_pointer(p))); })
__OS_ATOMIC_PRIVATE_IMPL_H__ None
_os_atomic_mo_relaxed os_atomic_std(memory_order_relaxed)
_os_atomic_mo_compiler_acquire os_atomic_std(memory_order_relaxed)
_os_atomic_mo_compiler_release os_atomic_std(memory_order_relaxed)
_os_atomic_mo_compiler_acq_rel os_atomic_std(memory_order_relaxed)
_os_atomic_mo_consume os_atomic_std(memory_order_consume)
_os_atomic_mo_acquire os_atomic_std(memory_order_acquire)
_os_atomic_mo_release os_atomic_std(memory_order_release)
_os_atomic_mo_acq_rel os_atomic_std(memory_order_acq_rel)
_os_atomic_mo_seq_cst os_atomic_std(memory_order_seq_cst)
memory_order_relaxed_smp _os_atomic_mo_relaxed_smp
memory_order_compiler_acquire_smp _os_atomic_mo_compiler_acquire_smp
memory_order_compiler_release_smp _os_atomic_mo_compiler_release_smp
memory_order_compiler_acq_rel_smp _os_atomic_mo_compiler_acq_rel_smp
memory_order_consume_smp _os_atomic_mo_consume_smp
memory_order_acquire_smp _os_atomic_mo_acquire_smp
memory_order_release_smp _os_atomic_mo_release_smp
memory_order_acq_rel_smp _os_atomic_mo_acq_rel_smp
memory_order_seq_cst_smp _os_atomic_mo_seq_cst_smp
_os_compiler_barrier_relaxed _os_atomic_mo_relaxed
_os_compiler_barrier_acquire _os_atomic_mo_acquire
_os_compiler_barrier_release _os_atomic_mo_release
_os_compiler_barrier_acq_rel _os_atomic_mo_acq_rel
_os_compiler_barrier_ _os_atomic_mo_acq_rel
_os_rel_barrier_relaxed _os_atomic_mo_relaxed
_os_rel_barrier_compiler_acquire _os_atomic_mo_relaxed
_os_rel_barrier_compiler_release _os_atomic_mo_release
_os_rel_barrier_compiler_acq_rel _os_atomic_mo_release
_os_rel_barrier_consume _os_atomic_mo_relaxed
_os_rel_barrier_acquire _os_atomic_mo_relaxed
_os_rel_barrier_release _os_atomic_mo_release
_os_rel_barrier_acq_rel _os_atomic_mo_release
_os_rel_barrier_seq_cst _os_atomic_mo_release
_os_acq_barrier_relaxed _os_atomic_mo_relaxed
_os_acq_barrier_compiler_acquire _os_atomic_mo_acquire
_os_acq_barrier_compiler_release _os_atomic_mo_relaxed
_os_acq_barrier_compiler_acq_rel _os_atomic_mo_acquire
_os_acq_barrier_consume _os_atomic_mo_acquire
_os_acq_barrier_acquire _os_atomic_mo_acquire
_os_acq_barrier_release _os_atomic_mo_relaxed
_os_acq_barrier_acq_rel _os_atomic_mo_acquire
_os_acq_barrier_seq_cst _os_atomic_mo_acquire
_os_compiler_barrier_before_atomic(m) os_atomic_std(atomic_signal_fence)(_os_rel_barrier_##m)
_os_compiler_barrier_after_atomic(m) os_atomic_std(atomic_signal_fence)(_os_acq_barrier_##m)
_os_rel_fence_relaxed _os_atomic_mo_relaxed
_os_rel_fence_compiler_acquire _os_atomic_mo_relaxed
_os_rel_fence_compiler_release _os_atomic_mo_release
_os_rel_fence_compiler_acq_rel _os_atomic_mo_release
_os_rel_fence_consume _os_atomic_mo_relaxed_smp
_os_rel_fence_acquire _os_atomic_mo_relaxed_smp
_os_rel_fence_release _os_atomic_mo_release_smp
_os_rel_fence_acq_rel _os_atomic_mo_release_smp
_os_rel_fence_seq_cst _os_atomic_mo_release_smp
_os_acq_fence_relaxed _os_atomic_mo_relaxed
_os_acq_fence_compiler_acquire _os_atomic_mo_relaxed
_os_acq_fence_compiler_release _os_atomic_mo_relaxed
_os_acq_fence_compiler_acq_rel _os_atomic_mo_relaxed
_os_acq_fence_consume _os_atomic_mo_acquire_smp
_os_acq_fence_acquire _os_atomic_mo_acquire_smp
_os_acq_fence_release _os_atomic_mo_relaxed_smp
_os_acq_fence_acq_rel _os_atomic_mo_acquire_smp
_os_acq_fence_seq_cst _os_atomic_mo_acquire_smp
_os_memory_fence_before_atomic(m) os_atomic_std(atomic_thread_fence)(_os_rel_fence_##m)
_os_memory_fence_after_atomic(m) os_atomic_std(atomic_thread_fence)(_os_acq_fence_##m)
_os_atomic_value_cast(p, v) 	({ __typeof__(*os_cast_to_nonatomic_pointer(p)) ___v = (v); ___v; })
_os_atomic_c11_op_orig(p, v, m, o)  ({ 	_os_compiler_barrier_before_atomic(m); 	__auto_type _r = os_atomic_std(atomic_##o##_explicit)(	    os_cast_to_atomic_pointer(p), 	    _os_atomic_value_cast(p, v), 	    _os_atomic_mo_##m##_smp); 	_os_compiler_barrier_after_atomic(m); 	_r; })
_os_atomic_c11_op(p, v, m, o, op) ({ 	__auto_type _v = _os_atomic_value_cast(p, v); 	_os_atomic_c11_op_orig(p, _v, m, o) op _v; })
_os_atomic_clang_op_orig(p, v, m, o)  ({ 	_os_compiler_barrier_before_atomic(m); 	__auto_type _r = __atomic_##o(os_cast_to_nonatomic_pointer(p), 	    _os_atomic_value_cast(p, v), 	    _os_atomic_mo_##m##_smp); 	_os_compiler_barrier_after_atomic(m); 	_r; })
_os_atomic_clang_op(p, v, m, o, op) ({ 	__auto_type _v = _os_atomic_value_cast(p, v); 	__auto_type _s = _os_atomic_clang_op_orig(p, _v, m, o); 	op(_s, _v); })
__OS_BASE__ None
__has_builtin(x) 0
__has_include(x) 0
__has_feature(x) 0
__has_attribute(x) 0
__has_extension(x) 0
__OS_STRINGIFY(s) #s
OS_STRINGIFY(s) __OS_STRINGIFY(s)
__OS_CONCAT(x, y) x ## y
OS_CONCAT(x, y) __OS_CONCAT(x, y)
XNU_PTRAUTH_SIGNED_PTR OS_PTRAUTH_SIGNED_PTR
XNU_PTRAUTH_SIGNED_PTR_AUTH_NULL OS_PTRAUTH_SIGNED_PTR_AUTH_NULL
OS_ASSUME_PTR_ABI_SINGLE_BEGIN __ASSUME_PTR_ABI_SINGLE_BEGIN
OS_ASSUME_PTR_ABI_SINGLE_END __ASSUME_PTR_ABI_SINGLE_END
OS_UNSAFE_INDEXABLE __unsafe_indexable
OS_HEADER_INDEXABLE __header_indexable
OS_COUNTED_BY(N) __counted_by(N)
OS_SIZED_BY(N) __sized_by(N)
__OS_BASE_PRIVATE__ None
os_likely(x) OS_EXPECT(!!(x), 1)
os_unlikely(x) OS_EXPECT(!!(x), 0)
_OS_CPP_UTIL_H None
_OS_CXX_SAFE_BUFFERS_H None
__firehose_h None
_OS_HASH_H_ None
OS_LOGMEM_BUF_ORDER 14
OS_LOGMEM_MIN_LOG_ORDER 9
OS_LOG_SUBSYSTEM_MAX_CNT 1024
OS_LOG_SUBSYSTEM_NONE 0xffff
OS_LOG_SUBSYSTEM_BASE 0x0001
OS_LOG_SUBSYSTEM_NAME_MAX_LEN 128
__os_log_h None
__has_attribute(x) 0
__has_builtin(x) 0
OS_LOG_BUFFER_MAX_SIZE 256
OS_LOG_DISABLED NULL
OS_LOG_DEFAULT OS_OBJECT_GLOBAL_OBJECT(os_log_t, _os_log_default)
os_log(log, format, ...)     os_log_with_type(log, OS_LOG_TYPE_DEFAULT, format, ##__VA_ARGS__)
os_log_info(log, format, ...)     os_log_with_type(log, OS_LOG_TYPE_INFO, format, ##__VA_ARGS__)
os_log_debug(log, format, ...)     os_log_with_type(log, OS_LOG_TYPE_DEBUG, format, ##__VA_ARGS__)
os_log_error(log, format, ...)     os_log_with_type(log, OS_LOG_TYPE_ERROR, format, ##__VA_ARGS__)
os_log_fault(log, format, ...)     os_log_with_type(log, OS_LOG_TYPE_FAULT, format, ##__VA_ARGS__)
os_log_with_type(log, type, format, ...) __extension__({                                _Static_assert(__builtin_constant_p(format), "format string must be constant");             __attribute__((section("__TEXT,__os_log"))) static const char _os_log_fmt[] = format;       if (0) {                                                                                	_os_log_verify_format_str(format, ##__VA_ARGS__);                                       } else {                                                                                  	_os_log_internal(&__dso_handle, log, type, _os_log_fmt, ##__VA_ARGS__);                 }                                                                                           __asm__("");                                                        })
os_log_at_time(log, type, ts, format, ...) __extension__({                              _Static_assert(__builtin_constant_p(format), "format string must be constant");             __attribute__((section("__TEXT,__os_log"))) static const char _os_log_fmt[] = format;       if (0) {                                                                                	_os_log_verify_format_str(format, ##__VA_ARGS__);                                       } else {                                                                                  	_os_log_at_time(&__dso_handle, log, type, ts, _os_log_fmt, ##__VA_ARGS__);              }                                                                                           __asm__("");                                                        })
os_log_driverKit(out, log, type, format, ...) __extension__({                                _Static_assert(__builtin_constant_p(format), "format string must be constant");             __attribute__((section("__TEXT,__os_log"))) static const char _os_log_fmt[] = format;       if (0) {                                                                                	_os_log_verify_format_str(format, ##__VA_ARGS__);                                       } else {                                                                                  	(*(out)) = _os_log_internal_driverKit(&__dso_handle, log, type, _os_log_fmt, ##__VA_ARGS__);                     }                                                                                           __asm__("");                                                        })
os_log_with_startup_serial_and_type(log, type, format, ...) __extension__({     if (startup_serial_logging_active) { printf(format, ##__VA_ARGS__); }               else { os_log_with_type(log, type, format, ##__VA_ARGS__); }                    })
os_log_with_startup_serial(log, format, ...)     os_log_with_startup_serial_and_type(log, OS_LOG_TYPE_DEFAULT, format, ##__VA_ARGS__)
os_log_info_with_startup_serial(log, format, ...)     os_log_with_startup_serial_and_type(log, OS_LOG_TYPE_INFO, format, ##__VA_ARGS__)
os_log_debug_with_startup_serial(log, format, ...)     os_log_with_startup_serial_and_type(log, OS_LOG_TYPE_DEBUG, format, ##__VA_ARGS__)
os_log_error_with_startup_serial(log, format, ...)     os_log_with_startup_serial_and_type(log, OS_LOG_TYPE_ERROR, format, ##__VA_ARGS__)
os_log_fault_with_startup_serial(log, format, ...)     os_log_with_startup_serial_and_type(log, OS_LOG_TYPE_FAULT, format, ##__VA_ARGS__)
log_context_cursor(ctx) &(ctx)->ctx_hdr->hdr_data[(ctx)->ctx_content_off]
log_encode_h None
log_encode_types_h None
log_internal_h None
BLOCK_INDEX(lm, l, a, s)     (BLOCK_LEVEL_BASE(l) + ((uintptr_t)(a) - (uintptr_t)(lm)->lm_mem) / (s))
MAP_SIZE(size_order, min_order)     MAX(1, (1 << ((size_order) - (min_order) + 1)) / 8)
logmem_lock(lock, lm) if ((lock)) lck_spin_lock(&(lm)->lm_lock)
logmem_unlock(lock, lm) if ((lock)) lck_spin_unlock(&(lm)->lm_lock)
log_mem_h None
__os_log_private_h None
OS_LOG_XNU_SUBSYSTEM "com.apple.xnu"
OS_LOG_SUBSYSTEM "com.apple.xnu.oslog"
OS_LOG_MAX_SIZE_ORDER 10
LQ_DEFAULT_SZ_ORDER 15
LQ_DEFAULT_FREE_AFTER_CNT 15000
LQ_MAX_SZ_ORDER 20
LQ_MIN_LOG_SZ_ORDER 5
LQ_MAX_LOG_SZ_ORDER 11
LQ_BATCH_SIZE 24
LQ_MAX_LM_SLOTS 9
LQ_LOW_MEM_SCALE 3
LQ_MIN_ALLOCATED_LM_SLOTS 2
LQ_METADATA_START_SLOT 0
LQ_MEM_ENABLE(q, i) ((q)->lq_mem_set |= (1 << (i)))
LQ_MEM_ENABLED(q, i) ((q)->lq_mem_set & (1 << (i)))
LQ_MEM_DISABLE(q, i) ((q)->lq_mem_set &= ~(1 << (i)))
publish(a, v) os_atomic_store((a), (v), release)
read_dependency(v) os_atomic_load((v), dependency)
read_dependent(v, t) os_atomic_load_with_dependency_on((v), (uintptr_t)(t))
read_dependent_w(v, t) ({ 	__auto_type _v = os_atomic_inject_dependency((v), (uintptr_t)(t)); 	os_atomic_load_wide(_v, dependency); })
log_queue_h None
__OS_OBJECT__ None
OS_OBJECT_GLOBAL_OBJECT(type, object) ((OS_OBJECT_BRIDGE type)&(object))
_OS_OVERFLOW_H None
os_add3_overflow(a, b, c, res) __os_warn_unused(__extension__({ 	__typeof(*(res)) _tmp; 	bool _s, _t; 	_s = os_add_overflow((a), (b), &_tmp); 	_t = os_add_overflow((c), _tmp, (res)); 	_s | _t; }))
os_sub3_overflow(a, b, c, res) __os_warn_unused(__extension__({ 	__typeof(*(res)) _tmp; 	bool _s, _t; 	_s = os_sub_overflow((a), (b), &_tmp); 	_t = os_sub_overflow(_tmp, (c), (res)); 	_s | _t; }))
os_mul3_overflow(a, b, c, res) __os_warn_unused(__extension__({ 	__typeof(*(res)) _tmp; 	bool _s, _t; 	_s = os_mul_overflow((a), (b), &_tmp); 	_t = os_mul_overflow((c), _tmp, (res)); 	_s | _t; }))
os_add_and_mul_overflow(a, b, x, res) __os_warn_unused(__extension__({ 	__typeof(*(res)) _tmp; 	bool _s, _t; 	_s = os_add_overflow((a), (b), &_tmp); 	_t = os_mul_overflow((x), _tmp, (res)); 	_s | _t; }))
os_mul_and_add_overflow(a, x, b, res) __os_warn_unused(__extension__({ 	__typeof(*(res)) _tmp; 	bool _s, _t; 	_s = os_mul_overflow((a), (x), &_tmp); 	_t = os_add_overflow((b), _tmp, (res)); 	_s | _t; }))
os_convert_overflow(a, res) os_add_overflow((a), 0, (res))
os_inc_overflow(res) __os_warn_unused(__extension__({ 	__typeof((res)) _tmp = (res); 	os_add_overflow(*_tmp, 1, _tmp); }))
os_dec_overflow(res) __os_warn_unused(__extension__({ 	__typeof((res)) _tmp = (res); 	os_sub_overflow(*_tmp, 1, _tmp); }))
_OS_PTRTOOLS_H None
__os_unaligned_type(p) struct { __typeof__(*(p)) val; } __attribute__((packed)) *
OS_REASON_PRIVATE_H None
OS_PCPU_REF_LIVE 1ull
OS_PCPU_REF_WAITER 2ull
OS_PCPU_REF_INC 4ull
_OS_REFCNT_H_ None
os_ref_init(rc, grp) os_ref_init_count((rc), (grp), 1)
os_ref_init_raw(rc, grp) os_ref_init_count_raw((rc), (grp), 1)
os_ref_init_mask(rc, b, grp, bits) os_ref_init_count_mask((rc), (b), (grp), 1, bits)
_OS_REFCNT_INTERNAL_H None
__os_system_event_log_h None
__OS_TRACE_H__ None
os_trace(format, ...) __extension__({                                               _Static_assert(__builtin_constant_p(format), "format must be a constant string");       __attribute__((section("__TEXT,__os_trace"))) static const char _m[] = format;         OS_TRACE_CALL(format, _m, OS_TRACE_TYPE_RELEASE, ##__VA_ARGS__);                     })
os_trace_debug(format, ...) __extension__({                                         _Static_assert(__builtin_constant_p(format), "format must be a constant string");       __attribute__((section("__TEXT,__os_trace"))) static const char _m[] = format;         OS_TRACE_CALL(format, _m, OS_TRACE_TYPE_DEBUG, ##__VA_ARGS__);                       })
os_trace_error(format, ...) __extension__({                                         _Static_assert(__builtin_constant_p(format), "format must be a constant string");       __attribute__((section("__TEXT,__os_trace"))) static const char _m[] = format;         OS_TRACE_CALL(format, _m, OS_TRACE_TYPE_ERROR, ##__VA_ARGS__);                       })
os_trace_fault(format, ...) __extension__({                                         _Static_assert(__builtin_constant_p(format), "format must be a constant string");       __attribute__((section("__TEXT,__os_trace"))) static const char _m[] = format;          OS_TRACE_CALL(format, _m, OS_TRACE_TYPE_FAULT, ##__VA_ARGS__);                      })
libtrace_trace_internal_h None
BUF 32
LONG 0x01
SHORT 0x04
SUPPRESS 0x08
POINTER 0x10
NOSKIP 0x20
LONGLONG 0x400
SHORTSHORT 0x4000
UNSIGNED 0x8000
SIGNOK 0x40
NDIGITS 0x80
DPTOK 0x100
EXPOK 0x200
PFXOK 0x100
NZDIGITS 0x200
CT_CHAR 0
CT_CCL 1
CT_STRING 2
CT_INT 3
ZLIB_INTERNAL None
BASE 65521UL
NMAX 5552
DO1(buf,i) {adler += (buf)[i]; sum2 += adler;}
DO2(buf,i) DO1(buf,i); DO1(buf,i+1);
DO4(buf,i) DO2(buf,i); DO2(buf,i+2);
DO8(buf,i) DO4(buf,i); DO4(buf,i+4);
DO16(buf) DO8(buf,0); DO8(buf,8);
ZLIB_INTERNAL None
NIL 0
EQUAL 0
CLEAR_HASH(s) s->head[s->hash_size-1] = NIL;     zmemzero((Bytef *)s->head, (unsigned)(s->hash_size-1)*sizeof(*s->head));
FLUSH_BLOCK_ONLY(s, eof) {    _tr_flush_block(s, (s->block_start >= 0L ?                    (charf *)&s->window[(unsigned)s->block_start] :                    (charf *)Z_NULL),                 (ulg)((long)s->strstart - s->block_start),                 (eof));    s->block_start = s->strstart;    flush_pending(s->strm);    Tracev((stderr,"[FLUSH]")); }
FLUSH_BLOCK(s, eof) {    FLUSH_BLOCK_ONLY(s, eof);    if (s->strm->avail_out == 0) return (eof) ? finish_started : need_more; }
DEFLATE_H None
LENGTH_CODES 29
LITERALS 256
D_CODES 30
BL_CODES 19
MAX_BITS 15
INIT_STATE 42
EXTRA_STATE 69
NAME_STATE 73
COMMENT_STATE 91
HCRC_STATE 103
BUSY_STATE 113
FINISH_STATE 666
Freq fc.freq
Code fc.code
Dad dl.dad
Len dl.len
put_byte(s, c) {s->pending_buf[s->pending++] = (c);}
LOAD() do {         put = strm->next_out;         left = strm->avail_out;         next = strm->next_in;         have = strm->avail_in;         hold = state->hold;         bits = state->bits;     } while (0)
RESTORE() do {         strm->next_out = put;         strm->avail_out = left;         strm->next_in = next;         strm->avail_in = have;         state->hold = hold;         state->bits = bits;     } while (0)
INITBITS() do {         hold = 0;         bits = 0;     } while (0)
PULL() do {         if (have == 0) {             have = in(in_desc, &next);             if (have == 0) {                 next = Z_NULL;                 ret = Z_BUF_ERROR;                 goto inf_leave;             }         }     } while (0)
PULLBYTE() do {         PULL();         have--;         hold += (unsigned long)(*next++) << bits;         bits += 8;     } while (0)
NEEDBITS(n) do {         while (bits < (unsigned)(n))             PULLBYTE();     } while (0)
DROPBITS(n) do {         hold >>= (n);         bits -= (unsigned)(n);     } while (0)
BYTEBITS() do {         hold >>= bits & 7;         bits -= bits & 7;     } while (0)
ROOM() do {         if (left == 0) {             put = state->window;             left = state->wsize;             state->whave = left;             if (out(out_desc, put, left)) {                 ret = Z_BUF_ERROR;                 goto inf_leave;             }         }     } while (0)
LOAD() do {         put = strm->next_out;         left = strm->avail_out;         next = strm->next_in;         have = strm->avail_in;         hold = state->hold;         bits = state->bits;     } while (0)
RESTORE() do {         strm->next_out = put;         strm->avail_out = left;         strm->next_in = next;         strm->avail_in = have;         state->hold = hold;         state->bits = bits;     } while (0)
INITBITS() do {         hold = 0;         bits = 0;     } while (0)
PULLBYTE() do {         if (have == 0) goto inf_leave;         have--;         hold += (unsigned long)(*next++) << bits;         bits += 8;     } while (0)
NEEDBITS(n) do {         while (bits < (unsigned)(n))             PULLBYTE();     } while (0)
DROPBITS(n) do {         hold >>= (n);         bits -= (unsigned)(n);     } while (0)
BYTEBITS() do {         hold >>= bits & 7;         bits -= bits & 7;     } while (0)
MAXBITS 15
ENOUGH 2048
MAXD 592
MAX_BL_BITS 7
END_BLOCK 256
REP_3_6 16
REPZ_3_10 17
REPZ_11_138 18
DIST_CODE_LEN 512
put_short(s, w) {     put_byte(s, (uch)((w) & 0xff));     put_byte(s, (uch)((ush)(w) >> 8)); }
SMALLEST 1
pqremove(s, tree, top) {    top = s->heap[SMALLEST];     s->heap[SMALLEST] = s->heap[s->heap_len--];     pqdownheap(s, tree, SMALLEST); }
smaller(tree, n, m, depth)    (tree[n].Freq < tree[m].Freq ||    (tree[n].Freq == tree[m].Freq && depth[n] <= depth[m]))
ZLIB_INTERNAL None
ZUTIL_H None
ZLIB_INTERNAL None
ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]
ERR_RETURN(strm,err) return (strm->msg = (char*)ERR_MSG(err), (err))
STORED_BLOCK 0
STATIC_TREES 1
DYN_TREES 2
MIN_MATCH 3
MAX_MATCH 258
PRESET_DICT 0x20
ZALLOC(strm, items, size)            (*((strm)->zalloc))((strm)->opaque, (items), (size))
ZFREE(strm, addr)  (*((strm)->zfree))((strm)->opaque, (voidpf)(addr))
TRY_FREE(s, p) {if (p) ZFREE(s, p);}
local static
DO1 crc = crc_table[0][((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8)
DO8 DO1; DO1; DO1; DO1; DO1; DO1; DO1; DO1
GF2_DIM 32
__AMFI_H None
KERN_AMFI_INTERFACE_VERSION 7
KERN_AMFI_SUPPORTS_DATA_ALLOC 2
CORE_ENTITLEMENTS_I_KNOW_WHAT_IM_DOING None
KERN_AMFI_SUPPORTS_OSENTITLEMENTS_API 1
OSENTITLEMENTS_INTERFACE_VERSION 1u
KERN_AMFI_SUPPORTS_TRUST_CACHE_API 1
TRUST_CACHE_INTERFACE_VERSION 3u
__APPLE_ENCRYPTED_ARCHIVE_H None
_OS_OSBYTEORDERARM_H None
_OS__OSBYTEORDERARM_H None
XNU_LIBKERN_LIBKERN_CXX_BOUNDED_ARRAY_H None
XNU_LIBKERN_LIBKERN_CXX_BOUNDED_ARRAY_REF_H None
XNU_LIBKERN_LIBKERN_CXX_BOUNDED_PTR_H None
XNU_LIBKERN_LIBKERN_CXX_BOUNDED_PTR_FWD_H None
XNU_LIBKERN_LIBKERN_CXX_INTRUSIVE_SHARED_PTR_H None
XNU_LIBKERN_LIBKERN_CXX_OS_ALLOCATION_H None
_OS_OSARRAY_H None
_OS_OSBOOLEAN_H None
XNU_LIBKERN_LIBKERN_CXX_OS_BOUNDED_ARRAY_H None
XNU_LIBKERN_LIBKERN_CXX_OS_BOUNDED_ARRAY_REF_H None
XNU_LIBKERN_LIBKERN_CXX_OS_BOUNDED_PTR_H None
XNU_LIBKERN_LIBKERN_CXX_OS_BOUNDED_PTR_FWD_H None
_OS_OSCOLLECTION_H None
_OS_OSCOLLECTIONITERATOR_H None
_OS_OSCONTAINERS_H None
_OSCPPDEBUG_H None
OSCPP_DEBUG None
_OS_OSDATA_H None
_IOKIT_IODICTIONARY_H None
_OS_OSENDIANHELPER_H None
_OS_OSITERATOR_H None
_LIBKERN_OSKEXT_H None
container_of(ptr, type, member) ((type*)(((uintptr_t)ptr) - offsetof(type, member)))
_OS_OSLIB_H None
MACH_ASSERT 1
kallocp_type_container(ty, countp, flags) ({                           	uint32_t *__countp = (countp);                                         	struct kalloc_result __kar;                                            	static KALLOC_TYPE_VAR_DEFINE_3(kt_view_var, ty, KT_SHARED_ACCT);      	__kar = kalloc_ext(kt_mangle_var_view(kt_view_var),                    	    kt_size(0, sizeof(ty), *__countp),                                 	    Z_VM_TAG_BT(flags | Z_FULLSIZE | Z_SPRAYQTN | Z_SET_NOTEARLY,     	    VM_KERN_MEMORY_LIBKERN), NULL);                                    	*__countp = (uint32_t)MIN(__kar.size / sizeof(ty), UINT32_MAX);        	(ty *)__kar.addr;                                                      })
kreallocp_type_container(ty, ptr, old_count, countp, flags) ({         	uint32_t *__countp = (countp);                                         	struct kalloc_result __kar;                                            	static KALLOC_TYPE_VAR_DEFINE_3(kt_view_var, ty, KT_SHARED_ACCT);      	__kar = krealloc_ext(kt_mangle_var_view(kt_view_var), ptr,             	    kt_size(0, sizeof(ty), old_count),                                 	    kt_size(0, sizeof(ty), *__countp),                                 	    Z_VM_TAG_BT(flags | Z_FULLSIZE | Z_SPRAYQTN | Z_SET_NOTEARLY,     	    VM_KERN_MEMORY_LIBKERN), NULL);                                    	*__countp = (uint32_t)MIN(__kar.size / sizeof(ty), UINT32_MAX);        	(ty *)__kar.addr;                                                      })
_LIBKERN_OSMETACLASS_H None
APPLE_KEXT_COMPATIBILITY None
APPLE_KEXT_ALIGN_CONTAINERS 1
APPLE_KEXT_LEGACY_ABI 0
APPLE_KEXT_COMPATIBILITY_VIRTUAL None
APPLE_KEXT_DEPRECATED __attribute__((deprecated))
APPLE_KEXT_WSHADOW_PUSH _Pragma("clang diagnostic push") 	_Pragma("clang diagnostic ignored \"-Wunknown-warning-option\"") 	_Pragma("clang diagnostic ignored \"-Wshadow-field\"")
APPLE_KEXT_WSHADOW_POP _Pragma("clang diagnostic pop")
OSDynamicCast(type, inst)       ((type *) OSMetaClassBase::safeMetaCast((inst), OSTypeID(type)))
OSRequiredCast(type, inst)      ((type *) OSMetaClassBase::requiredMetaCast((inst), OSTypeID(type)))
OSCheckTypeInst(typeinst, inst)     OSMetaClassBase::checkTypeInst(inst, typeinst)
OSSafeRelease(inst) do { int OSSafeRelease __attribute__ ((deprecated("Use OSSafeReleaseNULL"))); (OSSafeRelease); 	if (inst) (inst)->release(); } while (0)
OSSafeReleaseNULL(inst) do { if (inst != NULL) (inst)->release(); (inst) = NULL; } while (0)
_OS_ADD_METAMETHODS(b) _OS_ADD_METAMETHODS_ ## b
_OS_ADD_METAMETHODS_ None
_OS_ADD_METAMETHODS_dispatch virtual kern_return_t Dispatch(const IORPC rpc) APPLE_KEXT_OVERRIDE;
_OS_ADD_METHODS(className, b) _OS_ADD_METHODS_ ## b(className)
_OS_ADD_METHODS_(className) None
_OS_ADD_METHODS_dispatch(className) className ## _Methods                                           className ## _KernelMethods
OSDeclareCommonStructors(className, dispatch)               private:                                                        static const OSMetaClass * const superClass;                    public:                                                         static const OSMetaClass * const metaClass;                 	static class MetaClass : public OSMetaClass {                 	public:                                                       	    MetaClass();                                              	    virtual OSObject *alloc() const APPLE_KEXT_OVERRIDE;      	    _OS_ADD_METAMETHODS(dispatch);                            	} gMetaClass;                                                 	friend class className ::MetaClass;                           	virtual const OSMetaClass * getMetaClass() const APPLE_KEXT_OVERRIDE;     protected:                                                      className (const OSMetaClass *);                                virtual ~ className () APPLE_KEXT_OVERRIDE;                     _OS_ADD_METHODS(className, dispatch)
_OS_ADD_OPERATOR_PROTO public:                                                         static void *operator new(size_t size);                         protected:                                                      static void operator delete(void *mem, size_t size);
_OSDeclareDefaultStructors(className, dispatch)         	OSDeclareCommonStructors(className, dispatch);              	public:                                                     	className (void);                                           	_OS_ADD_OPERATOR_PROTO                                          protected:
OSDeclareDefaultStructors(className) _OSDeclareDefaultStructors(className, )
OSDeclareDefaultStructorsWithDispatch(className) _OSDeclareDefaultStructors(className, dispatch)
_OSDeclareAbstractStructors(className, dispatch)        	OSDeclareCommonStructors(className, dispatch)                   private:                                                    	          	className (void);                                               protected:
OSDeclareAbstractStructors(className) _OSDeclareAbstractStructors(className, )                    	_OS_ADD_OPERATOR_PROTO
OSDeclareAbstractStructorsWithDispatch(className) _OSDeclareAbstractStructors(className, dispatch)            	_OS_ADD_OPERATOR_PROTO
_OSDeclareFinalStructors(className, dispatch)           	_OSDeclareDefaultStructors(className, dispatch)                 private:                                                    	void __OSFinalClass(void);                                      protected:
OSDeclareFinalStructors(className) _OSDeclareFinalStructors(className, )
OSDeclareFinalStructorsWithDispatch(className) _OSDeclareFinalStructors(className, dispatch)
OSMetaClassConstructorInit(className, superclassName,   	    init)                                                   	                           	className ::MetaClass::MetaClass()                          	: OSMetaClass(#className, className::superClass,            	                sizeof(className))                          	{ init; }
declareZone(className) static SECURITY_READ_ONLY_LATE(zone_t) className ## _zone;
OSMetaClassConstructorInitWithZone(className, superclassName, init, zflags)                           	declareZone(className)                                      	                           	className ::MetaClass::MetaClass()                          	: OSMetaClass(#className, className::superClass,            	                sizeof(className),                          	                &(className ## _zone),                      	                "iokit." #className, zflags)                	{ init; }
OSDefineMetaClassWithInit(className, superclassName,    	    init)                                                   	                                     	className ::MetaClass className ::gMetaClass;               	const OSMetaClass * const className ::metaClass =           	& className ::gMetaClass;                                   	const OSMetaClass * const className ::superClass =          	& superclassName ::gMetaClass;                              	                                	className :: className(const OSMetaClass *meta)             	: superclassName (meta) { }                                 	className ::~ className() { }                               	const OSMetaClass * className ::getMetaClass() const        	{ return &gMetaClass; }
OSDefineAbstractStructors(className, superclassName)        OSObject * className ::MetaClass::alloc() const { return NULL; }
OSDefineBasicStructors(className, superclassName)       	OSObject * className ::MetaClass::alloc() const             	{ return new className; }                                   	className :: className () : superclassName (&gMetaClass)    	{ gMetaClass.instanceConstructed(); }
OSDefineOperatorMethods(className) static KALLOC_TYPE_DEFINE(className ## _ktv, className,     	    KT_DEFAULT);                                            	void * className::operator new(size_t size) {               	  return OSObject_typed_operator_new(className ## _ktv,     	      size);                                                	}                                                           	void className::operator delete(void *mem, size_t size) {   	  return OSObject_typed_operator_delete(className ## _ktv,  	      mem, size);                                           	}
OSDefineOperatorMethodsWithZone(className) void * className :: operator new(size_t size) {             	    if (className ## _zone) {                               	        return zalloc_flags(className ## _zone,             	                        (zalloc_flags_t) (Z_WAITOK | Z_ZERO));	    } else {                                                	        return OSObject::operator new(size);                	    }                                                       	}                                                           	void className :: operator delete(void *mem, size_t size) { 	    if (className ## _zone) {                               	        kern_os_zfree(className ## _zone, mem, size);       	    } else {                                                	        return OSObject::operator delete(mem, size);        	    }                                                       	}
OSDefineDefaultStructors(className, superclassName)     	OSDefineBasicStructors(className, superclassName)           	OSDefineOperatorMethods(className)
OSDefineFinalStructors(className, superclassName)           OSDefineBasicStructors(className, superclassName)               void className ::__OSFinalClass(void) { }
OSDefineMetaClassAndStructorsWithInit(className, superclassName, init)                                   	OSDefineMetaClassWithInit(className, superclassName, init)  	OSMetaClassConstructorInit(className, superclassName, init) 	OSDefineDefaultStructors(className, superclassName)
OSDefineMetaClassAndStructorsWithInitAndZone(className, superclassName, init, zflags)                           	OSDefineMetaClassWithInit(className, superclassName, init)  	OSMetaClassConstructorInitWithZone(className,               	                superclassName, init, zflags)               	OSDefineBasicStructors(className, superclassName)           	OSDefineOperatorMethodsWithZone(className)
OSDefineMetaClassAndFinalStructorsWithInit(className, superclassName, init)                                   	OSDefineMetaClassWithInit(className, superclassName, init)  	OSMetaClassConstructorInit(className, superclassName, init) 	OSDefineFinalStructors(className, superclassName)           	OSDefineOperatorMethods(className)
OSDefineMetaClass(className, superclassName)            	OSDefineMetaClassWithInit(className, superclassName, )      	OSMetaClassConstructorInit(className, superclassName, )     	OSDefineOperatorMethods(className)
OSDefineMetaClassAndStructors(className, superclassName) 	OSDefineMetaClassAndStructorsWithInit(className,            	                superclassName, )
OSDefineMetaClassAndStructorsWithZone(className, superclassName, zflags)                                 	OSDefineMetaClassAndStructorsWithInitAndZone(className,     	                superclassName, , zflags)
OSDefineMetaClassAndAbstractStructors(className, superclassName)                                         	OSDefineMetaClassAndAbstractStructorsWithInit (className,   	                superclassName, )
OSDefineMetaClassAndFinalStructors(className, superclassName)                                         	OSDefineMetaClassAndFinalStructorsWithInit(className,       	                superclassName, )
OSDefineMetaClassAndFinalStructorsWithZone(className, superclassName, zflags)                                 	OSDefineMetaClassAndFinalStructorsWithInitAndZone(          	                className, superclassName, , zflags)
OSMetaClassDeclareReservedUsed(className, index)
OSMetaClassDeclareReservedUsedARM(className, x86index, armindex)
OSMetaClassDefineReservedUsed(className, index)
OSMetaClassDefineReservedUsedARM(className, x86index, armindex)
OSMetaClassDeclareReservedUsedX86 OSMetaClassDeclareReservedUnused
OSMetaClassDefineReservedUsedX86 OSMetaClassDefineReservedUnused
_OS_OSNUMBER_H None
_LIBKERN_OSOBJECT_H None
_OS_OSORDEREDSET_H None
XNU_LIBKERN_LIBKERN_CXX_OS_PTR_H None
_OS_OSSERIALIZE_H None
_OS_OSSET_H None
XNU_LIBKERN_LIBKERN_CXX_OS_SHARED_PTR_H None
_OS_OSSTRING_H None
_OS_OSSYMBOL_H None
_OS_OSUNSERIALIZE_H None
YYBISON 1
YYBISON_VERSION "2.3"
YYSKELETON_NAME "yacc.c"
YYPURE 1
YYLSP_NEEDED 0
yyparse OSUnserializeXMLparse
yylex OSUnserializeXMLlex
yyerror OSUnserializeXMLerror
yylval OSUnserializeXMLlval
yychar OSUnserializeXMLchar
yydebug OSUnserializeXMLdebug
yynerrs OSUnserializeXMLnerrs
ARRAY 258
BOOLEAN 259
DATA 260
DICTIONARY 261
IDREF 262
KEY 263
NUMBER 264
SET 265
STRING 266
SYNTAX_ERROR 267
MAX_OBJECTS 131071
MAX_REFED_OBJECTS 65535
YYSTYPE object_t *
YYPARSE_PARAM state
yyerror(s) OSUnserializeerror(STATE, (s))
malloc(size) malloc_impl(size)
malloc_type(type) kalloc_type(type, Z_SET_NOTEARLY)
free(addr) free_impl(addr)
free_type(type, addr)  kfree_type(type, addr)
realloc(addr, osize, nsize) realloc_impl(addr, osize, nsize)
YYFINAL 33
YYLAST 108
YYNTOKENS 19
YYNNTS 15
YYNRULES 32
YYNSTATES 40
YYUNDEFTOK 2
YYMAXUTOK 267
YYPACT_NINF -20
YYTABLE_NINF -1
YYEOF 0
YYACCEPT goto yyacceptlab
YYABORT goto yyabortlab
YYERROR goto yyerrorlab
YYFAIL goto yyerrlab
YYBACKUP(Token, Value)                                  do                                                                if (yychar == YYEMPTY && yylen == 1)                              {                                                                 yychar = (Token);                                               yylval = (Value);                                               yytoken = YYTRANSLATE (yychar);                                 YYPOPSTACK (1);                                                 goto yybackup;                                                }                                                             else                                                              {                                                                 yyerror (YY_("syntax error: cannot back up"));       YYERROR;                                                      }                                                           while (YYID (0))
YYTERROR 1
YYERRCODE 256
YYRHSLOC(Rhs, K) ((Rhs)[K])
TAG_MAX_LENGTH 32
TAG_MAX_ATTRIBUTES 32
TAG_BAD 0
TAG_START 1
TAG_END 2
TAG_EMPTY 3
TAG_IGNORE 4
DATA_ALLOC_SIZE 4096
_OS_OSVALUEOBJECT_H None
XNU_LIBKERN_LIBKERN_CXX_SAFE_ALLOCATION_H None
__COMPRESSION_H None
CA_INT 1ULL
CA_UUID_LEN 37
CA_PROCNAME_LEN 17
CA_UBSANBUF_LEN 256
CA_TEAMID_MAX_LEN 32
CA_SIGNINGID_MAX_LEN 128
CA_STATIC_STRING(len) ca_sstr[len]
CA_EVENT_TYPE(name) struct _ca_event_ ## name
CA_EVENT(name, ...) 	const char * _CA_EVENT_NAME_PREFIX(name) = _CA_EVENT_ORG #name "\0" _CA_FOREACH(_CA_STRINGIFY, _CA_NULL_TERMINATOR, _CA_STRINGIFY, ##__VA_ARGS__) "\0"; 	_Static_assert(sizeof(_CA_EVENT_ORG #name) <= 64, "CoreAnalytics event name ('" _CA_EVENT_ORG #name "') is too long"); 	CA_EVENT_TYPE(name) { 	        _CA_FOREACH(_CA_TYPE_DECLARATION, _CA_NULL_EPSILON, _CA_VARIABLE_DECLARATION, ##__VA_ARGS__) 	} __attribute__ ((packed))
CA_EVENT_ALLOCATE(name) core_analytics_allocate_event(sizeof(CA_EVENT_TYPE(name)), _CA_EVENT_NAME_PREFIX(name), (zalloc_flags_t)(Z_WAITOK | Z_ZERO | Z_NOFAIL))
CA_EVENT_ALLOCATE_FLAGS(name, flags) 	core_analytics_allocate_event(sizeof(CA_EVENT_TYPE(name)), _CA_EVENT_NAME_PREFIX(name), flags)
CA_EVENT_DEALLOCATE_WITH_NAME(event, name)         ({                                                         	kfree_data(event->data, sizeof(CA_EVENT_TYPE(name)));  	kfree_type(struct _ca_event, event);            })
CA_EVENT_SEND(event) core_analytics_send_event(event)
CA_EVENT_SEND_PREEMPTION_DISABLED(event) core_analytics_send_event_preemption_disabled(event)
_CA_NTH(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, 	    _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, 	    _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, 	    _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, 	    _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, N, ...) N
_CA_NULL_TERMINATOR "\0"
_CA_NULL_EPSILON None
_f0(f, ...)
_f1(fe, e, fo, x, ...) fo(x)
_f2(fe, e, fo, x, ...) fe(x) e _f1(fe, e, fo, __VA_ARGS__)
_f3(fe, e, fo, x, ...) fo(x) e _f2(fe, e, fo, __VA_ARGS__)
_f4(fe, e, fo, x, ...) fe(x) e _f3(fe, e, fo, __VA_ARGS__)
_f5(fe, e, fo, x, ...) fo(x) e _f4(fe, e, fo, __VA_ARGS__)
_f6(fe, e, fo, x, ...) fe(x) e _f5(fe, e, fo, __VA_ARGS__)
_f7(fe, e, fo, x, ...) fo(x) e _f6(fe, e, fo, __VA_ARGS__)
_f8(fe, e, fo, x, ...) fe(x) e _f7(fe, e, fo, __VA_ARGS__)
_f9(fe, e, fo, x, ...) fo(x) e _f8(fe, e, fo, __VA_ARGS__)
_f10(fe, e, fo, x, ...) fe(x) e _f9(fe, e, fo, __VA_ARGS__)
_f11(fe, e, fo, x, ...) fo(x) e _f10(fe, e, fo, __VA_ARGS__)
_f12(fe, e, fo, x, ...) fe(x) e _f11(fe, e, fo, __VA_ARGS__)
_f13(fe, e, fo, x, ...) fo(x) e _f12(fe, e, fo, __VA_ARGS__)
_f14(fe, e, fo, x, ...) fe(x) e _f13(fe, e, fo, __VA_ARGS__)
_f15(fe, e, fo, x, ...) fo(x) e _f14(fe, e, fo, __VA_ARGS__)
_f16(fe, e, fo, x, ...) fe(x) e _f15(fe, e, fo, __VA_ARGS__)
_f17(fe, e, fo, x, ...) fo(x) e _f16(fe, e, fo, __VA_ARGS__)
_f18(fe, e, fo, x, ...) fe(x) e _f17(fe, e, fo, __VA_ARGS__)
_f19(fe, e, fo, x, ...) fo(x) e _f18(fe, e, fo, __VA_ARGS__)
_f20(fe, e, fo, x, ...) fe(x) e _f19(fe, e, fo, __VA_ARGS__)
_f21(fe, e, fo, x, ...) fo(x) e _f20(fe, e, fo, __VA_ARGS__)
_f22(fe, e, fo, x, ...) fe(x) e _f21(fe, e, fo, __VA_ARGS__)
_f23(fe, e, fo, x, ...) fo(x) e _f22(fe, e, fo, __VA_ARGS__)
_f24(fe, e, fo, x, ...) fe(x) e _f23(fe, e, fo, __VA_ARGS__)
_f25(fe, e, fo, x, ...) fo(x) e _f24(fe, e, fo, __VA_ARGS__)
_f26(fe, e, fo, x, ...) fe(x) e _f25(fe, e, fo, __VA_ARGS__)
_f27(fe, e, fo, x, ...) fo(x) e _f26(fe, e, fo, __VA_ARGS__)
_f28(fe, e, fo, x, ...) fe(x) e _f27(fe, e, fo, __VA_ARGS__)
_f29(fe, e, fo, x, ...) fo(x) e _f28(fe, e, fo, __VA_ARGS__)
_f30(fe, e, fo, x, ...) fe(x) e _f29(fe, e, fo, __VA_ARGS__)
_f31(fe, e, fo, x, ...) fo(x) e _f30(fe, e, fo, __VA_ARGS__)
_f32(fe, e, fo, x, ...) fe(x) e _f31(fe, e, fo, __VA_ARGS__)
_f33(fe, e, fo, x, ...) fo(x) e _f32(fe, e, fo, __VA_ARGS__)
_f34(fe, e, fo, x, ...) fe(x) e _f33(fe, e, fo, __VA_ARGS__)
_f35(fe, e, fo, x, ...) fo(x) e _f34(fe, e, fo, __VA_ARGS__)
_f36(fe, e, fo, x, ...) fe(x) e _f35(fe, e, fo, __VA_ARGS__)
_f37(fe, e, fo, x, ...) fo(x) e _f36(fe, e, fo, __VA_ARGS__)
_f38(fe, e, fo, x, ...) fe(x) e _f37(fe, e, fo, __VA_ARGS__)
_f39(fe, e, fo, x, ...) fo(x) e _f38(fe, e, fo, __VA_ARGS__)
_f40(fe, e, fo, x, ...) fe(x) e _f39(fe, e, fo, __VA_ARGS__)
_f41(fe, e, fo, x, ...) fo(x) e _f40(fe, e, fo, __VA_ARGS__)
_f42(fe, e, fo, x, ...) fe(x) e _f41(fe, e, fo, __VA_ARGS__)
_f43(fe, e, fo, x, ...) fo(x) e _f42(fe, e, fo, __VA_ARGS__)
_f44(fe, e, fo, x, ...) fe(x) e _f43(fe, e, fo, __VA_ARGS__)
_f45(fe, e, fo, x, ...) fo(x) e _f44(fe, e, fo, __VA_ARGS__)
_f46(fe, e, fo, x, ...) fe(x) e _f45(fe, e, fo, __VA_ARGS__)
_f47(fe, e, fo, x, ...) fo(x) e _f46(fe, e, fo, __VA_ARGS__)
_f48(fe, e, fo, x, ...) fe(x) e _f47(fe, e, fo, __VA_ARGS__)
_f49(fe, e, fo, x, ...) fo(x) e _f48(fe, e, fo, __VA_ARGS__)
_f50(fe, e, fo, x, ...) fe(x) e _f49(fe, e, fo, __VA_ARGS__)
_f51(fe, e, fo, x, ...) fo(x) e _f50(fe, e, fo, __VA_ARGS__)
_f52(fe, e, fo, x, ...) fe(x) e _f51(fe, e, fo, __VA_ARGS__)
_f53(fe, e, fo, x, ...) fo(x) e _f52(fe, e, fo, __VA_ARGS__)
_f54(fe, e, fo, x, ...) fe(x) e _f53(fe, e, fo, __VA_ARGS__)
_f55(fe, e, fo, x, ...) fo(x) e _f54(fe, e, fo, __VA_ARGS__)
_f56(fe, e, fo, x, ...) fe(x) e _f55(fe, e, fo, __VA_ARGS__)
_f57(fe, e, fo, x, ...) fo(x) e _f56(fe, e, fo, __VA_ARGS__)
_f58(fe, e, fo, x, ...) fe(x) e _f57(fe, e, fo, __VA_ARGS__)
_f59(fe, e, fo, x, ...) fo(x) e _f58(fe, e, fo, __VA_ARGS__)
_f60(fe, e, fo, x, ...) fe(x) e _f59(fe, e, fo, __VA_ARGS__)
_f61(fe, e, fo, x, ...) fo(x) e _f60(fe, e, fo, __VA_ARGS__)
_f62(fe, e, fo, x, ...) fe(x) e _f61(fe, e, fo, __VA_ARGS__)
_f63(fe, e, fo, x, ...) fo(x) e _f62(fe, e, fo, __VA_ARGS__)
_f64(fe, e, fo, x, ...) fe(x) e _f63(fe, e, fo, __VA_ARGS__)
_f65(fe, e, fo, x, ...) fo(x) e _f64(fe, e, fo, __VA_ARGS__)
_f66(fe, e, fo, x, ...) fe(x) e _f65(fe, e, fo, __VA_ARGS__)
_f67(fe, e, fo, x, ...) fo(x) e _f66(fe, e, fo, __VA_ARGS__)
_f68(fe, e, fo, x, ...) fe(x) e _f67(fe, e, fo, __VA_ARGS__)
_f69(fe, e, fo, x, ...) fo(x) e _f68(fe, e, fo, __VA_ARGS__)
_f70(fe, e, fo, x, ...) fe(x) e _f69(fe, e, fo, __VA_ARGS__)
_CA_FOREACH(fe, e, fo, ...) _CA_NTH(__VA_ARGS__,     _f70, _f69, _f68, _f67, _f66, _f65, _f64, _f63, _f62, _f61,     _f60, _f59, _f58, _f57, _f56, _f55, _f54, _f53, _f52, _f51, _f50, _f49, _f48, _f47, _f46, _f45, _f44, _f43,     _f42, _f41, _f40, _f39, _f38, _f37, _f36, _f35, _f34, _f33, _f32, _f31, _f30, _f29, _f28, _f27, _f26, _f25,     _f24, _f23, _f22, _f21, _f20, _f19, _f18, _f17, _f16, _f15, _f14, _f13, _f12, _f11, _f10, _f9, _f8, _f7,     _f6, _f5, _f4, _f3, _f2, _f1, _f0)(fe, e, fo, ##__VA_ARGS__)
_CA_TYPE_DECLARATION(T) __typeof__(T)
_CA_STRINGIFY(T) #T
_CA_STRINGIFY_EXPAND(T) _CA_STRINGIFY(T)
_CA_VARIABLE_DECLARATION(T) T;
_CA_EVENT_NAME_PREFIX(name) _ca_event_format_##name
_CA_EVENT_ORG "com.apple.xnu."
_COREANALYTICS_SHIM_H None
CORE_ANALYTICS_FUNCTIONS_TABLE_VERSION 1
__CORETRUST_H None
XNU_SUPPORTS_CORETRUST_AMFI 1
XNU_SUPPORTS_CORETRUST_LOCAL_SIGNING 1
XNU_SUPPORTS_CORETRUST_PROVISIONING_PROFILE 1
XNU_SUPPORTS_CORETRUST_MULTI_STEP_AMFI 1
_AES_H None
AES_BLOCK_SIZE 16
aes_ret int
aes_good 0
aes_error -1
aes_rval aes_ret
_CRYPTO_AESXTS_H None
_CHACHA20POLY1305_H None
_CRYPTO_CRYPTO_H_ None
_CRYPTO_CRYPTO_INTERNAL_H_ None
_CRYPTO_DES_H None
DES_LONG u_int32_t
des_set_key des_ecb_key_sched
DES_ENCRYPT 1
DES_DECRYPT 0
_CRYPTO_MD5_H_ None
MD5_DIGEST_LENGTH 16
_RAND_H None
_CRYPTO_REGISTER_CRYPTO_H_ None
_RSA_H None
RSA_MAX_KEY_BITSIZE 4096
_CRYPTO_SHA1_H_ None
SHA_DIGEST_LENGTH 20
SHA1_RESULTLEN SHA_DIGEST_LENGTH
sha1_init(c) SHA1Init(c)
sha1_loop(c, b, l)      SHA1Update(c, b, l)
sha1_result(c, b)       SHA1Final(b, c)
_CRYPTO_SHA2_H__ None
SHA256_BLOCK_LENGTH CCSHA256_BLOCK_SIZE
SHA256_DIGEST_LENGTH CCSHA256_OUTPUT_SIZE
SHA384_BLOCK_LENGTH CCSHA512_BLOCK_SIZE
SHA384_DIGEST_LENGTH CCSHA384_OUTPUT_SIZE
SHA512_BLOCK_LENGTH CCSHA512_BLOCK_SIZE
SHA512_DIGEST_LENGTH CCSHA512_OUTPUT_SIZE
_OS_OSBYTEORDERI386_H None
_OS__OSBYTEORDERI386_H None
__IMAGE4_DLXK_API_H None
image4_xnu_callable(_f, _v, _rv, ...) ({ 	const image4_dlxk_interface_t *dlxk = NULL; 	dlxk = image4_dlxk_get(_v); 	dlxk ? (dlxk->dlxk_ ## _f(__VA_ARGS__)) : (_rv); })
image4_xnu_callable_ptr(_f, _v, ...) 	image4_xnu_callable(_f, _v, NULL, ## __VA_ARGS__)
image4_xnu_callable_posix(_f, _v, ...) 	image4_xnu_callable(_f, _v, ENOSYS, ## __VA_ARGS__)
image4_xnu_callable_void(_f, _v, ...) ({ 	const image4_dlxk_interface_t *dlxk = NULL; 	dlxk = image4_dlxk_get(_v); 	if (dlxk) { 	    dlxk->dlxk_ ## _f(__VA_ARGS__); 	} })
image4_xnu_const(_s, _v) ({ 	const image4_dlxk_interface_t *dlxk = NULL; 	dlxk = image4_dlxk_get(_v); 	dlxk ? (dlxk->dlxk_ ## _s) : NULL; })
IMAGE4_COPROCESSOR_HOST image4_xnu_const(coprocessor_host, 0)
IMAGE4_COPROCESSOR_AP image4_xnu_const(coprocessor_ap, 0)
IMAGE4_COPROCESSOR_AP_LOCAL image4_xnu_const(coprocessor_ap_local, 0)
IMAGE4_COPROCESSOR_CRYPTEX1 image4_xnu_const(coprocessor_cryptex1, 0)
IMAGE4_COPROCESSOR_SEP image4_xnu_const(coprocessor_sep, 0)
IMAGE4_COPROCESSOR_X86 image4_xnu_const(coprocessor_x86, 0)
IMAGE4_COPROCESSOR_BOOTPC image4_xnu_const(coprocessor_bootpc, 1)
IMAGE4_COPROCESSOR_VMA2 image4_xnu_const(coprocessor_vma2, 2)
IMAGE4_COPROCESSOR_VMA3 image4_xnu_const(coprocessor_vma3, 2)
image4_coprocessor_resolve_from_manifest(...) image4_xnu_callable_posix(coprocessor_resolve_from_manifest, 	    1, ## __VA_ARGS__)
IMAGE4_TRUST_EVALUATION_EXEC image4_xnu_const(trust_evaluation_exec, 0)
IMAGE4_TRUST_EVALUATION_PREFLIGHT image4_xnu_const(trust_evaluation_preflight, 0)
IMAGE4_TRUST_EVALUATION_SIGN image4_xnu_const(trust_evaluation_sign, 0)
IMAGE4_TRUST_EVALUATION_BOOT image4_xnu_const(trust_evaluation_boot, 0)
IMAGE4_TRUST_EVALUATION_NORMALIZE image4_xnu_const(trust_evaluation_boot, 1)
_image4_environment_init(...) image4_xnu_callable_ptr(environment_init, 0, ## __VA_ARGS__)
image4_environment_new(...) image4_xnu_callable_ptr(environment_new, 0, ## __VA_ARGS__)
image4_environment_set_secure_boot(...) image4_xnu_callable_void(environment_set_secure_boot, 0, ## __VA_ARGS__)
image4_environment_set_callbacks(...) image4_xnu_callable_void(environment_set_callbacks, 0, ## __VA_ARGS__)
image4_environment_identify(...) image4_xnu_callable_posix(environment_identify, 1, ## __VA_ARGS__)
image4_environment_get_digest_info(...) image4_xnu_callable_posix(environment_get_digest_info, 1, ## __VA_ARGS__)
image4_environment_copy_nonce_digest(...) image4_xnu_callable_posix(environment_copy_nonce_digest, 0, ## __VA_ARGS__)
image4_environment_roll_nonce(...) image4_xnu_callable_posix(environment_roll_nonce, 0, ## __VA_ARGS__)
image4_environment_generate_nonce_proposal(...) image4_xnu_callable_posix(environment_generate_nonce_proposal, 	    0, ## __VA_ARGS__)
image4_environment_commit_nonce_proposal(...) image4_xnu_callable_posix(environment_commit_nonce_proposal, 	    0, ## __VA_ARGS__)
image4_environment_get_nonce_handle(...) image4_xnu_callable_posix(environment_get_nonce_handle, 0, ## __VA_ARGS__)
image4_environment_flash(...) image4_xnu_callable_posix(environment_flash, 1, ## __VA_ARGS__)
image4_environment_destroy(...) image4_xnu_callable_void(environment_destroy, 0, ## __VA_ARGS__)
_image4_trust_init(...) image4_xnu_callable_ptr(trust_init, 0, ## __VA_ARGS__)
image4_trust_new(...) image4_xnu_callable_ptr(trust_new, 0, ## __VA_ARGS__)
image4_trust_set_payload(...) image4_xnu_callable_void(trust_set_payload, 0, ## __VA_ARGS__)
image4_trust_set_booter(...) image4_xnu_callable_void(trust_set_booter, 0, ## __VA_ARGS__)
image4_trust_set_result_buffer(...) image4_xnu_callable_void(trust_set_result_buffer, 2, ## __VA_ARGS__)
image4_trust_record_property_bool(...) image4_xnu_callable_void(trust_record_property_bool, 0, ## __VA_ARGS__)
image4_trust_record_property_integer(...) image4_xnu_callable_void(trust_record_property_integer, 0, ## __VA_ARGS__)
image4_trust_record_property_data(...) image4_xnu_callable_void(trust_record_property_data, 0, ## __VA_ARGS__)
image4_trust_evaluate(...) image4_xnu_callable_void(trust_evaluate, 0, ## __VA_ARGS__)
image4_trust_destroy(...) image4_xnu_callable_void(trust_destroy, 0, ## __VA_ARGS__)
image4_cs_trap_resolve_handler(...) image4_xnu_callable_ptr(cs_trap_resolve_handler, 0, ## __VA_ARGS__)
image4_cs_trap_vector_size(...) image4_xnu_callable(cs_trap_vector_size, 0, -1, ## __VA_ARGS__)
__IMAGE4_DLXK_H None
__IMAGE4_XNU_INDIRECT 1
__IMAGE4_DLXK_INTERFACE_H None
image4_xnu_dlxk_type(_s) _image4_ ## _s ## _dlxk_t
image4_xnu_dlxk_fld(_s) dlxk_ ## _s
image4_xnu_dlxk_fld_decl(_s) image4_xnu_dlxk_type(_s) image4_xnu_dlxk_fld(_s)
__IMG4_INTERFACE_H None
_OS_OSBYTEORDERMACHINE_H None
qDEBUG 0
kIOHDIXControllerClassName "IOHDIXController"
kDIRootImageKey "di-root-image"
kDIRootImageRemovableKey "di-root-removable"
kDIRootImageResultKey "di-root-image-result"
kDIRootImageDevNameKey "di-root-image-devname"
kDIRootImageDevTKey "di-root-image-devt"
kDIRootRamFileKey "di-root-ram-file"
kDIMatchQuiesceTimeout 30ull
__DINETBOOKHOOK_H__ None
ROUNDUP(a, b) (((a) + ((b) - 1)) & (~((b) - 1)))
kIOCoreDumpPrebootPath "/private/preboot/kernelcore"
SYSTEM_NVRAM_PREFIX "40A0DDD2-77F8-4392-B4A3-1E7304206516:"
HFS_IOCTL_VOLUME_STATUS _IOR('h', 24, u_int32_t)
XNU_LIBKERN_LIBKERN_CXX_BOUNDED_ARRAY_H None
XNU_LIBKERN_LIBKERN_CXX_BOUNDED_ARRAY_REF_H None
XNU_LIBKERN_LIBKERN_CXX_BOUNDED_PTR_H None
XNU_LIBKERN_LIBKERN_CXX_BOUNDED_PTR_FWD_H None
_IOKERNELREPORTSTRUCTS_H_ None
kIOReportLegendPublicKey "IOReportLegendPublic"
kIOReportLegendKey "IOReportLegend"
kIOReportLegendChannelsKey "IOReportChannels"
kIOReportLegendGroupNameKey "IOReportGroupName"
kIOReportLegendSubGroupNameKey "IOReportSubGroupName"
kIOReportLegendInfoKey "IOReportChannelInfo"
kIOReportLegendUnitKey "IOReportChannelUnit"
kIOReportLegendConfigKey "IOReportChannelConfig"
kIOReportLegendStateNamesKey "IOReportChannelStateNames"
kIOReportChannelIDIdx 0
kIOReportChannelTypeIdx 1
kIOReportChannelNameIdx 2
kIOHistogramScaleLinear 0
kIOHistogramScaleExponential 1
_IOKIT_IOKITKEYS_H None
kIOKitBuildVersionKey "IOKitBuildVersion"
kIOKitDiagnosticsKey "IOKitDiagnostics"
kIORegistryPlanesKey "IORegistryPlanes"
kIOCatalogueKey "IOCatalogue"
kIOServicePlane "IOService"
kIOPowerPlane "IOPower"
kIODeviceTreePlane "IODeviceTree"
kIOAudioPlane "IOAudio"
kIOFireWirePlane "IOFireWire"
kIOUSBPlane "IOUSB"
kIORegistryEntryIDKey "IORegistryEntryID"
kIORegistryEntryPropertyKeysKey "IORegistryEntryPropertyKeys"
kIORegistryEntryAllowableSetPropertiesKey "IORegistryEntryAllowableSetProperties"
kIORegistryEntryDefaultLockingSetPropertiesKey "IORegistryEntryDefaultLockingSetProperties"
kIOServiceClass "IOService"
kIOResourcesClass "IOResources"
kIOClassKey "IOClass"
kIOProbeScoreKey "IOProbeScore"
kIOKitDebugKey "IOKitDebug"
kIOUserClassKey "IOUserClass"
kIOUserClassesKey "IOUserClasses"
kIOSupportedPropertiesKey "IOSupportedProperties"
kIOUserServicePropertiesKey "IOUserServiceProperties"
kIOProviderClassKey "IOProviderClass"
kIONameMatchKey "IONameMatch"
kIOPropertyMatchKey "IOPropertyMatch"
kIOPropertyExistsMatchKey "IOPropertyExistsMatch"
kIOPathMatchKey "IOPathMatch"
kIOLocationMatchKey "IOLocationMatch"
kIOParentMatchKey "IOParentMatch"
kIOResourceMatchKey "IOResourceMatch"
kIOResourceMatchedKey "IOResourceMatched"
kIOMatchedServiceCountKey "IOMatchedServiceCountMatch"
kIONameMatchedKey "IONameMatched"
kIOMatchCategoryKey "IOMatchCategory"
kIODefaultMatchCategoryKey "IODefaultMatchCategory"
kIOMatchedPersonalityKey "IOMatchedPersonality"
kIORematchPersonalityKey "IORematchPersonality"
kIORematchCountKey "IORematchCount"
kIODEXTMatchCountKey "IODEXTMatchCount"
kIOUserClientEntitlementsKey "IOUserClientEntitlements"
kIOServiceDEXTEntitlementsKey "IOServiceDEXTEntitlements"
kIODriverKitEntitlementKey "com.apple.developer.driverkit"
kIODriverKitUserClientEntitlementsKey "com.apple.developer.driverkit.userclient-access"
kIODriverKitRequiredEntitlementsKey "com.apple.private.driverkit.driver-access"
kIODriverKitTestDriverEntitlementKey "com.apple.private.driverkit.test-driver"
kIODriverKitUserClientEntitlementAllowAnyKey "com.apple.developer.driverkit.allow-any-userclient-access"
kIODriverKitUserClientEntitlementAdministratorKey "com.apple.developer.driverkit.administrator"
kIODriverKitUserClientEntitlementCommunicatesWithDriversKey "com.apple.developer.driverkit.communicates-with-drivers"
kIODriverKitUserClientEntitlementAllowThirdPartyUserClientsKey "com.apple.developer.driverkit.allow-third-party-userclients"
kIODriverKitUSBTransportEntitlementKey "com.apple.developer.driverkit.transport.usb"
kIODriverKitHIDTransportEntitlementKey "com.apple.developer.driverkit.transport.hid"
kIODriverKitHIDFamilyDeviceEntitlementKey "com.apple.developer.driverkit.family.hid.device"
kIODriverKitHIDFamilyEventServiceEntitlementKey "com.apple.developer.driverkit.family.hid.eventservice"
kIODriverKitTransportBuiltinEntitlementKey "com.apple.developer.driverkit.builtin"
kIONVRAMReadAccessKey "com.apple.private.iokit.nvram-read-access"
kIONVRAMWriteAccessKey "com.apple.private.iokit.nvram-write-access"
kIOResourcesSetPropertyKey "com.apple.private.iokit.ioresources.setproperty"
kIONVRAMSystemAllowKey "com.apple.private.iokit.system-nvram-allow"
kIOMatchDeferKey "IOMatchDefer"
kIOAllCPUInitializedKey "IOAllCPUInitialized"
kIOUserClientClassKey "IOUserClientClass"
kIOMapperIDKey "IOMapperID"
kIOExcludeListBundleID "com.apple.driver.KextExcludeList"
kIOUserClientCrossEndianKey "IOUserClientCrossEndian"
kIOUserClientCrossEndianCompatibleKey "IOUserClientCrossEndianCompatible"
kIOUserClientSharedInstanceKey "IOUserClientSharedInstance"
kIOUserClientMessageAppSuspendedKey "IOUserClientMessageAppSuspended"
kIOUserClientDefaultLockingKey "IOUserClientDefaultLocking"
kIOUserClientDefaultLockingSetPropertiesKey "IOUserClientDefaultLockingSetProperties"
kIOUserClientDefaultLockingSingleThreadExternalMethodKey "IOUserClientDefaultLockingSingleThreadExternalMethod"
kIOUserClientCreatorKey "IOUserClientCreator"
kIOUserServerCDHashKey "IOUserServerCDHash"
kIOUserUserClientKey "IOUserUserClient"
kIOUserServerOneProcessKey "IOUserServerOneProcess"
kIOUserServerPreserveUserspaceRebootKey "IOUserServerPreserveUserspaceReboot"
kIOPublishNotification "IOServicePublish"
kIOFirstPublishNotification "IOServiceFirstPublish"
kIOMatchedNotification "IOServiceMatched"
kIOFirstMatchNotification "IOServiceFirstMatch"
kIOTerminatedNotification "IOServiceTerminate"
kIOWillTerminateNotification "IOServiceWillTerminate"
kIOGeneralInterest "IOGeneralInterest"
kIOBusyInterest "IOBusyInterest"
kIOAppPowerStateInterest "IOAppPowerStateInterest"
kIOPriorityPowerStateInterest "IOPriorityPowerStateInterest"
kIOPlatformDeviceMessageKey "IOPlatformDeviceMessage"
kIOCFPlugInTypesKey "IOCFPlugInTypes"
kIOCompatibilityMatchKey "IOCompatibilityMatch"
kIOCompatibilityPropertiesKey "IOCompatibilityProperties"
kIOPathKey "IOPath"
kIOCommandPoolSizeKey "IOCommandPoolSize"
kIOMaximumPriorityCountKey "IOMaximumPriorityCount"
kIOMaximumBlockCountReadKey "IOMaximumBlockCountRead"
kIOMaximumBlockCountWriteKey "IOMaximumBlockCountWrite"
kIOMaximumByteCountReadKey "IOMaximumByteCountRead"
kIOMaximumByteCountWriteKey "IOMaximumByteCountWrite"
kIOMaximumSegmentCountReadKey "IOMaximumSegmentCountRead"
kIOMaximumSegmentCountWriteKey "IOMaximumSegmentCountWrite"
kIOMaximumSegmentByteCountReadKey "IOMaximumSegmentByteCountRead"
kIOMaximumSegmentByteCountWriteKey "IOMaximumSegmentByteCountWrite"
kIOMinimumSegmentAlignmentByteCountKey "IOMinimumSegmentAlignmentByteCount"
kIOMaximumSegmentAddressableBitCountKey "IOMaximumSegmentAddressableBitCount"
kIOMinimumSaturationByteCountKey "IOMinimumSaturationByteCount"
kIOMaximumSwapWriteKey "IOMaximumSwapWrite"
kIOIconKey "IOIcon"
kIOBundleResourceFileKey "IOBundleResourceFile"
kIOBusBadgeKey "IOBusBadge"
kIODeviceIconKey "IODeviceIcon"
kIOPlatformSerialNumberKey "IOPlatformSerialNumber"
kIOPlatformUUIDKey "IOPlatformUUID"
kIONVRAMBootArgsKey "boot-args"
kIONVRAMDeletePropertyKey "IONVRAM-DELETE-PROPERTY"
kIONVRAMSyncNowPropertyKey "IONVRAM-SYNCNOW-PROPERTY"
kIONVRAMActivateCSRConfigPropertyKey "IONVRAM-ARMCSR-PROPERTY"
kIODTNVRAMPanicInfoKey "aapl,panic-info"
kIONVRAMDeletePropertyKeyWRet "IONVRAM-DELETEWRET-PROPERTY"
kIOBootDeviceKey "IOBootDevice"
kIOBootDevicePathKey "IOBootDevicePath"
kIOBootDeviceSizeKey "IOBootDeviceSize"
kOSBuildVersionKey "OS Build Version"
kIOStateNotificationItemCreateKey "com.apple.iokit.statenotification.create"
kIOStateNotificationItemSetKey "com.apple.iokit.statenotification.set"
kIOStateNotificationItemCopyKey "com.apple.iokit.statenotification.copy"
kIOStateNotificationNameKey "com.apple.iokit.statenotification.name"
kIOStateNotificationEntitlementSetKey "com.apple.iokit.statenotification.entitlement-set"
kIOStateNotificationEntitlementGetKey "com.apple.iokit.statenotification.entitlement-get"
kIOSystemStateClamshellKey "com.apple.iokit.pm.clamshell"
kIOSystemStateSleepDescriptionKey "com.apple.iokit.pm.sleepdescription"
kIOSystemStateSleepDescriptionReasonKey "com.apple.iokit.pm.sleepreason"
kIOSystemStateSleepDescriptionHibernateStateKey "com.apple.iokit.pm.hibernatestate"
kIOSystemStateWakeDescriptionKey "com.apple.iokit.pm.wakedescription"
kIOSystemStateWakeDescriptionWakeReasonKey "com.apple.iokit.pm.wakereason"
kIOSystemStateWakeDescriptionContinuousTimeOffsetKey "com.apple.iokit.pm.wakedescription.continuous-time-offset"
kIOSystemStateHaltDescriptionKey "com.apple.iokit.pm.haltdescription"
kIOSystemStateHaltDescriptionHaltStateKey "com.apple.iokit.pm.haltstate"
kIOSystemStatePowerSourceDescriptionKey "com.apple.iokit.pm.powersourcedescription"
kIOSystemStatePowerSourceDescriptionACAttachedKey "com.apple.iokit.pm.acattached"
_IOREPORT_TYPES_H_ None
IOR_VALUES_PER_ELEMENT 4
kIOReportInvalidIntValue INT64_MIN
kIOReportInvalidCategory UINT16_MAX
__IOR_lshiftchr(c, chshift)     ((uint64_t)(c) << (8*(chshift)))
IOREPORT_MAKEID(A, B, C, D, E, F, G, H)     (__IOR_lshiftchr(A, 7) | __IOR_lshiftchr(B, 6) | __IOR_lshiftchr(C, 5)     | __IOR_lshiftchr(D, 4) | __IOR_lshiftchr(E, 3) | __IOR_lshiftchr(F, 2)     | __IOR_lshiftchr(G, 1) | __IOR_lshiftchr(H, 0))
__IOR_MAKEUNIT(quantity, scale) 	(((IOReportUnit)quantity << 56) | (uint64_t)scale)
kIOReportScaleConstMask 0x000000007fffffff
kIOReportExpZeroOffset -(kIOReportExpBase)
kIOReportScaleSIShift 32
kIOReportScaleSIMask 0x000000ff00000000
kIOReportScaleIECShift 40
kIOReportScaleIECMask 0x0000ff0000000000
kIOReportCardinalShift 48
kIOReportCardinalMask 0x00ff000000000000
kIOReportScaleUnity 0
kIOReportScaleBits kIOReportScaleUnity
kIOReportUnitNone __IOR_MAKEUNIT(kIOReportQuantityUndefined,  	                                          kIOReportScaleUnity)
kIOReportUnit_s __IOR_MAKEUNIT(kIOReportQuantityTime,  	                                       kIOReportScaleUnity)
kIOReportUnit_ms __IOR_MAKEUNIT(kIOReportQuantityTime,  	                                       kIOReportScaleMilli)
kIOReportUnit_us __IOR_MAKEUNIT(kIOReportQuantityTime,  	                                       kIOReportScaleMicro)
kIOReportUnit_ns __IOR_MAKEUNIT(kIOReportQuantityTime,  	                                       kIOReportScaleNano)
kIOReportUnit_J __IOR_MAKEUNIT(kIOReportQuantityEnergy,  	                                       kIOReportScaleUnity)
kIOReportUnit_mJ __IOR_MAKEUNIT(kIOReportQuantityEnergy,  	                                       kIOReportScaleMilli)
kIOReportUnit_uJ __IOR_MAKEUNIT(kIOReportQuantityEnergy,  	                                       kIOReportScaleMicro)
kIOReportUnit_nJ __IOR_MAKEUNIT(kIOReportQuantityEnergy,  	                                       kIOReportScaleNano)
kIOReportUnit_pJ __IOR_MAKEUNIT(kIOReportQuantityEnergy,  	                                       kIOReportScalePico)
kIOReportUnitHWTicks __IOR_MAKEUNIT(kIOReportQuantityTime,  	                                       kIOReportScaleMachHWTicks)
kIOReportUnit24MHzTicks __IOR_MAKEUNIT(kIOReportQuantityTime,  	                                       kIOReportScale24MHz)
kIOReportUnit1GHzTicks __IOR_MAKEUNIT(kIOReportQuantityTime,  	                                       kIOReportScale1GHz)
kIOReportUnitBits __IOR_MAKEUNIT(kIOReportQuantityData,  	                                        kIOReportScaleBits)
kIOReportUnitBytes __IOR_MAKEUNIT(kIOReportQuantityData,  	                                        kIOReportScaleBytes)
kIOReportUnit_KiB __IOR_MAKEUNIT(kIOReportQuantityData,  	                                       kIOReportScaleKiBytes)
kIOReportUnit_MiB __IOR_MAKEUNIT(kIOReportQuantityData,  	                                       kIOReportScaleMiBytes)
kIOReportUnit_GiB __IOR_MAKEUNIT(kIOReportQuantityData,  	                                       kIOReportScaleGiBytes)
kIOReportUnit_TiB __IOR_MAKEUNIT(kIOReportQuantityData,  	                                       kIOReportScaleTiBytes)
kIOReportUnitEvents __IOR_MAKEUNIT(kIOReportQuantityEventCount,  	                                       kIOReportScaleUnity)
kIOReportUnitPackets __IOR_MAKEUNIT(kIOReportQuantityPacketCount,  	                                       kIOReportScaleUnity)
kIOReportUnitInstrs __IOR_MAKEUNIT(kIOReportQuantityCPUInstrs,  	                                       kIOReportScaleUnity)
kIOReportUnit_KI __IOR_MAKEUNIT(kIOReportQuantityCPUInstrs,  	                                       kIOReportScaleKilo)
kIOReportUnit_MI __IOR_MAKEUNIT(kIOReportQuantityCPUInstrs,  	                                       kIOReportScaleMega)
kIOReportUnit_GI __IOR_MAKEUNIT(kIOReportQuantityCPUInstrs,  	                                       kIOReportScaleGiga)
__IOKIT_IORETURN_H None
sys_iokit err_system(0x38)
sub_iokit_common err_sub(0)
sub_iokit_usb err_sub(1)
sub_iokit_firewire err_sub(2)
sub_iokit_block_storage err_sub(4)
sub_iokit_graphics err_sub(5)
sub_iokit_networking err_sub(6)
sub_iokit_bluetooth err_sub(8)
sub_iokit_pmu err_sub(9)
sub_iokit_acpi err_sub(10)
sub_iokit_smbus err_sub(11)
sub_iokit_ahci err_sub(12)
sub_iokit_powermanagement err_sub(13)
sub_iokit_hidsystem err_sub(14)
sub_iokit_scsi err_sub(16)
sub_iokit_usbaudio err_sub(17)
sub_iokit_wirelesscharging err_sub(18)
sub_iokit_nvme err_sub(28)
sub_iokit_thunderbolt err_sub(29)
sub_iokit_graphics_acceleration err_sub(30)
sub_iokit_keystore err_sub(31)
sub_iokit_smc err_sub(32)
sub_iokit_apfs err_sub(33)
sub_iokit_acpiec err_sub(34)
sub_iokit_timesync_avb err_sub(35)
sub_iokit_platform err_sub(0x2A)
sub_iokit_audio_video err_sub(0x45)
sub_iokit_cec err_sub(0x46)
sub_iokit_arc err_sub(0x47)
sub_iokit_baseband err_sub(0x80)
sub_iokit_HDA err_sub(0xFE)
sub_iokit_hsic err_sub(0x147)
sub_iokit_sdio err_sub(0x174)
sub_iokit_wlan err_sub(0x208)
sub_iokit_appleembeddedsleepwakehandler err_sub(0x209)
sub_iokit_appleppm err_sub(0x20A)
sub_iokit_vendor_specific err_sub(-2)
sub_iokit_reserved err_sub(-1)
iokit_common_err(return )          (sys_iokit|sub_iokit_common|return)
iokit_family_err(sub, return )      (sys_iokit|sub|return)
iokit_vendor_specific_err(return ) (sys_iokit|sub_iokit_vendor_specific|return)
kIOReturnSuccess KERN_SUCCESS
kIOReturnError iokit_common_err(0x2bc)
kIOReturnNoMemory iokit_common_err(0x2bd)
kIOReturnNoResources iokit_common_err(0x2be)
kIOReturnIPCError iokit_common_err(0x2bf)
kIOReturnNoDevice iokit_common_err(0x2c0)
kIOReturnNotPrivileged iokit_common_err(0x2c1)
kIOReturnBadArgument iokit_common_err(0x2c2)
kIOReturnLockedRead iokit_common_err(0x2c3)
kIOReturnLockedWrite iokit_common_err(0x2c4)
kIOReturnExclusiveAccess iokit_common_err(0x2c5)
kIOReturnBadMessageID iokit_common_err(0x2c6)
kIOReturnUnsupported iokit_common_err(0x2c7)
kIOReturnVMError iokit_common_err(0x2c8)
kIOReturnInternalError iokit_common_err(0x2c9)
kIOReturnIOError iokit_common_err(0x2ca)
kIOReturnCannotLock iokit_common_err(0x2cc)
kIOReturnNotOpen iokit_common_err(0x2cd)
kIOReturnNotReadable iokit_common_err(0x2ce)
kIOReturnNotWritable iokit_common_err(0x2cf)
kIOReturnNotAligned iokit_common_err(0x2d0)
kIOReturnBadMedia iokit_common_err(0x2d1)
kIOReturnStillOpen iokit_common_err(0x2d2)
kIOReturnRLDError iokit_common_err(0x2d3)
kIOReturnDMAError iokit_common_err(0x2d4)
kIOReturnBusy iokit_common_err(0x2d5)
kIOReturnTimeout iokit_common_err(0x2d6)
kIOReturnOffline iokit_common_err(0x2d7)
kIOReturnNotReady iokit_common_err(0x2d8)
kIOReturnNotAttached iokit_common_err(0x2d9)
kIOReturnNoChannels iokit_common_err(0x2da)
kIOReturnNoSpace iokit_common_err(0x2db)
kIOReturnPortExists iokit_common_err(0x2dd)
kIOReturnCannotWire iokit_common_err(0x2de)
kIOReturnNoInterrupt iokit_common_err(0x2df)
kIOReturnNoFrames iokit_common_err(0x2e0)
kIOReturnMessageTooLarge iokit_common_err(0x2e1)
kIOReturnNotPermitted iokit_common_err(0x2e2)
kIOReturnNoPower iokit_common_err(0x2e3)
kIOReturnNoMedia iokit_common_err(0x2e4)
kIOReturnUnformattedMedia iokit_common_err(0x2e5)
kIOReturnUnsupportedMode iokit_common_err(0x2e6)
kIOReturnUnderrun iokit_common_err(0x2e7)
kIOReturnOverrun iokit_common_err(0x2e8)
kIOReturnDeviceError iokit_common_err(0x2e9)
kIOReturnNoCompletion iokit_common_err(0x2ea)
kIOReturnAborted iokit_common_err(0x2eb)
kIOReturnNoBandwidth iokit_common_err(0x2ec)
kIOReturnNotResponding iokit_common_err(0x2ed)
kIOReturnIsoTooOld iokit_common_err(0x2ee)
kIOReturnIsoTooNew iokit_common_err(0x2ef)
kIOReturnNotFound iokit_common_err(0x2f0)
kIOReturnInvalid iokit_common_err(0x1)
_IORPC_H None
__IOKIT_IOTYPES_H None
IOKIT 1
__IOKIT_PORTS_DEFINED__ None
LIBKERN_OSNUMBER_FLOAT_SUPPORT 1
_KERN_MACRO_HELP_H_ None
MACRO_BEGIN do {
MACRO_END } while (NEVER)
MACRO_RETURN if (ALWAYS) return
XNU_LIBKERN_LIBKERN_CXX_OS_BOUNDED_ARRAY_H None
XNU_LIBKERN_LIBKERN_CXX_OS_BOUNDED_ARRAY_REF_H None
XNU_LIBKERN_LIBKERN_CXX_OS_BOUNDED_PTR_H None
XNU_LIBKERN_LIBKERN_CXX_OS_BOUNDED_PTR_FWD_H None
_KERN_QUEUE_H_ None
__queue_element_linkage_invalid(e) ml_fatal_trap_invalid_list_linkage((unsigned long)(e))
qe_element(qe, type, field) __container_of(qe, type, field)
qe_foreach(qe, head) 	for (qe = (head)->next; qe != (head); qe = (qe)->next)
qe_foreach_safe(qe, head) 	for (queue_entry_t _ne = ((head)->next)->next, 	         __ ## qe ## _unused_shadow __unused = (qe = (head)->next); 	     qe != (head); 	     qe = _ne, _ne = (qe)->next)
qe_foreach_element(elt, head, field) 	for (elt = qe_element((head)->next, typeof(*(elt)), field); 	     &((elt)->field) != (head); 	     elt = qe_element((elt)->field.next, typeof(*(elt)), field))
qe_foreach_element_safe(elt, head, field) 	for (typeof(*(elt)) *_nelt = qe_element(((head)->next)->next, typeof(*(elt)), field), 	     *__ ## elt ## _unused_shadow __unused = 	         (elt = qe_element((head)->next, typeof(*(elt)), field)); 	     &((elt)->field) != (head); 	     elt = _nelt, _nelt = qe_element((elt)->field.next, typeof(*(elt)), field))
qe_dequeue_head(head, type, field) ({ 	queue_entry_t _tmp_entry = dequeue_head((head)); 	type *_tmp_element = (type*) NULL; 	if (_tmp_entry != (queue_entry_t) NULL) 	        _tmp_element = qe_element(_tmp_entry, type, field); 	_tmp_element; })
qe_dequeue_tail(head, type, field) ({ 	queue_entry_t _tmp_entry = dequeue_tail((head)); 	type *_tmp_element = (type*) NULL; 	if (_tmp_entry != (queue_entry_t) NULL) 	        _tmp_element = qe_element(_tmp_entry, type, field); 	_tmp_element; })
qe_queue_first(head, type, field) ({ 	queue_entry_t _tmp_entry = queue_first((head)); 	type *_tmp_element = (type*) NULL; 	if (_tmp_entry != (queue_entry_t) head) 	        _tmp_element = qe_element(_tmp_entry, type, field); 	_tmp_element; })
qe_queue_last(head, type, field) ({ 	queue_entry_t _tmp_entry = queue_last((head)); 	type *_tmp_element = (type*) NULL; 	if (_tmp_entry != (queue_entry_t) head) 	        _tmp_element = qe_element(_tmp_entry, type, field); 	_tmp_element; })
qe_queue_next(head, element, type, field) ({ 	queue_entry_t _tmp_entry = queue_next(&(element)->field); 	type *_tmp_element = (type*) NULL; 	if (_tmp_entry != (queue_entry_t) head) 	        _tmp_element = qe_element(_tmp_entry, type, field); 	_tmp_element; })
qe_queue_prev(head, element, type, field) ({ 	queue_entry_t _tmp_entry = queue_prev(&(element)->field); 	type *_tmp_element = (type*) NULL; 	if (_tmp_entry != (queue_entry_t) head) 	        _tmp_element = qe_element(_tmp_entry, type, field); 	_tmp_element; })
QUEUE_HEAD_INITIALIZER(name) { &name, &name }
queue_init(q) MACRO_BEGIN             	(q)->next = (q);	(q)->prev = (q);MACRO_END
queue_head_init(q) queue_init(&(q))
queue_chain_init(q) queue_init(&(q))
queue_end(q, qe)        ((q) == (qe))
queue_empty(q) queue_end((q), queue_first(q))
__QUEUE2_CHECK_NEXT(__fail, __elt, __prev, __head, type, field)         MACRO_BEGIN                                                                     	if (__prev == __head) {                                                 	        __fail |= __head->next != (queue_entry_t)__elt;                 	} else {                                                                	        __fail |= ((type)(void *)__prev)->field.next !=                 	            (queue_entry_t)__elt;                                       	}                                                                       MACRO_END
__QUEUE2_CHECK_PREV(__fail, __elt, __next, __head, type, field)         MACRO_BEGIN                                                                     	if (__next == __head) {                                                 	        __fail |= __head->prev != (queue_entry_t)__elt;                 	} else {                                                                	        __fail |= ((type)(void *)__next)->field.prev !=                 	            (queue_entry_t)__elt;                                       	}                                                                       MACRO_END
__QUEUE2_CHECK_FAIL(__fail, __elt)                                      MACRO_BEGIN                                                                     	if (__improbable(__fail)) {                                             	        __queue_element_linkage_invalid(__elt);                         	}                                                                       MACRO_END
__QUEUE2_SET_NEXT(__prev, __elt, __head, type, field)                   MACRO_BEGIN                                                                     	if (__head == __prev) {                                                 	        __head->next = (queue_entry_t)__elt;                            	} else {                                                                	        ((type)(void *)__prev)->field.next = (queue_entry_t)__elt;      	}                                                                       MACRO_END
__QUEUE2_SET_PREV(__next, __elt, __head, type, field)                   MACRO_BEGIN                                                                     	if (__head == __next) {                                                 	        __head->prev = (queue_entry_t)__elt;                            	} else {                                                                	        ((type)(void *)__next)->field.prev = (queue_entry_t)__elt;      	}                                                                       MACRO_END
queue_enter(head, elt, type, field)                                     MACRO_BEGIN                                                                     	queue_entry_t __head, __prev;                                           	type __elt;                                                             	int __fail = 0;                                                                                                                                         	__elt  = (elt);                                                         	__head = (head);                                                        	__prev = __head->prev;                                                                                                                                  	__QUEUE2_CHECK_NEXT(__fail, __head, __prev, __head, type, field);       	__QUEUE2_CHECK_FAIL(__fail, __head);                                                                                                                    	__elt->field.prev = __prev;                                             	__elt->field.next = __head;                                             	__compiler_barrier();                                                   	__QUEUE2_SET_NEXT(__prev, __elt, __head, type, field);                  	__head->prev = (queue_entry_t)__elt;                                    MACRO_END
queue_enter_first(head, elt, type, field)                               MACRO_BEGIN                                                                     	queue_entry_t __head, __next;                                           	type __elt;                                                             	int __fail = 0;                                                                                                                                         	__elt  = (elt);                                                         	__head = (head);                                                        	__next = __head->next;                                                                                                                                  	__QUEUE2_CHECK_PREV(__fail, __head, __next, __head, type, field);       	__QUEUE2_CHECK_FAIL(__fail, __head);                                                                                                                    	__elt->field.next = __next;                                             	__elt->field.prev = __head;                                             	__compiler_barrier();                                                   	__QUEUE2_SET_PREV(__next, __elt, __head, type, field);                  	__head->next = (queue_entry_t)__elt;                                    MACRO_END
queue_insert_before(head, elt, cur, type, field)                        MACRO_BEGIN                                                                     	queue_entry_t __head, __cur, __prev;                                    	type __elt;                                                             	int __fail = 0;                                                                                                                                         	__elt  = (elt);                                                         	__cur  = (queue_entry_t)(cur);                                          	__head = (head);                                                                                                                                        	if (__head == __cur) {                                                  	        __prev = __head->prev;                                          	} else {                                                                	        __prev = ((type)(void *)__cur)->field.prev;                     	}                                                                                                                                                       	__QUEUE2_CHECK_NEXT(__fail, __cur, __prev, __head, type, field);        	__QUEUE2_CHECK_FAIL(__fail, __head);                                                                                                                    	__elt->field.prev = __prev;                                             	__elt->field.next = __cur;                                              	__compiler_barrier();                                                   	__QUEUE2_SET_NEXT(__prev, __elt, __head, type, field);                  	__QUEUE2_SET_PREV(__cur, __elt, __head, type, field);                   MACRO_END
queue_insert_after(head, elt, cur, type, field)                         MACRO_BEGIN                                                                     	queue_entry_t __head, __cur, __next;                                    	type __elt;                                                             	int __fail = 0;                                                                                                                                         	__elt  = (elt);                                                         	__cur  = (queue_entry_t)(cur);                                          	__head = (head);                                                                                                                                        	if (__head == __cur) {                                                  	        __next = __head->next;                                          	} else {                                                                	        __next = ((type)(void *)__cur)->field.next;                     	}                                                                                                                                                       	__QUEUE2_CHECK_PREV(__fail, __cur, __next, __head, type, field);        	__QUEUE2_CHECK_FAIL(__fail, __head);                                                                                                                    	__elt->field.prev = __cur;                                              	__elt->field.next = __next;                                             	__compiler_barrier();                                                   	__QUEUE2_SET_NEXT(__cur, __elt, __head, type, field);                   	__QUEUE2_SET_PREV(__next, __elt, __head, type, field);                  MACRO_END
queue_field(head, thing, type, field)                   	        (((head) == (thing)) ? (head) : &((type)(void *)(thing))->field)
queue_remove(head, elt, type, field)                                    MACRO_BEGIN                                                                     	queue_entry_t __head, __next, __prev;                                   	type __elt;                                                             	int __fail = 0;                                                                                                                                         	__elt  = (elt);                                                         	__head = (head);                                                        	__next = __elt->field.next;                                             	__prev = __elt->field.prev;                                                                                                                             	__QUEUE2_CHECK_PREV(__fail, __elt, __next, __head, type, field);        	__QUEUE2_CHECK_NEXT(__fail, __elt, __prev, __head, type, field);        	__QUEUE2_CHECK_FAIL(__fail, __head);                                                                                                                    	__QUEUE2_SET_PREV(__next, __prev, __head, type, field);                 	__QUEUE2_SET_NEXT(__prev, __next, __head, type, field);                 	__compiler_barrier();                                                   	__elt->field.next = NULL;                                               	__elt->field.prev = NULL;                                               MACRO_END
queue_remove_first(head, entry, type, field)            MACRO_BEGIN                                                     	queue_entry_t __hd;                                     	type __entry;                                                                                                           	__hd    = (head);                                       	__entry = (type)(void *)__hd->next;                                                                                     	if ((queue_entry_t)__entry != __hd) {                   	        queue_remove(__hd, __entry, type, field);       	}                                                       	(entry) = __entry;                                      MACRO_END
queue_remove_last(head, entry, type, field)             MACRO_BEGIN                                                     	queue_entry_t __hd;                                     	type __entry;                                                                                                           	__hd    = (head);                                       	__entry = (type)(void *)__hd->prev;                                                                                     	if ((queue_entry_t)__entry != __hd) {                   	        queue_remove(__hd, __entry, type, field);       	}                                                       	(entry) = __entry;                                      MACRO_END
queue_assign(to, from, type, field)                     MACRO_BEGIN                                                     	((type)(void *)((from)->prev))->field.next = (to);      	((type)(void *)((from)->next))->field.prev = (to);      	*to = *from;                                            MACRO_END
queue_new_head(old, new, type, field)                   MACRO_BEGIN                                                     	if (!queue_empty(old)) {                                	        *(new) = *(old);                                	        ((type)(void *)((new)->next))->field.prev =     	                (new);                                  	        ((type)(void *)((new)->prev))->field.next =     	                (new);                                  	} else {                                                	        queue_init(new);                                	}                                                       MACRO_END
queue_iterate(head, elt, type, field)                   	for ((elt) = (type)(void *) queue_first(head);          	     !queue_end((head), (queue_entry_t)(elt));          	     (elt) = (type)(void *) queue_next(&(elt)->field))
XNU_LIBKERN_LIBKERN_CXX_SAFE_ALLOCATION_H None
_IOKIT_EXCLAVES_H None
_IOKIT_APPLEKEYSTOREINTERFACE_H None
AKS_MAX_KEY_SIZE 128
AKS_PLATFORM_FUNCTION_GETKEY "getKey"
PLATFORM_FUNCTION_GET_MEDIA_ENCRYPTION_KEY_UUID "CSFDETargetVEKID"
AKS_SERVICE_PATH "/IOResources/AppleFDEKeyStore"
_IO_ASSERT_H_ None
_IOBSD_H None
kIOBSDKey "IOBSD"
kIOBSDNameKey "BSD Name"
kIOBSDNamesKey "BSD Names"
kIOBSDMajorKey "BSD Major"
kIOBSDMinorKey "BSD Minor"
kIOBSDUnitKey "BSD Unit"
_IOBUFFERMEMORYDESCRIPTOR_H None
_IOBUFFERMEMORYDESCRIPTOR_INTASKWITHOPTIONS_ 1
_IOBUFFERMEMORYDESCRIPTOR_HOSTPHYSICALLYCONTIGUOUS_ 1
IOBUFFERMEMORYDESCRIPTOR_SUPPORTS_INTASKWITHOPTIONS_TAGS 1
_IOKIT_IOCATALOGUE_H None
_IOKIT_IO_COMMAND_H_ None
_IOKIT_IOCOMMANDGATE_H None
_IOKIT_IO_COMMAND_POOL_H_ None
_IOKIT_IOCOMMANDQUEUE_H None
_IOKIT_IOCONDITIONLOCK_H None
_IOKIT_CPU_H None
_IOKIT_IODATAQUEUE_H None
_IOKIT_IODATAQUEUESHARED_H None
_IOKIT_IODEVICEMEMORY_H None
_IOKIT_IODEVICETREE_H None
kIODTAssociatedServiceKey "associated-service"
_IODMACOMMAND_H None
_IOKIT_IODMACONTROLLER_H None
_IOKIT_IODMAEVENTSOURCE_H None
IODMAEventAction IODMAEventSource::Action
_IOKIT_IOEVENTSOURCE_H None
IOEventSourceAction IOEventSource::Action
_IOKIT_IOEXTENSIBLEPANICLOG_H None
_IOKIT_IOFILTERINTERRUPTEVENTSOURCE_H None
IOFilterInterruptAction IOFilterInterruptEventSource::Filter
_IOGUARDPAGEMEMORYDESCRIPTOR_H None
__IOKIT_IOHIBERNATEPRIVATE_H None
HIBERNATE_HMAC_SIZE 48
HIBERNATE_SHA256_SIZE 32
NUM_HIBSEGINFO_SEGMENTS 10
DECLARE_IOHIBERNATEPROGRESSALPHA static const uint8_t gIOHibernateProgressAlpha                  [kIOHibernateProgressHeight][kIOHibernateProgressWidth] =       {                                                                   { 0x00,0x63,0xd8,0xf0,0xd8,0x63,0x00 },                         { 0x51,0xff,0xff,0xff,0xff,0xff,0x51 },                         { 0xae,0xff,0xff,0xff,0xff,0xff,0xae },                         { 0xc3,0xff,0xff,0xff,0xff,0xff,0xc3 },                         { 0xc3,0xff,0xff,0xff,0xff,0xff,0xc3 },                         { 0xc3,0xff,0xff,0xff,0xff,0xff,0xc3 },                         { 0xc3,0xff,0xff,0xff,0xff,0xff,0xc3 },                         { 0xc3,0xff,0xff,0xff,0xff,0xff,0xc3 },                         { 0xc3,0xff,0xff,0xff,0xff,0xff,0xc3 },                         { 0xc3,0xff,0xff,0xff,0xff,0xff,0xc3 },                         { 0xc3,0xff,0xff,0xff,0xff,0xff,0xc3 },                         { 0xc3,0xff,0xff,0xff,0xff,0xff,0xc3 },                         { 0xc3,0xff,0xff,0xff,0xff,0xff,0xc3 },                         { 0xae,0xff,0xff,0xff,0xff,0xff,0xae },                         { 0x54,0xff,0xff,0xff,0xff,0xff,0x54 },                         { 0x00,0x66,0xdb,0xf3,0xdb,0x66,0x00 }                      };
kIOSysctlHibernateStatistics "kern.hibernatestatistics"
kIOSysctlHibernateGraphicsReady "kern.hibernategraphicsready"
kIOSysctlHibernateWakeNotify "kern.hibernatewakenotification"
kIOSysctlHibernateScreenReady "kern.hibernatelockscreenready"
kIOSysctlHibernateHIDReady "kern.hibernatehidready"
kIOSysctlHibernateCount "kern.hibernatecount"
kIOSysctlHibernateSetPreview "kern.hibernatepreview"
kIOHibernateSetPreviewEntitlementKey "com.apple.private.hibernation.set-preview"
HIBLOGFROMPANIC(fmt, args...)     { if (kernel_debugger_entry_count) { kdb_printf(fmt, ## args); } }
HIBLOG(fmt, args...)        { if (kernel_debugger_entry_count) { kdb_printf(fmt, ## args); } else { kprintf(fmt, ## args); printf(fmt, ## args); } }
HIBPRINT(fmt, args...)      { if (kernel_debugger_entry_count) { kdb_printf(fmt, ## args); } else { kprintf(fmt, ## args); } }
kIOHibernateModeKey "Hibernate Mode"
kIOHibernateFileKey "Hibernate File"
kIOHibernateFileMinSizeKey "Hibernate File Min"
kIOHibernateFileMaxSizeKey "Hibernate File Max"
kIOHibernateFreeRatioKey "Hibernate Free Ratio"
kIOHibernateFreeTimeKey "Hibernate Free Time"
kIOHibernateStateKey "IOHibernateState"
kIOHibernateFeatureKey "Hibernation"
kIOHibernatePreviewBufferKey "IOPreviewBuffer"
kIOHibernatePreviewActiveKey "IOHibernatePreviewActive"
kIOHibernateOptionsKey "IOHibernateOptions"
kIOHibernateGfxStatusKey "IOHibernateGfxStatus"
kIOHibernateBootImageKey "boot-image"
kIOHibernateBootImageKeyKey "boot-image-key"
kIOHibernateBootSignatureKey "boot-signature"
kIOHibernateMemorySignatureKey "memory-signature"
kIOHibernateMemorySignatureEnvKey "mem-sig"
kIOHibernateMachineSignatureKey "machine-signature"
kIOHibernateRTCVariablesKey "IOHibernateRTCVariables"
kIOHibernateSMCVariablesKey "IOHibernateSMCVariables"
kIOHibernateBootSwitchVarsKey "boot-switch-vars"
kIOHibernateBootNoteKey "boot-note"
kIOHibernateUseKernelInterpreter 0x80000000
kIOScreenLockStateKey "IOScreenLockState"
kIOBooterScreenLockStateKey "IOBooterScreenLockState"
_IOINTERLEAVEDMEMORYDESCRIPTOR_H None
__IOKIT_IOINTERRUPTACCOUNTING_H None
IA_BASE_CHANNEL_ID IOREPORT_MAKEID('I', 'n', 't', 'r', 0, 0, 0, 0)
IA_MAX_CHANNEL_ID IOREPORT_MAKEID('I', 'n', 't', 'r', 0xFF, 0xFF, 0xFF, 0xFF)
IA_GET_CHANNEL_ID(interruptIndex, statisticIndex)     ((IA_BASE_CHANNEL_ID) +     ((interruptIndex % IA_INDEX_MASK) << IA_INTERRUPT_INDEX_SHIFT) +     ((statisticIndex % IA_INDEX_MASK) << IA_STATISTIC_INDEX_SHIFT))
kInterruptAccountingGroupName "Interrupt Statistics (by index)"
__IOKIT_IOINTERRUPTACCOUNTING_PRIVATE_H None
IA_ADD_VALUE(target, value)     (*(target) += (value))
_IOKIT_IOINTERRUPTCONTROLLER_H None
_IOKIT_IOINTERRUPTEVENTSOURCE_H None
IOInterruptEventAction IOInterruptEventSource::Action
_IOKIT_IOINTERRUPTS_H None
_IOKERNEL_REPORTERS_H_ None
_IOKERNELREPORTSTRUCTS_H_ None
kIOReportLegendPublicKey "IOReportLegendPublic"
kIOReportLegendKey "IOReportLegend"
kIOReportLegendChannelsKey "IOReportChannels"
kIOReportLegendGroupNameKey "IOReportGroupName"
kIOReportLegendSubGroupNameKey "IOReportSubGroupName"
kIOReportLegendInfoKey "IOReportChannelInfo"
kIOReportLegendUnitKey "IOReportChannelUnit"
kIOReportLegendConfigKey "IOReportChannelConfig"
kIOReportLegendStateNamesKey "IOReportChannelStateNames"
kIOReportChannelIDIdx 0
kIOReportChannelTypeIdx 1
kIOReportChannelNameIdx 2
kIOHistogramScaleLinear 0
kIOHistogramScaleExponential 1
_IOKIT_IOKITDEBUG_H None
DKLOG(fmt, args...) { IOLog("DK: " fmt, ## args); }
DKS "%s-0x%qx"
DKN(s) s->getName(), s->getRegistryEntryID()
IOPrintMemory OSPrintMemory
kIOKitDiagnosticsClientClassName "IOKitDiagnosticsClient"
kIOMallocTrackingName "IOMalloc"
kIOWireTrackingName "IOWire"
kIOMapTrackingName "IOMap"
_IOKIT_IOKITKEYS_H None
kIOKitBuildVersionKey "IOKitBuildVersion"
kIOKitDiagnosticsKey "IOKitDiagnostics"
kIORegistryPlanesKey "IORegistryPlanes"
kIOCatalogueKey "IOCatalogue"
kIOServicePlane "IOService"
kIOPowerPlane "IOPower"
kIODeviceTreePlane "IODeviceTree"
kIOAudioPlane "IOAudio"
kIOFireWirePlane "IOFireWire"
kIOUSBPlane "IOUSB"
kIORegistryEntryIDKey "IORegistryEntryID"
kIORegistryEntryPropertyKeysKey "IORegistryEntryPropertyKeys"
kIORegistryEntryAllowableSetPropertiesKey "IORegistryEntryAllowableSetProperties"
kIORegistryEntryDefaultLockingSetPropertiesKey "IORegistryEntryDefaultLockingSetProperties"
kIOServiceClass "IOService"
kIOResourcesClass "IOResources"
kIOClassKey "IOClass"
kIOProbeScoreKey "IOProbeScore"
kIOKitDebugKey "IOKitDebug"
kIOUserClassKey "IOUserClass"
kIOUserClassesKey "IOUserClasses"
kIOSupportedPropertiesKey "IOSupportedProperties"
kIOUserServicePropertiesKey "IOUserServiceProperties"
kIOProviderClassKey "IOProviderClass"
kIONameMatchKey "IONameMatch"
kIOPropertyMatchKey "IOPropertyMatch"
kIOPropertyExistsMatchKey "IOPropertyExistsMatch"
kIOPathMatchKey "IOPathMatch"
kIOLocationMatchKey "IOLocationMatch"
kIOParentMatchKey "IOParentMatch"
kIOResourceMatchKey "IOResourceMatch"
kIOResourceMatchedKey "IOResourceMatched"
kIOMatchedServiceCountKey "IOMatchedServiceCountMatch"
kIONameMatchedKey "IONameMatched"
kIOMatchCategoryKey "IOMatchCategory"
kIODefaultMatchCategoryKey "IODefaultMatchCategory"
kIOMatchedPersonalityKey "IOMatchedPersonality"
kIORematchPersonalityKey "IORematchPersonality"
kIORematchCountKey "IORematchCount"
kIODEXTMatchCountKey "IODEXTMatchCount"
kIOUserClientEntitlementsKey "IOUserClientEntitlements"
kIOServiceDEXTEntitlementsKey "IOServiceDEXTEntitlements"
kIODriverKitEntitlementKey "com.apple.developer.driverkit"
kIODriverKitUserClientEntitlementsKey "com.apple.developer.driverkit.userclient-access"
kIODriverKitRequiredEntitlementsKey "com.apple.private.driverkit.driver-access"
kIODriverKitTestDriverEntitlementKey "com.apple.private.driverkit.test-driver"
kIODriverKitUserClientEntitlementAllowAnyKey "com.apple.developer.driverkit.allow-any-userclient-access"
kIODriverKitUserClientEntitlementAdministratorKey "com.apple.developer.driverkit.administrator"
kIODriverKitUserClientEntitlementCommunicatesWithDriversKey "com.apple.developer.driverkit.communicates-with-drivers"
kIODriverKitUserClientEntitlementAllowThirdPartyUserClientsKey "com.apple.developer.driverkit.allow-third-party-userclients"
kIODriverKitUSBTransportEntitlementKey "com.apple.developer.driverkit.transport.usb"
kIODriverKitHIDTransportEntitlementKey "com.apple.developer.driverkit.transport.hid"
kIODriverKitHIDFamilyDeviceEntitlementKey "com.apple.developer.driverkit.family.hid.device"
kIODriverKitHIDFamilyEventServiceEntitlementKey "com.apple.developer.driverkit.family.hid.eventservice"
kIODriverKitTransportBuiltinEntitlementKey "com.apple.developer.driverkit.builtin"
kIONVRAMReadAccessKey "com.apple.private.iokit.nvram-read-access"
kIONVRAMWriteAccessKey "com.apple.private.iokit.nvram-write-access"
kIOResourcesSetPropertyKey "com.apple.private.iokit.ioresources.setproperty"
kIONVRAMSystemAllowKey "com.apple.private.iokit.system-nvram-allow"
kIOMatchDeferKey "IOMatchDefer"
kIOAllCPUInitializedKey "IOAllCPUInitialized"
kIOUserClientClassKey "IOUserClientClass"
kIOMapperIDKey "IOMapperID"
kIOExcludeListBundleID "com.apple.driver.KextExcludeList"
kIOUserClientCrossEndianKey "IOUserClientCrossEndian"
kIOUserClientCrossEndianCompatibleKey "IOUserClientCrossEndianCompatible"
kIOUserClientSharedInstanceKey "IOUserClientSharedInstance"
kIOUserClientMessageAppSuspendedKey "IOUserClientMessageAppSuspended"
kIOUserClientDefaultLockingKey "IOUserClientDefaultLocking"
kIOUserClientDefaultLockingSetPropertiesKey "IOUserClientDefaultLockingSetProperties"
kIOUserClientDefaultLockingSingleThreadExternalMethodKey "IOUserClientDefaultLockingSingleThreadExternalMethod"
kIOUserClientCreatorKey "IOUserClientCreator"
kIOUserServerCDHashKey "IOUserServerCDHash"
kIOUserUserClientKey "IOUserUserClient"
kIOUserServerOneProcessKey "IOUserServerOneProcess"
kIOUserServerPreserveUserspaceRebootKey "IOUserServerPreserveUserspaceReboot"
kIOPublishNotification "IOServicePublish"
kIOFirstPublishNotification "IOServiceFirstPublish"
kIOMatchedNotification "IOServiceMatched"
kIOFirstMatchNotification "IOServiceFirstMatch"
kIOTerminatedNotification "IOServiceTerminate"
kIOWillTerminateNotification "IOServiceWillTerminate"
kIOGeneralInterest "IOGeneralInterest"
kIOBusyInterest "IOBusyInterest"
kIOAppPowerStateInterest "IOAppPowerStateInterest"
kIOPriorityPowerStateInterest "IOPriorityPowerStateInterest"
kIOPlatformDeviceMessageKey "IOPlatformDeviceMessage"
kIOCFPlugInTypesKey "IOCFPlugInTypes"
kIOCompatibilityMatchKey "IOCompatibilityMatch"
kIOCompatibilityPropertiesKey "IOCompatibilityProperties"
kIOPathKey "IOPath"
kIOCommandPoolSizeKey "IOCommandPoolSize"
kIOMaximumPriorityCountKey "IOMaximumPriorityCount"
kIOMaximumBlockCountReadKey "IOMaximumBlockCountRead"
kIOMaximumBlockCountWriteKey "IOMaximumBlockCountWrite"
kIOMaximumByteCountReadKey "IOMaximumByteCountRead"
kIOMaximumByteCountWriteKey "IOMaximumByteCountWrite"
kIOMaximumSegmentCountReadKey "IOMaximumSegmentCountRead"
kIOMaximumSegmentCountWriteKey "IOMaximumSegmentCountWrite"
kIOMaximumSegmentByteCountReadKey "IOMaximumSegmentByteCountRead"
kIOMaximumSegmentByteCountWriteKey "IOMaximumSegmentByteCountWrite"
kIOMinimumSegmentAlignmentByteCountKey "IOMinimumSegmentAlignmentByteCount"
kIOMaximumSegmentAddressableBitCountKey "IOMaximumSegmentAddressableBitCount"
kIOMinimumSaturationByteCountKey "IOMinimumSaturationByteCount"
kIOMaximumSwapWriteKey "IOMaximumSwapWrite"
kIOIconKey "IOIcon"
kIOBundleResourceFileKey "IOBundleResourceFile"
kIOBusBadgeKey "IOBusBadge"
kIODeviceIconKey "IODeviceIcon"
kIOPlatformSerialNumberKey "IOPlatformSerialNumber"
kIOPlatformUUIDKey "IOPlatformUUID"
kIONVRAMBootArgsKey "boot-args"
kIONVRAMDeletePropertyKey "IONVRAM-DELETE-PROPERTY"
kIONVRAMSyncNowPropertyKey "IONVRAM-SYNCNOW-PROPERTY"
kIONVRAMActivateCSRConfigPropertyKey "IONVRAM-ARMCSR-PROPERTY"
kIODTNVRAMPanicInfoKey "aapl,panic-info"
kIONVRAMDeletePropertyKeyWRet "IONVRAM-DELETEWRET-PROPERTY"
kIOBootDeviceKey "IOBootDevice"
kIOBootDevicePathKey "IOBootDevicePath"
kIOBootDeviceSizeKey "IOBootDeviceSize"
kOSBuildVersionKey "OS Build Version"
kIOStateNotificationItemCreateKey "com.apple.iokit.statenotification.create"
kIOStateNotificationItemSetKey "com.apple.iokit.statenotification.set"
kIOStateNotificationItemCopyKey "com.apple.iokit.statenotification.copy"
kIOStateNotificationNameKey "com.apple.iokit.statenotification.name"
kIOStateNotificationEntitlementSetKey "com.apple.iokit.statenotification.entitlement-set"
kIOStateNotificationEntitlementGetKey "com.apple.iokit.statenotification.entitlement-get"
kIOSystemStateClamshellKey "com.apple.iokit.pm.clamshell"
kIOSystemStateSleepDescriptionKey "com.apple.iokit.pm.sleepdescription"
kIOSystemStateSleepDescriptionReasonKey "com.apple.iokit.pm.sleepreason"
kIOSystemStateSleepDescriptionHibernateStateKey "com.apple.iokit.pm.hibernatestate"
kIOSystemStateWakeDescriptionKey "com.apple.iokit.pm.wakedescription"
kIOSystemStateWakeDescriptionWakeReasonKey "com.apple.iokit.pm.wakereason"
kIOSystemStateWakeDescriptionContinuousTimeOffsetKey "com.apple.iokit.pm.wakedescription.continuous-time-offset"
kIOSystemStateHaltDescriptionKey "com.apple.iokit.pm.haltdescription"
kIOSystemStateHaltDescriptionHaltStateKey "com.apple.iokit.pm.haltstate"
kIOSystemStatePowerSourceDescriptionKey "com.apple.iokit.pm.powersourcedescription"
kIOSystemStatePowerSourceDescriptionACAttachedKey "com.apple.iokit.pm.acattached"
_IOKIT_IOKITKEYSPRIVATE_H None
kIOConsoleLockedKey "IOConsoleLocked"
kIOConsoleUsersKey "IOConsoleUsers"
kIOMaximumMappedIOByteCountKey "IOMaximumMappedIOByteCount"
kIOConsoleSessionAuditIDKey "kCGSSessionAuditIDKey"
kIOConsoleSessionUserNameKey "kCGSSessionUserNameKey"
kIOConsoleSessionUIDKey "kCGSSessionUserIDKey"
kIOConsoleSessionConsoleSetKey "kCGSSessionConsoleSetKey"
kIOConsoleSessionOnConsoleKey "kCGSSessionOnConsoleKey"
kIOConsoleSessionLoginDoneKey "kCGSessionLoginDoneKey"
kIOConsoleSessionSecureInputPIDKey "kCGSSessionSecureInputPID"
kIOConsoleSessionScreenLockedTimeKey "CGSSessionScreenLockedTime"
kIOConsoleSessionScreenIsLockedKey "CGSSessionScreenIsLocked"
kIOConsoleUsersSeedKey "IOConsoleUsersSeed"
kIOProgressBackbufferKey "IOProgressBackbuffer"
kIOProgressColorThemeKey "IOProgressColorTheme"
kIOBridgeBootSessionUUIDKey "bridge-boot-session-uuid"
kIOConsoleSecurityInterest "IOConsoleSecurityInterest"
kIOClientPrivilegeConsoleUser "console"
kIOClientPrivilegeSecureConsoleProcess "secureprocess"
kIOClientPrivilegeConsoleSession "consolesession"
kIONVRAMForceSyncNowPropertyKey "IONVRAM-FORCESYNCNOW-PROPERTY"
kIOKitSystemGUID "40A0DDD2-77F8-4392-B4A3-1E7304206516"
kIONVRAMSystemInternalAllowKey "com.apple.private.iokit.system-nvram-internal-allow"
kIONVRAMSystemHiddenAllowKey "com.apple.private.iokit.system-nvram-hidden-allow"
kIOKernelHasSafeSleep 1
kIOPlatformSleepActionKey "IOPlatformSleepAction"
kIOPlatformWakeActionKey "IOPlatformWakeAction"
kIOPlatformQuiesceActionKey "IOPlatformQuiesceAction"
kIOPlatformActiveActionKey "IOPlatformActiveAction"
kIOPlatformHaltRestartActionKey "IOPlatformHaltRestartAction"
kIOPlatformPanicActionKey "IOPlatformPanicAction"
kIOPlatformFunctionHandlerSet "IOPlatformFunctionHandlerSet"
kIOPlatformFunctionHandlerMaxBusDelay "IOPlatformFunctionHandlerMaxBusDelay"
kIOPlatformMaxBusDelay "IOPlatformMaxBusDelay"
kIOClassNameOverrideKey "IOClassNameOverride"
kIOWaitQuietPanicsEntitlement "com.apple.private.security.waitquiet-panics"
kIOSystemStateEntitlement "com.apple.private.iokit.systemstate"
kIODriverKitAllowsPublishEntitlementsKey "com.apple.private.driverkit.allows-publish"
kIODriverKitPublishEntitlementsKey "IODriverKitPublishEntitlementsKey"
kIOServiceBusyTimeoutExtensionsKey "IOServiceBusyTimeoutExtensions"
kIOServiceLegacyMatchingRegistryIDKey "IOServiceLegacyMatchingRegistryID"
kIOServiceMatchDeferredKey "IOServiceMatchDeferred"
kIOMatchedAtBootKey "IOMatchedAtBoot"
kIOPrimaryDriverTerminateOptionsKey "IOPrimaryDriverTerminateOptions"
kIOServiceNotificationUserKey "IOServiceNotificationUser"
kIOExclaveAssignedKey "exclave-assigned"
kIOExclaveProxyKey "IOExclaveProxy"
IONVRAMSystemVariableList "allow-root-hash-mismatch", 	                          "auto-boot", 	                          "auto-boot-halt-stage", 	                          "base-system-path", 	                          "boot-args", 	                          "boot-command", 	                          "boot-image", 	                          "bootdelay", 	                          "com.apple.System.boot-nonce", 	                          "darkboot", 	                          "emu", 	                          "one-time-boot-command", 	                          "policy-nonce-digests", 	                          "prevent-restores", 	                          "prev-lang:kbd", 	                          "root-live-fs", 	                          "sep-debug-args", 	                          "StartupMute", 	                          "SystemAudioVolume", 	                          "SystemAudioVolumeExtension", 	                          "SystemAudioVolumeSaved"
_IOKIT_IOKITSERVER_H None
__IOKIT_IOLIB_H None
min(a, b) ((a) < (b) ? (a) : (b))
max(a, b) ((a) > (b) ? (a) : (b))
IOKIT_TYPE_IS_COMPATIBLE_PTR(ptr, type) 	(__builtin_xnu_types_compatible(os_get_pointee_type(ptr), type) ||   	    __builtin_xnu_types_compatible(os_get_pointee_type(ptr), void))
IOKIT_TYPE_ASSERT_COMPATIBLE_POINTER(ptr, type) 	_Static_assert(IOKIT_TYPE_IS_COMPATIBLE_PTR(ptr, type), 	    "Pointer type is not compatible with specified type")
IOMalloc(size) __IOMalloc_internal(KHEAP_DEFAULT, size, Z_WAITOK)
IOMallocZero(size) __IOMalloc_internal(KHEAP_DEFAULT, size, Z_ZERO)
IOMallocAligned(size, alignment) 	__IOMallocAligned_internal(KHEAP_DATA_BUFFERS, size, alignment, Z_WAITOK)
IOMallocData(size) __IOMalloc_internal(KHEAP_DATA_BUFFERS, size, Z_WAITOK)
IOMallocZeroData(size) __IOMalloc_internal(KHEAP_DATA_BUFFERS, size, Z_ZERO)
IONewData(type, count) 	((type *)IOMallocData(IOMallocArraySize(0, sizeof(type), count)))
IONewZeroData(type, count) 	((type *)IOMallocZeroData(IOMallocArraySize(0, sizeof(type), count)))
IODeleteData(ptr, type, count) ({ 	vm_size_t  __count = (vm_size_t)(count);             	IOKIT_TYPE_ASSERT_COMPATIBLE_POINTER(ptr, type);     	IOFreeData(os_ptr_load_and_erase(ptr),               	    IOMallocArraySize(0, sizeof(type), __count));    })
IOFreeType(elem, type) ({                       	static _KALLOC_TYPE_DEFINE(kt_view_var, type,       	   KT_SHARED_ACCT);                                 	IOFREETYPE_ASSERT_COMPATIBLE_POINTER(elem, type);   	IOFreeTypeImpl(kt_view_var,                         	    os_ptr_load_and_erase(elem));                   })
IO_TYPED_ALLOCATOR_VERSION 1
IONew(...) __IOKIT_DISPATCH(IONew, ##__VA_ARGS__)
IONewZero(...) __IOKIT_DISPATCH(IONewZero, ##__VA_ARGS__)
IODelete(...) __IOKIT_DISPATCH(IODelete, ##__VA_ARGS__)
IOSafeDeleteNULL(...) __IOKIT_DISPATCH(IODelete, ##__VA_ARGS__)
IONew_2(e_ty, count) ({                                             	static KALLOC_TYPE_VAR_DEFINE(kt_view_var, e_ty, KT_SHARED_ACCT);       	(e_ty *) IOMallocTypeVarImpl(kt_view_var,                               	    IOMallocArraySize(0, sizeof(e_ty), count));                         })
IONew_3(h_ty, e_ty, count) ({                                       	static KALLOC_TYPE_VAR_DEFINE(kt_view_var, h_ty, e_ty, KT_SHARED_ACCT); 	(h_ty *) IOMallocTypeVarImpl(kt_view_var,                               	    IOMallocArraySize(sizeof(h_ty), sizeof(e_ty), count));              })
IONewZero_2(e_ty, count) 	IONew_2(e_ty, count)
IONewZero_3(h_ty, e_ty, count) 	IONew_3(h_ty, e_ty, count)
IODelete_3(ptr, e_ty, count) ({                                     	vm_size_t __s = IOMallocArraySize(0, sizeof(e_ty), count);              	KALLOC_TYPE_ASSERT_COMPATIBLE_POINTER(ptr, e_ty);                       	static KALLOC_TYPE_VAR_DEFINE(kt_view_var, e_ty, KT_SHARED_ACCT);       	IOFreeTypeVarImpl(kt_view_var, os_ptr_load_and_erase(ptr), __s);        })
IODelete_4(ptr, h_ty, e_ty, count) ({                               	vm_size_t __s = IOMallocArraySize(sizeof(h_ty), sizeof(e_ty), count);   	KALLOC_TYPE_ASSERT_COMPATIBLE_POINTER(ptr, h_ty);                       	static KALLOC_TYPE_VAR_DEFINE(kt_view_var, h_ty, e_ty, KT_SHARED_ACCT); 	IOFreeTypeVarImpl(kt_view_var, os_ptr_load_and_erase(ptr), __s);        })
_FN_KPRINTF None
_FN_KPRINTF_DECLARED None
IOPanic(reason) panic("%s", reason)
IORound(value, multiple) 	((((value) + (multiple) - 1) / (multiple)) * (multiple))
IOTrunc(value, multiple) 	(((value) / (multiple)) * (multiple));
__IOKIT_COUNT_ARGS1(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, N, ...) N
__IOKIT_COUNT_ARGS(...) __IOKIT_COUNT_ARGS1(, ##__VA_ARGS__, _9, _8, _7, _6, _5, _4, _3, _2, _1, _0)
__IOKIT_DISPATCH1(base, N, ...) __CONCAT(base, N)(__VA_ARGS__)
__IOKIT_DISPATCH(base, ...) 	__IOKIT_DISPATCH1(base, __IOKIT_COUNT_ARGS(__VA_ARGS__), ##__VA_ARGS__)
IOFREETYPE_ASSERT_COMPATIBLE_POINTER(ptr, type)     KALLOC_TYPE_ASSERT_COMPATIBLE_POINTER(ptr, type)
__IOKIT_IOLOCKS_H None
IOLOCKS_INLINE 1
IOLockLock(l) lck_mtx_lock(l)
IOLockTryLock(l) lck_mtx_try_lock(l)
IOLockUnlock(l) lck_mtx_unlock(l)
IOLockAssert(l, type) LCK_MTX_ASSERT(l, type)
IORWLockRead(l) lck_rw_lock_shared(l)
IORWLockTryRead(l) lck_rw_try_lock_shared(l)
IORWLockWrite(l) lck_rw_lock_exclusive(l)
IORWLockTryWrite(l) lck_rw_try_lock_exclusive(l)
IORWLockUnlock(l) lck_rw_done(l)
IORWLockAssert(l, type) LCK_RW_ASSERT(l, type)
IOSimpleLockLock(l) lck_spin_lock(l)
IOSimpleLockTryLock(l) lck_spin_try_lock(l)
IOSimpleLockUnlock(l) lck_spin_unlock(l)
IOSimpleLockAssert(l, type) LCK_SPIN_ASSERT(l, type)
__IOKIT_IOLOCKS_PRIVATE_H None
__IOKIT_IOMAPPER_H None
__IOKIT_IOMAPTYPES_H None
_IOMEMORYCURSOR_H None
IOPhysicalSegment IOMemoryCursor::PhysicalSegment
OutputSegmentFunc IOMemoryCursor::SegmentFunction
naturalOutputSegment IONaturalMemoryCursor::outputSegment
bigOutputSegment IOBigMemoryCursor::outputSegment
littleOutputSegment IOLittleMemoryCursor::outputSegment
_IOMEMORYDESCRIPTOR_H None
IODIRECTIONPREPARENONCOHERENTDEFINED 1
IODIRECTIONPREPAREAVOIDTHROTTLING 1
IODIRECTIONCOMPLETEWITHERRORDEFINED 1
IODIRECTIONCOMPLETEWITHDATAVALIDDEFINED 1
IOMEMORYUSERESERVEDEFINED 1
IOMEMORYDESCRIPTOR_SUPPORTS_DMACOMMAND 1
IOMEMORYDESCRIPTOR_SUPPORTS_GETDMAMAPLENGTH None
__IOKIT_IOMESSAGE_H None
iokit_family_msg(sub, message)      (UInt32)(sys_iokit|sub|message)
kIOMessageServiceIsTerminated iokit_common_msg(0x010)
kIOMessageServiceIsSuspended iokit_common_msg(0x020)
kIOMessageServiceIsResumed iokit_common_msg(0x030)
kIOMessageServiceIsRequestingClose iokit_common_msg(0x100)
kIOMessageServiceIsAttemptingOpen iokit_common_msg(0x101)
kIOMessageServiceWasClosed iokit_common_msg(0x110)
kIOMessageServiceBusyStateChange iokit_common_msg(0x120)
kIOMessageConsoleSecurityChange iokit_common_msg(0x128)
kIOMessageServicePropertyChange iokit_common_msg(0x130)
kIOMessageCopyClientID iokit_common_msg(0x330)
kIOMessageSystemCapabilityChange iokit_common_msg(0x340)
kIOMessageDeviceSignaledWakeup iokit_common_msg(0x350)
kIOMessageTaskAppSuspendedChange iokit_common_msg(0x800)
kIOMessageDeviceWillPowerOff iokit_common_msg(0x210)
kIOMessageDeviceHasPoweredOn iokit_common_msg(0x230)
kIOMessageSystemWillPowerOff iokit_common_msg(0x250)
kIOMessageSystemWillRestart iokit_common_msg(0x310)
kIOMessageSystemPagingOff iokit_common_msg(0x255)
kIOMessageCanSystemSleep iokit_common_msg(0x270)
kIOMessageSystemWillNotSleep iokit_common_msg(0x290)
kIOMessageSystemWillSleep iokit_common_msg(0x280)
kIOMessageSystemWillPowerOn iokit_common_msg(0x320)
kIOMessageSystemHasPoweredOn iokit_common_msg(0x300)
kIOMessageCanDevicePowerOff iokit_common_msg(0x200)
kIOMessageDeviceWillNotPowerOff iokit_common_msg(0x220)
kIOMessageSystemWillNotPowerOff iokit_common_msg(0x260)
kIOMessageCanSystemPowerOff iokit_common_msg(0x240)
kIOMessageDeviceWillPowerOn iokit_common_msg(0x215)
kIOMessageDeviceHasPoweredOff iokit_common_msg(0x225)
_IOMULTIMEMORYDESCRIPTOR_H None
IOMULTIMEMORYDESCRIPTOR_SUPPORTS_GETPAGECOUNTS 1
_IOKIT_IONOTIFIER_H None
_IOKIT_IONVRAM_H None
_IOKIT_IOPLATFORMEXPERT_H None
kPanicDetailsForcePowerOff 0x1
PANIC_FLUSH_BOUNDARY 16
_IOPOLLEDINTERFACE_H_ None
_IOPROVIDERPROPERTYMERGER_H_ None
kIOProviderMergePropertiesKey "IOProviderMergeProperties"
kIOProviderParentMergePropertiesKey "IOProviderParentMergeProperties"
_IOKIT_IORANGEALLOCATOR_H None
_IOKIT_IOREGISTRYENTRY_H None
_IOREPORT_MACROS_H_ None
IOREPORT_ABORT panic
SIMPLEREPORT_INIT(buf, bufSize, providerID, channelID, cats)  do {      memset((buf), '&', (bufSize));      IOReportElement     *__elem = (IOReportElement *)(buf);      IOSimpleReportValues *__vals;      if ((bufSize) >= SIMPLEREPORT_BUFSIZE) {  	__elem->provider_id = (providerID);  	__elem->channel_id = (channelID);  	__elem->channel_type.report_format = kIOReportFormatSimple;  	__elem->channel_type.reserved = 0;  	__elem->channel_type.categories = (cats);  	__elem->channel_type.nelements = 1;  	__elem->channel_type.element_idx = 0;  	__elem->timestamp = 0;  	__vals = (IOSimpleReportValues*)&__elem->values;  	__vals->simple_value = kIOReportInvalidIntValue;      }      else {  	IOREPORT_ABORT("bufSize is smaller than the required size\n");      }  } while(0)
SIMPLEREPORT_SETVALUE(simp_buf, new_value)  do {      IOReportElement *__elem = (IOReportElement *)(simp_buf);      IOSimpleReportValues *__vals;      __vals = (IOSimpleReportValues*)&__elem->values;      __vals->simple_value = (new_value);  } while(0)
SIMPLEREPORT_INCREMENTVALUE(simp_buf, increment_by)  do {      IOReportElement *__elem = (IOReportElement *)(simp_buf);      IOSimpleReportValues *__vals;      __vals = (IOSimpleReportValues*)&__elem->values;      int64_t __simple_value = INT64_MAX;      if (os_add_overflow(__vals->simple_value, (increment_by), &__simple_value)) {      __vals->simple_value = INT64_MAX;      } else {      __vals->simple_value = __simple_value;      }  } while(0)
SIMPLEREPORT_UPDATEPREP(simp_buf, ptr2cpy, size2cpy)  do {      (ptr2cpy) = (simp_buf);      (size2cpy) = sizeof(IOReportElement);  } while(0)
SIMPLEREPORT_UPDATERES(action, result)  do {      if (((action) == kIOReportGetDimensions) || ((action) == kIOReportCopyChannelData)) {  	int *__nElements = (int *)(result);  	*__nElements += 1;      }  } while (0)
STATEREPORT_INIT(nstates, buf, bufSize, providerID, channelID, cats) do {      memset((buf), '&', (bufSize));      IOStateReportInfo *__info = (IOStateReportInfo *)(buf);      IOStateReportValues *__rep;      IOReportElement     *__elem;      if ((bufSize) >= STATEREPORT_BUFSIZE(nstates)) {  	for (uint16_t __no = 0; __no < (nstates); __no++) {  	    __elem =  &(__info->elem[__no]);  	    __rep = (IOStateReportValues *) &(__elem->values);  	    __elem->provider_id = (providerID);  	    __elem->channel_id = (channelID);  	    __elem->channel_type.report_format = kIOReportFormatState;  	    __elem->channel_type.reserved = 0;  	    __elem->channel_type.categories = (cats);  	    __elem->channel_type.nelements = (nstates);  	    __elem->channel_type.element_idx = __no;  	    __elem->timestamp = 0;  	    __rep->state_id = __no;  	    __rep->intransitions = 0;  	    __rep->upticks = 0;  	    __rep->last_intransition = 0;  	}  	__info->curr_state = 0;  	__info->update_ts = 0;      }      else {  	IOREPORT_ABORT("bufSize is smaller than the required size\n");      }  } while(0)
STATEREPORT_SETSTATEID(state_buf, stateIdx, stateID)  do {      IOStateReportInfo *__info = (IOStateReportInfo *)(state_buf);      IOStateReportValues *__rep;      if ((stateIdx) < __info->elem[0].channel_type.nelements) {  	__rep = (IOStateReportValues*) &(__info->elem[(stateIdx)].values);  	__rep->state_id = (stateID);      }  } while (0)
STATEREPORT_SETSTATE(state_buf, newStateIdx, changeTime)  do {      IOStateReportInfo *__info = (IOStateReportInfo *)(state_buf);      IOStateReportValues *__rep;      if ((newStateIdx) < __info->elem[0].channel_type.nelements ) {  	__rep = (IOStateReportValues*) &(__info->elem[__info->curr_state].values);  	if (__info->update_ts)  	    __rep->upticks += (changeTime) - __info->update_ts;  	__info->elem[(newStateIdx)].timestamp = (changeTime);  	__rep = (IOStateReportValues*) &(__info->elem[(newStateIdx)].values);  	__rep->intransitions++;  	__info->curr_state = (newStateIdx);  	__info->update_ts = (changeTime);      }  } while(0)
STATEREPORT_UPDATEPREP(state_buf, currentTime, ptr2cpy, size2cpy)  do {      IOStateReportInfo *__info = (IOStateReportInfo *)(state_buf);      IOReportElement     *__elem;      IOStateReportValues *__state;      (size2cpy) = __info->elem[0].channel_type.nelements * sizeof(IOReportElement);      (ptr2cpy) =  (void *) &__info->elem[0];      if (__info->update_ts)  {  	__elem = &__info->elem[__info->curr_state];  	__state = (IOStateReportValues *)&__elem->values;  	__elem->timestamp = (currentTime);  	__state->upticks  += (currentTime) - __info->update_ts;  	__info->update_ts = (currentTime);      }  } while(0)
STATEREPORT_UPDATERES(state_buf, action, result)  do {      IOStateReportInfo *__info = (IOStateReportInfo *)(state_buf);      IOReportElement     *__elem;      int *__nElements = (int *)(result);      if (((action) == kIOReportGetDimensions) || ((action) == kIOReportCopyChannelData)) {  	__elem =  &(__info->elem[0]);      if (os_add_overflow(*__nElements, __elem->channel_type.nelements, __nElements)) {  	*__nElements = INT_MAX;      }      }  } while (0)
STATEREPORT_GETTRANSITIONS(state_buf, stateIdx)      (((stateIdx) < ((IOStateReportInfo *)(state_buf))->elem[0].channel_type.nelements)  	? ((IOStateReportValues*)&(((IOStateReportInfo*)(state_buf))->elem[(stateIdx)].values))->intransitions  	: kIOReportInvalidValue)
STATEREPORT_GETTICKS(state_buf, stateIdx)      (((stateIdx) < ((IOStateReportInfo*)(state_buf))->elem[0].channel_type.nelements)  	? ((IOStateReportValues*)&(((IOStateReportInfo*)(state_buf))->elem[(stateIdx)].values))->upticks  	: kIOReportInvalidValue)
SIMPLEARRAY_INIT(nValues, buf, bufSize, providerID, channelID, cats) do {      memset((buf), '&', (bufSize));      IOSimpleArrayReportValues *__rep;      IOReportElement     *__elem;      uint32_t            __nElems = (((nValues) / IOR_VALUES_PER_ELEMENT) + 	                            (((nValues) % IOR_VALUES_PER_ELEMENT) ? 1 : 0));     if ((bufSize) >= SIMPLEARRAY_BUFSIZE(nValues)) {  	for (unsigned __no = 0; __no < __nElems; __no++) {  	    __elem =  &(((IOReportElement *)(buf))[__no]);  	    __rep = (IOSimpleArrayReportValues *) &(__elem->values);  	    __elem->provider_id = (providerID);  	    __elem->channel_id = (channelID);  	    __elem->channel_type.report_format = kIOReportFormatSimpleArray;  	    __elem->channel_type.reserved = 0;  	    __elem->channel_type.categories = (cats);  	    __elem->channel_type.nelements = (__nElems);  	    __elem->channel_type.element_idx = __no;  	    __elem->timestamp = 0;  	    __rep->simple_values[0] = kIOReportInvalidIntValue;  	    __rep->simple_values[1] = kIOReportInvalidIntValue;  	    __rep->simple_values[2] = kIOReportInvalidIntValue;  	    __rep->simple_values[3] = kIOReportInvalidIntValue;  	}      }      else {  	IOREPORT_ABORT("bufSize is smaller than the required size\n");      }  } while(0)
__SA_FINDREP(array_buf, idx)  	IOSimpleArrayReportValues *__rep;  	IOReportElement     *__elem;  	unsigned __elemIdx = (idx) / IOR_VALUES_PER_ELEMENT;  	unsigned __valueIdx = (idx) % IOR_VALUES_PER_ELEMENT;  	__elem = &(((IOReportElement *)(array_buf))[0]);  	if (__elemIdx < __elem->channel_type.nelements)  { 	    __elem = &(((IOReportElement *)(array_buf))[__elemIdx]);  	    __rep = (IOSimpleArrayReportValues *) &(__elem->values);
SIMPLEARRAY_SETVALUE(array_buf, idx, newValue) do {      __SA_FINDREP((array_buf), (idx)) 	__rep->simple_values[__valueIdx] = (newValue);      } } while(0)
SIMPLEARRAY_INCREMENTVALUE(array_buf, idx, value)  do {      __SA_FINDREP((array_buf), (idx))     if (os_add_overflow(__rep->simple_values[__valueIdx], (value), &__rep->simple_values[__valueIdx])) {  	__rep->simple_values[__valueIdx] = INT64_MAX;      }     } } while(0)
SIMPLEARRAY_UPDATEPREP(array_buf, ptr2cpy, size2cpy) do {      IOReportElement     *__elem;      __elem = &(((IOReportElement *)(array_buf))[0]);      (ptr2cpy) =  (void *) (array_buf);      (size2cpy) = __elem->channel_type.nelements * sizeof(IOReportElement);  } while(0)
SIMPLEARRAY_UPDATERES(array_buf, action, result) do {      IOReportElement     *__elem;      int *__nElements = (int *)(result);      __elem = &(((IOReportElement *)(array_buf))[0]);      if (((action) == kIOReportGetDimensions) || ((action) == kIOReportCopyChannelData)) {      if (os_add_overflow(*__nElements, __elem->channel_type.nelements, __nElements)) {  	*__nElements = INT_MAX;      }      }  } while (0)
SIMPLEARRAY_GETVALUE(array_buf, idx)      (((idx) > __SA_MAXINDEX(array_buf) || (idx) < 0) ? kIOReportInvalidIntValue :      ((IOSimpleArrayReportValues*)&(  	((IOReportElement*)(array_buf))[(idx) / IOR_VALUES_PER_ELEMENT].values))  	    ->simple_values[(idx) % IOR_VALUES_PER_ELEMENT])
HISTREPORT_INIT(nbuckets, bktSize, buf, bufSize, providerID, channelID, cats) do {      memset((buf), '&', (bufSize));      IOHistReportInfo   *__info = (IOHistReportInfo *)(buf);      IOReportElement         *__elem;      IOHistogramReportValues *__rep;      if ((bufSize) >= HISTREPORT_BUFSIZE(nbuckets)) {  	__info->bucketWidth = (bktSize);  	for (uint16_t __no = 0; __no < (nbuckets); __no++) {  	    __elem =  &(__info->elem[__no]);  	    __rep = (IOHistogramReportValues *) &(__elem->values);  	    __elem->provider_id = (providerID);  	    __elem->channel_id = (channelID);  	    __elem->channel_type.report_format = kIOReportFormatHistogram;  	    __elem->channel_type.reserved = 0;  	    __elem->channel_type.categories = (cats);  	    __elem->channel_type.nelements = (nbuckets);  	    __elem->channel_type.element_idx = __no;  	    __elem->timestamp = 0;  	    memset(__rep, '\0', sizeof(IOHistogramReportValues)); 	}      }      else {  	IOREPORT_ABORT("bufSize is smaller than the required size\n");      }  } while (0)
HISTREPORT_TALLYVALUE(hist_buf, value) do {      IOHistReportInfo   *__info = (IOHistReportInfo *)(hist_buf);      IOReportElement         *__elem;      IOHistogramReportValues *__rep;      for (unsigned __no = 0; __no < __info->elem[0].channel_type.nelements; __no++) {  	if ((value) <= __info->bucketWidth * (__no+1)) {  	    __elem =  &(__info->elem[__no]);  	    __rep = (IOHistogramReportValues *) &(__elem->values);  	    if (__rep->bucket_hits == 0) {  	        __rep->bucket_min = __rep->bucket_max = (value);  	    }  	    else if ((value) < __rep->bucket_min) {  	        __rep->bucket_min = (value);  	    }  	    else if ((value) > __rep->bucket_max) {  	        __rep->bucket_max = (value);  	    }  	int64_t __sum = 0;  	if (os_add_overflow(__rep->bucket_sum, (value), &__sum)) {  	    __rep->bucket_sum = INT64_MAX;  	} else {  	    __rep->bucket_sum = __sum;  	}  	    __rep->bucket_hits++;  	    break;  	}      }  } while (0)
HISTREPORT_UPDATEPREP(hist_buf, ptr2cpy, size2cpy) do {      IOHistReportInfo   *__info = (IOHistReportInfo *)(hist_buf);      (size2cpy) = __info->elem[0].channel_type.nelements * sizeof(IOReportElement);      (ptr2cpy) =  (void *) &__info->elem[0];  } while(0)
HISTREPORT_UPDATERES(hist_buf, action, result) do {      IOHistReportInfo   *__info = (IOHistReportInfo *)(hist_buf);      int *__nElements = (int *)(result);      if (((action) == kIOReportGetDimensions) || ((action) == kIOReportCopyChannelData)) {  	if (os_add_overflow(*__nElements, __info->elem[0].channel_type.nelements, __nElements)) {  	    *__nElements = INT_MAX;  	}      }  } while (0)
_IOREPORT_TYPES_H_ None
IOR_VALUES_PER_ELEMENT 4
kIOReportInvalidIntValue INT64_MIN
kIOReportInvalidCategory UINT16_MAX
__IOR_lshiftchr(c, chshift)     ((uint64_t)(c) << (8*(chshift)))
IOREPORT_MAKEID(A, B, C, D, E, F, G, H)     (__IOR_lshiftchr(A, 7) | __IOR_lshiftchr(B, 6) | __IOR_lshiftchr(C, 5)     | __IOR_lshiftchr(D, 4) | __IOR_lshiftchr(E, 3) | __IOR_lshiftchr(F, 2)     | __IOR_lshiftchr(G, 1) | __IOR_lshiftchr(H, 0))
__IOR_MAKEUNIT(quantity, scale) 	(((IOReportUnit)quantity << 56) | (uint64_t)scale)
kIOReportScaleConstMask 0x000000007fffffff
kIOReportExpZeroOffset -(kIOReportExpBase)
kIOReportScaleSIShift 32
kIOReportScaleSIMask 0x000000ff00000000
kIOReportScaleIECShift 40
kIOReportScaleIECMask 0x0000ff0000000000
kIOReportCardinalShift 48
kIOReportCardinalMask 0x00ff000000000000
kIOReportScaleUnity 0
kIOReportScaleBits kIOReportScaleUnity
kIOReportUnitNone __IOR_MAKEUNIT(kIOReportQuantityUndefined,  	                                          kIOReportScaleUnity)
kIOReportUnit_s __IOR_MAKEUNIT(kIOReportQuantityTime,  	                                       kIOReportScaleUnity)
kIOReportUnit_ms __IOR_MAKEUNIT(kIOReportQuantityTime,  	                                       kIOReportScaleMilli)
kIOReportUnit_us __IOR_MAKEUNIT(kIOReportQuantityTime,  	                                       kIOReportScaleMicro)
kIOReportUnit_ns __IOR_MAKEUNIT(kIOReportQuantityTime,  	                                       kIOReportScaleNano)
kIOReportUnit_J __IOR_MAKEUNIT(kIOReportQuantityEnergy,  	                                       kIOReportScaleUnity)
kIOReportUnit_mJ __IOR_MAKEUNIT(kIOReportQuantityEnergy,  	                                       kIOReportScaleMilli)
kIOReportUnit_uJ __IOR_MAKEUNIT(kIOReportQuantityEnergy,  	                                       kIOReportScaleMicro)
kIOReportUnit_nJ __IOR_MAKEUNIT(kIOReportQuantityEnergy,  	                                       kIOReportScaleNano)
kIOReportUnit_pJ __IOR_MAKEUNIT(kIOReportQuantityEnergy,  	                                       kIOReportScalePico)
kIOReportUnitHWTicks __IOR_MAKEUNIT(kIOReportQuantityTime,  	                                       kIOReportScaleMachHWTicks)
kIOReportUnit24MHzTicks __IOR_MAKEUNIT(kIOReportQuantityTime,  	                                       kIOReportScale24MHz)
kIOReportUnit1GHzTicks __IOR_MAKEUNIT(kIOReportQuantityTime,  	                                       kIOReportScale1GHz)
kIOReportUnitBits __IOR_MAKEUNIT(kIOReportQuantityData,  	                                        kIOReportScaleBits)
kIOReportUnitBytes __IOR_MAKEUNIT(kIOReportQuantityData,  	                                        kIOReportScaleBytes)
kIOReportUnit_KiB __IOR_MAKEUNIT(kIOReportQuantityData,  	                                       kIOReportScaleKiBytes)
kIOReportUnit_MiB __IOR_MAKEUNIT(kIOReportQuantityData,  	                                       kIOReportScaleMiBytes)
kIOReportUnit_GiB __IOR_MAKEUNIT(kIOReportQuantityData,  	                                       kIOReportScaleGiBytes)
kIOReportUnit_TiB __IOR_MAKEUNIT(kIOReportQuantityData,  	                                       kIOReportScaleTiBytes)
kIOReportUnitEvents __IOR_MAKEUNIT(kIOReportQuantityEventCount,  	                                       kIOReportScaleUnity)
kIOReportUnitPackets __IOR_MAKEUNIT(kIOReportQuantityPacketCount,  	                                       kIOReportScaleUnity)
kIOReportUnitInstrs __IOR_MAKEUNIT(kIOReportQuantityCPUInstrs,  	                                       kIOReportScaleUnity)
kIOReportUnit_KI __IOR_MAKEUNIT(kIOReportQuantityCPUInstrs,  	                                       kIOReportScaleKilo)
kIOReportUnit_MI __IOR_MAKEUNIT(kIOReportQuantityCPUInstrs,  	                                       kIOReportScaleMega)
kIOReportUnit_GI __IOR_MAKEUNIT(kIOReportQuantityCPUInstrs,  	                                       kIOReportScaleGiga)
__IOKIT_IORETURN_H None
sys_iokit err_system(0x38)
sub_iokit_common err_sub(0)
sub_iokit_usb err_sub(1)
sub_iokit_firewire err_sub(2)
sub_iokit_block_storage err_sub(4)
sub_iokit_graphics err_sub(5)
sub_iokit_networking err_sub(6)
sub_iokit_bluetooth err_sub(8)
sub_iokit_pmu err_sub(9)
sub_iokit_acpi err_sub(10)
sub_iokit_smbus err_sub(11)
sub_iokit_ahci err_sub(12)
sub_iokit_powermanagement err_sub(13)
sub_iokit_hidsystem err_sub(14)
sub_iokit_scsi err_sub(16)
sub_iokit_usbaudio err_sub(17)
sub_iokit_wirelesscharging err_sub(18)
sub_iokit_nvme err_sub(28)
sub_iokit_thunderbolt err_sub(29)
sub_iokit_graphics_acceleration err_sub(30)
sub_iokit_keystore err_sub(31)
sub_iokit_smc err_sub(32)
sub_iokit_apfs err_sub(33)
sub_iokit_acpiec err_sub(34)
sub_iokit_timesync_avb err_sub(35)
sub_iokit_platform err_sub(0x2A)
sub_iokit_audio_video err_sub(0x45)
sub_iokit_cec err_sub(0x46)
sub_iokit_arc err_sub(0x47)
sub_iokit_baseband err_sub(0x80)
sub_iokit_HDA err_sub(0xFE)
sub_iokit_hsic err_sub(0x147)
sub_iokit_sdio err_sub(0x174)
sub_iokit_wlan err_sub(0x208)
sub_iokit_appleembeddedsleepwakehandler err_sub(0x209)
sub_iokit_appleppm err_sub(0x20A)
sub_iokit_vendor_specific err_sub(-2)
sub_iokit_reserved err_sub(-1)
iokit_common_err(return )          (sys_iokit|sub_iokit_common|return)
iokit_family_err(sub, return )      (sys_iokit|sub|return)
iokit_vendor_specific_err(return ) (sys_iokit|sub_iokit_vendor_specific|return)
kIOReturnSuccess KERN_SUCCESS
kIOReturnError iokit_common_err(0x2bc)
kIOReturnNoMemory iokit_common_err(0x2bd)
kIOReturnNoResources iokit_common_err(0x2be)
kIOReturnIPCError iokit_common_err(0x2bf)
kIOReturnNoDevice iokit_common_err(0x2c0)
kIOReturnNotPrivileged iokit_common_err(0x2c1)
kIOReturnBadArgument iokit_common_err(0x2c2)
kIOReturnLockedRead iokit_common_err(0x2c3)
kIOReturnLockedWrite iokit_common_err(0x2c4)
kIOReturnExclusiveAccess iokit_common_err(0x2c5)
kIOReturnBadMessageID iokit_common_err(0x2c6)
kIOReturnUnsupported iokit_common_err(0x2c7)
kIOReturnVMError iokit_common_err(0x2c8)
kIOReturnInternalError iokit_common_err(0x2c9)
kIOReturnIOError iokit_common_err(0x2ca)
kIOReturnCannotLock iokit_common_err(0x2cc)
kIOReturnNotOpen iokit_common_err(0x2cd)
kIOReturnNotReadable iokit_common_err(0x2ce)
kIOReturnNotWritable iokit_common_err(0x2cf)
kIOReturnNotAligned iokit_common_err(0x2d0)
kIOReturnBadMedia iokit_common_err(0x2d1)
kIOReturnStillOpen iokit_common_err(0x2d2)
kIOReturnRLDError iokit_common_err(0x2d3)
kIOReturnDMAError iokit_common_err(0x2d4)
kIOReturnBusy iokit_common_err(0x2d5)
kIOReturnTimeout iokit_common_err(0x2d6)
kIOReturnOffline iokit_common_err(0x2d7)
kIOReturnNotReady iokit_common_err(0x2d8)
kIOReturnNotAttached iokit_common_err(0x2d9)
kIOReturnNoChannels iokit_common_err(0x2da)
kIOReturnNoSpace iokit_common_err(0x2db)
kIOReturnPortExists iokit_common_err(0x2dd)
kIOReturnCannotWire iokit_common_err(0x2de)
kIOReturnNoInterrupt iokit_common_err(0x2df)
kIOReturnNoFrames iokit_common_err(0x2e0)
kIOReturnMessageTooLarge iokit_common_err(0x2e1)
kIOReturnNotPermitted iokit_common_err(0x2e2)
kIOReturnNoPower iokit_common_err(0x2e3)
kIOReturnNoMedia iokit_common_err(0x2e4)
kIOReturnUnformattedMedia iokit_common_err(0x2e5)
kIOReturnUnsupportedMode iokit_common_err(0x2e6)
kIOReturnUnderrun iokit_common_err(0x2e7)
kIOReturnOverrun iokit_common_err(0x2e8)
kIOReturnDeviceError iokit_common_err(0x2e9)
kIOReturnNoCompletion iokit_common_err(0x2ea)
kIOReturnAborted iokit_common_err(0x2eb)
kIOReturnNoBandwidth iokit_common_err(0x2ec)
kIOReturnNotResponding iokit_common_err(0x2ed)
kIOReturnIsoTooOld iokit_common_err(0x2ee)
kIOReturnIsoTooNew iokit_common_err(0x2ef)
kIOReturnNotFound iokit_common_err(0x2f0)
kIOReturnInvalid iokit_common_err(0x1)
_IORPC_H None
_IOKIT_IOSERVICE_H None
UINT64_MAX 18446744073709551615ULL
_IOKIT_IOSERVICEPM_H None
kPMPowerStatesChID IOREPORT_MAKEID('P','M','S','t','H','i','s','t')
kPMCurrStateChID IOREPORT_MAKEID( 'P','M','C','u','r','S','t','\0' )
kPMReportPowerOn 0x01
kPMReportDeviceUsable 0x02
kPMReportLowPower 0x04
PM_VARS_SUPPORT 0
_IOKIT_IOSERVICESTATENOTIFICATIONEVENTSOURCE_H None
_IOKIT_IOSHAREDDATAQUEUE_H None
DISABLE_DATAQUEUE_WARNING None
_IOKIT_IOSHAREDLOCK_H None
IOSharedLockData OSSpinLock
ev_lock_data_t OSSpinLock
ev_unlock(l) OSSpinLockUnlock(l)
ev_try_lock(l) OSSpinLockTry(l)
_IOKIT_STATISTICS_H None
IOSTATISTICS_SIG 'IOST'
IOSTATISTICS_SIG_USERCLIENT 'IOSU'
IOSTATISTICS_SIG_WORKLOOP 'IOSW'
IOSTATISTICS_VER 0x2
__IOKIT_STATISTICS_PRIVATE_H None
_IOSUBMEMORYDESCRIPTOR_H None
_IOSYNCER_H None
_IOTIMEREVENTSOURCE None
IOTIMEREVENTSOURCEOPTIONS_DEFINED 1
IOKIT_IOTIMESTAMP_H None
IODBG_DISK(code) IODBG_STORAGE(code)
IODBG_POINTING(code) IODBG_HID(code)
IOINTC_HANDLER 1
IOINTC_SPURIOUS 2
IOWL_CLIENT 1
IOWL_WORK 2
IOINTES_CLIENT 1
IOINTES_LAT 2
IOINTES_SEMA 3
IOINTES_INTCTXT 4
IOINTES_INTFLTR 5
IOINTES_ACTION 6
IOINTES_FILTER 7
IOTIMES_CLIENT 1
IOTIMES_LAT 2
IOTIMES_SEMA 3
IOTIMES_ACTION 4
IOCMDQ_CLIENT 1
IOCMDQ_LAT 2
IOCMDQ_SEMA 3
IOCMDQ_PSEMA 4
IOCMDQ_PLOCK 5
IOCMDQ_ACTION 6
IOMDESC_WIRE 1
IOMDESC_PREPARE 2
IOMDESC_MAP 3
IOMDESC_UNMAP 4
IOMDESC_DMA_MAP 5
IOMDESC_DMA_UNMAP 6
IOMDESC_COMPLETE 7
IOMDPA_MAPPED 1
IOMDPA_UNMAPPED 2
IOMDPA_SEGMENTS_PAGE 3
IOMDPA_SEGMENTS_LONG 4
IOSERVICE_BUSY 1
IOSERVICE_NONBUSY 2
IOSERVICE_MODULESTALL 3
IOSERVICE_MODULEUNSTALL 4
IOSERVICE_TERMINATE_PHASE1 5
IOSERVICE_TERMINATE_REQUEST_OK 6
IOSERVICE_TERMINATE_REQUEST_FAIL 7
IOSERVICE_TERMINATE_SCHEDULE_STOP 8
IOSERVICE_TERMINATE_SCHEDULE_FINALIZE 9
IOSERVICE_TERMINATE_WILL 10
IOSERVICE_TERMINATE_DID 11
IOSERVICE_TERMINATE_DID_DEFER 12
IOSERVICE_TERMINATE_FINALIZE 13
IOSERVICE_TERMINATE_STOP 14
IOSERVICE_TERMINATE_STOP_NOP 15
IOSERVICE_TERMINATE_STOP_DEFER 16
IOSERVICE_TERMINATE_DONE 17
IOSERVICE_KEXTD_ALIVE 18
IOSERVICE_KEXTD_READY 19
IOSERVICE_REGISTRY_QUIET 20
IOSERVICE_TERM_SET_INACTIVE 21
IOSERVICE_TERM_SCHED_PHASE2 22
IOSERVICE_TERM_START_PHASE2 23
IOSERVICE_TERM_TRY_PHASE2 24
IOSERVICE_TERM_UC_DEFER 25
IOSERVICE_DETACH 26
IOREGISTRYENTRY_NAME_STRING 1
IOREGISTRYENTRY_NAME 2
__IOKIT_IOTYPES_H None
IOKIT 1
__IOKIT_PORTS_DEFINED__ None
LIBKERN_OSNUMBER_FLOAT_SUPPORT 1
_IOKIT_IOUSERCLIENT_H None
_IOUSERCLIENT_SENDASYNCRESULT64WITHOPTIONS_ 1
kIOClientPrivilegeAdministrator "root"
kIOClientPrivilegeLocalUser "local"
kIOClientPrivilegeForeground "foreground"
IO_EXTERNAL_METHOD_ARGUMENTS_CURRENT_VERSION 2
IOUC_COPYPORTNAMEFOROBJECTINTASK 1
IOUSERCLIENT2022_SUPPORTED 1
_IOUSERSERVER_H None
kIOUserServerClassKey "IOUserServer"
kIOUserServerNameKey "IOUserServerName"
kIOUserServerTagKey "IOUserServerTag"
kIOUserServerCDHashKey "IOUserServerCDHash"
__IOKIT_IOWORKLOOP_H None
__OS_OSMESSAGENOTIFICATION_H None
__IOKIT_SYSTEM_H None
__STDC_LIMIT_MACROS None
IOKIT_ENABLE_SHARED_PTR None
_IOMEMORYDESCRIPTOR_INTERNAL_ None
super IOGeneralMemoryDescriptor
IOKIT_ENABLE_SHARED_PTR None
super OSObject
super OSObject
IOKIT_ENABLE_SHARED_PTR None
super IOEventSource
IOKIT_ENABLE_SHARED_PTR None
super OSObject
IOKIT_ENABLE_SHARED_PTR None
super OSObject
IOKIT_ENABLE_SHARED_PTR None
super IOService
super IOInterruptController
IOKIT_ENABLE_SHARED_PTR None
DISABLE_DATAQUEUE_WARNING None
super OSObject
IODTSUPPORTDEBUG 0
unexpected(a) { kprintf("unexpected %s:%d\n", __FILE__, __LINE__); a; }
IOKIT_ENABLE_SHARED_PTR None
fInternalState reserved
fState reserved->fState
fMDSummary reserved->fMDSummary
SHOULD_COPY_DIR(op, direction)                                      	((kIODirectionNone == (direction))                                  	    || (kWalkSyncAlways & (op))                                     	    || (((kWalkSyncIn & (op)) ? kIODirectionIn : kIODirectionOut)   	                                            & (direction)))
super IOCommand
IOKIT_ENABLE_SHARED_PTR None
super IOService
CREATE_BUF_LEN 48
IOKIT_ENABLE_SHARED_PTR None
super IOEventSource
IOKIT_ENABLE_SHARED_PTR None
super OSObject
super OSObject
IOKIT_ENABLE_SHARED_PTR None
super IOInterruptEventSource
IOKIT_ENABLE_SHARED_PTR None
super IOGeneralMemoryDescriptor
DISABLE_TRIM 0
TRIM_DELAY 25000
tStat(x, y)     gIOHibernateStats->x = t40ms(gIOHibernateCurrentHeader->y);
IOKIT_ENABLE_SHARED_PTR None
__STDC_LIMIT_MACROS None
super IOReporter
super IOMemoryDescriptor
IOKIT_ENABLE_SHARED_PTR None
super IOService
super IOInterruptController
IOKIT_ENABLE_SHARED_PTR None
super IOEventSource
super OSObject
super IOUserClient2022
_IOKIT_KERNELINTERNAL_H None
__IODEQUALIFY(type, expr)                                  ({ typeof(expr) expr_ = (type)(uintptr_t)(expr);                    (type)(uintptr_t)(expr_); })
IOKIT_ENABLE_SHARED_PTR None
super IOService
IOKIT_ENABLE_SHARED_PTR None
super OSObject
super IOMemoryCursor
super IOMemoryCursor
super IOMemoryCursor
IOKIT_ENABLE_SHARED_PTR None
super IOMemoryDescriptor
LOCK IORecursiveLockLock( gIOMemoryLock)
UNLOCK IORecursiveLockUnlock( gIOMemoryLock)
SLEEP IORecursiveLockSleep( gIOMemoryLock, (void *)this, THREAD_UNINT)
WAKEUP IORecursiveLockWakeup( gIOMemoryLock, (void *)this,  false)
getNumIOPL(osd, d)          ((UInt)(((osd)->getLength() - ((char *) getIOPLList(d) - (char *) d)) / sizeof(ioPLBlock)))
computeDataSize(p, u)     (offsetof(ioGMDData, fPageList) + p * sizeof(upl_page_info_t) + u * sizeof(ioPLBlock))
LOGUNALIGN 0
super OSObject
super OSObject
super IOMemoryDescriptor
IOKIT_ENABLE_SHARED_PTR None
super IOService
MAX_VAR_NAME_SIZE 63
kNVRAMBankSizeKey "nvram-bank-size"
kNVRAMBankCountKey "nvram-bank-count"
kNVRAMCurrentBankKey "nvram-current-bank"
kCurrentGenerationCountKey "Generation"
kCurrentNVRAMVersionKey "Version"
kNVRAMCommonUsedKey "CommonUsed"
kNVRAMSystemUsedKey "SystemUsed"
kIONVRAMPrivilege kIOClientPrivilegeAdministrator
MIN_SYNC_NOW_INTERVAL 15*60
DEBUG_ERROR DEBUG_ALWAYS
KERNEL_ONLY_VAR_NAME_PREFIX "krn."
IONVRAMSystemVariableListInternal IONVRAMSystemVariableList, 	                                      "force-lock-bits", 	                                      "stress-rack"
kIODTNVRAMDiagsStatsKey "Stats"
kIODTNVRAMDiagsInitKey "Init"
kIODTNVRAMDiagsReadKey "Read"
kIODTNVRAMDiagsWriteKey "Write"
kIODTNVRAMDiagsDeleteKey "Delete"
kIODTNVRAMDiagsNameKey "Name"
kIODTNVRAMDiagsSizeKey "Size"
kIODTNVRAMDiagsPresentKey "Present"
NVRAM_CHRP_APPLE_HEADER_NAME_V1 "nvram"
NVRAM_CHRP_APPLE_HEADER_NAME_V2 "2nvram"
NVRAM_CHRP_PARTITION_NAME_COMMON_V1 "common"
NVRAM_CHRP_PARTITION_NAME_SYSTEM_V1 "system"
NVRAM_CHRP_PARTITION_NAME_COMMON_V2 "2common"
NVRAM_CHRP_PARTITION_NAME_SYSTEM_V2 "2system"
NVRAM_CHRP_LENGTH_BLOCK_SIZE 0x10
VARIABLE_STORE_SIGNATURE 'NVV3'
VARIABLE_STORE_VERSION 0x1
VARIABLE_DATA 0x55AA
INVALIDATED_VARIABLE_DATA 0x0000
VAR_IN_DELETED_TRANSITION 0xFE
VAR_DELETED 0xFD
VAR_INACTIVE 0xFB
VAR_ADDED 0x7F
VAR_NEW_STATE_NONE 0x01
VAR_NEW_STATE_REMOVE 0x02
VAR_NEW_STATE_APPEND 0x03
super OSObject
PLATFORM_ACTION_FLAGS_ALLOW_NESTED_CALLOUTS 1
PLATFORM_ACTION_FLAGS_NO_LOGGING 2
kShutdownTimeout 30
APPLE_VENDOR_VARIABLE_GUID "4d1ede05-38c7-4a6a-9cc6-4bcca8b38c14"
super IOService
RESTART_NODE_PATH "/defaults"
super IOPlatformExpert
super IOService
super IOService
super IOService
super IOService
super OSObject
super OSObject
super IOService
super OSObject
super IOEventSource
_IOPMPOWERSTATEQUEUE_H_ None
IOKIT_ENABLE_SHARED_PTR None
kIOPMrootDomainClass "IOPMrootDomain"
LOG_PREFIX "PMRD: "
MSG(x...) do { kprintf(LOG_PREFIX x); IOLog(x); } while (false)
LOG(x...) do { kprintf(LOG_PREFIX x); } while (false)
DLOG(x...) do {     if (kIOLogPMRootDomain & gIOKitDebug) 	IOLog(LOG_PREFIX x);     else 	os_log(OS_LOG_DEFAULT, LOG_PREFIX x); } while (false)
DMSG(x...) do {     if (kIOLogPMRootDomain & gIOKitDebug) { 	kprintf(LOG_PREFIX x);     } } while (false)
_LOG(x...) None
CHECK_THREAD_CONTEXT None
ASSERT_GATED() do {                                                            if (gIOPMWorkLoop && gIOPMWorkLoop->inGate() != true) { 	panic("RootDomain: not inside PM gate");                }                                                       } while(false)
YMDTF "%04d/%02d/%d %02d:%02d:%02d"
kIOSleepSupportedKey "IOSleepSupported"
kIOPMSystemCapabilitiesKey "System Capabilities"
kIOPMSystemDefaultOverrideKey "SystemPowerProfileOverrideDict"
kIORequestWranglerIdleKey "IORequestIdle"
kDefaultWranglerIdlePeriod 1000
kIOSleepWakeFailureString "SleepWakeFailureString"
kIOEFIBootRomFailureKey "wake-failure"
kIOSleepWakeFailurePanic "SleepWakeFailurePanic"
POWER_STATE(x) {(uint32_t) x, #x}
ON_POWER kIOPMPowerOn
RESTART_POWER kIOPMRestart
SLEEP_POWER kIOPMAuxPowerOn
kIOPMRootDomainWakeTypeSleepService "SleepService"
kIOPMRootDomainWakeTypeMaintenance "Maintenance"
kIOPMRootDomainWakeTypeSleepTimer "SleepTimer"
kIOPMrootDomainWakeTypeLowBattery "LowBattery"
kIOPMRootDomainWakeTypeUser "User"
kIOPMRootDomainWakeTypeAlarm "Alarm"
kIOPMRootDomainWakeTypeNetwork "Network"
kIOPMRootDomainWakeTypeHIDActivity "HID Activity"
kIOPMRootDomainWakeTypeNotification "Notification"
kIOPMRootDomainWakeTypeHibernateError "HibernateError"
kIOPMSystemCapabilityInterest "IOPMSystemCapabilityInterest"
kRootDomainEntitlementSetProperty "com.apple.private.iokit.rootdomain-set-property"
WAKEEVENT_LOCK() IOLockLock(wakeEventLock)
WAKEEVENT_UNLOCK() IOLockUnlock(wakeEventLock)
AGGRESSIVES_LOCK() IOLockLock(featuresDictLock)
AGGRESSIVES_UNLOCK() IOLockUnlock(featuresDictLock)
kAggressivesMinValue 1
AGGRESSIVENESS_TYPE(x) {(uint32_t) x, #x}
SYSTEM_SLEEP_PREVENTER(x) {(int) x, #x}
kCPUUnknownIndex 9999999
kBadPMFeatureID 0
PMSETTING_LOCK() IOLockLock(settingsCtrlLock)
PMSETTING_UNLOCK() IOLockUnlock(settingsCtrlLock)
PMSETTING_WAIT(p) IOLockSleep(settingsCtrlLock, p, THREAD_UNINT)
PMSETTING_WAKEUP(p) IOLockWakeup(settingsCtrlLock, p, true)
kPMHaltMaxWorkers 8
kPMHaltTimeoutMS 100
super IOService
kRootDomainSettingsCount 20
kRootDomainNoPublishSettingsCount 4
CAP_WILL_CHANGE_TO_OFF(params, flag)     (((params)->changeFlags & kIOPMSystemCapabilityWillChange) &&      ((params)->fromCapabilities & (flag)) &&      (((params)->toCapabilities & (flag)) == 0))
CAP_DID_CHANGE_TO_ON(params, flag)     (((params)->changeFlags & kIOPMSystemCapabilityDidChange) &&      ((params)->toCapabilities & (flag)) &&      (((params)->fromCapabilities & (flag)) == 0))
CAP_DID_CHANGE_TO_OFF(params, flag)     (((params)->changeFlags & kIOPMSystemCapabilityDidChange) &&      ((params)->fromCapabilities & (flag)) &&      (((params)->toCapabilities & (flag)) == 0))
CAP_WILL_CHANGE_TO_ON(params, flag)     (((params)->changeFlags & kIOPMSystemCapabilityWillChange) &&      ((params)->toCapabilities & (flag)) &&      (((params)->fromCapabilities & (flag)) == 0))
kIOPMRegisterNVRAMTracePointHandlerKey "IOPMRegisterNVRAMTracePointHandler"
super OSObject
kPMBestGuessPCIDevicesCount 25
kPMMaxRTCBitfieldSize 32
super OSObject
kAssertUniqueIDStart 500
_IOPMROOTDOMAINIOCTLS_H_ None
PMIOCGETVARIDINFO _IOW('P', 25, uint64_t)
PMIOCGETVARNAMEINFO _IOW('P', 26, uint64_t)
PMIOCSETVARINFO _IOW('P', 27, uint64_t)
PMVARNAMELEN 16
kIOMediaPreferredBlockSizeKey "Preferred Block Size"
super IOService
super IOService
super OSObject
LOCK() if( options & kLocking)	lck_mtx_lock( &gIORangeAllocatorLock )
UNLOCK() if( options & kLocking)	lck_mtx_unlock( &gIORangeAllocatorLock )
super OSObject
kIORegPlaneParentSuffix "ParentLinks"
kIORegPlaneChildSuffix "ChildLinks"
kIORegPlaneNameSuffix "Name"
kIORegPlaneLocationSuffix "Location"
KASLR_IOREG_DEBUG 0
UNLOCK lck_rw_done( &gIORegistryLock )
RLOCK lck_rw_lock_shared( &gIORegistryLock )
WLOCK lck_rw_lock_exclusive( &gIORegistryLock );      	        gIORegistryGenerationCount++
PUNLOCK IORecursiveLockUnlock( reserved->fLock )
PLOCK IORecursiveLockLock( reserved->fLock )
IOREGSPLITTABLES None
registryTable() fRegistryTable
DEBUG_FREE 1
wrap2(type, constant)                                           OSObject *                                                              IORegistryEntry::copyProperty( type * aKey) constant                    {                                                                           OSObject *	obj;                                                                                                                                PLOCK;                                                                  obj = getProperty( aKey );                                              if( obj)                                                            	obj->retain();                                                      PUNLOCK;                                                                                                                                        return( obj );                                                      }
wrap4(type, constant) OSObject * IORegistryEntry::getProperty( type *                  aKey, 	                      const IORegistryPlane * plane, 	                      IOOptionBits            options ) constant {     OSObject * obj = getProperty( aKey );         if ( (NULL == obj) && plane && (options & kIORegistryIterateRecursively) ) { 	IORegistryEntry * entry = (IORegistryEntry *) this; 	IORegistryIterator * iter; 	iter = IORegistryIterator::iterateOver( entry, plane, options );         	if(iter) { 	    while ( (NULL == obj) && (entry = iter->getNextObject()) ) { 	        obj = entry->getProperty( aKey ); 	    } 	    iter->release(); 	}     }         return( obj ); }
wrap5(type, constant) OSObject * IORegistryEntry::copyProperty( type *                  aKey, 	                      const IORegistryPlane * plane, 	                      IOOptionBits            options ) constant {     OSObject * obj = copyProperty( aKey );         if ( (NULL == obj) && plane && (options & kIORegistryIterateRecursively) ) { 	IORegistryEntry * entry = (IORegistryEntry *) this; 	IORegistryIterator * iter; 	iter = IORegistryIterator::iterateOver( entry, plane, options );         	if(iter) { 	    while ( (NULL == obj) && (entry = iter->getNextObject()) ) { 	        obj = entry->copyProperty( aKey ); 	    } 	    iter->release(); 	}     }         return( obj ); }
IOLinkIterator OSCollectionIterator
super OSObject
super OSIterator
IOKIT_ENABLE_SHARED_PTR None
super OSObject
_IOEPORTERDEFS_H None
IORERROR_LOG None
IORERROR(fmt, args...) IOLog(fmt, ##args);
PREFL_MEMOP_FAIL(__val, __type) do {      if (__val <= 0) {  	IORERROR("%s - %s <= 0!\n", __func__, #__val);  	res = kIOReturnUnderrun;  	goto finish;      }  else if (__val > INT_MAX / (int)sizeof(__type)) {  	IORERROR("%s - %s > INT_MAX / sizeof(%s)!\n",__func__,#__val,#__type);	res = kIOReturnOverrun;  	goto finish;      }  } while(0)
PREFL_MEMOP_PANIC(__val, __type) do {      if (__val <= 0) {  	panic("%s - %s <= 0!", __func__, #__val);      }  else if (__val > INT_MAX / (int)sizeof(__type)) {  	panic("%s - %s > INT_MAX / sizeof(%s)!", __func__, #__val, #__type);      }  } while(0)
IOREPORTER_DEBUG_ELEMENT(idx) do {                                                                    IOLog("IOReporter::DrvID: %llx | Elt:[%3d] |ID: %llx |Ticks: %llu |",   _elements[idx].provider_id,                                             idx,                                                                    _elements[idx].channel_id,                                              _elements[idx].timestamp);                                              IOLog("0: %llu | 1: %llu | 2: %llu | 3: %llu\n",                        _elements[idx].values.v[0],                                             _elements[idx].values.v[1],                                             _elements[idx].values.v[2],                                             _elements[idx].values.v[3]);                                            } while(0)
IOREPORTER_CHECK_LOCK() do {                                                                        if (!_reporterIsLocked) {                                           	panic("%s was called out of locked context!", __PRETTY_FUNCTION__);     }                                                                   } while(0)
IOREPORTER_CHECK_CONFIG_LOCK() do {                                                                        if (!_reporterConfigIsLocked) {                                     	panic("%s was called out of config locked context!", __PRETTY_FUNCTION__);     }                                                                   } while(0)
IOKIT_ENABLE_SHARED_PTR None
super OSObject
super IOService
LOG kprintf
MATCH_DEBUG 0
DEBUG_NOTIFIER_LOCKED 0
super IORegistryEntry
LOCKREADNOTIFY() IORecursiveLockLock( gNotificationLock )
LOCKWRITENOTIFY() IORecursiveLockLock( gNotificationLock )
LOCKWRITE2READNOTIFY() None
UNLOCKNOTIFY() IORecursiveLockUnlock( gNotificationLock )
SLEEPNOTIFY(event) IORecursiveLockSleep( gNotificationLock, (void *)(event), THREAD_UNINT )
SLEEPNOTIFYTO(event, deadline)     IORecursiveLockSleepDeadline( gNotificationLock, (void *)(event), deadline, THREAD_UNINT )
WAKEUPNOTIFY(event) IORecursiveLockWakeup( gNotificationLock, (void *)(event),  false )
randomDelay() int del = read_processor_clock();                               	del = (((int)IOThreadSelf()) ^ del ^ (del >> 10)) & 0x3ff;      	IOSleep( del );
queue_element(entry, element, type, field) do { 	vm_address_t __ele = (vm_address_t) (entry);    	__ele -= -4 + ((size_t)(&((type) 4)->field));   	(element) = (type) __ele;                           } while(0)
iterqueue(que, elt)                             	for (queue_entry_t elt = queue_first(que);      	     !queue_end(que, elt);                      	     elt = queue_next(elt))
tailQ(o) setObject(o)
headQ(o) setObject(0, o)
TLOG(fmt, args...)      { if(kIOLogYield & gIOKitDebug) { IOLog("[%llx] ", thread_tid(current_thread())); IOLog(fmt, ## args); }}
propMatch(key) obj = table->getObject(key);                    	if (obj)                                        	{                                               	    OSObject * prop;                            	    done++;                                     	    prop = copyProperty(key);                   	    match = obj->isEqualTo(prop);               	    if (prop) prop->release();                  	    if ((!match) || (done == count)) break;     	}
PM_ERROR(x...) do { kprintf(x);IOLog(x); 	                            } while (false)
PM_LOG(x...) do { kprintf(x); } while (false)
PM_LOG1(x...) do {  	                            if (kIOLogDebugPower & gIOKitDebug) 	                                kprintf(x); } while (false)
PM_LOG2(x...) do {  	                            if (kIOLogDebugPower & gIOKitDebug) 	                                kprintf(x); } while (false)
RD_LOG(x...) do { 	                            if ((kIOLogPMRootDomain & gIOKitDebug) && 	                                (getPMRootDomain() == this)) { 	                                IOLog("PMRD: " x); 	                            }} while (false)
PM_ASSERT_IN_GATE(x) do {                                      assert(gIOPMWorkLoop->inGate());  } while(false)
PM_LOCK() IOLockLock(fPMLock)
PM_UNLOCK() IOLockUnlock(fPMLock)
PM_LOCK_SLEEP(event, dl)    IOLockSleepDeadline(fPMLock, event, dl, THREAD_UNINT)
PM_LOCK_WAKEUP(event) IOLockWakeup(fPMLock, event, false)
us_per_s 1000000
ns_per_us 1000
kMaxTimeRequested k30Seconds
kIOPMTardyAckSPSKey "IOPMTardyAckSetPowerState"
kIOPMTardyAckPSCKey "IOPMTardyAckPowerStateChange"
kPwrMgtKey "IOPowerManagement"
OUR_PMLog(t, a, b) do {                     if (pwrMgt) {                               	if (gIOKitDebug & kIOLogPower)          	    pwrMgt->pmPrint(t, a, b);           	if (gIOKitTrace & kIOTracePowerMgmt)    	    pwrMgt->pmTrace(t, DBG_FUNC_NONE, a, b);            }                                               } while(0)
OUR_PMLogFuncStart(t, a, b) do {            if (pwrMgt) {                               	if (gIOKitDebug & kIOLogPower)          	    pwrMgt->pmPrint(t, a, b);           	if (gIOKitTrace & kIOTracePowerMgmt)    	    pwrMgt->pmTrace(t, DBG_FUNC_START, a, b);           }                                               } while(0)
OUR_PMLogFuncEnd(t, a, b) do {              if (pwrMgt) {                               	if (gIOKitDebug & kIOLogPower)          	    pwrMgt->pmPrint(-t, a, b);          	if (gIOKitTrace & kIOTracePowerMgmt)    	    pwrMgt->pmTrace(t, DBG_FUNC_END, a, b);            }                                               } while(0)
SUPPORT_IDLE_CANCEL 1
kIOPMPowerStateMax 0xFFFFFFFF
kInvalidTicklePowerState kIOPMPowerStateMax
MS_PUSH(n) do { assert(kIOPM_BadMachineState == fSavedMachineState); 	 assert(kIOPM_BadMachineState != n); 	 fSavedMachineState = n; } while (false)
MS_POP() do { assert(kIOPM_BadMachineState != fSavedMachineState); 	 fMachineState = fSavedMachineState; 	 fSavedMachineState = kIOPM_BadMachineState; } while (false)
PM_ACTION_TICKLE(a) do { if (fPMActions.a) { 	 (fPMActions.a)(fPMActions.target, this, &fPMActions); } 	 } while (false)
PM_ACTION_CHANGE(a, x, y)     do { if (fPMActions.a) { 	 (fPMActions.a)(fPMActions.target, this, &fPMActions, gIOPMRequest, x, y); } 	 } while (false)
PM_ACTION_CLIENT(a, x, y, z)     do { if (fPMActions.a) { 	 (fPMActions.a)(fPMActions.target, this, &fPMActions, x, y, z); } 	 } while (false)
MSG_ENTRY(x) {(int) x, #x}
PHASE_ENTRY(x) {(int) x, #x}
_IOKIT_IOSERVICEPMPRIVATE_H None
USE_SETTLE_TIMER 0
fOwner pwrMgt->Owner
fInterestedDrivers pwrMgt->InterestedDrivers
fDriverTimer pwrMgt->DriverTimer
fMachineState pwrMgt->MachineState
fAckTimer pwrMgt->AckTimer
fSettleTimer pwrMgt->SettleTimer
fIdleTimer pwrMgt->IdleTimer
fWatchdogTimer pwrMgt->WatchdogTimer
fWatchdogDeadline pwrMgt->WatchdogDeadline
fWatchdogStart pwrMgt->WatchdogStart
fWatchdogLock pwrMgt->WatchdogLock
fBlockedArray pwrMgt->BlockedArray
fPendingResponseDeadline pwrMgt->PendingResponseDeadline
fSettleTimeUS pwrMgt->SettleTimeUS
fIdleTimerGeneration pwrMgt->IdleTimerGeneration
fHeadNoteChangeFlags pwrMgt->HeadNoteChangeFlags
fHeadNotePowerState pwrMgt->HeadNotePowerState
fHeadNotePowerArrayEntry pwrMgt->HeadNotePowerArrayEntry
fHeadNoteDomainFlags pwrMgt->HeadNoteDomainFlags
fHeadNoteDomainTargetFlags pwrMgt->HeadNoteDomainTargetFlags
fHeadNoteParentConnection pwrMgt->HeadNoteParentConnection
fHeadNoteParentFlags pwrMgt->HeadNoteParentFlags
fHeadNotePendingAcks pwrMgt->HeadNotePendingAcks
fPMLock pwrMgt->PMLock
fInitialPowerChange pwrMgt->InitialPowerChange
fInitialSetPowerState pwrMgt->InitialSetPowerState
fDeviceOverrideEnabled pwrMgt->DeviceOverrideEnabled
fDoNotPowerDown pwrMgt->DoNotPowerDown
fParentsKnowState pwrMgt->ParentsKnowState
fStrictTreeOrder pwrMgt->StrictTreeOrder
fIdleTimerStopped pwrMgt->IdleTimerStopped
fAdjustPowerScheduled pwrMgt->AdjustPowerScheduled
fIsPreChange pwrMgt->IsPreChange
fDriverCallBusy pwrMgt->DriverCallBusy
fPCDFunctionOverride pwrMgt->PCDFunctionOverride
fIdleTimerIgnored pwrMgt->IdleTimerIgnored
fHasAdvisoryDesire pwrMgt->HasAdvisoryDesire
fAdvisoryTickleUsed pwrMgt->AdvisoryTickleUsed
fResetPowerStateOnWake pwrMgt->ResetPowerStateOnWake
fDeviceActiveTimestamp pwrMgt->DeviceActiveTimestamp
fMaxPowerStateEntryTime pwrMgt->MaxPowerStateEntryTime
fMaxPowerStateExitTime pwrMgt->MaxPowerStateExitTime
fActivityLock pwrMgt->ActivityLock
fIdleTimerPeriod pwrMgt->IdleTimerPeriod
fIdleTimerMinPowerState pwrMgt->IdleTimerMinPowerState
fNextIdleTimerPeriod pwrMgt->NextIdleTimerPeriod
fIdleTimerStartTime pwrMgt->IdleTimerStartTime
fDeviceDesire pwrMgt->DeviceDesire
fDesiredPowerState pwrMgt->DesiredPowerState
fPreviousRequestPowerFlags pwrMgt->PreviousRequestPowerFlags
fName pwrMgt->Name
fNumberOfPowerStates pwrMgt->NumberOfPowerStates
fHighestPowerState pwrMgt->HighestPowerState
fPowerStates pwrMgt->PowerStates
fControllingDriver pwrMgt->ControllingDriver
fCurrentPowerState pwrMgt->CurrentPowerState
fParentsCurrentPowerFlags pwrMgt->ParentsCurrentPowerFlags
fMaxPowerState pwrMgt->MaxPowerState
fMergedOutputPowerFlags pwrMgt->MergedOutputPowerFlags
fResponseArray pwrMgt->ResponseArray
fNotifyClientArray pwrMgt->NotifyClientArray
fSerialNumber pwrMgt->SerialNumber
fOutOfBandParameter pwrMgt->OutOfBandParameter
fDriverCallStartTime pwrMgt->DriverCallStartTime
fCurrentCapabilityFlags pwrMgt->CurrentCapabilityFlags
fCurrentPowerConsumption pwrMgt->CurrentPowerConsumption
fTempClampPowerState pwrMgt->TempClampPowerState
fNotifyChildArray pwrMgt->NotifyChildArray
fPowerClients pwrMgt->PowerClients
fDriverCallEntry pwrMgt->DriverCallEntry
fDriverCallParamPtr pwrMgt->DriverCallParamPtr
fDriverCallParamCount pwrMgt->DriverCallParamCount
fDriverCallParamSlots pwrMgt->DriverCallParamSlots
fDriverCallReason pwrMgt->DriverCallReason
fOutOfBandMessage pwrMgt->OutOfBandMessage
fTempClampCount pwrMgt->TempClampCount
fOverrideMaxPowerState pwrMgt->OverrideMaxPowerState
fDeviceUsablePowerState pwrMgt->DeviceUsablePowerState
fDriverCallTimer pwrMgt->DriverCallTimer
fActivityTicklePowerState pwrMgt->ActivityTicklePowerState
fAdvisoryTicklePowerState pwrMgt->AdvisoryTicklePowerState
fActivityTickleCount pwrMgt->ActivityTickleCount
fDeviceWasActive pwrMgt->DeviceWasActive
fAdvisoryTickled pwrMgt->AdvisoryTickled
fWaitReason pwrMgt->WaitReason
fSavedMachineState pwrMgt->SavedMachineState
fLockedFlags pwrMgt->LockedFlags
fPMDriverCallQueue pwrMgt->PMDriverCallQueue
fInsertInterestSet pwrMgt->InsertInterestSet
fRemoveInterestSet pwrMgt->RemoveInterestSet
fReportClientCnt pwrMgt->ReportClientCnt
fReportBuf pwrMgt->ReportBuf
fPMVars pwrMgt->PMVars
fPMActions pwrMgt->PMActions
StateMax(a, b)               (StateOrder((a)) < StateOrder((b)) ? (b) : (a))
StateMin(a, b)               (StateOrder((a)) < StateOrder((b)) ? (a) : (b))
ACK_TIMER_PERIOD 100000000
kIOPMParentInitiated 0x0001
kIOPMSelfInitiated 0x0002
kIOPMNotDone 0x0004
kIOPMDomainWillChange 0x0008
kIOPMDomainDidChange 0x0010
kIOPMDomainPowerDrop 0x0020
kIOPMIgnoreChildren 0x0040
kIOPMSkipAskPowerDown 0x0080
kIOPMSynchronize 0x0100
kIOPMSyncNoChildNotify 0x0200
kIOPMSyncTellPowerDown 0x0400
kIOPMSyncCancelPowerDown 0x0800
kIOPMInitialPowerChange 0x1000
kIOPMRootChangeUp 0x2000
kIOPMRootChangeDown 0x4000
kIOPMExpireIdleTimer 0x8000
kTickleTypePowerDrop 0x01
kTickleTypePowerRise 0x02
kTickleTypeActivity 0x04
kTickleTypeAdvisory 0x08
WORK_QUEUE_STATS 1
_IOKIT_IOSERVICEPRIVATE_H None
IOKIT_ENABLE_SHARED_PTR None
super IODataQueue
IOKIT_ENABLE_SHARED_PTR None
super IOReporter
IOKIT_ENABLE_SHARED_PTR None
super IOReporter
super IOMemoryDescriptor
super IOEventSource
IOMACF_LOG 0
super OSObject
PORT_HASH_SIZE 4096
super IOUserIterator
super IOUserNotification
super IOService
CHECK(cls, obj, out)                      	cls * out;                              	if( !(out = OSDynamicCast( cls, obj)))  	    return( kIOReturnBadArgument )
CHECKLOCKED(cls, obj, out)                                        	IOUserIterator * oIter;                                         	cls * out;                                                      	if( !(oIter = OSDynamicCast(IOUserIterator, obj)))              	    return (kIOReturnBadArgument);                              	if( !(out = OSDynamicCast(cls, oIter->userIteratorObject)))     	    return (kIOReturnBadArgument)
fInternalState reserved
MAX_UEXT_REPLY_SIZE 0x17c0
super IOUserClient2022
super IOUserClient
IOKIT_ENABLE_SHARED_PTR None
MAX_CRITICALITY_OFFSET 16
kWorkloadIDTableKey "WorkloadIDTable"
kRootKey "Root"
kPhasesKey "Phases"
kWorkIntervalTypeKey "WorkIntervalType"
kWorkloadClassKey "WorkloadClass"
kCriticalityOffsetKey "CriticalityOffset"
kDefaultPhaseKey "DefaultPhase"
kFlagsKey "Flags"
kWorkloadIDConfigurationFlagsKey "WorkloadIDConfigurationFlags"
kDisableWorkloadClassThreadPolicyValue "DisableWorkloadClassThreadPolicy"
kWIComplexityAllowedValue "ComplexityAllowed"
super OSObject
fFlags loopRestart
passiveEventChain reserved->passiveEventChain
super IOInterruptController
super IOUserClient2022
_IOKIT_ROOTDOMAINUSERCLIENT_H None
DATA_QUEUE_ENTRY_HEADER_SIZE sizeof(IODataQueueEntry)
YYBISON 1
YYBISON_VERSION "2.3"
YYSKELETON_NAME "yacc.c"
YYPURE 1
YYLSP_NEEDED 0
yyparse OSUnserializeXMLparse
yylex OSUnserializeXMLlex
yyerror OSUnserializeXMLerror
yylval OSUnserializeXMLlval
yychar OSUnserializeXMLchar
yydebug OSUnserializeXMLdebug
yynerrs OSUnserializeXMLnerrs
ARRAY 258
BOOLEAN 259
DATA 260
DICTIONARY 261
IDREF 262
KEY 263
NUMBER 264
SET 265
STRING 266
SYNTAX_ERROR 267
MAX_OBJECTS 131071
MAX_REFED_OBJECTS 65535
YYSTYPE object_t *
YYPARSE_PARAM state
yyerror(s) OSUnserializeerror(STATE, (s))
malloc(size) malloc_impl(size)
malloc_type(type) kalloc_type(type, Z_SET_NOTEARLY)
free(addr) free_impl(addr)
free_type(type, addr)  kfree_type(type, addr)
realloc(addr, osize, nsize) realloc_impl(addr, osize, nsize)
YYFINAL 33
YYLAST 108
YYNTOKENS 19
YYNNTS 15
YYNRULES 32
YYNSTATES 40
YYUNDEFTOK 2
YYMAXUTOK 267
YYPACT_NINF -20
YYTABLE_NINF -1
YYEOF 0
YYACCEPT goto yyacceptlab
YYABORT goto yyabortlab
YYERROR goto yyerrorlab
YYFAIL goto yyerrlab
YYBACKUP(Token, Value)                                  do                                                                if (yychar == YYEMPTY && yylen == 1)                              {                                                                 yychar = (Token);                                               yylval = (Value);                                               yytoken = YYTRANSLATE (yychar);                                 YYPOPSTACK (1);                                                 goto yybackup;                                                }                                                             else                                                              {                                                                 yyerror (YY_("syntax error: cannot back up"));       YYERROR;                                                      }                                                           while (YYID (0))
YYTERROR 1
YYERRCODE 256
YYRHSLOC(Rhs, K) ((Rhs)[K])
TAG_MAX_LENGTH 32
TAG_MAX_ATTRIBUTES 32
TAG_BAD 0
TAG_START 1
TAG_END 2
TAG_EMPTY 3
TAG_IGNORE 4
DATA_ALLOC_SIZE 4096
TEST_HEADERS 0
IOKIT_ENABLE_SHARED_PTR None
kIOServiceTestServiceManagementEntitlementKey "com.apple.iokit.test-service-management"
_IOKIT_TESTIOCONNECTMAPMEMORYPORTLEAK45265408_H_ None
_IOKIT_TESTIODEVICEMEMORYROSETTA_H_ None
_IOKIT_TESTIOSERVICEUSERNOTIFICATION_H_ None
_IOKIT_TESTIOUSERCLIENT2022ENTITLEMENTS_H_ None
DEBG(fmt, args...)      { kprintf(fmt, ## args); }
_IOKIT_IONVRAMCONTROLLER_H None
_IOKIT_APPLEMACIO_H None
_IOKIT_APPLEMACIODEVICE_H None
_IOKIT_APPLENMI_H None
_IOKIT_APPLEPLATFORM_H None
_IOKIT_PLATFORM_IOPLATFORMIO_H None
_IOKIT_IOPM_H None
kAppleClamshellStateKey "AppleClamshellState"
kAppleClamshellCausesSleepKey "AppleClamshellCausesSleep"
kIOPMSleepWakeUUIDKey "SleepWakeUUID"
kIOPMBootSessionUUIDKey "BootSessionUUID"
kIOPMDeepSleepEnabledKey "Standby Enabled"
kIOPMDeepSleepDelayKey "Standby Delay"
kIOPMDeepSleepDelayHighKey "High Standby Delay"
kIOPMStandbyBatteryThresholdKey "Standby Battery Threshold"
kIOPMDestroyFVKeyOnStandbyKey "DestroyFVKeyOnStandby"
kIOPMResetPowerStateOnWakeKey "IOPMResetPowerStateOnWake"
kIOPMAssertionsDriverKey "DriverPMAssertions"
kIOPMAssertionsDriverDetailedKey "DriverPMAssertionsDetailed"
kIOPMDriverAssertionIDKey "ID"
kIOPMDriverAssertionCreatedTimeKey "CreatedTime"
kIOPMDriverAssertionModifiedTimeKey "ModifiedTime"
kIOPMDriverAssertionOwnerStringKey "Owner"
kIOPMDriverAssertionOwnerServiceKey "ServicePtr"
kIOPMDriverAssertionRegistryEntryIDKey "RegistryEntryID"
kIOPMDriverAssertionLevelKey "Level"
kIOPMDriverAssertionAssertedKey "Assertions"
kIOPMMessageClamshellStateChange iokit_family_msg(sub_iokit_powermanagement, 0x100)
kIOPMMessageFeatureChange iokit_family_msg(sub_iokit_powermanagement, 0x110)
kIOPMMessageInternalBatteryFullyDischarged iokit_family_msg(sub_iokit_powermanagement, 0x120)
kIOPMMessageSystemPowerEventOccurred iokit_family_msg(sub_iokit_powermanagement, 0x130)
kIOPMMessageSleepWakeUUIDChange iokit_family_msg(sub_iokit_powermanagement, 0x140)
kIOPMMessageDriverAssertionsChanged iokit_family_msg(sub_iokit_powermanagement, 0x150)
kIOPMMessageDarkWakeThermalEmergency iokit_family_msg(sub_iokit_powermanagement, 0x160)
kIOPMPSExternalConnectedKey "ExternalConnected"
kIOPMPSExternalChargeCapableKey "ExternalChargeCapable"
kIOPMPSBatteryInstalledKey "BatteryInstalled"
kIOPMPSIsChargingKey "IsCharging"
kIOPMFullyChargedKey "FullyCharged"
kIOPMPSAtWarnLevelKey "AtWarnLevel"
kIOPMPSAtCriticalLevelKey "AtCriticalLevel"
kIOPMPSCurrentCapacityKey "CurrentCapacity"
kIOPMPSMaxCapacityKey "MaxCapacity"
kIOPMPSDesignCapacityKey "DesignCapacity"
kIOPMPSTimeRemainingKey "TimeRemaining"
kIOPMPSAmperageKey "Amperage"
kIOPMPSVoltageKey "Voltage"
kIOPMPSCycleCountKey "CycleCount"
kIOPMPSMaxErrKey "MaxErr"
kIOPMPSAdapterInfoKey "AdapterInfo"
kIOPMPSLocationKey "Location"
kIOPMPSErrorConditionKey "ErrorCondition"
kIOPMPSManufacturerKey "Manufacturer"
kIOPMPSManufactureDateKey "ManufactureDate"
kIOPMPSModelKey "Model"
kIOPMPSSerialKey "Serial"
kIOPMDeviceNameKey "DeviceName"
kIOPMPSLegacyBatteryInfoKey "LegacyBatteryInfo"
kIOPMPSBatteryHealthKey "BatteryHealth"
kIOPMPSHealthConfidenceKey "HealthConfidence"
kIOPMPSCapacityEstimatedKey "CapacityEstimated"
kIOPMPSBatteryChargeStatusKey "ChargeStatus"
kIOPMPSBatteryTemperatureKey "Temperature"
kIOPMPSAdapterDetailsKey "AdapterDetails"
kIOPMPSChargerConfigurationKey "ChargerConfiguration"
kIOPMBatteryChargeStatusTooHot "HighTemperature"
kIOPMBatteryChargeStatusTooCold "LowTemperature"
kIOPMBatteryChargeStatusTooHotOrCold "HighOrLowTemperature"
kIOPMBatteryChargeStatusGradient "BatteryTemperatureGradient"
kIOPMPSAdapterDetailsIDKey "AdapterID"
kIOPMPSAdapterDetailsWattsKey "Watts"
kIOPMPSAdapterDetailsRevisionKey "AdapterRevision"
kIOPMPSAdapterDetailsSerialNumberKey "SerialNumber"
kIOPMPSAdapterDetailsFamilyKey "FamilyCode"
kIOPMPSAdapterDetailsAmperageKey "Current"
kIOPMPSAdapterDetailsDescriptionKey "Description"
kIOPMPSAdapterDetailsPMUConfigurationKey "PMUConfiguration"
kIOPMPSAdapterDetailsVoltage "AdapterVoltage"
kIOPMPSAdapterDetailsSourceIDKey "Source"
kIOPMPSAdapterDetailsErrorFlagsKey "ErrorFlags"
kIOPMPSAdapterDetailsSharedSourceKey "SharedSource"
kIOPMPSAdapterDetailsCloakedKey "CloakedSource"
kIOPMPSInvalidWakeSecondsKey "BatteryInvalidWakeSeconds"
kIOPMPSPostChargeWaitSecondsKey "PostChargeWaitSeconds"
kIOPMPSPostDishargeWaitSecondsKey "PostDischargeWaitSeconds"
kIOPMGraphicsPowerLimitsKey "Graphics_Power_Limits"
kIOPMGraphicsPowerLimitPerformanceKey "Graphics_Power_Performance"
kIOPMCPUPowerLimitsKey "CPU_Power_Limits"
kIOPMCPUPowerLimitProcessorSpeedKey "CPU_Speed_Limit"
kIOPMCPUPowerLimitProcessorCountKey "CPU_Available_CPUs"
kIOPMCPUPowerLimitSchedulerTimeKey "CPU_Scheduler_Limit"
kIOPMThermalLevelWarningKey "Thermal_Level_Warning"
kIOPMThermalWarningLevelNormal kIOPMThermalLevelNormal
kIOPMThermalWarningLevelDanger kIOPMThermalLevelWarning
kIOPMThermalWarningLevelCrisis kIOPMThermalLevelCritical
kIOPMSettingWakeOnRingKey "Wake On Modem Ring"
kIOPMSettingRestartOnPowerLossKey "Automatic Restart On Power Loss"
kIOPMSettingWakeOnACChangeKey "Wake On AC Change"
kIOPMSettingSleepOnPowerButtonKey "Sleep On Power Button"
kIOPMSettingWakeOnClamshellKey "Wake On Clamshell Open"
kIOPMSettingReduceBrightnessKey "ReduceBrightness"
kIOPMSettingDisplaySleepUsesDimKey "Display Sleep Uses Dim"
kIOPMSettingTimeZoneOffsetKey "TimeZoneOffsetSeconds"
kIOPMSettingMobileMotionModuleKey "MobileMotionModule"
kIOPMSettingGraphicsSwitchKey "GPUSwitch"
kIOPMSettingProModeControl "ProModeControl"
kIOPMSettingProModeDefer "ProModeDefer"
kIOPMSettingAutoWakeSecondsKey "wake"
kIOPMSettingAutoWakeCalendarKey "WakeByCalendarDate"
kIOPMSettingAutoPowerSecondsKey "poweron"
kIOPMSettingAutoPowerCalendarKey "PowerByCalendarDate"
kIOPMSettingDebugWakeRelativeKey "WakeRelativeToSleep"
kIOPMSettingDebugPowerRelativeKey "PowerRelativeToShutdown"
kIOPMSettingMaintenanceWakeCalendarKey "MaintenanceWakeCalendarDate"
kIOREMSleepEnabledKey "REMSleepEnabled"
kIOBatteryInfoKey "IOBatteryInfo"
kIOBatteryCurrentChargeKey "Current"
kIOBatteryCapacityKey "Capacity"
kIOBatteryFlagsKey "Flags"
kIOBatteryVoltageKey "Voltage"
kIOBatteryAmperageKey "Amperage"
kIOBatteryCycleCountKey "Cycle Count"
kIOPMMessageBatteryStatusHasChanged iokit_family_msg(sub_iokit_pmu, 0x100)
kIOPMUMessageLegacyAutoWake iokit_family_msg(sub_iokit_pmu, 0x200)
kIOPMUMessageLegacyAutoPower iokit_family_msg(sub_iokit_pmu, 0x210)
IOPM_POWER_SOURCE_REV 2
_IOKIT_IOPMINFORMEE_H None
kPMSetAggressiveness 0
kPMGetAggressiveness 1
kPMSleepSystem 2
kPMAllowPowerChange 3
kPMCancelPowerChange 4
kPMShutdownSystem 5
kPMRestartSystem 6
kPMSleepSystemOptions 7
kPMSetMaintenanceWakeCalendar 8
kPMSetUserAssertionLevels 9
kPMActivityTickle 10
kPMGetSystemSleepType 11
kPMSetClamshellSleepState 12
kPMSleepWakeWatchdogEnable 13
kPMSleepWakeDebugTrig 14
kPMSetDisplayPowerOn 15
kPMSetDisplayState 16
kPMRequestIdleSleepRevert 17
kNumPMMethods 18
_IOPMPowerSource_h_ None
_IOKIT_IOPMPOWERSTATE_H None
_IOKIT_IOPMPRIVATE_H None
kIOPMEventTypeIntermediateFlag 0x10000000
kIOPMMessageUserIsActiveChanged iokit_family_msg(sub_iokit_powermanagement, 0x400)
kIOPMMessageLastCallBeforeSleep iokit_family_msg(sub_iokit_powermanagement, 0x410)
kIOPMMessageIdleSleepPreventers iokit_family_msg(sub_iokit_powermanagement, 0x420)
kIOPMMessageSystemSleepPreventers iokit_family_msg(sub_iokit_powermanagement, 0x430)
kIOPMMessageLaunchBootSpinDump iokit_family_msg(sub_iokit_powermanagement, 0x440)
kIOPMMessageProModeStateChange iokit_family_msg(sub_iokit_powermanagement, 0x450)
kIOPMMessageRequestUserActive iokit_family_msg(sub_iokit_powermanagement, 0x460)
kIOPMMessageRequestSystemShutdown iokit_family_msg(sub_iokit_powermanagement, 0x470)
kIOPMClamshellSleepKey "Clamshell Sleep"
kIOPMPowerButtonSleepKey "Power Button Sleep"
kIOPMSoftwareSleepKey "Software Sleep"
kIOPMOSSwitchHibernationKey "OS Switch Sleep"
kIOPMIdleSleepKey "Idle Sleep"
kIOPMLowPowerSleepKey "Low Power Sleep"
kIOPMThermalEmergencySleepKey "Thermal Emergency Sleep"
kIOPMSleepServiceExitKey "Sleep Service Back to Sleep"
kIOPMDarkWakeThermalEmergencyKey "Dark Wake Thermal Emergency"
kIOPMNotificationWakeExitKey "Notification Wake Back to Sleep"
kIOPMPSRestrictedModeKey "RestrictedMode"
kIOPMPSAdapterDetailsIsWirelessKey "IsWireless"
kIOPMPSAdapterDetailsPowerTierKey "AdapterPowerTier"
kIOPMSleepServiceScheduleImmediate "SleepServiceImmediate"
kIOPMSettingSleepServiceWakeCalendarKey "SleepServiceWakeCalendarKey"
kIOPMStateConsoleShutdown "ConsoleShutdown"
kIOPMSettingSilentRunningKey "SilentRunning"
kIOPMFeatureSilentRunningKey kIOPMSettingSilentRunningKey
kIOPMSettingLowLatencyAudioModeKey "LowLatencyAudioMode"
kIOPMSleepStatisticsKey "SleepStatistics"
kIOPMSleepStatisticsAppsKey "AppStatistics"
kIOPMIdleSleepPreventersKey "IdleSleepPreventers"
kIOPMSystemSleepPreventersKey "SystemSleepPreventers"
kIOPMIdleSleepPreventersWithIDKey "IdleSleepPreventersWithID"
kIOPMSystemSleepPreventersWithIDKey "SystemSleepPreventersWithID"
kIOPMStatsNameKey "Name"
kIOPMStatsPIDKey "Pid"
kIOPMStatsTimeMSKey "TimeMS"
kIOPMStatsApplicationResponseTypeKey "ResponseType"
kIOPMStatsMessageTypeKey "MessageType"
kIOPMStatsPowerCapabilityKey "PowerCaps"
kIOPMStatsSystemTransitionKey "TransitionType"
kIOPMStatsResponseTimedOut "ResponseTimedOut"
kIOPMStatsResponseCancel "ResponseCancel"
kIOPMStatsResponseSlow "ResponseSlow"
kIOPMStatsResponsePrompt "ResponsePrompt"
kIOPMStatsDriverPSChangeSlow "DriverPSChangeSlow"
kIOPMLoginWindowProgressKey "LoginWindowProgress"
kIOPMCoreDisplayProgressKey "CoreDisplayProgress"
kIOPMCoreGraphicsProgressKey "CoreGraphicsProgress"
kIOPMDynamicStoreSleepFailureKey "SleepFailure"
kIOPMSleepWakeFailureKey "PMFailurePhase"
kIOPMSleepWakeFailureCodeKey "PMStatusCode"
kIOPMSleepWakeFailureLoginKey "LWFailurePhase"
kIOPMSleepWakeFailureUUIDKey "UUID"
kIOPMSleepWakeFailureDateKey "Date"
kIOPMSleepWakeWdogRebootKey "SWWdogTriggeredRestart"
kIOPMSleepWakeWdogLogsValidKey "SWWdogLogsValid"
kIOPMFeatureAutoPowerOffKey "AutoPowerOff"
kIOPMAutoPowerOffEnabledKey "AutoPowerOff Enabled"
kIOPMAutoPowerOffDelayKey "AutoPowerOff Delay"
kIOPMAutoPowerOffTimerKey "AutoPowerOff Timer"
kIOPMDeepSleepTimerKey "Standby Timer"
kIOPMUserWakeAlarmScheduledKey "UserWakeAlarmScheduled"
kIOPMDeepIdleSupportedKey "IOPMDeepIdleSupported"
kIOPMUserTriggeredFullWakeKey "IOPMUserTriggeredFullWake"
kIOPMUserIsActiveKey "IOPMUserIsActive"
kIOPMDriverWakeEventsKey "IOPMDriverWakeEvents"
kIOPMWakeEventTimeKey "Time"
kIOPMWakeEventFlagsKey "Flags"
kIOPMWakeEventReasonKey "Reason"
kIOPMWakeEventDetailsKey "Details"
kIOPMFeatureProModeKey "ProMode"
kIOPMWakeEventSource 0x00000001
kIOPMWakeEventAOTExit 0x00000002
kIOPMWakeEventAOTPossibleExit 0x00000004
kIOPMWakeEventAOTConfirmedPossibleExit 0x00000008
kIOPMWakeEventAOTRejectedPossibleExit 0x00000010
kIOPMWakeEventAOTExpiredPossibleExit 0x00000020
kIOPMAOTPowerKey "aot-power"
kIOPMDarkWakeMaxPowerStateKey "IOPMDarkWakeMaxPowerState"
kIOPMSystemSleepPolicySignature 0x54504c53
kIOPMSystemSleepPolicyVersion 2
kIOPMSystemSleepTypeKey "IOPMSystemSleepType"
kIOPMSystemSleepParametersKey "IOPMSystemSleepParameters"
kIOPMSystemSleepParametersVersion 2
SWD_HDR_SIGNATURE 0xdeb8da2a
SWD_STACKSHOT_VAR_PREFIX "sleepwake_diags"
SWD_WDOG_ENABLED 0x01
SWD_BOOT_BY_SW_WDOG 0x02
SWD_BOOT_BY_OSX_WDOG 0x04
SWD_VALID_LOGS 0x08
SWD_LOGS_IN_FILE 0x10
SWD_LOGS_IN_MEM 0x20
SWD_PWR_BTN_STACKSHOT 0x30
SWD_DATA_CRC_ERROR 0x010000
SWD_BUF_SIZE_ERROR 0x020000
SWD_HDR_SIZE_ERROR 0x040000
SWD_FILEOP_ERROR 0x080000
SWD_HDR_SIGNATURE_ERROR 0x100000
SWD_INTERNAL_FAILURE 0x200000
kOSWatchdogStacksFilename "/var/log/OSXWatchdogStacks.gz"
kOSWatchdogFailureStringFile "/var/log/OSWatchdogFailureString.txt"
kSleepWakeStacksFilename "/var/log/SleepWakeStacks.gz"
kSleepWakeFailureStringFile "/var/log/SleepWakeFailureString.txt"
kSleepCntChID IOREPORT_MAKEID('S','l','e','e','p','C','n','t')
kDarkWkCntChID IOREPORT_MAKEID('G','U','I','W','k','C','n','t')
kUserWkCntChID IOREPORT_MAKEID('D','r','k','W','k','C','n','t')
kAssertDelayBcktCnt 11
kAssertDelayBcktSize 3
kAssertDelayChID IOREPORT_MAKEID('r','d','A','s','r','t','D','l')
kSleepDelaysBcktCnt 13
kSleepDelaysBcktSize 10
kSleepDelaysChID IOREPORT_MAKEID('r','d','S','l','p','D','l','y')
kSleepOptionDisplayCapturedModeKey "DisplayCapturedMode"
kIOPMPerformanceWarningKey "Performance_Warning"
_IOKIT_IOPOWERCONNECTION_H None
_IOKIT_ROOTDOMAIN_H None
kIOPMUndefinedDriverAssertionID 0
kIOPMDriverAssertionLevelOff 0
kIOPMDriverAssertionLevelOn 255
kRootDomainSupportedFeatures "Supported Features"
kRootDomainSleepReasonKey "Last Sleep Reason"
kRootDomainSleepOptionsKey "Last Sleep Options"
kIOPMRootDomainWakeReasonKey "Wake Reason"
kIOPMRootDomainWakeTypeKey "Wake Type"
kIOPMRootDomainPowerStatusKey "Power Status"
kIOPMClamshellSleepKey "Clamshell Sleep"
kIOPMPowerButtonSleepKey "Power Button Sleep"
kIOPMSoftwareSleepKey "Software Sleep"
kIOPMOSSwitchHibernationKey "OS Switch Sleep"
kIOPMIdleSleepKey "Idle Sleep"
kIOPMLowPowerSleepKey "Low Power Sleep"
kIOPMThermalEmergencySleepKey "Thermal Emergency Sleep"
kIOPMMaintenanceSleepKey "Maintenance Sleep"
kIOPMRootDomainLidCloseCString "LidClose"
kIOPMRootDomainBatPowerCString "BatPower"
IOPM_ROOTDOMAIN_REV 2
_IORTCCONTROLLER_H None
__IOSKYWALKSUPPORT_H None
_IOWATCHDOGTIMER_H None
super IOService
kWatchDogEnabledProperty "IOWatchDogEnabled"
super IOService
super IOInterruptController
_IOKIT_GENERICINTERRUPTCONTROLLER_H None
_AES_H None
AES_BLOCK_SIZE 16
aes_ret int
aes_good 0
aes_error -1
aes_rval aes_ret
_CRYPTO_MD5_H_ None
MD5_DIGEST_LENGTH 16
_CRYPTO_SHA1_H_ None
SHA_DIGEST_LENGTH 20
SHA1_RESULTLEN SHA_DIGEST_LENGTH
sha1_init(c) SHA1Init(c)
sha1_loop(c, b, l)      SHA1Update(c, b, l)
sha1_result(c, b)       SHA1Final(b, c)
_CRYPTO_SHA2_H__ None
SHA256_BLOCK_LENGTH CCSHA256_BLOCK_SIZE
SHA256_DIGEST_LENGTH CCSHA256_OUTPUT_SIZE
SHA384_BLOCK_LENGTH CCSHA512_BLOCK_SIZE
SHA384_DIGEST_LENGTH CCSHA384_OUTPUT_SIZE
SHA512_BLOCK_LENGTH CCSHA512_BLOCK_SIZE
SHA512_DIGEST_LENGTH CCSHA512_OUTPUT_SIZE
ELOG(fmt, args...)      SK_ERR(fmt, ##args)
DLOG(fmt, args...)      SK_DF(SK_VERB_IOSK, fmt, ##args)
super OSObject
super OSObject
super OSObject
super OSObject
super IOBufferMemoryDescriptor
__ACTBL_H__ None
DSDT_SIG "DSDT"
FADT_SIG "FACP"
FACS_SIG "FACS"
PSDT_SIG "PSDT"
RSDP_SIG "RSD PTR "
RSDT_SIG "RSDT"
XSDT_SIG "XSDT"
SSDT_SIG "SSDT"
RSDP_NAME "RSDP"
ACPI_TABLE_HEADER_DEF char                    Signature[4];            UINT32                  Length;                  UINT8                   Revision;                UINT8                   Checksum;                char                    OemId[6];                char                    OemTableId[8];           UINT32                  OemRevision;             char                    AslCompilerId[4];        UINT32                  AslCompilerRevision;
ACPI_RSDP_REV0_SIZE 20
ACPI_GLOCK_PENDING 0x01
ACPI_GLOCK_OWNED 0x02
ACPI_FADT_COMMON ACPI_TABLE_HEADER_DEF UINT32                  V1_FirmwareCtrl;     UINT32                  V1_Dsdt;             UINT8                   Reserved1;           UINT8                   Prefer_PM_Profile;   UINT16                  SciInt;              UINT32                  SmiCmd;              UINT8                   AcpiEnable;          UINT8                   AcpiDisable;         UINT8                   S4BiosReq;           UINT8                   PstateCnt;           UINT32                  V1_Pm1aEvtBlk;       UINT32                  V1_Pm1bEvtBlk;       UINT32                  V1_Pm1aCntBlk;       UINT32                  V1_Pm1bCntBlk;       UINT32                  V1_Pm2CntBlk;        UINT32                  V1_PmTmrBlk;         UINT32                  V1_Gpe0Blk;          UINT32                  V1_Gpe1Blk;          UINT8                   Pm1EvtLen;           UINT8                   Pm1CntLen;           UINT8                   Pm2CntLen;           UINT8                   PmTmLen;             UINT8                   Gpe0BlkLen;          UINT8                   Gpe1BlkLen;          UINT8                   Gpe1Base;            UINT8                   CstCnt;              UINT16                  Plvl2Lat;            UINT16                  Plvl3Lat;            UINT16                  FlushSize;           UINT16                  FlushStride;         UINT8                   DutyOffset;          UINT8                   DutyWidth;           UINT8                   DayAlrm;             UINT8                   MonAlrm;             UINT8                   Century;             UINT16                  IapcBootArch;        UINT8                   Reserved2;
PM_UNSPECIFIED 0
PM_DESKTOP 1
PM_MOBILE 2
PM_WORKSTATION 3
PM_ENTERPRISE_SERVER 4
PM_SOHO_SERVER 5
PM_APPLIANCE_PC 6
BAF_LEGACY_DEVICES 0x0001
BAF_8042_KEYBOARD_CONTROLLER 0x0002
FADT2_REVISION_ID 3
FADT2_MINUS_REVISION_ID 2
ACPI_FLAG_OFFSET(d, f, o)         (UINT8) (ACPI_OFFSET (d,f) +	                                         sizeof(((d *)0)->f) + o)
ACPI_MEM_NOT_ALLOCATED 0
ACPI_MEM_ALLOCATED 1
ACPI_MEM_MAPPED 2
ACPI_TABLE_SINGLE 0x00
ACPI_TABLE_MULTIPLE 0x01
ACPI_TABLE_EXECUTABLE 0x02
ACPI_TABLE_ROOT 0x00
ACPI_TABLE_PRIMARY 0x10
ACPI_TABLE_SECONDARY 0x20
ACPI_TABLE_ALL 0x30
ACPI_TABLE_TYPE_MASK 0x30
ACPI_FADT_FLAG_OFFSET(f, o)      ACPI_FLAG_OFFSET (FADT_DESCRIPTOR,f,o)
ACPI_FACS_FLAG_OFFSET(f, o)      ACPI_FLAG_OFFSET (FACS_DESCRIPTOR,f,o)
__ACTBL1_H__ None
ACPI_SIG_ASF "ASF!"
ACPI_SIG_BOOT "BOOT"
ACPI_SIG_CPEP "CPEP"
ACPI_SIG_DBGP "DBGP"
ACPI_SIG_ECDT "ECDT"
ACPI_SIG_HPET "HPET"
ACPI_SIG_MADT "APIC"
ACPI_SIG_MCFG "MCFG"
ACPI_SIG_SBST "SBST"
ACPI_SIG_SLIT "SLIT"
ACPI_SIG_SPCR "SPCR"
ACPI_SIG_SPMI "SPMI"
ACPI_SIG_SRAT "SRAT"
ACPI_SIG_TCPA "TCPA"
ACPI_SIG_WDRT "WDRT"
APIC_SIG "APIC"
BOOT_SIG "BOOT"
SBST_SIG "SBST"
ACPI_ASF_HEADER_DEF UINT8                   Type; UINT8                   Reserved; UINT16                  Length;
ASF_INFO 0
ASF_ALERT 1
ASF_CONTROL 2
ASF_BOOT 3
ASF_ADDRESS 4
ASF_RESERVED 5
DUAL_PIC 0
MULTIPLE_APIC 1
APIC_HEADER_DEF UINT8                   Type; UINT8                   Length;
APIC_PROCESSOR 0
APIC_IO 1
APIC_XRUPT_OVERRIDE 2
APIC_NMI 3
APIC_LOCAL_NMI 4
APIC_ADDRESS_OVERRIDE 5
APIC_IO_SAPIC 6
APIC_LOCAL_SAPIC 7
APIC_XRUPT_SOURCE 8
APIC_RESERVED 9
ACPI_MADT_IFLAGS UINT8                   Polarity        : 2;     UINT8                   TriggerMode     : 2;     UINT8                                   : 4;     UINT8                   Reserved1;
ACPI_MADT_LFLAGS UINT8                   ProcessorEnabled: 1;     UINT8                                   : 7;     UINT8                   Reserved2[3];
POLARITY_CONFORMS 0
POLARITY_ACTIVE_HIGH 1
POLARITY_RESERVED 2
POLARITY_ACTIVE_LOW 3
TRIGGER_CONFORMS 0
TRIGGER_EDGE 1
TRIGGER_RESERVED 2
TRIGGER_LEVEL 3
SRAT_SUBTABLE_HEADER UINT8                   Type; UINT8                   Length;
SRAT_CPU_AFFINITY 0
SRAT_MEMORY_AFFINITY 1
SRAT_RESERVED 2
ACPI_HPET_FLAG_OFFSET(f, o)      ACPI_FLAG_OFFSET (HPET_TABLE,f,o)
ACPI_SRAT0_FLAG_OFFSET(f, o)     ACPI_FLAG_OFFSET (STATIC_RESOURCE_ALLOC,f,o)
ACPI_SRAT1_FLAG_OFFSET(f, o)     ACPI_FLAG_OFFSET (MEMORY_AFFINITY,f,o)
ACPI_MADT_FLAG_OFFSET(f, o)      ACPI_FLAG_OFFSET (MULTIPLE_APIC_TABLE,f,o)
ACPI_MADT0_FLAG_OFFSET(f, o)     ACPI_FLAG_OFFSET (MADT_PROCESSOR_APIC,f,o)
ACPI_MADT2_FLAG_OFFSET(f, o)     ACPI_FLAG_OFFSET (MADT_INTERRUPT_OVERRIDE,f,o)
ACPI_MADT3_FLAG_OFFSET(f, o)     ACPI_FLAG_OFFSET (MADT_NMI_SOURCE,f,o)
ACPI_MADT4_FLAG_OFFSET(f, o)     ACPI_FLAG_OFFSET (MADT_LOCAL_APIC_NMI,f,o)
ACPI_MADT7_FLAG_OFFSET(f, o)     ACPI_FLAG_OFFSET (MADT_LOCAL_SAPIC,f,o)
ACPI_MADT8_FLAG_OFFSET(f, o)     ACPI_FLAG_OFFSET (MADT_INTERRUPT_SOURCE,f,o)
_ARCHITECTURE_BYTE_ORDER_H_ None
_CORECRYPTO_CC_H_ None
cc_concat_(a, b) a##b
cc_concat(a, b) cc_concat_(a, b)
cc_aligned_struct(_alignment_) typedef struct { uint8_t b[_alignment_]; } CC_ALIGNED(_alignment_)
cc_ctx_n(_type_, _size_) ((_size_ + sizeof(_type_) - 1) / sizeof(_type_))
cc_ctx_sizeof(_type_, _size_) 	CC_IGNORE_VLA_WARNINGS 	sizeof(_type_[cc_ctx_n(_type_, _size_)]) 	CC_RESTORE_VLA_WARNINGS
cc_ctx_decl_field(_type_, _size_, _name_)   _type_ _name_ [cc_ctx_n(_type_, _size_)]
cc_ctx_decl_vla(_type_, _size_, _name_)   CC_IGNORE_VLA_WARNINGS                          cc_ctx_decl(_type_, _size_, _name_);            CC_RESTORE_VLA_WARNINGS
cc_copy(_size_, _dst_, _src_) memcpy(_dst_, _src_, _size_)
CC_SWAP(S, T) do {      S ^= T; T ^= S; S ^= T; } while (0)
CC_MAX(S, T) ({__typeof__(S) _cc_max_s = S; __typeof__(T) _cc_max_t = T; _cc_max_s > _cc_max_t ? _cc_max_s : _cc_max_t;})
CC_MAX_EVAL(S, T) ((S) > (T) ? (S) : (T))
CC_MIN(S, T) ({__typeof__(S) _cc_min_s = S; __typeof__(T) _cc_min_t = T; _cc_min_s <= _cc_min_t ? _cc_min_s : _cc_min_t;})
CC_MIN_EVAL(S, T) ((S) < (T) ? (S) : (T))
_CORECRYPTO_CCAES_H_ None
CCAES_BLOCK_SIZE 16
CCAES_KEY_SIZE_128 16
CCAES_KEY_SIZE_192 24
CCAES_KEY_SIZE_256 32
CCAES_CTR_MAX_PARALLEL_NBLOCKS 8
_CORECRYPTO_CCASN1_H_ None
_CORECRYPTO_CCCHACHA20POLY1305_H_ None
CCCHACHA20_KEY_NBYTES 32
CCCHACHA20_BLOCK_NBYTES 64
CCCHACHA20_NONCE_NBYTES 12
CCPOLY1305_TAG_NBYTES 16
CCPOLY1305_KEY_NBYTES 32
CCCHACHA20POLY1305_STATE_SETNONCE 1
CCCHACHA20POLY1305_STATE_AAD 2
CCCHACHA20POLY1305_STATE_ENCRYPT 3
CCCHACHA20POLY1305_STATE_DECRYPT 4
CCCHACHA20POLY1305_STATE_FINAL 5
_CORECRYPTO_CCCMAC_H_ None
CMAC_BLOCKSIZE 16
cccmac_hdr_size sizeof(struct cccmac_ctx)
cccmac_ctx_n(_mode_) ccn_nof_size(cccmac_ctx_size(_mode_))
cccmac_mode_decl(_mode_, _name_) cc_ctx_decl_vla(struct cccmac_ctx, cccmac_ctx_size(_mode_), _name_)
cccmac_mode_clear(_mode_, _name_) cc_clear(cccmac_ctx_size(_mode_), _name_)
cccmac_mode_ctx_start(_mode_, HC)    (HC->ctx)
cccmac_mode_sym_ctx(_mode_, HC)     (cccbc_ctx *)(cccmac_mode_ctx_start(_mode_, HC))
cccmac_mode_iv(_mode_, HC)     (cccbc_iv *)(cccmac_mode_ctx_start(_mode_, HC)+cccmac_cbc_size(_mode_))
_CORECRYPTO_CCDER_H_ None
CCDER_EOL CCASN1_EOL
CCDER_BOOLEAN CCASN1_BOOLEAN
CCDER_INTEGER CCASN1_INTEGER
CCDER_BIT_STRING CCASN1_BIT_STRING
CCDER_OCTET_STRING CCASN1_OCTET_STRING
CCDER_NULL CCASN1_NULL
CCDER_OBJECT_IDENTIFIER CCASN1_OBJECT_IDENTIFIER
CCDER_OBJECT_DESCRIPTOR CCASN1_OBJECT_DESCRIPTOR
CCDER_REAL CCASN1_REAL
CCDER_ENUMERATED CCASN1_ENUMERATED
CCDER_EMBEDDED_PDV CCASN1_EMBEDDED_PDV
CCDER_UTF8_STRING CCASN1_UTF8_STRING
CCDER_SEQUENCE CCASN1_SEQUENCE
CCDER_SET CCASN1_SET
CCDER_NUMERIC_STRING CCASN1_NUMERIC_STRING
CCDER_PRINTABLE_STRING CCASN1_PRINTABLE_STRING
CCDER_T61_STRING CCASN1_T61_STRING
CCDER_VIDEOTEX_STRING CCASN1_VIDEOTEX_STRING
CCDER_IA5_STRING CCASN1_IA5_STRING
CCDER_UTC_TIME CCASN1_UTC_TIME
CCDER_GENERALIZED_TIME CCASN1_GENERALIZED_TIME
CCDER_GRAPHIC_STRING CCASN1_GRAPHIC_STRING
CCDER_VISIBLE_STRING CCASN1_VISIBLE_STRING
CCDER_GENERAL_STRING CCASN1_GENERAL_STRING
CCDER_UNIVERSAL_STRING CCASN1_UNIVERSAL_STRING
CCDER_BMP_STRING CCASN1_BMP_STRING
CCDER_HIGH_TAG_NUMBER CCASN1_HIGH_TAG_NUMBER
CCDER_TELETEX_STRING CCDER_T61_STRING
CC_EC_OID_SECP192R1 {                                                                         ((unsigned char *)"\x06\x08\x2a\x86\x48\xce\x3d\x03\x01\x01")     }
CC_EC_OID_SECP256R1 {                                                                         ((unsigned char *)"\x06\x08\x2a\x86\x48\xce\x3d\x03\x01\x07")     }
CC_EC_OID_SECP224R1 {                                                             ((unsigned char *)"\x06\x05\x2B\x81\x04\x00\x21")     }
CC_EC_OID_SECP384R1 {                                                             ((unsigned char *)"\x06\x05\x2B\x81\x04\x00\x22")     }
CC_EC_OID_SECP521R1 {                                                             ((unsigned char *)"\x06\x05\x2B\x81\x04\x00\x23")     }
_CORECRYPTO_CCDER_BLOB_H_ None
CCDER_MULTIBYTE_TAGS 1
ccder_size(BEGIN, END) ((size_t)((END) - (BEGIN)))
ccder_blob_size(BLOB) ccder_size((BLOB).der, (BLOB).der_end)
_CORECRYPTO_CCDES_H_ None
CCDES_BLOCK_SIZE 8
CCDES_KEY_SIZE 8
_CORECRYPTO_CCDIGEST_H_ None
ccdigest_ctx_size(_state_size_, _block_size_)  ((_state_size_) + sizeof(uint64_t) + (_block_size_) + sizeof(unsigned int))
ccdigest_ctx_decl(_state_size_, _block_size_, _name_)  cc_ctx_decl(struct ccdigest_ctx, ccdigest_ctx_size(_state_size_, _block_size_), _name_)
ccdigest_ctx_clear(_state_size_, _block_size_, _name_) cc_clear(ccdigest_ctx_size(_state_size_, _block_size_), _name_)
ccdigest_di_decl(_di_, _name_)  cc_ctx_decl_vla(struct ccdigest_ctx, ccdigest_di_size(_di_), _name_)
ccdigest_di_clear(_di_, _name_) cc_clear(ccdigest_di_size(_di_), _name_)
ccdigest_state_u8(_di_, _ctx_)   ccdigest_u8(ccdigest_state((_di_), (_ctx_)))
ccdigest_state_u32(_di_, _ctx_)  ccdigest_u32(ccdigest_state((_di_), (_ctx_)))
ccdigest_state_u64(_di_, _ctx_)  ccdigest_u64(ccdigest_state((_di_), (_ctx_)))
ccdigest_state_ccn(_di_, _ctx_)  ccdigest_ccn(ccdigest_state((_di_), (_ctx_)))
ccdigest_nbits(_di_, _ctx_)      (*((uint64_t *)((ccdigest_ctx_t)(_ctx_))->state))
ccdigest_state(_di_, _ctx_)      ((ccdigest_state_t)(((ccdigest_ctx_t)(_ctx_))->state + sizeof(uint64_t)))
ccdigest_data(_di_, _ctx_)       (((ccdigest_ctx_t)(_ctx_))->state + (_di_)->state_size + sizeof(uint64_t))
ccdigest_num(_di_, _ctx_)        (*((unsigned int *)(((ccdigest_ctx_t)(_ctx_))->state + (_di_)->state_size + sizeof(uint64_t) + (_di_)->block_size)))
CC_DIGEST_OID_MD2 OID_DEF("\x06\x08\x2A\x86\x48\x86\xF7\x0D\x02\x02")
CC_DIGEST_OID_MD4 OID_DEF("\x06\x08\x2A\x86\x48\x86\xF7\x0D\x02\x04")
CC_DIGEST_OID_MD5 OID_DEF("\x06\x08\x2A\x86\x48\x86\xF7\x0D\x02\x05")
CC_DIGEST_OID_SHA1 OID_DEF("\x06\x05\x2b\x0e\x03\x02\x1a")
CC_DIGEST_OID_SHA224 OID_DEF("\x06\x09\x60\x86\x48\x01\x65\x03\x04\x02\x04")
CC_DIGEST_OID_SHA256 OID_DEF("\x06\x09\x60\x86\x48\x01\x65\x03\x04\x02\x01")
CC_DIGEST_OID_SHA384 OID_DEF("\x06\x09\x60\x86\x48\x01\x65\x03\x04\x02\x02")
CC_DIGEST_OID_SHA512 OID_DEF("\x06\x09\x60\x86\x48\x01\x65\x03\x04\x02\x03")
CC_DIGEST_OID_SHA512_256 OID_DEF("\x06\x09\x60\x86\x48\x01\x65\x03\x04\x02\x06")
CC_DIGEST_OID_RMD160 OID_DEF("\x06\x05\x2B\x24\x03\x02\x01")
CC_DIGEST_OID_SHA3_224 OID_DEF("\x06\x09\x60\x86\x48\x01\x65\x03\x04\x02\x07")
CC_DIGEST_OID_SHA3_256 OID_DEF("\x06\x09\x60\x86\x48\x01\x65\x03\x04\x02\x08")
CC_DIGEST_OID_SHA3_384 OID_DEF("\x06\x09\x60\x86\x48\x01\x65\x03\x04\x02\x09")
CC_DIGEST_OID_SHA3_512 OID_DEF("\x06\x09\x60\x86\x48\x01\x65\x03\x04\x02\x0A")
MAX_DIGEST_BLOCK_SIZE 144
MAX_DIGEST_STATE_SIZE 200
MAX_DIGEST_OUTPUT_SIZE 64
_CORECRYPTO_CCDIGEST_PRIV_H_ None
ccdigest_copy_state(_di_, _dst_, _src_) cc_memcpy_nochk(_dst_, _src_, (_di_)->state_size)
_CORECRYPTO_CCDRBG_H_ None
_CORECRYPTO_CCDRBG_DF_H_ None
_CORECRYPTO_CCDRBG_IMPL_H_ None
_CORECRYPTO_CCENTROPY_H_ None
_CORECRYPTO_CCHKDF_H_ None
_CORECRYPTO_CCHMAC_H_ None
cchmac_ctx_size(STATE_SIZE, BLOCK_SIZE) (cc_pad_align(ccdigest_ctx_size(STATE_SIZE, BLOCK_SIZE)) + (STATE_SIZE))
cchmac_ctx_n(STATE_SIZE, BLOCK_SIZE)  ccn_nof_size(cchmac_ctx_size((STATE_SIZE), (BLOCK_SIZE)))
cchmac_ctx_decl(STATE_SIZE, BLOCK_SIZE, _name_) cc_ctx_decl_vla(struct cchmac_ctx, cchmac_ctx_size(STATE_SIZE, BLOCK_SIZE), _name_)
cchmac_ctx_clear(STATE_SIZE, BLOCK_SIZE, _name_) cc_clear(cchmac_ctx_size(STATE_SIZE, BLOCK_SIZE), _name_)
cchmac_di_decl(_di_, _name_) cchmac_ctx_decl((_di_)->state_size, (_di_)->block_size, _name_)
cchmac_di_clear(_di_, _name_) cchmac_ctx_clear((_di_)->state_size, (_di_)->block_size, _name_)
cchmac_digest_ctx(_di_, HC)    ((ccdigest_ctx_t)(HC))
cchmac_ostate(_di_, HC)    ((ccdigest_state_t)(((cchmac_ctx_t)(HC))->b + cc_pad_align(ccdigest_di_size(_di_))))
cchmac_ostate8(_di_, HC)   (ccdigest_u8(cchmac_ostate(_di_, HC)))
cchmac_ostate32(_di_, HC)  (ccdigest_u32(cchmac_ostate(_di_, HC)))
cchmac_ostate64(_di_, HC)  (ccdigest_u64(cchmac_ostate(_di_, HC)))
cchmac_ostateccn(_di_, HC) (ccdigest_ccn(cchmac_ostate(_di_, HC)))
cchmac_istate(_di_, HC)    ccdigest_state(_di_, ((ccdigest_ctx_t)(HC)))
cchmac_istate8(_di_, HC)   ccdigest_u8(cchmac_istate(_di_, HC))
cchmac_istate32(_di_, HC)  ccdigest_u32(cchmac_istate(_di_, HC))
cchmac_istate64(_di_, HC)  ccdigest_u64(cchmac_istate(_di_, HC))
cchmac_istateccn(_di_, HC) ccdigest_ccn(cchmac_istate(_di_, HC))
cchmac_data(_di_, HC)      ccdigest_data(_di_, ((ccdigest_ctx_t)(HC)))
cchmac_num(_di_, HC)       ccdigest_num(_di_, ((ccdigest_ctx_t)(HC)))
cchmac_nbits(_di_, HC)     ccdigest_nbits(_di_, ((ccdigest_ctx_t)(HC)))
_CORECRYPTO_CCKPRNG_H_ None
CCKPRNG_SEED_NBYTES 32
CCKPRNG_ENTROPY_SIZE 64
CCKPRNG_GENERATE_MAX_NBYTES 256
_CORECRYPTO_CCMD4_H_ None
CCMD4_BLOCK_SIZE 64
CCMD4_OUTPUT_SIZE 16
CCMD4_STATE_SIZE 16
ccmd4_di ccmd4_ltc_di
_CORECRYPTO_CCMODE_H_ None
ccecb_ctx_decl(_size_, _name_) cc_ctx_decl_vla(ccecb_ctx, _size_, _name_)
ccecb_ctx_clear(_size_, _name_) cc_clear(_size_, _name_)
cccbc_ctx_decl(_size_, _name_) cc_ctx_decl_vla(cccbc_ctx, _size_, _name_)
cccbc_ctx_clear(_size_, _name_) cc_clear(_size_, _name_)
cccbc_iv_decl(_size_, _name_) cc_ctx_decl_vla(cccbc_iv, _size_, _name_)
cccbc_iv_clear(_size_, _name_) cc_clear(_size_, _name_)
cccfb_ctx_decl(_size_, _name_) cc_ctx_decl_vla(cccfb_ctx, _size_, _name_)
cccfb_ctx_clear(_size_, _name_) cc_clear(_size_, _name_)
cccfb8_ctx_decl(_size_, _name_) cc_ctx_decl_vla(cccfb8_ctx, _size_, _name_)
cccfb8_ctx_clear(_size_, _name_) cc_clear(_size_, _name_)
ccctr_ctx_decl(_size_, _name_) cc_ctx_decl_vla(ccctr_ctx, _size_, _name_)
ccctr_ctx_clear(_size_, _name_) cc_clear(_size_, _name_)
ccofb_ctx_decl(_size_, _name_) cc_ctx_decl_vla(ccofb_ctx, _size_, _name_)
ccofb_ctx_clear(_size_, _name_) cc_clear(_size_, _name_)
ccxts_ctx_decl(_size_, _name_) cc_ctx_decl_vla(ccxts_ctx, _size_, _name_)
ccxts_ctx_clear(_size_, _name_) cc_clear(_size_, _name_)
ccxts_tweak_decl(_size_, _name_) cc_ctx_decl_vla(ccxts_tweak, _size_, _name_)
ccxts_tweak_clear(_size_, _name_) cc_clear(_size_, _name_)
ccgcm_ctx_decl(_size_, _name_) cc_ctx_decl_vla(ccgcm_ctx, _size_, _name_)
ccgcm_ctx_clear(_size_, _name_) cc_clear(_size_, _name_)
CCGCM_IV_NBYTES 12
CCGCM_BLOCK_NBYTES 16
CCM_MAX_TAG_SIZE 16
ccccm_ctx_decl(_size_, _name_) cc_ctx_decl_vla(ccccm_ctx, _size_, _name_)
ccccm_ctx_clear(_size_, _name_) cc_clear(_size_, _name_)
ccccm_nonce_decl(_size_, _name_) cc_ctx_decl_vla(ccccm_nonce, _size_, _name_)
ccccm_nonce_clear(_size_, _name_) cc_clear(_size_, _name_)
ccomac_ctx_decl(_size_, _name_) cc_ctx_decl_vla(ccomac_ctx, _size_, _name_)
ccomac_ctx_clear(_size_, _name_) cc_clear(_size_, _name_)
_CORECRYPTO_CCMODE_FACTORY_H_ None
_CORECRYPTO_CCMODE_IMPL_H_ None
CCMODE_MAX_BLOCK_SIZE 16
CCCBC_MAX_CTX_SIZE 512
CCMODE_GCM_DECRYPTOR 78647
CCMODE_GCM_ENCRYPTOR 4073947
_CORECRYPTO_CCMODE_SIV_H_ None
ccsiv_ctx_decl(_size_, _name_)  cc_ctx_decl_vla(ccsiv_ctx, _size_, _name_)
ccsiv_ctx_clear(_size_, _name_) cc_clear(_size_, _name_)
_CORECRYPTO_CCMODE_SIV_HMAC_H None
ccsiv_hmac_ctx_decl(_size_, _name_) cc_ctx_decl_vla(ccsiv_hmac_ctx, _size_, _name_)
ccsiv_hmac_ctx_clear(_size_, _name_) cc_clear(_size_, _name_)
_CORECRYPTO_CCN_H_ None
ccn_nof_sizeof(_expr_) ccn_nof_size(sizeof(_expr_))
ccn_sizeof_size(_size_) ccn_sizeof_n(ccn_nof_size(_size_))
CCN8_C(a0) CC_UNIT_C(0x##a0)
CCN16_C(a1,a0) CC_UNIT_C(0x##a1##a0)
CCN32_C(a3,a2,a1,a0) CC_UNIT_C(0x##a3##a2##a1##a0)
ccn192_64(a2,a1,a0) ccn64_64(a0),ccn64_64(a1),ccn64_64(a2)
ccn192_32(a5,a4,a3,a2,a1,a0) ccn64_32(a1,a0),ccn64_32(a3,a2),ccn64_32(a5,a4)
ccn224_32(a6,a5,a4,a3,a2,a1,a0) ccn64_32(a1,a0),ccn64_32(a3,a2),ccn64_32(a5,a4),ccn32_32(a6)
ccn256_32(a7,a6,a5,a4,a3,a2,a1,a0) ccn64_32(a1,a0),ccn64_32(a3,a2),ccn64_32(a5,a4),ccn64_32(a7,a6)
ccn384_32(a11,a10,a9,a8,a7,a6,a5,a4,a3,a2,a1,a0) ccn64_32(a1,a0),ccn64_32(a3,a2),ccn64_32(a5,a4),ccn64_32(a7,a6),ccn64_32(a9,a8),ccn64_32(a11,a10)
CCN192_C(c7,c6,c5,c4,c3,c2,c1,c0,b7,b6,b5,b4,b3,b2,b1,b0,a7,a6,a5,a4,a3,a2,a1,a0) CCN64_C(a7,a6,a5,a4,a3,a2,a1,a0),    CCN64_C(b7,b6,b5,b4,b3,b2,b1,b0),    CCN64_C(c7,c6,c5,c4,c3,c2,c1,c0)
CCN200_C(d0,c7,c6,c5,c4,c3,c2,c1,c0,b7,b6,b5,b4,b3,b2,b1,b0,a7,a6,a5,a4,a3,a2,a1,a0) CCN192_C(c7,c6,c5,c4,c3,c2,c1,c0,b7,b6,b5,b4,b3,b2,b1,b0,a7,a6,a5,a4,a3,a2,a1,a0),    CCN8_C(d0)
CCN224_C(d3,d2,d1,d0,c7,c6,c5,c4,c3,c2,c1,c0,b7,b6,b5,b4,b3,b2,b1,b0,a7,a6,a5,a4,a3,a2,a1,a0) CCN192_C(c7,c6,c5,c4,c3,c2,c1,c0,b7,b6,b5,b4,b3,b2,b1,b0,a7,a6,a5,a4,a3,a2,a1,a0),    CCN32_C(d3,d2,d1,d0)
CCN232_C(d4,d3,d2,d1,d0,c7,c6,c5,c4,c3,c2,c1,c0,b7,b6,b5,b4,b3,b2,b1,b0,a7,a6,a5,a4,a3,a2,a1,a0) CCN192_C(c7,c6,c5,c4,c3,c2,c1,c0,b7,b6,b5,b4,b3,b2,b1,b0,a7,a6,a5,a4,a3,a2,a1,a0),    CCN40_C(d4,d3,d2,d1,d0)
CCN256_C(d7,d6,d5,d4,d3,d2,d1,d0,c7,c6,c5,c4,c3,c2,c1,c0,b7,b6,b5,b4,b3,b2,b1,b0,a7,a6,a5,a4,a3,a2,a1,a0) CCN192_C(c7,c6,c5,c4,c3,c2,c1,c0,b7,b6,b5,b4,b3,b2,b1,b0,a7,a6,a5,a4,a3,a2,a1,a0),    CCN64_C(d7,d6,d5,d4,d3,d2,d1,d0)
CCN384_C(f7,f6,f5,f4,f3,f2,f1,f0,e7,e6,e5,e4,e3,e2,e1,e0,d7,d6,d5,d4,d3,d2,d1,d0,c7,c6,c5,c4,c3,c2,c1,c0,b7,b6,b5,b4,b3,b2,b1,b0,a7,a6,a5,a4,a3,a2,a1,a0) CCN256_C(d7,d6,d5,d4,d3,d2,d1,d0,c7,c6,c5,c4,c3,c2,c1,c0,b7,b6,b5,b4,b3,b2,b1,b0,a7,a6,a5,a4,a3,a2,a1,a0),    CCN64_C(e7,e6,e5,e4,e3,e2,e1,e0),    CCN64_C(f7,f6,f5,f4,f3,f2,f1,f0)
CCN448_C(g7,g6,g5,g4,g3,g2,g1,g0,f7,f6,f5,f4,f3,f2,f1,f0,e7,e6,e5,e4,e3,e2,e1,e0,d7,d6,d5,d4,d3,d2,d1,d0,c7,c6,c5,c4,c3,c2,c1,c0,b7,b6,b5,b4,b3,b2,b1,b0,a7,a6,a5,a4,a3,a2,a1,a0) CCN256_C(d7,d6,d5,d4,d3,d2,d1,d0,c7,c6,c5,c4,c3,c2,c1,c0,b7,b6,b5,b4,b3,b2,b1,b0,a7,a6,a5,a4,a3,a2,a1,a0),    CCN192_C(g7,g6,g5,g4,g3,g2,g1,g0,f7,f6,f5,f4,f3,f2,f1,f0,e7,e6,e5,e4,e3,e2,e1,e0)
CCN528_C(i1,i0,h7,h6,h5,h4,h3,h2,h1,h0,g7,g6,g5,g4,g3,g2,g1,g0,f7,f6,f5,f4,f3,f2,f1,f0,e7,e6,e5,e4,e3,e2,e1,e0,d7,d6,d5,d4,d3,d2,d1,d0,c7,c6,c5,c4,c3,c2,c1,c0,b7,b6,b5,b4,b3,b2,b1,b0,a7,a6,a5,a4,a3,a2,a1,a0) CCN256_C(d7,d6,d5,d4,d3,d2,d1,d0,c7,c6,c5,c4,c3,c2,c1,c0,b7,b6,b5,b4,b3,b2,b1,b0,a7,a6,a5,a4,a3,a2,a1,a0),    CCN256_C(h7,h6,h5,h4,h3,h2,h1,h0,g7,g6,g5,g4,g3,g2,g1,g0,f7,f6,f5,f4,f3,f2,f1,f0,e7,e6,e5,e4,e3,e2,e1,e0),    CCN16_C(i1,i0)
CCN192_N ccn_nof(192)
CCN224_N ccn_nof(224)
CCN256_N ccn_nof(256)
CCN384_N ccn_nof(384)
CCN448_N ccn_nof(448)
CCN512_N ccn_nof(512)
CCN521_N ccn_nof(521)
ccn_is_zero(_n_, _s_) (!ccn_n((_n_), (_s_)))
ccn_is_one(_n_, _s_) (ccn_n((_n_), (_s_)) == 1 && (_s_)[0] == 1)
ccn_is_zero_or_one(_n_, _s_) (((_n_)==0) || ((ccn_n((_n_), (_s_)) <= 1) && ((_s_)[0] <= 1)))
ccn_read_int(n, r, data_size, data) ccn_read_uint(n, r, data_size, data)
ccn_random(_n_,_r_,_ccrng_ctx_) ccrng_generate(_ccrng_ctx_, ccn_sizeof_n(_n_), (unsigned char *)_r_)
_CORECRYPTO_CCPAD_H_ None
_CORECRYPTO_CCRNG_H_ None
CCRNG_STATE_COMMON int (*CC_SPTR(ccrng_state, generate))(struct ccrng_state *rng, size_t outlen, void *out);
ccrng_generate(rng, outlen, out)     ((rng)->generate((struct ccrng_state *)(rng), (outlen), (out)))
_CORECRYPTO_CCRNG_CRYPTO_H_ None
_CORECRYPTO_CCRNG_FORTUNA_H_ None
CCRNG_FORTUNA_NPOOLS 32
CCRNG_FORTUNA_SEED_NBYTES 32
CCRNG_FORTUNA_POOL_NBYTES 32
CCRNG_FORTUNA_KEY_NBYTES 32
CCRNG_FORTUNA_GENERATE_MAX_NBYTES 256
_CORECRYPTO_CCRNG_SCHEDULE_H_ None
_CORECRYPTO_CCRSA_H_ None
CCRSA_KEYGEN_MAX_NBITS 8192
ccrsa_pub_ctx_ws(_n_) ccn_nof_size(ccrsa_pub_ctx_size(ccn_sizeof_n(_n_)))
ccrsa_full_ctx_ws(_n_) ccn_nof_size(ccrsa_full_ctx_size(ccn_sizeof_n(_n_)))
ccrsa_full_ctx_decl(_nbytes_, _name_)   cc_ctx_decl(struct ccrsa_full_ctx, ccrsa_full_ctx_size(_nbytes_), _name_)
ccrsa_full_ctx_clear(_nbytes_, _name_)  cc_clear(ccrsa_full_ctx_size(_nbytes_), _name_)
ccrsa_pub_ctx_decl(_nbytes_, _name_)    cc_ctx_decl(struct ccrsa_pub_ctx, ccrsa_pub_ctx_size(_nbytes_), _name_)
ccrsa_pub_ctx_clear(_nbytes_, _name_)   cc_clear(ccrsa_pub_ctx_size(_nbytes_), _name_)
ccrsa_full_ctx_decl_nbits(_nbits_, _name_)   cc_ctx_decl(struct ccrsa_full_ctx, ccrsa_full_ctx_size(ccn_sizeof(_nbits_)), _name_)
ccrsa_full_ctx_clear_nbits(_nbits_, _name_)  cc_clear(ccrsa_full_ctx_size(ccn_sizeof(_nbits_)), _name_)
ccrsa_pub_ctx_decl_nbits(_nbits_, _name_)    cc_ctx_decl(struct ccrsa_pub_ctx, ccrsa_pub_ctx_size(ccn_sizeof(_nbits_)), _name_)
ccrsa_pub_ctx_clear_nbits(_nbits_, _name_)   cc_clear(ccrsa_pub_ctx_size(ccn_sizeof(_nbits_)), _name_)
ccrsa_full_ctx_decl_n(_nunits_, _name_)   cc_ctx_decl(struct ccrsa_full_ctx, ccrsa_full_ctx_size(ccn_sizeof_n(_nunits_)), _name_)
ccrsa_full_ctx_clear_n(_nunits_, _name_)  cc_clear(ccrsa_full_ctx_size(ccn_sizeof_n(_nunits_)), _name_)
ccrsa_pub_ctx_decl_n(_nunits_, _name_)    cc_ctx_decl(struct ccrsa_pub_ctx, ccrsa_pub_ctx_size(ccn_sizeof_n(_nunits_)), _name_)
ccrsa_pub_ctx_clear_n(_nunits_, _name_)   cc_clear(ccrsa_pub_ctx_size(ccn_sizeof_n(_nunits_)), _name_)
ccrsa_unsafe_forge_bidi_indexable(_ctx_, _nbytes_, _offset_) ((cc_unit *)cc_unsafe_forge_bidi_indexable((cc_unit *)cc_unsafe_forge_bidi_indexable((_ctx_)->pb_ccn, _nbytes_ + ccn_sizeof_n(_offset_)) + _offset_, _nbytes_))
ccrsa_ctx_e(_ctx_) ccrsa_unsafe_forge_bidi_indexable(_ctx_, ccn_sizeof_n(ccrsa_ctx_n(_ctx_)), 2 * ccrsa_ctx_n(_ctx_) + 1)
ccrsa_ctx_d(_ctx_) ccrsa_unsafe_forge_bidi_indexable(_ctx_, ccn_sizeof_n(ccrsa_ctx_n(_ctx_)), 3 * ccrsa_ctx_n(_ctx_) + 1)
CCRSA_PKCS1_PAD_SIGN 1
CCRSA_PKCS1_PAD_ENCRYPT 2
CCRSA_GENKEY_DETERMINISTIC_LEGACY 0b1
_CORECRYPTO_CCSHA1_H_ None
CCSHA1_BLOCK_SIZE 64
CCSHA1_OUTPUT_SIZE 20
CCSHA1_STATE_SIZE 20
ccoid_sha1_len 7
_CORECRYPTO_CCSHA2_H_ None
ccoid_sha224_len 11
ccoid_sha256_len 11
ccoid_sha384_len 11
ccoid_sha512_len 11
ccoid_sha512_256_len 11
CCSHA256_BLOCK_SIZE 64
CCSHA256_OUTPUT_SIZE 32
CCSHA256_STATE_SIZE 32
CCSHA224_OUTPUT_SIZE 28
CCSHA512_BLOCK_SIZE 128
CCSHA512_OUTPUT_SIZE 64
CCSHA512_STATE_SIZE 64
CCSHA512_256_BLOCK_SIZE 128
CCSHA512_256_OUTPUT_SIZE 32
CCSHA512_256_STATE_SIZE 64
CCSHA384_OUTPUT_SIZE 48
_CORECRYPTO_CCZP_H_ None
__CCZP_HEADER_ELEMENTS_DEFINITIONS(pre) cc_size pre##n;                                 cc_unit pre##bitlen;                            cczp_funcs_t pre##funcs;
__CCZP_ELEMENTS_DEFINITIONS(pre) __CCZP_HEADER_ELEMENTS_DEFINITIONS(pre)     cc_unit pre##ccn[];
_CORECRYPTO_CC_CONFIG_H_ None
__cc_printflike(fmtarg, firstvararg) __attribute__((format(printf, fmtarg, firstvararg)))
CORECRYPTO_SIMULATE_POSIX_ENVIRONMENT 0
CORECRYPTO_SIMULATE_WINDOWS_ENVIRONMENT 0
CORECRYPTO_HACK_FOR_WINDOWS_DEVELOPMENT 0
CORECRYPTO_DEBUG_ENABLE_CC_REQUIRE_PRINTS 0
CC_XNU_KERNEL_PRIVATE 1
CC_HANDLE_UNALIGNED_DATA CC_BASEBAND
CC_SMALL_CODE 0
CC_CACHE_DESCRIPTORS CC_KERNEL
CC_INLINE static inline
CC_NONNULL4 CC_NONNULL((4))
_CORECRYPTO_CC_ERROR_H_ None
CCDRBG_STATUS_OK CCERR_OK
CCKPRNG_OK CCERR_OK
_CORECRYPTO_CC_FAULT_CANARY_H_ None
CC_FAULT_CANARY_SIZE 16
CC_FAULT_CANARY_MEMCPY(_dst_, _src_) cc_memcpy(_dst_, _src_, CC_FAULT_CANARY_SIZE)
CC_FAULT_CANARY_CLEAR(_name_) cc_memset(_name_, 0x00, CC_FAULT_CANARY_SIZE)
CC_FAULT_CANARY_EQUAL(_a_, _b_) (cc_cmp_safe(CC_FAULT_CANARY_SIZE, _a_, _b_) == 0)
_CORECRYPTO_CC_IMPL_H_ None
CC_IMPL_LIST CC_IMPL_ITEM(UNKNOWN, 0)                                                                                                CC_IMPL_ITEM(SHA256_LTC, 1)                                 CC_IMPL_ITEM(SHA256_VNG_ARM, 2)                             CC_IMPL_ITEM(SHA256_VNG_ARM64_NEON, 3)                      CC_IMPL_ITEM(SHA256_VNG_INTEL_SUPPLEMENTAL_SSE3, 4)         CC_IMPL_ITEM(SHA256_VNG_INTEL_AVX1, 5)                      CC_IMPL_ITEM(SHA256_VNG_INTEL_AVX2, 6)                                                                                  CC_IMPL_ITEM(AES_ECB_LTC, 11)                               CC_IMPL_ITEM(AES_ECB_ARM, 12)                               CC_IMPL_ITEM(AES_ECB_INTEL_OPT, 13)                         CC_IMPL_ITEM(AES_ECB_INTEL_AESNI, 14)                       CC_IMPL_ITEM(AES_ECB_SKG, 15)                               CC_IMPL_ITEM(AES_ECB_TRNG, 16)                                                                                          CC_IMPL_ITEM(AES_XTS_GENERIC, 21)                           CC_IMPL_ITEM(AES_XTS_ARM, 22)                               CC_IMPL_ITEM(AES_XTS_INTEL_OPT, 23)                         CC_IMPL_ITEM(AES_XTS_INTEL_AESNI, 24)                                                                                   CC_IMPL_ITEM(SHA1_LTC, 31)                                  CC_IMPL_ITEM(SHA1_VNG_ARM, 32)                              CC_IMPL_ITEM(SHA1_VNG_INTEL_SUPPLEMENTAL_SSE3, 33)          CC_IMPL_ITEM(SHA1_VNG_INTEL_AVX1, 34)                       CC_IMPL_ITEM(SHA1_VNG_INTEL_AVX2, 35)                                                                                   CC_IMPL_ITEM(SHA384_LTC, 41)                                CC_IMPL_ITEM(SHA384_VNG_ARM, 42)                            CC_IMPL_ITEM(SHA384_VNG_INTEL_SUPPLEMENTAL_SSE3, 43)        CC_IMPL_ITEM(SHA384_VNG_INTEL_AVX1, 44)                     CC_IMPL_ITEM(SHA384_VNG_INTEL_AVX2, 45)                                                                                 CC_IMPL_ITEM(SHA512_LTC, 51)                                CC_IMPL_ITEM(SHA512_VNG_ARM, 52)                            CC_IMPL_ITEM(SHA512_VNG_INTEL_SUPPLEMENTAL_SSE3, 53)        CC_IMPL_ITEM(SHA512_VNG_INTEL_AVX1, 54)                     CC_IMPL_ITEM(SHA512_VNG_INTEL_AVX2, 55)
CC_IMPL_ITEM(k, v)                          CC_IMPL_##k = v,
_CORECRYPTO_CC_LOCK_H_ None
_CORECRYPTO_CC_MACROS_H_ None
__CC_DEBUG_ASSERT_COMPONENT_NAME_STRING ""
__CC_DEBUG_ASSERT_PRODUCTION_CODE !CORECRYPTO_DEBUG
_CORECRYPTO_CC_PRIV_H_ None
__has_builtin(x) 0
__DECONST(type, var) ((type)(uintptr_t)(const void *)(var))
CC_MEMCPY(D,S,L) cc_memcpy((D),(S),(L))
CC_MEMMOVE(D,S,L) cc_memmove((D),(S),(L))
CC_MEMSET(D,V,L) cc_memset((D),(V),(L))
CC_BITLEN_TO_BYTELEN(x) cc_ceiling((x), 8)
cc_abort_if(cond, msg)                      do {                                                if (CC_UNLIKELY(cond)) {                            cc_abort(msg);                              }                                           } while (0)
CC_STORE32_BE(x, y) cc_store32_be((uint32_t)(x), (uint8_t *)(y))
CC_STORE32_LE(x, y) cc_store32_le((uint32_t)(x), (uint8_t *)(y))
CC_STORE64_BE(x, y) cc_store64_be((uint64_t)(x), (uint8_t *)(y))
CC_STORE64_LE(x, y) cc_store64_le((uint64_t)(x), (uint8_t *)(y))
CC_LOAD32_BE(x, y) ((x) = cc_load32_be((uint8_t *)(y)))
CC_LOAD32_LE(x, y) ((x) = cc_load32_le((uint8_t *)(y)))
CC_LOAD64_BE(x, y) ((x) = cc_load64_be((uint8_t *)(y)))
CC_LOAD64_LE(x, y) ((x) = cc_load64_le((uint8_t *)(y)))
CC_READ_LE32(ptr) cc_load32_le((uint8_t *)(ptr))
CC_WRITE_LE32(ptr, x) cc_store32_le((uint32_t)(x), (uint8_t *)(ptr))
CC_WRITE_LE64(ptr, x) cc_store64_le((uint64_t)(x), (uint8_t *)(ptr))
CORECRYPTO_CC_RUNTIME_CONFIG_H_ None
_CORECRYPTO_FIPSPOST_TRACE_H_ None
CORE_ENTITLEMENTS_H None
_CE_INDIRECT 1
CE_RT_LOG(msg) do { if (rt->log) { rt->log(rt, "[%s]: %s\n", __FUNCTION__, msg); } } while(0)
CE_RT_LOGF(fmt, ...) do { if (rt->log) { rt->log(rt, "[%s]: " fmt, __FUNCTION__, __VA_ARGS__); } } while(0)
CE_RT_ABORT(...) do { rt->abort(rt, "[%s]: %s\n", __FUNCTION__, __VA_ARGS__); } while(0)
CORE_ENTITLEMENTS_PRIV_H None
CE_BRIDGE_STRUCT_VERSION 3
CORE_ENTITLEMENTS_DER_VM_H None
CORE_ENTITLEMENTS_ENTITLEMENTS_H None
CORE_ENTITLEMENTS_ENTS_PRIV_H None
CORE_ENTITLEMENTS_ERRORS_H None
CE_DEF_ERROR(name) extern CEError_t name;
CORE_ENTITLEMENTS_INDEX_H None
CE_ACCELERATION_SUPPORTED 1
CORE_ENTITLEMENTS_KERNEL_H None
CORE_ENTITLEMENTS_HELPERS_H None
CESelectKey() CESelectIndex(0)
CESelectValue() CESelectIndex(1)
CESelectDictValueDynamic(key, len) (CEQueryOperation_t){.opcode = CEDynamic(kCEOpSelectKey), .parameters = {.dynamicParameter = {.data = key, .length = len}}}
CEMatchDynamicString(string, len) (CEQueryOperation_t){.opcode = CEDynamic(kCEOpMatchString), .parameters = {.dynamicParameter = {.data = string, .length = len}}}
CEMatchDynamicPrefix(prefix, len) (CEQueryOperation_t){.opcode = CEDynamic(kCEOpMatchStringPrefix), .parameters = {.dynamicParameter = {.data = prefix, .length = len}}}
CEIsDynamicStringAllowed(string, len) (CEQueryOperation_t){.opcode = CEDynamic(kCEOpStringValueAllowed), .parameters = {.dynamicParameter = {.data = string, .length = len}}}
CEIsDynamicStringPrefixAllowed(string, len) (CEQueryOperation_t){.opcode = CEDynamic(kCEOpStringPrefixValueAllowed), .parameters = {.dynamicParameter = {.data = (const uint8_t*)(string), .length = len}}}
CEMatchDynamicData(d, len) (CEQueryOperation_t){.opcode = CEDynamic(kCEOpMatchData), .parameters = {.dynamicParameter = {.data = d, .length = len}}}
CEIsDynamicDataAllowed(d, len) (CEQueryOperation_t){.opcode = CEDynamic(kCEOpMatchDataValueAllowed), .parameters = {.dynamicParameter = {.data = d, .length = len}}}
_SELECT_NTH_ARG(_1, _2, _3, _4, _5, _6, _7, _8, _9, N, ...) N
_mc_1(_call, x) _call(x),
_mc_2(_call, x, ...) _call(x), _mc_1(_call, __VA_ARGS__)
_mc_3(_call, x, ...) _call(x), _mc_2(_call, __VA_ARGS__)
_mc_4(_call, x, ...) _call(x), _mc_3(_call, __VA_ARGS__)
_mc_5(_call, x, ...) _call(x), _mc_4(_call, __VA_ARGS__)
_mc_6(_call, x, ...) _call(x), _mc_5(_call, __VA_ARGS__)
_mc_7(_call, x, ...) _call(x), _mc_6(_call, __VA_ARGS__)
_mc_8(_call, x, ...) _call(x), _mc_7(_call, __VA_ARGS__)
_mc_9(_call, x, ...) _call(x), _mc_8(_call, __VA_ARGS__)
_mc_10(_call, x, ...) _call(x), _mc_9(_call, __VA_ARGS__)
_MACRO_ITER(macro, ...) _SELECT_NTH_ARG(__VA_ARGS__, _mc_10, _mc_9, _mc_8 _mc_7, _mc_6, _mc_5, _mc_4, _mc_3, _mc_2, _mc_1)(macro, __VA_ARGS__)
CE_SELECT_PATH(...) _MACRO_ITER(CESelectDictValue, __VA_ARGS__)
CE_STRING_EQUALS(str) CEMatchString(str)
CE_CONTEXT_GRANTS_ENTITLEMENT(ctx, ...) (CEContextQuery(ctx, (CEQuery_t){CE_SELECT_PATH(__VA_ARGS__) CEMatchBool(true)}, sizeof((CEQuery_t){CE_SELECT_PATH(__VA_ARGS__) CEMatchBool(true)}) / sizeof(CEQueryOperation_t)) == kCENoError)
CORE_ENTITLEMENTS_RESULT_H None
CE_CHECK(ret) do { CEError_t _ce_error = ret; if (_ce_error != kCENoError) {return CEErrorPassThrough(_ce_error);} } while(0)
CE_THROW(err) return CEErrorPassThrough(err)
CORE_ENTITLEMENTS_RUNTIME_H None
CE_MAX_KEY_SIZE 240
__result_use_check None
CE_RUNTIME_VERSION 1
CE_RUNTIME_WITH_INDEX_VERSION 2
CORE_ENTITLEMENTS_SERIALIZATION_H None
CESerializeDynamicKey(strVal, len) (CESerializedElement_t){.type = kCESerializedKey, .data.value = (intptr_t)strVal, .length = len}
CESerializeString(strVal, len) (CESerializedElement_t){.type = kCESerializedString, .data.value = (intptr_t)strVal, .length = len}
CESerializeData(dataVal, len) (CESerializedElement_t){.type = kCESerializedData, .data.value = (intptr_t)dataVal, .length = len}
CESerializeDictionaryPair(a, b) CESerializeArray(a, b)
_CORETRUST_CONFIG_H_ None
_CORETRUST_EVALUATE_H_ None
__IMAGE4_API_COPROCESSOR_H None
IMAGE4_COPROCESSOR_HANDLE_HOST_DEFAULT 0
__IMAGE4_API_ENVIRONMENT_H None
image4_environment_init(_storage, _coproc, _handle) 	_image4_environment_init( 		(_storage), 		(_coproc), 		(_handle), 		IMAGE4_ENVIRONMENT_STRUCT_VERSION)
image4_environment_init_coproc(_storage, _coproc_short, _handle_short) 	image4_environment_init( 		(_storage), 		IMAGE4_COPROCESSOR_ ## _coproc_short, 		IMAGE4_COPROCESSOR_HANDLE_ ## _coproc_short ## _ ## _handle_short)
image4_environment_new_coproc(_coproc_short, _handle_short) 	image4_environment_new( 		IMAGE4_COPROCESSOR_ ## _coproc_short, 		IMAGE4_COPROCESSOR_HANDLE_ ## _coproc_short ## _ ## _handle_short)
__IMAGE4_API_IDENTIFIER_H None
__IMAGE4_API_H None
IMAGE4_API_AVAILABLE_SPRING_2024 API_AVAILABLE( 		macos(14.3), 		ios(17.4), 		tvos(17.4), 		watchos(10.4), 		bridgeos(8.3))
IMAGE4_API_AVAILABLE_FALL_2024 API_AVAILABLE( 		macos(15.0), 		ios(18.0), 		tvos(18.0), 		watchos(11.0), 		bridgeos(9.0))
IMAGE4_XNU_AVAILABLE_DIRECT(_s) typedef typeof(&_s) _ ## _s ## _dlxk_t
IMAGE4_XNU_AVAILABLE_INDIRECT(_s) typedef typeof(&_s) _s ## _dlxk_t
IMAGE4_XNU_RETIRED_DIRECT(_s) typedef void * _ ## _s ## _dlxk_t
IMAGE4_XNU_RETIRED_INDIRECT(_s) typedef void * _s ## _dlxk_t
__IMAGE4_API_TRUST_H None
image4_trust_init(_storage, _environment, _evaluation, 		_manifest, _manifest_len, _flags) 	_image4_trust_init( 		(_storage), 		(_environment), 		(_evaluation), 		(_manifest), 		(_manifest_len), 		(_flags), 		IMAGE4_TRUST_STRUCT_VERSION)
__IMAGE4_API_TRUST_EVALUATION_H None
__IMAGE4_API_TYPES_H None
__IMG4_4XNU_H None
__IMG4_API_H None
IMG4_API_AVAILABLE_20180112 IMG4_API_AVAILABLE_FALL_2018
IMG4_API_AVAILABLE_20181106 IMG4_API_AVAILABLE_SPRING_2019
IMG4_API_AVAILABLE_20200508 IMG4_API_AVAILABLE_FALL_2020
IMG4_API_AVAILABLE_20200608 IMG4_API_AVAILABLE_FALL_2020
IMG4_API_AVAILABLE_20200724 IMG4_API_AVAILABLE_FALL_2020
IMG4_API_AVAILABLE_20210113 IMG4_API_AVAILABLE_FALL_2021
IMG4_API_AVAILABLE_20210205 IMG4_API_AVAILABLE_FALL_2021
IMG4_API_AVAILABLE_20210226 IMG4_API_AVAILABLE_FALL_2021
IMG4_API_AVAILABLE_20210305 IMG4_API_AVAILABLE_FALL_2021
IMG4_API_AVAILABLE_20210521 IMG4_API_AVAILABLE_FALL_2021
IMG4_API_AVAILABLE_20210624 IMG4_API_AVAILABLE_FALL_2021
IMG4_API_AVAILABLE_20210731 IMG4_API_AVAILABLE_FALL_2021_B
IMG4_API_AVAILABLE_20211105 IMG4_API_AVAILABLE_FALL_2022
IMG4_API_AVAILABLE_20211112 IMG4_API_AVAILABLE_FALL_2022
IMG4_API_AVAILABLE_20211119 IMG4_API_AVAILABLE_FALL_2022
IMG4_API_AVAILABLE_20211126 IMG4_API_AVAILABLE_FALL_2022
IMG4_API_AVAILABLE_20211224 IMG4_API_AVAILABLE_FALL_2022
IMG4_API_AVAILABLE_20220128 IMG4_API_AVAILABLE_FALL_2022
IMG4_API_AVAILABLE_20220322 IMG4_API_AVAILABLE_FALL_2022
IMG4_API_AVAILABLE_20220401 IMG4_API_AVAILABLE_FALL_2022
IMG4_API_AVAILABLE_20220513 IMG4_API_AVAILABLE_FALL_2022
IMG4_API_AVAILABLE_20220711 IMG4_API_AVAILABLE_FALL_2022
IMG4_API_AVAILABLE_20220714 IMG4_API_AVAILABLE_FALL_2022
IMG4_API_AVAILABLE_20220715 IMG4_API_AVAILABLE_FALL_2022
IMG4_API_AVAILABLE_20220912 IMG4_API_AVAILABLE_FALL_2022
IMG4_API_AVAILABLE_20220915 IMG4_API_AVAILABLE_SPRING_2023
IMG4_API_AVAILABLE_20221202 IMG4_API_AVAILABLE_SPRING_2023
__IMG4_CHIP_H None
__IMG4_CHIP_AP_H None
__IMG4_CHIP_AP_CATEGORY_H None
__IMG4_CHIP_AP_SOFTWARE_H None
__IMG4_CHIP_CRYPTEX1_H None
__IMG4_CHIP_SEP_H None
__IMG4_CHIP_X86_H None
__IMG4_FIRMWARE_H None
__IMG4_INDIRECT 1
__IMG4_IMAGE_H None
__IMG4_H None
__IMG4_INDIRECT 1
__IMG4_NONCE_H None
IMG4_NONCE_VERSION IMG4_NONCE_STRUCT_VERSION
__IMG4_OBJECT_H None
__IMG4_RUNTIME_H None
IMG4_RUNTIME_REGISTER(_rt) LINKER_SET_ENTRY(__img4_rt, _rt);
__IMG4_SHIM_H None
IMG4_TARGET_SHIM_FOUND 1
IMG4_TARGET_XNU 1
IMG4_TARGET_XNU_PROPER 1
IMG4_TARGET_DARWIN_GENERIC 1
__IMG4_SHIM_XNU_H None
_MACH_O_FAT_H_ None
FAT_MAGIC 0xcafebabe
FAT_CIGAM 0xbebafeca
__MACH_O_FIXUP_CHAINS__ 6
_MACHO_LOADER_H_ None
MH_MAGIC 0xfeedface
MH_CIGAM 0xcefaedfe
MH_MAGIC_64 0xfeedfacf
MH_CIGAM_64 0xcffaedfe
MH_OBJECT 0x1
MH_EXECUTE 0x2
MH_FVMLIB 0x3
MH_CORE 0x4
MH_PRELOAD 0x5
MH_DYLIB 0x6
MH_DYLINKER 0x7
MH_BUNDLE 0x8
MH_DYLIB_STUB 0x9
MH_DSYM 0xa
MH_KEXT_BUNDLE 0xb
MH_FILESET 0xc
MH_NOUNDEFS 0x1
MH_INCRLINK 0x2
MH_DYLDLINK 0x4
MH_BINDATLOAD 0x8
MH_PREBOUND 0x10
MH_SPLIT_SEGS 0x20
MH_LAZY_INIT 0x40
MH_TWOLEVEL 0x80
MH_FORCE_FLAT 0x100
MH_NOMULTIDEFS 0x200
MH_NOFIXPREBINDING 0x400
MH_PREBINDABLE 0x800
MH_ALLMODSBOUND 0x1000
MH_SUBSECTIONS_VIA_SYMBOLS 0x2000
MH_CANONICAL 0x4000
MH_WEAK_DEFINES 0x8000
MH_BINDS_TO_WEAK 0x10000
MH_ALLOW_STACK_EXECUTION 0x20000
MH_ROOT_SAFE 0x40000
MH_SETUID_SAFE 0x80000
MH_NO_REEXPORTED_DYLIBS 0x100000
MH_PIE 0x200000
MH_DEAD_STRIPPABLE_DYLIB 0x400000
MH_HAS_TLV_DESCRIPTORS 0x800000
MH_NO_HEAP_EXECUTION 0x1000000
MH_APP_EXTENSION_SAFE 0x02000000
MH_NLIST_OUTOFSYNC_WITH_DYLDINFO 0x04000000
MH_SIM_SUPPORT 0x08000000
MH_DYLIB_IN_CACHE 0x80000000
LC_REQ_DYLD 0x80000000
LC_SEGMENT 0x1
LC_SYMTAB 0x2
LC_SYMSEG 0x3
LC_THREAD 0x4
LC_UNIXTHREAD 0x5
LC_LOADFVMLIB 0x6
LC_IDFVMLIB 0x7
LC_IDENT 0x8
LC_FVMFILE 0x9
LC_PREPAGE 0xa
LC_DYSYMTAB 0xb
LC_LOAD_DYLIB 0xc
LC_ID_DYLIB 0xd
LC_LOAD_DYLINKER 0xe
LC_ID_DYLINKER 0xf
LC_PREBOUND_DYLIB 0x10
LC_ROUTINES 0x11
LC_SUB_FRAMEWORK 0x12
LC_SUB_UMBRELLA 0x13
LC_SUB_CLIENT 0x14
LC_SUB_LIBRARY 0x15
LC_TWOLEVEL_HINTS 0x16
LC_PREBIND_CKSUM 0x17
LC_SEGMENT_64 0x19
LC_ROUTINES_64 0x1a
LC_UUID 0x1b
LC_CODE_SIGNATURE 0x1d
LC_SEGMENT_SPLIT_INFO 0x1e
LC_LAZY_LOAD_DYLIB 0x20
LC_ENCRYPTION_INFO 0x21
LC_DYLD_INFO 0x22
LC_VERSION_MIN_MACOSX 0x24
LC_VERSION_MIN_IPHONEOS 0x25
LC_FUNCTION_STARTS 0x26
LC_DYLD_ENVIRONMENT 0x27
LC_DATA_IN_CODE 0x29
LC_SOURCE_VERSION 0x2A
LC_DYLIB_CODE_SIGN_DRS 0x2B
LC_ENCRYPTION_INFO_64 0x2C
LC_LINKER_OPTION 0x2D
LC_LINKER_OPTIMIZATION_HINT 0x2E
LC_VERSION_MIN_TVOS 0x2F
LC_VERSION_MIN_WATCHOS 0x30
LC_NOTE 0x31
LC_BUILD_VERSION 0x32
SG_HIGHVM 0x1
SG_FVMLIB 0x2
SG_NORELOC 0x4
SG_PROTECTED_VERSION_1 0x8
SG_READ_ONLY 0x10
SECTION_TYPE 0x000000ff
SECTION_ATTRIBUTES 0xffffff00
S_REGULAR 0x0
S_ZEROFILL 0x1
S_CSTRING_LITERALS 0x2
S_4BYTE_LITERALS 0x3
S_8BYTE_LITERALS 0x4
S_LITERAL_POINTERS 0x5
S_NON_LAZY_SYMBOL_POINTERS 0x6
S_LAZY_SYMBOL_POINTERS 0x7
S_SYMBOL_STUBS 0x8
S_MOD_INIT_FUNC_POINTERS 0x9
S_MOD_TERM_FUNC_POINTERS 0xa
S_COALESCED 0xb
S_GB_ZEROFILL 0xc
S_INTERPOSING 0xd
S_16BYTE_LITERALS 0xe
S_DTRACE_DOF 0xf
S_LAZY_DYLIB_SYMBOL_POINTERS 0x10
S_THREAD_LOCAL_REGULAR 0x11
S_THREAD_LOCAL_ZEROFILL 0x12
S_THREAD_LOCAL_VARIABLES 0x13
S_THREAD_LOCAL_VARIABLE_POINTERS 0x14
S_THREAD_LOCAL_INIT_FUNCTION_POINTERS 0x15
S_INIT_FUNC_OFFSETS 0x16
SECTION_ATTRIBUTES_USR 0xff000000
S_ATTR_PURE_INSTRUCTIONS 0x80000000
S_ATTR_NO_TOC 0x40000000
S_ATTR_STRIP_STATIC_SYMS 0x20000000
S_ATTR_NO_DEAD_STRIP 0x10000000
S_ATTR_LIVE_SUPPORT 0x08000000
S_ATTR_SELF_MODIFYING_CODE 0x04000000
S_ATTR_DEBUG 0x02000000
SECTION_ATTRIBUTES_SYS 0x00ffff00
S_ATTR_SOME_INSTRUCTIONS 0x00000400
S_ATTR_EXT_RELOC 0x00000200
S_ATTR_LOC_RELOC 0x00000100
SEG_PAGEZERO "__PAGEZERO"
SEG_TEXT "__TEXT"
SECT_TEXT "__text"
SECT_FVMLIB_INIT0 "__fvmlib_init0"
SECT_FVMLIB_INIT1 "__fvmlib_init1"
SEG_DATA "__DATA"
SECT_DATA "__data"
SECT_BSS "__bss"
SECT_COMMON "__common"
SEG_OBJC "__OBJC"
SECT_OBJC_SYMBOLS "__symbol_table"
SECT_OBJC_MODULES "__module_info"
SECT_OBJC_STRINGS "__selector_strs"
SECT_OBJC_REFS "__selector_refs"
SEG_ICON "__ICON"
SECT_ICON_HEADER "__header"
SECT_ICON_TIFF "__tiff"
SEG_LINKEDIT "__LINKEDIT"
SEG_LINKINFO "__LINKINFO"
SEG_UNIXSTACK "__UNIXSTACK"
SEG_IMPORT "__IMPORT"
INDIRECT_SYMBOL_LOCAL 0x80000000
INDIRECT_SYMBOL_ABS 0x40000000
PLATFORM_MACOS 1
PLATFORM_IOS 2
PLATFORM_TVOS 3
PLATFORM_WATCHOS 4
PLATFORM_BRIDGEOS 5
PLATFORM_MACCATALYST 6
PLATFORM_IOSSIMULATOR 7
PLATFORM_TVOSSIMULATOR 8
PLATFORM_WATCHOSSIMULATOR 9
PLATFORM_DRIVERKIT 10
PLATFORM_MAX PLATFORM_DRIVERKIT
TOOL_CLANG 1
TOOL_SWIFT 2
TOOL_LD 3
REBASE_TYPE_POINTER 1
REBASE_TYPE_TEXT_ABSOLUTE32 2
REBASE_TYPE_TEXT_PCREL32 3
REBASE_OPCODE_MASK 0xF0
REBASE_IMMEDIATE_MASK 0x0F
REBASE_OPCODE_DONE 0x00
REBASE_OPCODE_SET_TYPE_IMM 0x10
REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB 0x20
REBASE_OPCODE_ADD_ADDR_ULEB 0x30
REBASE_OPCODE_ADD_ADDR_IMM_SCALED 0x40
REBASE_OPCODE_DO_REBASE_IMM_TIMES 0x50
REBASE_OPCODE_DO_REBASE_ULEB_TIMES 0x60
REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB 0x70
REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB 0x80
BIND_TYPE_POINTER 1
BIND_TYPE_TEXT_ABSOLUTE32 2
BIND_TYPE_TEXT_PCREL32 3
BIND_SPECIAL_DYLIB_SELF 0
BIND_SPECIAL_DYLIB_MAIN_EXECUTABLE -1
BIND_SPECIAL_DYLIB_FLAT_LOOKUP -2
BIND_SPECIAL_DYLIB_WEAK_LOOKUP -3
BIND_SYMBOL_FLAGS_WEAK_IMPORT 0x1
BIND_SYMBOL_FLAGS_NON_WEAK_DEFINITION 0x8
BIND_OPCODE_MASK 0xF0
BIND_IMMEDIATE_MASK 0x0F
BIND_OPCODE_DONE 0x00
BIND_OPCODE_SET_DYLIB_ORDINAL_IMM 0x10
BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB 0x20
BIND_OPCODE_SET_DYLIB_SPECIAL_IMM 0x30
BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM 0x40
BIND_OPCODE_SET_TYPE_IMM 0x50
BIND_OPCODE_SET_ADDEND_SLEB 0x60
BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB 0x70
BIND_OPCODE_ADD_ADDR_ULEB 0x80
BIND_OPCODE_DO_BIND 0x90
BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB 0xA0
BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED 0xB0
BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB 0xC0
BIND_OPCODE_THREADED 0xD0
BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB 0x00
BIND_SUBOPCODE_THREADED_APPLY 0x01
EXPORT_SYMBOL_FLAGS_KIND_MASK 0x03
EXPORT_SYMBOL_FLAGS_KIND_REGULAR 0x00
EXPORT_SYMBOL_FLAGS_KIND_THREAD_LOCAL 0x01
EXPORT_SYMBOL_FLAGS_KIND_ABSOLUTE 0x02
EXPORT_SYMBOL_FLAGS_WEAK_DEFINITION 0x04
EXPORT_SYMBOL_FLAGS_REEXPORT 0x08
EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER 0x10
DICE_KIND_DATA 0x0001
DICE_KIND_JUMP_TABLE8 0x0002
DICE_KIND_JUMP_TABLE16 0x0003
DICE_KIND_JUMP_TABLE32 0x0004
DICE_KIND_ABS_JUMP_TABLE32 0x0005
_MACHO_NLIST_H_ None
N_STAB 0xe0
N_PEXT 0x10
N_TYPE 0x0e
N_EXT 0x01
N_UNDF 0x0
N_ABS 0x2
N_SECT 0xe
N_PBUD 0xc
N_INDR 0xa
NO_SECT 0
MAX_SECT 255
REFERENCE_TYPE 0x7
REFERENCE_FLAG_UNDEFINED_NON_LAZY 0
REFERENCE_FLAG_UNDEFINED_LAZY 1
REFERENCE_FLAG_DEFINED 2
REFERENCE_FLAG_PRIVATE_DEFINED 3
REFERENCE_FLAG_PRIVATE_UNDEFINED_NON_LAZY 4
REFERENCE_FLAG_PRIVATE_UNDEFINED_LAZY 5
REFERENCED_DYNAMICALLY 0x0010
SELF_LIBRARY_ORDINAL 0x0
MAX_LIBRARY_ORDINAL 0xfd
DYNAMIC_LOOKUP_ORDINAL 0xfe
EXECUTABLE_ORDINAL 0xff
N_NO_DEAD_STRIP 0x0020
N_DESC_DISCARDED 0x0020
N_WEAK_REF 0x0040
N_WEAK_DEF 0x0080
N_REF_TO_WEAK 0x0080
N_ARM_THUMB_DEF 0x0008
N_SYMBOL_RESOLVER 0x0100
N_ALT_ENTRY 0x0200
_MACHO_RELOC_H_ None
R_ABS 0
R_SCATTERED 0x80000000
_MACHO_STAB_H_ None
N_GSYM 0x20
N_FNAME 0x22
N_FUN 0x24
N_STSYM 0x26
N_LCSYM 0x28
N_BNSYM 0x2e
N_AST 0x32
N_OPT 0x3c
N_RSYM 0x40
N_SLINE 0x44
N_ENSYM 0x4e
N_SSYM 0x60
N_SO 0x64
N_OSO 0x66
N_LSYM 0x80
N_BINCL 0x82
N_SOL 0x84
N_PARAMS 0x86
N_VERSION 0x88
N_OLEVEL 0x8A
N_PSYM 0xa0
N_EINCL 0xa2
N_ENTRY 0xa4
N_LBRAC 0xc0
N_EXCL 0xc2
N_RBRAC 0xe0
N_BCOMM 0xe2
N_ECOMM 0xe4
N_ECOML 0xe8
N_LENG 0xfe
N_PC 0x30
_SYS__PTHREAD_TYPES_H_ None
__PTHREAD_SIZE__ 8176
__PTHREAD_ATTR_SIZE__ 56
__PTHREAD_MUTEXATTR_SIZE__ 8
__PTHREAD_MUTEX_SIZE__ 56
__PTHREAD_CONDATTR_SIZE__ 8
__PTHREAD_COND_SIZE__ 40
__PTHREAD_ONCE_SIZE__ 8
__PTHREAD_RWLOCK_SIZE__ 192
__PTHREAD_RWLOCKATTR_SIZE__ 16
__IMAGE4_API_COPROCESSOR_AP_H None
IMAGE4_COPROCESSOR_HANDLE_AP_DEFAULT IMAGE4_COPROCESSOR_HANDLE_AP
__IMAGE4_API_COPROCESSOR_AP_LOCAL_H None
IMAGE4_COPROCESSOR_HANDLE_AP_LOCAL_DEFAULT IMAGE4_COPROCESSOR_HANDLE_AP_LOCAL
__IMAGE4_API_COPROCESSOR_BOOTPC_H None
IMAGE4_COPROCESSOR_HANDLE_BOOTPC_DEFAULT IMAGE4_COPROCESSOR_HANDLE_BOOTPC_SHA2_384
__IMAGE4_API_COPROCESSOR_CRYPTEX1_H None
IMAGE4_COPROCESSOR_HANDLE_CRYPTEX1_DEFAULT IMAGE4_COPROCESSOR_HANDLE_CRYPTEX1_BOOT
__IMAGE4_API_COPROCESSOR_SEP_H None
IMAGE4_COPROCESSOR_HANDLE_SEP_DEFAULT IMAGE4_COPROCESSOR_HANDLE_SEP
__IMAGE4_API_COPROCESSOR_VMA2_H None
__IMAGE4_API_COPROCESSOR_VMA3_H None
__IMAGE4_API_COPROCESSOR_X86_H None
IMAGE4_COPROCESSOR_HANDLE_X86_DEFAULT IMAGE4_COPROCESSOR_HANDLE_X86
__IMAGE4_DARWIN_CRYPTEX1_NONCE_H None
__IMAGE4_CS_PMAP_H None
__IMAGE4_CS_TRAPS_H None
__cs_copy None
__cs_xfer None
__cs_borrow None
__cs_nullable None
__cs_diagnostic None
image4_cs_trap_handler(_el, _where, _which) 	_image4_ ## _el ## _cs_trap_ ## _where ## _ ## _which
image4_cs_trap_argv(_which) image4_cs_trap_argv_ ## _which ## _t
image4_cs_trap_argv_decl(_which) typedef struct _image4_cs_trap_argv_ ## _which 			image4_cs_trap_argv(_which); 	struct __attribute__((packed)) _image4_cs_trap_argv_ ## _which
__IMAGE4_API_RESTRICTED_ENVIRONMENT_H None
image4_environment_get_firmware_chip(...) image4_call_restricted(environment_get_firmware_chip, ## __VA_ARGS__)
__OS_BASE__ None
__has_builtin(x) 0
__has_include(x) 0
__has_feature(x) 0
__has_attribute(x) 0
__has_extension(x) 0
__OS_STRINGIFY(s) #s
OS_STRINGIFY(s) __OS_STRINGIFY(s)
__OS_CONCAT(x, y) x ## y
OS_CONCAT(x, y) __OS_CONCAT(x, y)
OS_ASSUME_PTR_ABI_SINGLE_BEGIN __ASSUME_PTR_ABI_SINGLE_BEGIN
OS_ASSUME_PTR_ABI_SINGLE_END __ASSUME_PTR_ABI_SINGLE_END
OS_UNSAFE_INDEXABLE __unsafe_indexable
OS_HEADER_INDEXABLE __header_indexable
OS_COUNTED_BY(N) __counted_by(N)
OS_SIZED_BY(N) __sized_by(N)
__IMAGE4_SHIM_SYS_TYPES_H None
_ARCH_I386_ASM_HELP_H_ None
DESC_CODE_EXEC 0x18
DESC_CODE_READ 0x1a
DESC_CODE_16B 0
DESC_CODE_32B 1
DESC_GRAN_BYTE 0
DESC_GRAN_PAGE 1
DESC_DATA_RONLY 0x10
DESC_DATA_WRITE 0x12
DESC_DATA_16B 0
DESC_DATA_32B 1
DESC_LDT 0x02
DESC_CALL_GATE 0x0c
DESC_TRAP_GATE 0x0f
DESC_INTR_GATE 0x0e
_ARCH_I386_PIO_H_ None
_ARCH_I386_REG_HELP_H_ None
BITS_WIDTH(msb, lsb)	((msb)-(lsb)+1)
MKMASK(width, offset)	(((unsigned)-1)>>(32-(width))<<(offset))
BITSMASK(msb, lsb)	MKMASK(BITS_WIDTH(msb, lsb), lsb & 0x1f)
BITMASK(pos) MKMASK(BIT_WIDTH(pos), pos & 0x1f)
STACK_INCR 4
__STR(x) #x
STRINGIFY(x) __STR(x)
REG_PAIR_DEF(type0, name0, type1, name1)			struct {								type0	name0 __attribute__(( aligned(8) ));			type1	name1;						} name0##_##name1
REG_PAIR(name0, name1, the_name)				name0##_##name1.the_name
__XNU_ARCH_I386_SEL_H None
KERN_PRIV 0
USER_PRIV 3
SEL_GDT 0
SEL_LDT 1
DESC_TBL_MAX 8192
DESC_TSS 0x09
DESC_TASK_GATE 0x05
_MACHINE_DISKLABEL_H_ None
_ARM__ENDIAN_H_ None
_QUAD_HIGHWORD 1
_QUAD_LOWWORD 0
_ARM_FASTTRAP_ISA_H None
_FASTTRAP_ISA_H None
ftt_instr ftt_mtp.ftmt_instr.instr32
ftt_instr1 ftt_mtp.ftmt_instr.instr16.instr1
ftt_instr2 ftt_mtp.ftmt_instr.instr16.instr2
ftt_fntype ftt_mtp.ftmt_fntype
ftt_thumb ftt_mtp.ftmt_thumb
ftt_type ftt_mtp.ftmt_type
ftt_installed ftt_mtp.ftmt_installed
ftt_retired ftt_mtp.ftmt_retired
FASTTRAP_T_INV 1
FASTTRAP_T_COMMON 2
FASTTRAP_T_BLX 3
FASTTRAP_T_B_COND 4
FASTTRAP_T_B_UNCOND 5
FASTTRAP_T_BX_REG 6
FASTTRAP_T_PUSH_LR 7
FASTTRAP_T_POP_PC 8
FASTTRAP_T_STM_LR 9
FASTTRAP_T_LDM_PC 10
FASTTRAP_T_CPY_PC 11
FASTTRAP_T_MOV_PC_REG 12
FASTTRAP_T_LDR_PC_IMMED 13
FASTTRAP_T_VLDR_PC_IMMED 14
FASTTRAP_T_CB_N_Z 15
FASTTRAP_T_ARM64_STANDARD_FUNCTION_ENTRY 16
FASTTRAP_T_ARM64_LDR_S_PC_REL 17
FASTTRAP_T_ARM64_LDR_W_PC_REL 18
FASTTRAP_T_ARM64_LDR_D_PC_REL 19
FASTTRAP_T_ARM64_LDR_X_PC_REL 20
FASTTRAP_T_ARM64_LDR_Q_PC_REL 21
FASTTRAP_T_ARM64_LDRSW_PC_REL 22
FASTTRAP_T_ARM64_B_COND 23
FASTTRAP_T_ARM64_CBNZ_W 24
FASTTRAP_T_ARM64_CBNZ_X 25
FASTTRAP_T_ARM64_CBZ_W 26
FASTTRAP_T_ARM64_CBZ_X 27
FASTTRAP_T_ARM64_TBNZ 28
FASTTRAP_T_ARM64_TBZ 29
FASTTRAP_T_ARM64_B 30
FASTTRAP_T_ARM64_BL 31
FASTTRAP_T_ARM64_BLR 32
FASTTRAP_T_ARM64_BR 33
FASTTRAP_T_ARM64_RET 34
FASTTRAP_T_ARM64_ADRP 35
FASTTRAP_T_ARM64_ADR 36
FASTTRAP_T_ARM64_PRFM 37
FASTTRAP_T_ARM64_EXCLUSIVE_MEM 38
FASTTRAP_T_ARM64_RETAB 39
FASTTRAP_FN_DONE_INIT 255
FASTTRAP_FN_UNKNOWN 0
FASTTRAP_FN_ARM 1
FASTTRAP_FN_THUMB 2
FASTTRAP_FN_USDT 3
FASTTRAP_FN_ARM64 4
FASTTRAP_FN_ARM64_32 5
THUMB32_RM(x, y) ((y) & 0xF)
THUMB32_RD(x, y) (((y) >> 8) & 0xF)
THUMB32_RT(x, y) (((y) >> 12) & 0xF)
THUMB32_RN(x, y) ((x) & 0xF)
REG_SP 13
REG_LR 14
REG_PC 15
FASTTRAP_RETURN_AFRAMES 6
FASTTRAP_ENTRY_AFRAMES 5
FASTTRAP_OFFSET_AFRAMES 5
FASTTRAP_ARM64_OP_VALUE_FUNC_ENTRY 0xa9bf7bfd
FASTTRAP_ARM64_OP_MASK_LDR_S_PC_REL 0xff000000
FASTTRAP_ARM64_OP_VALUE_LDR_S_PC_REL 0x1c000000
FASTTRAP_ARM64_OP_MASK_LDR_W_PC_REL 0xff000000
FASTTRAP_ARM64_OP_VALUE_LDR_W_PC_REL 0x18000000
FASTTRAP_ARM64_OP_MASK_LDR_D_PC_REL 0xff000000
FASTTRAP_ARM64_OP_VALUE_LDR_D_PC_REL 0x5c000000
FASTTRAP_ARM64_OP_MASK_LDR_X_PC_REL 0xff000000
FASTTRAP_ARM64_OP_VALUE_LDR_X_PC_REL 0x58000000
FASTTRAP_ARM64_OP_MASK_LDR_Q_PC_REL 0xff000000
FASTTRAP_ARM64_OP_VALUE_LDR_Q_PC_REL 0x9c000000
FASTTRAP_ARM64_OP_MASK_LRDSW_PC_REL 0xff000000
FASTTRAP_ARM64_OP_VALUE_LRDSW_PC_REL 0x98000000
FASTTRAP_ARM64_OP_MASK_B_COND_PC_REL 0xff000010
FASTTRAP_ARM64_OP_VALUE_B_COND_PC_REL 0x54000000
FASTTRAP_ARM64_OP_MASK_CBNZ_W_PC_REL 0xff000000
FASTTRAP_ARM64_OP_VALUE_CBNZ_W_PC_REL 0x35000000
FASTTRAP_ARM64_OP_MASK_CBNZ_X_PC_REL 0xff000000
FASTTRAP_ARM64_OP_VALUE_CBNZ_X_PC_REL 0xb5000000
FASTTRAP_ARM64_OP_MASK_CBZ_W_PC_REL 0xff000000
FASTTRAP_ARM64_OP_VALUE_CBZ_W_PC_REL 0x34000000
FASTTRAP_ARM64_OP_MASK_CBZ_X_PC_REL 0xff000000
FASTTRAP_ARM64_OP_VALUE_CBZ_X_PC_REL 0xb4000000
FASTTRAP_ARM64_OP_MASK_TBNZ_PC_REL 0x7f000000
FASTTRAP_ARM64_OP_VALUE_TBNZ_PC_REL 0x37000000
FASTTRAP_ARM64_OP_MASK_TBZ_PC_REL 0x7f000000
FASTTRAP_ARM64_OP_VALUE_TBZ_PC_REL 0x36000000
FASTTRAP_ARM64_OP_MASK_B_PC_REL 0xfc000000
FASTTRAP_ARM64_OP_VALUE_B_PC_REL 0x14000000
FASTTRAP_ARM64_OP_MASK_BL_PC_REL 0xfc000000
FASTTRAP_ARM64_OP_VALUE_BL_PC_REL 0x94000000
FASTTRAP_ARM64_OP_MASK_BLR 0xfffffe1f
FASTTRAP_ARM64_OP_VALUE_BLR 0xd63f0000
FASTTRAP_ARM64_OP_MASK_BR 0xfffffe1f
FASTTRAP_ARM64_OP_VALUE_BR 0xd61f0000
FASTTRAP_ARM64_OP_MASK_RET 0xfffffc1f
FASTTRAP_ARM64_OP_VALUE_RET 0xd65f0000
FASTTRAP_ARM64_OP_MASK_ADRP 0x9f000000
FASTTRAP_ARM64_OP_VALUE_ADRP 0x90000000
FASTTRAP_ARM64_OP_MASK_ADR 0x9f000000
FASTTRAP_ARM64_OP_VALUE_ADR 0x10000000
FASTTRAP_ARM64_OP_MASK_PRFM 0xff000000
FASTTRAP_ARM64_OP_VALUE_PRFM 0xd8000000
FASTTRAP_ARM64_OP_MASK_EXCL_MEM 0x3f000000
FASTTRAP_ARM64_OP_VALUE_EXCL_MEM 0x08000000
FASTTRAP_ARM64_OP_MASK_RETAB 0xfffffc1f
FASTTRAP_ARM64_OP_VALUE_RETAB 0xd65f0c1f
_ARM_LIMITS_H_ None
USE_CLANG_LIMITS 0
MB_LEN_MAX 6
_ARM_PARAM_H_ None
ALIGNBYTES __DARWIN_ALIGNBYTES
ALIGN(p) __DARWIN_ALIGN(p)
NBPG 4096
PGSHIFT 12
DEV_BSIZE 512
DEV_BSHIFT 9
BLKDEV_IOSIZE 2048
CLSIZE 1
CLSIZELOG2 0
MSIZESHIFT 8
MCLSHIFT 11
MBIGCLSHIFT 12
M16KCLSHIFT 14
NMBCLUSTERS CONFIG_NMBCLUSTERS
btodb(bytes, devBlockSize)         	((unsigned)(bytes) / devBlockSize)
dbtob(db, devBlockSize)            	((unsigned)(db) * devBlockSize)
STATUS_WORD(rpl, ipl)   (((ipl) << 8) | (rpl))
DELAY(n) delay(n)
_BSD_ARM_PROFILE_H_ None
_BSD_ARM_PSL_H_ None
_BSD_ARM_REG_H_ None
_ARM_SIGNAL_ 1
_ARM_MACHTYPES_H_ None
_MACHTYPES_H_ None
_BSD_ARM_VMPARAM_H_ 1
_ARM___ENDIAN_H_ None
__DARWIN_BYTE_ORDER __DARWIN_LITTLE_ENDIAN
_ARM__LIMITS_H_ None
__DARWIN_CLK_TCK 100
__ARM_MCONTEXT_H_ None
_MCONTEXT_T None
_STRUCT_MCONTEXT _STRUCT_MCONTEXT64
_ARM__PARAM_H_ None
_BSD_ARM__TYPES_H_ None
USE_CLANG_TYPES 0
_BSM_AUDIT_H None
AUDIT_RECORD_MAGIC 0x828a0f1b
MAX_AUDIT_RECORDS 20
MAX_AUDIT_RECORD_SIZE MAXAUDITDATA
AUDIT_HARD_LIMIT_FREE_BLOCKS 4
AUDIT_TRIGGER_MIN 1
AUDIT_TRIGGER_LOW_SPACE 1
AUDIT_TRIGGER_ROTATE_KERNEL 2
AUDIT_TRIGGER_READ_FILE 3
AUDIT_TRIGGER_CLOSE_AND_DIE 4
AUDIT_TRIGGER_NO_SPACE 5
AUDIT_TRIGGER_ROTATE_USER 6
AUDIT_TRIGGER_INITIALIZE 7
AUDIT_TRIGGER_EXPIRE_TRAILS 8
AUDIT_TRIGGER_MAX 8
AUDITDEV_FILENAME "audit"
AU_DEFAUDITSID 0
AU_ASSIGN_ASID -1
AUC_UNSET 0
AUC_AUDITING 1
AUC_NOAUDIT 2
AUC_DISABLED -1
A_OLDGETPOLICY 2
A_OLDSETPOLICY 3
A_GETKMASK 4
A_SETKMASK 5
A_OLDGETQCTRL 6
A_OLDSETQCTRL 7
A_GETCWD 8
A_GETCAR 9
A_GETSTAT 12
A_SETSTAT 13
A_SETUMASK 14
A_SETSMASK 15
A_OLDGETCOND 20
A_OLDSETCOND 21
A_GETCLASS 22
A_SETCLASS 23
A_GETPINFO 24
A_SETPMASK 25
A_SETFSIZE 26
A_GETFSIZE 27
A_GETPINFO_ADDR 28
A_GETKAUDIT 29
A_SETKAUDIT 30
A_SENDTRIGGER 31
A_GETSINFO_ADDR 32
A_GETPOLICY 33
A_SETPOLICY 34
A_GETQCTRL 35
A_SETQCTRL 36
A_GETCOND 37
A_SETCOND 38
A_GETSFLAGS 39
A_SETSFLAGS 40
A_GETCTLMODE 41
A_SETCTLMODE 42
A_GETEXPAFTER 43
A_SETEXPAFTER 44
AUDIT_CNT 0x0001
AUDIT_AHLT 0x0002
AUDIT_ARGV 0x0004
AUDIT_ARGE 0x0008
AUDIT_SEQ 0x0010
AUDIT_WINDATA 0x0020
AUDIT_USER 0x0040
AUDIT_GROUP 0x0080
AUDIT_TRAIL 0x0100
AUDIT_PATH 0x0200
AUDIT_SCNT 0x0400
AUDIT_PUBLIC 0x0800
AUDIT_ZONENAME 0x1000
AUDIT_PERZONE 0x2000
AQ_HIWATER 100
AQ_MAXHIGH 10000
AQ_LOWATER 10
AQ_BUFSZ MAXAUDITDATA
AQ_MAXBUFSZ 1048576
AU_FS_MINFREE 20
AU_IPv4 4
AU_IPv6 16
AU_CLASS_MASK_RESERVED 0x10000000
_BSM_AUDIT_DOMAIN_H_ None
BSM_PF_UNSPEC 0
BSM_PF_LOCAL 1
BSM_PF_INET 2
BSM_PF_IMPLINK 3
BSM_PF_PUP 4
BSM_PF_CHAOS 5
BSM_PF_NS 6
BSM_PF_NBS 7
BSM_PF_ECMA 8
BSM_PF_DATAKIT 9
BSM_PF_CCITT 10
BSM_PF_SNA 11
BSM_PF_DECnet 12
BSM_PF_DLI 13
BSM_PF_LAT 14
BSM_PF_HYLINK 15
BSM_PF_APPLETALK 16
BSM_PF_NIT 17
BSM_PF_802 18
BSM_PF_OSI 19
BSM_PF_X25 20
BSM_PF_OSINET 21
BSM_PF_GOSIP 22
BSM_PF_IPX 23
BSM_PF_ROUTE 24
BSM_PF_LINK 25
BSM_PF_INET6 26
BSM_PF_KEY 27
BSM_PF_NCA 28
BSM_PF_POLICY 29
BSM_PF_INET_OFFLOAD 30
BSM_PF_NETBIOS 500
BSM_PF_ISO 501
BSM_PF_XTP 502
BSM_PF_COIP 503
BSM_PF_CNT 504
BSM_PF_RTIP 505
BSM_PF_SIP 506
BSM_PF_PIP 507
BSM_PF_ISDN 508
BSM_PF_E164 509
BSM_PF_NATM 510
BSM_PF_ATM 511
BSM_PF_NETGRAPH 512
BSM_PF_SLOW 513
BSM_PF_SCLUSTER 514
BSM_PF_ARP 515
BSM_PF_BLUETOOTH 516
BSM_PF_IEEE80211 517
BSM_PF_AX25 518
BSM_PF_ROSE 519
BSM_PF_NETBEUI 520
BSM_PF_SECURITY 521
BSM_PF_PACKET 522
BSM_PF_ASH 523
BSM_PF_ECONET 524
BSM_PF_ATMSVC 525
BSM_PF_IRDA 526
BSM_PF_PPPOX 527
BSM_PF_WANPIPE 528
BSM_PF_LLC 529
BSM_PF_CAN 530
BSM_PF_TIPC 531
BSM_PF_IUCV 532
BSM_PF_RXRPC 533
BSM_PF_PHONET 534
BSM_PF_UNKNOWN 700
_BSM_AUDIT_ERRNO_H_ None
BSM_ERRNO_ESUCCESS 0
BSM_ERRNO_EPERM 1
BSM_ERRNO_ENOENT 2
BSM_ERRNO_ESRCH 3
BSM_ERRNO_EINTR 4
BSM_ERRNO_EIO 5
BSM_ERRNO_ENXIO 6
BSM_ERRNO_E2BIG 7
BSM_ERRNO_ENOEXEC 8
BSM_ERRNO_EBADF 9
BSM_ERRNO_ECHILD 10
BSM_ERRNO_EAGAIN 11
BSM_ERRNO_ENOMEM 12
BSM_ERRNO_EACCES 13
BSM_ERRNO_EFAULT 14
BSM_ERRNO_ENOTBLK 15
BSM_ERRNO_EBUSY 16
BSM_ERRNO_EEXIST 17
BSM_ERRNO_EXDEV 18
BSM_ERRNO_ENODEV 19
BSM_ERRNO_ENOTDIR 20
BSM_ERRNO_EISDIR 21
BSM_ERRNO_EINVAL 22
BSM_ERRNO_ENFILE 23
BSM_ERRNO_EMFILE 24
BSM_ERRNO_ENOTTY 25
BSM_ERRNO_ETXTBSY 26
BSM_ERRNO_EFBIG 27
BSM_ERRNO_ENOSPC 28
BSM_ERRNO_ESPIPE 29
BSM_ERRNO_EROFS 30
BSM_ERRNO_EMLINK 31
BSM_ERRNO_EPIPE 32
BSM_ERRNO_EDOM 33
BSM_ERRNO_ERANGE 34
BSM_ERRNO_ENOMSG 35
BSM_ERRNO_EIDRM 36
BSM_ERRNO_ECHRNG 37
BSM_ERRNO_EL2NSYNC 38
BSM_ERRNO_EL3HLT 39
BSM_ERRNO_EL3RST 40
BSM_ERRNO_ELNRNG 41
BSM_ERRNO_EUNATCH 42
BSM_ERRNO_ENOCSI 43
BSM_ERRNO_EL2HLT 44
BSM_ERRNO_EDEADLK 45
BSM_ERRNO_ENOLCK 46
BSM_ERRNO_ECANCELED 47
BSM_ERRNO_ENOTSUP 48
BSM_ERRNO_EDQUOT 49
BSM_ERRNO_EBADE 50
BSM_ERRNO_EBADR 51
BSM_ERRNO_EXFULL 52
BSM_ERRNO_ENOANO 53
BSM_ERRNO_EBADRQC 54
BSM_ERRNO_EBADSLT 55
BSM_ERRNO_EDEADLOCK 56
BSM_ERRNO_EBFONT 57
BSM_ERRNO_EOWNERDEAD 58
BSM_ERRNO_ENOTRECOVERABLE 59
BSM_ERRNO_ENOSTR 60
BSM_ERRNO_ENODATA 61
BSM_ERRNO_ETIME 62
BSM_ERRNO_ENOSR 63
BSM_ERRNO_ENONET 64
BSM_ERRNO_ENOPKG 65
BSM_ERRNO_EREMOTE 66
BSM_ERRNO_ENOLINK 67
BSM_ERRNO_EADV 68
BSM_ERRNO_ESRMNT 69
BSM_ERRNO_ECOMM 70
BSM_ERRNO_EPROTO 71
BSM_ERRNO_ELOCKUNMAPPED 72
BSM_ERRNO_ENOTACTIVE 73
BSM_ERRNO_EMULTIHOP 74
BSM_ERRNO_EBADMSG 77
BSM_ERRNO_ENAMETOOLONG 78
BSM_ERRNO_EOVERFLOW 79
BSM_ERRNO_ENOTUNIQ 80
BSM_ERRNO_EBADFD 81
BSM_ERRNO_EREMCHG 82
BSM_ERRNO_ELIBACC 83
BSM_ERRNO_ELIBBAD 84
BSM_ERRNO_ELIBSCN 85
BSM_ERRNO_ELIBMAX 86
BSM_ERRNO_ELIBEXEC 87
BSM_ERRNO_EILSEQ 88
BSM_ERRNO_ENOSYS 89
BSM_ERRNO_ELOOP 90
BSM_ERRNO_ERESTART 91
BSM_ERRNO_ESTRPIPE 92
BSM_ERRNO_ENOTEMPTY 93
BSM_ERRNO_EUSERS 94
BSM_ERRNO_ENOTSOCK 95
BSM_ERRNO_EDESTADDRREQ 96
BSM_ERRNO_EMSGSIZE 97
BSM_ERRNO_EPROTOTYPE 98
BSM_ERRNO_ENOPROTOOPT 99
BSM_ERRNO_EPROTONOSUPPORT 120
BSM_ERRNO_ESOCKTNOSUPPORT 121
BSM_ERRNO_EOPNOTSUPP 122
BSM_ERRNO_EPFNOSUPPORT 123
BSM_ERRNO_EAFNOSUPPORT 124
BSM_ERRNO_EADDRINUSE 125
BSM_ERRNO_EADDRNOTAVAIL 126
BSM_ERRNO_ENETDOWN 127
BSM_ERRNO_ENETUNREACH 128
BSM_ERRNO_ENETRESET 129
BSM_ERRNO_ECONNABORTED 130
BSM_ERRNO_ECONNRESET 131
BSM_ERRNO_ENOBUFS 132
BSM_ERRNO_EISCONN 133
BSM_ERRNO_ENOTCONN 134
BSM_ERRNO_ESHUTDOWN 143
BSM_ERRNO_ETOOMANYREFS 144
BSM_ERRNO_ETIMEDOUT 145
BSM_ERRNO_ECONNREFUSED 146
BSM_ERRNO_EHOSTDOWN 147
BSM_ERRNO_EHOSTUNREACH 148
BSM_ERRNO_EALREADY 149
BSM_ERRNO_EINPROGRESS 150
BSM_ERRNO_ESTALE 151
BSM_ERRNO_EQFULL 152
BSM_ERRNO_EPROCLIM 190
BSM_ERRNO_EBADRPC 191
BSM_ERRNO_ERPCMISMATCH 192
BSM_ERRNO_EPROGUNAVAIL 193
BSM_ERRNO_EPROGMISMATCH 194
BSM_ERRNO_EPROCUNAVAIL 195
BSM_ERRNO_EFTYPE 196
BSM_ERRNO_EAUTH 197
BSM_ERRNO_ENEEDAUTH 198
BSM_ERRNO_ENOATTR 199
BSM_ERRNO_EDOOFUS 200
BSM_ERRNO_EJUSTRETURN 201
BSM_ERRNO_ENOIOCTL 202
BSM_ERRNO_EDIRIOCTL 203
BSM_ERRNO_EPWROFF 204
BSM_ERRNO_EDEVERR 205
BSM_ERRNO_EBADEXEC 206
BSM_ERRNO_EBADARCH 207
BSM_ERRNO_ESHLIBVERS 208
BSM_ERRNO_EBADMACHO 209
BSM_ERRNO_EPOLICY 210
BSM_ERRNO_EDOTDOT 211
BSM_ERRNO_EUCLEAN 212
BSM_ERRNO_ENOTNAM 213
BSM_ERRNO_ENAVAIL 214
BSM_ERRNO_EISNAM 215
BSM_ERRNO_EREMOTEIO 216
BSM_ERRNO_ENOMEDIUM 217
BSM_ERRNO_EMEDIUMTYPE 218
BSM_ERRNO_ENOKEY 219
BSM_ERRNO_EKEYEXPIRED 220
BSM_ERRNO_EKEYREVOKED 221
BSM_ERRNO_EKEYREJECTED 222
BSM_ERRNO_UNKNOWN 250
_BSM_AUDIT_FCNTL_H_ None
BSM_F_DUPFD 0
BSM_F_GETFD 1
BSM_F_SETFD 2
BSM_F_GETFL 3
BSM_F_SETFL 4
BSM_F_O_GETLK 5
BSM_F_SETLK 6
BSM_F_SETLKW 7
BSM_F_CHKFL 8
BSM_F_DUP2FD 9
BSM_F_ALLOCSP 10
BSM_F_FREESP 11
BSM_F_ISSTREAM 13
BSM_F_GETLK 14
BSM_F_PRIV 15
BSM_F_NPRIV 16
BSM_F_QUOTACTL 17
BSM_F_BLOCKS 18
BSM_F_BLKSIZE 19
BSM_F_GETOWN 23
BSM_F_SETOWN 24
BSM_F_REVOKE 25
BSM_F_HASREMOTELOCKS 26
BSM_F_FREESP64 27
BSM_F_ALLOCSP64 28
BSM_F_GETLK64 33
BSM_F_SETLK64 34
BSM_F_SETLKW64 35
BSM_F_SHARE 40
BSM_F_UNSHARE 41
BSM_F_SETLK_NBMAND 42
BSM_F_SHARE_NBMAND 43
BSM_F_SETLK64_NBMAND 44
BSM_F_GETXFL 45
BSM_F_BADFD 46
BSM_F_OGETLK 107
BSM_F_OSETLK 108
BSM_F_OSETLKW 109
BSM_F_SETLK_REMOTE 114
BSM_F_SETSIG 210
BSM_F_GETSIG 211
BSM_F_CHKCLEAN 341
BSM_F_PREALLOCATE 342
BSM_F_SETSIZE 343
BSM_F_RDADVISE 344
BSM_F_RDAHEAD 345
BSM_F_NOCACHE 348
BSM_F_LOG2PHYS 349
BSM_F_GETPATH 350
BSM_F_FULLFSYNC 351
BSM_F_PATHPKG_CHECK 352
BSM_F_FREEZE_FS 353
BSM_F_THAW_FS 354
BSM_F_GLOBAL_NOCACHE 355
BSM_F_OPENFROM 356
BSM_F_UNLINKFROM 357
BSM_F_CHECK_OPENEVT 358
BSM_F_ADDSIGS 359
BSM_F_MARKDEPENDENCY 360
BSM_F_BARRIERFSYNC 361
BSM_F_PUNCHHOLE 362
BSM_F_TRIM_ACTIVE_FILE 363
BSM_F_SPECULATIVE_READ 364
BSM_F_ATTRIBUTION_TAG 365
BSM_F_FS_SPECIFIC_0 400
BSM_F_FS_SPECIFIC_1 401
BSM_F_FS_SPECIFIC_2 402
BSM_F_FS_SPECIFIC_3 403
BSM_F_FS_SPECIFIC_4 404
BSM_F_FS_SPECIFIC_5 405
BSM_F_FS_SPECIFIC_6 406
BSM_F_FS_SPECIFIC_7 407
BSM_F_FS_SPECIFIC_8 408
BSM_F_FS_SPECIFIC_9 409
BSM_F_FS_SPECIFIC_10 410
BSM_F_FS_SPECIFIC_11 411
BSM_F_FS_SPECIFIC_12 412
BSM_F_FS_SPECIFIC_13 413
BSM_F_FS_SPECIFIC_14 414
BSM_F_FS_SPECIFIC_15 415
BSM_F_UNKNOWN 0xFFFF
_AUDIT_INTERNAL_H None
AUDIT_HEADER_SIZE 18
AUDIT_TRAILER_SIZE 7
MAX_AUDIT_IDENTITY_SIZE 179
ADD_U_CHAR(loc, val)                                            	do {                                                            	        *(loc) = (val);                                         	        (loc) += sizeof(u_char);                                	} while(0)
ADD_U_INT16(loc, val)                                           	do {                                                            	        be16enc((loc), (val));                                  	        (loc) += sizeof(u_int16_t);                             	} while(0)
ADD_U_INT32(loc, val)                                           	do {                                                            	        be32enc((loc), (val));                                  	        (loc) += sizeof(u_int32_t);                             	} while(0)
ADD_U_INT64(loc, val)                                           	do {                                                            	        be64enc((loc), (val));                                  	        (loc) += sizeof(u_int64_t);                             	} while(0)
ADD_MEM(loc, data, size)                                        	do {                                                            	        memcpy((loc), (data), (size));                          	        (loc) += size;                                          	} while(0)
ADD_STRING(loc, data, size)     ADD_MEM(loc, data, size)
_BSM_AUDIT_KERNEL_H None
_BSM_AUDIT_KEVENTS_H_ None
AUE_NULL 0
AUE_EXIT 1
AUE_FORK 2
AUE_FORKALL AUE_FORK
AUE_OPEN 3
AUE_CREAT 4
AUE_LINK 5
AUE_UNLINK 6
AUE_DELETE AUE_UNLINK
AUE_EXEC 7
AUE_CHDIR 8
AUE_MKNOD 9
AUE_CHMOD 10
AUE_CHOWN 11
AUE_UMOUNT 12
AUE_JUNK 13
AUE_ACCESS 14
AUE_KILL 15
AUE_STAT 16
AUE_LSTAT 17
AUE_ACCT 18
AUE_MCTL 19
AUE_REBOOT 20
AUE_SYMLINK 21
AUE_READLINK 22
AUE_EXECVE 23
AUE_CHROOT 24
AUE_VFORK 25
AUE_SETGROUPS 26
AUE_SETPGRP 27
AUE_SWAPON 28
AUE_SETHOSTNAME 29
AUE_FCNTL 30
AUE_SETPRIORITY 31
AUE_CONNECT 32
AUE_ACCEPT 33
AUE_BIND 34
AUE_SETSOCKOPT 35
AUE_VTRACE 36
AUE_SETTIMEOFDAY 37
AUE_FCHOWN 38
AUE_FCHMOD 39
AUE_SETREUID 40
AUE_SETREGID 41
AUE_RENAME 42
AUE_TRUNCATE 43
AUE_FTRUNCATE 44
AUE_FLOCK 45
AUE_SHUTDOWN 46
AUE_MKDIR 47
AUE_RMDIR 48
AUE_UTIMES 49
AUE_ADJTIME 50
AUE_SETRLIMIT 51
AUE_KILLPG 52
AUE_NFS_SVC 53
AUE_STATFS 54
AUE_FSTATFS 55
AUE_UNMOUNT 56
AUE_ASYNC_DAEMON 57
AUE_NFS_GETFH 58
AUE_SETDOMAINNAME 59
AUE_QUOTACTL 60
AUE_EXPORTFS 61
AUE_MOUNT 62
AUE_SEMSYS 63
AUE_MSGSYS 64
AUE_SHMSYS 65
AUE_BSMSYS 66
AUE_RFSSYS 67
AUE_FCHDIR 68
AUE_FCHROOT 69
AUE_VPIXSYS 70
AUE_PATHCONF 71
AUE_OPEN_R 72
AUE_OPEN_RC 73
AUE_OPEN_RT 74
AUE_OPEN_RTC 75
AUE_OPEN_W 76
AUE_OPEN_WC 77
AUE_OPEN_WT 78
AUE_OPEN_WTC 79
AUE_OPEN_RW 80
AUE_OPEN_RWC 81
AUE_OPEN_RWT 82
AUE_OPEN_RWTC 83
AUE_MSGCTL 84
AUE_MSGCTL_RMID 85
AUE_MSGCTL_SET 86
AUE_MSGCTL_STAT 87
AUE_MSGGET 88
AUE_MSGRCV 89
AUE_MSGSND 90
AUE_SHMCTL 91
AUE_SHMCTL_RMID 92
AUE_SHMCTL_SET 93
AUE_SHMCTL_STAT 94
AUE_SHMGET 95
AUE_SHMAT 96
AUE_SHMDT 97
AUE_SEMCTL 98
AUE_SEMCTL_RMID 99
AUE_SEMCTL_SET 100
AUE_SEMCTL_STAT 101
AUE_SEMCTL_GETNCNT 102
AUE_SEMCTL_GETPID 103
AUE_SEMCTL_GETVAL 104
AUE_SEMCTL_GETALL 105
AUE_SEMCTL_GETZCNT 106
AUE_SEMCTL_SETVAL 107
AUE_SEMCTL_SETALL 108
AUE_SEMGET 109
AUE_SEMOP 110
AUE_CORE 111
AUE_CLOSE 112
AUE_SYSTEMBOOT 113
AUE_ASYNC_DAEMON_EXIT 114
AUE_NFSSVC_EXIT 115
AUE_WRITEL 128
AUE_WRITEVL 129
AUE_GETAUID 130
AUE_SETAUID 131
AUE_GETAUDIT 132
AUE_SETAUDIT 133
AUE_GETUSERAUDIT 134
AUE_SETUSERAUDIT 135
AUE_AUDITSVC 136
AUE_AUDITUSER 137
AUE_AUDITON 138
AUE_AUDITON_GTERMID 139
AUE_AUDITON_STERMID 140
AUE_AUDITON_GPOLICY 141
AUE_AUDITON_SPOLICY 142
AUE_AUDITON_GQCTRL 145
AUE_AUDITON_SQCTRL 146
AUE_GETKERNSTATE 147
AUE_SETKERNSTATE 148
AUE_GETPORTAUDIT 149
AUE_AUDITSTAT 150
AUE_REVOKE 151
AUE_MAC 152
AUE_ENTERPROM 153
AUE_EXITPROM 154
AUE_IFLOAT 155
AUE_PFLOAT 156
AUE_UPRIV 157
AUE_IOCTL 158
AUE_SOCKET 183
AUE_SENDTO 184
AUE_PIPE 185
AUE_SOCKETPAIR 186
AUE_SEND 187
AUE_SENDMSG 188
AUE_RECV 189
AUE_RECVMSG 190
AUE_RECVFROM 191
AUE_READ 192
AUE_GETDENTS 193
AUE_LSEEK 194
AUE_WRITE 195
AUE_WRITEV 196
AUE_NFS 197
AUE_READV 198
AUE_OSTAT 199
AUE_SETUID 200
AUE_STIME 201
AUE_UTIME 202
AUE_NICE 203
AUE_OSETPGRP 204
AUE_SETGID 205
AUE_READL 206
AUE_READVL 207
AUE_FSTAT 208
AUE_DUP2 209
AUE_MMAP 210
AUE_AUDIT 211
AUE_PRIOCNTLSYS 212
AUE_MUNMAP 213
AUE_SETEGID 214
AUE_SETEUID 215
AUE_PUTMSG 216
AUE_GETMSG 217
AUE_PUTPMSG 218
AUE_GETPMSG 219
AUE_AUDITSYS 220
AUE_AUDITON_GETKMASK 221
AUE_AUDITON_SETKMASK 222
AUE_AUDITON_GETCWD 223
AUE_AUDITON_GETCAR 224
AUE_AUDITON_GETSTAT 225
AUE_AUDITON_SETSTAT 226
AUE_AUDITON_SETUMASK 227
AUE_AUDITON_SETSMASK 228
AUE_AUDITON_GETCOND 229
AUE_AUDITON_SETCOND 230
AUE_AUDITON_GETCLASS 231
AUE_AUDITON_SETCLASS 232
AUE_FUSERS 233
AUE_STATVFS 234
AUE_XSTAT 235
AUE_LXSTAT 236
AUE_LCHOWN 237
AUE_MEMCNTL 238
AUE_SYSINFO 239
AUE_XMKNOD 240
AUE_FORK1 241
AUE_MODCTL 242
AUE_MODLOAD 243
AUE_MODUNLOAD 244
AUE_MODCONFIG 245
AUE_MODADDMAJ 246
AUE_SOCKACCEPT 247
AUE_SOCKCONNECT 248
AUE_SOCKSEND 249
AUE_SOCKRECEIVE 250
AUE_ACLSET 251
AUE_FACLSET 252
AUE_DOORFS 253
AUE_DOORFS_DOOR_CALL 254
AUE_DOORFS_DOOR_RETURN 255
AUE_DOORFS_DOOR_CREATE 256
AUE_DOORFS_DOOR_REVOKE 257
AUE_DOORFS_DOOR_INFO 258
AUE_DOORFS_DOOR_CRED 259
AUE_DOORFS_DOOR_BIND 260
AUE_DOORFS_DOOR_UNBIND 261
AUE_P_ONLINE 262
AUE_PROCESSOR_BIND 263
AUE_INST_SYNC 264
AUE_SOCKCONFIG 265
AUE_SETAUDIT_ADDR 266
AUE_GETAUDIT_ADDR 267
AUE_UMOUNT2 268
AUE_FSAT 269
AUE_OPENAT_R 270
AUE_OPENAT_RC 271
AUE_OPENAT_RT 272
AUE_OPENAT_RTC 273
AUE_OPENAT_W 274
AUE_OPENAT_WC 275
AUE_OPENAT_WT 276
AUE_OPENAT_WTC 277
AUE_OPENAT_RW 278
AUE_OPENAT_RWC 279
AUE_OPENAT_RWT 280
AUE_OPENAT_RWTC 281
AUE_RENAMEAT 282
AUE_FSTATAT 283
AUE_FCHOWNAT 284
AUE_FUTIMESAT 285
AUE_UNLINKAT 286
AUE_CLOCK_SETTIME 287
AUE_NTP_ADJTIME 288
AUE_SETPPRIV 289
AUE_MODDEVPLCY 290
AUE_MODADDPRIV 291
AUE_CRYPTOADM 292
AUE_CONFIGKSSL 293
AUE_BRANDSYS 294
AUE_PF_POLICY_ADDRULE 295
AUE_PF_POLICY_DELRULE 296
AUE_PF_POLICY_CLONE 297
AUE_PF_POLICY_FLIP 298
AUE_PF_POLICY_FLUSH 299
AUE_PF_POLICY_ALGS 300
AUE_PORTFS 301
AUE_DARWIN_GETFSSTAT 301
AUE_DARWIN_PTRACE 302
AUE_DARWIN_CHFLAGS 303
AUE_DARWIN_FCHFLAGS 304
AUE_DARWIN_PROFILE 305
AUE_DARWIN_KTRACE 306
AUE_DARWIN_SETLOGIN 307
AUE_DARWIN_REBOOT 308
AUE_DARWIN_REVOKE 309
AUE_DARWIN_UMASK 310
AUE_DARWIN_MPROTECT 311
AUE_DARWIN_SETPRIORITY 312
AUE_DARWIN_SETTIMEOFDAY 313
AUE_DARWIN_FLOCK 314
AUE_DARWIN_MKFIFO 315
AUE_DARWIN_POLL 316
AUE_DARWIN_SOCKETPAIR 317
AUE_DARWIN_FUTIMES 318
AUE_DARWIN_SETSID 319
AUE_DARWIN_SETPRIVEXEC 320
AUE_DARWIN_NFSSVC 321
AUE_DARWIN_GETFH 322
AUE_DARWIN_QUOTACTL 323
AUE_DARWIN_ADDPROFILE 324
AUE_DARWIN_KDEBUGTRACE 325
AUE_DARWIN_KDBUGTRACE AUE_KDEBUGTRACE
AUE_DARWIN_FSTAT 326
AUE_DARWIN_FPATHCONF 327
AUE_DARWIN_GETDIRENTRIES 328
AUE_DARWIN_TRUNCATE 329
AUE_DARWIN_FTRUNCATE 330
AUE_DARWIN_SYSCTL 331
AUE_DARWIN_MLOCK 332
AUE_DARWIN_MUNLOCK 333
AUE_DARWIN_UNDELETE 334
AUE_DARWIN_GETATTRLIST 335
AUE_DARWIN_SETATTRLIST 336
AUE_DARWIN_GETDIRENTRIESATTR 337
AUE_DARWIN_EXCHANGEDATA 338
AUE_DARWIN_SEARCHFS 339
AUE_DARWIN_MINHERIT 340
AUE_DARWIN_SEMCONFIG 341
AUE_DARWIN_SEMOPEN 342
AUE_DARWIN_SEMCLOSE 343
AUE_DARWIN_SEMUNLINK 344
AUE_DARWIN_SHMOPEN 345
AUE_DARWIN_SHMUNLINK 346
AUE_DARWIN_LOADSHFILE 347
AUE_DARWIN_RESETSHFILE 348
AUE_DARWIN_NEWSYSTEMSHREG 349
AUE_DARWIN_PTHREADKILL 350
AUE_DARWIN_PTHREADSIGMASK 351
AUE_DARWIN_AUDITCTL 352
AUE_DARWIN_RFORK 353
AUE_DARWIN_LCHMOD 354
AUE_DARWIN_SWAPOFF 355
AUE_DARWIN_INITPROCESS 356
AUE_DARWIN_MAPFD 357
AUE_DARWIN_TASKFORPID 358
AUE_DARWIN_PIDFORTASK 359
AUE_DARWIN_SYSCTL_NONADMIN 360
AUE_DARWIN_COPYFILE 361
AUE_TRACKERACTION 362
AUE_GETFSSTAT 43001
AUE_PTRACE 43002
AUE_CHFLAGS 43003
AUE_FCHFLAGS 43004
AUE_PROFILE 43005
AUE_KTRACE 43006
AUE_SETLOGIN 43007
AUE_OPENBSM_REVOKE 43008
AUE_UMASK 43009
AUE_MPROTECT 43010
AUE_MKFIFO 43011
AUE_POLL 43012
AUE_FUTIMES 43013
AUE_SETSID 43014
AUE_SETPRIVEXEC 43015
AUE_ADDPROFILE 43016
AUE_KDEBUGTRACE 43017
AUE_KDBUGTRACE AUE_KDEBUGTRACE
AUE_OPENBSM_FSTAT 43018
AUE_FPATHCONF 43019
AUE_GETDIRENTRIES 43020
AUE_SYSCTL 43021
AUE_MLOCK 43022
AUE_MUNLOCK 43023
AUE_UNDELETE 43024
AUE_GETATTRLIST 43025
AUE_SETATTRLIST 43026
AUE_GETDIRENTRIESATTR 43027
AUE_EXCHANGEDATA 43028
AUE_SEARCHFS 43029
AUE_MINHERIT 43030
AUE_SEMCONFIG 43031
AUE_SEMOPEN 43032
AUE_SEMCLOSE 43033
AUE_SEMUNLINK 43034
AUE_SHMOPEN 43035
AUE_SHMUNLINK 43036
AUE_LOADSHFILE 43037
AUE_RESETSHFILE 43038
AUE_NEWSYSTEMSHREG 43039
AUE_PTHREADKILL 43040
AUE_PTHREADSIGMASK 43041
AUE_AUDITCTL 43042
AUE_RFORK 43043
AUE_LCHMOD 43044
AUE_SWAPOFF 43045
AUE_INITPROCESS 43046
AUE_MAPFD 43047
AUE_TASKFORPID 43048
AUE_PIDFORTASK 43049
AUE_SYSCTL_NONADMIN 43050
AUE_COPYFILE 43051
AUE_LUTIMES 43052
AUE_LCHFLAGS 43053
AUE_SENDFILE 43054
AUE_USELIB 43055
AUE_GETRESUID 43056
AUE_SETRESUID 43057
AUE_GETRESGID 43058
AUE_SETRESGID 43059
AUE_WAIT4 43060
AUE_LGETFH 43061
AUE_FHSTATFS 43062
AUE_FHOPEN 43063
AUE_FHSTAT 43064
AUE_JAIL 43065
AUE_EACCESS 43066
AUE_KQUEUE 43067
AUE_KEVENT 43068
AUE_FSYNC 43069
AUE_NMOUNT 43070
AUE_BDFLUSH 43071
AUE_SETFSUID 43072
AUE_SETFSGID 43073
AUE_PERSONALITY 43074
AUE_SCHED_GETSCHEDULER 43075
AUE_SCHED_SETSCHEDULER 43076
AUE_PRCTL 43077
AUE_GETCWD 43078
AUE_CAPGET 43079
AUE_CAPSET 43080
AUE_PIVOT_ROOT 43081
AUE_RTPRIO 43082
AUE_SCHED_GETPARAM 43083
AUE_SCHED_SETPARAM 43084
AUE_SCHED_GET_PRIORITY_MAX 43085
AUE_SCHED_GET_PRIORITY_MIN 43086
AUE_SCHED_RR_GET_INTERVAL 43087
AUE_ACL_GET_FILE 43088
AUE_ACL_SET_FILE 43089
AUE_ACL_GET_FD 43090
AUE_ACL_SET_FD 43091
AUE_ACL_DELETE_FILE 43092
AUE_ACL_DELETE_FD 43093
AUE_ACL_CHECK_FILE 43094
AUE_ACL_CHECK_FD 43095
AUE_ACL_GET_LINK 43096
AUE_ACL_SET_LINK 43097
AUE_ACL_DELETE_LINK 43098
AUE_ACL_CHECK_LINK 43099
AUE_SYSARCH 43100
AUE_EXTATTRCTL 43101
AUE_EXTATTR_GET_FILE 43102
AUE_EXTATTR_SET_FILE 43103
AUE_EXTATTR_LIST_FILE 43104
AUE_EXTATTR_DELETE_FILE 43105
AUE_EXTATTR_GET_FD 43106
AUE_EXTATTR_SET_FD 43107
AUE_EXTATTR_LIST_FD 43108
AUE_EXTATTR_DELETE_FD 43109
AUE_EXTATTR_GET_LINK 43110
AUE_EXTATTR_SET_LINK 43111
AUE_EXTATTR_LIST_LINK 43112
AUE_EXTATTR_DELETE_LINK 43113
AUE_KENV 43114
AUE_JAIL_ATTACH 43115
AUE_SYSCTL_WRITE 43116
AUE_IOPERM 43117
AUE_READDIR 43118
AUE_IOPL 43119
AUE_VM86 43120
AUE_MAC_GET_PROC 43121
AUE_MAC_SET_PROC 43122
AUE_MAC_GET_FD 43123
AUE_MAC_GET_FILE 43124
AUE_MAC_SET_FD 43125
AUE_MAC_SET_FILE 43126
AUE_MAC_SYSCALL 43127
AUE_MAC_GET_PID 43128
AUE_MAC_GET_LINK 43129
AUE_MAC_SET_LINK 43130
AUE_MAC_EXECVE 43131
AUE_GETPATH_FROMFD 43132
AUE_GETPATH_FROMADDR 43133
AUE_MQ_OPEN 43134
AUE_MQ_SETATTR 43135
AUE_MQ_TIMEDRECEIVE 43136
AUE_MQ_TIMEDSEND 43137
AUE_MQ_NOTIFY 43138
AUE_MQ_UNLINK 43139
AUE_LISTEN 43140
AUE_MLOCKALL 43141
AUE_MUNLOCKALL 43142
AUE_CLOSEFROM 43143
AUE_FEXECVE 43144
AUE_FACCESSAT 43145
AUE_FCHMODAT 43146
AUE_LINKAT 43147
AUE_MKDIRAT 43148
AUE_MKFIFOAT 43149
AUE_MKNODAT 43150
AUE_READLINKAT 43151
AUE_SYMLINKAT 43152
AUE_MAC_GETFSSTAT 43153
AUE_MAC_GET_MOUNT 43154
AUE_MAC_GET_LCID 43155
AUE_MAC_GET_LCTX 43156
AUE_MAC_SET_LCTX 43157
AUE_MAC_MOUNT 43158
AUE_GETLCID 43159
AUE_SETLCID 43160
AUE_TASKNAMEFORPID 43161
AUE_ACCESS_EXTENDED 43162
AUE_CHMOD_EXTENDED 43163
AUE_FCHMOD_EXTENDED 43164
AUE_FSTAT_EXTENDED 43165
AUE_LSTAT_EXTENDED 43166
AUE_MKDIR_EXTENDED 43167
AUE_MKFIFO_EXTENDED 43168
AUE_OPEN_EXTENDED 43169
AUE_OPEN_EXTENDED_R 43170
AUE_OPEN_EXTENDED_RC 43171
AUE_OPEN_EXTENDED_RT 43172
AUE_OPEN_EXTENDED_RTC 43173
AUE_OPEN_EXTENDED_W 43174
AUE_OPEN_EXTENDED_WC 43175
AUE_OPEN_EXTENDED_WT 43176
AUE_OPEN_EXTENDED_WTC 43177
AUE_OPEN_EXTENDED_RW 43178
AUE_OPEN_EXTENDED_RWC 43179
AUE_OPEN_EXTENDED_RWT 43180
AUE_OPEN_EXTENDED_RWTC 43181
AUE_STAT_EXTENDED 43182
AUE_UMASK_EXTENDED 43183
AUE_OPENAT 43184
AUE_POSIX_OPENPT 43185
AUE_CAP_NEW 43186
AUE_CAP_GETRIGHTS 43187
AUE_CAP_ENTER 43188
AUE_CAP_GETMODE 43189
AUE_POSIX_SPAWN 43190
AUE_FSGETPATH 43191
AUE_PREAD 43192
AUE_PWRITE 43193
AUE_FSCTL 43194
AUE_FFSCTL 43195
AUE_LPATHCONF 43196
AUE_PDFORK 43197
AUE_PDKILL 43198
AUE_PDGETPID 43199
AUE_PDWAIT 43200
AUE_GETATTRLISTBULK 43201
AUE_GETATTRLISTAT 43202
AUE_OPENBYID 43203
AUE_OPENBYID_R 43204
AUE_OPENBYID_RT 43205
AUE_OPENBYID_W 43206
AUE_OPENBYID_WT 43207
AUE_OPENBYID_RW 43208
AUE_OPENBYID_RWT 43209
AUE_CLONEFILEAT 43210
AUE_FCLONEFILEAT 43211
AUE_SETATTRLISTAT 43212
AUE_FMOUNT 43213
AUE_FSGETPATH_EXTENDED 43214
AUE_DBGPORTFORPID 43215
AUE_PREADV 43216
AUE_PWRITEV 43217
AUE_FREADLINK 43218
AUE_SESSION_START 44901
AUE_SESSION_UPDATE 44902
AUE_SESSION_END 44903
AUE_SESSION_CLOSE 44904
AUE_O_CREAT AUE_OPEN_RWTC
AUE_O_EXECVE AUE_NULL
AUE_O_SBREAK AUE_NULL
AUE_O_LSEEK AUE_NULL
AUE_O_MOUNT AUE_NULL
AUE_O_UMOUNT AUE_NULL
AUE_O_STAT AUE_STAT
AUE_O_LSTAT AUE_LSTAT
AUE_O_FSTAT AUE_FSTAT
AUE_O_GETPAGESIZE AUE_NULL
AUE_O_VREAD AUE_NULL
AUE_O_VWRITE AUE_NULL
AUE_O_MMAP AUE_MMAP
AUE_O_VADVISE AUE_NULL
AUE_O_VHANGUP AUE_NULL
AUE_O_VLIMIT AUE_NULL
AUE_O_WAIT AUE_NULL
AUE_O_GETHOSTNAME AUE_NULL
AUE_O_SETHOSTNAME AUE_SYSCTL
AUE_O_GETDOPT AUE_NULL
AUE_O_SETDOPT AUE_NULL
AUE_O_ACCEPT AUE_NULL
AUE_O_SEND AUE_SENDMSG
AUE_O_RECV AUE_RECVMSG
AUE_O_VTIMES AUE_NULL
AUE_O_SIGVEC AUE_NULL
AUE_O_SIGBLOCK AUE_NULL
AUE_O_SIGSETMASK AUE_NULL
AUE_O_SIGSTACK AUE_NULL
AUE_O_RECVMSG AUE_RECVMSG
AUE_O_SENDMSG AUE_SENDMSG
AUE_O_VTRACE AUE_NULL
AUE_O_RESUBA AUE_NULL
AUE_O_RECVFROM AUE_RECVFROM
AUE_O_SETREUID AUE_SETREUID
AUE_O_SETREGID AUE_SETREGID
AUE_O_GETDIRENTRIES AUE_GETDIRENTRIES
AUE_O_TRUNCATE AUE_TRUNCATE
AUE_O_FTRUNCATE AUE_FTRUNCATE
AUE_O_GETPEERNAME AUE_NULL
AUE_O_GETHOSTID AUE_NULL
AUE_O_SETHOSTID AUE_NULL
AUE_O_GETRLIMIT AUE_NULL
AUE_O_SETRLIMIT AUE_SETRLIMIT
AUE_O_KILLPG AUE_KILL
AUE_O_SETQUOTA AUE_NULL
AUE_O_QUOTA AUE_NULL
AUE_O_GETSOCKNAME AUE_NULL
AUE_O_GETDIREENTRIES AUE_GETDIREENTRIES
AUE_O_ASYNCDAEMON AUE_NULL
AUE_O_GETDOMAINNAME AUE_NULL
AUE_O_SETDOMAINNAME AUE_SYSCTL
AUE_O_PCFS_MOUNT AUE_NULL
AUE_O_EXPORTFS AUE_NULL
AUE_O_USTATE AUE_NULL
AUE_O_WAIT3 AUE_NULL
AUE_O_RPAUSE AUE_NULL
AUE_O_GETDENTS AUE_NULL
AUE_ATGETMSG AUE_NULL
AUE_ATPUTMSG AUE_NULL
AUE_ATSOCKET AUE_NULL
AUE_ATPGETREQ AUE_NULL
AUE_ATPGETRSP AUE_NULL
AUE_ATPSNDREQ AUE_NULL
AUE_ATPSNDRSP AUE_NULL
AUE_BSDTHREADCREATE AUE_NULL
AUE_BSDTHREADTERMINATE AUE_NULL
AUE_BSDTHREADREGISTER AUE_NULL
AUE_CSOPS AUE_NULL
AUE_DUP AUE_NULL
AUE_FDATASYNC AUE_NULL
AUE_FGETATTRLIST AUE_NULL
AUE_FGETXATTR AUE_NULL
AUE_FLISTXATTR AUE_NULL
AUE_FREMOVEXATTR AUE_NULL
AUE_FSETATTRLIST AUE_NULL
AUE_FSETXATTR AUE_NULL
AUE_FSTATFS64 AUE_NULL
AUE_FSTATV AUE_NULL
AUE_FSTAT64 AUE_NULL
AUE_FSTAT64_EXTENDED AUE_NULL
AUE_GCCONTROL AUE_NULL
AUE_GETDIRENTRIES64 AUE_NULL
AUE_GETDTABLESIZE AUE_NULL
AUE_GETEGID AUE_NULL
AUE_GETEUID AUE_NULL
AUE_GETFSSTAT64 AUE_NULL
AUE_GETGID AUE_NULL
AUE_GETGROUPS AUE_NULL
AUE_GETITIMER AUE_NULL
AUE_GETLOGIN AUE_NULL
AUE_GETPEERNAME AUE_NULL
AUE_GETPGID AUE_NULL
AUE_GETPGRP AUE_NULL
AUE_GETPID AUE_NULL
AUE_GETPPID AUE_NULL
AUE_GETPRIORITY AUE_NULL
AUE_GETRLIMIT AUE_NULL
AUE_GETRUSAGE AUE_NULL
AUE_GETSGROUPS AUE_NULL
AUE_GETSID AUE_NULL
AUE_GETSOCKNAME AUE_NULL
AUE_GETTIMEOFDAY AUE_NULL
AUE_GETTID AUE_NULL
AUE_GETUID AUE_NULL
AUE_GETSOCKOPT AUE_NULL
AUE_GETWGROUPS AUE_NULL
AUE_GETXATTR AUE_NULL
AUE_IDENTITYSVC AUE_NULL
AUE_INITGROUPS AUE_NULL
AUE_IOPOLICYSYS AUE_NULL
AUE_ISSETUGID AUE_NULL
AUE_LEDGER AUE_NULL
AUE_LIOLISTIO AUE_NULL
AUE_LISTXATTR AUE_NULL
AUE_LSTATV AUE_NULL
AUE_LSTAT64 AUE_NULL
AUE_LSTAT64_EXTENDED AUE_NULL
AUE_MADVISE AUE_NULL
AUE_MINCORE AUE_NULL
AUE_MKCOMPLEX AUE_NULL
AUE_MSGCL AUE_NULL
AUE_MSYNC AUE_NULL
AUE_NECP AUE_NULL
AUE_NETAGENT AUE_NULL
AUE_PROCINFO AUE_NULL
AUE_PTHREADCANCELED AUE_NULL
AUE_PTHREADCHDIR AUE_NULL
AUE_PTHREADCONDBROADCAST AUE_NULL
AUE_PTHREADCONDDESTORY AUE_NULL
AUE_PTHREADCONDINIT AUE_NULL
AUE_PTHREADCONDSIGNAL AUE_NULL
AUE_PTHREADCONDWAIT AUE_NULL
AUE_PTHREADFCHDIR AUE_NULL
AUE_PTHREADMARK AUE_NULL
AUE_PTHREADMUTEXDESTROY AUE_NULL
AUE_PTHREADMUTEXINIT AUE_NULL
AUE_PTHREADMUTEXTRYLOCK AUE_NULL
AUE_PTHREADMUTEXUNLOCK AUE_NULL
AUE_REMOVEXATTR AUE_NULL
AUE_SBRK AUE_NULL
AUE_SELECT AUE_NULL
AUE_SEMDESTROY AUE_NULL
AUE_SEMGETVALUE AUE_NULL
AUE_SEMINIT AUE_NULL
AUE_SEMPOST AUE_NULL
AUE_SEMTRYWAIT AUE_NULL
AUE_SEMWAIT AUE_NULL
AUE_SEMWAITSIGNAL AUE_NULL
AUE_SETITIMER AUE_NULL
AUE_SETSGROUPS AUE_NULL
AUE_SETTID AUE_NULL
AUE_SETTIDWITHPID AUE_NULL
AUE_SETWGROUPS AUE_NULL
AUE_SETXATTR AUE_NULL
AUE_SHAREDREGIONCHECK AUE_NULL
AUE_SHAREDREGIONMAP AUE_NULL
AUE_SIGACTION AUE_NULL
AUE_SIGALTSTACK AUE_NULL
AUE_SIGPENDING AUE_NULL
AUE_SIGPROCMASK AUE_NULL
AUE_SIGRETURN AUE_NULL
AUE_SIGSUSPEND AUE_NULL
AUE_SIGWAIT AUE_NULL
AUE_SSTK AUE_NULL
AUE_STACKSNAPSHOT AUE_NULL
AUE_STATFS64 AUE_NULL
AUE_STATV AUE_NULL
AUE_STAT64 AUE_NULL
AUE_STAT64_EXTENDED AUE_NULL
AUE_SYNC AUE_NULL
AUE_SYSCALL AUE_NULL
AUE_TABLE AUE_NULL
AUE_VMPRESSUREMONITOR AUE_NULL
AUE_WAITID AUE_NULL
AUE_WORKQOPEN AUE_NULL
AUE_WORKQOPS AUE_NULL
AUE_WORKLOOPCTL AUE_NULL
AUE_PERSONA AUE_NULL
AUE_USRCTL AUE_NULL
AUE_NEXUS AUE_NULL
AUE_CHANNEL AUE_NULL
AUE_NET AUE_NULL
AUE_TASKREADFORPID AUE_NULL
AUE_TASKINSPECTFORPID AUE_NULL
AUE_DEBUG_SYSCALL_REJECT AUE_NULL
AUE_DEBUG_SYSCALL_REJECT_CONFIG AUE_NULL
_BSM_AUDIT_RECORD_H_ None
AUT_INVALID 0x00
AUT_OTHER_FILE32 0x11
AUT_OHEADER 0x12
AUT_TRAILER 0x13
AUT_HEADER32 0x14
AUT_HEADER32_EX 0x15
AUT_DATA 0x21
AUT_IPC 0x22
AUT_PATH 0x23
AUT_SUBJECT32 0x24
AUT_XATPATH 0x25
AUT_PROCESS32 0x26
AUT_RETURN32 0x27
AUT_TEXT 0x28
AUT_OPAQUE 0x29
AUT_IN_ADDR 0x2a
AUT_IP 0x2b
AUT_IPORT 0x2c
AUT_ARG32 0x2d
AUT_SOCKET 0x2e
AUT_SEQ 0x2f
AUT_ACL 0x30
AUT_ATTR 0x31
AUT_IPC_PERM 0x32
AUT_LABEL 0x33
AUT_GROUPS 0x34
AUT_ACE 0x35
AUT_PRIV 0x38
AUT_UPRIV 0x39
AUT_LIAISON 0x3a
AUT_NEWGROUPS 0x3b
AUT_EXEC_ARGS 0x3c
AUT_EXEC_ENV 0x3d
AUT_ATTR32 0x3e
AUT_UNAUTH 0x3f
AUT_XATOM 0x40
AUT_XOBJ 0x41
AUT_XPROTO 0x42
AUT_XSELECT 0x43
AUT_XCOLORMAP 0x44
AUT_XCURSOR 0x45
AUT_XFONT 0x46
AUT_XGC 0x47
AUT_XPIXMAP 0x48
AUT_XPROPERTY 0x49
AUT_XWINDOW 0x4a
AUT_XCLIENT 0x4b
AUT_CMD 0x51
AUT_EXIT 0x52
AUT_ZONENAME 0x60
AUT_HOST 0x70
AUT_ARG64 0x71
AUT_RETURN64 0x72
AUT_ATTR64 0x73
AUT_HEADER64 0x74
AUT_SUBJECT64 0x75
AUT_PROCESS64 0x77
AUT_OTHER_FILE64 0x78
AUT_HEADER64_EX 0x79
AUT_SUBJECT32_EX 0x7a
AUT_PROCESS32_EX 0x7b
AUT_SUBJECT64_EX 0x7c
AUT_PROCESS64_EX 0x7d
AUT_IN_ADDR_EX 0x7e
AUT_SOCKET_EX 0x7f
AUT_HEADER AUT_HEADER32
AUT_ARG AUT_ARG32
AUT_RETURN AUT_RETURN32
AUT_SUBJECT AUT_SUBJECT32
AUT_PROCESS AUT_PROCESS32
AUT_OTHER_FILE AUT_OTHER_FILE32
AUT_SOCKINET32 0x80
AUT_SOCKINET128 0x81
AUT_SOCKUNIX 0x82
AUT_IDENTITY 0xed
AUT_KRB5_PRINCIPAL 0xee
AUT_CERT_HASH 0xef
AUP_BINARY 0
AUP_OCTAL 1
AUP_DECIMAL 2
AUP_HEX 3
AUP_STRING 4
AUR_BYTE 0
AUR_CHAR AUR_BYTE
AUR_SHORT 1
AUR_INT32 2
AUR_INT AUR_INT32
AUR_INT64 3
AUR_BYTE_SIZE sizeof(u_char)
AUR_CHAR_SIZE AUR_BYTE_SIZE
AUR_SHORT_SIZE sizeof(uint16_t)
AUR_INT32_SIZE sizeof(uint32_t)
AUR_INT_SIZE AUR_INT32_SIZE
AUR_INT64_SIZE sizeof(uint64_t)
PAD_NOTATTR 0x4000
PAD_FAILURE 0x8000
AUDIT_MAX_GROUPS 16
AUDIT_HEADER_VERSION_OLDDARWIN 1
AUDIT_HEADER_VERSION_SOLARIS 2
AUDIT_HEADER_VERSION_TSOL25 3
AUDIT_HEADER_VERSION_TSOL 4
AUDIT_HEADER_VERSION_OPENBSM10 10
AUDIT_HEADER_VERSION_OPENBSM11 11
AUDIT_HEADER_VERSION_OPENBSM AUDIT_HEADER_VERSION_OPENBSM11
AUT_TRAILER_MAGIC 0xb105
_BSM_AUDIT_SOCKET_TYPE_H_ None
BSM_SOCK_DGRAM 1
BSM_SOCK_STREAM 2
BSM_SOCK_RAW 4
BSM_SOCK_RDM 5
BSM_SOCK_SEQPACKET 6
BSM_SOCK_UNKNOWN 500
HNPROC 2500
_BSD_DEV_KMREG_COM_ None
KM_COLOR_WHITE 0
KM_COLOR_LTGRAY 1
KM_COLOR_DKGRAY 2
KM_COLOR_BLACK 3
KMIOCPOPUP _IO('k', 1)
KMIOCRESTORE _IO('k', 2)
KMIOCDUMPLOG _IO('k', 3)
KMIOCDRAWRECT _IOW('k', 5, struct km_drawrect)
KMIOCERASERECT _IOW('k', 6, struct km_drawrect)
KMIOCDISABLCONS _IO('k', 8)
KMIOCANIMCTL _IOW('k',9, km_anim_ctl_t)
KMIOCSTATUS _IOR('k',10, int)
KMIOCSIZE _IOR('k',11, struct winsize)
KMS_SEE_MSGS 0x00000001
_BSD_DEV_LDD_PRIV_ None
mdInited 0x01
mdRO 0x02
mdPhys 0x04
_SYS_MEMDEV_H_ None
MT_NODE "monotonic"
MT_SYSCTL(NAME, ARG, FLAGS, SIZE, SIZESTR, DESC)     SYSCTL_PROC(_kern_monotonic, OID_AUTO, NAME,     CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED | (FLAGS),     (void *)(ARG), SIZE, mt_sysctl, SIZESTR, DESC)
_MACHINE_DISKLABEL_H_ None
_DIS_TABLES_H None
SIZE16 1
SIZE32 2
SIZE64 3
OPLEN 256
PFIXLEN 8
NCPS 20
DIS_F_OCTAL 0x1
DIS_F_NOIMMSYM 0x2
_I386__ENDIAN_H_ None
_I386_FASTTRAP_ISA_H None
_FASTTRAP_ISA_H None
_I386_LIMITS_H_ None
_I386_PARAM_H_ None
_BSD_I386_PROFILE_H_ None
_BSD_I386_PSL_H_ None
PSL_ALLCC EFL_ALLCC
PSL_T EFL_TF
_BSD_I386_REG_H_ None
_I386_SIGNAL_H_ 1
_I386_MACHTYPES_H_ None
_MACHTYPES_H_ None
_BSD_I386_VMPARAM_H_ 1
_I386___ENDIAN_H_ None
_I386__LIMITS_H_ None
__I386_MCONTEXT_H_ None
_I386__PARAM_H_ None
_BSD_I386__TYPES_H_ None
_KERN_AST_H_ None
AST_KEVENT_RETURN_TO_KERNEL 0x0001
AST_KEVENT_REDRIVE_THREADREQ 0x0002
AST_KEVENT_WORKQ_QUANTUM_EXPIRED 0x0004
RAMDEV "md0"
DEBUG_BSDINIT 0
bsd_init_kprintf(x, ...) kprintf("bsd_init: " x, ## __VA_ARGS__)
AUTHDBG(fmt, args...) do { printf("%s: " fmt "\n", __func__, ##args); } while (0)
AUTHPRNT(fmt, args...) do { printf("%s: " fmt "\n", __func__, ##args); } while (0)
_CHUNKLIST_H None
CHUNKLIST_MAGIC 0x4C4B4E43
CHUNKLIST_FILE_VERSION_10 1
CHUNKLIST_CHUNK_METHOD_10 1
CHUNKLIST_SIGNATURE_METHOD_REV1 1
CHUNKLIST_REV1_SIG_LEN 256
DEBUG_IMAGEBOOT 0
DBG_TRACE(...) printf("imageboot: " __VA_ARGS__)
AUTHDBG(fmt, args...) do { printf("%s: " fmt "\n", __func__, ##args); } while (0)
AUTHPRNT(fmt, args...) do { printf("%s: " fmt "\n", __func__, ##args); } while (0)
kIBFilePrefix "file://"
PIVOTMNT "/System/Volumes/BaseSystem"
TYPEFILTER_ALLOC_SIZE MAX(round_page_32(KDBG_TYPEFILTER_BITMAP_SIZE), KDBG_TYPEFILTER_BITMAP_SIZE)
TRACE_KDCOPYBUF_COUNT 8192
RAW_VERSION3 0x00001000
V3_RAW_EVENTS 0x00001e00
TRIAGE_KDCOPYBUF_COUNT 128
ACCT_SUBSYS_LOCK() lck_mtx_lock(&acct_subsys_mutex)
ACCT_SUBSYS_UNLOCK() lck_mtx_unlock(&acct_subsys_mutex)
MANTSIZE 13
EXPSIZE 3
AIO_work_queued 1
AIO_worker_wake 2
AIO_completion_sig 3
AIO_completion_cleanup_wait 4
AIO_completion_cleanup_wake 5
AIO_completion_suspend_wake 6
AIO_fsync_delay 7
AIO_cancel 10
AIO_cancel_async_workq 11
AIO_cancel_sync_workq 12
AIO_cancel_activeq 13
AIO_cancel_doneq 14
AIO_fsync 20
AIO_read 30
AIO_write 40
AIO_listio 50
AIO_error 60
AIO_error_val 61
AIO_error_activeq 62
AIO_error_workq 63
AIO_return 70
AIO_return_val 71
AIO_return_activeq 72
AIO_return_workq 73
AIO_exec 80
AIO_exit 90
AIO_exit_sleep 91
AIO_close 100
AIO_close_sleep 101
AIO_suspend 110
AIO_suspend_sleep 111
AIO_worker_thread 120
AIO_NUM_WORK_QUEUES 1
AIO_SUSPEND_SLEEP_CHAN p_aio_activeq
AIO_CLEANUP_SLEEP_CHAN p_aio_total_count
ASSERT_AIO_FROM_PROC(aiop, theproc)     	if ((aiop)->procp != (theproc)) {       	        panic("AIO on a proc list that does not belong to that proc."); 	}
ASSERT_AIO_PROC_LOCK_OWNED(p) LCK_MTX_ASSERT(aio_proc_mutex(p), LCK_MTX_ASSERT_OWNED)
ASSERT_AIO_WORKQ_LOCK_OWNED(q) LCK_SPIN_ASSERT(aio_workq_lock(q), LCK_ASSERT_OWNED)
KAUTH_SCOPELOCK() lck_mtx_lock(&kauth_scope_mtx);
KAUTH_SCOPEUNLOCK() lck_mtx_unlock(&kauth_scope_mtx);
KAUTH_SCOPE_MAX_LISTENERS 15
ROUNDUP64(x) P2ROUNDUP((x), sizeof (u_int64_t))
ADVANCE64(p, n) (void*)((char *)(p) + ROUNDUP64(n))
KCTL_TBL_INC 16
KCTLREF_INDEX_MASK 0x0000FFFF
KCTLREF_GENCNT_MASK 0xFFFF0000
KCTLREF_GENCNT_SHIFT 16
MACH_ASSERT 1
KAUTH_CRED_REF_MAX 0x0ffffffful
FD_DUP2RESV 1
f_flag fp_glob->fg_flag
f_type fp_glob->fg_ops->fo_type
f_cred fp_glob->fg_cred
f_ops fp_glob->fg_ops
f_offset fp_glob->fg_offset
APFSIOC_REVERT_TO_SNAPSHOT _IOW('J', 1, u_int64_t)
APFSIOC_IS_GRAFT_SUPPORTED _IO('J', 133)
CHECK_ADD_OVERFLOW_INT64L(x, y) 	        (((((x) > 0) && ((y) > 0) && ((x) > LLONG_MAX - (y))) || 	        (((x) < 0) && ((y) < 0) && ((x) < LLONG_MIN - (y)))) 	        ? 1 : 0)
ACCOUNT_OPENFROM_ENTITLEMENT "com.apple.private.vfs.role-account-openfrom"
SYS_FCNTL_DECLARE_VFS_CONTEXT(context) struct vfs_context context = { 	    .vc_thread = current_thread(), 	    .vc_ucred = fp->f_cred, 	}
STK_PARAMS 128
KEV_EVTID(code) BSDDBG_CODE(DBG_BSD_KEVENT, (code))
KQUEUE_THREADREQ_UNBIND_SOFT 0x1
KN_HASH(val, mask)      (((val) ^ (val >> 8)) & (mask))
knote_assert_aliases(name1, offs1, name2) 	static_assert(offsetof(struct kevent_qos_s, name1) + offs1 == 	    offsetof(struct kevent_internal_s, name2), 	        "kevent_qos_s::" #name1 " and kevent_internal_s::" #name2 "need to alias")
f_flag fp_glob->fg_flag
f_ops fp_glob->fg_ops
f_lflags fp_glob->fg_lflags
TIMER_IDLE 0x0
TIMER_ARMED 0x1
TIMER_FIRED 0x2
TIMER_IMMEDIATE 0x3
TIMER_STATE_MASK 0x3
TIMER_GEN_INC 0x4
EVFILT_WORKLOOP_EFAULT_RETRY_COUNT 100
FILT_WLATTACH 0
FILT_WLTOUCH 1
FILT_WLDROP 2
KQ_HASH(val, mask)  (((val) ^ (val >> 8)) & (mask))
CONFIG_KQ_HASHSIZE CONFIG_KN_HASHSIZE
KQWQAE_BEGIN_PROCESSING 1
KQWQAE_END_PROCESSING 2
KQWQAE_UNBIND 3
MAX_NESTED_KQ 10
ROUNDUP64(x) P2ROUNDUP((x), sizeof (u_int64_t))
ADVANCE64(p, n) (void*)((char *)(p) + ROUNDUP64(n))
USERSPACE_COREDUMP_PANIC_ENTITLEMENT "com.apple.private.enable-coredump-on-panic"
USERSPACE_COREDUMP_PANIC_SEED_ENTITLEMENT "com.apple.private.enable-coredump-on-panic-seed-privacy-approved"
EAI_ITERLIMIT 3
USER_ADDR_ALIGN(addr, val) 	( ( (user_addr_t)(addr) + (val) - 1) 	        & ~((val) - 1) )
SPAWN_SUBSYSTEM_ROOT_ENTITLEMENT "com.apple.private.spawn-subsystem-root"
SPAWN_SET_PANIC_CRASH_BEHAVIOR "com.apple.private.spawn-panic-crash-behavior"
SPAWN_ENABLE_HARDENED_PROCESS "com.apple.developer.hardened-process"
SPAWN_ENABLE_HARDENED_HEAP "com.apple.developer.hardened-process.hardened-heap"
EXECUTABLE_KEY "executable_path="
MIN_IOS_TPRO_SDK_VERSION 0x00100000
MIN_OSX_TPRO_SDK_VERSION 0x000D0000
MIN_TVOS_TPRO_SDK_VERSION 0x000D0000
MIN_WATCHOS_TPRO_SDK_VERSION 0x00090000
MIN_DRIVERKIT_TPRO_SDK_VERSION 0x00600000
SINGLE_JIT_ENTITLEMENT "com.apple.security.cs.single-jit"
GUARD_VALUES 1
GUARD_KEY "stack_guard="
ENTROPY_VALUES 2
ENTROPY_KEY "malloc_entropy="
PTR_MUNGE_VALUES 1
PTR_MUNGE_KEY "ptr_munge="
NANO_ENGAGE_KEY "MallocNanoZone=1"
LIBMALLOC_EXPERIMENT_FACTORS_KEY "MallocExperiment="
HARDENED_RUNTIME_KEY "HardenedRuntime="
PFZ_KEY "pfz="
MAIN_STACK_VALUES 4
MAIN_STACK_KEY "main_stack="
FSID_KEY "executable_file="
DYLD_FSID_KEY "dyld_file="
CDHASH_KEY "executable_cdhash="
DYLD_FLAGS_KEY "dyld_flags="
SUBSYSTEM_ROOT_PATH_KEY "subsystem_root_path="
APP_BOOT_SESSION_KEY "executable_boothash="
MAIN_TH_PORT_KEY "th_port="
FSID_MAX_STRING "0x1234567890abcdef,0x1234567890abcdef"
HEX_STR_LEN 18
HEX_STR_LEN32 10
PREVENT_CALLER_STACK_USE __attribute__((noinline))
FIXED_76621401 0
_KERN_EXEC_INTERNAL_H_ None
OS_REASON_IFLAG_USER_FAULT 0x1
OS_REASON_TOTAL_USER_FAULTS_PER_PROC 5
f_flag fp_glob->fg_flag
KTRACE_ALLOW_ENTITLEMENT "com.apple.private.ktrace-allow"
SELF 0x1
OTHERS 0x2
OFF_MAX 0x7fffffffffffffffULL
MEMORYSTATUS_CLEAR_THE_DECKS_OFFSET_PERCENTAGE 5UL
MEMORYSTATUS_BALLAST_OFFSET_PERCENTAGE 5UL
MEMORYSTATUS_AGGR_SYSPROC_AGING_PERCENTAGE 7UL
MEMORYSTATUS_DELTA_PERCENTAGE_LARGE 4UL
MEMORYSTATUS_DELTA_PERCENTAGE_SMALL 5UL
MEMORYSTATUS_CRITICAL_PERCENTAGE_SMALL 5UL
MEMORYSTATUS_CRITICAL_PERCENTAGE_LARGE 4UL
MEMORYSTATUS_IDLE_RATIO_NUM 2UL
MEMORYSTATUS_IDLE_RATIO_DENOM 1UL
MEMORYSTATUS_PRESSURE_RATIO_NUM 3UL
MEMORYSTATUS_PRESSURE_RATIO_DENOM 1UL
MEMORYSTATUS_REAPER_RATIO_NUM 4UL
MEMORYSTATUS_REAPER_RATIO_DENOM 1UL
MEMORYSTATUS_REAPER_MIN_AGE_SECS_DEFAULT 300
MEMORYSTATUS_REAPER_MAX_PRIORITY_DEFAULT JETSAM_PRIORITY_IDLE
MEMORYSTATUS_REAPER_RESCAN_SECS_DEFAULT 300
MEMORYSTATUS_REAPER_SENTINAL_VALUE_MEANING_USE_DEFAULT -1
MEMORYSTATUS_IDLE_RATIO_NUM_MEDIUM 9UL
MEMORYSTATUS_IDLE_RATIO_DENOM_MEDIUM 4UL
MEMORYSTATUS_PRESSURE_RATIO_NUM_MEDIUM 15UL
MEMORYSTATUS_PRESSURE_RATIO_DENOM_MEDIUM 4UL
MEMORYSTATUS_REAPER_RATIO_NUM_MEDIUM 18UL
MEMORYSTATUS_REAPER_RATIO_DENOM_MEDIUM 4UL
JETSAM_SNAPSHOT_FREEZER_MAX_FACTOR 20
MEMORYSTATUS_FREEZE_THRESHOLD_PERCENTAGE 50UL
CONFIG_SEPARATE_BINCOMPAT_ENTITLED_MEMLIMIT XNU_TARGET_OS_XR
AGGRESSIVE_JETSAM_LENIENT_MODE_THRESHOLD 25
MEMSTAT_OLDEST_REAPABLE_PROC_PRIO_START_UNKNOWN UINT64_MAX
JETSAM_THREADS_LIMIT 3
MEMORYSTATUS_VM_MAP_FORK_ALLOWED 0x100000000
MEMORYSTATUS_VM_MAP_FORK_NOT_ALLOWED 0x200000000
MAX_SORT_PIDS 80
MAX_COAL_LEADERS 10
FREEZE_APPS_IDLE_DELAY_MULTIPLIER_FAST 1
FREEZE_APPS_IDLE_DELAY_MULTIPLIER_SLOW 30
FREEZE_APPS_IDLE_DELAY_MULTIPLIER_DEFAULT FREEZE_APPS_IDLE_DELAY_MULTIPLIER_FAST
MAX_XPC_SERVICE_PIDS 10
FREEZER_ERROR_STRING_LENGTH 128
_KERN_MEMORYSTATUS_INTERNAL_H_ None
VM_PAGE_DONATE_DISABLED 0
VM_PAGE_DONATE_ENABLED 1
_memorystatus_log_with_type(type, format, ...) os_log_with_startup_serial_and_type(memorystatus_log_handle, type, format, ##__VA_ARGS__)
memorystatus_log(format, ...) _memorystatus_log_with_type(OS_LOG_TYPE_DEFAULT, format, ##__VA_ARGS__)
memorystatus_log_info(format, ...) if (memorystatus_log_level >= MEMORYSTATUS_LOG_LEVEL_INFO) { _memorystatus_log_with_type(OS_LOG_TYPE_INFO, format, ##__VA_ARGS__); }
memorystatus_log_debug(format, ...) if (memorystatus_log_level >= MEMORYSTATUS_LOG_LEVEL_DEBUG) { _memorystatus_log_with_type(OS_LOG_TYPE_DEBUG, format, ##__VA_ARGS__); }
memorystatus_log_error(format, ...) _memorystatus_log_with_type(OS_LOG_TYPE_ERROR, format, ##__VA_ARGS__)
memorystatus_log_fault(format, ...) _memorystatus_log_with_type(OS_LOG_TYPE_FAULT, format, ##__VA_ARGS__)
VM_PRESSURE_DECREASED_SMOOTHING_PERIOD 5000
WARNING_NOTIFICATION_RESTING_PERIOD 25
CRITICAL_NOTIFICATION_RESTING_PERIOD 25
MAX(a, b) (a >= b ? a : b)
SYSCTL_RETURN(r, x)     SYSCTL_OUT(r, &x, sizeof(x))
BSD_HOST 1
HW_LOCAL_FREQUENCY 1
HW_LOCAL_FREQUENCY_MIN 2
HW_LOCAL_FREQUENCY_MAX 3
HW_LOCAL_FREQUENCY_CLOCK_RATE 4
ARM_FEATURE_FLAG(flag_name) SECURITY_READ_ONLY_LATE(int) gARM_ ## flag_name = 0; 	SYSCTL_INT(_hw_optional_arm, OID_AUTO, flag_name, CTLFLAG_RD | CTLFLAG_KERN | CTLFLAG_LOCKED, &gARM_ ## flag_name, 0, "")
LEGACY_ARM_SYSCTL(legacy_name, flag_name) 	SYSCTL_INT(_hw_optional, OID_AUTO, legacy_name, CTLFLAG_RD | CTLFLAG_KERN | CTLFLAG_LOCKED, &gARM_ ## flag_name, 0, "")
CAP_DO_SET_BIT(n) { 	        assert((n) < CAP_BIT_NB); 	        const uint32_t word_id = ((uint32_t) (n)) >> 3; 	        assert(word_id < CAP_BYTE_NB); 	        const uint8_t bit_id = ((uint32_t) (n)) & 0x7; 	        feats[word_id] |= ((uint8_t) 1) << bit_id; 	}
CAP_SET_BIT_(var, name) 	if (var) { 	        CAP_DO_SET_BIT(CAP_BIT_##name); 	}
CAP_SET_BIT(name) CAP_SET_BIT_(gARM_##name, name)
CAP_SET_FIELD(name, val) { 	        const uint32_t start = CAP_BIT_##name; 	        const uint32_t end = start + CAP_BIT_##name##_LEN; 	        uint32_t src = CAP_BIT_##name##_##val; 	        for (uint32_t id = start; id < end; id++) { 	                if (src & 1) { 	                        CAP_DO_SET_BIT(id); 	                } 	                src >>= 1; 	        } 	}
ARM_FEATURE_FLAG(x) CAP_SET_BIT(x)
SYSCTL_OID_FOREACH_NUM_ORDER(oidp, l) 	for (struct sysctl_oid_iterator it = sysctl_oid_iterator_begin(l); 	        ((oidp) = sysctl_oid_iterator_next_num_order(&it)); )
SYSCTL_OID_FOREACH_SYS_ORDER(oidp, l) 	for (struct sysctl_oid_iterator it = sysctl_oid_iterator_begin(l); 	        ((oidp) = sysctl_oid_iterator_next_system_order(&it)); )
WRITE_EXPERIMENT_FACTORS_ENTITLEMENT "com.apple.private.write-kr-experiment-factors"
X(name, T) int experiment_factor_##name##_handler SYSCTL_HANDLER_ARGS { 	int error, changed = 0; 	T *ptr; 	T new_value, current_value; 	struct experiment_spec *spec = (struct experiment_spec *) arg1; 	if (!arg1) { 	        return EINVAL; 	} 	ptr = (T *)(spec->ptr); 	current_value = *ptr; 	error = sysctl_io_number(req, current_value, sizeof(T), &new_value, &changed); 	if (error != 0) { 	        return error; 	} 	if (changed) { 	        if (new_value < (T) spec->min_value || new_value > (T) spec->max_value) { 	                return EINVAL; 	        } 	        if (os_atomic_cmpxchg(&spec->modified, false, true, acq_rel)) { 	                spec->original_value = current_value; 	        } 	        os_atomic_store_wide(ptr, new_value, relaxed); 	} 	return 0; }
L_ADD(v, u)     ((v) += (u))
L_SUB(v, u)     ((v) -= (u))
L_ADDHI(v, a)   ((v) += (int64_t)(a) << 32)
L_RSHIFT(v, n) 	do { 	        if ((v) < 0) 	                (v) = -(-(v) >> (n)); 	        else 	                (v) = (v) >> (n); 	} while (0)
L_MPY(v, a)     ((v) *= (a))
L_LINT(v, a) 	do { 	        if ((a) > 0) 	                ((v) = (int64_t)(a) << 32); 	        else 	                ((v) = -((int64_t)(-(a)) << 32)); 	} while (0)
SHIFT_PLL 4
SHIFT_FLL 2
NTP_LOCK(enable) enable =  ml_set_interrupts_enabled(FALSE); 	        lck_spin_lock(&ntp_lock);
NTP_UNLOCK(enable) lck_spin_unlock(&ntp_lock);	        ml_set_interrupts_enabled(enable);
NTP_ASSERT_LOCKED() LCK_SPIN_ASSERT(&ntp_lock, LCK_ASSERT_OWNED)
PIDS_PER_ENTRY 1021
SET_GAME_MODE_ENTITLEMENT "com.apple.private.set-game-mode"
SET_CARPLAY_MODE_ENTITLEMENT "com.apple.private.set-carplay-mode"
AUTHORIZED_ACCESS_ENTITLEMENT "com.apple.private.vfs.authorized-access"
SKIP_MTIME_UPDATE_ENTITLEMENT "com.apple.private.vfs.skip-mtime-updates"
ALLOW_LOW_SPACE_WRITES_ENTITLEMENT "com.apple.private.vfs.allow-low-space-writes"
DISALLOW_RW_FOR_O_EVTONLY_ENTITLEMENT "com.apple.private.vfs.disallow-rw-for-o-evtonly"
SUPPORT_LONG_PATHS_ENTITLEMENT "com.apple.private.vfs.support-long-paths"
SFI_DEBUG 0
dprintf(...) printf(__VA_ARGS__)
SIGPROP None
PSIG_LOCKED 0x1
PSIG_VFORK 0x2
PSIG_THREAD 0x4
PSIG_TRY_THREAD 0x8
OLDMINSIGSTKSZ 8*1024
DBG_UIO_COPYOUT 16
DBG_UIO_COPYIN 17
BSD_HOST 1
SYSCTL_PROCARGS_READ_ENVVARS_ENTITLEMENT "com.apple.private.read-environment-variables"
EXECUTABLE_KEY "executable_path="
kRootsInstalledReadWriteEntitlement "com.apple.private.roots-installed-read-write"
kRootsInstalledReadOnlyEntitlement "com.apple.private.roots-installed-read-only"
HZ 100
kPanicStringMaxLen 1024
__KPI__ None
MAX_MBUF_TX_COMPL_FUNC 8
MTAG_FIRST_ID FIRST_KPI_STR_ID
MBUF_DRVAUX_MAXLEN P2ROUNDDOWN(MLEN -                                              	M_TAG_ALIGN(sizeof (struct m_drvaux_tag)), sizeof (uint64_t))
__KPI_MBUF_INTERNAL_ None
__KPI__ None
SOCK_SEND_MBUF_MODE_VERBOSE 0x0001
SFEF_ATTACHED 0x1
SFEF_NODETACH 0x2
SFEF_NOSOCKET 0x4
SFF_INTERNAL 0x1
SOLIST_ADD(_so) do {                                            	solist->next = solisthead;                                      	sock_retain((_so));                                             	solist->so = (_so);                                             	solisthead = solist;                                            } while (0)
MAX_NUM_FRAMES 5
_BSD_KERN_MACH_FAT_H_ None
MACHO_PRINTF(args) do {                                            	        if (macho_printf) {                     	                printf args;                    	        }                                       	} while (0)
DEFAULT_DYLD_PATH "/usr/lib/dyld"
_BSD_KERN_MACH_LOADER_H_ None
LOAD_SUCCESS 0
LOAD_BADARCH 1
LOAD_BADMACHO 2
LOAD_SHLIB 3
LOAD_FAILURE 4
LOAD_NOSPACE 5
LOAD_PROTECT 6
LOAD_RESOURCE 7
LOAD_ENOENT 8
LOAD_IOERROR 9
LOAD_DECRYPTFAIL 10
LOAD_BADMACHO_UPX 11
LOAD_BADARCH_X86 12
SET(t, f)       (t) |= (f)
CLR(t, f)       (t) &= ~(f)
ISSET(t, f)     ((t) & (f))
MCACHE_SIZE(n) __builtin_offsetof(mcache_t, mc_cpu[n])
MCACHE_LIST_LOCK() {                            	lck_mtx_lock(&mcache_llock);                     	mcache_llock_owner = current_thread();          }
MCACHE_LIST_UNLOCK() {                          	mcache_llock_owner = NULL;                      	lck_mtx_unlock(&mcache_llock);                   }
MCACHE_LOCK(l) lck_mtx_lock(l)
MCACHE_UNLOCK(l) lck_mtx_unlock(l)
MCACHE_LOCK_TRY(l) lck_mtx_try_lock(l)
DUMP_TRN_FMT() "%s transaction thread %p saved PC stack (%d deep):\n" 	    "\t%p, %p, %p, %p, %p, %p, %p, %p\n" 	    "\t%p, %p, %p, %p, %p, %p, %p, %p\n"
DUMP_TRN_FIELDS(s, x) 	    s, 	    mca->mca_trns[x].mca_thread, mca->mca_trns[x].mca_depth, 	    mca->mca_trns[x].mca_stack[0], mca->mca_trns[x].mca_stack[1], 	    mca->mca_trns[x].mca_stack[2], mca->mca_trns[x].mca_stack[3], 	    mca->mca_trns[x].mca_stack[4], mca->mca_trns[x].mca_stack[5], 	    mca->mca_trns[x].mca_stack[6], mca->mca_trns[x].mca_stack[7], 	    mca->mca_trns[x].mca_stack[8], mca->mca_trns[x].mca_stack[9], 	    mca->mca_trns[x].mca_stack[10], mca->mca_trns[x].mca_stack[11], 	    mca->mca_trns[x].mca_stack[12], mca->mca_trns[x].mca_stack[13], 	    mca->mca_trns[x].mca_stack[14], mca->mca_trns[x].mca_stack[15]
BOOTP_RESPONSE "bootp-response"
BSDP_RESPONSE "bsdp-response"
DHCP_RESPONSE "dhcp-response"
IP_FORMAT "%d.%d.%d.%d"
IP_LIST(ip) IP_CH(ip)[0],IP_CH(ip)[1],IP_CH(ip)[2],IP_CH(ip)[3]
kNetBootRootPathPrefixNFS "nfs:"
kNetBootRootPathPrefixHTTP "http:"
CHECK_POLICY_CHECK 0x00000001
CHECK_POLICY_FAIL 0x00000002
CHECK_POLICY_BACKTRACE 0x00000004
CHECK_POLICY_PANIC 0x00000008
CHECK_POLICY_PERIODIC 0x00000010
CHECK_SET_HOOK(x) .mpo_##x = (mpo_##x##_t *)(void (*)(void))common_hook,
CLASS_PERIOD_LIMIT 10000
CLASS_PERIOD_MULT 20
f_flag fp_glob->fg_flag
f_ops fp_glob->fg_ops
PSEMNAMLEN 31
PSEM_NONE 1
PSEM_DEFINED 2
PSEM_ALLOCATED 4
PSEM_MAPPED 8
PSEM_INUSE 0x10
PSEM_REMOVED 0x20
PSEM_INCREATE 0x40
PSEM_INDELETE 0x80
PSEM_SUBSYS_LOCK() lck_mtx_lock(&psx_sem_subsys_mutex)
PSEM_SUBSYS_UNLOCK() lck_mtx_unlock(&psx_sem_subsys_mutex)
PSEM_SUBSYS_ASSERT_HELD() LCK_MTX_ASSERT(&psx_sem_subsys_mutex, LCK_MTX_ASSERT_OWNED)
f_flag fp_glob->fg_flag
f_ops fp_glob->fg_ops
pshm_flags pshm_hdr.pshm_flags
pshm_usecount pshm_hdr.pshm_usecount
pshm_length pshm_hdr.pshm_length
pshm_mode pshm_hdr.pshm_mode
pshm_uid pshm_hdr.pshm_uid
pshm_gid pshm_hdr.pshm_gid
pshm_label pshm_hdr.pshm_label
PSHM_ALLOCATED 0x004
PSHM_MAPPED 0x008
PSHM_INUSE 0x010
PSHM_REMOVED 0x020
PSHM_ALLOCATING 0x100
PSHM_MAXCOUNT UINT_MAX
PSHM_SUBSYS_LOCK() lck_mtx_lock(& psx_shm_subsys_mutex)
PSHM_SUBSYS_UNLOCK() lck_mtx_unlock(& psx_shm_subsys_mutex)
PSHM_SUBSYS_ASSERT_HELD() LCK_MTX_ASSERT(&psx_shm_subsys_mutex, LCK_MTX_ASSERT_OWNED)
CHECK_SAME_USER TRUE
NO_CHECK_SAME_USER FALSE
MAX_UPTRS 16392
cryptexdrsrWriteEntitlement "com.apple.private.cryptexd-rsr-write"
delegateSignalEntitlement "com.apple.private.delegate-signals"
PROC_UUID_POLICY_DEBUG 0
dprintf(...) printf(__VA_ARGS__)
PROC_UUID_POLICY_SUBSYS_LOCK() lck_mtx_lock(&proc_uuid_policy_subsys_mutex)
PROC_UUID_POLICY_SUBSYS_UNLOCK() lck_mtx_unlock(&proc_uuid_policy_subsys_mutex)
PROC_UUID_POLICY_HASH_SIZE 64
BUMP_PROC_UUID_POLICY_GENERATION_COUNT() do {                                                                   	        if (OSIncrementAtomic(&proc_uuid_policy_table_gencount) == (INT32_MAX - 1)) {   	                proc_uuid_policy_table_gencount = 1;                                                                            	        }                                                                                                                                                               	} while (0)
MAX_PROC_UUID_POLICY_COUNT 10240
min(a, b)       ((a) < (b) ? (a) : (b))
swapcode(TYPE, parmi, parmj, n)                 	long i = (n) / sizeof (TYPE);                   	TYPE *pi = (TYPE *) (parmi);                    	TYPE *pj = (TYPE *) (parmj);                    	do {                                            	        TYPE	t = *pi;                        	        *pi++ = *pj;                            	        *pj++ = t;                              	} while (--i > 0);
SWAPINIT(a, es) swaptype = ((char *)a - (char *)0) % sizeof(long) || 	es % sizeof(long) ? 2 : es == sizeof(long)? 0 : 1;
swap(a, b)                                      	if (swaptype == 0) {                            	        long t = *(long *)(a);                  	        *(long *)(a) = *(long *)(b);            	        *(long *)(b) = t;                       	} else                                          	        swapfunc(a, b, es, swaptype)
vecswap(a, b, n)        if ((n) > 0) swapfunc(a, b, n, swaptype)
_IP_VHL None
SOFLOW_LOG(level, so, debug, fmt, ...)                                                                      do {                                                                                                                    if (soflow_log_level >= level && debug && soflow_log_handle) {                                                  	if (level == LOG_ERR) {                                                                                         	    os_log_error(soflow_log_handle, "SOFLOW - %s:%d <pid %d so %llx> " fmt "\n", __FUNCTION__, __LINE__,        	             so ? SOFLOW_SOCKET_PID(so) : 0, so ? (uint64_t)VM_KERNEL_ADDRPERM(so) : 0, ##__VA_ARGS__);         	} else {                                                                                                        	    os_log(soflow_log_handle, "SOFLOW - %s:%d <pid %d so %llx> " fmt "\n", __FUNCTION__, __LINE__,              	       so ? SOFLOW_SOCKET_PID(so) : 0, so ? (uint64_t)VM_KERNEL_ADDRPERM(so) : 0, ##__VA_ARGS__);               	}                                                                                                                   }                                                                                                               } while (0)
SOFLOW_ENTRY_LOG(level, so, entry, debug, msg)                                                              do {                                                                                                                    if (soflow_log_level >= level && entry && debug) {                                                                  soflow_entry_log(level, so, entry, msg);                                                                            }                                                                                                               } while (0)
SOFLOW_HASH(laddr, faddr, lport, fport) ((faddr) ^ ((laddr) >> 16) ^ (fport) ^ (lport))
SOFLOW_ENABLE_DEBUG(so, entry)     ((soflow_log_port == 0 || !entry || soflow_log_port == ntohs(entry->soflow_lport) || soflow_log_port == ntohs(entry->soflow_fport)) &&      (soflow_log_pid == 0 || !so || soflow_log_pid == SOFLOW_SOCKET_PID(so)) &&      (soflow_log_proto == 0 || !so || soflow_log_proto == SOFLOW_GET_SO_PROTO(so)))
SOFLOW_ENTRY_FREE(entry) if (entry && (os_ref_release(&entry->soflow_ref_count) == 0)) { 	soflow_entry_free(entry);     }
SOFLOW_DB_FREE(db) if (db && (os_ref_release(&db->soflow_db_ref_count) == 0)) {     soflow_db_free(db);     }
SOFLOW_LOCK_EXCLUSIVE lck_rw_lock_exclusive(&soflow_lck_rw)
SOFLOW_UNLOCK_EXCLUSIVE lck_rw_unlock_exclusive(&soflow_lck_rw)
SOFLOW_LOCK_SHARED lck_rw_lock_shared(&soflow_lck_rw)
SOFLOW_UNLOCK_SHARED lck_rw_unlock_shared(&soflow_lck_rw)
SOFLOW_GC_IDLE_TO 30
SOFLOW_GC_MAX_COUNT 100
__SOCKET_FLOWS_H__ None
SOFLOW_HASH_SIZE 16
SOFLOWF_SO_DELAYED_DEAD 0x0001
SSHOT_ANALYTICS_PERIOD_HOURS 1
STACKSHOT_ENTITLEMENT "com.apple.private.stackshot"
STACKSHOT_STATS_ENTITLEMENT "com.apple.private.stackshot.stats"
SSHOT_ENTITLEMENT_BOOTARG_REPORT "sshot-entitlement-report"
SSHOT_ENTITLEMENT_BOOTARG_FAIL "sshot-entitlement-refuse"
SSHOT_ENTITLEMENT_RECENT 16
SSHOT_ENTITLEMENT_REPORT_NORMAL 0
SSHOT_ENTITLEMENT_REPORT_TEST_OVERFLOW SSHOT_ENTITLEMENT_REPORT_TEST(-1)
LOG_NBIO 0x02
LOG_ASYNC 0x04
LOG_RDWAIT 0x08
ls_atomic(T) union { T v; _Atomic(T) av; }
log_stream_lock() lck_mtx_lock(&log_stream_lock)
log_stream_unlock() lck_mtx_unlock(&log_stream_lock)
log_stream_si_lock(s) lck_spin_lock(&(s)->lsi_lock)
log_stream_si_unlock(s) lck_spin_unlock(&(s)->lsi_lock)
SBUF_ISSET(s, f)        ((s)->s_flags & (f))
SBUF_SETFLAG(s, f)      do { (s)->s_flags |= (f); } while (0)
SBUF_CLEARFLAG(s, f)    do { (s)->s_flags &= ~(f); } while (0)
SBUF_CANEXTEND(s) SBUF_ISSET(s, SBUF_AUTOEXTEND)
SBUF_HASOVERFLOWED(s) SBUF_ISSET(s, SBUF_OVERFLOWED)
SBUF_ISDYNAMIC(s) SBUF_ISSET(s, SBUF_DYNAMIC)
SBUF_ISDYNSTRUCT(s) SBUF_ISSET(s, SBUF_DYNSTRUCT)
SBUF_ISFINISHED(s) SBUF_ISSET(s, SBUF_FINISHED)
SBUF_MINEXTENDSIZE 16
SBUF_MAXEXTENDSIZE PAGE_SIZE
SBUF_MAXEXTENDINCR PAGE_SIZE
f_flag fp_glob->fg_flag
f_type fp_glob->fg_ops->fo_type
f_cred fp_glob->fg_cred
f_ops fp_glob->fg_ops
STK_PARAMS 128
SEL_FIRSTPASS 1
SEL_SECONDPASS 2
getbits(name, x) 	(uap->name ? copyin(uap->name, &sel->ibits[(x) * nw], ni) : 0)
putbits(name, x) 	(uap->name ? copyout(&sel->obits[(x) * nw], uap->name, ni) : 0)
PERSONA_INFO_V1_SIZE offsetof(struct kpersona_info, persona_uid)
PERSONA_INFO_V2_SIZE sizeof(struct kpersona_info)
f_flag fp_glob->fg_flag
f_ops fp_glob->fg_ops
PIPE_PAIR(pipe) __container_of(PIPE_MTX(pipe), struct pipepair, pp_mtx)
PIPE_ATIME 0x00000001
PIPE_MTIME 0x00000002
PIPE_CTIME 0x00000004
XNU_TEST_BITMAP None
ULL_MUST_EXIST 0x0001
ULL_INDEX(keyp) ull_hash_index(keyp, keyp->ulk_key_type == ULK_UADDR ? ULK_UADDR_LEN : ULK_XPROC_LEN)
_IP_VHL None
TRACKER_LOG(level, fmt, ...)                                                                                    do {                                                                                                                        if (tracker_log_level >= level && tracker_db_log_handle) {                                                          	if (level == LOG_ERR) {                                                                                         	    os_log_error(tracker_db_log_handle, "TRACKER - %s:%d " fmt "\n", __FUNCTION__, __LINE__, ##__VA_ARGS__);    	} else {                                                                                                        	    os_log(tracker_db_log_handle, "TRACKER - %s:%d " fmt "\n", __FUNCTION__, __LINE__, ##__VA_ARGS__);          	}                                                                                                                   }                                                                                                                   } while (0)
TRACKER_ENTRY_LOG(level, msg, entry, hash)                                                                      do {                                                                                                                        if (tracker_log_level >= level) {                                                                                   	tracker_entry_log(level, msg, entry, hash);                                                                         }                                                                                                                   } while (0)
TRACKERHASHSIZE tcp_tcbhashsize
TRACKER_HASH(uuidptr, wordptr0, wordptr1, wordptr2, wordptr3)     ( TRACKER_HASH_WORD_TO_BYTE(wordptr0) ^ TRACKER_HASH_WORD_TO_BYTE(wordptr1) ^ TRACKER_HASH_WORD_TO_BYTE(wordptr2) ^ TRACKER_HASH_WORD_TO_BYTE(wordptr3) ^       TRACKER_HASH_UUID_TO_BYTE(uuidptr) )
TRACKER_SCRATCH_PAD_SIZE 200
TRACKER_DUMP_SCRATCH_PAD_SIZE 2048
TRACKER_HASH_ENTRY_HEADER_FIELDS LIST_ENTRY(tracker_hash_entry)      entry_link;             uuid_t                              app_uuid;               sa_family_t                         address_family;         union {                                                 	struct in_addr_4in6 addr46;                             	struct in6_addr addr6;                                      }                                   address;                u_int64_t                           lastused;
TRACKER_LOCK_EXCLUSIVE lck_rw_lock_exclusive(&g_tracker_lck_rw);
TRACKER_UNLOCK_EXCLUSIVE lck_rw_unlock_exclusive(&g_tracker_lck_rw);
TRACKER_LOCK_SHARED lck_rw_lock_shared(&g_tracker_lck_rw);
TRACKER_UNLOCK_SHARED lck_rw_unlock_shared(&g_tracker_lck_rw);
ALLOC_ENTRY(flags, entry)                                                                       if (flags & SO_TRACKER_ATTRIBUTE_FLAGS_DOMAIN_SHORT) {                                              tracker_hash_entry_short_t *short_entry = zalloc_flags(tracker_hash_entry_short_zone, Z_WAITOK | Z_ZERO | Z_NOFAIL);     if (short_entry == NULL) {                                                                      	TRACKER_LOG(LOG_ERR, "Failed to allocate tracker IP entry (Short)");                                } else {                                                                                        	entry = (tracker_hash_entry_t *)short_entry;                                                        }                                                                                                   } else {                                                                                            entry = zalloc_flags(tracker_hash_entry_zone, Z_WAITOK | Z_ZERO | Z_NOFAIL);                        if (entry == NULL) {                                                                            	TRACKER_LOG(LOG_ERR, "Failed to allocate tracker IP entry");                                        }                                                                                                   }
FREE_ENTRY(entry) if (entry) {                                                                                        if (entry->metadata.flags & SO_TRACKER_ATTRIBUTE_FLAGS_DOMAIN_SHORT) {                          	zfree(tracker_hash_entry_short_zone, entry);                                                        } else {                                                                                        	zfree(tracker_hash_entry_zone, entry);                                                              }                                                                                                   }
STRLEN_SRC_DOMAIN strbuflen((char *)src_domain_buffer, src_domain_buffer_size)
STRLEN_SRC_DOMAIN_OWNER strbuflen((char *)src_domain_owner_buffer, src_domain_owner_buffer_size)
STRLEN_DST_DOMAIN strbuflen((char *)dst_domain_buffer, dst_domain_buffer_size)
STRLEN_DST_DOMAIN_OWNER strbuflen((char *)dst_domain_owner_buffer, dst_domain_owner_buffer_size)
GET_METADATA_BUFFERS_DST(metadata) size_t dst_domain_max = 0;                                                                          size_t dst_domain_buffer_size = 0;                                                                  uint8_t * __sized_by(dst_domain_buffer_size) dst_domain_buffer = NULL;                              size_t dst_domain_owner_buffer_size = 0;                                                            uint8_t * __sized_by(dst_domain_owner_buffer_size) dst_domain_owner_buffer = NULL;                  if (metadata != NULL) {                                                                         	if (metadata->flags & SO_TRACKER_ATTRIBUTE_FLAGS_DOMAIN_SHORT) {                            	    tracker_metadata_short_t *short_metadata = (tracker_metadata_short_t *)metadata;        	    dst_domain_max = TRACKER_DOMAIN_SHORT_MAX;                                              	    dst_domain_buffer = (uint8_t *)(&short_metadata->domain);                               	    dst_domain_buffer_size = dst_domain_max + 1;                                            	    dst_domain_owner_buffer = (uint8_t *)(&short_metadata->domain_owner);                   	    dst_domain_owner_buffer_size = dst_domain_max + 1;                                      	} else {                                                                                    	    dst_domain_max = TRACKER_DOMAIN_MAX;                                                    	    dst_domain_buffer = (uint8_t *)(&metadata->domain);                                     	    dst_domain_buffer_size = dst_domain_max + 1;                                            	    dst_domain_owner_buffer = (uint8_t *)(&metadata->domain_owner);                         	    dst_domain_owner_buffer_size = dst_domain_max + 1;                                      	}                                                                                               }
GET_METADATA_BUFFERS_SRC(metadata) size_t src_domain_max = 0;                                                                          size_t src_domain_buffer_size = 0;                                                                  uint8_t * __sized_by(src_domain_buffer_size) src_domain_buffer = NULL;                              size_t src_domain_owner_buffer_size = 0;                                                            uint8_t * __sized_by(src_domain_owner_buffer_size) src_domain_owner_buffer = NULL;                  if (metadata != NULL) {                                                                         	if (metadata->flags & SO_TRACKER_ATTRIBUTE_FLAGS_DOMAIN_SHORT) {                            	    tracker_metadata_short_t *short_metadata = (tracker_metadata_short_t *)metadata;        	    src_domain_max = TRACKER_DOMAIN_SHORT_MAX;                                              	    src_domain_buffer = (uint8_t *)(&short_metadata->domain);                               	    src_domain_buffer_size = src_domain_max + 1;                                            	    src_domain_owner_buffer = (uint8_t *)(&short_metadata->domain_owner);                   	    src_domain_owner_buffer_size = src_domain_max + 1;                                      	} else {                                                                                    	    src_domain_max = TRACKER_DOMAIN_MAX;                                                    	    src_domain_buffer = (uint8_t *)(&metadata->domain);                                     	    src_domain_buffer_size = src_domain_max + 1;                                            	    src_domain_owner_buffer = (uint8_t *)(&metadata->domain_owner);                         	    src_domain_owner_buffer_size = src_domain_max + 1;                                      	}                                                                                               }
TTYDEFCHARS 1
E 0x00
O 0x80
ALPHA 0x40
CCLASSMASK 0x3f
BS BACKSPACE
CC CONTROL
CR RETURN
NA ORDINARY | ALPHA
NL NEWLINE
NO ORDINARY
TB TAB
VT VTAB
SET(t, f)       (t) |= (f)
CLR(t, f)       (t) &= ~(f)
ISSET(t, f)     ((t) & (f))
FLUSHQ(q) {                                                     	if ((q)->c_cc)                                                  	        ndflush(q, (q)->c_cc);                                  }
TTBREAKC(c, lflag)                                                      	((c) == '\n' || (((c) == cc[VEOF] ||                            	  (c) == cc[VEOL] || ((c) == cc[VEOL2] && lflag & IEXTEN)) &&   	 (c) != _POSIX_VDISABLE))
diff(t1, t2) (((t1).tv_sec - (t2).tv_sec) * 1000000 + 	                 ((t1).tv_usec - (t2).tv_usec))
PANICSTR "ttyrub: would panic c = %d, val = %d\n"
CLAMP(x, h, l)  ((x) > h ? h : ((x) < l) ? l : (x))
TESTAB(a, b)    ((a)<<1 | (b))
ONLYA 2
ONLYB 1
BOTH 3
MAX_SPEED 17
MAXLDISC 8
NODISC(n) { l_noopen,	l_noclose,	l_noread,	l_nowrite, 	  l_noioctl,	l_norint,	l_nostart,	ttymodem }
LOADABLE_LDISC 6
BUFSIZ 100
FIX_VSX_HANG 1
__TTY_DEV_H__ None
PF_PKT 0x0008
PF_STOPPED 0x0010
PF_NOSTOP 0x0040
PF_UCNTL 0x0080
PF_UNLOCKED 0x0100
PF_OPEN_M 0x0200
PF_OPEN_S 0x0400
PTMX_TEMPLATE "ptmx"
PTSD_TEMPLATE "ttys%03d"
PTMX_MAX_DEFAULT 511
PTMX_MAX_HARD 999
PTMX_GROW_VECTOR 16
QBITS None
MB_GROWTH_AGGRESSIVE 1
MB_GROWTH_NORMAL 2
MBUF_CLASS_MIN MC_MBUF
MBUF_CLASS_MAX MC_MBUF_16KCL
MBUF_CLASS_LAST MC_16KCL
MCR_COMP MCR_USR1
SLF_MAPPED 0x0001
SLF_PARTIAL 0x0002
SLF_DETACHED 0x0004
MINCL 32
MBIGCL_LOWAT MINBIGCL
M16KCL_LOWAT MIN16KCL
m_class(c) mbuf_table[c].mtbl_class
m_maxsize(c) mbuf_table[c].mtbl_maxsize
m_minlimit(c) mbuf_table[c].mtbl_minlimit
m_maxlimit(c) mbuf_table[c].mtbl_maxlimit
m_wantpurge(c) mbuf_table[c].mtbl_wantpurge
m_cname(c) mbuf_table[c].mtbl_stats->mbcl_cname
m_size(c) mbuf_table[c].mtbl_stats->mbcl_size
m_total(c) mbuf_table[c].mtbl_stats->mbcl_total
m_active(c) mbuf_table[c].mtbl_stats->mbcl_active
m_infree(c) mbuf_table[c].mtbl_stats->mbcl_infree
m_slab_cnt(c) mbuf_table[c].mtbl_stats->mbcl_slab_cnt
m_alloc_cnt(c) mbuf_table[c].mtbl_stats->mbcl_alloc_cnt
m_free_cnt(c) mbuf_table[c].mtbl_stats->mbcl_free_cnt
m_notified(c) mbuf_table[c].mtbl_stats->mbcl_notified
m_purge_cnt(c) mbuf_table[c].mtbl_stats->mbcl_purge_cnt
m_fail_cnt(c) mbuf_table[c].mtbl_stats->mbcl_fail_cnt
m_ctotal(c) mbuf_table[c].mtbl_stats->mbcl_ctotal
m_release_cnt(c) mbuf_table[c].mtbl_stats->mbcl_release_cnt
m_region_expand(c) mbuf_table[c].mtbl_expand
MB_WDT_MAXTIME 10
M_COPYBACK0_COPYBACK 0x0001
M_COPYBACK0_PRESERVE 0x0002
M_COPYBACK0_COW 0x0004
M_COPYBACK0_EXTEND 0x0008
EXTF_COMPOSITE 0x1
EXTF_READONLY 0x2
EXTF_PAIRED 0x4
MBUF_INIT_PKTHDR(m) {                                           	(m)->m_pkthdr.rcvif = NULL;                                     	(m)->m_pkthdr.pkt_hdr = NULL;                                   	(m)->m_pkthdr.len = 0;                                          	(m)->m_pkthdr.csum_flags = 0;                                   	(m)->m_pkthdr.csum_data = 0;                                    	(m)->m_pkthdr.vlan_tag = 0;                                     	(m)->m_pkthdr.comp_gencnt = 0;                                  	(m)->m_pkthdr.pkt_crumbs = 0;                                   	m_classifier_init(m, 0);                                        	m_tag_init(m, 1);                                               	m_scratch_init(m);                                              }
MBUF_INIT(m, pkthdr, type) {                                    	_MCHECK(m);                                                     	(m)->m_next = (m)->m_nextpkt = NULL;                            	(m)->m_len = 0;                                                 	(m)->m_type = type;                                             	if ((pkthdr) == 0) {                                            	        (m)->m_data = (uintptr_t)(m)->m_dat;                    	        (m)->m_flags = 0;                                       	} else {                                                        	        (m)->m_data = (uintptr_t)(m)->m_pktdat;                 	        (m)->m_flags = M_PKTHDR;                                	        MBUF_INIT_PKTHDR(m);                                    	}                                                               }
MEXT_INIT mext_init
MBUF_CL_INIT(m, buf, rfa, ref, flag)    	MEXT_INIT(m, buf, m_maxsize(MC_CL), NULL, NULL, rfa, 0,         	    ref, 0, flag, 0, NULL)
MBUF_BIGCL_INIT(m, buf, rfa, ref, flag) 	MEXT_INIT(m, buf, m_maxsize(MC_BIGCL), m_bigfree, NULL, rfa, 0, 	    ref, 0, flag, 0, NULL)
MBUF_16KCL_INIT(m, buf, rfa, ref, flag) 	MEXT_INIT(m, buf, m_maxsize(MC_16KCL), m_16kfree, NULL, rfa, 0, 	    ref, 0, flag, 0, NULL)
MB_STAT_SIZE(n) __builtin_offsetof(mb_stat_t, mbs_class[n])
OMB_STAT_SIZE(n) __builtin_offsetof(struct omb_stat, mbs_class[n])
mtype_stat_add(type, n) {                                       	if ((unsigned)(type) < MT_MAX) {                                	        mbuf_mtypes_t *mbs = PERCPU_GET(mbuf_mtypes);           	        os_atomic_add(&mbs->cpu_mtypes[type], n, relaxed);               	} else if ((unsigned)(type) < (unsigned)MBSTAT_MTYPES_MAX) {    	        os_atomic_add((int16_t *)&mbstat.m_mtypes[type], n, relaxed);    	}                                                               }
mtype_stat_sub(t, n)    mtype_stat_add(t, -(n))
mtype_stat_inc(t) mtype_stat_add(t, 1)
mtype_stat_dec(t) mtype_stat_sub(t, 1)
_M_GET(wait, type)      m_get_common(wait, type, 0)
_M_GETHDR(wait, type)   m_get_common(wait, type, 1)
_M_RETRY(wait, type)    _M_GET(wait, type)
_M_RETRYHDR(wait, type) _M_GETHDR(wait, type)
_MGET(m, how, type)     ((m) = _M_GET(how, type))
_MGETHDR(m, how, type)  ((m) = _M_GETHDR(how, type))
ROUNDUP(a, b) (((a) + ((b) - 1)) & (~((b) - 1)))
EVEN_MORE_LOCKING_DEBUG 0
DBG_LAYER_IN_BEG NETDBG_CODE(DBG_NETSOCK, 0)
DBG_LAYER_IN_END NETDBG_CODE(DBG_NETSOCK, 2)
DBG_LAYER_OUT_BEG NETDBG_CODE(DBG_NETSOCK, 1)
DBG_LAYER_OUT_END NETDBG_CODE(DBG_NETSOCK, 3)
DBG_FNC_SOSEND NETDBG_CODE(DBG_NETSOCK, (4 << 8) | 1)
DBG_FNC_SOSEND_LIST NETDBG_CODE(DBG_NETSOCK, (4 << 8) | 3)
DBG_FNC_SORECEIVE NETDBG_CODE(DBG_NETSOCK, (8 << 8))
DBG_FNC_SORECEIVE_LIST NETDBG_CODE(DBG_NETSOCK, (8 << 8) | 3)
DBG_FNC_SOSHUTDOWN NETDBG_CODE(DBG_NETSOCK, (9 << 8))
SO_IDLE_BK_IDLE_MAX_PER_PROC 1
SO_IDLE_BK_IDLE_TIME 600
SO_IDLE_BK_IDLE_RCV_HIWAT 131072
SO_MAX_MSG_X 1024
MIN_BINDTODEVICE_NAME_SIZE 2
DBG_FNC_SBDROP NETDBG_CODE(DBG_NETSOCK, 4)
DBG_FNC_SBAPPEND NETDBG_CODE(DBG_NETSOCK, 5)
DEFAULT(foo, bar)       if ((foo) == NULL) (foo) = (bar)
f_flag fp_glob->fg_flag
f_ops fp_glob->fg_ops
DBG_LAYER_IN_BEG NETDBG_CODE(DBG_NETSOCK, 0)
DBG_LAYER_IN_END NETDBG_CODE(DBG_NETSOCK, 2)
DBG_LAYER_OUT_BEG NETDBG_CODE(DBG_NETSOCK, 1)
DBG_LAYER_OUT_END NETDBG_CODE(DBG_NETSOCK, 3)
DBG_FNC_SENDMSG NETDBG_CODE(DBG_NETSOCK, (1 << 8) | 1)
DBG_FNC_SENDTO NETDBG_CODE(DBG_NETSOCK, (2 << 8) | 1)
DBG_FNC_SENDIT NETDBG_CODE(DBG_NETSOCK, (3 << 8) | 1)
DBG_FNC_RECVFROM NETDBG_CODE(DBG_NETSOCK, (5 << 8))
DBG_FNC_RECVMSG NETDBG_CODE(DBG_NETSOCK, (6 << 8))
DBG_FNC_RECVIT NETDBG_CODE(DBG_NETSOCK, (7 << 8))
DBG_FNC_SENDFILE NETDBG_CODE(DBG_NETSOCK, (10 << 8))
DBG_FNC_SENDFILE_WAIT NETDBG_CODE(DBG_NETSOCK, ((10 << 8) | 1))
DBG_FNC_SENDFILE_READ NETDBG_CODE(DBG_NETSOCK, ((10 << 8) | 2))
DBG_FNC_SENDFILE_SEND NETDBG_CODE(DBG_NETSOCK, ((10 << 8) | 3))
DBG_FNC_SENDMSG_X NETDBG_CODE(DBG_NETSOCK, (11 << 8))
DBG_FNC_RECVMSG_X NETDBG_CODE(DBG_NETSOCK, (12 << 8))
SO_MAX_MSG_X_DEFAULT 256
MIN(a, b) ((a) > (b) ? (b) : (a))
MIN(a, b) ((a) > (b) ? (b) : (a))
ROUNDUP64(x) P2ROUNDUP((x), sizeof (u_int64_t))
ADVANCE64(p, n) (void*)((char *)(p) + ROUNDUP64(n))
UIPC_MAX_CMSG_FD 512
ULEF_CONNECTION 0x01
MDNSRESPONDER_PATH "/var/run/mDNSResponder"
MDNS_IPC_MSG_HDR_VERSION_1 1
PIPSIZ 8192
MIN(a, b) (((a) < (b)) ? (a) : (b))
VSOCK_PORT_RESERVED 1024
_LIBKERN_COPYIO_H_ None
_LIBKERN_LIBKERN_H_ None
UNSUPPORTED_API(funcname, ...) 	_Pragma("clang diagnostic push") 	_Pragma("clang diagnostic ignored \"-Wunused-parameter\"") 	funcname(__VA_ARGS__) { panic("%s: unsupported API", __func__); } 	_Pragma("clang diagnostic pop")
_BSD_MACHINE_BYTE_ORDER_H_ None
CN_DEAD 0
CN_NORMAL 1
CN_INTERNAL 2
CN_REMOTE 3
CONSMAJOR 0
_BSD_MACHINE_CPU_H_ None
_BSD_MACHINE_DIS_TABLES_H_ None
_BSD_MACHINE_ENDIAN_H_ None
_BSD_MACHINE_EXEC_H_ None
_BSD_MACHINE_FASTTRAP_ISA_H_ None
_BSD_MACHINE_LIMITS_H_ None
_BSD_MACHINE_PARAM_H_ None
_BSD_MACHINE_PROFILE_H_ None
_BSD_MACHINE_PSL_H_ None
_BSD_MACHINE_PTRACE_H_ None
_BSD_MACHINE_REG_H_ None
_BSD_MACHINE_SIGNAL_H_ None
_BSD_MACHINE_SMP_H_ None
_BSD_MACHINE_TYPES_H_ None
_BSD_MACHINE_VMPARAM_H_ None
_BSD_MACHINE__ENDIAN_H_ None
_BSD_MACHINE__LIMITS_H_ None
_BSD_MACHINE__MCONTEXT_H_ None
_BSD_MACHINE__PARAM_H_ None
_BSD_MACHINE__TYPES_H_ None
_NET_BLOOM_FILTER_H_ None
net_bloom_howmany(x, y) (((x) / (y)) + ((x) % (y) != 0))
inline None
BPF_BUFSIZE 4096
PRINET 26
ESP_HDR_SIZE sizeof(struct newesp)
BPF_WRITE_LEEWAY 18
BPF_WRITE_MAX 0x1000000
BPF_MAX_DEVICES 256
CDEV_MAJOR 23
SOCKADDR_HDR_LEN offsetof(struct sockaddr, sa_data)
BPF_SLEEP bpf_sleep
ROTATE_BUFFERS(d) do { 	if (d->bd_hbuf_read) 	        panic("rotating bpf buffers during read"); 	(d)->bd_hbuf = (d)->bd_sbuf; 	(d)->bd_hlen = (d)->bd_slen; 	(d)->bd_hcnt = (d)->bd_scnt; 	(d)->bd_sbuf = (d)->bd_fbuf; 	(d)->bd_slen = 0; 	(d)->bd_scnt = 0; 	(d)->bd_fbuf = NULL; 	if ((d)->bd_headdrop != 0) 	        (d)->bd_prev_slen = 0; } while(false)
_NET_BPF_H_ None
DLT_NULL 0
DLT_EN10MB 1
DLT_EN3MB 2
DLT_AX25 3
DLT_PRONET 4
DLT_CHAOS 5
DLT_IEEE802 6
DLT_ARCNET 7
DLT_SLIP 8
DLT_PPP 9
DLT_FDDI 10
DLT_ATM_RFC1483 11
DLT_RAW 12
DLT_SLIP_BSDOS 15
DLT_PPP_BSDOS 16
DLT_PFSYNC 18
DLT_ATM_CLIP 19
DLT_PPP_SERIAL 50
DLT_PPP_ETHER 51
DLT_SYMANTEC_FIREWALL 99
DLT_MATCHING_MIN 104
DLT_C_HDLC 104
DLT_CHDLC DLT_C_HDLC
DLT_IEEE802_11 105
DLT_FRELAY 107
DLT_LOOP 108
DLT_ENC 109
DLT_LINUX_SLL 113
DLT_LTALK 114
DLT_ECONET 115
DLT_IPFILTER 116
DLT_PFLOG 117
DLT_CISCO_IOS 118
DLT_PRISM_HEADER 119
DLT_AIRONET_HEADER 120
DLT_HHDLC 121
DLT_IP_OVER_FC 122
DLT_SUNATM 123
DLT_RIO 124
DLT_PCI_EXP 125
DLT_AURORA 126
DLT_IEEE802_11_RADIO 127
DLT_TZSP 128
DLT_ARCNET_LINUX 129
DLT_JUNIPER_MLPPP 130
DLT_JUNIPER_MLFR 131
DLT_JUNIPER_ES 132
DLT_JUNIPER_GGSN 133
DLT_JUNIPER_MFR 134
DLT_JUNIPER_ATM2 135
DLT_JUNIPER_SERVICES 136
DLT_JUNIPER_ATM1 137
DLT_APPLE_IP_OVER_IEEE1394 138
DLT_MTP2_WITH_PHDR 139
DLT_MTP2 140
DLT_MTP3 141
DLT_SCCP 142
DLT_DOCSIS 143
DLT_LINUX_IRDA 144
DLT_IBM_SP 145
DLT_IBM_SN 146
DLT_USER0 147
DLT_USER1 148
DLT_USER2 149
DLT_USER3 150
DLT_USER4 151
DLT_USER5 152
DLT_USER6 153
DLT_USER7 154
DLT_USER8 155
DLT_USER9 156
DLT_USER10 157
DLT_USER11 158
DLT_USER12 159
DLT_USER13 160
DLT_USER14 161
DLT_USER15 162
DLT_USER0_APPLE_INTERNAL DLT_USER0
DLT_USER1_APPLE_INTERNAL DLT_USER1
DLT_PKTAP DLT_USER2
DLT_USER3_APPLE_INTERNAL DLT_USER3
DLT_USER4_APPLE_INTERNAL DLT_USER4
DLT_IEEE802_11_RADIO_AVS 163
DLT_JUNIPER_MONITOR 164
DLT_BACNET_MS_TP 165
DLT_PPP_PPPD 166
DLT_PPP_WITH_DIRECTION DLT_PPP_PPPD
DLT_LINUX_PPP_WITHDIRECTION DLT_PPP_PPPD
DLT_JUNIPER_PPPOE 167
DLT_JUNIPER_PPPOE_ATM 168
DLT_GPRS_LLC 169
DLT_GPF_T 170
DLT_GPF_F 171
DLT_GCOM_T1E1 172
DLT_GCOM_SERIAL 173
DLT_JUNIPER_PIC_PEER 174
DLT_ERF_ETH 175
DLT_ERF_POS 176
DLT_LINUX_LAPD 177
DLT_JUNIPER_ETHER 178
DLT_JUNIPER_PPP 179
DLT_JUNIPER_FRELAY 180
DLT_JUNIPER_CHDLC 181
DLT_MFR 182
DLT_JUNIPER_VP 183
DLT_A429 184
DLT_A653_ICM 185
DLT_USB 186
DLT_BLUETOOTH_HCI_H4 187
DLT_IEEE802_16_MAC_CPS 188
DLT_USB_LINUX 189
DLT_CAN20B 190
DLT_IEEE802_15_4_LINUX 191
DLT_PPI 192
DLT_IEEE802_16_MAC_CPS_RADIO 193
DLT_JUNIPER_ISM 194
DLT_IEEE802_15_4 195
DLT_SITA 196
DLT_ERF 197
DLT_RAIF1 198
DLT_IPMB 199
DLT_JUNIPER_ST 200
DLT_BLUETOOTH_HCI_H4_WITH_PHDR 201
DLT_AX25_KISS 202
DLT_LAPD 203
DLT_PPP_WITH_DIR 204
DLT_C_HDLC_WITH_DIR 205
DLT_FRELAY_WITH_DIR 206
DLT_LAPB_WITH_DIR 207
DLT_IPMB_LINUX 209
DLT_FLEXRAY 210
DLT_MOST 211
DLT_LIN 212
DLT_X2E_SERIAL 213
DLT_X2E_XORAYA 214
DLT_IEEE802_15_4_NONASK_PHY 215
DLT_LINUX_EVDEV 216
DLT_GSMTAP_UM 217
DLT_GSMTAP_ABIS 218
DLT_MPLS 219
DLT_USB_LINUX_MMAPPED 220
DLT_DECT 221
DLT_AOS 222
DLT_WIHART 223
DLT_FC_2 224
DLT_FC_2_WITH_FRAME_DELIMS 225
DLT_IPNET 226
DLT_CAN_SOCKETCAN 227
DLT_IPV4 228
DLT_IPV6 229
DLT_IEEE802_15_4_NOFCS 230
DLT_DBUS 231
DLT_JUNIPER_VS 232
DLT_JUNIPER_SRX_E2E 233
DLT_JUNIPER_FIBRECHANNEL 234
DLT_DVB_CI 235
DLT_MUX27010 236
DLT_STANAG_5066_D_PDU 237
DLT_JUNIPER_ATM_CEMIC 238
DLT_NFLOG 239
DLT_NETANALYZER 240
DLT_NETANALYZER_TRANSPARENT 241
DLT_IPOIB 242
DLT_MPEG_2_TS 243
DLT_NG40 244
DLT_NFC_LLCP 245
DLT_USB_DARWIN 266
DLT_MATCHING_MAX 266
BPF_TAP_MODE_T None
_NET_BPFDESC_H_ None
BPF_REF_HIST 4
BPF_IDLE 0
BPF_WAITING 1
BPF_TIMED_OUT 2
BPF_DRAINING 3
BPF_EXTENDED_HDR 0x0001
BPF_WANT_PKTAP 0x0002
BPF_FINALIZE_PKTAP 0x0004
BPF_KNOTE 0x0008
BPF_DETACHING 0x0010
BPF_DETACHED 0x0020
BPF_CLOSING 0x0040
BPF_TRUNCATE 0x0080
BPF_PKTHDRV2 0x0100
BPF_COMP_REQ 0x0200
BPF_COMP_ENABLED 0x0400
BPF_BATCH_WRITE 0x0800
BPF_DIVERT_IN 0x1000
_NET_BPF_COMPAT_H_ None
BSTP_TASK_INIT(bt, func, context) do { 	(bt)->bt_count = 0; 	(bt)->bt_func = func; 	(bt)->bt_context = context; } while(0)
BSTP_LOCK_INIT(_bs) lck_mtx_init(&(_bs)->bs_mtx, &bstp_lock_grp, &bstp_lock_attr)
BSTP_LOCK_DESTROY(_bs) lck_mtx_destroy(&(_bs)->bs_mtx, &bstp_lock_grp)
BSTP_LOCK(_bs) lck_mtx_lock(&(_bs)->bs_mtx)
BSTP_UNLOCK(_bs) lck_mtx_unlock(&(_bs)->bs_mtx)
BSTP_LOCK_ASSERT(_bs) LCK_MTX_ASSERT(&(_bs)->bs_mtx, LCK_MTX_ASSERT_OWNED)
PV2ADDR(pv, eaddr)      do {            	eaddr[0] = pv >> 40;                    	eaddr[1] = pv >> 32;                    	eaddr[2] = pv >> 24;                    	eaddr[3] = pv >> 16;                    	eaddr[4] = pv >> 8;                     	eaddr[5] = pv >> 0;                     } while (0)
INFO_BETTER 1
INFO_SAME 0
INFO_WORSE -1
__BRIDGESTP_H__ None
BSTP_IFSTATE_DISABLED 0
BSTP_IFSTATE_LISTENING 1
BSTP_IFSTATE_LEARNING 2
BSTP_IFSTATE_FORWARDING 3
BSTP_IFSTATE_BLOCKING 4
BSTP_IFSTATE_DISCARDING 5
BSTP_TCSTATE_ACTIVE 1
BSTP_TCSTATE_DETECTED 2
BSTP_TCSTATE_INACTIVE 3
BSTP_TCSTATE_LEARNING 4
BSTP_TCSTATE_PROPAG 5
BSTP_TCSTATE_ACK 6
BSTP_TCSTATE_TC 7
BSTP_TCSTATE_TCN 8
BSTP_ROLE_DISABLED 0
BSTP_ROLE_ROOT 1
BSTP_ROLE_DESIGNATED 2
BSTP_ROLE_ALTERNATE 3
BSTP_ROLE_BACKUP 4
BSTP_PORT_CANMIGRATE 0x0001
BSTP_PORT_NEWINFO 0x0002
BSTP_PORT_DISPUTED 0x0004
BSTP_PORT_ADMCOST 0x0008
BSTP_PORT_AUTOEDGE 0x0010
BSTP_PORT_AUTOPTP 0x0020
BSTP_PORT_ADMEDGE 0x0040
BSTP_PORT_PNDCOST 0x0080
BSTP_PDU_SUPERIOR 1
BSTP_PDU_REPEATED 2
BSTP_PDU_INFERIOR 3
BSTP_PDU_INFERIORALT 4
BSTP_PDU_OTHER 5
BSTP_PDU_PRMASK 0x0c
BSTP_PDU_PRSHIFT 2
BSTP_PDU_F_UNKN 0x00
BSTP_PDU_F_ALT 0x01
BSTP_PDU_F_ROOT 0x02
BSTP_PDU_F_DESG 0x03
BSTP_PDU_STPMASK 0x81
BSTP_PDU_RSTPMASK 0x7f
BSTP_PDU_F_TC 0x01
BSTP_PDU_F_P 0x02
BSTP_PDU_F_L 0x10
BSTP_PDU_F_F 0x20
BSTP_PDU_F_A 0x40
BSTP_PDU_F_TCA 0x80
BSTP_DEFAULT_HOLD_COUNT 6
BSTP_DEFAULT_BRIDGE_PRIORITY 0x8000
BSTP_DEFAULT_PORT_PRIORITY 0x80
BSTP_DEFAULT_PATH_COST 55
BSTP_MIN_HOLD_COUNT 1
BSTP_MAX_HOLD_COUNT 10
BSTP_MAX_PRIORITY 61440
BSTP_MAX_PORT_PRIORITY 240
BSTP_MAX_PATH_COST 200000000
BSTP_MSGTYPE_CFG 0x00
BSTP_MSGTYPE_RSTP 0x02
BSTP_MSGTYPE_TCN 0x80
BSTP_PROTO_ID 0x00
BSTP_PROTO_STP 0x00
BSTP_PROTO_RSTP 0x02
BSTP_PROTO_MAX BSTP_PROTO_RSTP
BSTP_INFO_RECIEVED 1
BSTP_INFO_RECEIVED 1
BSTP_INFO_MINE 2
BSTP_INFO_AGED 3
BSTP_INFO_DISABLED 4
LINK_STATE_UNKNOWN 0
LINK_STATE_DOWN 1
LINK_STATE_UP 2
_IP_VHL None
MAX_CONTENT_FILTER 8
CFF_ACTIVE 0x01
CFF_DETACHING 0x02
CFF_FLOW_CONTROLLED 0x04
CFF_PRESERVE_CONNECTIONS 0x08
CFIL_RW_LCK_MAX 8
CFEF_CFIL_ATTACHED 0x0001
CFEF_SENT_SOCK_ATTACHED 0x0002
CFEF_DATA_START 0x0004
CFEF_FLOW_CONTROLLED 0x0008
CFEF_SENT_DISCONNECT_IN 0x0010
CFEF_SENT_DISCONNECT_OUT 0x0020
CFEF_SENT_SOCK_CLOSED 0x0040
CFEF_CFIL_DETACHED 0x0080
CFI_ADD_TIME_LOG(cfil, t1, t0, op)                                                                                      	        struct timeval64 _tdiff;                                                                                          	        size_t offset = (cfil)->cfi_op_list_ctr;                                                                        	        if (offset < CFI_MAX_TIME_LOG_ENTRY) {                                                                          	                timersub(t1, t0, &_tdiff);                                                                              	                (cfil)->cfi_op_time[offset] = (uint32_t)(_tdiff.tv_sec * 1000 + _tdiff.tv_usec / 1000);                 	                (cfil)->cfi_op_list[offset] = (unsigned char)op;                                                        	                (cfil)->cfi_op_list_ctr ++;                                                                             	        }
CFIF_DROP 0x0001
CFIF_CLOSE_WAIT 0x0002
CFIF_SOCK_CLOSED 0x0004
CFIF_RETRY_INJECT_IN 0x0010
CFIF_RETRY_INJECT_OUT 0x0020
CFIF_SHUT_WR 0x0040
CFIF_SHUT_RD 0x0080
CFIF_SOCKET_CONNECTED 0x0100
CFIF_INITIAL_VERDICT 0x0200
CFIF_NO_CLOSE_WAIT 0x0400
CFIF_SO_DELAYED_DEAD 0x0800
CFIF_SO_DELAYED_TCP_TIME_WAIT 0x1000
CFI_MASK_GENCNT 0xFFFFFFFF00000000
CFI_SHIFT_GENCNT 32
CFI_MASK_FLOWHASH 0x00000000FFFFFFFF
CFI_SHIFT_FLOWHASH 0
CFI_ENTRY_KCUNIT(i, e) ((uint32_t)(((e) - &((i)->cfi_entries[0])) + 1))
CFIL_QUEUE_VERIFY(x) if (cfil_debug) cfil_queue_verify(x)
CFIL_INFO_VERIFY(x) if (cfil_debug) cfil_info_verify(x)
IS_ENTRY_ATTACHED(cfil_info, kcunit) (cfil_info != NULL && (kcunit <= MAX_CONTENT_FILTER) && 	                                                                                  cfil_info->cfi_entries[kcunit - 1].cfe_filter != NULL)
IS_DNS(local, remote) (check_port(local, 53) || check_port(remote, 53) || check_port(local, 5353) || check_port(remote, 5353))
SET_NO_CLOSE_WAIT(inp, cfil_info)     if (inp && cfil_info && !(cfil_info->cfi_flags & CFIF_INITIAL_VERDICT) && IS_LOOPBACK_FADDR(inp)) { 	cfil_info->cfi_flags |= CFIF_NO_CLOSE_WAIT;     }
CFIL_INFO_FREE(cfil_info) if (cfil_info && (os_ref_release(&cfil_info->cfi_ref_count) == 0)) { 	cfil_info_free(cfil_info);     }
MATCH_PORT(inp, local, remote)     ((inp && ntohs(inp->inp_lport) == cfil_log_port) || (inp && ntohs(inp->inp_fport) == cfil_log_port) || 	check_port(local, cfil_log_port) || check_port(remote, cfil_log_port))
DEBUG_FLOW(inp, so, local, remote)     ((cfil_log_port && MATCH_PORT(inp, local, remote)) || (cfil_log_pid && MATCH_PID(so)) || (cfil_log_proto && MATCH_PROTO(so)))
SO_DELAYED_DEAD_SET(so, set) do {                               	if (so->so_cfil) {                                              	        if (set) {                                              	                so->so_cfil->cfi_flags |= CFIF_SO_DELAYED_DEAD; 	        } else {                                                	                so->so_cfil->cfi_flags &= ~CFIF_SO_DELAYED_DEAD; 	        }                                                       	} else if (so->so_flow_db) {                                    	        if (set) {                                              	                so->so_flow_db->soflow_db_flags |= SOFLOWF_SO_DELAYED_DEAD; 	        } else {                                                	                so->so_flow_db->soflow_db_flags &= ~SOFLOWF_SO_DELAYED_DEAD; 	        }                                                       	}                                                               } while (0)
SO_DELAYED_TCP_TIME_WAIT_SET(so, set) do {                      	if (so->so_cfil) {                                              	        if (set) {                                              	                so->so_cfil->cfi_flags |= CFIF_SO_DELAYED_TCP_TIME_WAIT; 	        } else {                                                	                so->so_cfil->cfi_flags &= ~CFIF_SO_DELAYED_TCP_TIME_WAIT; 	        }                                                       	}                                                               } while (0)
CFIL_STATS_REPORT_INTERVAL_MIN_MSEC 500
CFIL_STATS_REPORT_MAX_COUNT 50
UDP_FLOW_GC_ACTION_TO 10
UDP_FLOW_GC_MAX_COUNT 100
UDP_FLOW_GC_MBUF_SHIFT 5
CFIL_BEHAVIOR_FLAG_PRESERVE_CONNECTIONS 0x00000001
__CONTENT_FILTER_H__ None
CONTENT_FILTER_CONTROL_NAME "com.apple.content-filter"
CFIL_SOCK_ID_NONE UINT64_MAX
CFIL_OPT_NECP_CONTROL_UNIT 1
CFIL_OPT_GET_SOCKET_INFO 2
CFIL_OPT_PRESERVE_CONNECTIONS 3
CFIL_MAX_FILTER_COUNT 8
CFIL_CRYPTO 1
CFIL_CRYPTO_SIGNATURE_SIZE 32
CFIL_CRYPTO_DATA_EVENT 1
CFIL_RESPONSIBLE_PID_SUPPORT 1
CFM_TYPE_EVENT 1
CFM_TYPE_ACTION 2
CFM_OP_SOCKET_ATTACHED 1
CFM_OP_SOCKET_CLOSED 2
CFM_OP_DATA_OUT 3
CFM_OP_DATA_IN 4
CFM_OP_DISCONNECT_OUT 5
CFM_OP_DISCONNECT_IN 6
CFM_OP_STATS 7
CFM_OP_DATA_UPDATE 16
CFM_OP_DROP 17
CFM_OP_BLESS_CLIENT 18
CFM_OP_SET_CRYPTO_KEY 19
CFM_VERSION_CURRENT 1
CFS_CONNECTION_DIR_IN 0
CFS_CONNECTION_DIR_OUT 1
CFS_REAL_AUDIT_TOKEN 1
CFS_MAX_DOMAIN_NAME_LENGTH 256
CFD_DATA_FLAG_IP_HEADER 0x00000001
CFIL_DATA_HAS_DELEGATED_PID 1
CFI_MAX_TIME_LOG_ENTRY 6
CFC_CLOSED_EVENT_LADDR 1
CFM_MAX_OFFSET UINT64_MAX
M_SKIPCFIL M_PROTO5
CFIL_LOG(level, fmt, ...) do { 	if (cfil_log_level >= level) 	        os_log(OS_LOG_DEFAULT, "%s:%d " fmt "\n",	                __FUNCTION__, __LINE__, ##__VA_ARGS__); } while (0)
CFIL_CRYPTO_LOG(level, fmt, ...) do {     if (cfil_log_level >= level) 	printf("%s:%d " fmt "\n",	    __FUNCTION__, __LINE__, ##__VA_ARGS__); } while (0)
CFIL_CRYPTO_LOG_4BYTES(name) CFIL_CRYPTO_LOG(LOG_DEBUG, 	            "%s \t%s: %hhX %hhX %hhX %hhX", 	            prefix, name, ptr[0], ptr[1], ptr[2], ptr[3])
CFIL_CRYPTO_LOG_8BYTES(name) CFIL_CRYPTO_LOG(LOG_DEBUG, 	            "%s \t%s: %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX", 	            prefix, name, ptr[0], ptr[1], ptr[2], ptr[3], ptr[4], ptr[5], ptr[6], ptr[7])
CFIL_CRYPTO_LOG_16BYTES(name) CFIL_CRYPTO_LOG(LOG_DEBUG, 	        "%s \t%s: %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX", 	        prefix, name, ptr[0], ptr[1], ptr[2], ptr[3], ptr[4], ptr[5], ptr[6], ptr[7], ptr[8], ptr[9], ptr[10], ptr[11], ptr[12], ptr[13], ptr[14], ptr[15])
CFIL_CRYPTO_LOG_28BYTES(name) CFIL_CRYPTO_LOG(LOG_DEBUG, 	            "%s \t%s: %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX", 	            prefix, name, ptr[0], ptr[1], ptr[2], ptr[3], ptr[4], ptr[5], ptr[6], ptr[7], ptr[8], ptr[9], ptr[10], ptr[11], ptr[12], ptr[13], ptr[14], ptr[15], ptr[16], ptr[17], ptr[18], ptr[19], ptr[20], ptr[21], ptr[22], ptr[23], ptr[24], ptr[25], ptr[26], ptr[27])
CFIL_CRYPTO_LOG_32BYTES(name, prefix)     CFIL_CRYPTO_LOG(LOG_DEBUG, 	            "%s \t%s: %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX %hhX", 	            prefix, name, ptr[0], ptr[1], ptr[2], ptr[3], ptr[4], ptr[5], ptr[6], ptr[7], ptr[8], ptr[9], ptr[10], ptr[11], ptr[12], ptr[13], ptr[14], ptr[15], ptr[16], ptr[17], ptr[18], ptr[19], ptr[20], ptr[21], ptr[22], ptr[23], ptr[24], ptr[25], ptr[26], ptr[27], ptr[28], ptr[29], ptr[30], ptr[31])
__content_filter_crypto_h None
_NET_DEVTIMER_H None
DLIL_INPUT_CHECK(m, ifp) {                                      	ifnet_ref_t _rcvif = mbuf_pkthdr_rcvif(m);                      	if (_rcvif == NULL || (ifp != lo_ifp && _rcvif != ifp) ||       	    !(mbuf_flags(m) & MBUF_PKTHDR)) {                           	        panic_plain("%s: invalid mbuf %p\n", __func__, m);      	                                        	}                                                               }
TMP_IF_PROTO_ARR_SIZE 10
CASE_STRINGIFY(x) case x: return #x
DUMP_BUF_CHK() {        	clen -= k;              	if (clen < 1)           	        goto done;      	c += k;                 }
DLIL_H None
DLIL_DESC_ETYPE2 4
DLIL_DESC_SAP 5
DLIL_DESC_SNAP 6
net_timercmp(tvp, uvp, cmp)                                     	(((tvp)->tv_sec == (uvp)->tv_sec) ?                             	((tvp)->tv_nsec cmp (uvp)->tv_nsec) :                           	((tvp)->tv_sec cmp (uvp)->tv_sec))
net_timeradd(tvp, uvp, vvp) do {                                	(vvp)->tv_sec = (tvp)->tv_sec + (uvp)->tv_sec;                  	(vvp)->tv_nsec = (tvp)->tv_nsec + (uvp)->tv_nsec;               	if ((vvp)->tv_nsec >= (long)NSEC_PER_SEC) {                     	        (vvp)->tv_sec++;                                        	        (vvp)->tv_nsec -= NSEC_PER_SEC;                         	}                                                               } while (0)
net_timersub(tvp, uvp, vvp) do {                                	(vvp)->tv_sec = (tvp)->tv_sec - (uvp)->tv_sec;                  	(vvp)->tv_nsec = (tvp)->tv_nsec - (uvp)->tv_nsec;               	if ((vvp)->tv_nsec < 0) {                                       	        (vvp)->tv_sec--;                                        	        (vvp)->tv_nsec += NSEC_PER_SEC;                         	}                                                               } while (0)
net_timerusec(tvp, nsp) do {                                    	*(nsp) = (tvp)->tv_nsec / NSEC_PER_USEC;                        	if ((tvp)->tv_sec > 0)                                          	        *(nsp) += ((tvp)->tv_sec * USEC_PER_SEC);               } while (0)
net_timernsec(tvp, nsp) do {                                    	*(nsp) = (tvp)->tv_nsec;                                        	if ((tvp)->tv_sec > 0)                                          	        *(nsp) += ((tvp)->tv_sec * NSEC_PER_SEC);               } while (0)
net_nsectimer(nsp, tvp) do {                                    	u_int64_t __nsp = *(nsp);                                       	net_timerclear(tvp);                                            	uint64_t __sec = __nsp / NSEC_PER_SEC;                          	(tvp)->tv_sec = (__darwin_time_t)__sec;                         	(tvp)->tv_nsec = (long)(__nsp - __sec * NSEC_PER_SEC);          } while (0)
DLIL_THREADNAME_LEN 32
DLIL_INPUT_RUNNING 0x80000000
DLIL_INPUT_WAITING 0x40000000
DLIL_PROTO_REGISTER 0x20000000
DLIL_PROTO_WAITING 0x10000000
DLIL_INPUT_TERMINATE 0x08000000
DLIL_INPUT_TERMINATE_COMPLETE 0x04000000
DLIL_INPUT_EMBRYONIC 0x00000001
DLIL_IFF_TSO 0x01
DLIL_IFF_INTERNAL 0x02
DLIL_IFF_BRIDGE 0x04
NET_THREAD_HELD_PF 0x1
NET_THREAD_HELD_DOMAIN 0x2
NET_THREAD_CKREQ_LLADDR 0x4
DLIL_OUTPUT_FLAGS_NONE 0x0
DLIL_OUTPUT_FLAGS_RAW 0x1
DLIL_OUTPUT_FLAGS_SKIP_IF_FILTERS 0x2
PROTO_HASH_SLOTS 4
MAX_KNOWN_MBUF_CLASS 8
DLIL_EWMA(old, new, decay) do {                                 	u_int32_t _avg;                                                 	if ((_avg = (old)) > 0)                                         	        _avg = (((_avg << (decay)) - _avg) + (new)) >> (decay); 	else                                                            	        _avg = (new);                                           	(old) = _avg;                                                   } while (0)
MBUF_QUEUE_IS_OVERCOMMITTED(q) __improbable(MAX(if_rcvq_burst_limit, qlimit(q)) < qlen(q) &&           	                        qtype(q) == QP_MBUF)
DLIF_ZONE_NAME "ifnet"
DLIF_TCPSTAT_ZONE_NAME "ifnet_tcpstat"
DLIF_UDPSTAT_ZONE_NAME "ifnet_udpstat"
MAX_DUMP_BUF 32
IF_SNDQ_MINLEN 32
IF_RCVQ_BURST_LIMIT_MIN 1024
IF_RCVQ_BURST_LIMIT_DEFAULT 8192
IF_RCVQ_BURST_LIMIT_MAX 32768
IF_RCVQ_TRIM_PCT_MIN 20
IF_RCVQ_TRIM_PCT_DEFAULT 80
IF_RCVQ_TRIM_PCT_MAX 100
IF_RXPOLL_DECAY 2
IF_RXPOLL_INTERVAL_PKTS 0
IF_RXPOLL_WLOWAT 10
IF_RXPOLL_WHIWAT 100
DLIL_SYSCTL_H None
IF_RCVQ_MINLEN 32
IF_RCVQ_MAXLEN 256
HWCKSUM_DBG_PARTIAL_FORCED 0x1
HWCKSUM_DBG_PARTIAL_RXOFF_ADJ 0x2
HWCKSUM_DBG_FINALIZE_FORCED 0x10
DLIL_VAR_PRIVATE_H None
DBG_LAYER_BEG DLILDBG_CODE(DBG_DLIL_STATIC, 0)
DBG_LAYER_END DLILDBG_CODE(DBG_DLIL_STATIC, 2)
DBG_FNC_DLIL_INPUT DLILDBG_CODE(DBG_DLIL_STATIC, (1 << 8))
DBG_FNC_DLIL_OUTPUT DLILDBG_CODE(DBG_DLIL_STATIC, (2 << 8))
DBG_FNC_DLIL_IFOUT DLILDBG_CODE(DBG_DLIL_STATIC, (3 << 8))
IF_DATA_REQUIRE_ALIGNED_64(f) _CASSERT(!(offsetof(struct if_data_internal, f) % sizeof (u_int64_t)))
IFNET_IF_DATA_REQUIRE_ALIGNED_64(f) _CASSERT(!(offsetof(struct ifnet, if_data.f) % sizeof (u_int64_t)))
DLIL_PRINTF printf
DLIF_INUSE 0x1
DLIF_REUSE 0x2
DLIF_DEBUG 0x4
IF_REF_TRACE_HIST_SIZE 8
DROPTAP_MAXUNIT IF_MAXUNIT
_NET_DROPTAP_H_ None
DROPTAP_IFNAME "droptap"
DROPTAP_DROPFUNC_MAXLEN 64
DROP_COMPONENT_MASK 0x0f000000
DROP_COMPONENT_OFFSET 24
DROP_COMPONENT_MAX 0x0f
DROP_DOMAIN_MASK 0x00ff0000
DROP_DOMAIN_OFFSET 16
DROP_DOMAIN_MAX 0xff
DROP_CODE_MASK 0x0000ffff
DROP_CODE_OFFSET 0
DROP_CODE_MAX 0xffff
DROP_REASON(component, domain, code) 	(((unsigned)((component) &   0x0f) << DROP_COMPONENT_OFFSET) | 	 ((unsigned)((domain)    &   0xff) << DROP_DOMAIN_OFFSET)    | 	 ((unsigned)((code)      & 0xffff) << DROP_CODE_OFFSET))
DROPTAP_SKYWALK 1
DROPTAP_BSD 2
DROPTAP_FSW 1
DROPTAP_NETIF 2
_DROPTAP_PAD_3 3
_DROPTAP_PAD_4 4
DROPTAP_AQM 5
DROPTAP_TCP 1
DROPTAP_UDP 2
DROPTAP_IP 3
DROPTAP_SOCK 4
DROPTAP_DLIL 5
DROPTAP_IPSEC 6
DROPTAP_IP6 7
DROPTAP_MPTCP 8
DROPTAP_UNSPEC 0
DROP_REASON_LIST X(DROP_REASON_UNSPECIFIED,                  DROPTAP_UNSPEC,  DROPTAP_UNSPEC, DROPTAP_UNSPEC, "Drop reason not specified")    	                                                                                                      	X(DROP_REASON_FSW_PP_ALLOC_FAILED,          DROPTAP_SKYWALK, DROPTAP_FSW,  1,  "Flowswitch packet alloc failed")             	X(DROP_REASON_RX_DST_RING_FULL,             DROPTAP_SKYWALK, DROPTAP_FSW,  2,  "Flowswitch Rx destination ring full")        	X(DROP_REASON_FSW_QUIESCED,                 DROPTAP_SKYWALK, DROPTAP_FSW,  3,  "Flowswitch detached")                        	X(DROP_REASON_FSW_IFNET_NOT_ATTACHED,       DROPTAP_SKYWALK, DROPTAP_FSW,  4,  "Flowswitch ifnet not attached")              	X(DROP_REASON_FSW_DEMUX_FAILED,             DROPTAP_SKYWALK, DROPTAP_FSW,  5,  "Flowswitch demux error")                     	X(DROP_REASON_FSW_TX_DEVPORT_NOT_ATTACHED,  DROPTAP_SKYWALK, DROPTAP_FSW,  6,  "Flowswitch destination nexus port inactive") 	X(DROP_REASON_FSW_TX_FLOW_EXTRACT_FAILED,   DROPTAP_SKYWALK, DROPTAP_FSW,  7,  "Flowswitch flow extract error")              	X(DROP_REASON_FSW_TX_FRAG_BAD_CONT,         DROPTAP_SKYWALK, DROPTAP_FSW,  8,  "Flowswitch invalid continuation fragment")   	X(DROP_REASON_FSW_TX_FLOW_NOT_FOUND,        DROPTAP_SKYWALK, DROPTAP_FSW,  9,  "Flowswitch flow lookup failed")              	X(DROP_REASON_FSW_TX_RESOLV_PENDING,        DROPTAP_SKYWALK, DROPTAP_FSW,  10, "Flowswitch resolution pending")              	X(DROP_REASON_FSW_TX_RESOLV_FAILED,         DROPTAP_SKYWALK, DROPTAP_FSW,  11, "Flowswitch resolution failed")               	X(DROP_REASON_FSW_FLOW_NONVIABLE,           DROPTAP_SKYWALK, DROPTAP_FSW,  12, "Flowswitch flow not viable")                 	X(DROP_REASON_FSW_RX_RING_NOT_FOUND,        DROPTAP_SKYWALK, DROPTAP_FSW,  13, "Flowswitch Rx ring not found")               	X(DROP_REASON_FSW_RX_PKT_NOT_FINALIZED,     DROPTAP_SKYWALK, DROPTAP_FSW,  14, "Flowswitch packet not finalized")            	X(DROP_REASON_FSW_FLOW_TRACK_ERR,           DROPTAP_SKYWALK, DROPTAP_FSW,  15, "Flowswitch flow tracker error")              	X(DROP_REASON_FSW_PKT_COPY_FAILED,          DROPTAP_SKYWALK, DROPTAP_FSW,  16, "Flowswitch packet copy failed")              	X(DROP_REASON_FSW_GSO_FAILED,               DROPTAP_SKYWALK, DROPTAP_FSW,  17, "Flowswitch GSO failed")                      	X(DROP_REASON_FSW_GSO_NOMEM_PKT,            DROPTAP_SKYWALK, DROPTAP_FSW,  18, "Flowswitch GSO not enough packet memory")    	X(DROP_REASON_FSW_GSO_NOMEM_MBUF,           DROPTAP_SKYWALK, DROPTAP_FSW,  19, "Flowswitch GSO not enough mbuf memory")      	X(DROP_REASON_FSW_DST_NXPORT_INVALID,       DROPTAP_SKYWALK, DROPTAP_FSW,  20, "Flowswitch dst nexus port invalid")          	X(DROP_REASON_AQM_FULL,                     DROPTAP_SKYWALK, DROPTAP_AQM,  1,  "AQM full")                                   	X(DROP_REASON_AQM_COMPRESSED,               DROPTAP_SKYWALK, DROPTAP_AQM,  2,  "AQM compressed")                             	X(DROP_REASON_AQM_BK_SYS_THROTTLED,         DROPTAP_SKYWALK, DROPTAP_AQM,  3,  "AQM BK_SYS throttled")                       	X(DROP_REASON_AQM_PURGE_FLOW,               DROPTAP_SKYWALK, DROPTAP_AQM,  4,  "AQM purge flow")                             	X(DROP_REASON_AQM_DROP,                     DROPTAP_SKYWALK, DROPTAP_AQM,  5,  "AQM drop")                                   	                                                                                                                 	X(DROP_REASON_FULL_SOCK_RCVBUF,             DROPTAP_BSD,     DROPTAP_SOCK, 1,  "Socket receive buffer full")                 	                                                                                                                   	X(DROP_REASON_DLIL_BURST_LIMIT,             DROPTAP_BSD,     DROPTAP_DLIL, 1,  "DLIL burst limit exceeded")                  	X(DROP_REASON_DLIL_ENQUEUE_INVALID,         DROPTAP_BSD,     DROPTAP_DLIL, 2,  "DLIL enqueue invalid")                       	X(DROP_REASON_DLIL_ENQUEUE_IF_NOT_ATTACHED, DROPTAP_BSD,     DROPTAP_DLIL, 3,  "DLIL enqueue interface not fully attached")  	X(DROP_REASON_DLIL_ENQUEUE_IF_NOT_UP,       DROPTAP_BSD,     DROPTAP_DLIL, 4,  "DLIL enqueue interface not up")              	X(DROP_REASON_DLIL_IF_FILTER,               DROPTAP_BSD,     DROPTAP_DLIL, 5,  "DLIL interface filter")                      	X(DROP_REASON_DLIL_IF_DATAMOV_BEGIN,        DROPTAP_BSD,     DROPTAP_DLIL, 6,  "DLIL interface datamove begin")              	X(DROP_REASON_DLIL_CLAT64,                  DROPTAP_BSD,     DROPTAP_DLIL, 7,  "DLIL CLAT46")                                	X(DROP_REASON_DLIL_PROMISC,                 DROPTAP_BSD,     DROPTAP_DLIL, 8,  "DLIL promiscuous")                           	X(DROP_REASON_DLIL_NO_PROTO,                DROPTAP_BSD,     DROPTAP_DLIL, 9,  "DLIL no protocol")                           	X(DROP_REASON_DLIL_PRE_OUTPUT,              DROPTAP_BSD,     DROPTAP_DLIL, 10, "DLIL pre output")                            	X(DROP_REASON_DLIL_IF_FRAMER,               DROPTAP_BSD,     DROPTAP_DLIL, 11, "DLIL interface framer")                      	X(DROP_REASON_DLIL_TSO_NOT_OK,              DROPTAP_BSD,     DROPTAP_DLIL, 12, "DLIL interface TSO not OK")                  	                                                                                                                  	X(DROP_REASON_MPTCP_INPUT_MALFORMED,        DROPTAP_BSD,     DROPTAP_MPTCP,1,  "MPTCP input packet malformed")               	                                                                                                                    	X(DROP_REASON_TCP_RST,                      DROPTAP_BSD,     DROPTAP_TCP,  1,  "TCP connection reset")                       	X(DROP_REASON_TCP_REASSEMBLY_ALLOC,         DROPTAP_BSD,     DROPTAP_TCP,  2,  "TCP reassembly allocation")                  	X(DROP_REASON_TCP_NECP,                     DROPTAP_BSD,     DROPTAP_TCP,  3,  "TCP NECP not allowed")                       	X(DROP_REASON_TCP_PKT_UNSENT,               DROPTAP_BSD,     DROPTAP_TCP,  4,  "TCP unsent packet")                          	X(DROP_REASON_TCP_SRC_ADDR_NOT_AVAIL,       DROPTAP_BSD,     DROPTAP_TCP,  5,  "TCP source address not available")           	X(DROP_REASON_TCP_REASS_OVERFLOW,           DROPTAP_BSD,     DROPTAP_TCP,  6,  "TCP reassembly queue overflow")              	X(DROP_REASON_TCP_CHECKSUM_INCORRECT,       DROPTAP_BSD,     DROPTAP_TCP,  7,  "TCP checksum incorrect")                     	X(DROP_REASON_TCP_SRC_ADDR_UNSPECIFIED,     DROPTAP_BSD,     DROPTAP_TCP,  8,  "TCP source address unspecified")             	X(DROP_REASON_TCP_OFFSET_INCORRECT,         DROPTAP_BSD,     DROPTAP_TCP,  9,  "TCP offset incorrect")                       	X(DROP_REASON_TCP_SYN_FIN,                  DROPTAP_BSD,     DROPTAP_TCP,  10, "TCP SYN with FIN")                           	X(DROP_REASON_TCP_NO_SOCK,                  DROPTAP_BSD,     DROPTAP_TCP,  11, "TCP no socket")                              	X(DROP_REASON_TCP_PCB_MISMATCH,             DROPTAP_BSD,     DROPTAP_TCP,  12, "TCP protocol control block mismatch")        	X(DROP_REASON_TCP_NO_PCB,                   DROPTAP_BSD,     DROPTAP_TCP,  13, "TCP no protocol control block")              	X(DROP_REASON_TCP_CLOSED,                   DROPTAP_BSD,     DROPTAP_TCP,  14, "TCP state CLOSED")                           	X(DROP_REASON_TCP_FLAGS_INCORRECT,          DROPTAP_BSD,     DROPTAP_TCP,  15, "TCP flags incorrect")                        	X(DROP_REASON_TCP_LISTENER_CLOSING,         DROPTAP_BSD,     DROPTAP_TCP,  16, "TCP listener closing")                       	X(DROP_REASON_TCP_SYN_RST,                  DROPTAP_BSD,     DROPTAP_TCP,  17, "TCP SYN with RST")                           	X(DROP_REASON_TCP_SYN_ACK_LISTENER,         DROPTAP_BSD,     DROPTAP_TCP,  18, "TCP SYN with ACK for listener")              	X(DROP_REASON_TCP_LISTENER_NO_SYN,          DROPTAP_BSD,     DROPTAP_TCP,  19, "TCP no SYN for listener")                    	X(DROP_REASON_TCP_SAME_PORT,                DROPTAP_BSD,     DROPTAP_TCP,  20, "TCP same source and destination ports")      	X(DROP_REASON_TCP_BCAST_MCAST,              DROPTAP_BSD,     DROPTAP_TCP,  21, "TCP address not unicast")                    	X(DROP_REASON_TCP_DEPRECATED_ADDR,          DROPTAP_BSD,     DROPTAP_TCP,  22, "TCP address deprecated")                     	X(DROP_REASON_TCP_LISTENER_DROP,            DROPTAP_BSD,     DROPTAP_TCP,  23, "TCP listener drop")                          	X(DROP_REASON_TCP_PCB_HASH_FAILED,          DROPTAP_BSD,     DROPTAP_TCP,  24, "TCP protocol control block hash")            	X(DROP_REASON_TCP_CONTENT_FILTER_ATTACH,    DROPTAP_BSD,     DROPTAP_TCP,  25, "TCP control filter attach")                  	X(DROP_REASON_TCP_BIND_IN_PROGRESS,         DROPTAP_BSD,     DROPTAP_TCP,  26, "TCP bind in progress")                       	X(DROP_REASON_TCP_MEM_ALLOC,                DROPTAP_BSD,     DROPTAP_TCP,  27, "TCP memory allocation")                      	X(DROP_REASON_TCP_PCB_CONNECT,              DROPTAP_BSD,     DROPTAP_TCP,  28, "TCP protocol control block connect")         	X(DROP_REASON_TCP_SYN_RECEIVED_BAD_ACK,     DROPTAP_BSD,     DROPTAP_TCP,  29, "TCP SYN_RECEIVED bad ACK")                   	X(DROP_REASON_TCP_SYN_SENT_BAD_ACK,         DROPTAP_BSD,     DROPTAP_TCP,  30, "TCP SYN_SENT bad ACK")                       	X(DROP_REASON_TCP_SYN_SENT_NO_SYN,          DROPTAP_BSD,     DROPTAP_TCP,  31, "TCP SYN_SENT no SYN")                        	X(DROP_REASON_TCP_ACK_TOOMUCH,              DROPTAP_BSD,     DROPTAP_TCP,  32, "TCP ACK rate limit")                         	X(DROP_REASON_TCP_OLD_ACK,                  DROPTAP_BSD,     DROPTAP_TCP,  33, "TCP challenge ACK")                          	X(DROP_REASON_TCP_SYN_DATA_INVALID,         DROPTAP_BSD,     DROPTAP_TCP,  34, "TCP SYN data invalid")                       	X(DROP_REASON_TCP_SYN_RECEIVED_BAD_SEQ,     DROPTAP_BSD,     DROPTAP_TCP,  35, "TCP SYN_RECEIVED bad sequence number")       	X(DROP_REASON_TCP_RECV_AFTER_CLOSE,         DROPTAP_BSD,     DROPTAP_TCP,  36, "TCP receive after close")                    	X(DROP_REASON_TCP_BAD_ACK,                  DROPTAP_BSD,     DROPTAP_TCP,  37, "TCP bad ACK")                                	X(DROP_REASON_TCP_BAD_RST,                  DROPTAP_BSD,     DROPTAP_TCP,  38, "TCP bad RST")                                	X(DROP_REASON_TCP_PAWS,                     DROPTAP_BSD,     DROPTAP_TCP,  39, "TCP PAWS")                                   	X(DROP_REASON__TCP_REASS_MEMORY_PRESSURE,   DROPTAP_BSD,     DROPTAP_TCP,  40, "TCP reassembly queue memory pressure")       	                                                                                                                     	X(DROP_REASON_IP_UNKNOWN_MULTICAST_GROUP,   DROPTAP_BSD,     DROPTAP_IP,   2, "IP unknown multicast group join")             	X(DROP_REASON_IP_INVALID_ADDR,              DROPTAP_BSD,     DROPTAP_IP,   3, "Invalid IP address")                          	X(DROP_REASON_IP_TOO_SHORT,                 DROPTAP_BSD,     DROPTAP_IP,   4, "IP packet too short")                         	X(DROP_REASON_IP_TOO_SMALL,                 DROPTAP_BSD,     DROPTAP_IP,   5, "IP header too small")                         	X(DROP_REASON_IP_RCV_IF_NO_MATCH,           DROPTAP_BSD,     DROPTAP_IP,   6, "IP receive interface no match")               	X(DROP_REASON_IP_CANNOT_FORWARD,            DROPTAP_BSD,     DROPTAP_IP,   7, "IP cannot forward")                           	X(DROP_REASON_IP_BAD_VERSION,               DROPTAP_BSD,     DROPTAP_IP,   8, "IP bad version")                              	X(DROP_REASON_IP_BAD_CHECKSUM,              DROPTAP_BSD,     DROPTAP_IP,   9, "IP bad checksum")                             	X(DROP_REASON_IP_BAD_HDR_LENGTH,            DROPTAP_BSD,     DROPTAP_IP,   10, "IP bad header length")                       	X(DROP_REASON_IP_BAD_LENGTH,                DROPTAP_BSD,     DROPTAP_IP,   11, "IP bad length")                              	X(DROP_REASON_IP_BAD_TTL,                   DROPTAP_BSD,     DROPTAP_IP,   12, "IP bad TTL")                                 	X(DROP_REASON_IP_NO_PROTO,                  DROPTAP_BSD,     DROPTAP_IP,   13, "IP unknown protocol")                        	X(DROP_REASON_IP_FRAG_NOT_ACCEPTED,         DROPTAP_BSD,     DROPTAP_IP,   14, "IP fragment not accepted")                   	X(DROP_REASON_IP_FRAG_DROPPED,              DROPTAP_BSD,     DROPTAP_IP,   15, "IP fragment dropped")                        	X(DROP_REASON_IP_FRAG_TIMEOUT,              DROPTAP_BSD,     DROPTAP_IP,   16, "IP fragment timeout")                        	X(DROP_REASON_IP_FRAG_TOO_MANY,             DROPTAP_BSD,     DROPTAP_IP,   17, "IP fragment too many")                       	X(DROP_REASON_IP_FRAG_TOO_LONG,             DROPTAP_BSD,     DROPTAP_IP,   18, "IP fragment too long")                       	X(DROP_REASON_IP_FRAG_DRAINED,              DROPTAP_BSD,     DROPTAP_IP,   19, "IP fragment drained")                        	X(DROP_REASON_IP_FILTER_DROP,               DROPTAP_BSD,     DROPTAP_IP,   20, "IP filter drop")                             	X(DROP_REASON_IP_FRAG_TOO_SMALL,            DROPTAP_BSD,     DROPTAP_IP,   21, "IP too small to fragment")                   	X(DROP_REASON_IP_FRAG_NO_MEM,               DROPTAP_BSD,     DROPTAP_IP,   22, "IP no memory for fragmentation")             	X(DROP_REASON_IP_CANNOT_FRAGMENT,           DROPTAP_BSD,     DROPTAP_IP,   23, "IP cannot fragment")                         	X(DROP_REASON_IP_OUTBOUND_IPSEC_POLICY,     DROPTAP_BSD,     DROPTAP_IP,   24, "IP outbound IPsec policy")                   	X(DROP_REASON_IP_ZERO_NET,                  DROPTAP_BSD,     DROPTAP_IP,   25, "IP to network zero")                         	X(DROP_REASON_IP_SRC_ADDR_NO_AVAIL,         DROPTAP_BSD,     DROPTAP_IP,   26, "IP source address not available")            	X(DROP_REASON_IP_DST_ADDR_NO_AVAIL,         DROPTAP_BSD,     DROPTAP_IP,   27, "IP destination address not available")       	X(DROP_REASON_IP_TO_RESTRICTED_IF,          DROPTAP_BSD,     DROPTAP_IP,   28, "IP packet to a restricted interface")        	X(DROP_REASON_IP_NO_ROUTE,                  DROPTAP_BSD,     DROPTAP_IP,   29, "IP no route")                                	X(DROP_REASON_IP_IF_CANNOT_MULTICAST,       DROPTAP_BSD,     DROPTAP_IP,   30, "IP multicast not supported by interface")    	X(DROP_REASON_IP_SRC_ADDR_ANY,              DROPTAP_BSD,     DROPTAP_IP,   31, "IP source address any")                      	X(DROP_REASON_IP_IF_CANNOT_BROADCAST,       DROPTAP_BSD,     DROPTAP_IP,   32, "IP broadcast not supported by interface")    	X(DROP_REASON_IP_BROADCAST_NOT_ALLOWED,     DROPTAP_BSD,     DROPTAP_IP,   33, "IP broadcast not allowed")                   	X(DROP_REASON_IP_BROADCAST_TOO_BIG,         DROPTAP_BSD,     DROPTAP_IP,   34, "IP broadcast too big for MTU")               	X(DROP_REASON_IP_FILTER_TSO,                DROPTAP_BSD,     DROPTAP_IP,   35, "TSO packet to IP filter")                    	X(DROP_REASON_IP_NECP_POLICY_NO_ALLOW_IF,   DROPTAP_BSD,     DROPTAP_IP,   36, "NECP not allowed on interface")              	X(DROP_REASON_IP_NECP_POLICY_DROP,          DROPTAP_BSD,     DROPTAP_IP,   37, "NECP drop")                                  	X(DROP_REASON_IP_NECP_POLICY_SOCKET_DIVERT, DROPTAP_BSD,     DROPTAP_IP,   38, "NECP socket divert")                         	X(DROP_REASON_IP_NECP_POLICY_TUN_NO_ALLOW_IF, DROPTAP_BSD,   DROPTAP_IP,   39, "NECP tunnel not allowed on interface")       	X(DROP_REASON_IP_NECP_POLICY_TUN_REBIND_NO_ALLOW_IF, DROPTAP_BSD,     DROPTAP_IP,   40, "NECP rebind not allowed on interface") 	X(DROP_REASON_IP_NECP_POLICY_TUN_NO_REBIND_IF, DROPTAP_BSD,  DROPTAP_IP,   41, "NECP rebind not allowed on interface")       	X(DROP_REASON_IP_NECP_NO_ALLOW_IF,          DROPTAP_BSD,     DROPTAP_IP,   42, "NECP packet not allowed on interface")       	X(DROP_REASON_IP_ENOBUFS,                   DROPTAP_BSD,     DROPTAP_IP,   43, "IP No buffer space available")               	X(DROP_REASON_IP_ILLEGAL_PORT,              DROPTAP_BSD,     DROPTAP_IP,   44, "IP Illegal port")                            	X(DROP_REASON_IP_UNREACHABLE_PORT,          DROPTAP_BSD,     DROPTAP_IP,   45, "IP Unreachable port")                        	X(DROP_REASON_IP_MULTICAST_NO_PORT,         DROPTAP_BSD,     DROPTAP_IP,   46, "IP Multicast no port")                       	X(DROP_REASON_IP_EISCONN,                   DROPTAP_BSD,     DROPTAP_IP,   47, "IP Socket is already connected")             	X(DROP_REASON_IP_EAFNOSUPPORT,              DROPTAP_BSD,     DROPTAP_IP,   48, "IP Address family not supported by protocol family") 	X(DROP_REASON_IP_NO_SOCK,                   DROPTAP_BSD,     DROPTAP_IP,   49, "IP No matching sock") 	                                                                                                                  	X(DROP_REASON_IPSEC_REJECT,                 DROPTAP_BSD,     DROPTAP_IPSEC,1,  "IPsec reject")                               	                                                                                                                   	X(DROP_REASON_IP6_OPT_DISCARD,              DROPTAP_BSD,     DROPTAP_IP6,  1, "IPv6 discard option")                         	X(DROP_REASON_IP6_IF_IPV6_DISABLED,         DROPTAP_BSD,     DROPTAP_IP6,  2, "IPv6 is disabled on the interface")           	X(DROP_REASON_IP6_BAD_SCOPE,                DROPTAP_BSD,     DROPTAP_IP6,  3, "IPv6 bad scope")                              	X(DROP_REASON_IP6_UNPROXIED_NS,             DROPTAP_BSD,     DROPTAP_IP6,  4, "IPv6 unproxied mistargeted Neighbor Solicitation") 	X(DROP_REASON_IP6_BAD_OPTION,               DROPTAP_BSD,     DROPTAP_IP6,  5, "IPv6 bad option")                             	X(DROP_REASON_IP6_TOO_MANY_OPTIONS,         DROPTAP_BSD,     DROPTAP_IP6,  6, "IPv6 too many header options")                	X(DROP_REASON_IP6_BAD_PATH_MTU,             DROPTAP_BSD,     DROPTAP_IP6,  7, "IPv6 bad path MTU")                           	X(DROP_REASON_IP6_NO_PREFERRED_SRC_ADDR,    DROPTAP_BSD,     DROPTAP_IP6,  8, "IPv6 no preferred source address")            	X(DROP_REASON_IP6_BAD_HLIM,                 DROPTAP_BSD,     DROPTAP_IP6,  9, "IPv6 bad HLIM")                               	X(DROP_REASON_IP6_BAD_DAD,                  DROPTAP_BSD,     DROPTAP_IP6,  10, "IPv6 bad DAD")                               	X(DROP_REASON_IP6_NO_ND6ALT_IF,             DROPTAP_BSD,     DROPTAP_IP6,  11, "IPv6 no ND6ALT interface")                   	X(DROP_REASON_IP6_BAD_ND_STATE,             DROPTAP_BSD,     DROPTAP_IP6,  12, "IPv6 Bad ND state")                          	X(DROP_REASON_IP6_ONLY,                     DROPTAP_BSD,     DROPTAP_IP6,  13, "IPv6 Only")                                  	X(DROP_REASON_IP6_ADDR_UNSPECIFIED,         DROPTAP_BSD,     DROPTAP_IP6,  14, "IPv6 Address is unspecified")                	X(DROP_REASON_IP6_FRAG_OVERLAPPING,         DROPTAP_BSD,     DROPTAP_IP6,  15, "IPv6 Fragment overlaping")                   	X(DROP_REASON_IP6_FRAG_MIXED_CE,            DROPTAP_BSD,     DROPTAP_IP6,  16, "IPv6 Fragment mixed CE bits")                	                                                                                                                    	X(DROP_REASON_UDP_SET_PORT_FAILURE,         DROPTAP_BSD,     DROPTAP_UDP,  1, "UDP failed to set ephemeral port ")           	X(DROP_REASON_UDP_DST_PORT_ZERO,            DROPTAP_BSD,     DROPTAP_UDP,  2, "UDP destination port zero")                   	X(DROP_REASON_UDP_BAD_LENGTH,               DROPTAP_BSD,     DROPTAP_UDP,  3, "UDP bad length")                              	X(DROP_REASON_UDP_BAD_CHECKSUM,             DROPTAP_BSD,     DROPTAP_UDP,  4, "UDP bad checksum")                            	X(DROP_REASON_UDP_PORT_UNREACHEABLE,        DROPTAP_BSD,     DROPTAP_UDP,  5, "UDP port unreachable")                        	X(DROP_REASON_UDP_SOCKET_CLOSING,           DROPTAP_BSD,     DROPTAP_UDP,  6, "UDP socket closing")                          	X(DROP_REASON_UDP_NECP,                     DROPTAP_BSD,     DROPTAP_UDP,  7, "UDP denied by NECP")                          	X(DROP_REASON_UDP_CANNOT_SAVE_CONTROL,      DROPTAP_BSD,     DROPTAP_UDP,  8, "UDP cannot save control mbufs")               	X(DROP_REASON_UDP_IPSEC,                    DROPTAP_BSD,     DROPTAP_UDP,  9, "UDP IPsec")
X(reason, component, domain, code, ...) 	reason = DROP_REASON(component, domain, code),
X(reason, ...) 	case (reason): return #reason;
DROPTAP_FLAG_DIR_IN 0x0001
DROPTAP_FLAG_DIR_OUT 0x0002
DROPTAP_FLAG_L2_MISSING 0x0004
_ETHERDEFS_ None
_NET_ETHERNET_H_ None
ETHER_ADDR_LEN 6
ETHER_TYPE_LEN 2
ETHER_CRC_LEN 4
ETHER_MIN_LEN 64
ETHER_MAX_LEN 1518
ETHER_ALIGN 2
ether_addr_octet octet
ETHERTYPE_PUP 0x0200
ETHERTYPE_IP 0x0800
ETHERTYPE_ARP 0x0806
ETHERTYPE_REVARP 0x8035
ETHERTYPE_VLAN 0x8100
ETHERTYPE_IPV6 0x86dd
ETHERTYPE_PAE 0x888e
ETHERTYPE_RSN_PREAUTH 0x88c7
ETHERTYPE_PTP 0x88f7
ETHERTYPE_LOOPBACK 0x9000
ETHERTYPE_TRAIL 0x1000
ETHERTYPE_NTRAILER 16
etherbroadcastaddr fugly
_NET_ETHER_IF_MODULE_H None
_ip_copy(dst, src)      	bcopy(src, dst, sizeof (struct in_addr))
_NET_FIREWIRE_H_ None
FIREWIRE_EUI64_LEN 8
FIREWIRE_TYPE_LEN 2
FIREWIRE_MIN_LEN 64
FIREWIRE_MAX_LEN 4096
FIREWIRE_ADDR_LEN 16
FADV_CACHE_NAME "flowadv"
_NET_FLOWADV_H_ None
FADV_SUCCESS 0
FADV_FLOW_CONTROLLED 1
FADV_SUSPENDED 2
ROTL32(x, r)    (((x) << (r)) | ((x) >> (32 - (r))))
ROTL64(x, r)    (((x) << (r)) | ((x) >> (64 - (r))))
MH3_X86_32_C1 0xcc9e2d51
MH3_X86_32_C2 0x1b873593
MH3_X64_128_C1 0x87c37b91114253d5LLU
MH3_X64_128_C2 0x4cf5ad432745937fLLU
JHASH_INIT 0xdeadbeef
JHASH_MIX(a, b, c) {                    	a -= c;  a ^= ROTL32(c, 4);   c += b;   	b -= a;  b ^= ROTL32(a, 6);   a += c;   	c -= b;  c ^= ROTL32(b, 8);   b += a;   	a -= c;  a ^= ROTL32(c, 16);  c += b;   	b -= a;  b ^= ROTL32(a, 19);  a += c;   	c -= b;  c ^= ROTL32(b, 4);   b += a;   }
JHASH_FINAL(a, b, c) {                  	c ^= b;  c -= ROTL32(b, 14);            	a ^= c;  a -= ROTL32(c, 11);            	b ^= a;  b -= ROTL32(a, 25);            	c ^= b;  c -= ROTL32(b, 16);            	a ^= c;  a -= ROTL32(c, 4);             	b ^= a;  b -= ROTL32(a, 14);            	c ^= b;  c -= ROTL32(b, 24);            }
_NET_FLOWHASH_H_ None
_NET_IEEE8023AD_H_ None
IEEE8023AD_SLOW_PROTO_ETHERTYPE 0x8809
IEEE8023AD_SLOW_PROTO_MULTICAST { 0x01, 0x80, 0xc2, 0x00, 0x00, 0x02 }
IEEE8023AD_SLOW_PROTO_SUBTYPE_LACP 1
IEEE8023AD_SLOW_PROTO_SUBTYPE_LA_MARKER_PROTOCOL 2
IEEE8023AD_SLOW_PROTO_SUBTYPE_RESERVED_START 3
IEEE8023AD_SLOW_PROTO_SUBTYPE_RESERVED_END 10
IFMA_ZONE_NAME "ifmultiaddr"
IFMA_TRACE_HIST_SIZE 32
INITIAL_IF_INDEXLIM 8
IF_MAXAGENTS 64
IF_AGENT_INCREMENT 8
COPYFIELD(fld) if_data->fld = if_data_int->fld
COPYFIELD32(fld) if_data->fld = (u_int32_t)(if_data_int->fld)
COPYFIELD32_ATOMIC(fld) do {                                    	uint64_t _val = 0;                                              	_val = os_atomic_load(&if_data_int->fld, relaxed); 	if_data->fld = (uint32_t) _val;                                 } while (0)
COPYFIELD64(fld) if_data64->fld = if_data_int->fld
COPYFIELD64_ATOMIC(fld) do {                                    	if_data64->fld = os_atomic_load(&if_data_int->fld, relaxed); } while (0)
COPY_IF_TC_FIELD64_ATOMIC(fld) do {                     	if_tc->fld = os_atomic_load(&ifp->if_tc.fld, relaxed); } while (0)
COPY_IF_DE_FIELD64_ATOMIC(fld) do {                     	if_de->fld = os_atomic_load(&ifp->if_data.fld, relaxed); } while (0)
COPY_IF_PS_TCP_FIELD64_ATOMIC(fld) do {                         	if_ps->ifi_tcp_##fld = os_atomic_load(&ifp->if_tcp_stat->fld, relaxed); } while (0)
COPY_IF_PS_UDP_FIELD64_ATOMIC(fld) do {                         	if_ps->ifi_udp_##fld = os_atomic_load(&ifp->if_udp_stat->fld, relaxed); } while (0)
COPY_IF_LH_FIELD64_ATOMIC(fld) do {                     	if_linkheuristics->iflh_##fld = os_atomic_load(&ifp->if_data.ifi_##fld, relaxed); } while (0)
COPY_IF_LH_TCP_FIELD64_ATOMIC(fld) do {                         	if_linkheuristics->iflh_tcp_##fld = os_atomic_load(&ifp->if_tcp_stat->fld, relaxed); } while (0)
COPY_IF_LH_UDP_FIELD64_ATOMIC(fld) do {                         	if_linkheuristics->iflh_udp_##fld = os_atomic_load(&ifp->if_udp_stat->fld, relaxed); } while (0)
INTF_STATE_TO_STRING(type) case type: return #type;
_NET_IF_H_ None
IF_NAMESIZE 16
_NET_IF_ARP_H_ None
ARPHRD_ETHER 1
ARPHRD_IEEE802 6
ARPHRD_FRELAY 15
ARPHRD_IEEE1394 24
ARPHRD_IEEE1394_EUI64 27
ARPOP_REQUEST 1
ARPOP_REPLY 2
ARPOP_REVREQUEST 3
ARPOP_REVREPLY 4
ARPOP_INVREQUEST 8
ARPOP_INVREPLY 9
ATF_INUSE 0x01
ATF_COM 0x02
ATF_PERM 0x04
ATF_PUBL 0x08
ATF_USETRAILERS 0x10
BOND_MAXUNIT 128
BOND_ZONE_MAX_ELEM MIN(IFNETS_MAX, BOND_MAXUNIT)
BONDNAME "bond"
EA_FORMAT "%x:%x:%x:%x:%x:%x"
EA_CH(e, i)     ((u_char)((u_char *)(e))[(i)])
EA_LIST(ea) EA_CH(ea,0),EA_CH(ea,1),EA_CH(ea,2),EA_CH(ea,3),EA_CH(ea,4),EA_CH(ea,5)
BD_DBGF_LIFECYCLE 0x0001
BD_DBGF_INPUT 0x0002
BD_DBGF_OUTPUT 0x0004
BD_DBGF_LACP 0x0008
BOND_LOG(__level, __dbgf, __string, ...)              	do {                                                            	        if (__level <= if_bond_log_level ||                   	            BOND_DBGF_ENABLED(__dbgf)) {                      	                os_log(OS_LOG_DEFAULT, "%s: " __string, 	                       __func__, ## __VA_ARGS__);       	        }                                                       	} while (0)
BOND_LOG_SIMPLE(__level, __dbgf, __string, ...)               	do {                                                    	        if (__level <= if_bond_log_level ||           	            BOND_DBGF_ENABLED(__dbgf)) {                      	                os_log(OS_LOG_DEFAULT, __string, ## __VA_ARGS__); 	        }                                                               	} while (0)
PORT_CONTROL_FLAGS_IN_LIST 0x01
PORT_CONTROL_FLAGS_PROTO_ATTACHED 0x02
PORT_CONTROL_FLAGS_LLADDR_SET 0x04
PORT_CONTROL_FLAGS_MTU_SET 0x08
PORT_CONTROL_FLAGS_PROMISCUOUS_SET 0x10
PORT_CONTROL_FLAGS_BOND_PROMISCUOUS_SET 0x20
IFBF_PROMISC 0x1
IFBF_IF_DETACHING 0x2
IFBF_LLADDR 0x4
IFBF_CHANGE_IN_PROGRESS 0x8
BONDPORT_FLAGS_NTT 0x01
BONDPORT_FLAGS_READY 0x02
BONDPORT_FLAGS_SELECTED_CHANGED 0x04
BONDPORT_FLAGS_MUX_ATTACHED 0x08
BONDPORT_FLAGS_DISTRIBUTING 0x10
BONDPORT_FLAGS_UNUSED2 0x20
BONDPORT_FLAGS_UNUSED3 0x40
BONDPORT_FLAGS_UNUSED4 0x80
BOND_HASH_L3_HEADER 0
_FORCE_LINK_EVENT_INTERVAL 1
_NET_IF_BOND_VAR_H_ None
IF_BOND_OP_ADD_INTERFACE 1
IF_BOND_OP_REMOVE_INTERFACE 2
IF_BOND_OP_GET_STATUS 3
IF_BOND_OP_SET_VERBOSE 4
IF_BOND_OP_SET_MODE 5
IF_BOND_MODE_LACP 0
IF_BOND_MODE_STATIC 1
IF_BOND_STATUS_SELECTED_STATE_UNSELECTED 0
IF_BOND_STATUS_SELECTED_STATE_SELECTED 1
IF_BOND_STATUS_SELECTED_STATE_STANDBY 2
IF_BOND_STATUS_REQ_VERSION 1
ibsr_buffer ibsr_ibsru.ibsru_buffer
_IP_VHL None
__M_FLAGS_ARE_SET(m, flags)     (((m)->m_flags & (flags)) != 0)
IS_BCAST(m) __M_FLAGS_ARE_SET(m, M_BCAST)
IS_MCAST(m) __M_FLAGS_ARE_SET(m, M_MCAST)
IS_BCAST_MCAST(m) __M_FLAGS_ARE_SET(m, M_BCAST | M_MCAST)
HTONS_ETHERTYPE_ARP htons(ETHERTYPE_ARP)
HTONS_ETHERTYPE_IP htons(ETHERTYPE_IP)
HTONS_ETHERTYPE_IPV6 htons(ETHERTYPE_IPV6)
HTONS_ARPHRD_ETHER htons(ARPHRD_ETHER)
HTONS_ARPOP_REQUEST htons(ARPOP_REQUEST)
HTONS_ARPOP_REPLY htons(ARPOP_REPLY)
HTONS_IPPORT_BOOTPC htons(IPPORT_BOOTPC)
HTONS_IPPORT_BOOTPS htons(IPPORT_BOOTPS)
HTONS_DHCP_FLAGS_BROADCAST htons(DHCP_FLAGS_BROADCAST)
BR_DBGF_LIFECYCLE 0x0001
BR_DBGF_INPUT 0x0002
BR_DBGF_OUTPUT 0x0004
BR_DBGF_RT_TABLE 0x0008
BR_DBGF_DELAYED_CALL 0x0010
BR_DBGF_IOCTL 0x0020
BR_DBGF_MBUF 0x0040
BR_DBGF_MCAST 0x0080
BR_DBGF_HOSTFILTER 0x0100
BR_DBGF_CHECKSUM 0x0200
BR_DBGF_MAC_NAT 0x0400
BR_DBGF_INPUT_LIST 0x0800
BRIDGE_LOG(__level, __dbgf, __string, ...)              	do {                                                            	        if (__level <= if_bridge_log_level ||                   	            BRIDGE_DBGF_ENABLED(__dbgf)) {                      	                os_log(OS_LOG_DEFAULT, "%s: " __string, 	                       __func__, ## __VA_ARGS__);       	        }                                                       	} while (0)
BRIDGE_LOG_SIMPLE(__level, __dbgf, __string, ...)               	do {                                                    	        if (__level <= if_bridge_log_level ||           	            BRIDGE_DBGF_ENABLED(__dbgf)) {                      	                os_log(OS_LOG_DEFAULT, __string, ## __VA_ARGS__); 	        }                                                               	} while (0)
_BRIDGE_LOCK(_sc) lck_mtx_lock(&(_sc)->sc_mtx)
_BRIDGE_UNLOCK(_sc) lck_mtx_unlock(&(_sc)->sc_mtx)
BRIDGE_LOCK_ASSERT_HELD(_sc) LCK_MTX_ASSERT(&(_sc)->sc_mtx, LCK_MTX_ASSERT_OWNED)
BRIDGE_LOCK_ASSERT_NOTHELD(_sc) LCK_MTX_ASSERT(&(_sc)->sc_mtx, LCK_MTX_ASSERT_NOTOWNED)
BRIDGE_LOCK_DEBUG 1
BR_LCKDBG_MAX 4
BRIDGE_LOCK(_sc) bridge_lock(_sc)
BRIDGE_UNLOCK(_sc) bridge_unlock(_sc)
BRIDGE_LOCK2REF(_sc, _err)      _err = bridge_lock2ref(_sc)
BRIDGE_UNREF(_sc) bridge_unref(_sc)
BRIDGE_XLOCK(_sc) bridge_xlock(_sc)
BRIDGE_XDROP(_sc) bridge_xdrop(_sc)
BRIDGE_BPF_TAP_IN(ifp, m) 	do {                                                            	        if (ifp->if_bpf != NULL) {                              	                bpf_tap_in(ifp, DLT_EN10MB, m, NULL, 0);        	        }                                                       	} while(0)
BRIDGE_BPF_TAP_OUT(ifp, m)                                      	do {                                                            	        if (ifp->if_bpf != NULL) {                              	                bpf_tap_out(ifp, DLT_EN10MB, m, NULL, 0);       	        }                                                       	} while(0)
BRIDGE_RTHASH_SIZE 16
BRIDGE_RTHASH_SIZE_MAX 2048
BRIDGE_RTABLE_MAX 100
BRIDGE_MAC_NAT_ENTRY_MAX 64
BRIDGE_IFCAPS_STRIP IFCAP_LRO
_EBADIP EJUSTRETURN
_EBADIPCHECKSUM EJUSTRETURN
_EBADIPV6 EJUSTRETURN
_EBADUDP EJUSTRETURN
_EBADTCP EJUSTRETURN
_EBADUDPCHECKSUM EJUSTRETURN
_EBADTCPCHECKSUM EJUSTRETURN
BIFF_PROMISC 0x01
BIFF_PROTO_ATTACHED 0x02
BIFF_FILTER_ATTACHED 0x04
BIFF_MEDIA_ACTIVE 0x08
BIFF_HOST_FILTER 0x10
BIFF_HF_HWSRC 0x20
BIFF_HF_IPSRC 0x40
BIFF_INPUT_BROADCAST 0x80
BIFF_IN_MEMBER_LIST 0x100
BIFF_WIFI_INFRA 0x200
BIFF_ALL_MULTI 0x400
BIFF_LRO_DISABLED 0x800
mne_ip mne_u.mneu_ip
mne_ip6 mne_u.mneu_ip6
MNE_FLAGS_IPV6 0x01
mnr_arp_offset mnr_u.mnru_arp_offset
mnr_ip_header_len mnr_u.mnru_ip.mnruip_header_len
mnr_ip_dhcp_flags mnr_u.mnru_ip.mnruip_dhcp_flags
mnr_ip_udp_csum mnr_u.mnru_ip.mnruip_udp_csum
mnr_ip6_icmp6_len mnr_u.mnru_ip6.mnruip6_icmp6_len
mnr_ip6_icmp6_type mnr_u.mnru_ip6.mnruip6_icmp6_type
mnr_ip6_header_len mnr_u.mnru_ip6.mnruip6_header_len
mnr_ip6_lladdr_offset mnr_u.mnru_ip6.mnruip6_lladdr_offset
brt_ifp brt_dst->bif_ifp
BDCF_OUTSTANDING 0x01
BDCF_CANCELLING 0x02
SCF_DETACHING 0x01
SCF_RESIZING 0x02
SCF_MEDIA_ACTIVE 0x04
SCF_ADDRESS_ASSIGNED 0x08
m_copypacket(m, how) m_copym(m, 0, M_COPYALL, how)
VLANTAGOF(_m) 0
BSTP_ETHERADDR_RANGE_FIRST 0x00
BSTP_ETHERADDR_RANGE_LAST 0x0f
BC_F_COPYIN 0x01
BC_F_COPYOUT 0x02
BC_F_SUSER 0x04
BRIDGENAME "bridge"
BRIDGES_MAX IF_MAXUNIT
BRIDGE_ZONE_MAX_ELEM MIN(IFNETS_MAX, BRIDGES_MAX)
BRIDGE_TSO_REDUCE_MSS_FORWARDING_MAX 256
BRIDGE_TSO_REDUCE_MSS_FORWARDING_DEFAULT 110
BRIDGE_TSO_REDUCE_MSS_TX_MAX 256
BRIDGE_TSO_REDUCE_MSS_TX_DEFAULT 0
DECL_RETURN_ADDR(v) void * __single v = __unsafe_forge_single(void *, __builtin_return_address(0))
DRVSPEC do { 	if (ifd->ifd_cmd >= bridge_control_table_size) {                	        error = EINVAL;                                         	        break;                                                  	}                                                               	bc = &bridge_control_table[ifd->ifd_cmd];                                                                                               	if (cmd == SIOCGDRVSPEC &&                                      	    (bc->bc_flags & BC_F_COPYOUT) == 0) {                       	        error = EINVAL;                                         	        break;                                                  	} else if (cmd == SIOCSDRVSPEC &&                               	    (bc->bc_flags & BC_F_COPYOUT) != 0) {                       	        error = EINVAL;                                         	        break;                                                  	}                                                                                                                                       	if (bc->bc_flags & BC_F_SUSER) {                                	        error = kauth_authorize_generic(kauth_cred_get(),       	            KAUTH_GENERIC_ISSUSER);                             	        if (error)                                              	                break;                                          	}                                                                                                                                       	if (ifd->ifd_len != bc->bc_argsize ||                           	    ifd->ifd_len > sizeof (args)) {                             	        error = EINVAL;                                         	        break;                                                  	}                                                                                                                                       	bzero(&args, sizeof (args));                                    	if (bc->bc_flags & BC_F_COPYIN) {                               	        error = copyin(ifd->ifd_data, &args, ifd->ifd_len);     	        if (error)                                              	                break;                                          	}                                                                                                                                       	BRIDGE_LOCK(sc);                                                	error = (*bc->bc_func)(sc, &args, sizeof(args));                	BRIDGE_UNLOCK(sc);                                              	if (error)                                                      	        break;                                                                                                                          	if (bc->bc_flags & BC_F_COPYOUT)                                	        error = copyout(&args, ifd->ifd_data, ifd->ifd_len);    } while (0)
BRIDGE_IOCTL_GIFS do { 	struct bridge_iflist *bif;                                      	struct ifbreq breq;                                             	char *buf, *outbuf;                                             	unsigned int count, buflen, len;                                                                                                        	count = 0;                                                      	TAILQ_FOREACH(bif, &sc->sc_iflist, bif_next)                    	        count++;                                                	TAILQ_FOREACH(bif, &sc->sc_spanlist, bif_next)                  	        count++;                                                                                                                        	buflen = sizeof (breq) * count;                                 	if (bifc->ifbic_len == 0) {                                     	        bifc->ifbic_len = buflen;                               	        return (0);                                             	}                                                               	BRIDGE_UNLOCK(sc);                                              	outbuf = kalloc_data(buflen, Z_WAITOK | Z_ZERO);                	BRIDGE_LOCK(sc);                                                                                                                        	count = 0;                                                      	buf = outbuf;                                                   	len = min(bifc->ifbic_len, buflen);                             	bzero(&breq, sizeof (breq));                                    	TAILQ_FOREACH(bif, &sc->sc_iflist, bif_next) {                  	        if (len < sizeof (breq))                                	                break;                                                                                                                  	        snprintf(breq.ifbr_ifsname, sizeof (breq.ifbr_ifsname), 	            "%s", bif->bif_ifp->if_xname);                      	                      	        error = bridge_ioctl_gifflags(sc, &breq, sizeof(breq)); 	        if (error)                                              	                break;                                          	        memcpy(buf, &breq, sizeof (breq));                      	        count++;                                                	        buf += sizeof (breq);                                   	        len -= sizeof (breq);                                   	}                                                               	TAILQ_FOREACH(bif, &sc->sc_spanlist, bif_next) {                	        if (len < sizeof (breq))                                	                break;                                                                                                                  	        snprintf(breq.ifbr_ifsname,                             	                 sizeof (breq.ifbr_ifsname),                    	                 "%s", bif->bif_ifp->if_xname);                 	        breq.ifbr_ifsflags = bif->bif_ifflags;                  	        breq.ifbr_portno                                        	                = bif->bif_ifp->if_index & 0xfff;               	        memcpy(buf, &breq, sizeof (breq));                      	        count++;                                                	        buf += sizeof (breq);                                   	        len -= sizeof (breq);                                   	}                                                                                                                                       	BRIDGE_UNLOCK(sc);                                              	bifc->ifbic_len = sizeof (breq) * count;                        	if (bifc->ifbic_len > 0) {                                      	        error = copyout(outbuf, bifc->ifbic_req, bifc->ifbic_len);	}                                                               	BRIDGE_LOCK(sc);                                                	kfree_data(outbuf, buflen);                                     } while (0)
BRIDGE_IOCTL_RTS do {                                               	struct bridge_rtnode *brt;                                          	char *buf;                                                          	char *outbuf = NULL;                                                	unsigned int count, buflen, len;                                    	unsigned long now;                                                                                                                              	if (bac->ifbac_len == 0)                                            	        return (0);                                                                                                                             	bzero(&bareq, sizeof (bareq));                                      	count = 0;                                                          	LIST_FOREACH(brt, &sc->sc_rtlist, brt_list)                         	        count++;                                                    	buflen = sizeof (bareq) * count;                                                                                                                	BRIDGE_UNLOCK(sc);                                                  	outbuf = kalloc_data(buflen, Z_WAITOK | Z_ZERO);                    	BRIDGE_LOCK(sc);                                                                                                                                	count = 0;                                                          	buf = outbuf;                                                       	len = min(bac->ifbac_len, buflen);                                  	LIST_FOREACH(brt, &sc->sc_rtlist, brt_list) {                       	        if (len < sizeof (bareq))                                   	                goto out;                                           	        snprintf(bareq.ifba_ifsname, sizeof (bareq.ifba_ifsname),   	                 "%s", brt->brt_ifp->if_xname);                     	        memcpy(bareq.ifba_dst, brt->brt_addr, sizeof (brt->brt_addr)); 	        bareq.ifba_vlan = brt->brt_vlan;                            	        if ((brt->brt_flags & IFBAF_TYPEMASK) == IFBAF_DYNAMIC) {   	                now = (unsigned long) net_uptime();                 	                if (now < brt->brt_expire)                          	                        bareq.ifba_expire =                         	                            brt->brt_expire - now;                  	        } else                                                      	                bareq.ifba_expire = 0;                              	        bareq.ifba_flags = brt->brt_flags;                                                                                                      	        memcpy(buf, &bareq, sizeof (bareq));                        	        count++;                                                    	        buf += sizeof (bareq);                                      	        len -= sizeof (bareq);                                      	}                                                                   out:                                                                        	bac->ifbac_len = sizeof (bareq) * count;                            	if (outbuf != NULL) {                                               	        BRIDGE_UNLOCK(sc);                                          	        if (bac->ifbac_len > 0) {                                   	                error = copyout(outbuf, bac->ifbac_req, bac->ifbac_len);	        }                                                           	        kfree_data(outbuf, buflen);                                 	        BRIDGE_LOCK(sc);                                            	}                                                                   	return (error);                                                     } while (0)
BRIDGE_IOCTL_GBPARAM do {                                       	struct bstp_state *bs = &sc->sc_stp;                            	struct bstp_port *root_port;                                                                                                            	req->ifbop_maxage = bs->bs_bridge_max_age >> 8;                 	req->ifbop_hellotime = bs->bs_bridge_htime >> 8;                	req->ifbop_fwddelay = bs->bs_bridge_fdelay >> 8;                                                                                        	root_port = bs->bs_root_port;                                   	if (root_port == NULL)                                          	        req->ifbop_root_port = 0;                               	else                                                            	        req->ifbop_root_port = root_port->bp_ifp->if_index;                                                                             	req->ifbop_holdcount = bs->bs_txholdcount;                      	req->ifbop_priority = bs->bs_bridge_priority;                   	req->ifbop_protocol = bs->bs_protover;                          	req->ifbop_root_path_cost = bs->bs_root_pv.pv_cost;             	req->ifbop_bridgeid = bs->bs_bridge_pv.pv_dbridge_id;           	req->ifbop_designated_root = bs->bs_root_pv.pv_root_id;         	req->ifbop_designated_bridge = bs->bs_root_pv.pv_dbridge_id;    	req->ifbop_last_tc_time.tv_sec = bs->bs_last_tc_time.tv_sec;    	req->ifbop_last_tc_time.tv_usec = bs->bs_last_tc_time.tv_usec;  } while (0)
BRIDGE_IOCTL_GIFSSTP do {                                       	struct bridge_iflist *bif;                                      	struct bstp_port *bp;                                           	struct ifbpstpreq bpreq;                                        	char *buf, *outbuf;                                             	unsigned int count, buflen, len;                                                                                                        	count = 0;                                                      	TAILQ_FOREACH(bif, &sc->sc_iflist, bif_next) {                  	        if ((bif->bif_ifflags & IFBIF_STP) != 0)                	                count++;                                        	}                                                                                                                                       	buflen = sizeof (bpreq) * count;                                	if (bifstp->ifbpstp_len == 0) {                                 	        bifstp->ifbpstp_len = buflen;                           	        return (0);                                             	}                                                                                                                                       	BRIDGE_UNLOCK(sc);                                              	outbuf = kalloc_data(buflen, Z_WAITOK | Z_ZERO);                	BRIDGE_LOCK(sc);                                                                                                                        	count = 0;                                                      	buf = outbuf;                                                   	len = min(bifstp->ifbpstp_len, buflen);                         	bzero(&bpreq, sizeof (bpreq));                                  	TAILQ_FOREACH(bif, &sc->sc_iflist, bif_next) {                  	        if (len < sizeof (bpreq))                               	                break;                                                                                                                  	        if ((bif->bif_ifflags & IFBIF_STP) == 0)                	                continue;                                                                                                               	        bp = &bif->bif_stp;                                     	        bpreq.ifbp_portno = bif->bif_ifp->if_index & 0xfff;     	        bpreq.ifbp_fwd_trans = bp->bp_forward_transitions;      	        bpreq.ifbp_design_cost = bp->bp_desg_pv.pv_cost;        	        bpreq.ifbp_design_port = bp->bp_desg_pv.pv_port_id;     	        bpreq.ifbp_design_bridge = bp->bp_desg_pv.pv_dbridge_id; 	        bpreq.ifbp_design_root = bp->bp_desg_pv.pv_root_id;                                                                             	        memcpy(buf, &bpreq, sizeof (bpreq));                    	        count++;                                                	        buf += sizeof (bpreq);                                  	        len -= sizeof (bpreq);                                  	}                                                                                                                                       	BRIDGE_UNLOCK(sc);                                              	bifstp->ifbpstp_len = sizeof (bpreq) * count;                   	if (bifstp->ifbpstp_len > 0) {                                  	        error = copyout(outbuf, bifstp->ifbpstp_req, bifstp->ifbpstp_len);	}                                                               	BRIDGE_LOCK(sc);                                                	kfree_data(outbuf, buflen);                                     	return (error);                                                 } while (0)
__ATOMIC_INC(s) os_atomic_inc(&s, relaxed)
ETHER_TYPE_FLAG_NONE 0x00
ETHER_TYPE_FLAG_IPV4 0x01
ETHER_TYPE_FLAG_IPV6 0x02
ETHER_TYPE_FLAG_ARP 0x04
mix(a, b, c)                                                    do {                                                                    	a -= b; a -= c; a ^= (c >> 13);                                 	b -= c; b -= a; b ^= (a << 8);                                  	c -= a; c -= b; c ^= (b >> 13);                                 	a -= b; a -= c; a ^= (c >> 12);                                 	b -= c; b -= a; b ^= (a << 16);                                 	c -= a; c -= b; c ^= (b >> 5);                                  	a -= b; a -= c; a ^= (c >> 3);                                  	b -= c; b -= a; b ^= (a << 10);                                 	c -= a; c -= b; c ^= (b >> 15);                                 } while (  0)
BRIDGE_HF_DROP(reason, func, line) {                            	        bridge_hostfilter_stats.reason++;                       	        BRIDGE_LOG(LOG_DEBUG, BR_DBGF_HOSTFILTER,               	                   "%s.%d" #reason, func, line);                	        error = EINVAL;                                         	}
CKSUM_OFFSET_ICMP6 offsetof(struct icmp6_hdr, icmp6_cksum)
_NET_IF_BRIDGEVAR_H_ None
BRDGADD 0
BRDGDEL 1
BRDGGIFFLGS 2
BRDGSIFFLGS 3
BRDGSCACHE 4
BRDGGCACHE 5
BRDGGIFS 6
BRDGRTS 7
BRDGSADDR 8
BRDGSTO 9
BRDGGTO 10
BRDGDADDR 11
BRDGFLUSH 12
BRDGGPRI 13
BRDGSPRI 14
BRDGGHT 15
BRDGSHT 16
BRDGGFD 17
BRDGSFD 18
BRDGGMA 19
BRDGSMA 20
BRDGSIFPRIO 21
BRDGSIFCOST 22
BRDGGFILT 23
BRDGSFILT 24
BRDGPURGE 25
BRDGADDS 26
BRDGDELS 27
BRDGPARAM 28
BRDGGRTE 29
BRDGGIFSSTP 30
BRDGSPROTO 31
BRDGSTXHC 32
BRDGSIFAMAX 33
BRDGGHOSTFILTER 34
BRDGSHOSTFILTER 35
BRDGGMACNATLIST 36
BRDGGIFSTATS 37
IFBIF_LEARNING 0x0001
IFBIF_DISCOVER 0x0002
IFBIF_STP 0x0004
IFBIF_SPAN 0x0008
IFBIF_STICKY 0x0010
IFBIF_BSTP_EDGE 0x0020
IFBIF_BSTP_AUTOEDGE 0x0040
IFBIF_BSTP_PTP 0x0080
IFBIF_BSTP_AUTOPTP 0x0100
IFBIF_BSTP_ADMEDGE 0x0200
IFBIF_BSTP_ADMCOST 0x0400
IFBIF_PRIVATE 0x0800
IFBIF_MAC_NAT 0x8000
IFBIF_CHECKSUM_OFFLOAD 0x10000
IFBIF_USES_VIRTIO 0x20000
IFBIFBITS "\020\001LEARNING\002DISCOVER\003STP\004SPAN" 	"\005STICKY\006EDGE\007AUTOEDGE\010PTP"                       	"\011AUTOPTP\014PRIVATE"                                      	"\020MACNAT\021CSUM\022VIRTIO"
IFBIFMASK ~(IFBIF_BSTP_EDGE|IFBIF_BSTP_AUTOEDGE|IFBIF_BSTP_PTP| 	                IFBIF_BSTP_AUTOPTP|IFBIF_BSTP_ADMEDGE| 	                IFBIF_BSTP_ADMCOST)
IFBF_FLUSHDYN 0x00
IFBF_FLUSHALL 0x01
IFBF_FILT_USEIPF 0x00000001
IFBF_FILT_MEMBER 0x00000002
IFBF_FILT_ONLYIP 0x00000004
IFBF_FILT_MASK 0x00000007
IFBAF_TYPEMASK 0x03
IFBAF_DYNAMIC 0x00
IFBAF_STATIC 0x01
IFBAF_STICKY 0x02
IFBAFBITS "\020\1STATIC\2STICKY"
ifbrp_csize ifbrp_ifbrpu.ifbrpu_int32
ifbrp_ctime ifbrp_ifbrpu.ifbrpu_int32
ifbrp_prio ifbrp_ifbrpu.ifbrpu_int16
ifbrp_proto ifbrp_ifbrpu.ifbrpu_int8
ifbrp_txhc ifbrp_ifbrpu.ifbrpu_int8
ifbrp_hellotime ifbrp_ifbrpu.ifbrpu_int8
ifbrp_fwddelay ifbrp_ifbrpu.ifbrpu_int8
ifbrp_maxage ifbrp_ifbrpu.ifbrpu_int8
ifbrp_cexceeded ifbrp_ifbrpu.ifbrpu_int32
ifbrp_filter ifbrp_ifbrpu.ifbrpu_int32
IFBRHF_ENABLED 0x01
IFBRHF_HWSRC 0x02
IFBRHF_IPSRC 0x04
ifbmne_ip_addr ifbmne_ip.ifbrip_addr
ifbmne_ip6_addr ifbmne_ip.ifbrip_addr6
_NET_IF_DL_H_ None
DLIL_SDLMAXLEN 64
_NET_IF_ETHER_H None
FE_DBGF_LIFECYCLE 0x0001
FE_DBGF_INPUT 0x0002
FE_DBGF_OUTPUT 0x0004
FE_DBGF_CONTROL 0x0008
FE_DBGF_MISC 0x0010
FAKE_LOG(__level, __dbgf, __string, ...)              	do {                                                            	        if (__level <= if_fake_log_level ||                   	            FAKE_DBGF_ENABLED(__dbgf)) {                      	                os_log(OS_LOG_DEFAULT, "%s: " __string, 	                       __func__, ## __VA_ARGS__);       	        }                                                       	} while (0)
FAKE_ETHER_NAME "feth"
DEFAULT_EXPIRATION_THRESHOLD 500
FETH_LINK_LAYER_AGGRETATION_FACTOR_MAX 512
FETH_LINK_LAYER_AGGRETATION_FACTOR_DEF 96
FETH_TX_HEADROOM_MAX 32
FETH_TRAILER_LENGTH_MAX 28
FETH_MAX_MTU_DEFAULT 2048
FETH_BUFLET_SIZE_MIN 512
FETH_IF_ADV_INTVL_MIN 10
FETH_IF_ADV_INTVL_MAX INT_MAX
FETH_TX_DROPS_MIN 0
FETH_TX_DROPS_MAX INT_MAX
FETH_MAX_LLINKS 16
FETH_DEF_LLINKS 0
FETH_MAX_QSETS 16
FETH_DEF_QSETS 4
IFF_NUM_TX_RINGS_WMM_MODE 4
IFF_NUM_RX_RINGS_WMM_MODE 1
IFF_MAX_TX_RINGS IFF_NUM_TX_RINGS_WMM_MODE
IFF_MAX_RX_RINGS IFF_NUM_RX_RINGS_WMM_MODE
IFF_NUM_TX_QUEUES_WMM_MODE 4
IFF_NUM_RX_QUEUES_WMM_MODE 1
IFF_MAX_TX_QUEUES IFF_NUM_TX_QUEUES_WMM_MODE
IFF_MAX_RX_QUEUES IFF_NUM_RX_QUEUES_WMM_MODE
IFF_MAX_BATCH_SIZE 32
IFF_FLAGS_HWCSUM 0x0001
IFF_FLAGS_BSD_MODE 0x0002
IFF_FLAGS_DETACHING 0x0004
IFF_FLAGS_WMM_MODE 0x0008
IFF_FLAGS_MULTIBUFLETS 0x0010
IFF_FLAGS_TSO_SUPPORT 0x0020
IFF_FLAGS_LRO 0x0040
IFF_FLAGS_VLAN_MTU 0x0080
IFF_FLAGS_VLAN_TAGGING 0x0100
IFF_FLAGS_SEPARATE_FRAME_HEADER 0x0200
IFF_FLAGS_NX_ATTACHED 0x0400
FETH_MAXUNIT IF_MAXUNIT
FETH_ZONE_MAX_ELEM MIN(IFNETS_MAX, FETH_MAXUNIT)
FAKE_DEFAULT_MEDIA IFM_MAKEWORD(IFM_ETHER, IFM_10G_T, IFM_FDX, 0)
_NET_IF_FAKE_VAR_H_ 1
IF_FAKE_MEDIA_LIST_MAX 27
iffr_peer_name iffr_u.iffru_peer_name
iffr_media iffr_u.iffru_media
iffr_dequeue_stall iffr_u.iffru_dequeue_stall
GIFNAME "gif"
GIFDEV "if_gif"
GIF_MAXUNIT IF_MAXUNIT
GIF_ZONE_MAX_ELEM MIN(IFNETS_MAX, GIF_MAXUNIT)
GIF_ORDERED_LOCK(sc, sc2)       	if (sc < sc2) {                 	        GIF_LOCK(sc);           	        GIF_LOCK(sc2);          	} else {                        	        GIF_LOCK(sc2);          	        GIF_LOCK(sc);           	}
GIF_ORDERED_UNLOCK(sc, sc2)     	if (sc > sc2) {                 	        GIF_UNLOCK(sc);         	        GIF_UNLOCK(sc2);        	} else {                        	        GIF_UNLOCK(sc2);        	        GIF_UNLOCK(sc);         	}
_NET_IF_GIF_H_ None
IFGIF_DETACHING 0x1
GIF_LOCK(_sc) lck_mtx_lock(&(_sc)->gif_lock)
GIF_UNLOCK(_sc) lck_mtx_unlock(&(_sc)->gif_lock)
GIF_LOCK_ASSERT(_sc) LCK_MTX_ASSERT(&(_sc)->gif_lock,            LCK_MTX_ASSERT_OWNED)
gif_ro gifsc_gifscr.gifscr_ro
gif_ro6 gifsc_gifscr.gifscr_ro6
IPSEC_FLAGS_KPIPE_ALLOCATED 1
IPSEC_PCB_DATA_PATH_READY 0x1
IPSECQ_MAXLEN 256
_NET_IF_IPSEC_H_ None
IPSEC_CONTROL_NAME "com.apple.net.ipsec_control"
IPSEC_OPT_FLAGS 1
IPSEC_OPT_IFNAME 2
IPSEC_OPT_EXT_IFDATA_STATS 3
IPSEC_OPT_INC_IFDATA_STATS_IN 4
IPSEC_OPT_INC_IFDATA_STATS_OUT 5
IPSEC_OPT_SET_DELEGATE_INTERFACE 6
IPSEC_OPT_OUTPUT_TRAFFIC_CLASS 7
IPSEC_OPT_ENABLE_CHANNEL 8
IPSEC_OPT_GET_CHANNEL_UUID 9
IPSEC_OPT_ENABLE_FLOWSWITCH 10
IPSEC_OPT_INPUT_FRAG_SIZE 11
IPSEC_OPT_ENABLE_NETIF 12
IPSEC_OPT_SLOT_SIZE 13
IPSEC_OPT_NETIF_RING_SIZE 14
IPSEC_OPT_TX_FSW_RING_SIZE 15
IPSEC_OPT_RX_FSW_RING_SIZE 16
IPSEC_OPT_CHANNEL_BIND_PID 17
IPSEC_OPT_KPIPE_TX_RING_SIZE 18
IPSEC_OPT_KPIPE_RX_RING_SIZE 19
IPSEC_OPT_CHANNEL_BIND_UUID 20
IPSEC_OPT_OUTPUT_DSCP_MAPPING 21
_NET_IF_LLC_H_ None
llc_control llc_un.type_u.control
llc_control_ext llc_un.type_raw.control_ext
llc_fid llc_un.type_u.format_id
llc_class llc_un.type_u.class
llc_window llc_un.type_u.window_x2
llc_frmrinfo llc_un.type_frmr.frmr_rej_pdu0
llc_frmr_pdu0 llc_un.type_frmr.frmr_rej_pdu0
llc_frmr_pdu1 llc_un.type_frmr.frmr_rej_pdu1
llc_frmr_control llc_un.type_frmr.frmr_control
llc_frmr_control_ext llc_un.type_frmr.frmr_control_ext
llc_frmr_cause llc_un.type_frmr.frmr_cause
llc_snap llc_un.type_snap
LLC_ISFRAMELEN 4
LLC_UFRAMELEN 3
LLC_FRMRLEN 7
LLC_SNAPFRAMELEN 8
LLC_UI 0x3
LLC_UI_P 0x13
LLC_DISC 0x43
LLC_DISC_P 0x53
LLC_UA 0x63
LLC_UA_P 0x73
LLC_TEST 0xe3
LLC_TEST_P 0xf3
LLC_FRMR 0x87
LLC_FRMR_P 0x97
LLC_DM 0x0f
LLC_DM_P 0x1f
LLC_XID 0xaf
LLC_XID_P 0xbf
LLC_SABME 0x6f
LLC_SABME_P 0x7f
LLC_RR 0x01
LLC_RNR 0x05
LLC_REJ 0x09
LLC_INFO 0x00
LLC_8021D_LSAP 0x42
LLC_X25_LSAP 0x7e
LLC_SNAP_LSAP 0xaa
LLC_ISO_LSAP 0xfe
LLC_XID_FORMAT_BASIC 0x81
LLC_XID_CLASS_I 0x1
LLC_XID_CLASS_II 0x3
LLC_XID_CLASS_III 0x5
LLC_XID_CLASS_IV 0x7
LL_COMPUTE_RTIME(x) ND_COMPUTE_RTIME(x)
_NET_IF_LLREACH_H_ None
IF_LLREACHINFO_ADDRLEN 64
IF_LLREACHINFO_RESERVED2 16
IF_LLREACH_MAXLEN ETHER_ADDR_LEN
IFLR_LOCK_ASSERT_HELD(_iflr) LCK_MTX_ASSERT(&(_iflr)->lr_lock, LCK_MTX_ASSERT_OWNED)
IFLR_LOCK_ASSERT_NOTHELD(_iflr) LCK_MTX_ASSERT(&(_iflr)->lr_lock, LCK_MTX_ASSERT_NOTOWNED)
IFLR_LOCK(_iflr) lck_mtx_lock(&(_iflr)->lr_lock)
IFLR_LOCK_SPIN(_iflr) lck_mtx_lock_spin(&(_iflr)->lr_lock)
IFLR_CONVERT_LOCK(_iflr) do {                                   	IFLR_LOCK_ASSERT_HELD(_iflr);                                   	lck_mtx_convert_spin(&(_iflr)->lr_lock);                        } while (0)
IFLR_UNLOCK(_iflr) lck_mtx_unlock(&(_iflr)->lr_lock)
IFLR_ADDREF(_iflr) iflr_addref(_iflr, 0)
IFLR_ADDREF_LOCKED(_iflr) iflr_addref(_iflr, 1)
IFLR_REMREF(_iflr) iflr_remref(_iflr)
_NET_IF_MEDIA_H_ None
IFM_X(x) IFM_X_SUBTYPE(x)
IFM_ETHER 0x00000020
IFM_10_T 3
IFM_10_2 4
IFM_10_5 5
IFM_100_TX 6
IFM_100_FX 7
IFM_100_T4 8
IFM_100_VG 9
IFM_100_T2 10
IFM_1000_SX 11
IFM_10_STP 12
IFM_10_FL 13
IFM_1000_LX 14
IFM_1000_CX 15
IFM_1000_T 16
IFM_1000_TX IFM_1000_T
IFM_HPNA_1 17
IFM_10G_SR 18
IFM_10G_LR 19
IFM_10G_CX4 20
IFM_10G_T 21
IFM_2500_T 22
IFM_5000_T 23
IFM_1000_CX_SGMII 24
IFM_1000_KX 25
IFM_10G_KX4 26
IFM_10G_KR 27
IFM_10G_CR1 28
IFM_10G_ER 29
IFM_20G_KR2 30
IFM_OTHER 31
IFM_2500_SX IFM_X(32)
IFM_10G_TWINAX IFM_X(33)
IFM_10G_TWINAX_LONG IFM_X(34)
IFM_10G_LRM IFM_X(35)
IFM_2500_KX IFM_X(36)
IFM_40G_CR4 IFM_X(37)
IFM_40G_SR4 IFM_X(38)
IFM_50G_PCIE IFM_X(39)
IFM_25G_PCIE IFM_X(40)
IFM_1000_SGMII IFM_X(41)
IFM_10G_SFI IFM_X(42)
IFM_40G_XLPPI IFM_X(43)
IFM_40G_LR4 IFM_X(44)
IFM_40G_KR4 IFM_X(45)
IFM_100G_CR4 IFM_X(47)
IFM_100G_SR4 IFM_X(48)
IFM_100G_KR4 IFM_X(49)
IFM_100G_LR4 IFM_X(50)
IFM_56G_R4 IFM_X(51)
IFM_100_T IFM_X(52)
IFM_25G_CR IFM_X(53)
IFM_25G_KR IFM_X(54)
IFM_25G_SR IFM_X(55)
IFM_50G_CR2 IFM_X(56)
IFM_50G_KR2 IFM_X(57)
IFM_25G_LR IFM_X(58)
IFM_10G_AOC IFM_X(59)
IFM_25G_ACC IFM_X(60)
IFM_25G_AOC IFM_X(61)
IFM_100_SGMII IFM_X(62)
IFM_2500_X IFM_X(63)
IFM_5000_KR IFM_X(64)
IFM_25G_T IFM_X(65)
IFM_25G_CR_S IFM_X(66)
IFM_25G_CR1 IFM_X(67)
IFM_25G_KR_S IFM_X(68)
IFM_5000_KR_S IFM_X(69)
IFM_5000_KR1 IFM_X(70)
IFM_25G_AUI IFM_X(71)
IFM_40G_XLAUI IFM_X(72)
IFM_40G_XLAUI_AC IFM_X(73)
IFM_40G_ER4 IFM_X(74)
IFM_50G_SR2 IFM_X(75)
IFM_50G_LR2 IFM_X(76)
IFM_50G_LAUI2_AC IFM_X(77)
IFM_50G_LAUI2 IFM_X(78)
IFM_50G_AUI2_AC IFM_X(79)
IFM_50G_AUI2 IFM_X(80)
IFM_50G_CP IFM_X(81)
IFM_50G_SR IFM_X(82)
IFM_50G_LR IFM_X(83)
IFM_50G_FR IFM_X(84)
IFM_50G_KR_PAM4 IFM_X(85)
IFM_25G_KR1 IFM_X(86)
IFM_50G_AUI1_AC IFM_X(87)
IFM_50G_AUI1 IFM_X(88)
IFM_100G_CAUI4_AC IFM_X(89)
IFM_100G_CAUI4 IFM_X(90)
IFM_100G_AUI4_AC IFM_X(91)
IFM_100G_AUI4 IFM_X(92)
IFM_100G_CR_PAM4 IFM_X(93)
IFM_100G_KR_PAM4 IFM_X(94)
IFM_100G_CP2 IFM_X(95)
IFM_100G_SR2 IFM_X(96)
IFM_100G_DR IFM_X(97)
IFM_100G_KR2_PAM4 IFM_X(98)
IFM_100G_CAUI2_AC IFM_X(99)
IFM_100G_CAUI2 IFM_X(100)
IFM_100G_AUI2_AC IFM_X(101)
IFM_100G_AUI2 IFM_X(102)
IFM_200G_CR4_PAM4 IFM_X(103)
IFM_200G_SR4 IFM_X(104)
IFM_200G_FR4 IFM_X(105)
IFM_200G_LR4 IFM_X(106)
IFM_200G_DR4 IFM_X(107)
IFM_200G_KR4_PAM4 IFM_X(108)
IFM_200G_AUI4_AC IFM_X(109)
IFM_200G_AUI4 IFM_X(110)
IFM_200G_AUI8_AC IFM_X(111)
IFM_200G_AUI8 IFM_X(112)
IFM_400G_FR8 IFM_X(113)
IFM_400G_LR8 IFM_X(114)
IFM_400G_DR4 IFM_X(115)
IFM_400G_AUI8_AC IFM_X(116)
IFM_400G_AUI8 IFM_X(117)
IFM_TOKEN 0x00000040
IFM_TOK_STP4 3
IFM_TOK_STP16 4
IFM_TOK_UTP4 5
IFM_TOK_UTP16 6
IFM_TOK_STP100 7
IFM_TOK_UTP100 8
IFM_TOK_ETR 0x00000200
IFM_TOK_SRCRT 0x00000400
IFM_TOK_ALLR 0x00000800
IFM_TOK_DTR 0x00002000
IFM_TOK_CLASSIC 0x00004000
IFM_TOK_AUTO 0x00008000
IFM_FDDI 0x00000060
IFM_FDDI_SMF 3
IFM_FDDI_MMF 4
IFM_FDDI_UTP 5
IFM_FDDI_DA 0x00000100
IFM_IEEE80211 0x00000080
IFM_IEEE80211_FH1 3
IFM_IEEE80211_FH2 4
IFM_IEEE80211_DS2 5
IFM_IEEE80211_DS5 6
IFM_IEEE80211_DS11 7
IFM_IEEE80211_DS1 8
IFM_IEEE80211_DS22 9
IFM_IEEE80211_ADHOC 0x00000100
IFM_AUTO 0
IFM_MANUAL 1
IFM_NONE 2
IFM_FDX 0x00100000
IFM_HDX 0x00200000
IFM_FLOW 0x00400000
IFM_EEE 0x00800000
IFM_FLAG0 0x01000000
IFM_FLAG1 0x02000000
IFM_FLAG2 0x04000000
IFM_LOOP 0x08000000
IFM_TMASK_COMPAT 0x0000001f
IFM_TMASK_EXT 0x000f0000
IFM_TMASK_EXT_SHIFT 11
IFM_NMASK 0x000000e0
IFM_IMASK 0xf0000000
IFM_ISHIFT 28
IFM_OMASK 0x0000ff00
IFM_GMASK 0x0ff00000
IFM_AVALID 0x00000001
IFM_ACTIVE 0x00000002
IFM_WAKESAMENET 0x00000004
IFM_INST_MAX IFM_INST(IFM_IMASK)
IFM_MAKEWORD(type, subtype, options, instance)                  	((type) | (subtype) | (options) | ((instance) << IFM_ISHIFT))
IFM_TYPE_DESCRIPTIONS {                         { IFM_ETHER,     "Ethernet"   },                    { IFM_TOKEN,     "Token ring" },                    { IFM_FDDI,      "FDDI"       },                    { IFM_IEEE80211, "IEEE802.11" },                    { 0, NULL },                                    }
IFM_SUBTYPE_ETHERNET_DESCRIPTIONS {             { IFM_10_T,     "10baseT/UTP" },                    { IFM_10_2,     "10base2/BNC" },                    { IFM_10_5,     "10base5/AUI" },                    { IFM_100_TX,   "100baseTX"   },                    { IFM_100_FX,   "100baseFX"   },                    { IFM_100_T4,   "100baseT4"   },                    { IFM_100_VG,   "100baseVG"   },                    { IFM_100_T2,   "100baseT2"   },                    { IFM_10_STP,   "10baseSTP"   },                    { IFM_10_FL,    "10baseFL"    },                    { IFM_1000_SX,              "1000baseSX" },                             { IFM_1000_LX,  "1000baseLX"  },                    { IFM_1000_CX,  "1000baseCX"  },                    { IFM_1000_T,   "1000baseT"   },                    { IFM_HPNA_1,               "homePNA" },                                { IFM_10G_LR,               "10Gbase-LR" },                             { IFM_10G_SR,               "10Gbase-SR" },                             { IFM_10G_CX4,              "10Gbase-CX4" },                            { IFM_2500_SX,              "2500BaseSX" },                             { IFM_10G_LRM,              "10Gbase-LRM" },                            { IFM_10G_TWINAX,           "10Gbase-Twinax" },                         { IFM_10G_TWINAX_LONG,      "10Gbase-Twinax-Long" },                    { IFM_10G_T,                "10Gbase-T" },                              { IFM_40G_CR4,              "40Gbase-CR4" },                            { IFM_40G_SR4,              "40Gbase-SR4" },                            { IFM_40G_LR4,              "40Gbase-LR4" },                            { IFM_1000_KX,  "1000Base-KX" },                    { IFM_OTHER,                "Other" },                                  { IFM_10G_KX4,  "10GBase-KX4" },                    { IFM_10G_KR,   "10GBase-KR" },                     { IFM_10G_CR1,  "10GBase-CR1" },                    { IFM_20G_KR2,              "20GBase-KR2" },                            { IFM_2500_KX,              "2500Base-KX" },                            { IFM_2500_T,               "2500Base-T" },                             { IFM_5000_T,               "5000Base-T" },                             { IFM_50G_PCIE,             "PCIExpress-50G" },                         { IFM_25G_PCIE,             "PCIExpress-25G" },                         { IFM_1000_SGMII,           "1000Base-SGMII" },                         { IFM_10G_SFI,              "10GBase-SFI" },                            { IFM_40G_XLPPI,            "40GBase-XLPPI" },                          { IFM_1000_CX_SGMII,        "1000Base-CX-SGMII" },                      { IFM_40G_KR4,              "40GBase-KR4" },                            { IFM_10G_ER,   "10GBase-ER" },                     { IFM_100G_CR4,             "100GBase-CR4" },                           { IFM_100G_SR4,             "100GBase-SR4" },                           { IFM_100G_KR4,             "100GBase-KR4" },                           { IFM_100G_LR4,             "100GBase-LR4" },                           { IFM_56G_R4,               "56GBase-R4" },                             { IFM_100_T,                "100BaseT" },                               { IFM_25G_CR,   "25GBase-CR" },                     { IFM_25G_KR,   "25GBase-KR" },                     { IFM_25G_SR,   "25GBase-SR" },                     { IFM_50G_CR2,  "50GBase-CR2" },                    { IFM_50G_KR2,  "50GBase-KR2" },                    { IFM_25G_LR,               "25GBase-LR" },                             { IFM_10G_AOC,              "10GBase-AOC" },                            { IFM_25G_ACC,              "25GBase-ACC" },                            { IFM_25G_AOC,              "25GBase-AOC" },                            { IFM_100_SGMII,            "100M-SGMII" },                             { IFM_2500_X,               "2500Base-X" },                             { IFM_5000_KR,              "5000Base-KR" },                            { IFM_25G_T,                "25GBase-T" },                              { IFM_25G_CR_S,             "25GBase-CR-S" },                           { IFM_25G_CR1,              "25GBase-CR1" },                            { IFM_25G_KR_S,             "25GBase-KR-S" },                           { IFM_5000_KR_S,            "5000Base-KR-S" },                          { IFM_5000_KR1,             "5000Base-KR1" },                           { IFM_25G_AUI,              "25G-AUI" },                                { IFM_40G_XLAUI,            "40G-XLAUI" },                              { IFM_40G_XLAUI_AC,         "40G-XLAUI-AC" },                           { IFM_40G_ER4,              "40GBase-ER4" },                            { IFM_50G_SR2,  "50GBase-SR2" },                    { IFM_50G_LR2,  "50GBase-LR2" },                    { IFM_50G_LAUI2_AC,         "50G-LAUI2-AC" },                           { IFM_50G_LAUI2,            "50G-LAUI2" },                              { IFM_50G_AUI2_AC,          "50G-AUI2-AC" },                            { IFM_50G_AUI2,             "50G-AUI2" },                               { IFM_50G_CP,               "50GBase-CP" },                             { IFM_50G_SR,               "50GBase-SR" },                             { IFM_50G_LR,               "50GBase-LR" },                             { IFM_50G_FR,               "50GBase-FR" },                             { IFM_50G_KR_PAM4,          "50GBase-KR-PAM4" },                        { IFM_25G_KR1,              "25GBase-KR1" },                            { IFM_50G_AUI1_AC,          "50G-AUI1-AC" },                            { IFM_50G_AUI1,             "50G-AUI1" },                               { IFM_100G_CAUI4_AC,        "100G-CAUI4-AC" },                          { IFM_100G_CAUI4,           "100G-CAUI4" },                             { IFM_100G_AUI4_AC,         "100G-AUI4-AC" },                           { IFM_100G_AUI4,            "100G-AUI4" },                              { IFM_100G_CR_PAM4,         "100GBase-CR-PAM4" },                       { IFM_100G_KR_PAM4,         "100GBase-KR-PAM4" },                       { IFM_100G_CP2,             "100GBase-CP2" },                           { IFM_100G_SR2,             "100GBase-SR2" },                           { IFM_100G_DR,              "100GBase-DR" },                            { IFM_100G_KR2_PAM4,        "100GBase-KR2-PAM4" },                      { IFM_100G_CAUI2_AC,        "100G-CAUI2-AC" },                          { IFM_100G_CAUI2,           "100G-CAUI2" },                             { IFM_100G_AUI2_AC,         "100G-AUI2-AC" },                           { IFM_100G_AUI2,            "100G-AUI2" },                              { IFM_200G_CR4_PAM4,        "200GBase-CR4-PAM4" },                      { IFM_200G_SR4,             "200GBase-SR4" },                           { IFM_200G_FR4,             "200GBase-FR4" },                           { IFM_200G_LR4,             "200GBase-LR4" },                           { IFM_200G_DR4,             "200GBase-DR4" },                           { IFM_200G_KR4_PAM4,        "200GBase-KR4-PAM4" },                      { IFM_200G_AUI4_AC,         "200G-AUI4-AC" },                           { IFM_200G_AUI4,            "200G-AUI4" },                              { IFM_200G_AUI8_AC,         "200G-AUI8-AC" },                           { IFM_200G_AUI8,            "200G-AUI8" },                              { IFM_400G_FR8,             "400GBase-FR8" },                           { IFM_400G_LR8,             "400GBase-LR8" },                           { IFM_400G_DR4,             "400GBase-DR4" },                           { IFM_400G_AUI8_AC,         "400G-AUI8-AC" },                           { IFM_400G_AUI8,            "400G-AUI8" },                              { 0, NULL },                                    }
IFM_SUBTYPE_ETHERNET_ALIASES {                  { IFM_10_T,     "UTP"    },                         { IFM_10_T,     "10UTP"  },                         { IFM_10_2,     "BNC"    },                         { IFM_10_2,     "10BNC"  },                         { IFM_10_5,     "AUI"    },                         { IFM_10_5,     "10AUI"  },                         { IFM_100_TX,   "100TX"  },                         { IFM_100_FX,   "100FX"  },                         { IFM_100_T4,   "100T4"  },                         { IFM_100_VG,   "100VG"  },                         { IFM_100_T2,   "100T2"  },                         { IFM_1000_SX,  "1000SX" },                         { IFM_10_STP,   "STP"    },                         { IFM_10_STP,   "10STP"  },                         { IFM_10_FL,    "FL"     },                         { IFM_10_FL,    "10FL"   },                         { IFM_1000_LX,  "1000LX" },                         { IFM_1000_CX,  "1000CX" },                         { IFM_1000_T,   "1000T"  },                         { IFM_HPNA_1,   "HPNA1"  },                         { IFM_10G_SR,   "10GSR"  },                         { IFM_10G_LR,   "10GLR"  },                         { IFM_10G_CX4,  "10GCX4" },                         { IFM_10G_T,    "10GT"   },                         { 0, NULL },                                    }
IFM_SUBTYPE_ETHERNET_OPTION_DESCRIPTIONS {      { 0, NULL },                                    }
IFM_SUBTYPE_TOKENRING_DESCRIPTIONS {            { IFM_TOK_STP4,  "DB9/4Mbit" },                     { IFM_TOK_STP16, "DB9/16Mbit" },                    { IFM_TOK_UTP4,  "UTP/4Mbit" },                     { IFM_TOK_UTP16, "UTP/16Mbit" },                    { 0, NULL },                                    }
IFM_SUBTYPE_TOKENRING_ALIASES {                 { IFM_TOK_STP4,  "4STP" },                          { IFM_TOK_STP16, "16STP" },                         { IFM_TOK_UTP4,  "4UTP" },                          { IFM_TOK_UTP16, "16UTP" },                         { 0, NULL },                                    }
IFM_SUBTYPE_TOKENRING_OPTION_DESCRIPTIONS {     { IFM_TOK_ETR,   "EarlyTokenRelease" },             { IFM_TOK_SRCRT, "SourceRouting" },                 { IFM_TOK_ALLR,  "AllRoutes" },                     { 0, NULL },                                    }
IFM_SUBTYPE_FDDI_DESCRIPTIONS {                 { IFM_FDDI_SMF, "Single-mode" },                    { IFM_FDDI_MMF, "Multi-mode" },                     { IFM_FDDI_UTP, "UTP" },                            { 0, NULL },                                    }
IFM_SUBTYPE_FDDI_ALIASES {                      { IFM_FDDI_SMF, "SMF" },                            { IFM_FDDI_MMF, "MMF" },                            { IFM_FDDI_UTP, "CDDI" },                           { 0, NULL },                                    }
IFM_SUBTYPE_FDDI_OPTION_DESCRIPTIONS {          { IFM_FDDI_DA,  "Dual-attach" },                    { 0, NULL },                                    }
IFM_SUBTYPE_IEEE80211_DESCRIPTIONS {            { IFM_IEEE80211_FH1,  "FH1"  },                     { IFM_IEEE80211_FH2,  "FH2"  },                     { IFM_IEEE80211_DS1,  "DS1"  },                     { IFM_IEEE80211_DS2,  "DS2"  },                     { IFM_IEEE80211_DS5,  "DS5"  },                     { IFM_IEEE80211_DS11, "DS11" },                     { IFM_IEEE80211_DS22, "DS22" },                     { 0, NULL },                                    }
IFM_SUBTYPE_IEEE80211_OPTION_DESCRIPTIONS {     { IFM_IEEE80211_ADHOC,  "adhoc" },                  { 0, NULL },                                    }
IFM_SUBTYPE_SHARED_DESCRIPTIONS {               { IFM_AUTO,     "autoselect" },                     { IFM_MANUAL,   "manual" },                         { IFM_NONE,     "none" },                           { 0, NULL },                                    }
IFM_SUBTYPE_SHARED_ALIASES {                    { IFM_AUTO,     "auto" },                           { 0, NULL },                                    }
IFM_SHARED_OPTION_DESCRIPTIONS {                { IFM_FDX,      "full-duplex" },                    { IFM_HDX,      "half-duplex" },                    { IFM_FLOW,     "flow-control" },                   { IFM_EEE,	    "energy-efficient-ethernet" },      { IFM_FLAG0,    "flag0" },                          { IFM_FLAG1,    "flag1" },                          { IFM_FLAG2,    "flag2" },                          { IFM_LOOP,     "hw-loopback" },                    { 0, NULL },                                    }
COPY(fld) ifmd.ifmd_##fld = ifp->if_##fld
_NET_IF_MIB_H 1
IFMIB_SYSTEM 1
IFMIB_IFDATA 2
IFMIB_IFALLDATA 3
IFDATA_GENERAL 1
IFDATA_LINKSPECIFIC 2
IFDATA_ADDRS 3
IFDATA_MULTIADDRS 4
IFMIB_IFCOUNT 1
NETLINK_GENERIC 0
DOT3COMPLIANCE_STATS 1
DOT3COMPLIANCE_COLLS 2
DOT3CHIPSET(v, p)        (((v) << 16) + ((p) & 0xffff))
_NET_IF_MIB_PRIVATE_H 1
IFDATA_SUPPLEMENTAL 5
IFDATA_LINKHEURISTICS 6
PFLOGNAME "pflog"
_NET_IF_PFLOG_H_ None
ESP_HDR_SIZE 4
PORT_ISAKMP 500
PORT_ISAKMP_NATT 4500
NPE_HASH_BUCKET_COUNT 32
npi_ev_wake_pkt_attributed npi_ev_wake_pkt_._npi_ev_wake_pkt_attributed
npi_ev_wake_pkt_unattributed npi_ev_wake_pkt_._npi_ev_wake_pkt_unattributed
NPI_MAX_IF_FAMILY_BITS 32
_NET_IF_PORT_USED_H_ None
IP_PORTRANGE_SIZE 65536
WAKE_PKT_EVENT_CONTROL_ENTITLEMENT "com.apple.private.network.wake_pkt.control"
NPIF_IPV4 0x0001
NPIF_IPV6 0x0002
NPIF_TCP 0x0004
NPIF_UDP 0x0008
NPIF_DELEGATED 0x0010
NPIF_SOCKET 0x0020
NPIF_CHANNEL 0x0040
NPIF_LISTEN 0x0080
NPIF_WAKEPKT 0x0100
NPIF_NOWAKE 0x0200
NPIF_FRAG 0x0400
NPIF_ESP 0x0800
NPIF_COMPLINK 0x1000
NPI_HAS_EFFECTIVE_UUID 1
npi_local_addr_in npi_local_addr_._in_a_4
npi_foreign_addr_in npi_foreign_addr_._in_a_4
npi_local_addr_in6 npi_local_addr_._in_a_6
npi_foreign_addr_in6 npi_foreign_addr_._in_a_6
NPI_HAS_WAKE_EVENT_TUPLE 1
NPI_HAS_PACKET_INFO 1
NPI_HAS_PHYSICAL_LINK 1
NPICF_TH_FIN 0x01
NPICF_TH_SYN 0x02
NPICF_TH_RST 0x04
NPICF_TH_PUSH 0x08
NPICF_TH_ACK 0x10
NPICF_TH_URG 0x20
NPICF_TH_ECE 0x40
NPICF_TH_CWR 0x80
NPICF_NOWAKE 0x1000
NPI_MAX_UNA_WAKE_PKT_LEN 102
IFPU_HAS_MATCH_WAKE_PKT_NO_FLAG 1
IF_PORTS_USED_STATS_LIST X(uint64_t, ifpu_wakeuid_gen, "wakeuuid generation%s", "", "s") 	X(uint64_t, ifpu_wakeuuid_not_set_count, "offload port list quer%s with wakeuuid not set", "y", "ies") 	X(uint64_t, ifpu_npe_total, "total offload port entr%s created since boot", "y", "ies") 	X(uint64_t, ifpu_npe_count, "current offload port entr%s", "y", "ies") 	X(uint64_t, ifpu_npe_max, "max offload port entr%s", "y", "ies") 	X(uint64_t, ifpu_npe_dup, "duplicate offload port entr%s", "y", "ies") 	X(uint64_t, ifpu_npi_hash_search_total, "total table entry search%s", "", "es") 	X(uint64_t, ifpu_npi_hash_search_max, "max hash table entry search%s", "", "es") 	X(uint64_t, ifpu_so_match_wake_pkt, "match so wake packet call%s", "", "s") 	X(uint64_t, ifpu_ch_match_wake_pkt, "match ch wake packet call%s", "", "s") 	X(uint64_t, ifpu_ipv4_wake_pkt, "IPv4 wake packet%s", "", "s") 	X(uint64_t, ifpu_ipv6_wake_pkt, "IPv6 wake packet%s", "", "s") 	X(uint64_t, ifpu_tcp_wake_pkt, "TCP wake packet%s", "", "s") 	X(uint64_t, ifpu_udp_wake_pkt, "UDP wake packet%s", "", "s") 	X(uint64_t, ifpu_isakmp_natt_wake_pkt, "ISAKMP NAT traversal wake packet%s", "", "s") 	X(uint64_t, ifpu_esp_wake_pkt, "ESP wake packet%s", "", "s") 	X(uint64_t, ifpu_bad_proto_wake_pkt, "bad protocol wake packet%s", "", "s") 	X(uint64_t, ifpu_bad_family_wake_pkt, "bad family wake packet%s", "", "s") 	X(uint64_t, ifpu_wake_pkt_event, "wake packet event%s", "", "s") 	X(uint64_t, ifpu_dup_wake_pkt_event, "duplicate wake packet event%s in same wake cycle", "", "s") 	X(uint64_t, ifpu_wake_pkt_event_error, "wake packet event%s undelivered", "", "s") 	X(uint64_t, ifpu_unattributed_wake_event, "unattributed wake packet event%s", "", "s") 	X(uint64_t, ifpu_dup_unattributed_wake_event, "duplicate unattributed wake packet event%s in same wake cycle", "", "s") 	X(uint64_t, ifpu_unattributed_wake_event_error, "unattributed wake packet event%s undelivered", "", "s") 	X(uint64_t, ifpu_unattributed_null_recvif, "unattributed wake packet%s received with null interface", "", "s") 	X(uint64_t, ifpu_match_wake_pkt_no_flag, "bad packet%s without wake flag", "", "s") 	X(uint64_t, ifpu_frag_wake_pkt, "pure fragment wake packet%s", "", "s") 	X(uint64_t, ifpu_incomplete_tcp_hdr_pkt, "packet%s with incomplete TCP header", "", "s") 	X(uint64_t, ifpu_incomplete_udp_hdr_pkt, "packet%s with incomplete UDP header", "", "s") 	X(uint64_t, ifpu_npi_not_added_no_wakeuuid, "port entr%s not added with wakeuuid not set", "y", "ies") 	X(uint64_t, ifpu_deferred_isakmp_natt_wake_pkt, "deferred matching of ISAKMP NAT traversal wake packet%s", "", "s") 	X(uint64_t, ifpu_spurious_wake_event, "spurious wake packet event%s", "", "s") 	X(uint64_t, ifpu_delayed_attributed_wake_event, "delayed attributed wake packet event%s", "", "s") 	X(uint64_t, ifpu_delayed_unattributed_wake_event, "delayed unattributed wake packet event%s", "", "s") 	X(uint64_t, ifpu_delayed_wake_event_undelivered, "undelivered delayed wake packet event%s", "", "s")
X(_type, _field, ...) _type _field;
_IF_PPP_H_ None
PPP_MTU 1500
PPP_MAXMRU 65000
PPP_MAXMTU 16384
SC_COMP_PROT 0x00000001
SC_COMP_AC 0x00000002
SC_COMP_TCP 0x00000004
SC_NO_TCP_CCID 0x00000008
SC_REJ_COMP_AC 0x00000010
SC_REJ_COMP_TCP 0x00000020
SC_CCP_OPEN 0x00000040
SC_CCP_UP 0x00000080
SC_DEBUG 0x00010000
SC_LOG_INPKT 0x00020000
SC_LOG_OUTPKT 0x00040000
SC_LOG_RAWIN 0x00080000
SC_LOG_FLUSH 0x00100000
SC_RCV_B7_0 0x01000000
SC_RCV_B7_1 0x02000000
SC_RCV_EVNP 0x04000000
SC_RCV_ODDP 0x08000000
SC_MASK 0x0fff00ff
SC_TIMEOUT 0x00000400
SC_VJ_RESET 0x00000800
SC_COMP_RUN 0x00001000
SC_DECOMP_RUN 0x00002000
SC_DC_ERROR 0x00004000
SC_DC_FERROR 0x00008000
SC_TBUSY 0x10000000
SC_PKTLOST 0x20000000
SC_FLUSH 0x40000000
SC_ESCAPED 0x80000000
PPPIOCGFLAGS _IOR('t', 90, int)
PPPIOCSFLAGS _IOW('t', 89, int)
PPPIOCGASYNCMAP _IOR('t', 88, int)
PPPIOCSASYNCMAP _IOW('t', 87, int)
PPPIOCGUNIT _IOR('t', 86, int)
PPPIOCGRASYNCMAP _IOR('t', 85, int)
PPPIOCSRASYNCMAP _IOW('t', 84, int)
PPPIOCGMRU _IOR('t', 83, int)
PPPIOCSMRU _IOW('t', 82, int)
PPPIOCSMAXCID _IOW('t', 81, int)
PPPIOCGXASYNCMAP _IOR('t', 80, ext_accm)
PPPIOCSXASYNCMAP _IOW('t', 79, ext_accm)
PPPIOCXFERUNIT _IO('t', 78)
PPPIOCSCOMPRESS _IOW('t', 77, struct ppp_option_data)
PPPIOCGNPMODE _IOWR('t', 76, struct npioctl)
PPPIOCSNPMODE _IOW('t', 75, struct npioctl)
PPPIOCGIDLE _IOR('t', 74, struct ppp_idle)
PPPIOCSPASS _IOW('t', 71, struct bpf_program)
PPPIOCSACTIVE _IOW('t', 70, struct bpf_program)
PPPIOCGMTU _IOR('t', 73, int)
PPPIOCSMTU _IOW('t', 72, int)
SIOCGPPPSTATS _IOWR('i', 123, struct ifpppstatsreq)
SIOCGPPPCSTATS _IOWR('i', 122, struct ifpppcstatsreq)
_NET_IF_PRIVATE_H_ None
RD_NAME "rd"
RD_MAXUNIT IF_MAXUNIT
RD_ZONE_MAX_ELEM MIN(IFNETS_MAX, RD_MAXUNIT)
RD_MAX_MTU 2048
RD_MAX_TX_RINGS 1
RD_MAX_RX_RINGS 1
RD_POOL_SIZE 1024
RDLOG(level, format, ...) do {                                        	if (level == LOG_ERR) {                                               	        os_log_error(redirect_log_handle, "%s: " format "\n",         	            __FUNCTION__, ##__VA_ARGS__);                             	} else {                                                              	        if (__probable(if_redirect_debug == 0)) {                     	                break;                                                	        }                                                             	        if (level == LOG_DEBUG) {                                     	                os_log_debug(redirect_log_handle, "%s: " format "\n", 	                    __FUNCTION__, ##__VA_ARGS__);                     	        } else if (level == LOG_INFO) {                               	                os_log_info(redirect_log_handle, "%s: " format "\n",  	                    __FUNCTION__, ##__VA_ARGS__);                     	        }                                                             	}                                                                     } while (0)
RDLOG_ERR(format, ...) RDLOG(LOG_ERR, format, ##__VA_ARGS__)
RDLOG_DBG(format, ...) RDLOG(LOG_DEBUG, format, ##__VA_ARGS__)
RDLOG_INFO(format, ...) RDLOG(LOG_INFO, format, ##__VA_ARGS__)
RD_MEDIA_LIST_MAX 27
RD_LOCK_INIT(rd) lck_mtx_init(&(rd)->rd_lock, &redirect_lock_group, &redirect_lock_attr)
RD_LOCK(rd) lck_mtx_lock(&(rd)->rd_lock)
RD_UNLOCK(rd) lck_mtx_unlock(&(rd)->rd_lock)
RD_LOCK_DESTROY(rd) lck_mtx_destroy(&(rd)->rd_lock, &redirect_lock_group)
_NET_IF_REDIRECT_VAR_H_ 1
RD_CREATE_PARAMS_TYPE 0x2D27
RD_CREATE_PARAMS_TYPE_NOATTACH 0x2D28
ifrr_delegate_name ifrr_u.ifrru_delegate_name
sc_ro __sc_ro46.__sc_ro4
_NET_IF_TYPES_H_ None
IFT_OTHER 0x1
IFT_1822 0x2
IFT_HDH1822 0x3
IFT_X25DDN 0x4
IFT_X25 0x5
IFT_ETHER 0x6
IFT_ISO88023 0x7
IFT_ISO88024 0x8
IFT_ISO88025 0x9
IFT_ISO88026 0xa
IFT_STARLAN 0xb
IFT_P10 0xc
IFT_P80 0xd
IFT_HY 0xe
IFT_FDDI 0xf
IFT_LAPB 0x10
IFT_SDLC 0x11
IFT_T1 0x12
IFT_CEPT 0x13
IFT_ISDNBASIC 0x14
IFT_ISDNPRIMARY 0x15
IFT_PTPSERIAL 0x16
IFT_PPP 0x17
IFT_LOOP 0x18
IFT_EON 0x19
IFT_XETHER 0x1a
IFT_NSIP 0x1b
IFT_SLIP 0x1c
IFT_ULTRA 0x1d
IFT_DS3 0x1e
IFT_SIP 0x1f
IFT_FRELAY 0x20
IFT_RS232 0x21
IFT_PARA 0x22
IFT_ARCNET 0x23
IFT_ARCNETPLUS 0x24
IFT_ATM 0x25
IFT_MIOX25 0x26
IFT_SONET 0x27
IFT_X25PLE 0x28
IFT_ISO88022LLC 0x29
IFT_LOCALTALK 0x2a
IFT_SMDSDXI 0x2b
IFT_FRELAYDCE 0x2c
IFT_V35 0x2d
IFT_HSSI 0x2e
IFT_HIPPI 0x2f
IFT_MODEM 0x30
IFT_AAL5 0x31
IFT_SONETPATH 0x32
IFT_SONETVT 0x33
IFT_SMDSICIP 0x34
IFT_PROPVIRTUAL 0x35
IFT_PROPMUX 0x36
IFT_GIF 0x37
IFT_FAITH 0x38
IFT_STF 0x39
IFT_6LOWPAN 0x40
IFT_L2VLAN 0x87
IFT_IEEE8023ADLAG 0x88
IFT_IEEE1394 0x90
IFT_BRIDGE 0xd1
IFT_ENC 0xf4
IFT_PFLOG 0xf5
IFT_PFSYNC 0xf6
IFT_CARP 0xf8
IFT_PKTAP 0xfe
IFT_CELLULAR 0xff
IFT_PDP IFT_CELLULAR
UTUN_DEFAULT_MTU 1500
_NET_IF_UTUN_H_ None
UTUN_CONTROL_NAME "com.apple.net.utun_control"
UTUN_OPT_FLAGS 1
UTUN_OPT_IFNAME 2
UTUN_OPT_EXT_IFDATA_STATS 3
UTUN_OPT_INC_IFDATA_STATS_IN 4
UTUN_OPT_INC_IFDATA_STATS_OUT 5
UTUN_OPT_SET_DELEGATE_INTERFACE 15
UTUN_OPT_MAX_PENDING_PACKETS 16
UTUN_OPT_ENABLE_CHANNEL 17
UTUN_OPT_GET_CHANNEL_UUID 18
UTUN_OPT_ENABLE_FLOWSWITCH 19
UTUN_OPT_ENABLE_NETIF 20
UTUN_OPT_SLOT_SIZE 21
UTUN_OPT_NETIF_RING_SIZE 22
UTUN_OPT_TX_FSW_RING_SIZE 23
UTUN_OPT_RX_FSW_RING_SIZE 24
UTUN_OPT_KPIPE_TX_RING_SIZE 25
UTUN_OPT_KPIPE_RX_RING_SIZE 26
UTUN_OPT_ATTACH_FLOWSWITCH 27
UTUN_FLAGS_NO_OUTPUT 0x0001
UTUN_FLAGS_NO_INPUT 0x0002
UTUN_FLAGS_ENABLE_PROC_UUID 0x0004
_NET_IF_VAR_H_ None
_NET_IF_VAR_PRIVATE_H_ None
_NET_IF_VAR_STATUS_H_ None
IF_CELLULAR_STATUS_REPORT_VERSION_1 1
IF_WIFI_STATUS_REPORT_VERSION_1 1
IF_CELLULAR_STATUS_REPORT_CURRENT_VERSION IF_CELLULAR_STATUS_REPORT_VERSION_1
IF_WIFI_STATUS_REPORT_CURRENT_VERSION IF_WIFI_STATUS_REPORT_VERSION_1
IF_CELL_LINK_QUALITY_METRIC_VALID 0x1
IF_CELL_UL_EFFECTIVE_BANDWIDTH_VALID 0x2
IF_CELL_UL_MAX_BANDWIDTH_VALID 0x4
IF_CELL_UL_MIN_LATENCY_VALID 0x8
IF_CELL_UL_EFFECTIVE_LATENCY_VALID 0x10
IF_CELL_UL_MAX_LATENCY_VALID 0x20
IF_CELL_UL_RETXT_LEVEL_VALID 0x40
IF_CELL_UL_BYTES_LOST_VALID 0x80
IF_CELL_UL_MIN_QUEUE_SIZE_VALID 0x100
IF_CELL_UL_AVG_QUEUE_SIZE_VALID 0x200
IF_CELL_UL_MAX_QUEUE_SIZE_VALID 0x400
IF_CELL_DL_EFFECTIVE_BANDWIDTH_VALID 0x800
IF_CELL_DL_MAX_BANDWIDTH_VALID 0x1000
IF_CELL_CONFIG_INACTIVITY_TIME_VALID 0x2000
IF_CELL_CONFIG_BACKOFF_TIME_VALID 0x4000
IF_CELL_UL_MSS_RECOMMENDED_VALID 0x8000
IF_CELL_UL_RETXT_LEVEL_NONE 1
IF_CELL_UL_RETXT_LEVEL_LOW 2
IF_CELL_UL_RETXT_LEVEL_MEDIUM 3
IF_CELL_UL_RETXT_LEVEL_HIGH 4
IF_CELL_UL_MSS_RECOMMENDED_NONE 0x0
IF_CELL_UL_MSS_RECOMMENDED_MEDIUM 0x1
IF_CELL_UL_MSS_RECOMMENDED_LOW 0x2
IF_WIFI_LINK_QUALITY_METRIC_VALID 0x1
IF_WIFI_UL_EFFECTIVE_BANDWIDTH_VALID 0x2
IF_WIFI_UL_MAX_BANDWIDTH_VALID 0x4
IF_WIFI_UL_MIN_LATENCY_VALID 0x8
IF_WIFI_UL_EFFECTIVE_LATENCY_VALID 0x10
IF_WIFI_UL_MAX_LATENCY_VALID 0x20
IF_WIFI_UL_RETXT_LEVEL_VALID 0x40
IF_WIFI_UL_ERROR_RATE_VALID 0x80
IF_WIFI_UL_BYTES_LOST_VALID 0x100
IF_WIFI_DL_EFFECTIVE_BANDWIDTH_VALID 0x200
IF_WIFI_DL_MAX_BANDWIDTH_VALID 0x400
IF_WIFI_DL_MIN_LATENCY_VALID 0x800
IF_WIFI_DL_EFFECTIVE_LATENCY_VALID 0x1000
IF_WIFI_DL_MAX_LATENCY_VALID 0x2000
IF_WIFI_DL_ERROR_RATE_VALID 0x4000
IF_WIFI_CONFIG_FREQUENCY_VALID 0x8000
IF_WIFI_CONFIG_MULTICAST_RATE_VALID 0x10000
IF_WIFI_CONFIG_SCAN_COUNT_VALID 0x20000
IF_WIFI_CONFIG_SCAN_DURATION_VALID 0x40000
IF_WIFI_UL_RETXT_LEVEL_NONE 1
IF_WIFI_UL_RETXT_LEVEL_LOW 2
IF_WIFI_UL_RETXT_LEVEL_MEDIUM 3
IF_WIFI_UL_RETXT_LEVEL_HIGH 4
IF_WIFI_CONFIG_FREQUENCY_2_4_GHZ 1
IF_WIFI_CONFIG_FREQUENCY_5_0_GHZ 2
IF_INTERFACE_ADVISORY_WIFI_RADIO_COEX_BT 0x01
IF_INTERFACE_ADVISORY_WIFI_RADIO_COEX_AWDL 0x02
IF_INTERFACE_ADVISORY_WIFI_TX_QUEUE_COUNT 6
IF_INTERFACE_ADVISORY_CELL_OUTAGE_STATE_NO 0
IF_INTERFACE_ADVISORY_CELL_OUTAGE_STATE_YES 1
IFNET_TRAFFIC_DESCRIPTOR_TYPE_INET 2
IFNET_TRAFFIC_DESCRIPTOR_FLAG_INBOUND 0x0001
IFNET_TRAFFIC_DESCRIPTOR_FLAG_OUTBOUND 0x0002
IFNET_TRAFFIC_DESCRIPTOR_INET_IPVER 0x01
IFNET_TRAFFIC_DESCRIPTOR_INET_PROTO 0x02
IFNET_TRAFFIC_DESCRIPTOR_INET_LADDR 0x04
IFNET_TRAFFIC_DESCRIPTOR_INET_RADDR 0x08
IFNET_TRAFFIC_DESCRIPTOR_INET_LPORT 0x10
IFNET_TRAFFIC_DESCRIPTOR_INET_RPORT 0x20
iia_v4addr addr32[3]
IFNET_TRAFFIC_RULE_ACTION_STEER 1
VLANNAME "vlan"
VL_DBGF_LIFECYCLE 0x0001
VL_DBGF_INPUT 0x0002
VL_DBGF_OUTPUT 0x0004
VL_DBGF_CONTROL 0x0008
VL_DBGF_MISC 0x0010
VLAN_LOG(__level, __dbgf, __string, ...)              	do {                                                            	        if (__level <= if_vlan_log_level ||                   	            VL_DBGF_ENABLED(__dbgf)) {                      	                os_log(OS_LOG_DEFAULT, "%s: " __string, 	                       __func__, ## __VA_ARGS__);       	        }                                                       	} while (0)
VLP_SIGNATURE 0xfaceface
VLPF_SUPPORTS_VLAN_MTU 0x00000001
VLPF_CHANGE_IN_PROGRESS 0x00000002
VLPF_DETACHING 0x00000004
VLPF_INVALIDATED 0x00000008
VLPF_LINK_EVENT_REQUIRED 0x00000010
IFV_SIGNATURE 0xbeefbeef
IFVF_PROMISC 0x1
IFVF_DETACHING 0x2
IFVF_READY 0x4
VLAN_PARENT_WAIT(vlp) vlan_parent_wait(vlp, __func__)
VLAN_PARENT_SIGNAL(vlp) vlan_parent_signal(vlp, __func__)
VLAN_UNITMAX IF_MAXUNIT
VLAN_ZONE_MAX_ELEM MIN(IFNETS_MAX, VLAN_UNITMAX)
_NET_IF_VLAN_VAR_H_ 1
ETHER_VLAN_ENCAP_LEN 4
EVL_VLID_MASK 0x0FFF
_NET_INIT_H_ None
_IP_VHL None
IPTAP_MAXUNIT IF_MAXUNIT
IPTAP_ZONE_MAX_ELEM MIN(IFNETS_MAX, IPTAP_MAXUNIT)
IPTAP_LOG(fmt, ...) do {     if ((iptap_log)) 	printf("%s:%d " fmt, __FUNCTION__, __LINE__, ##__VA_ARGS__); } while(false)
IPTAP_H None
IPTAP_IFNAME "iptap"
NET_KEXT_NET_H None
NFF_BEFORE 0x01
NFF_AFTER 0x02
NKE_OK 0
TOUCHLASTCHANGE(__if_lastchange) {                              	(__if_lastchange)->tv_sec = (time_t)net_uptime();               	(__if_lastchange)->tv_usec = 0;                                 }
__KPI_INTERFACE__ None
BPF_TAP_MODE_T None
IFNET_MAX_FRAME_TYPE_BUFFER_SIZE 16
IFNET_MAX_LINKADDR_BUFFER_SIZE 16
IFNET_INIT_VERSION_2 2
IFNET_INIT_CURRENT_VERSION IFNET_INIT_VERSION_2
IFNET_INIT_LEGACY 0x1
IFNET_INIT_INPUT_POLL 0x2
IFNET_INIT_NX_NOAUTO 0x4
IFNET_INIT_ALLOC_KPI 0x8
IFNET_INIT_IF_ADV 0x40000000
IFNET_INIT_SKYWALK_NATIVE 0x80000000
IFNET_LOG_MIN IFNET_LOG_DEFAULT
IFNET_LOG_MAX IFNET_LOG_DEBUG
demux_list demux_array
ifnet_allocate(init, interface) 	ifnet_allocate_internal((init), (interface))
IFNET_LLREACHINFO_ADDRLEN 64
ifnet_address_list_free_counted_by(_addresses, _addresses_count) ({        	ifnet_address_list_free_counted_by_internal(_addresses, _addresses_count); 	_addresses = NULL;                                                         	_addresses_count = 0;                                                      })
ifnet_list_free_counted_by(_interfaces, _count) ({              	ifnet_list_free_counted_by_internal(_interfaces, _count);       	_interfaces = NULL;                                             	_count = 0;                                                     })
IP_PORTRANGE_BITFIELD_LEN 8192
IFNET_GET_LOCAL_PORTS_WILDCARDOK 0x01
IFNET_GET_LOCAL_PORTS_NOWAKEUPOK 0x02
IFNET_GET_LOCAL_PORTS_TCPONLY 0x04
IFNET_GET_LOCAL_PORTS_UDPONLY 0x08
IFNET_GET_LOCAL_PORTS_RECVANYIFONLY 0x10
IFNET_GET_LOCAL_PORTS_EXTBGIDLEONLY 0x20
IFNET_GET_LOCAL_PORTS_ACTIVEONLY 0x40
IFNET_GET_LOCAL_PORTS_ANYTCPSTATEOK 0x80
IFNET_MODIDLEN 20
IFNET_MODARGLEN 12
IFNET_KEEPALIVE_OFFLOAD_FRAME_DATA_SIZE 128
IFNET_KEEPALIVE_OFFLOAD_MAX_ADDR_SIZE 16
IFNET_KEEPALIVE_OFFLOAD_FRAME_IPSEC 0x0
IFNET_KEEPALIVE_OFFLOAD_FRAME_AIRPLAY 0x1
IFNET_KEEPALIVE_OFFLOAD_FRAME_TCP 0x2
IFNET_KEEPALIVE_OFFLOAD_FRAME_ETHERTYPE_IPV4 0x0
IFNET_KEEPALIVE_OFFLOAD_FRAME_ETHERTYPE_IPV6 0x1
IFNET_KEEPALIVE_OFFLOAD_FLAG_NOWAKEFROMSLEEP 0x01
__KPI_INTERFACEFILTER__ None
iflt_attach(interface, filter, filter_ref) 	iflt_attach_internal((interface), (filter), (filter_ref))
__KPI_PROTOCOL__ None
_NET_LACP_H_ None
LACPDU_VERSION_1 1
LACPDU_TLV_TYPE_TERMINATOR 0x00
LACPDU_TLV_TYPE_ACTOR 0x01
LACPDU_TLV_TYPE_PARTNER 0x02
LACPDU_TLV_TYPE_COLLECTOR 0x03
LACPDU_ACTOR_TLV_LENGTH 20
LACPDU_PARTNER_TLV_LENGTH 20
LACPDU_COLLECTOR_TLV_LENGTH 16
LACP_ACTOR_PARTNER_STATE_LACP_ACTIVITY 0x01
LACP_ACTOR_PARTNER_STATE_LACP_TIMEOUT 0x02
LACP_ACTOR_PARTNER_STATE_AGGREGATION 0x04
LACP_ACTOR_PARTNER_STATE_SYNCHRONIZATION 0x08
LACP_ACTOR_PARTNER_STATE_COLLECTING 0x10
LACP_ACTOR_PARTNER_STATE_DISTRIBUTING 0x20
LACP_ACTOR_PARTNER_STATE_DEFAULTED 0x40
LACP_ACTOR_PARTNER_STATE_EXPIRED 0x80
LACP_FAST_PERIODIC_TIME 1
LACP_SLOW_PERIODIC_TIME 30
LACP_SHORT_TIMEOUT_TIME 3
LACP_LONG_TIMEOUT_TIME 90
LACP_CHURN_DETECTION_TIME 60
LACP_AGGREGATE_WAIT_TIME 2
LACP_PACKET_RATE 3
LA_MARKER_PDU_VERSION_1 1
LA_MARKER_TLV_TYPE_TERMINATOR 0x00
LA_MARKER_TLV_TYPE_MARKER 0x01
LA_MARKER_TLV_TYPE_MARKER_RESPONSE 0x02
LA_MARKER_TLV_LENGTH 16
LA_MARKER_RESPONSE_TLV_LENGTH 16
_NET_MBLIST_H None
_NET_MULTICAST_LIST_H None
_NET_MULTI_LAYER_PKT_LOG_H_ None
MPKL_VERSION 1
MPKL_CREATE_LOGOBJECT(Name) os_log_create("com.apple.magnetpacketlog", Name)
MPKL_UUID_UUID_ASSOCIATE_PREV(LOGOBJECT, CUR_PROTOCOL_ID, PREV_PROTOCOL_ID, CUR_UUID, PREV_UUID, CUR_LEN, LOG_SEQN) os_log(LOGOBJECT, "1 {curProtocol: %hhu, prevProtocol: %hhu, curUUID: %{public,uuid_t}.16P, prevUUID: %{public,uuid_t}.16P, curPktLen: %hu, logSeqn: %hhu}", CUR_PROTOCOL_ID, PREV_PROTOCOL_ID, CUR_UUID, PREV_UUID, CUR_LEN, LOG_SEQN)
MPKL_UUID_UUID_ASSOCIATE_NEXT(LOGOBJECT, CUR_PROTOCOL_ID, NEXT_PROTOCOL_ID, CUR_UUID, NEXT_UUID, CUR_LEN, LOG_SEQN) os_log(LOGOBJECT, "2 {curProtocol: %hhu, nextProtocol: %hhu, curUUID: %{public,uuid_t}.16P, nextUUID: %{public,uuid_t}.16P, curPktLen: %hu, logSeqn: %hhu}", CUR_PROTOCOL_ID, NEXT_PROTOCOL_ID, CUR_UUID, NEXT_UUID, CUR_LEN, LOG_SEQN)
MPKL_SEQRANGE_UUID_ASSOCIATE(LOGOBJECT, CUR_PROTOCOL_ID, PREV_PROTOCOL_ID, PREV_RANGE_START, PREV_RANGE_END, CUR_UUID, CUR_LEN, LOG_SEQN) os_log(LOGOBJECT, "3 {curProtocol: %hhu, prevProtocol: %hhu, prevStart: %u, prevEnd: %u, curUUID: %{public,uuid_t}.16P, curPktLen: %hu, logSeqn: %hhu}", CUR_PROTOCOL_ID, PREV_PROTOCOL_ID, PREV_RANGE_START, PREV_RANGE_END, CUR_UUID, CUR_LEN, LOG_SEQN)
MPKL_UUID_SEQRANGE_ASSOCIATE(LOGOBJECT, CUR_PROTOCOL_ID, PREV_PROTOCOL_ID, PREV_UUID, CUR_RANGE_START, CUR_RANGE_END, PREV_LEN, LOG_SEQN) os_log(LOGOBJECT, "4 {curProtocol: %hhu, prevProtocol: %hhu, prevUUID: %{public,uuid_t}.16P, curStart: %u, curEnd: %u, prevPktLen: %hu, logSeqn: %hhu}", CUR_PROTOCOL_ID, PREV_PROTOCOL_ID, PREV_UUID, CUR_RANGE_START, CUR_RANGE_END, PREV_LEN, LOG_SEQN)
MPKL_BUNDLEID_UUID_ASSOCIATE(LOGOBJECT, CUR_PROTOCOL_ID, PREV_PROTOCOL_ID, PREV_BUNDLE_ID, CUR_UUID, CUR_LEN, LOG_SEQN) os_log(LOGOBJECT, "5 {curProtocol: %hhu, prevProtocol: %hhu, prevBundleID: %@, curUUID: %{public,uuid_t}.16P, curPktLen: %u, logSeqn: %hhu}", CUR_PROTOCOL_ID, PREV_PROTOCOL_ID, PREV_BUNDLE_ID, CUR_UUID, CUR_LEN, LOG_SEQN)
MPKL_SEQRANGE_UUID_ASSOCIATE_W_BUNDLEID(LOGOBJECT, CUR_PROTOCOL_ID, PREV_PROTOCOL_ID, PREV_RANGE_START, PREV_RANGE_END, CUR_UUID, CLIENT_BUNDLE_ID, CUR_LEN, LOG_SEQN) os_log(LOGOBJECT, "6 {curProtocol: %hhu, prevProtocol: %hhu, prevStart: %u, prevEnd: %u, curUUID: %{public,uuid_t}.16P, curBundleID: %@, curPktLen: %hu, logSeqn: %hhu}", CUR_PROTOCOL_ID, PREV_PROTOCOL_ID, PREV_RANGE_START, PREV_RANGE_END, CUR_UUID, CLIENT_BUNDLE_ID, CUR_LEN, LOG_SEQN)
MPKL_SEQN_UUID_ASSOCIATE_PREV(LOGOBJECT, CUR_PROTOCOL_ID, PREV_PROTOCOL_ID, PREV_UUID, PREV_RANGE_START, PREV_RANGE_END, PREV_LEN, CUR_SEQ_N, CUR_RANGE_START, CUR_RANGE_END, LOG_SEQN) os_log(LOGOBJECT, "7 {Send, curProtocol: %hhu, prevProtocol: %hhu, prevUUID: %{public,uuid_t}.16P, prevStart: %hu, prevEnd: %hu, prevPktLen %hu, curSeqN: %hu, curStart: %hu, curEnd: %hu,  logSeqn: %hhu}", CUR_PROTOCOL_ID, PREV_PROTOCOL_ID, PREV_UUID, PREV_RANGE_START, PREV_RANGE_END, PREV_LEN, CUR_SEQ_N, CUR_RANGE_START, CUR_RANGE_END, LOG_SEQN)
MPKL_SEQN_UUID_ASSOCIATE_NEXT(LOGOBJECT, CUR_PROTOCOL_ID, NEXT_PROTOCOL_ID, NEXT_UUID, NEXT_RANGE_START, NEXT_RANGE_END, NEXT_LEN, CUR_SEQ_N, CUR_RANGE_START, CUR_RANGE_END, LOG_SEQN) os_log(LOGOBJECT, "8 {Receive, curProtocol: %hhu, nextProtocol: %hhu, nextUUID: %{public,uuid_t}.16P, nextStart: %hu, nextEnd: %hu, nextPktLen %hu, curSeqN: %hu, curStart: %hu, curEnd: %hu, logSeqn: %hhu}", CUR_PROTOCOL_ID, NEXT_PROTOCOL_ID, NEXT_UUID, NEXT_RANGE_START, NEXT_RANGE_END, NEXT_LEN, CUR_SEQ_N, CUR_RANGE_START, CUR_RANGE_END, LOG_SEQN)
MPKL_UUID_NEXT(LOGOBJECT, CUR_PROTOCOL_ID, NEXT_PROTOCOL_ID, CUR_UUID, CUR_LEN, LOG_SEQN) os_log(LOGOBJECT, "9 {curProtocol: %hhu, nextProtocol: %hhu, curUUID: %{public,uuid_t}.16P, curPktLen: %u, logSeqn: %hhu}", CUR_PROTOCOL_ID, NEXT_PROTOCOL_ID, CUR_UUID, CUR_LEN, LOG_SEQN)
MPKL_SEQRANGE_NEXT(LOGOBJECT, CUR_PROTOCOL_ID, NEXT_PROTOCOL_ID, CUR_UUID, CUR_LEN, LOG_SEQN) os_log(LOGOBJECT, "10 {curProtocol: %hhu, nextProtocol: %hhu, curUUID: %{public,uuid_t}.16P, curPktLen: %hu, logSeqn: %hhu}", CUR_PROTOCOL_ID, NEXT_PROTOCOL_ID, CUR_UUID, CUR_LEN, LOG_SEQN)
MPKL_UUID_PREV(LOGOBJECT, CUR_PROTOCOL_ID, PREV_PROTOCOL_ID, PREV_UUID, PREV_LEN, LOG_SEQN) os_log(LOGOBJECT, "11 {curProtocol: %hhu, prevProtocol: %hhu, prevUUID: %{public,uuid_t}.16P, prevPktLen: %hu, logSeqn: %hhu}", CUR_PROTOCOL_ID, PREV_PROTOCOL_ID, PREV_UUID, PREV_LEN, LOG_SEQN)
MPKL_TASK_START(LOGOBJECT, CLIENT_BUNDLE_ID, TASK_UUID, CONN_UUID, LOG_SEQN) os_log(LOGOBJECT, "12 {startBundleID: %@, taskUUID: %{public,uuid_t}.16P, connUUID: %{public,uuid_t}.16P, logSeqn: %hhu}", CLIENT_BUNDLE_ID, TASK_UUID, CONN_UUID, LOG_SEQN)
MPKL_TASK_END(LOGOBJECT, CLIENT_BUNDLE_ID, TASK_UUID, CONN_UUID, LOG_SEQN) os_log(LOGOBJECT, "13 {endBundleID: %@, taskUUID: %{public,uuid_t}.16P, connUUID: %{public,uuid_t}.16P, logSeqn: %hhu}", CLIENT_BUNDLE_ID, TASK_UUID, CONN_UUID, LOG_SEQN)
MPKL_SEQN_INCOMPLETE_PREV(LOGOBJECT, CUR_PROTOCOL_ID, PREV_PROTOCOL_ID, CUR_SEQ_N, CUR_RANGE_START, CUR_RANGE_END, PREV_RANGE_START, PREV_RANGE_END, LOG_SEQN) os_log(LOGOBJECT, "14 {Send Incomplete. curProtocol: %hhu, prevProtocol: %hhu, curSeqN: %hu, curStart: %hu, curEnd: %hu, prevStart: %hu, prevEnd: %hu, logSeqn: %hhu}", CUR_PROTOCOL_ID, PREV_PROTOCOL_ID, CUR_SEQ_N, CUR_RANGE_START, CUR_RANGE_END, PREV_RANGE_START, PREV_RANGE_END, LOG_SEQN)
MPKL_SEQN_INCOMPLETE_NEXT(LOGOBJECT, CUR_PROTOCOL_ID, NEXT_PROTOCOL_ID, CUR_SEQ_N, CUR_RANGE_START, CUR_RANGE_END, NEXT_RANGE_START, NEXT_RANGE_END, LOG_SEQN) os_log(LOGOBJECT, "15 {Receive Incomplete. curProtocol: %hhu, nextProtocol: %hhu, curSeqN: %hu, curStart: %hu, curEnd: %hu, nextStart: %hu, nextEnd: %hu, logSeqn: %hhu}", CUR_PROTOCOL_ID, NEXT_PROTOCOL_ID, CUR_SEQ_N, CUR_RANGE_START, CUR_RANGE_END, NEXT_RANGE_START, NEXT_RANGE_END, LOG_SEQN)
MPKL_TCP_SEND(LOGOBJECT, PREV_PROTOCOL_ID, PREV_UUID, LOCAL_PORT, REMOTE_PORT, TCP_SEQ, TCP_LEN, PID, LOG_SEQN)           	os_log_with_type(LOGOBJECT, net_mpklog_type,                                                                              	    "16 {curProtocol: 100, prevProtocol: %hhu, "                                                                          	    "prevUUID: "                                                                                                          	    "%02X%02X%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X%02X%02X%02X%02X, "                                              	    "localPort: %hu, remotePort: %hu, tcpSeq: %u, length: %u, "                                                           	    "pid: %hu, logSeqn: %hhu}",                                                                                           	    PREV_PROTOCOL_ID,                                                                                                     	    PREV_UUID[0], PREV_UUID[1], PREV_UUID[2], PREV_UUID[3], PREV_UUID[4], PREV_UUID[5], PREV_UUID[6], PREV_UUID[7],       	    PREV_UUID[8], PREV_UUID[9], PREV_UUID[10], PREV_UUID[11], PREV_UUID[12], PREV_UUID[13], PREV_UUID[14], PREV_UUID[15], 	    LOCAL_PORT, REMOTE_PORT, TCP_SEQ, TCP_LEN,                                                                            	    (uint16_t)PID, LOG_SEQN)
MPKL_TCP_INPUT(LOGOBJECT, LOCAL_PORT, REMOTE_PORT, TCP_SEQ, TCP_ACK, TCP_LEN, TCP_FLAGS, PID, LOG_SEQN) 	os_log_with_type(LOGOBJECT, net_mpklog_type,                                                            	    "17 {curProtocol: 100, prevProtocol: 80, "                                                          	    "localPort: %hu, remotePort: %hu, tcpSeq: %u, tcpAck: %u, tcpLen: %hu, tcpFlags: 0x%02x, "          	    "pid: %hu, logSeqn: %hhu}",                                                                         	    LOCAL_PORT, REMOTE_PORT, TCP_SEQ, TCP_ACK, (uint16_t)TCP_LEN, TCP_FLAGS,               	    (uint16_t)PID, LOG_SEQN)
MPKL_ESP_OUTPUT_TCP(LOGOBJECT, SPI, ESP_SEQ, LOCAL_PORT, REMOTE_PORT, TCP_SEQ, TCP_ACK, TCP_LEN, TCP_FLAGS)     	os_log_with_type(LOGOBJECT, (os_log_type_t)net_mpklog_type,                                                                    	    "18 {curProtocol: 80, spi: 0x%X, espSeq: %u, PayloadProtocol: 100, "                                        	    "localPort: %hu, remotePort: %hu, tcpSeq: %u, tcpAck: %u, tcpLen: %hu, tcpFlags: 0x%02x}",                  	    SPI, ESP_SEQ,                                                                                               	    LOCAL_PORT, REMOTE_PORT, TCP_SEQ, TCP_ACK, (uint16_t)TCP_LEN, TCP_FLAGS)
MPKL_ESP_INPUT_TCP(LOGOBJECT, SPI, ESP_SEQ, LOCAL_PORT, REMOTE_PORT, TCP_SEQ, TCP_LEN)  	os_log_with_type(LOGOBJECT, (os_log_type_t)net_mpklog_type,                                            	    "19 {curProtocol: 80 spi: 0x%X, espSeq: %u, PayloadProtocol: 100, "                 	    "localPort: %hu, remotePort: %hu, tcpSeq: %u, tcpLen: %hu}",                        	    SPI, ESP_SEQ,                                                                       	    LOCAL_PORT, REMOTE_PORT, TCP_SEQ, (uint16_t)TCP_LEN)
MPKL_BYTERANGE_UUID_ASSOCIATE(LOGOBJECT, CUR_PROTOCOL_ID, NEXT_PROTOCOL_ID, CUR_UUID, CUR_RANGE_START, CUR_RANGE_END, LOG_SEQN) os_log(LOGOBJECT, "32 {curProtocol: %hhu, nextProtocol: %hhu, curUUID: %{public}.16P, curStart: %llu, curEnd: %llu, logSeqn: %hhu}", CUR_PROTOCOL_ID, NEXT_PROTOCOL_ID, CUR_UUID, CUR_RANGE_START, CUR_RANGE_END, LOG_SEQN)
MPKL_UUID_ONLY_ASSOCIATE_NEXT(LOGOBJECT, CUR_PROTOCOL_ID, NEXT_PROTOCOL_ID, CUR_UUID, NEXT_UUID, LOG_SEQN) os_log(LOGOBJECT, "33 {curProtocol: %hhu, nextProtocol: %hhu, curUUID: %{public}.16P, nextUUID: %{public}.16P, logSeqn: %hhu}", CUR_PROTOCOL_ID, NEXT_PROTOCOL_ID, CUR_UUID, NEXT_UUID, LOG_SEQN)
CLAT46_CODE_TO_STRING(type) case type: return #type;
_NET_NAT464_UTILS_H_ None
clat_log0(x) do { log x; } while (0)
clat_log1(x) do { if (clat_debug >= 1) log x; } while (0)
clat_log2(x) do { if (clat_debug >= 2) log x; } while (0)
natv4addr nat464a._v4addr
natv6addr nat464a._v6addr
nataddr8 nat464a._addr8
nataddr16 nat464a._addr16
nataddr32 nat464a._addr32
NDRV_PROTODEMUX_COUNT 10
_NET_NDRV_H None
NDRV_DEMUXTYPE_ETHERTYPE 4
NDRV_DEMUXTYPE_SAP 5
NDRV_DEMUXTYPE_SNAP 6
NDRVPROTO_NDRV 0
NDRV_PROTOCOL_DESC_VERS 1
SOL_NDRVPROTO NDRVPROTO_NDRV
NDRV_DELDMXSPEC 0x02
NDRV_SETDMXSPEC 0x04
NDRV_ADDMULTICAST 0x05
NDRV_DELMULTICAST 0x06
NDRV_DMUX_MAX_DESCR 1024
NRDV_MULTICAST_ADDRS_PER_SOCK 1
_NET_NDRV_VAR_H None
NDRV_SIGNATURE 0x4e445256
NDRVSNDQ 8192
NDRVRCVQ 8192
LIST_INSERT_SORTED_ASCENDING(head, elm, field, sortfield, tmpelm) do {          	if (LIST_EMPTY((head)) || (LIST_FIRST(head)->sortfield >= (elm)->sortfield)) {  	        LIST_INSERT_HEAD((head), elm, field);                                                                           	} else {                                                                                                                                                	        LIST_FOREACH(tmpelm, head, field) {                                                                                     	                if (LIST_NEXT(tmpelm, field) == NULL || LIST_NEXT(tmpelm, field)->sortfield >= (elm)->sortfield) {      	                        LIST_INSERT_AFTER(tmpelm, elm, field);                                                          	                        break;                                                                                                                          	                }                                                                                                                                               	        }                                                                                                                                                       	}                                                                                                                                                               } while (0)
LIST_INSERT_SORTED_TWICE_ASCENDING(head, elm, field, firstsortfield, secondsortfield, tmpelm) do {      	if (LIST_EMPTY((head)) || (LIST_FIRST(head)->firstsortfield > (elm)->firstsortfield) || ((LIST_FIRST(head)->firstsortfield == (elm)->firstsortfield) && (LIST_FIRST(head)->secondsortfield >= (elm)->secondsortfield))) {                                                                                                               	        LIST_INSERT_HEAD((head), elm, field);                                                                           	} else {                                                                                                                                                	        LIST_FOREACH(tmpelm, head, field) {                                                                                     	                if (LIST_NEXT(tmpelm, field) == NULL || (LIST_NEXT(tmpelm, field)->firstsortfield > (elm)->firstsortfield) || ((LIST_NEXT(tmpelm, field)->firstsortfield == (elm)->firstsortfield) && (LIST_NEXT(tmpelm, field)->secondsortfield >= (elm)->secondsortfield))) {         	                        LIST_INSERT_AFTER(tmpelm, elm, field);                                                          	                        break;                                                                                                                          	                }                                                                                                                                               	        }                                                                                                                                                       	}                                                                                                                                                               } while (0)
LIST_INSERT_SORTED_THRICE_ASCENDING(head, elm, field, firstsortfield, secondsortfield, thirdsortfield, tmpelm) do { 	if (LIST_EMPTY((head)) || (LIST_FIRST(head)->firstsortfield > (elm)->firstsortfield) || ((LIST_FIRST(head)->firstsortfield == (elm)->firstsortfield) && (LIST_FIRST(head)->secondsortfield >= (elm)->secondsortfield)) || ((LIST_FIRST(head)->firstsortfield == (elm)->firstsortfield) && (LIST_FIRST(head)->secondsortfield == (elm)->secondsortfield) && (LIST_FIRST(head)->thirdsortfield >= (elm)->thirdsortfield))) {                                                                                                                      	        LIST_INSERT_HEAD((head), elm, field);                                                                           	} else {                                                                                                                                                	        LIST_FOREACH(tmpelm, head, field) {                                                                                     	                if (LIST_NEXT(tmpelm, field) == NULL || (LIST_NEXT(tmpelm, field)->firstsortfield > (elm)->firstsortfield) || ((LIST_NEXT(tmpelm, field)->firstsortfield == (elm)->firstsortfield) && (LIST_NEXT(tmpelm, field)->secondsortfield >= (elm)->secondsortfield)) || ((LIST_NEXT(tmpelm, field)->firstsortfield == (elm)->firstsortfield) && (LIST_NEXT(tmpelm, field)->secondsortfield == (elm)->secondsortfield) && (LIST_NEXT(tmpelm, field)->thirdsortfield >= (elm)->thirdsortfield)))	{ 	                        LIST_INSERT_AFTER(tmpelm, elm, field);                                                          	                        break;                                                                                                                          	                }                                                                                                                                               	        }                                                                                                                                                       	}                                                                                                                                                               } while (0)
NECP_KERNEL_CONDITION_ALL_INTERFACES 0x000001
NECP_KERNEL_CONDITION_BOUND_INTERFACE 0x000002
NECP_KERNEL_CONDITION_PROTOCOL 0x000004
NECP_KERNEL_CONDITION_LOCAL_START 0x000008
NECP_KERNEL_CONDITION_LOCAL_END 0x000010
NECP_KERNEL_CONDITION_LOCAL_PREFIX 0x000020
NECP_KERNEL_CONDITION_REMOTE_START 0x000040
NECP_KERNEL_CONDITION_REMOTE_END 0x000080
NECP_KERNEL_CONDITION_REMOTE_PREFIX 0x000100
NECP_KERNEL_CONDITION_APP_ID 0x000200
NECP_KERNEL_CONDITION_REAL_APP_ID 0x000400
NECP_KERNEL_CONDITION_DOMAIN 0x000800
NECP_KERNEL_CONDITION_ACCOUNT_ID 0x001000
NECP_KERNEL_CONDITION_POLICY_ID 0x002000
NECP_KERNEL_CONDITION_PID 0x004000
NECP_KERNEL_CONDITION_UID 0x008000
NECP_KERNEL_CONDITION_LAST_INTERFACE 0x010000
NECP_KERNEL_CONDITION_TRAFFIC_CLASS 0x020000
NECP_KERNEL_CONDITION_ENTITLEMENT 0x040000
NECP_KERNEL_CONDITION_CUSTOM_ENTITLEMENT 0x080000
NECP_KERNEL_CONDITION_AGENT_TYPE 0x100000
NECP_KERNEL_CONDITION_HAS_CLIENT 0x200000
NECP_KERNEL_CONDITION_LOCAL_NETWORKS 0x400000
NECP_KERNEL_CONDITION_CLIENT_FLAGS 0x800000
NECP_KERNEL_CONDITION_LOCAL_EMPTY 0x1000000
NECP_KERNEL_CONDITION_REMOTE_EMPTY 0x2000000
NECP_KERNEL_CONDITION_PLATFORM_BINARY 0x4000000
NECP_KERNEL_CONDITION_SDK_VERSION 0x8000000
NECP_KERNEL_CONDITION_SIGNING_IDENTIFIER 0x10000000
NECP_KERNEL_CONDITION_PACKET_FILTER_TAGS 0x20000000
NECP_KERNEL_CONDITION_IS_LOOPBACK 0x40000000
NECP_KERNEL_CONDITION_DELEGATE_IS_PLATFORM_BINARY 0x80000000
NECP_KERNEL_CONDITION_SCHEME_PORT 0x100000000
NECP_KERNEL_CONDITION_DOMAIN_FILTER 0x200000000
NECP_KERNEL_CONDITION_SYSTEM_SIGNED_RESULT 0x400000000
NECP_KERNEL_CONDITION_EXACT_DOMAIN 0x800000000
NECP_KERNEL_CONDITION_REAL_UID 0x1000000000
NECP_KERNEL_CONDITION_URL 0x2000000000
NECP_KERNEL_CONDITION_BOUND_INTERFACE_FLAGS 0x4000000000
NECP_MAX_POLICY_RESULT_SIZE 512
NECP_MAX_ROUTE_RULES_ARRAY_SIZE 1024
NECP_MAX_CONDITIONS_ARRAY_SIZE 4096
NECP_MAX_POLICY_LIST_COUNT 1024
NECP_MAX_DOMAIN_FILTER_SIZE 65536
NECP_DOMAIN_FILTER_ID_MAX 10000
NECP_DOMAIN_TRIE_ID_START NECP_DOMAIN_FILTER_ID_MAX
NECP_SESSION_LOCK(_s) lck_mtx_lock(&_s->lock)
NECP_SESSION_UNLOCK(_s) lck_mtx_unlock(&_s->lock)
BUMP_KERNEL_SOCKET_POLICIES_GENERATION_COUNT() do {                                                     	if (OSIncrementAtomic(&necp_kernel_socket_policies_gencount) == (INT32_MAX - 1)) {      	        necp_kernel_socket_policies_gencount = 1;                                                                               	}                                                                                                                                                               } while (0)
SIGNING_ID_CONFIGD "com.apple.configd"
NECP_KERNEL_SOCKET_POLICIES_MAP_NUM_APP_ID_BUCKETS 5
NECP_KERNEL_IP_OUTPUT_POLICIES_MAP_NUM_ID_BUCKETS 5
MAX_RESULT_STRING_LEN 64
NECP_UUID_APP_ID_HASH_SIZE 64
MAX_ROUTE_RULE_INTERFACES 10
MAX_AGGREGATE_ROUTE_RULES 16
NECP_DATA_TRACE_LEVEL_BRIEF 1
NECP_DATA_TRACE_LEVEL_POLICY 2
NECP_DATA_TRACE_LEVEL_CONDITION 3
NECP_DATA_TRACE_LEVEL_DP 4
NECP_ENABLE_DATA_TRACE_OR(local_addr, remote_addr, protocol, pid, ifindex)     ((necp_data_tracing_level && 	((necp_data_tracing_pid && (!pid || NECP_DATA_TRACE_PID_MATCHED(pid))) || 	(necp_data_tracing_proto && NECP_DATA_TRACE_PROTO_MATCHED(protocol)) || 	(necp_data_tracing_ifindex && NECP_DATA_TRACE_IFINDEX_MATCHED(ifindex)) || 	(necp_data_tracing_port && (NECP_DATA_TRACE_LOCAL_PORT_MATCHED(local_addr) || NECP_DATA_TRACE_REMOTE_ORT_MATCHED(remote_addr))))) ? necp_data_tracing_level : 0)
NECP_ENABLE_DATA_TRACE_AND(local_addr, remote_addr, protocol, pid, ifindex)     ((necp_data_tracing_level && 	((!necp_data_tracing_pid || !pid || NECP_DATA_TRACE_PID_MATCHED(pid)) && 	(!necp_data_tracing_proto || NECP_DATA_TRACE_PROTO_MATCHED(protocol)) && 	(!necp_data_tracing_ifindex || NECP_DATA_TRACE_IFINDEX_MATCHED(ifindex)) && 	(!necp_data_tracing_port || (NECP_DATA_TRACE_LOCAL_PORT_MATCHED(local_addr) || NECP_DATA_TRACE_REMOTE_ORT_MATCHED(remote_addr))))) ? necp_data_tracing_level : 0)
NECP_ENABLE_DATA_TRACE(local_addr, remote_addr, protocol, pid, ifindex)     (necp_data_tracing_match_all ? 	NECP_ENABLE_DATA_TRACE_AND(local_addr, remote_addr, protocol, pid, ifindex) : 	NECP_ENABLE_DATA_TRACE_OR(local_addr, remote_addr, protocol, pid, ifindex))
NECP_DATA_TRACE_LOG_APP_LEVEL(debug, caller, log_msg, policy_id, skip_policy_id)     if (NECP_DATA_TRACE_ON(debug)) {     char laddr_str[MAX_IPv6_STR_LEN];     char raddr_str[MAX_IPv6_STR_LEN];     NECPDATATRACELOG(LOG_ERR, "DATA-TRACE <%s>: %s - fam %d proto %d port <local %d/%d remote %d/%d> <local %s remote %s> <drop-all order %d> <pid=%d Application %d Real Application %d BoundInterface %d> <policy_id %d skip_policy_id %d>", 	caller, log_msg, info.local_addr.sin.sin_family, info.protocol, ntohs(info.local_addr.sin.sin_port), ntohs(info.local_addr.sin6.sin6_port), ntohs(info.remote_addr.sin.sin_port), ntohs(info.remote_addr.sin6.sin6_port), necp_get_address_string(&info.local_addr, laddr_str), necp_get_address_string(&info.remote_addr, raddr_str), necp_drop_all_order, info.pid, info.application_id, info.real_application_id, info.bound_interface_index, policy_id, skip_policy_id);     }
NECP_DATA_TRACE_LOG_SOCKET(debug, socket, caller, log_msg, policy_id, skip_policy_id)     if (NECP_DATA_TRACE_ON(debug)) {     char laddr_str[MAX_IPv6_STR_LEN];     char raddr_str[MAX_IPv6_STR_LEN];     NECPDATATRACELOG(LOG_ERR, "DATA-TRACE <%s %llx>: %s - fam %d proto %d port <local %d/%d remote %d/%d> <local %s remote %s> <drop-all order %d> <pid=%d Application %d Real Application %d BoundInterface %d> <policy_id %d skip_policy_id %d result %d>", caller, (uint64_t)VM_KERNEL_ADDRPERM(socket), log_msg, info.local_addr.sin.sin_family, info.protocol, ntohs(info.local_addr.sin.sin_port), ntohs(info.local_addr.sin6.sin6_port), ntohs(info.remote_addr.sin.sin_port), ntohs(info.remote_addr.sin6.sin6_port), necp_get_address_string(&info.local_addr, laddr_str), necp_get_address_string(&info.remote_addr, raddr_str), necp_drop_all_order, info.pid, info.application_id, info.real_application_id, info.bound_interface_index, policy_id, skip_policy_id, inp ? inp->inp_policyresult.results.result : 0);     }
NECP_DATA_TRACE_LOG_SOCKET_DP(debug, socket, caller, log_msg, policy_id, skip_policy_id)     if (NECP_DATA_TRACE_ON(debug)) {     char laddr_str[MAX_IPv6_STR_LEN];     char raddr_str[MAX_IPv6_STR_LEN];     NECPDATATRACELOG(LOG_ERR, "DATA-TRACE <%s %llx>: %s - fam %d proto %d port <local %d/%d remote %d/%d> <local %s remote %s> <drop-all order %d> <pid=%d Application %d Real Application %d BoundInterface %d> <policy_id %d skip_policy_id %d result %d> <input ifindex %d> <allowed_to_receive %d><pf_tag %X pass_flags %X>", caller, (uint64_t)VM_KERNEL_ADDRPERM(socket), log_msg, info.local_addr.sin.sin_family, info.protocol, ntohs(info.local_addr.sin.sin_port), ntohs(info.local_addr.sin6.sin6_port), ntohs(info.remote_addr.sin.sin_port), ntohs(info.remote_addr.sin6.sin6_port), necp_get_address_string(&info.local_addr, laddr_str), necp_get_address_string(&info.remote_addr, raddr_str), necp_drop_all_order, info.pid, info.application_id, info.real_application_id, info.bound_interface_index, policy_id, skip_policy_id, inp ? inp->inp_policyresult.results.result : 0, verifyifindex, allowed_to_receive, pf_tag, pass_flags);     }
NECP_DATA_TRACE_LOG_SOCKET_RESULT(debug, socket, caller, log_msg)     if (NECP_DATA_TRACE_ON(debug)) {     char laddr_str[MAX_IPv6_STR_LEN];     char raddr_str[MAX_IPv6_STR_LEN];     NECPDATATRACELOG(LOG_ERR, "DATA-TRACE <%s %llx>: %s - fam %d proto %d port <local %d/%d remote %d/%d> <local %s remote %s> <drop-all order %d> <pid=%d Application %d Real Application %d BoundInterface %d> (policy id=%d session_order=%d policy_order=%d result=%s)", 	caller, (uint64_t)VM_KERNEL_ADDRPERM(socket), log_msg, info->local_addr.sin.sin_family, info->protocol, ntohs(info->local_addr.sin.sin_port), ntohs(info->local_addr.sin6.sin6_port), ntohs(info->remote_addr.sin.sin_port), ntohs(info->remote_addr.sin6.sin6_port), necp_get_address_string(&info->local_addr, laddr_str), necp_get_address_string(&info->remote_addr, raddr_str), necp_drop_all_order, info->pid, info->application_id, info->real_application_id, info->bound_interface_index, policy_search_array[i]->id, policy_search_array[i]->session_order, policy_search_array[i]->order, resultString[policy_search_array[i]->result]);     }
NECP_DATA_TRACE_LOG_SOCKET_BRIEF(debug, socket, caller, log_msg, policy_id, skip_policy_id, cached_policy_id, cached_skip_policy_id)     if (NECP_DATA_TRACE_ON(debug)) {     NECPDATATRACELOG(LOG_ERR, "DATA-TRACE <%s %llx>: %s - <policy_id %d skip_policy_id %d> <cached policy_id %d skip_policy_id %d>", caller, (uint64_t)VM_KERNEL_ADDRPERM(socket), log_msg, policy_id, skip_policy_id, cached_policy_id, cached_skip_policy_id);     }
NECP_DATA_TRACE_LOG_IP4(debug, caller, log_msg)     if (NECP_DATA_TRACE_ON(debug)) {     char laddr_str[MAX_IPv6_STR_LEN];     char raddr_str[MAX_IPv6_STR_LEN];     NECPDATATRACELOG(LOG_ERR, "DATA-TRACE <%s>: %s - fam %d proto %d port <local %d/%d remote %d/%d> <local %s remote %s> <drop-all order %d> <BoundInterface %d> <socket policy id %d socket skip id %d> <mbuf %X len %d %d>", 	        caller, log_msg, local_addr.sin.sin_family, protocol, ntohs(local_addr.sin.sin_port), ntohs(local_addr.sin6.sin6_port), ntohs(remote_addr.sin.sin_port), ntohs(remote_addr.sin6.sin6_port), necp_get_address_string(&local_addr, laddr_str), necp_get_address_string(&remote_addr, raddr_str), necp_drop_all_order, bound_interface_index, socket_policy_id, socket_skip_policy_id, (unsigned int)packet, ip->ip_len, ntohs(ip->ip_len));     }
NECP_DATA_TRACE_LOG_IP6(debug, caller, log_msg)     if (NECP_DATA_TRACE_ON(debug)) {     char laddr_str[MAX_IPv6_STR_LEN];     char raddr_str[MAX_IPv6_STR_LEN];     NECPDATATRACELOG(LOG_ERR, "DATA-TRACE <%s>: %s - fam %d proto %d port <local %d/%d remote %d/%d> <local %s remote %s> <drop-all order %d> <BoundInterface %d> <socket policy id %d socket skip id %d> <mbuf %X len %d %d %d>", caller, log_msg, local_addr.sin.sin_family, protocol, ntohs(local_addr.sin.sin_port), ntohs(local_addr.sin6.sin6_port), ntohs(remote_addr.sin.sin_port), ntohs(remote_addr.sin6.sin6_port), necp_get_address_string(&local_addr, laddr_str), necp_get_address_string(&remote_addr, raddr_str), necp_drop_all_order, bound_interface_index, socket_policy_id, socket_skip_policy_id, (unsigned int)packet, ip6->ip6_plen, ntohs(ip6->ip6_plen), packet ? packet->m_pkthdr.len : 0);     }
NECP_DATA_TRACE_LOG_IP_RESULT(debug, caller, log_msg)     if (NECP_DATA_TRACE_ON(debug)) {     char laddr_str[MAX_IPv6_STR_LEN];     char raddr_str[MAX_IPv6_STR_LEN];     NECPDATATRACELOG(LOG_ERR, "DATA-TRACE <%s>: %s - fam %d proto %d port <local %d/%d remote %d/%d> <local %s remote %s> <drop-all order %d> <BoundInterface %d> (policy id=%d session_order=%d policy_order=%d result=%s)", 	    caller, log_msg, local_addr->sin.sin_family, protocol, ntohs(local_addr->sin.sin_port), ntohs(local_addr->sin6.sin6_port), ntohs(remote_addr->sin.sin_port), ntohs(remote_addr->sin6.sin6_port), necp_get_address_string(local_addr, laddr_str), necp_get_address_string(remote_addr, raddr_str), necp_drop_all_order, bound_interface_index, policy_search_array[i]->id, policy_search_array[i]->session_order, policy_search_array[i]->order, resultString[policy_search_array[i]->result]);     }
NECP_DATA_TRACE_LOG_POLICY_SOCKET(debug, socket, caller, log_msg)     if (NECP_DATA_TRACE_POLICY_ON(debug)) {     NECPDATATRACELOG(LOG_ERR, "DATA-TRACE <%s %llx>: %s - policy id=%d session_order=%d policy_order=%d result=%s (cond_policy_id %d) (skip_session_order %d skip_order %d)", 	    caller, (uint64_t)VM_KERNEL_ADDRPERM(socket), log_msg, policy_search_array[i]->id, policy_search_array[i]->session_order, policy_search_array[i]->order, resultString[policy_search_array[i]->result], policy_search_array[i]->condition_mask & NECP_KERNEL_CONDITION_POLICY_ID ? policy_search_array[i]->cond_policy_id : 0, skip_session_order, skip_order);     }
NECP_DATA_TRACE_LOG_POLICY_IP(debug, caller, log_msg)     if (NECP_DATA_TRACE_POLICY_ON(debug)) {     NECPDATATRACELOG(LOG_ERR, "DATA-TRACE <%s>: %s - policy id=%d session_order=%d policy_order=%d result=%s (cond_policy_id %d) (skip_session_order %d skip_order %d)", 	        caller, log_msg, policy_search_array[i]->id, policy_search_array[i]->session_order, policy_search_array[i]->order, resultString[policy_search_array[i]->result], policy_search_array[i]->condition_mask & NECP_KERNEL_CONDITION_POLICY_ID ? policy_search_array[i]->cond_policy_id : 0, skip_session_order, skip_order);     }
NECP_DATA_TRACE_LOG_CONDITION_IP3(debug, caller, negate, name, val1, val2, val3, input1, input2, input3)     if (NECP_DATA_TRACE_CONDITION_ON(debug)) {     NECPDATATRACELOG(LOG_ERR, "DATA-TRACE <%s>: ------ %smatching <%s> <value (%d / 0x%X) (%d / 0x%X) (%d / 0x%X) input (%d / 0x%X) (%d / 0x%X) (%d / 0x%X)>", 	        caller, negate ? "!":"", name, val1, val1, val2, val2, val3, val3, input1, input1, input2, input2, input3, input3);     }
NECP_DATA_TRACE_LOG_CONDITION_IP_STR3(debug, caller, negate, name, val1, val2, val3, input1, input2, input3)     if (NECP_DATA_TRACE_CONDITION_ON(debug)) {     NECPDATATRACELOG(LOG_ERR, "DATA-TRACE <%s>: ------ %smatching <%s> <value %s %s %s input %s %s %s>", 	    caller, negate ? "!":"", name, val1 != NULL ? val1 : "null", val2 != NULL ? val2 : "null", val3 != NULL ? val3 : "null", 	    input1 != NULL ? input1 : "null", input2 != NULL ? input2 : "null", input3 != NULL ? input3 : "null");     }
NECP_DATA_TRACE_LOG_CONDITION_IP(debug, caller, negate, name, val, input)     NECP_DATA_TRACE_LOG_CONDITION_IP3(debug, caller, negate, name, val, 0, 0, input, 0, 0)
NECP_DATA_TRACE_LOG_CONDITION_IP_STR(debug, caller, negate, name, val, input)     NECP_DATA_TRACE_LOG_CONDITION_IP_STR3(debug, caller, negate, name, val, "n/a", "n/a", input, "n/a", "n/a")
NECP_DATA_TRACE_LOG_CONDITION_SOCKET3(debug, socket, caller, negate, name, val1, val2, val3, input1, input2, input3)     if (NECP_DATA_TRACE_CONDITION_ON(debug)) {     NECPDATATRACELOG(LOG_ERR, "DATA-TRACE <%s %llx>: ------ %smatching <%s> <value (%d / 0x%X) (%d / 0x%X) (%d / 0x%X) input (%d / 0x%X) (%d / 0x%X) (%d / 0x%X)>", 	    caller, (uint64_t)VM_KERNEL_ADDRPERM(socket), negate ? "!":"", name, val1, val1, val2, val2, val3, val3, input1, input1, input2, input2, input3, input3);     }
NECP_DATA_TRACE_LOG_CONDITION_SOCKET_STR3(debug, socket, caller, negate, name, val1, val2, val3, input1, input2, input3)     if (NECP_DATA_TRACE_CONDITION_ON(debug)) {     NECPDATATRACELOG(LOG_ERR, "DATA-TRACE <%s %llx>: ------ %smatching <%s> <value %s %s %s input %s %s %s>", 	caller, (uint64_t)VM_KERNEL_ADDRPERM(socket), negate ? "!":"", name, val1 != NULL ? val1 : "null", val2 != NULL ? val2 : "null", val3 != NULL ? val3 : "null", 	input1 != NULL ? input1 : "null", input2 != NULL ? input2 : "null", input3 != NULL ? input3 : "null");     }
NECP_DATA_TRACE_LOG_CONDITION_SOCKET(debug, socket, caller, negate, name, val, input)     NECP_DATA_TRACE_LOG_CONDITION_SOCKET3(debug, socket, caller, negate, name, val, 0, 0, input, 0, 0)
NECP_DATA_TRACE_LOG_CONDITION_SOCKET_STR(debug, socket, caller, negate, name, val, input)     NECP_DATA_TRACE_LOG_CONDITION_SOCKET_STR3(debug, socket, caller, negate, name, val, "n/a", "n/a", input, "n/a", "n/a")
NECP_DDE_ENTITLEMENT "com.apple.developer.media-device-discovery-extension"
IS_NECP_DEST_IN_LOCAL_NETWORKS(rt, addr, include_local_addresses)     ((rt) != NULL && !((rt)->rt_flags & RTF_GATEWAY) && (include_local_addresses || !((rt)->rt_flags & RTF_LOCAL)) && ((rt)->rt_ifa && (rt)->rt_ifa->ifa_ifp && !((rt)->rt_ifa->ifa_ifp->if_flags & IFF_POINTOPOINT) && !((rt)->rt_ifa->ifa_ifp->if_eflags & IFEF_DIRECTLINK)) && (include_local_addresses || addr == NULL || !necp_address_is_local_interface_address(addr)))
necp_address_is_valid(S) _necp_address_is_valid(SA(S))
REPORT_ERROR(error) error_occured = true;               	                                                response_error = error;         	                                                goto done
UNLOCK_AND_REPORT_ERROR(lock, error)    lck_rw_done(lock);      	                                                                                        REPORT_ERROR(error)
N_QUICK 256
NECP_KERNEL_POLICY_SUBORDER_ID_TUNNEL_CONDITION 0
NECP_KERNEL_POLICY_SUBORDER_NON_ID_TUNNEL_CONDITION 1
NECP_KERNEL_POLICY_SUBORDER_ID_CONDITION 2
NECP_KERNEL_POLICY_SUBORDER_NON_ID_CONDITIONS 3
NECP_FIRST_VALID_ROUTE_RULE_ID 1
NECP_FIRST_VALID_AGGREGATE_ROUTE_RULE_ID UINT16_MAX
NECP_NULL_SERVICE_ID 1
NECP_FIRST_VALID_SERVICE_ID 2
NECP_FIRST_VALID_APP_ID UINT16_MAX
NECP_MAX_STRING_LEN 1024
NECP_VERIFY_DELEGATION_ENTITLEMENT(_p, _c, _d) 	if (!has_checked_delegation_entitlement) { 	        has_delegation_entitlement = (priv_check_cred(_c, PRIV_NET_PRIVILEGED_SOCKET_DELEGATE, 0) == 0); 	        has_checked_delegation_entitlement = TRUE; 	} 	if (!has_delegation_entitlement) { 	        NECPLOG(LOG_ERR, "%s(%d) does not hold the necessary entitlement to delegate network traffic for other processes by %s", 	                                          proc_name_address(_p), proc_pid(_p), _d); 	        break; 	}
NECP_MAX_REQUIRED_AGENTS 16
_NET_NECP_H_ None
NECP_CONTROL_NAME "com.apple.net.necp_control"
NECP_TLV_LENGTH_UINT32 1
NECP_DOMAIN_TRIE_SUPPORT 1
NECP_DOMAIN_TRIE_FLAG_REVERSE_SEARCH 0x1
NECP_DOMAIN_TRIE_FLAG_ALLOW_PARTIAL_MATCH 0x2
NECP_PACKET_TYPE_POLICY_ADD 1
NECP_PACKET_TYPE_POLICY_GET 2
NECP_PACKET_TYPE_POLICY_DELETE 3
NECP_PACKET_TYPE_POLICY_APPLY_ALL 4
NECP_PACKET_TYPE_POLICY_LIST_ALL 5
NECP_PACKET_TYPE_POLICY_DELETE_ALL 6
NECP_PACKET_TYPE_SET_SESSION_PRIORITY 7
NECP_PACKET_TYPE_LOCK_SESSION_TO_PROC 8
NECP_PACKET_TYPE_REGISTER_SERVICE 9
NECP_PACKET_TYPE_UNREGISTER_SERVICE 10
NECP_PACKET_TYPE_POLICY_DUMP_ALL 11
NECP_SESSION_ACTION_POLICY_ADD 1
NECP_SESSION_ACTION_POLICY_GET 2
NECP_SESSION_ACTION_POLICY_DELETE 3
NECP_SESSION_ACTION_POLICY_APPLY_ALL 4
NECP_SESSION_ACTION_POLICY_LIST_ALL 5
NECP_SESSION_ACTION_POLICY_DELETE_ALL 6
NECP_SESSION_ACTION_SET_SESSION_PRIORITY 7
NECP_SESSION_ACTION_LOCK_SESSION_TO_PROC 8
NECP_SESSION_ACTION_REGISTER_SERVICE 9
NECP_SESSION_ACTION_UNREGISTER_SERVICE 10
NECP_SESSION_ACTION_POLICY_DUMP_ALL 11
NECP_SESSION_ACTION_ADD_DOMAIN_FILTER 12
NECP_SESSION_ACTION_REMOVE_DOMAIN_FILTER 13
NECP_SESSION_ACTION_REMOVE_ALL_DOMAIN_FILTERS 14
NECP_SESSION_ACTION_ADD_DOMAIN_TRIE 15
NECP_SESSION_ACTION_REMOVE_DOMAIN_TRIE 16
NECP_SESSION_ACTION_REMOVE_ALL_DOMAIN_TRIES 17
NECP_SESSION_ACTION_TRIE_DUMP_ALL 18
NECP_PACKET_FLAGS_RESPONSE 0x01
NECP_TLV_NIL 0
NECP_TLV_ERROR 1
NECP_TLV_POLICY_ORDER 2
NECP_TLV_POLICY_CONDITION 3
NECP_TLV_POLICY_RESULT 4
NECP_TLV_POLICY_ID 5
NECP_TLV_SESSION_PRIORITY 6
NECP_TLV_ATTRIBUTE_DOMAIN 7
NECP_TLV_ATTRIBUTE_ACCOUNT 8
NECP_TLV_SERVICE_UUID 9
NECP_TLV_ROUTE_RULE 10
NECP_TLV_ATTRIBUTE_DOMAIN_OWNER 11
NECP_TLV_ATTRIBUTE_TRACKER_DOMAIN 12
NECP_TLV_ATTRIBUTE_DOMAIN_CONTEXT 13
NECP_TLV_POLICY_OWNER 100
NECP_TLV_POLICY_DUMP 101
NECP_TLV_POLICY_RESULT_STRING 102
NECP_TLV_POLICY_SESSION_ORDER 103
NECP_POLICY_CONDITION_FLAGS_NEGATIVE 0x01
NECP_POLICY_CONDITION_FLAGS_EXACT 0x02
NECP_POLICY_CONDITION_FLAGS_NEGATIVE_SUPPORTS_DUMP 1
NECP_POLICY_CONDITION_DEFAULT 0
NECP_POLICY_CONDITION_APPLICATION 1
NECP_POLICY_CONDITION_REAL_APPLICATION 2
NECP_POLICY_CONDITION_DOMAIN 3
NECP_POLICY_CONDITION_ACCOUNT 4
NECP_POLICY_CONDITION_ENTITLEMENT 5
NECP_POLICY_CONDITION_PID 6
NECP_POLICY_CONDITION_UID 7
NECP_POLICY_CONDITION_ALL_INTERFACES 8
NECP_POLICY_CONDITION_BOUND_INTERFACE 9
NECP_POLICY_CONDITION_TRAFFIC_CLASS 10
NECP_POLICY_CONDITION_IP_PROTOCOL 11
NECP_POLICY_CONDITION_LOCAL_ADDR 12
NECP_POLICY_CONDITION_REMOTE_ADDR 13
NECP_POLICY_CONDITION_LOCAL_ADDR_RANGE 14
NECP_POLICY_CONDITION_REMOTE_ADDR_RANGE 15
NECP_POLICY_CONDITION_AGENT_TYPE 16
NECP_POLICY_CONDITION_HAS_CLIENT 17
NECP_POLICY_CONDITION_LOCAL_NETWORKS 18
NECP_POLICY_CONDITION_FLOW_IP_PROTOCOL 19
NECP_POLICY_CONDITION_FLOW_LOCAL_ADDR 20
NECP_POLICY_CONDITION_FLOW_REMOTE_ADDR 21
NECP_POLICY_CONDITION_FLOW_LOCAL_ADDR_RANGE 22
NECP_POLICY_CONDITION_FLOW_REMOTE_ADDR_RANGE 23
NECP_POLICY_CONDITION_FLOW_IS_LOOPBACK 31
NECP_POLICY_CONDITION_CLIENT_FLAGS 24
NECP_POLICY_CONDITION_FLOW_LOCAL_ADDR_EMPTY 25
NECP_POLICY_CONDITION_FLOW_REMOTE_ADDR_EMPTY 26
NECP_POLICY_CONDITION_PLATFORM_BINARY 27
NECP_POLICY_CONDITION_SDK_VERSION 28
NECP_POLICY_CONDITION_SIGNING_IDENTIFIER 29
NECP_POLICY_CONDITION_PACKET_FILTER_TAGS 30
NECP_POLICY_CONDITION_DELEGATE_IS_PLATFORM_BINARY 32
NECP_POLICY_CONDITION_DOMAIN_OWNER 33
NECP_POLICY_CONDITION_DOMAIN_CONTEXT 34
NECP_POLICY_CONDITION_TRACKER_DOMAIN 35
NECP_POLICY_CONDITION_ATTRIBUTED_BUNDLE_IDENTIFIER 36
NECP_POLICY_CONDITION_SCHEME_PORT 37
NECP_POLICY_CONDITION_DOMAIN_FILTER 38
NECP_POLICY_CONDITION_SYSTEM_SIGNED_RESULT 39
NECP_POLICY_CONDITION_REAL_UID 40
NECP_POLICY_CONDITION_APPLICATION_ID 41
NECP_POLICY_CONDITION_URL 42
NECP_POLICY_CONDITION_BOUND_INTERFACE_FLAGS 43
NECP_POLICY_CONDITION_BOUND_INTERFACE_FLAGS_IDX_FLAGS 0
NECP_POLICY_CONDITION_BOUND_INTERFACE_FLAGS_IDX_EFLAGS 1
NECP_POLICY_CONDITION_BOUND_INTERFACE_FLAGS_IDX_XFLAGS 2
NECP_POLICY_CONDITION_BOUND_INTERFACE_FLAGS_IDX_MAX 3
NECP_POLICY_CONDITION_PACKET_FILTER_TAG_STACK_DROP 0x01
NECP_POLICY_CONDITION_PACKET_FILTER_TAG_MAX NECP_POLICY_CONDITION_PACKET_FILTER_TAG_STACK_DROP
NECP_POLICY_RESULT_PASS 1
NECP_POLICY_RESULT_SKIP 2
NECP_POLICY_RESULT_DROP 3
NECP_POLICY_RESULT_SOCKET_DIVERT 4
NECP_POLICY_RESULT_SOCKET_FILTER 5
NECP_POLICY_RESULT_IP_TUNNEL 6
NECP_POLICY_RESULT_IP_FILTER 7
NECP_POLICY_RESULT_TRIGGER 8
NECP_POLICY_RESULT_TRIGGER_IF_NEEDED 9
NECP_POLICY_RESULT_TRIGGER_SCOPED 10
NECP_POLICY_RESULT_NO_TRIGGER_SCOPED 11
NECP_POLICY_RESULT_SOCKET_SCOPED 12
NECP_POLICY_RESULT_ROUTE_RULES 13
NECP_POLICY_RESULT_USE_NETAGENT 14
NECP_POLICY_RESULT_NETAGENT_SCOPED 15
NECP_POLICY_RESULT_SCOPED_DIRECT 16
NECP_POLICY_RESULT_ALLOW_UNENTITLED 17
NECP_POLICY_RESULT_REMOVE_NETAGENT 18
NECP_POLICY_RESULT_MAX NECP_POLICY_RESULT_REMOVE_NETAGENT
NECP_POLICY_PASS_NO_SKIP_IPSEC 0x01
NECP_POLICY_PASS_PF_TAG 0x02
NECP_POLICY_DROP_FLAG_LOCAL_NETWORK 0x01
NECP_POLICY_DROP_FLAG_SUPPRESS_ALERTS 0x02
NECP_POLICY_LOCAL_NETWORKS_FLAG_INCLUDE_LOCAL_ADDRESSES 0x01
NECP_ROUTE_RULE_NONE 0
NECP_ROUTE_RULE_DENY_INTERFACE 1
NECP_ROUTE_RULE_ALLOW_INTERFACE 2
NECP_ROUTE_RULE_QOS_MARKING 3
NECP_ROUTE_RULE_DENY_LQM_ABORT 4
NECP_ROUTE_RULE_USE_NETAGENT 5
NECP_ROUTE_RULE_REMOVE_NETAGENT 6
NECP_ROUTE_RULE_DIVERT_SOCKET 7
NECP_ROUTE_RULE_DENY_INTERFACE_WITH_TYPE 8
NECP_ROUTE_RULE_FLAG_CELLULAR 0x01
NECP_ROUTE_RULE_FLAG_WIFI 0x02
NECP_ROUTE_RULE_FLAG_WIRED 0x04
NECP_ROUTE_RULE_FLAG_EXPENSIVE 0x08
NECP_ROUTE_RULE_FLAG_CONSTRAINED 0x10
NECP_ROUTE_RULE_FLAG_COMPANION 0x20
NECP_ROUTE_RULE_FLAG_VPN 0x40
NECP_ROUTE_RULE_FLAG_NETAGENT 0x80
NECP_ROUTE_RULES_SUPPORT_NETAGENT_EXCEPTIONS 1
NECP_ERROR_INTERNAL 0
NECP_ERROR_UNKNOWN_PACKET_TYPE 1
NECP_ERROR_INVALID_TLV 2
NECP_ERROR_POLICY_RESULT_INVALID 3
NECP_ERROR_POLICY_CONDITIONS_INVALID 4
NECP_ERROR_POLICY_ID_NOT_FOUND 5
NECP_ERROR_INVALID_PROCESS 6
NECP_ERROR_ROUTE_RULES_INVALID 7
NECP_MASK_USERSPACE_ONLY 0x80000000
NECP_MASK_PRESERVE_CONNECTIONS 0x20000000
NECP_SESSION_PRIORITY_UNKNOWN 0
NECP_SESSION_PRIORITY_CONTROL 1
NECP_SESSION_PRIORITY_CONTROL_1 2
NECP_SESSION_PRIORITY_PRIVILEGED_TUNNEL 3
NECP_SESSION_PRIORITY_HIGH 4
NECP_SESSION_PRIORITY_HIGH_1 5
NECP_SESSION_PRIORITY_HIGH_2 6
NECP_SESSION_PRIORITY_HIGH_3 7
NECP_SESSION_PRIORITY_HIGH_4 8
NECP_SESSION_PRIORITY_HIGH_RESTRICTED 9
NECP_SESSION_PRIORITY_DEFAULT 10
NECP_SESSION_PRIORITY_LOW 11
NECP_SESSION_NUM_PRIORITIES NECP_SESSION_PRIORITY_LOW
NECP_SERVICE_FLAGS_REGISTERED 0x01
NECP_MAX_NETAGENTS 16
NECP_AGENT_USE_FLAG_SCOPE 0x01
NECP_AGENT_USE_FLAG_REMOVE 0x02
NECP_TFO_COOKIE_LEN_MAX 16
NECP_STAT_ROUTE_FLAGS 1
NECP_CLIENT_STATISTICS_TYPE_TCP 1
NECP_CLIENT_STATISTICS_TYPE_UDP 2
NECP_CLIENT_STATISTICS_TYPE_QUIC 3
NECP_CLIENT_STATISTICS_TYPE_TCP_VER_1 1
NECP_CLIENT_STATISTICS_TYPE_UDP_VER_1 1
NECP_CLIENT_STATISTICS_TYPE_QUIC_VER_1 1
NECP_CLIENT_STATISTICS_TYPE_TCP_CURRENT_VER NECP_CLIENT_STATISTICS_TYPE_TCP_VER_1
NECP_CLIENT_STATISTICS_TYPE_UDP_CURRENT_VER NECP_CLIENT_STATISTICS_TYPE_UDP_VER_1
NECP_CLIENT_STATISTICS_TYPE_QUIC_CURRENT_VER NECP_CLIENT_STATISTICS_TYPE_QUIC_VER_1
NECP_CLIENT_STATISTICS_EVENT_INIT 0x00000000
NECP_CLIENT_STATISTICS_EVENT_TIME_WAIT 0x00000001
QUIC_STATELESS_RESET_TOKEN_SIZE 16
NECP_QUIC_HAS_PROBE_STATUS 1
necp_quic_hdr necp_quic_udp_stats.necp_udp_hdr
necp_quic_counts necp_quic_udp_stats.necp_udp_counts
necp_quic_basic necp_quic_udp_stats.necp_udp_basic
NECP_CLIENT_STATISTICS_BUFREQ_ID 0xbf
NECP_MAX_PER_PROCESS_CLIENT_STATISTICS_STRUCTS 512
NECP_TCP_ECN_HEURISTICS_SYN_RST 1
NECP_TCP_TFO_HEURISTICS_RST 1
NECP_CLIENT_CACHE_TYPE_ECN 1
NECP_CLIENT_CACHE_TYPE_TFO 2
NECP_CLIENT_CACHE_TYPE_ECN_VER_1 1
NECP_CLIENT_CACHE_TYPE_TFO_VER_1 1
NECP_MAX_CLIENT_PARAMETERS_SIZE 1024
NECP_MAX_CLIENT_RESULT_SIZE 512
NECP_BASE_CLIENT_RESULT_SIZE 1024
NECP_CLIENT_FLOW_RESULT_SIZE 512
NECP_OPEN_FLAG_OBSERVER 0x01
NECP_OPEN_FLAG_BACKGROUND 0x02
NECP_OPEN_FLAG_PUSH_OBSERVER 0x04
NECP_FD_SUPPORTS_GUARD 1
NECP_CLIENT_ACTION_ADD 1
NECP_CLIENT_ACTION_REMOVE 2
NECP_CLIENT_ACTION_COPY_PARAMETERS 3
NECP_CLIENT_ACTION_COPY_RESULT 4
NECP_CLIENT_ACTION_COPY_LIST 5
NECP_CLIENT_ACTION_REQUEST_NEXUS_INSTANCE 6
NECP_CLIENT_ACTION_AGENT 7
NECP_CLIENT_ACTION_COPY_AGENT 8
NECP_CLIENT_ACTION_COPY_INTERFACE 9
NECP_CLIENT_ACTION_SET_STATISTICS 10
NECP_CLIENT_ACTION_COPY_ROUTE_STATISTICS 11
NECP_CLIENT_ACTION_AGENT_USE 12
NECP_CLIENT_ACTION_MAP_SYSCTLS 13
NECP_CLIENT_ACTION_UPDATE_CACHE 14
NECP_CLIENT_ACTION_COPY_CLIENT_UPDATE 15
NECP_CLIENT_ACTION_COPY_UPDATED_RESULT 16
NECP_CLIENT_ACTION_ADD_FLOW 17
NECP_CLIENT_ACTION_REMOVE_FLOW 18
NECP_CLIENT_ACTION_CLAIM 19
NECP_CLIENT_ACTION_SIGN 20
NECP_CLIENT_ACTION_GET_INTERFACE_ADDRESS 21
NECP_CLIENT_ACTION_ACQUIRE_AGENT_TOKEN 22
NECP_CLIENT_ACTION_VALIDATE 23
NECP_CLIENT_ACTION_GET_SIGNED_CLIENT_ID 24
NECP_CLIENT_ACTION_SET_SIGNED_CLIENT_ID 25
NECP_CLIENT_ACTION_COPY_UPDATED_RESULT_FINAL 26
NECP_CLIENT_PARAMETER_APPLICATION NECP_POLICY_CONDITION_APPLICATION
NECP_CLIENT_PARAMETER_REAL_APPLICATION NECP_POLICY_CONDITION_REAL_APPLICATION
NECP_CLIENT_PARAMETER_DOMAIN NECP_POLICY_CONDITION_DOMAIN
NECP_CLIENT_PARAMETER_DOMAIN_OWNER NECP_POLICY_CONDITION_DOMAIN_OWNER
NECP_CLIENT_PARAMETER_DOMAIN_CONTEXT NECP_POLICY_CONDITION_DOMAIN_CONTEXT
NECP_CLIENT_PARAMETER_TRACKER_DOMAIN NECP_POLICY_CONDITION_TRACKER_DOMAIN
NECP_CLIENT_PARAMETER_URL NECP_POLICY_CONDITION_URL
NECP_CLIENT_PARAMETER_ATTRIBUTED_BUNDLE_IDENTIFIER NECP_POLICY_CONDITION_ATTRIBUTED_BUNDLE_IDENTIFIER
NECP_CLIENT_PARAMETER_ACCOUNT NECP_POLICY_CONDITION_ACCOUNT
NECP_CLIENT_PARAMETER_PID NECP_POLICY_CONDITION_PID
NECP_CLIENT_PARAMETER_UID NECP_POLICY_CONDITION_UID
NECP_CLIENT_PARAMETER_BOUND_INTERFACE NECP_POLICY_CONDITION_BOUND_INTERFACE
NECP_CLIENT_PARAMETER_TRAFFIC_CLASS NECP_POLICY_CONDITION_TRAFFIC_CLASS
NECP_CLIENT_PARAMETER_IP_PROTOCOL NECP_POLICY_CONDITION_IP_PROTOCOL
NECP_CLIENT_PARAMETER_LOCAL_ADDRESS NECP_POLICY_CONDITION_LOCAL_ADDR
NECP_CLIENT_PARAMETER_REMOTE_ADDRESS NECP_POLICY_CONDITION_REMOTE_ADDR
NECP_CLIENT_PARAMETER_SCHEME_PORT NECP_POLICY_CONDITION_SCHEME_PORT
NECP_CLIENT_PARAMETER_APPLICATION_ID NECP_POLICY_CONDITION_APPLICATION_ID
NECP_CLIENT_PARAMETER_NEXUS_KEY 102
NECP_CLIENT_PARAMETER_PROHIBIT_INTERFACE 100
NECP_CLIENT_PARAMETER_PROHIBIT_IF_TYPE 101
NECP_CLIENT_PARAMETER_PROHIBIT_AGENT 102
NECP_CLIENT_PARAMETER_PROHIBIT_AGENT_TYPE 103
NECP_CLIENT_PARAMETER_REQUIRE_IF_TYPE 111
NECP_CLIENT_PARAMETER_REQUIRE_AGENT 112
NECP_CLIENT_PARAMETER_REQUIRE_AGENT_TYPE 113
NECP_CLIENT_PARAMETER_PREFER_AGENT 122
NECP_CLIENT_PARAMETER_PREFER_AGENT_TYPE 123
NECP_CLIENT_PARAMETER_AVOID_AGENT 124
NECP_CLIENT_PARAMETER_AVOID_AGENT_TYPE 125
NECP_CLIENT_PARAMETER_TRIGGER_AGENT 130
NECP_CLIENT_PARAMETER_ASSERT_AGENT 131
NECP_CLIENT_PARAMETER_UNASSERT_AGENT 132
NECP_CLIENT_PARAMETER_AGENT_ADD_GROUP_MEMBERS 133
NECP_CLIENT_PARAMETER_AGENT_REMOVE_GROUP_MEMBERS 134
NECP_CLIENT_PARAMETER_REPORT_AGENT_ERROR 135
NECP_CLIENT_PARAMETER_FALLBACK_MODE 140
NECP_CLIENT_PARAMETER_PARENT_ID 150
NECP_CLIENT_PARAMETER_LOCAL_ENDPOINT 200
NECP_CLIENT_PARAMETER_REMOTE_ENDPOINT 201
NECP_CLIENT_PARAMETER_BROWSE_DESCRIPTOR 202
NECP_CLIENT_PARAMETER_RESOLVER_TAG 203
NECP_CLIENT_PARAMETER_ADVERTISE_DESCRIPTOR 204
NECP_CLIENT_PARAMETER_GROUP_DESCRIPTOR 205
NECP_CLIENT_PARAMETER_DELEGATED_UPID 210
NECP_CLIENT_PARAMETER_ETHERTYPE 220
NECP_CLIENT_PARAMETER_TRANSPORT_PROTOCOL 221
NECP_CLIENT_PARAMETER_LOCAL_ADDRESS_PREFERENCE 230
NECP_CLIENT_PARAMETER_LOCAL_ADDRESS_PREFERENCE_DEFAULT 0
NECP_CLIENT_PARAMETER_LOCAL_ADDRESS_PREFERENCE_TEMPORARY 1
NECP_CLIENT_PARAMETER_LOCAL_ADDRESS_PREFERENCE_STABLE 2
NECP_CLIENT_PARAMETER_PERSONA_ID 231
NECP_CLIENT_PARAMETER_FLAGS 250
NECP_CLIENT_PARAMETER_FLOW_DEMUX_PATTERN 251
NECP_CLIENT_PARAMETER_FLAG_MULTIPATH 0x0001
NECP_CLIENT_PARAMETER_FLAG_BROWSE 0x0002
NECP_CLIENT_PARAMETER_FLAG_PROHIBIT_EXPENSIVE 0x0004
NECP_CLIENT_PARAMETER_FLAG_LISTENER 0x0008
NECP_CLIENT_PARAMETER_FLAG_DISCRETIONARY 0x0010
NECP_CLIENT_PARAMETER_FLAG_ECN_ENABLE 0x0020
NECP_CLIENT_PARAMETER_FLAG_ECN_DISABLE 0x0040
NECP_CLIENT_PARAMETER_FLAG_TFO_ENABLE 0x0080
NECP_CLIENT_PARAMETER_FLAG_ONLY_PRIMARY_REQUIRES_TYPE 0x0100
NECP_CLIENT_PARAMETER_FLAG_CUSTOM_ETHER 0x0200
NECP_CLIENT_PARAMETER_FLAG_CUSTOM_IP 0x0400
NECP_CLIENT_PARAMETER_FLAG_INTERPOSE 0x0800
NECP_CLIENT_PARAMETER_FLAG_PROHIBIT_CONSTRAINED 0x1000
NECP_CLIENT_PARAMETER_FLAG_FALLBACK_TRAFFIC 0x2000
NECP_CLIENT_PARAMETER_FLAG_INBOUND 0x4000
NECP_CLIENT_PARAMETER_FLAG_SYSTEM_PROXY 0x8000
NECP_CLIENT_PARAMETER_FLAG_KNOWN_TRACKER 0x10000
NECP_CLIENT_PARAMETER_FLAG_UNSAFE_SOCKET_ACCESS 0x20000
NECP_CLIENT_PARAMETER_FLAG_NON_APP_INITIATED 0x40000
NECP_CLIENT_PARAMETER_FLAG_THIRD_PARTY_WEB_CONTENT 0x80000
NECP_CLIENT_PARAMETER_FLAG_SILENT 0x100000
NECP_CLIENT_PARAMETER_FLAG_APPROVED_APP_DOMAIN 0x200000
NECP_CLIENT_PARAMETER_FLAG_NO_WAKE_FROM_SLEEP 0x400000
NECP_CLIENT_PARAMETER_FLAG_REUSE_LOCAL 0x800000
NECP_CLIENT_PARAMETER_FLAG_ENHANCED_PRIVACY 0x1000000
NECP_CLIENT_PARAMETER_FLAG_WEB_SEARCH_CONTENT 0x2000000
NECP_CLIENT_PARAMETER_FLAG_ALLOW_ULTRA_CONSTRAINED 0x4000000
NECP_CLIENT_PARAMETER_FLAG_HAS_ACCOUNT_ID 0x8000000
NECP_CLIENT_RESULT_CLIENT_ID 1
NECP_CLIENT_RESULT_POLICY_RESULT 2
NECP_CLIENT_RESULT_POLICY_RESULT_PARAMETER 3
NECP_CLIENT_RESULT_FILTER_CONTROL_UNIT 4
NECP_CLIENT_RESULT_INTERFACE_INDEX 5
NECP_CLIENT_RESULT_NETAGENT 6
NECP_CLIENT_RESULT_FLAGS 7
NECP_CLIENT_RESULT_INTERFACE 8
NECP_CLIENT_RESULT_INTERFACE_OPTION 9
NECP_CLIENT_RESULT_EFFECTIVE_MTU 10
NECP_CLIENT_RESULT_FLOW 11
NECP_CLIENT_RESULT_PROTO_CTL_EVENT 12
NECP_CLIENT_RESULT_TFO_COOKIE 13
NECP_CLIENT_RESULT_TFO_FLAGS 14
NECP_CLIENT_RESULT_RECOMMENDED_MSS 15
NECP_CLIENT_RESULT_FLOW_ID 16
NECP_CLIENT_RESULT_INTERFACE_TIME_DELTA 17
NECP_CLIENT_RESULT_REASON 18
NECP_CLIENT_RESULT_FLOW_DIVERT_AGGREGATE_UNIT 19
NECP_CLIENT_RESULT_REQUEST_IN_PROCESS_FLOW_DIVERT 20
NECP_CLIENT_RESULT_NEXUS_INSTANCE 100
NECP_CLIENT_RESULT_NEXUS_PORT 101
NECP_CLIENT_RESULT_NEXUS_KEY 102
NECP_CLIENT_RESULT_NEXUS_PORT_FLOW_INDEX 103
NECP_CLIENT_RESULT_NEXUS_FLOW_STATS 104
NECP_CLIENT_RESULT_LOCAL_ENDPOINT 200
NECP_CLIENT_RESULT_REMOTE_ENDPOINT 201
NECP_CLIENT_RESULT_DISCOVERED_ENDPOINT 202
NECP_CLIENT_RESULT_RESOLVED_ENDPOINT 203
NECP_CLIENT_RESULT_LOCAL_ETHER_ADDR 204
NECP_CLIENT_RESULT_REMOTE_ETHER_ADDR 205
NECP_CLIENT_RESULT_EFFECTIVE_TRAFFIC_CLASS 210
NECP_CLIENT_RESULT_TRAFFIC_MGMT_BG 211
NECP_CLIENT_RESULT_GATEWAY 212
NECP_CLIENT_RESULT_GROUP_MEMBER 213
NECP_CLIENT_RESULT_NAT64 214
NECP_CLIENT_RESULT_ESTIMATED_THROUGHPUT 215
NECP_CLIENT_RESULT_AGENT_ERROR 216
NECP_CLIENT_RESULT_FLAG_IS_LOCAL 0x0001
NECP_CLIENT_RESULT_FLAG_IS_DIRECT 0x0002
NECP_CLIENT_RESULT_FLAG_HAS_IPV4 0x0004
NECP_CLIENT_RESULT_FLAG_HAS_IPV6 0x0008
NECP_CLIENT_RESULT_FLAG_DEFUNCT 0x0010
NECP_CLIENT_RESULT_FLAG_SATISFIED 0x0020
NECP_CLIENT_RESULT_FLAG_FLOW_ASSIGNED 0x0040
NECP_CLIENT_RESULT_FLAG_FLOW_VIABLE 0x0080
NECP_CLIENT_RESULT_FLAG_PROBE_CONNECTIVITY 0x0100
NECP_CLIENT_RESULT_FLAG_ECN_ENABLED 0x0200
NECP_CLIENT_RESULT_FLAG_FAST_OPEN_BLOCKED 0x0400
NECP_CLIENT_RESULT_FLAG_LINK_QUALITY_ABORT 0x0800
NECP_CLIENT_RESULT_FLAG_ALLOW_QOS_MARKING 0x1000
NECP_CLIENT_RESULT_FLAG_HAS_NAT64 0x2000
NECP_CLIENT_RESULT_FLAG_INTERFACE_LOW_POWER 0x4000
NECP_CLIENT_RESULT_FLAG_SPECIFIC_LISTENER 0x8000
NECP_CLIENT_RESULT_FLAG_KEXT_FILTER_PRESENT 0x10000
NECP_CLIENT_RESULT_FLAG_PF_RULES_PRESENT 0x20000
NECP_CLIENT_RESULT_FLAG_ALF_PRESENT 0x40000
NECP_CLIENT_RESULT_FLAG_PARENTAL_CONTROLS_PRESENT 0x80000
NECP_CLIENT_RESULT_FLAG_IS_GLOBAL_INTERNET 0x100000
NECP_CLIENT_RESULT_FLAG_LINK_HEURISTICS 0x200000
NECP_CLIENT_RESULT_FAST_OPEN_SND_PROBE 0x01
NECP_CLIENT_RESULT_FAST_OPEN_RCV_PROBE 0x02
NECP_CLIENT_RESULT_RECOMMENDED_MSS_NONE 0x01
NECP_CLIENT_RESULT_RECOMMENDED_MSS_LOW 0x02
NECP_CLIENT_RESULT_RECOMMENDED_MSS_MEDIUM 0x04
NECP_CLIENT_RESULT_REASON_EXPENSIVE_PROHIBITED 1
NECP_CLIENT_RESULT_REASON_CONSTRAINED_PROHIBITED 2
NECP_CLIENT_RESULT_REASON_CELLULAR_DENIED 3
NECP_CLIENT_RESULT_REASON_WIFI_DENIED 4
NECP_CLIENT_RESULT_REASON_LOCAL_NETWORK_PROHIBITED 5
NECP_CLIENT_RESULT_REASON_ULTRA_CONSTRAINED_NOT_ALLOWED 6
NECP_INTERFACE_SUPPORTS_TSO 1
NECP_INTERFACE_SUPPORTS_HWCSUM 1
NECP_INTERFACE_FLAG_EXPENSIVE 0x0001
NECP_INTERFACE_FLAG_TXSTART 0X0002
NECP_INTERFACE_FLAG_NOACKPRI 0x0004
NECP_INTERFACE_FLAG_3CARRIERAGG 0x0008
NECP_INTERFACE_FLAG_IS_LOW_POWER 0x0010
NECP_INTERFACE_FLAG_MPK_LOG 0x0020
NECP_INTERFACE_FLAG_CONSTRAINED 0x0040
NECP_INTERFACE_FLAG_HAS_NETMASK 0x0080
NECP_INTERFACE_FLAG_HAS_BROADCAST 0x0100
NECP_INTERFACE_FLAG_SUPPORTS_MULTICAST 0x0200
NECP_INTERFACE_FLAG_HAS_DNS 0x0400
NECP_INTERFACE_FLAG_HAS_NAT64 0x0800
NECP_INTERFACE_FLAG_IPV4_ROUTABLE 0x1000
NECP_INTERFACE_FLAG_IPV6_ROUTABLE 0x2000
NECP_INTERFACE_FLAG_ULTRA_CONSTRAINED 0x4000
NECP_USES_INTERFACE_OPTIONS_FOR_BROWSE 1
NECP_CLIENT_ENDPOINT_TYPE_APPLICATION_SERVICE 6
NECP_CLIENT_FLOW_FLAGS_ALLOW_NEXUS 0x01
NECP_CLIENT_FLOW_FLAGS_USE_CLIENT_ID 0x02
NECP_CLIENT_FLOW_FLAGS_BROWSE 0x04
NECP_CLIENT_FLOW_FLAGS_RESOLVE 0x08
NECP_CLIENT_FLOW_FLAGS_OVERRIDE_ADDRESS 0x10
NECP_CLIENT_FLOW_FLAGS_OVERRIDE_IP_PROTOCOL 0x20
NECP_CLIENT_UPDATE_TYPE_PARAMETERS 1
NECP_CLIENT_UPDATE_TYPE_RESULT 2
NECP_CLIENT_UPDATE_TYPE_REMOVE 3
NECP_CLIENT_SIGN_TYPE_RESOLVER_ANSWER 1
NECP_CLIENT_SIGN_TYPE_BROWSE_RESULT 2
NECP_CLIENT_SIGN_TYPE_SERVICE_RESOLVER_ANSWER 3
NECP_CLIENT_SIGN_TYPE_SYSTEM_RESOLVER_ANSWER 4
NECP_CLIENT_SIGN_TYPE_SYSTEM_BROWSE_RESULT 5
NECP_CLIENT_SIGN_TYPE_SYSTEM_SERVICE_RESOLVER_ANSWER 6
NECP_CLIENT_ACTION_SIGN_MAX_STRING_LENGTH 1024
NECP_CLIENT_ACTION_SIGN_TAG_LENGTH 32
NECP_CLIENT_ACTION_SIGN_DEFAULT_DATA_LENGTH 128
NECP_CLIENT_ACTION_SIGN_MAX_TOTAL_LENGTH 4096
NECP_FILTER_UNIT_NO_FILTER UINT32_MAX
NECP_CLIENT_SIGNED_CLIENT_ID_TYPE_UUID 1
MAX_NECP_DROP_DEST_LEVEL_ADDRS 8
NECP_DEMUX_MAX_LEN 32
NECPLOG(level, format, ...) do {                                                                                        	if (level == LOG_ERR) {                                                          	    os_log_error(necp_log_handle, "%s: " format "\n", __FUNCTION__, __VA_ARGS__); 	} else {                                                                         	    os_log(necp_log_handle, "%s: " format "\n", __FUNCTION__, __VA_ARGS__);       	}                                                                                } while (0)
NECPLOG0(level, msg) do {                                                                                       	if (level == LOG_ERR) {                                                          	    os_log_error(necp_log_handle, "%s: %s\n", __FUNCTION__, msg);                 	} else {                                                                         	    os_log(necp_log_handle, "%s: %s\n", __FUNCTION__, msg);                       	}                                                                                } while (0)
NECPDATATRACELOG(level, format, ...) do {                                                                                            if (level == LOG_ERR) {                                                          	os_log_error(necp_data_trace_log_handle, "%s: " format "\n", __FUNCTION__, __VA_ARGS__);     } else {                                                                         	os_log(necp_data_trace_log_handle, "%s: " format "\n", __FUNCTION__, __VA_ARGS__);           }                                                                                } while (0)
NECPCTL_DROP_ALL_LEVEL 1
NECPCTL_DEBUG 2
NECPCTL_PASS_LOOPBACK 3
NECPCTL_PASS_KEEPALIVES 4
NECPCTL_SOCKET_POLICY_COUNT 5
NECPCTL_SOCKET_NON_APP_POLICY_COUNT 6
NECPCTL_IP_POLICY_COUNT 7
NECPCTL_SESSION_COUNT 8
NECPCTL_CLIENT_FD_COUNT 9
NECPCTL_CLIENT_COUNT 10
NECPCTL_ARENA_COUNT 11
NECPCTL_NEXUS_FLOW_COUNT 12
NECPCTL_SOCKET_FLOW_COUNT 13
NECPCTL_IF_FLOW_COUNT 14
NECPCTL_OBSERVER_FD_COUNT 15
NECPCTL_OBSERVER_MESSAGE_LIMIT 16
NECPCTL_SYSCTL_ARENA_COUNT 17
NECPCTL_DROP_UNENTITLED_LEVEL 18
NECPCTL_PASS_INTERPOSE 19
NECPCTL_RESTRICT_MULTICAST 20
NECPCTL_DEDUP_POLICIES 21
NECPCTL_CLIENT_TRACING_LEVEL 22
NECPCTL_CLIENT_TRACING_PID 23
NECPCTL_DROP_MANAGEMENT_LEVEL 24
NECPCTL_TRIE_COUNT 25
NECP_LOOPBACK_PASS_ALL 1
NECP_LOOPBACK_PASS_WITH_FILTER 2
NECPCTL_NAMES {                                 	{ 0, 0 },                                                       	{ "drop_all_level", CTLTYPE_INT },      	{ "debug", CTLTYPE_INT },                       	{ "pass_loopback", CTLTYPE_INT },           { "pass_keepalives", CTLTYPE_INT },         { "pass_interpose", CTLTYPE_INT },      }
NECP_KERNEL_POLICY_ID_NONE 0
NECP_KERNEL_POLICY_ID_NO_MATCH 1
NECP_KERNEL_POLICY_ID_FIRST_VALID_SOCKET 2
NECP_KERNEL_POLICY_ID_FIRST_VALID_IP UINT16_MAX
NECP_KERNEL_POLICY_RESULT_NONE 0
NECP_KERNEL_POLICY_RESULT_PASS NECP_POLICY_RESULT_PASS
NECP_KERNEL_POLICY_RESULT_SKIP NECP_POLICY_RESULT_SKIP
NECP_KERNEL_POLICY_RESULT_DROP NECP_POLICY_RESULT_DROP
NECP_KERNEL_POLICY_RESULT_SOCKET_DIVERT NECP_POLICY_RESULT_SOCKET_DIVERT
NECP_KERNEL_POLICY_RESULT_SOCKET_FILTER NECP_POLICY_RESULT_SOCKET_FILTER
NECP_KERNEL_POLICY_RESULT_IP_TUNNEL NECP_POLICY_RESULT_IP_TUNNEL
NECP_KERNEL_POLICY_RESULT_IP_FILTER NECP_POLICY_RESULT_IP_FILTER
NECP_KERNEL_POLICY_RESULT_SOCKET_SCOPED NECP_POLICY_RESULT_SOCKET_SCOPED
NECP_KERNEL_POLICY_RESULT_ROUTE_RULES NECP_POLICY_RESULT_ROUTE_RULES
NECP_KERNEL_POLICY_RESULT_USE_NETAGENT NECP_POLICY_RESULT_USE_NETAGENT
NECP_KERNEL_POLICY_RESULT_NETAGENT_SCOPED NECP_POLICY_RESULT_NETAGENT_SCOPED
NECP_KERNEL_POLICY_RESULT_SCOPED_DIRECT NECP_POLICY_RESULT_SCOPED_DIRECT
NECP_KERNEL_POLICY_RESULT_ALLOW_UNENTITLED NECP_POLICY_RESULT_ALLOW_UNENTITLED
NECP_KERNEL_POLICY_RESULT_REMOVE_NETAGENT NECP_POLICY_RESULT_REMOVE_NETAGENT
NECP_KERNEL_POLICY_PASS_NO_SKIP_IPSEC NECP_POLICY_PASS_NO_SKIP_IPSEC
NECP_KERNEL_POLICY_PASS_PF_TAG NECP_POLICY_PASS_PF_TAG
NECP_KERNEL_POLICY_DROP_FLAG_LOCAL_NETWORK NECP_POLICY_DROP_FLAG_LOCAL_NETWORK
NECP_KERNEL_POLICY_DROP_FLAG_SUPPRESS_ALERTS NECP_POLICY_DROP_FLAG_SUPPRESS_ALERTS
MAX_KERNEL_SOCKET_POLICIES 1
MAX_KERNEL_IP_OUTPUT_POLICIES 4
NECP_FLOWADV_IDX_INVALID UINT32_MAX
NECP_MAX_DEMUX_PATTERNS 4
NECP_CLIENT_CBACTION_NONVIABLE 1
NECP_CLIENT_CBACTION_VIABLE 2
NECP_CLIENT_CBACTION_INITIAL 3
NECP_CLIENT_TRACE_LEVEL_CLIENT 1
NECP_CLIENT_TRACE_LEVEL_FLOW 2
NECP_CLIENT_TRACE_LEVEL_PARAMS 3
NECP_CLIENT_LOG(client, fmt, ...)                                                                           if (client && NECP_ENABLE_CLIENT_TRACE(NECP_CLIENT_TRACE_LEVEL_CLIENT)) {                                   	uuid_string_t client_uuid_str = { };                                                                        	uuid_unparse_lower(client->client_id, client_uuid_str);                                                     	NECPLOG(LOG_NOTICE, "NECP_CLIENT_LOG <pid %d %s>: " fmt "\n", client ? client->proc_pid : 0, client_uuid_str, ##__VA_ARGS__);     }
NECP_CLIENT_FLOW_LOG(client, flow, fmt, ...)                                                                if (client && flow && NECP_ENABLE_CLIENT_TRACE(NECP_CLIENT_TRACE_LEVEL_FLOW)) {                             	uuid_string_t client_uuid_str = { };                                                                        	uuid_unparse_lower(client->client_id, client_uuid_str);                                                     	uuid_string_t flow_uuid_str = { };                                                                          	uuid_unparse_lower(flow->registration_id, flow_uuid_str);                                                   	NECPLOG(LOG_NOTICE, "NECP CLIENT FLOW TRACE <pid %d %s> <flow %s>: " fmt "\n", client ? client->proc_pid : 0, client_uuid_str, flow_uuid_str, ##__VA_ARGS__);     }
NECP_CLIENT_PARAMS_LOG(client, fmt, ...)                                                                    if (client && NECP_ENABLE_CLIENT_TRACE(NECP_CLIENT_TRACE_LEVEL_PARAMS)) {                                       uuid_string_t client_uuid_str = { };                                                                            uuid_unparse_lower(client->client_id, client_uuid_str);                                                         NECPLOG(LOG_NOTICE, "NECP_CLIENT_PARAMS_LOG <pid %d %s>: " fmt "\n", client ? client->proc_pid : 0, client_uuid_str, ##__VA_ARGS__);     }
NECP_SOCKET_PARAMS_LOG(so, fmt, ...)                                                                        if (so && NECP_ENABLE_SOCKET_TRACE(NECP_CLIENT_TRACE_LEVEL_PARAMS)) {                                           NECPLOG(LOG_NOTICE, "NECP_SOCKET_PARAMS_LOG <pid %d>: " fmt "\n", NECP_SOCKET_PID(so), ##__VA_ARGS__);          }
NECP_SOCKET_ATTRIBUTE_LOG(fmt, ...)                                                                         if (necp_client_tracing_level >= NECP_CLIENT_TRACE_LEVEL_PARAMS) {                                              NECPLOG(LOG_NOTICE, "NECP_SOCKET_ATTRIBUTE_LOG: " fmt "\n", ##__VA_ARGS__);                                     }
NECP_CLIENT_TRACKER_LOG(pid, fmt, ...)                                                                      if (pid) {                                                                                                      NECPLOG(LOG_NOTICE, "NECP_CLIENT_TRACKER_LOG <pid %d>: " fmt "\n", pid, ##__VA_ARGS__);                         }
NECP_MAX_CLIENT_LIST_SIZE 1024 * 1024
NECP_MAX_AGENT_ACTION_SIZE 10 * 1024
NECP_PARSED_PARAMETERS_FIELD_LOCAL_ADDR 0x00001
NECP_PARSED_PARAMETERS_FIELD_REMOTE_ADDR 0x00002
NECP_PARSED_PARAMETERS_FIELD_REQUIRED_IF 0x00004
NECP_PARSED_PARAMETERS_FIELD_PROHIBITED_IF 0x00008
NECP_PARSED_PARAMETERS_FIELD_REQUIRED_IFTYPE 0x00010
NECP_PARSED_PARAMETERS_FIELD_PROHIBITED_IFTYPE 0x00020
NECP_PARSED_PARAMETERS_FIELD_REQUIRED_AGENT 0x00040
NECP_PARSED_PARAMETERS_FIELD_PROHIBITED_AGENT 0x00080
NECP_PARSED_PARAMETERS_FIELD_PREFERRED_AGENT 0x00100
NECP_PARSED_PARAMETERS_FIELD_AVOIDED_AGENT 0x00200
NECP_PARSED_PARAMETERS_FIELD_REQUIRED_AGENT_TYPE 0x00400
NECP_PARSED_PARAMETERS_FIELD_PROHIBITED_AGENT_TYPE 0x00800
NECP_PARSED_PARAMETERS_FIELD_PREFERRED_AGENT_TYPE 0x01000
NECP_PARSED_PARAMETERS_FIELD_AVOIDED_AGENT_TYPE 0x02000
NECP_PARSED_PARAMETERS_FIELD_FLAGS 0x04000
NECP_PARSED_PARAMETERS_FIELD_IP_PROTOCOL 0x08000
NECP_PARSED_PARAMETERS_FIELD_EFFECTIVE_PID 0x10000
NECP_PARSED_PARAMETERS_FIELD_EFFECTIVE_UUID 0x20000
NECP_PARSED_PARAMETERS_FIELD_TRAFFIC_CLASS 0x40000
NECP_PARSED_PARAMETERS_FIELD_LOCAL_PORT 0x80000
NECP_PARSED_PARAMETERS_FIELD_DELEGATED_UPID 0x100000
NECP_PARSED_PARAMETERS_FIELD_ETHERTYPE 0x200000
NECP_PARSED_PARAMETERS_FIELD_TRANSPORT_PROTOCOL 0x400000
NECP_PARSED_PARAMETERS_FIELD_LOCAL_ADDR_PREFERENCE 0x800000
NECP_PARSED_PARAMETERS_FIELD_ATTRIBUTED_BUNDLE_IDENTIFIER 0x1000000
NECP_PARSED_PARAMETERS_FIELD_PARENT_UUID 0x2000000
NECP_PARSED_PARAMETERS_FIELD_FLOW_DEMUX_PATTERN 0x4000000
NECP_PARSED_PARAMETERS_FIELD_UID 0x8000000
NECP_PARSED_PARAMETERS_FIELD_PERSONA_ID 0x10000000
NECP_MAX_INTERFACE_PARAMETERS 16
NECP_MAX_AGENT_PARAMETERS 4
NECP_CLIENT_INTERFACE_OPTION_STATIC_COUNT 4
NECP_CLIENT_MAX_INTERFACE_OPTIONS 32
NECP_CLIENT_LOCK(_c) lck_mtx_lock(&_c->lock)
NECP_CLIENT_UNLOCK(_c) lck_mtx_unlock(&_c->lock)
NECP_CLIENT_ASSERT_LOCKED(_c) LCK_MTX_ASSERT(&_c->lock, LCK_MTX_ASSERT_OWNED)
NECP_CLIENT_ASSERT_UNLOCKED(_c) LCK_MTX_ASSERT(&_c->lock, LCK_MTX_ASSERT_NOTOWNED)
NECP_CLIENT_ROUTE_LOCK(_c) lck_mtx_lock(&_c->route_lock)
NECP_CLIENT_ROUTE_UNLOCK(_c) lck_mtx_unlock(&_c->route_lock)
NAIF_ATTACHED 0x1
NAIF_REDIRECT 0x2
NAIF_DEFUNCT 0x4
NECP_FD_REPORTED_AGENT_COUNT 2
NECP_FD_LOCK(_f) lck_mtx_lock(&_f->fd_lock)
NECP_FD_UNLOCK(_f) lck_mtx_unlock(&_f->fd_lock)
NECP_FD_ASSERT_LOCKED(_f) LCK_MTX_ASSERT(&_f->fd_lock, LCK_MTX_ASSERT_OWNED)
NECP_FD_ASSERT_UNLOCKED(_f) LCK_MTX_ASSERT(&_f->fd_lock, LCK_MTX_ASSERT_NOTOWNED)
NECP_STATS_LIST_LOCK_EXCLUSIVE() lck_rw_lock_exclusive(&necp_collect_stats_list_lock)
NECP_STATS_LIST_LOCK_SHARED() lck_rw_lock_shared(&necp_collect_stats_list_lock)
NECP_STATS_LIST_UNLOCK() lck_rw_done(&necp_collect_stats_list_lock)
NECP_CLIENT_TREE_LOCK_EXCLUSIVE() lck_rw_lock_exclusive(&necp_client_tree_lock)
NECP_CLIENT_TREE_LOCK_SHARED() lck_rw_lock_shared(&necp_client_tree_lock)
NECP_CLIENT_TREE_UNLOCK() lck_rw_done(&necp_client_tree_lock)
NECP_CLIENT_TREE_ASSERT_LOCKED() LCK_RW_ASSERT(&necp_client_tree_lock, LCK_RW_ASSERT_HELD)
NECP_FLOW_TREE_LOCK_EXCLUSIVE() lck_rw_lock_exclusive(&necp_flow_tree_lock)
NECP_FLOW_TREE_LOCK_SHARED() lck_rw_lock_shared(&necp_flow_tree_lock)
NECP_FLOW_TREE_UNLOCK() lck_rw_done(&necp_flow_tree_lock)
NECP_FLOW_TREE_ASSERT_LOCKED() LCK_RW_ASSERT(&necp_flow_tree_lock, LCK_RW_ASSERT_HELD)
NECP_FD_LIST_LOCK_EXCLUSIVE() lck_rw_lock_exclusive(&necp_fd_lock)
NECP_FD_LIST_LOCK_SHARED() lck_rw_lock_shared(&necp_fd_lock)
NECP_FD_LIST_UNLOCK() lck_rw_done(&necp_fd_lock)
NECP_FD_LIST_ASSERT_LOCKED() LCK_RW_ASSERT(&necp_fd_lock, LCK_RW_ASSERT_HELD)
NECP_OBSERVER_LIST_LOCK_EXCLUSIVE() lck_rw_lock_exclusive(&necp_observer_lock)
NECP_OBSERVER_LIST_LOCK_SHARED() lck_rw_lock_shared(&necp_observer_lock)
NECP_OBSERVER_LIST_UNLOCK() lck_rw_done(&necp_observer_lock)
NECP_UPDATE_ALL_CLIENTS_LOCK_EXCLUSIVE() lck_rw_lock_exclusive(&necp_update_all_clients_lock)
NECP_UPDATE_ALL_CLIENTS_SHARED_TO_EXCLUSIVE() lck_rw_lock_shared_to_exclusive(&necp_update_all_clients_lock)
NECP_UPDATE_ALL_CLIENTS_SHARED() lck_rw_lock_shared(&necp_update_all_clients_lock)
NECP_UPDATE_ALL_CLIENTS_UNLOCK() lck_rw_done(&necp_update_all_clients_lock)
NECP_MAX_FLOW_DIVERT_NEEDED_PIDS 4
INTERFACE_FLAGS_SHIFT 32
INTERFACE_FLAGS_MASK 0xffffffff
INTERFACE_INDEX_SHIFT 0
INTERFACE_INDEX_MASK 0xffffffff
necp_client_address_is_valid(S) _necp_client_address_is_valid(SA(S))
NECP_MAX_SOCKET_ATTRIBUTE_STRING_LENGTH 253
NETAGENT_DOMAIN_RADIO_MANAGER "WirelessRadioManager"
NETAGENT_TYPE_RADIO_MANAGER "WirelessRadioManager:BB Manager"
NECP_CLIENT_ACTION_FUNCTION __attribute__((noinline))
NECP_MAX_MATCH_POLICY_PARAMETER_SIZE 1024
IA_TO_NRP_FLAG(flag) if (ia->ia6_flags & IN6_IFF_##flag) {                   	                reply.nrp_flags |= NETSRC_FLAG_IP6_##flag;      	        }
NETSRC_CTLNAME "com.apple.netsrc"
NETSRC_VERSION1 1
NETSRC_VERSION2 2
NETSRC_CURVERS NETSRC_VERSION2
nrq_sin _usa.sin
nrq_sin6 _usa.sin6
NETSRC_IP6_FLAG_TENTATIVE 0x0001
NETSRC_IP6_FLAG_TEMPORARY 0x0002
NETSRC_IP6_FLAG_DEPRECATED 0x0004
NETSRC_IP6_FLAG_OPTIMISTIC 0x0008
NETSRC_IP6_FLAG_SECURED 0x0010
NETSRC_FLAG_IP6_TENTATIVE NETSRC_IP6_FLAG_TENTATIVE
NETSRC_FLAG_IP6_TEMPORARY NETSRC_IP6_FLAG_TEMPORARY
NETSRC_FLAG_IP6_DEPRECATED NETSRC_IP6_FLAG_DEPRECATED
NETSRC_FLAG_IP6_OPTIMISTIC NETSRC_IP6_FLAG_OPTIMISTIC
NETSRC_FLAG_IP6_SECURED NETSRC_IP6_FLAG_SECURED
NETSRC_FLAG_ROUTEABLE 0x00000020
NETSRC_FLAG_DIRECT 0x00000040
NETSRC_FLAG_AWDL 0x00000080
NETSRC_FLAG_IP6_DYNAMIC 0x00000100
NETSRC_FLAG_IP6_AUTOCONF 0x00000200
netsrc_rep netsrc_repv2
nrp_sin nrp_src.sin
nrp_sin6 nrp_src.sin6
NETAGENTLOG(level, format, ...) do {                                                 if (level <= netagent_debug) {                                                       	if (level == LOG_ERR) {                                                          	    os_log_error(OS_LOG_DEFAULT, "%s: " format "\n", __FUNCTION__, __VA_ARGS__); 	} else {                                                                         	    os_log(OS_LOG_DEFAULT, "%s: " format "\n", __FUNCTION__, __VA_ARGS__);       	}                                                                                    }                                                                                    } while (0)
NETAGENTLOG0(level, msg) do {                                                        if (level <= netagent_debug) {                                                       	        if (level == LOG_ERR) {                                                          	    os_log_error(OS_LOG_DEFAULT, "%s: %s\n", __FUNCTION__, msg);                 	} else {                                                                         	    os_log(OS_LOG_DEFAULT, "%s: %s\n", __FUNCTION__, msg);                       	}                                                                                    }                                                                                    } while (0)
NETAGENT_MAX_CLIENT_ERROR_COUNT 32
NETAGENT_LIST_LOCK_EXCLUSIVE() lck_rw_lock_exclusive(&netagent_list_lock)
NETAGENT_LIST_LOCK_SHARED() lck_rw_lock_shared(&netagent_list_lock)
NETAGENT_LIST_UNLOCK() lck_rw_done(&netagent_list_lock)
NETAGENT_LIST_ASSERT_LOCKED() LCK_RW_ASSERT(&netagent_list_lock, LCK_RW_ASSERT_HELD)
NETAGENT_SESSION_LOCK(session) lck_mtx_lock(&session->session_lock)
NETAGENT_SESSION_UNLOCK(session) lck_mtx_unlock(&session->session_lock)
NETAGENT_SESSION_ASSERT_LOCKED(session) LCK_MTX_ASSERT(&session->session_lock, LCK_MTX_ASSERT_OWNED)
NETAGENT_LOCK_EXCLUSIVE(registration) lck_rw_lock_exclusive(&registration->agent_lock)
NETAGENT_LOCK_SHARED(registration) lck_rw_lock_shared(&registration->agent_lock)
NETAGENT_LOCK_SHARED_TO_EXCLUSIVE(registration) lck_rw_lock_shared_to_exclusive(&registration->agent_lock)
NETAGENT_UNLOCK(registration) lck_rw_done(&registration->agent_lock)
NETAGENT_ASSERT_LOCKED(registration) LCK_RW_ASSERT(&registration->agent_lock, LCK_RW_ASSERT_HELD)
_NETAGENT_H_ None
NETAGENT_CONTROL_NAME "com.apple.net.netagent"
NETAGENT_MESSAGE_TYPE_REGISTER 1
NETAGENT_MESSAGE_TYPE_UNREGISTER 2
NETAGENT_MESSAGE_TYPE_UPDATE 3
NETAGENT_MESSAGE_TYPE_GET 4
NETAGENT_MESSAGE_TYPE_TRIGGER 5
NETAGENT_MESSAGE_TYPE_ASSERT 6
NETAGENT_MESSAGE_TYPE_UNASSERT 7
NETAGENT_MESSAGE_TYPE_TRIGGER_ASSERT 8
NETAGENT_MESSAGE_TYPE_TRIGGER_UNASSERT 9
NETAGENT_MESSAGE_TYPE_REQUEST_NEXUS 10
NETAGENT_MESSAGE_TYPE_ASSIGN_NEXUS 11
NETAGENT_MESSAGE_TYPE_CLOSE_NEXUS 12
NETAGENT_MESSAGE_TYPE_CLIENT_TRIGGER 13
NETAGENT_MESSAGE_TYPE_CLIENT_ASSERT 14
NETAGENT_MESSAGE_TYPE_CLIENT_UNASSERT 15
NETAGENT_OPTION_TYPE_REGISTER NETAGENT_MESSAGE_TYPE_REGISTER
NETAGENT_OPTION_TYPE_UNREGISTER NETAGENT_MESSAGE_TYPE_UNREGISTER
NETAGENT_OPTION_TYPE_UPDATE NETAGENT_MESSAGE_TYPE_UPDATE
NETAGENT_OPTION_TYPE_ASSIGN_NEXUS NETAGENT_MESSAGE_TYPE_ASSIGN_NEXUS
NETAGENT_OPTION_TYPE_USE_COUNT 16
NETAGENT_MESSAGE_TYPE_ABORT_NEXUS 17
NETAGENT_MESSAGE_TYPE_ADD_GROUP_MEMBERS 18
NETAGENT_MESSAGE_TYPE_REMOVE_GROUP_MEMBERS 19
NETAGENT_MESSAGE_TYPE_ASSIGN_GROUP_MEMBERS 20
NETAGENT_OPTION_TYPE_ADD_TOKEN 21
NETAGENT_OPTION_TYPE_FLUSH_TOKENS 22
NETAGENT_OPTION_TYPE_TOKEN_COUNT 23
NETAGENT_OPTION_TYPE_TOKEN_LOW_WATER 24
NETAGENT_MESSAGE_TYPE_TOKENS_NEEDED 25
NETAGENT_MESSAGE_TYPE_CLIENT_ERROR 26
NETAGENT_OPTION_TYPE_RESET_CLIENT_ERROR 27
NETAGENT_OPTION_TYPE_ENABLE_SESSION_MODE 28
NETAGENT_OPTION_TYPE_UNREGISTER_ALL 29
NETAGENT_MESSAGE_FLAGS_RESPONSE 0x01
NETAGENT_MESSAGE_ERROR_NONE 0
NETAGENT_MESSAGE_ERROR_INTERNAL 1
NETAGENT_MESSAGE_ERROR_UNKNOWN_TYPE 2
NETAGENT_MESSAGE_ERROR_INVALID_DATA 3
NETAGENT_MESSAGE_ERROR_NOT_REGISTERED 4
NETAGENT_MESSAGE_ERROR_ALREADY_REGISTERED 5
NETAGENT_MESSAGE_ERROR_CANNOT_UPDATE 6
NETAGENT_MESSAGE_ERROR_CANNOT_ASSIGN 7
NETAGENT_DOMAINSIZE 32
NETAGENT_TYPESIZE 32
NETAGENT_DESCSIZE 128
NETAGENT_MAX_DATA_SIZE 4096
NETAGENT_MAX_TOKEN_COUNT 256
NETAGENT_FLAG_REGISTERED 0x0001
NETAGENT_FLAG_ACTIVE 0x0002
NETAGENT_FLAG_KERNEL_ACTIVATED 0x0004
NETAGENT_FLAG_USER_ACTIVATED 0x0008
NETAGENT_FLAG_VOLUNTARY 0x0010
NETAGENT_FLAG_SPECIFIC_USE_ONLY 0x0020
NETAGENT_FLAG_NETWORK_PROVIDER 0x0040
NETAGENT_FLAG_NEXUS_PROVIDER 0x0080
NETAGENT_FLAG_SUPPORTS_BROWSE 0x0100
NETAGENT_FLAG_REQUIRES_ASSERT 0x0200
NETAGENT_FLAG_NEXUS_LISTENER 0x0400
NETAGENT_FLAG_UPDATE_IMMEDIATELY 0x0800
NETAGENT_FLAG_CUSTOM_ETHER_NEXUS 0x2000
NETAGENT_FLAG_CUSTOM_IP_NEXUS 0x4000
NETAGENT_FLAG_INTERPOSE_NEXUS 0x8000
NETAGENT_FLAG_SUPPORTS_RESOLVE 0x10000
NETAGENT_FLAG_SUPPORTS_GROUPS 0x20000
NETAGENT_NEXUS_MAX_REQUEST_TYPES 16
NETAGENT_NEXUS_MAX_RESOLUTION_TYPE_PAIRS 15
NETAGENT_NEXUS_FRAME_TYPE_UNKNOWN 0
NETAGENT_NEXUS_FRAME_TYPE_LINK 1
NETAGENT_NEXUS_FRAME_TYPE_INTERNET 2
NETAGENT_NEXUS_FRAME_TYPE_TRANSPORT 3
NETAGENT_NEXUS_FRAME_TYPE_APPLICATION 4
NETAGENT_NEXUS_ENDPOINT_TYPE_ADDRESS 1
NETAGENT_NEXUS_ENDPOINT_TYPE_HOST 2
NETAGENT_NEXUS_ENDPOINT_TYPE_BONJOUR 3
NETAGENT_NEXUS_ENDPOINT_TYPE_SRV 5
NETAGENT_NEXUS_FLAG_SUPPORTS_USER_PACKET_POOL 0x1
NETAGENT_NEXUS_FLAG_ASSERT_UNSUPPORTED 0x2
NETAGENT_NEXUS_FLAG_SHOULD_USE_EVENT_RING 0x4
NETAGENT_NEXUS_HAS_MAX_BUF_SIZE 1
NETAGENT_TRIGGER_FLAG_USER 0x0001
NETAGENT_TRIGGER_FLAG_KERNEL 0x0002
NETAGENT_EVENT_TRIGGER NETAGENT_MESSAGE_TYPE_CLIENT_TRIGGER
NETAGENT_EVENT_ASSERT NETAGENT_MESSAGE_TYPE_CLIENT_ASSERT
NETAGENT_EVENT_UNASSERT NETAGENT_MESSAGE_TYPE_CLIENT_UNASSERT
NETAGENT_EVENT_NEXUS_FLOW_INSERT NETAGENT_MESSAGE_TYPE_REQUEST_NEXUS
NETAGENT_EVENT_NEXUS_FLOW_REMOVE NETAGENT_MESSAGE_TYPE_CLOSE_NEXUS
NETAGENT_EVENT_NEXUS_FLOW_ABORT NETAGENT_MESSAGE_TYPE_ABORT_NEXUS
__NET_API_STATS__ None
NAS_HAS_FLTR_OS_COUNTS 1
INC_ATOMIC_INT64_LIM(counter) {                                 	int64_t val;                                                    	do {                                                            	        val = counter;                                          	        if (val >= INT64_MAX) {                                 	                break;                                          	        }                                                       	} while (!OSCompareAndSwap64(val, val + 1, &(counter)));        }
_NET_NETKEV_H_ None
_NET_LOG_COMMON_H_ None
NET_LOG_SUBSYSTEM_PREFIX "com.apple.xnu.net"
NET_LOG_SUBSYSTEM_MPTCP NET_LOG_SUBSYSTEM_PREFIX ".mptcp"
NET_LOG_SUBSYSTEM_TCP NET_LOG_SUBSYSTEM_PREFIX ".tcp"
__NET_NET_OSDEP_H_DEFINED_ None
HAVE_OLD_BPF None
ifa_list ifa_link
if_addrlist if_addrhead
if_list if_link
WITH_CONVERT_AND_STRIP_IP_LEN None
WITH_CONVERT_IP_OFF None
_NET_NET_PERF_H_ None
NET_PERF_BARS 4
NET_ID_STR_MAX_LEN 2048
FIRST_NET_STR_ID 1000
__NSI_STR_ID__ None
_NET_SYSCTL_H_ None
DECLARE_SYSCTL_HANDLER_ARG_ARRAY(element_type, expected_array_size,                                               	    array_var,                                                         	    len_var)                                                               unsigned int len_var = (unsigned int)arg2;                                 if (len_var != (expected_array_size)) {                                	    return EINVAL;                                                         }                                                                          element_type * array_var = __unsafe_forge_bidi_indexable(              	element_type *, arg1, len_var * sizeof(element_type))
NSTAT_TRACE_ENABLED 0
NSTAT_FUZZ_TIMING 0
_NSTAT_LOG(handle, type, fmt, ...) do {                           	os_log_with_type(handle, type, "%s - " fmt, __func__, ##__VA_ARGS__); } while (0)
NSTAT_LOG(fmt, ...)         _NSTAT_LOG(nstat_log_handle, OS_LOG_TYPE_DEFAULT, fmt, ##__VA_ARGS__)
NSTAT_LOG_DEBUG(fmt, ...)   _NSTAT_LOG(nstat_log_handle, OS_LOG_TYPE_DEBUG,   fmt, ##__VA_ARGS__)
NSTAT_LOG_INFO(fmt, ...)    _NSTAT_LOG(nstat_log_handle, OS_LOG_TYPE_INFO,    fmt, ##__VA_ARGS__)
NSTAT_LOG_ERROR(fmt, ...)   _NSTAT_LOG(nstat_log_handle, OS_LOG_TYPE_ERROR,   fmt, ##__VA_ARGS__)
NSTAT_DEBUG_SOCKET_LOG(so, fmt, ...)            if (NSTAT_DEBUG_SOCKET_ON(so)) {                	    NSTAT_LOG_DEBUG("NSTAT_DEBUG_SOCKET <pid %d>: " fmt, (so->so_flags & SOF_DELEGATED ? so->e_pid : so->last_pid), ##__VA_ARGS__);     }
QUERY_CONTINUATION_MIN_SRC_COUNT 5
ROUNDUP64(x) P2ROUNDUP((x), sizeof (u_int64_t))
ADVANCE64(p, n) (void*)((char *)(p) + ROUNDUP64(n))
NSTAT_TRACE(field, client, qual) {     nstat_trace(offsetof(struct nstat_metrics, field), client, (uint64_t)qual); }
NSTAT_RANDOM_DELAY(client) {     nstat_random_delay(client); }
NSTAT_NOTE_QUAL(field, client, qual) {       NSTAT_TRACE(field, client, qual);     NSTAT_RANDOM_DELAY(client);     client->ntc_metrics.field++; }
NSTAT_NOTE_SRC(field, client, src) {       NSTAT_TRACE(field, client, (src != NULL)? src->nts_srcref: 0);     NSTAT_RANDOM_DELAY(client);     client->ntc_metrics.field++; }
NSTAT_GLOBAL_COUNT_INCREMENT_WITH_MAX(_currentfield, _maxfield) {   	uint64_t _prev_count = os_atomic_inc_orig(&nstat_global_counts._currentfield, relaxed); 	if (_prev_count >= os_atomic_load(&nstat_global_counts._maxfield, relaxed)) {  	        os_atomic_store(&nstat_global_counts._maxfield, _prev_count + 1, relaxed); 	}   }
NSTAT_GLOBAL_COUNT_INCREMENT(_field) {   	os_atomic_inc_orig(&nstat_global_counts._field, relaxed); }
NSTAT_GLOBAL_COUNT_DECREMENT(_field) {   	os_atomic_dec_orig(&nstat_global_counts._field, relaxed); }
NSTAT_LOCK_EXCLUSIVE() lck_rw_lock_exclusive(&nstat_rwlock)
NSTAT_LOCK_SHARED() lck_rw_lock_shared(&nstat_rwlock)
NSTAT_LOCK_SHARED_TO_EXCLUSIVE() lck_rw_lock_shared_to_exclusive(&nstat_rwlock)
NSTAT_LOCK_EXCLUSIVE_TO_SHARED() lck_rw_lock_exclusive_to_shared(&nstat_rwlock)
NSTAT_UNLOCK() lck_rw_done(&nstat_rwlock)
NSTAT_UNLOCK_EXCLUSIVE() lck_rw_unlock_exclusive(&nstat_rwlock)
NSTAT_UNLOCK_SHARED() lck_rw_unlock_shared(&nstat_rwlock)
NSTAT_LOCK_WOULD_YIELD() lck_rw_lock_would_yield_shared(&nstat_rwlock)
NSTAT_LOCK_YIELD() lck_rw_lock_yield_shared(&nstat_rwlock, FALSE)
NSTAT_ASSERT_LOCKED_EXCLUSIVE() LCK_RW_ASSERT(&nstat_rwlock, LCK_RW_ASSERT_EXCLUSIVE)
NSTAT_ASSERT_LOCKED_SHARED() LCK_RW_ASSERT(&nstat_rwlock, LCK_RW_ASSERT_SHARED)
NSTAT_ASSERT_LOCKED() LCK_RW_ASSERT(&nstat_rwlock, LCK_RW_ASSERT_HELD)
NSTAT_ASSERT_UNLOCKED() LCK_RW_ASSERT(&nstat_rwlock, LCK_RW_ASSERT_NOTHELD)
NSTAT_PROCDETAILS_MAGIC 0xfeedc001
NSTAT_PROCDETAILS_UNMAGIC 0xdeadc001
NSTAT_EWMA_ATOMIC(_val_addr, _new_val, _decay) do {                                     	volatile uint32_t _old_val;                                                                                             	volatile uint32_t _avg;                                                                                                 	do {                                                                                                                                    	        _old_val = *_val_addr;                                                                                          	        if (_old_val == 0)                                                                                                      	        {                                                                                                                                       	                _avg = _new_val;                                                                                                	        }                                                                                                                                       	        else                                                                                                                            	        {                                                                                                                                       	                _avg = _old_val - (_old_val >> _decay) + (_new_val >> _decay);  	        }                                                                                                                                       	        if (_old_val == _avg) break;                                                                            	} while (!OSCompareAndSwap(_old_val, _avg, _val_addr));                                 } while (0);
NSTAT_MIN_ATOMIC(_val_addr, _new_val) do {                              	volatile uint32_t _old_val;                                                                     	do {                                                                                                            	        _old_val = *_val_addr;                                                                  	        if (_old_val != 0 && _old_val < _new_val)                               	        {                                                                                                               	                break;                                                                                          	        }                                                                                                               	} while (!OSCompareAndSwap(_old_val, _new_val, _val_addr));     } while (0);
NSTAT_LIM_DL_MAX_BANDWIDTH_THRESHOLD 1000000
NSTAT_LIM_UL_MAX_BANDWIDTH_THRESHOLD 500000
NSTAT_LIM_UL_MIN_RTT_THRESHOLD 1000
__NTSTAT_H__ None
__NSTAT_REVISION__ 9
NSTAT_SYSINFO_KEYVAL_STRING_MAXSIZE 24
NSTAT_SYSINFO_FLAG_SCALAR 0x0001
NSTAT_SYSINFO_FLAG_DISTRIBUTION 0x0002
NSTAT_SYSINFO_FLAG_STRING 0x0004
NSTAT_MAX_MSG_SIZE 4096
NSTAT_SYSINFO_ENUM_VERSION 20180416
NSTAT_SYSINFO_API_FIRST NSTAT_SYSINFO_API_IF_FLTR_ATTACH
NSTAT_SYSINFO_API_LAST NSTAT_SYSINFO_API_REPORT_INTERVAL
NSTAT_IFNET_IS_UNKNOWN_TYPE 0x00000001
NSTAT_IFNET_IS_LOOPBACK 0x00000002
NSTAT_IFNET_IS_CELLULAR 0x00000004
NSTAT_IFNET_IS_WIFI 0x00000008
NSTAT_IFNET_IS_WIRED 0x00000010
NSTAT_IFNET_IS_AWDL 0x00000020
NSTAT_IFNET_IS_EXPENSIVE 0x00000040
NSTAT_IFNET_IS_VPN 0x00000080
NSTAT_IFNET_VIA_CELLFALLBACK 0x00000100
NSTAT_IFNET_IS_COMPANIONLINK 0x00000200
NSTAT_IFNET_IS_CONSTRAINED 0x00000400
NSTAT_IFNET_IS_LOCAL 0x00000800
NSTAT_IFNET_IS_NON_LOCAL 0x00001000
NSTAT_IFNET_ROUTE_VALUE_UNOBTAINABLE 0x00002000
NSTAT_IFNET_FLOWSWITCH_VALUE_UNOBTAINABLE 0x00004000
NSTAT_IFNET_IS_LLW 0x00008000
NSTAT_IFNET_IS_WIFI_INFRA 0x00010000
NSTAT_IFNET_PEEREGRESSINTERFACE_IS_CELLULAR 0x00020000
NSTAT_IFNET_IS_COMPANIONLINK_BT 0x00040000
NSTAT_NECP_CONN_HAS_NET_ACCESS 0x01000000
NSTAT_SOURCE_IS_LISTENER 0x02000000
NSTAT_SOURCE_IS_INBOUND 0x04000000
NSTAT_SOURCE_IS_OUTBOUND 0x08000000
NSTAT_PROVIDER_LAST NSTAT_PROVIDER_UDP_SUBFLOW
NSTAT_MAX_DOMAIN_NAME_LENGTH 256
NSTAT_MAX_DOMAIN_OWNER_LENGTH 256
NSTAT_MAX_DOMAIN_TRACKER_CONTEXT 256
NSTAT_MAX_DOMAIN_ATTR_BUNDLE_ID 256
NSTAT_IFNET_DESC_CELL_LINK_QUALITY_METRIC_VALID 0x1
NSTAT_IFNET_DESC_CELL_UL_EFFECTIVE_BANDWIDTH_VALID 0x2
NSTAT_IFNET_DESC_CELL_UL_MAX_BANDWIDTH_VALID 0x4
NSTAT_IFNET_DESC_CELL_UL_MIN_LATENCY_VALID 0x8
NSTAT_IFNET_DESC_CELL_UL_EFFECTIVE_LATENCY_VALID 0x10
NSTAT_IFNET_DESC_CELL_UL_MAX_LATENCY_VALID 0x20
NSTAT_IFNET_DESC_CELL_UL_RETXT_LEVEL_VALID 0x40
NSTAT_IFNET_DESC_CELL_UL_BYTES_LOST_VALID 0x80
NSTAT_IFNET_DESC_CELL_UL_MIN_QUEUE_SIZE_VALID 0x100
NSTAT_IFNET_DESC_CELL_UL_AVG_QUEUE_SIZE_VALID 0x200
NSTAT_IFNET_DESC_CELL_UL_MAX_QUEUE_SIZE_VALID 0x400
NSTAT_IFNET_DESC_CELL_DL_EFFECTIVE_BANDWIDTH_VALID 0x800
NSTAT_IFNET_DESC_CELL_DL_MAX_BANDWIDTH_VALID 0x1000
NSTAT_IFNET_DESC_CELL_CONFIG_INACTIVITY_TIME_VALID 0x2000
NSTAT_IFNET_DESC_CELL_CONFIG_BACKOFF_TIME_VALID 0x4000
NSTAT_IFNET_DESC_CELL_MSS_RECOMMENDED_VALID 0x8000
NSTAT_IFNET_DESC_CELL_UL_RETXT_LEVEL_NONE 1
NSTAT_IFNET_DESC_CELL_UL_RETXT_LEVEL_LOW 2
NSTAT_IFNET_DESC_CELL_UL_RETXT_LEVEL_MEDIUM 3
NSTAT_IFNET_DESC_CELL_UL_RETXT_LEVEL_HIGH 4
NSTAT_IFNET_DESC_MSS_RECOMMENDED_NONE 0x0
NSTAT_IFNET_DESC_MSS_RECOMMENDED_MEDIUM 0x1
NSTAT_IFNET_DESC_MSS_RECOMMENDED_LOW 0x2
NSTAT_IFNET_DESC_WIFI_LINK_QUALITY_METRIC_VALID 0x1
NSTAT_IFNET_DESC_WIFI_UL_EFFECTIVE_BANDWIDTH_VALID 0x2
NSTAT_IFNET_DESC_WIFI_UL_MAX_BANDWIDTH_VALID 0x4
NSTAT_IFNET_DESC_WIFI_UL_MIN_LATENCY_VALID 0x8
NSTAT_IFNET_DESC_WIFI_UL_EFFECTIVE_LATENCY_VALID 0x10
NSTAT_IFNET_DESC_WIFI_UL_MAX_LATENCY_VALID 0x20
NSTAT_IFNET_DESC_WIFI_UL_RETXT_LEVEL_VALID 0x40
NSTAT_IFNET_DESC_WIFI_UL_ERROR_RATE_VALID 0x80
NSTAT_IFNET_DESC_WIFI_UL_BYTES_LOST_VALID 0x100
NSTAT_IFNET_DESC_WIFI_DL_EFFECTIVE_BANDWIDTH_VALID 0x200
NSTAT_IFNET_DESC_WIFI_DL_MAX_BANDWIDTH_VALID 0x400
NSTAT_IFNET_DESC_WIFI_DL_MIN_LATENCY_VALID 0x800
NSTAT_IFNET_DESC_WIFI_DL_EFFECTIVE_LATENCY_VALID 0x1000
NSTAT_IFNET_DESC_WIFI_DL_MAX_LATENCY_VALID 0x2000
NSTAT_IFNET_DESC_WIFI_DL_ERROR_RATE_VALID 0x4000
NSTAT_IFNET_DESC_WIFI_CONFIG_FREQUENCY_VALID 0x8000
NSTAT_IFNET_DESC_WIFI_CONFIG_MULTICAST_RATE_VALID 0x10000
NSTAT_IFNET_DESC_WIFI_CONFIG_SCAN_COUNT_VALID 0x20000
NSTAT_IFNET_DESC_WIFI_CONFIG_SCAN_DURATION_VALID 0x40000
NSTAT_IFNET_DESC_WIFI_UL_RETXT_LEVEL_NONE 1
NSTAT_IFNET_DESC_WIFI_UL_RETXT_LEVEL_LOW 2
NSTAT_IFNET_DESC_WIFI_UL_RETXT_LEVEL_MEDIUM 3
NSTAT_IFNET_DESC_WIFI_UL_RETXT_LEVEL_HIGH 4
NSTAT_IFNET_DESC_WIFI_CONFIG_FREQUENCY_2_4_GHZ 1
NSTAT_IFNET_DESC_WIFI_CONFIG_FREQUENCY_5_0_GHZ 2
IF_DESCSIZE 128
NSTAT_SYSINFO_TCP_STATS 0x0002
NSTAT_SYSINFO_LIM_STATS 0x0004
NSTAT_SYSINFO_NET_API_STATS 0x0005
NET_STAT_CONTROL_NAME "com.apple.network.statistics"
NSTAT_EXTENDED_UPDATE_TYPE_MIN NSTAT_EXTENDED_UPDATE_TYPE_DOMAIN
NSTAT_EXTENDED_UPDATE_TYPE_MAX NSTAT_EXTENDED_UPDATE_TYPE_BLUETOOTH_COUNTS
NSTAT_EXTENDED_UPDATE_FLAG_MASK 0x00ffffffull
NSTAT_FILTER_ALLOWED_EXTENSIONS_SHIFT 40
NSTAT_FILTER_ACCEPT_UNKNOWN 0x0000000000000001ull
NSTAT_FILTER_ACCEPT_LOOPBACK 0x0000000000000002ull
NSTAT_FILTER_ACCEPT_CELLULAR 0x0000000000000004ull
NSTAT_FILTER_ACCEPT_WIFI 0x0000000000000008ull
NSTAT_FILTER_ACCEPT_WIRED 0x0000000000000010ull
NSTAT_FILTER_ACCEPT_AWDL 0x0000000000000020ull
NSTAT_FILTER_ACCEPT_EXPENSIVE 0x0000000000000040ull
NSTAT_FILTER_ACCEPT_CELLFALLBACK 0x0000000000000100ull
NSTAT_FILTER_ACCEPT_COMPANIONLINK 0x0000000000000200ull
NSTAT_FILTER_ACCEPT_IS_CONSTRAINED 0x0000000000000400ull
NSTAT_FILTER_ACCEPT_IS_LOCAL 0x0000000000000800ull
NSTAT_FILTER_ACCEPT_IS_NON_LOCAL 0x0000000000001000ull
NSTAT_FILTER_ACCEPT_ROUTE_VAL_ERR 0x0000000000002000ull
NSTAT_FILTER_ACCEPT_FLOWSWITCH_ERR 0x0000000000004000ull
NSTAT_FILTER_ACCEPT_WIFI_LLW 0x0000000000008000ull
NSTAT_FILTER_ACCEPT_WIFI_INFRA 0x0000000000010000ull
NSTAT_FILTER_ACCEPT_PEERIFEGRESS_CELL 0x0000000000020000ull
NSTAT_FILTER_ACCEPT_COMPANIONLINK_BT 0x0000000000040000ull
NSTAT_FILTER_IFNET_FLAGS 0x000000000007FFFFull
NSTAT_FILTER_UDP_INTERFACE_ATTACH 0x0000000000020000ull
NSTAT_FILTER_UDP_FLAGS 0x0000000000020000ull
NSTAT_FILTER_TCP_INTERFACE_ATTACH 0x0000000000040000ull
NSTAT_FILTER_TCP_NO_EARLY_CLOSE 0x0000000000080000ull
NSTAT_FILTER_TCP_FLAGS 0x00000000000C0000ull
NSTAT_FILTER_SUPPRESS_SRC_ADDED 0x0000000000100000ull
NSTAT_FILTER_USE_UPDATE_FOR_ADD 0x0000000000200000ull
NSTAT_FILTER_PROVIDER_NOZEROBYTES 0x0000000000400000ull
NSTAT_FILTER_PROVIDER_NOZERODELTAS 0x0000000000800000ull
NSTAT_FILTER_CONN_HAS_NET_ACCESS 0x0000000001000000ull
NSTAT_FILTER_CONN_FLAGS 0x0000000001000000ull
NSTAT_FILTER_SOURCE_IS_LISTENER 0x0000000002000000ull
NSTAT_FILTER_SOURCE_IS_INBOUND 0x0000000004000000ull
NSTAT_FILTER_SOURCE_IS_OUTBOUND 0x0000000008000000ull
NSTAT_FILTER_SOURCE_ROLE_FLAGS 0x000000000E000000ull
NSTAT_FILTER_SUPPRESS_BORING_CLOSE 0x0000000010000000ull
NSTAT_FILTER_SUPPRESS_BORING_POLL 0x0000000020000000ull
NSTAT_FILTER_FLAGS_RESERVED_30 0x0000000040000000ull
NSTAT_FILTER_FLAGS_RESERVED_31 0x0000000080000000ull
NSTAT_FILTER_SPECIFIC_USER_BY_PID 0x0000000100000000ull
NSTAT_FILTER_SPECIFIC_USER_BY_EPID 0x0000000200000000ull
NSTAT_FILTER_SPECIFIC_USER_BY_UUID 0x0000000400000000ull
NSTAT_FILTER_SPECIFIC_USER_BY_EUUID 0x0000000800000000ull
NSTAT_FILTER_SPECIFIC_USER 0x0000000F00000000ull
NSTAT_FILTER_INITIAL_PROPERTIES 0x0000001000000000ull
NSTAT_FILTER_USE_LARGE_BUFFERS 0x0000002000000000ull
NSTAT_FILTER_DELIVER_ONCE 0x0000004000000000ull
NSTAT_FILTER_VERSION_2_PROTOCOL 0x0000008000000000ull
DEFINE_NTSTAT_DATA_ACCESSOR(NTSTAT_TYPE) static inline                                                               __attribute__((always_inline))                                              __attribute__((overloadable))                                               uint8_t * __header_indexable                                                nstat_get_data(NTSTAT_TYPE *__header_indexable desc)                        {                                                                               if (desc) {                                                             	_Pragma("clang diagnostic push");                                       	_Pragma("clang diagnostic ignored \"-Wunsafe-buffer-usage\"");          	return (uint8_t *)desc + sizeof(NTSTAT_TYPE);                           	_Pragma("clang diagnostic pop");                                            } else {                                                                	return NULL;                                                                }                                                                       }
MAX_NSTAT_MSG_HDR_LENGTH 65532
NSTAT_ADD_SRC_FIELDS nstat_msg_hdr		hdr;            	nstat_provider_id_t	provider;       	u_int8_t			reserved[4]
NSTAT_SRC_DESCRIPTION_FIELDS nstat_msg_hdr		hdr;                                                        	nstat_src_ref_t		srcref __attribute__((aligned(sizeof(u_int64_t))));         	nstat_event_flags_t	event_flags __attribute__((aligned(sizeof(u_int64_t))));    	nstat_provider_id_t	provider;                                                   	u_int8_t			reserved[4]
NSTAT_SRC_UPDATE_FIELDS nstat_msg_hdr		hdr;                                                        	nstat_src_ref_t		srcref __attribute__((aligned(sizeof(u_int64_t))));         	nstat_event_flags_t	event_flags __attribute__((aligned(sizeof(u_int64_t))));    	nstat_counts		counts;                                                     	nstat_provider_id_t	provider;                                                   	u_int8_t			reserved[4]
PR_PROTO_TCP 0x1
PR_PROTO_QUIC 0x2
NSTAT_SYSINFO_TCP_STATS_COUNT 71
NSTAT_LIM_STAT_KEYVAL_COUNT 12
locked_add_64(__addr, __count) do { 	*(__addr) += (__count); } while (0)
NWK_WQ_H None
MAX_PACKET_MANGLER 1
PKT_MNGLR_FLG_IPFILTER_ATTACHED 0x00000001
PKT_MNGLR_RW_LCK_MAX 8
TCP_OPT_MULTIPATH_TCP 30
MPTCP_SBT_VER_OFFSET 2
TCP_MAX_OPTLEN 40
__PACKET_MANGLER_H__ None
PACKET_MANGLER_CONTROL_NAME "com.apple.packet-mangler"
PKT_MNGLR_OPT_PROTO_ACT_MASK 1
PKT_MNGLR_OPT_IP_ACT_MASK 2
PKT_MNGLR_OPT_LOCAL_IP 3
PKT_MNGLR_OPT_REMOTE_IP 4
PKT_MNGLR_OPT_LOCAL_PORT 5
PKT_MNGLR_OPT_REMOTE_PORT 6
PKT_MNGLR_OPT_DIRECTION 7
PKT_MNGLR_OPT_PROTOCOL 8
PKT_MNGLR_OPT_ACTIVATE 0xFFFFFFFF
PKT_MNGLR_TCP_ACT_NOP_MPTCP 0x00000001
PKT_MNGLR_TCP_ACT_SWAP_L_PORT 0x00000002
PKT_MNGLR_TCP_ACT_SWAP_R_PORT 0x00000004
PKT_MNGLR_TCP_ACT_DSS_DROP 0x00000008
PKT_MNGLR_TCP_ACT_CHK_EXTENDED 0x80000000
PKT_MNGLR_IP_ACT_FLT_L_IP 0x00000001
PKT_MNGLR_IP_ACT_FLT_R_IP 0x00000002
PKT_MNGLR_IP_ACT_SWAP_L_IP 0x00000004
PKT_MNGLR_IP_ACT_SWAP_R_IP 0x00000008
PKT_MNGLR_IP_ACT_DROP_PACKET 0x00000010
PKT_MNGLR_IP_ACT_CHK_EXTENDED 0x80000000
PKT_MNGLR_MAX_FILTER_COUNT 1
PKT_MNGLR_VERSION_CURRENT 1
PKT_MNGLR_LOG(level, fmt, ...) do { 	if (pkt_mnglr_log_level >= level) 	        printf("%s:%d " fmt "\n",	                __FUNCTION__, __LINE__, ##__VA_ARGS__); } while (0)
DPFPRINTF(n, x) (pf_status.debug >= (n) ? printf x : ((void)0))
HOOK_REMOVE 0x01
HOOK_FREE 0x02
HOOK_ABORT 0x04
STATE_LOOKUP() do {                                                             	        int action;                                              	        *state = pf_find_state(kif, &key, direction);            	        if (*state != NULL && pd != NULL &&                      	            !(pd->pktflags & PKTF_FLOW_ID)) {                    	                pd->flowsrc = (*state)->state_key->flowsrc;      	                pd->flowhash = (*state)->state_key->flowhash;    	                if (pd->flowhash != 0) {                         	                        pd->pktflags |= PKTF_FLOW_ID;            	                        pd->pktflags &= ~PKTF_FLOW_ADV;          	                }                                                	        }                                                        	        if (pf_state_lookup_aux(state, kif, direction, &action)) 	                return (action);                                 	} while (0)
PD_CLEAR_STATE_FLOWID(_pd) do {                                                             	        if (__improbable(((_pd)->pktflags & PKTF_FLOW_ID) &&     	            ((_pd)->flowsrc == FLOWSRC_PF))) {                   	                (_pd)->flowhash = 0;                             	                (_pd)->flowsrc = 0;                              	                (_pd)->pktflags &= ~PKTF_FLOW_ID;                	        }                                                                                                                                 	} while (0)
BOUND_IFACE(r, k) 	((r)->rule_flag & PFRULE_IFBOUND) ? (k) : pfi_all
STATE_INC_COUNTERS(s) do {                                                    	        s->rule.ptr->states++;                          	        VERIFY(s->rule.ptr->states != 0);               	        if (s->anchor.ptr != NULL) {                    	                s->anchor.ptr->states++;                	                VERIFY(s->anchor.ptr->states != 0);     	        }                                               	        if (s->nat_rule.ptr != NULL) {                  	                s->nat_rule.ptr->states++;              	                VERIFY(s->nat_rule.ptr->states != 0);   	        }                                               	} while (0)
STATE_DEC_COUNTERS(s) do {                                                    	        if (s->nat_rule.ptr != NULL) {                  	                VERIFY(s->nat_rule.ptr->states > 0);    	                s->nat_rule.ptr->states--;              	        }                                               	        if (s->anchor.ptr != NULL) {                    	                VERIFY(s->anchor.ptr->states > 0);      	                s->anchor.ptr->states--;                	        }                                               	        VERIFY(s->rule.ptr->states > 0);                	        s->rule.ptr->states--;                          	} while (0)
PF_DT_SKIP_LANEXT 0x01
PF_DT_SKIP_EXTGWY 0x02
PF_PPTP_CTRL_TYPE_START_REQ 1
PF_PPTP_CTRL_TYPE_START_RPY 2
PF_PPTP_CTRL_TYPE_STOP_REQ 3
PF_PPTP_CTRL_TYPE_STOP_RPY 4
PF_PPTP_CTRL_TYPE_ECHO_REQ 5
PF_PPTP_CTRL_TYPE_ECHO_RPY 6
PF_PPTP_CTRL_TYPE_CALL_OUT_REQ 7
PF_PPTP_CTRL_TYPE_CALL_OUT_RPY 8
PF_PPTP_CTRL_TYPE_CALL_IN_1ST 9
PF_PPTP_CTRL_TYPE_CALL_IN_2ND 10
PF_PPTP_CTRL_TYPE_CALL_IN_3RD 11
PF_PPTP_CTRL_TYPE_CALL_CLR 12
PF_PPTP_CTRL_TYPE_CALL_DISC 13
PF_PPTP_CTRL_TYPE_ERROR 14
PF_PPTP_CTRL_TYPE_SET_LINKINFO 15
PF_GRE_FLAG_CHECKSUM_PRESENT 0x8000
PF_GRE_FLAG_VERSION_MASK 0x0007
PF_GRE_PPP_ETHERTYPE 0x880B
PF_IKEv1_EXCHTYPE_BASE 1
PF_IKEv1_EXCHTYPE_ID_PROTECT 2
PF_IKEv1_EXCHTYPE_AUTH_ONLY 3
PF_IKEv1_EXCHTYPE_AGGRESSIVE 4
PF_IKEv1_EXCHTYPE_INFORMATIONAL 5
PF_IKEv2_EXCHTYPE_SA_INIT 34
PF_IKEv2_EXCHTYPE_AUTH 35
PF_IKEv2_EXCHTYPE_CREATE_CHILD_SA 36
PF_IKEv2_EXCHTYPE_INFORMATIONAL 37
PF_IKEv1_FLAG_E 0x01
PF_IKEv1_FLAG_C 0x02
PF_IKEv1_FLAG_A 0x04
PF_IKEv2_FLAG_I 0x08
PF_IKEv2_FLAG_V 0x10
PF_IKEv2_FLAG_R 0x20
PF_SET_SKIP_STEPS(i) do {                                                    	        while (head[i] != cur) {                        	                head[i]->skip[i].ptr = cur;             	                head[i] = TAILQ_NEXT(head[i], entries); 	        }                                               	} while (0)
mix(a, b, c) 	do {                                    	        a -= b; a -= c; a ^= (c >> 13); 	        b -= c; b -= a; b ^= (a << 8);  	        c -= a; c -= b; c ^= (b >> 13); 	        a -= b; a -= c; a ^= (c >> 12); 	        b -= c; b -= a; b ^= (a << 16); 	        c -= a; c -= b; c ^= (b >> 5);  	        a -= b; a -= c; a ^= (c >> 3);  	        b -= c; b -= a; b ^= (a << 10); 	        c -= a; c -= b; c ^= (b >> 15); 	} while (0)
TYPE_LEN_CHECK(_type, _name)                            	case PF_PPTP_CTRL_TYPE_##_type:                         	        if (tlen < sizeof(struct pf_pptp_ctrl_##_name)) 	                return;                                 	        break;
PF_APPLE_UPDATE_PDESC_IPv6() do {                                                    	        if (pbuf && pd.mp && pbuf != pd.mp) {           	                pbuf = pd.mp;                           	        }                                               	        h = pbuf->pb_data;                              	} while (0)
_NET_PFKEYV2_H_ None
__PFKEY_V2_H 1
PF_KEY_V2 2
PFKEYV2_REVISION 199806L
SADB_RESERVED 0
SADB_GETSPI 1
SADB_UPDATE 2
SADB_ADD 3
SADB_DELETE 4
SADB_GET 5
SADB_ACQUIRE 6
SADB_REGISTER 7
SADB_EXPIRE 8
SADB_FLUSH 9
SADB_DUMP 10
SADB_X_PROMISC 11
SADB_X_PCHANGE 12
SADB_X_SPDUPDATE 13
SADB_X_SPDADD 14
SADB_X_SPDDELETE 15
SADB_X_SPDGET 16
SADB_X_SPDACQUIRE 17
SADB_X_SPDDUMP 18
SADB_X_SPDFLUSH 19
SADB_X_SPDSETIDX 20
SADB_X_SPDEXPIRE 21
SADB_X_SPDDELETE2 22
SADB_GETSASTAT 23
SADB_X_SPDENABLE 24
SADB_X_SPDDISABLE 25
SADB_MIGRATE 26
SADB_MAX 26
SADB_SA_NATT_SRC_PORT 1
SADB_EXT_RESERVED 0
SADB_EXT_SA 1
SADB_EXT_LIFETIME_CURRENT 2
SADB_EXT_LIFETIME_HARD 3
SADB_EXT_LIFETIME_SOFT 4
SADB_EXT_ADDRESS_SRC 5
SADB_EXT_ADDRESS_DST 6
SADB_EXT_ADDRESS_PROXY 7
SADB_EXT_KEY_AUTH 8
SADB_EXT_KEY_ENCRYPT 9
SADB_EXT_IDENTITY_SRC 10
SADB_EXT_IDENTITY_DST 11
SADB_EXT_SENSITIVITY 12
SADB_EXT_PROPOSAL 13
SADB_EXT_SUPPORTED_AUTH 14
SADB_EXT_SUPPORTED_ENCRYPT 15
SADB_EXT_SPIRANGE 16
SADB_X_EXT_KMPRIVATE 17
SADB_X_EXT_POLICY 18
SADB_X_EXT_SA2 19
SADB_EXT_SESSION_ID 20
SADB_EXT_SASTAT 21
SADB_X_EXT_IPSECIF 22
SADB_X_EXT_ADDR_RANGE_SRC_START 23
SADB_X_EXT_ADDR_RANGE_SRC_END 24
SADB_X_EXT_ADDR_RANGE_DST_START 25
SADB_X_EXT_ADDR_RANGE_DST_END 26
SADB_EXT_MIGRATE_ADDRESS_SRC 27
SADB_EXT_MIGRATE_ADDRESS_DST 28
SADB_X_EXT_MIGRATE_IPSECIF 29
SADB_EXT_MAX 29
SADB_SATYPE_UNSPEC 0
SADB_SATYPE_AH 2
SADB_SATYPE_ESP 3
SADB_SATYPE_RSVP 5
SADB_SATYPE_OSPFV2 6
SADB_SATYPE_RIPV2 7
SADB_SATYPE_MIP 8
SADB_X_SATYPE_IPCOMP 9
SADB_X_SATYPE_POLICY 10
SADB_SATYPE_MAX 11
SADB_SASTATE_LARVAL 0
SADB_SASTATE_MATURE 1
SADB_SASTATE_DYING 2
SADB_SASTATE_DEAD 3
SADB_SASTATE_MAX 3
SADB_SAFLAGS_PFS 1
SADB_AALG_NONE 0
SADB_AALG_MD5HMAC 1
SADB_AALG_SHA1HMAC 2
SADB_AALG_MAX 8
SADB_X_AALG_SHA2_256 6
SADB_X_AALG_SHA2_384 7
SADB_X_AALG_SHA2_512 8
SADB_X_AALG_MD5 3
SADB_X_AALG_SHA 4
SADB_X_AALG_NULL 5
SADB_EALG_NONE 0
SADB_EALG_DESCBC 1
SADB_EALG_3DESCBC 2
SADB_EALG_NULL 3
SADB_EALG_MAX 12
SADB_X_EALG_CAST128CBC 5
SADB_X_EALG_BLOWFISHCBC 4
SADB_X_EALG_RIJNDAELCBC 12
SADB_X_EALG_AESCBC 12
SADB_X_EALG_AES 12
SADB_X_EALG_AES_GCM 13
SADB_X_EALG_CHACHA20POLY1305 14
SADB_X_EALG_AES_GMAC 15
SADB_X_CALG_NONE 0
SADB_X_CALG_OUI 1
SADB_X_CALG_DEFLATE 2
SADB_X_CALG_LZS 3
SADB_X_CALG_MAX 4
SADB_IDENTTYPE_RESERVED 0
SADB_IDENTTYPE_PREFIX 1
SADB_IDENTTYPE_FQDN 2
SADB_IDENTTYPE_USERFQDN 3
SADB_X_IDENTTYPE_ADDR 4
SADB_IDENTTYPE_MAX 4
SADB_X_EXT_NONE 0x0000
SADB_X_EXT_OLD 0x0001
SADB_X_EXT_NATT 0x0002
SADB_X_EXT_NATT_KEEPALIVE 0x0004
SADB_X_EXT_NATT_MULTIPLEUSERS 0x0008
SADB_X_EXT_IV4B 0x0010
SADB_X_EXT_DERIV 0x0020
SADB_X_EXT_CYCSEQ 0x0040
SADB_X_EXT_PSEQ 0x0000
SADB_X_EXT_PRAND 0x0100
SADB_X_EXT_PZERO 0x0200
SADB_X_EXT_PMASK 0x0300
SADB_X_EXT_IIV 0x0400
SADB_X_EXT_NATT_DETECTED_PEER 0x1000
SADB_X_EXT_ESP_KEEPALIVE 0x2000
SADB_X_EXT_PUNT_RX_KEEPALIVE 0x4000
SADB_X_EXT_NATT_KEEPALIVE_OFFLOAD 0x8000
NATT_KEEPALIVE_OFFLOAD_INTERVAL 0x1
SADB_X_EXT_RAWCPI 0x0080
SADB_KEY_FLAGS_MAX 0x7fff
SADB_X_EXT_SA2_DELETE_ON_DETACH 0x0001
SADB_X_EXT_SA2_SEQ_PER_TRAFFIC_CLASS 0x0002
PFKEY_SPI_SIZE sizeof(u_int32_t)
SADB_X_LIFETIME_ALLOCATIONS 0
SADB_X_LIFETIME_BYTES 1
SADB_X_LIFETIME_ADDTIME 2
SADB_X_LIFETIME_USETIME 3
PFKEY_SOFT_LIFETIME_RATE 80
PFKEY_EXTLEN(msg) PFKEY_UNUNIT64(((struct sadb_ext *)(msg))->sadb_ext_len)
_NET_PFVAR_H_ None
PFI_BUFFER_MAX 0x10000
IFG_ALL "ALL"
NUM_RESERVED_TAGS 2
RESERVED_TAG_ID_MIN PF_TAG_ID_SYSTEM_SERVICE
DYNAMIC_TAG_ID_MAX 50000
DPFPRINTF(n, x) if (pf_status.debug >= (n)) printf x
PFIOCX_STRUCT_DECL(s) struct {                                                                	union {                                                         	        struct s##_32	_s##_32;                                	        struct s##_64	_s##_64;                                	} _u;                                                           } *__single s##_un = NULL
PFIOCX_STRUCT_BEGIN(a, s) {                                     	VERIFY(s##_un == NULL);                                         	s##_un = kalloc_type(typeof(*s##_un), Z_WAITOK_ZERO_NOFAIL);    	if (p64)                                                        	        bcopy((struct s##_64 *)(void *) (a), &s##_un->_u._s##_64,                           	            sizeof (struct s##_64));                            	else                                                            	        bcopy((struct s##_32 *)(void *) (a), &s##_un->_u._s##_32,                           	            sizeof (struct s##_32));                            }
PFIOCX_STRUCT_END(s, a) {                                       	VERIFY(s##_un != NULL);                                         	if (p64)                                                        	        bcopy(&s##_un->_u._s##_64, (struct s##_64 *)(void *) (a), sizeof (struct s##_64));  	else                                                            	        bcopy(&s##_un->_u._s##_32, (struct s##_32 *)(void *) (a), sizeof (struct s##_32));  	kfree_type(typeof(*s##_un), s##_un);                            }
PFIOC_STRUCT_BEGIN(a, v) {                                      	VERIFY((v) == NULL);                                            	(v) = kalloc_type(typeof(*(v)), Z_WAITOK_ZERO_NOFAIL);          	bcopy((typeof(v))(void *) a, v, sizeof (*(v)));                                     }
PFIOC_STRUCT_END(v, a) {                                        	VERIFY((v) != NULL);                                            	bcopy(v, (typeof(v))(void *) a, sizeof (*(v)));                                     	kfree_type(typeof(*(v)), v);                                    }
PF_MD5_UPD(st, elm)                                             	MD5Update(ctx, (u_int8_t *)&(st)->elm, sizeof((st)->elm))
PF_MD5_UPD_STRBUF(st, elm)     MD5Update(ctx, (u_int8_t *)(st)->elm, (unsigned int) strbuflen((st)->elm, sizeof(st)->elm))
PF_MD5_UPD_HTONL(st, elm, stor) do {                            	(stor) = htonl((st)->elm);                                      	MD5Update(ctx, (u_int8_t *)&(stor), sizeof (u_int32_t));        } while (0)
PF_MD5_UPD_HTONS(st, elm, stor) do {                            	(stor) = htons((st)->elm);                                      	MD5Update(ctx, (u_int8_t *)&(stor), sizeof (u_int16_t));        } while (0)
parent_ruleset ruleset->anchor->parent->ruleset
fr_ip fr_u.fru_ipv4
fr_ip6 fr_u.fru_ipv6
PFFRAG_SEENLAST 0x0001
PFFRAG_NOBUFFER 0x0002
PFFRAG_DROP 0x0004
fr_id fr_uid.fru_id4
fr_id6 fr_uid.fru_id6
fr_queue fr_u.fru_queue
fr_cache fr_u.fru_cache
DPFPRINTF(x) do {                               	if (pf_status.debug >= PF_DEBUG_MISC) {         	        printf("%s: ", __func__);               	        printf x ;                              	}                                               } while (0)
TS_MAXFREQ 1100
TS_MICROSECS 1000000
DPFPRINTF(format, x...)                 	if (pf_status.debug >= PF_DEBUG_NOISY)  	        printf(format, ##x)
MATCH_INT(_MOD, _DC, _field)                                    	if ((f->fp_flags & _DC) == 0) {                                 	        if ((f->fp_flags & _MOD) == 0) {                        	                if (f->_field != find->_field)                  	                        continue;                               	        } else {                                                	                if (f->_field == 0 || find->_field % f->_field) 	                        continue;                               	        }                                                       	}
SMART_MSS 1460
__PBUF_H__ None
PBUF_ACTION_RV_SUCCESS 0
pb_mbuf pb_u.pbu_mbuf
pb_memory pb_u.pbu_memory
DPFPRINTF(format, x ...)         	if (pf_status.debug >= PF_DEBUG_NOISY)  	        printf(format, ##x)
rs_malloc_data(size) kalloc_data(size, Z_WAITOK)
rs_malloc_type(type) kalloc_type(type, Z_WAITOK | Z_ZERO)
rs_free_data kfree_data
rs_free_type kfree_type
PF_ANCHOR_DELIMITER '/'
ACCEPT_FLAGS(flags, oklist)             	do {                                    	        if ((flags & ~(oklist)) &       	            PFR_FLAG_ALLMASK)           	                return (EINVAL);        	} while (0)
COPYIN(from, to, size, flags)                           	((flags & PFR_FLAG_USERIOCTL) ?                         	copyin((from), (to), (size)) :                          	(bcopy(__unsafe_forge_bidi_indexable(void *, (from), (size)), (to), (size)), 0))
COPYOUT(from, to, size, flags)                          	((flags & PFR_FLAG_USERIOCTL) ?                         	copyout((from), (to), (size)) :                         	(bcopy((from), __unsafe_forge_bidi_indexable(void *, (to), (size)), (size)), 0))
FILLIN_SIN(sin, addr)                   	do {                                    	        (sin).sin_len = sizeof (sin);   	        (sin).sin_family = AF_INET;     	        (sin).sin_addr = (addr);        	} while (0)
FILLIN_SIN6(sin6, addr)                         	do {                                            	        (sin6).sin6_len = sizeof (sin6);        	        (sin6).sin6_family = AF_INET6;          	        (sin6).sin6_addr = (addr);              	} while (0)
SWAP(type, a1, a2)                      	do {                                    	        type tmp = a1;                  	        a1 = a2;                        	        a2 = tmp;                       	} while (0)
SUNION2PF(su, af) (((af) == AF_INET) ?  	(struct pf_addr *)&(su)->sin.sin_addr : 	(struct pf_addr *)&(su)->sin6.sin6_addr)
pfrw_addr pfrw_1.pfrw1_addr
pfrw_astats pfrw_1.pfrw1_astats
pfrw_workq pfrw_1.pfrw1_workq
pfrw_kentry pfrw_1.pfrw1_kentry
pfrw_dyn pfrw_1.pfrw1_dyn
pfrw_cnt pfrw_free
senderr(e) do { rv = (e); goto _bad; } while (0)
_IP_VHL None
PKTAP_DEBUG 0
PKTAP_FILTER_OK 0
PKTAP_FILTER_SKIP 1
PKTAP_LOG(mask, fmt, ...) do { 	if (__improbable(pktap_log & mask)) 	        os_log(OS_LOG_DEFAULT, "%s:%d " fmt, __FUNCTION__, __LINE__, ##__VA_ARGS__); } while (false)
PKTP_LOG_FUNC 0x01
PKTP_LOG_FILTER 0x02
PKTP_LOG_INPUT 0x04
PKTP_LOG_OUTPUT 0x08
PKTP_LOG_ERROR 0x10
PKTP_LOG_NOPCB 0x20
PKTAP_MAXUNIT IF_MAXUNIT
PKTAP_ZONE_MAX_ELEM MIN(IFNETS_MAX, PKTAP_MAXUNIT)
_CASSERT_OFFFSETOF_FIELD(s1, s2, f) 	_CASSERT(offsetof(struct s1, f) == offsetof(struct s2, f))
_NET_PKTAP_H_ None
PKTAP_IFNAME "pktap"
PKTP_CMD_FILTER_GET 1
PKTP_CMD_FILTER_SET 3
PKTP_CMD_TAP_COUNT 4
PKTAP_FILTER_OP_NONE 0
PKTAP_FILTER_OP_PASS 1
PKTAP_FILTER_OP_SKIP 2
PKTAP_FILTER_PARAM_NONE 0
PKTAP_FILTER_PARAM_IF_TYPE 1
PKTAP_FILTER_PARAM_IF_NAME 2
filter_param_if_type param_._filter_if_type
filter_param_if_name param_._filter_if_name
PKTAP_MAX_FILTERS 8
PKTAP_HAS_TRACE_TAG 1
PKTAP_HAS_COMP_GENCNT 1
PTH_TYPE_NONE 0
PTH_TYPE_PACKET 1
PTH_TYPE_DROP 2
COPY_PKTAP_COMMON_FIELDS_TO_V2(pktap_v2_hdr_dst, pktap_header_src) { 	(pktap_v2_hdr_dst)->pth_length = sizeof(struct pktap_v2_hdr); 	(pktap_v2_hdr_dst)->pth_uuid_offset = 0; 	(pktap_v2_hdr_dst)->pth_e_uuid_offset = 0; 	(pktap_v2_hdr_dst)->pth_ifname_offset = 0; 	(pktap_v2_hdr_dst)->pth_comm_offset = 0; 	(pktap_v2_hdr_dst)->pth_e_comm_offset = 0; 	(pktap_v2_hdr_dst)->pth_dlt = (uint16_t)(pktap_header_src)->pth_dlt; 	(pktap_v2_hdr_dst)->pth_frame_pre_length = (uint16_t)(pktap_header_src)->pth_frame_pre_length; 	(pktap_v2_hdr_dst)->pth_frame_post_length = (uint16_t)(pktap_header_src)->pth_frame_post_length; 	(pktap_v2_hdr_dst)->pth_iftype = (pktap_header_src)->pth_iftype; 	(pktap_v2_hdr_dst)->pth_ipproto = (uint16_t)(pktap_header_src)->pth_ipproto; 	(pktap_v2_hdr_dst)->pth_protocol_family = (pktap_header_src)->pth_protocol_family; 	(pktap_v2_hdr_dst)->pth_svc = (pktap_header_src)->pth_svc; 	(pktap_v2_hdr_dst)->pth_flowid = (pktap_header_src)->pth_flowid; 	(pktap_v2_hdr_dst)->pth_pid = (pktap_header_src)->pth_pid; 	(pktap_v2_hdr_dst)->pth_e_pid = (pktap_header_src)->pth_epid; 	(pktap_v2_hdr_dst)->pth_flags = (pktap_header_src)->pth_flags; 	(pktap_v2_hdr_dst)->pth_flags |= PTH_FLAG_V2_HDR; }
PTH_FLAG_DIR_IN 0x00000001
PTH_FLAG_DIR_OUT 0x00000002
PTH_FLAG_PROC_DELEGATED 0x00000004
PTH_FLAG_IF_DELEGATED 0x00000008
PTH_FLAG_DELAY_PKTAP 0x00001000
PTH_FLAG_TSTAMP 0x00002000
PTH_FLAG_NEW_FLOW 0x00004000
PTH_FLAG_REXMIT 0x00008000
PTH_FLAG_KEEP_ALIVE 0x00010000
PTH_FLAG_SOCKET 0x00020000
PTH_FLAG_NEXUS_CHAN 0x00040000
PTH_FLAG_V2_HDR 0x00080000
PTH_FLAG_WAKE_PKT 0x00100000
_NET_PPP_COMP_H None
DO_BSD_COMPRESS 1
DO_DEFLATE 1
DO_PREDICTOR_1 0
DO_PREDICTOR_2 0
DECOMP_OK 0
DECOMP_ERROR 1
DECOMP_FATALERROR 2
CCP_CONFREQ 1
CCP_CONFACK 2
CCP_TERMREQ 5
CCP_TERMACK 6
CCP_RESETREQ 14
CCP_RESETACK 15
CCP_MAX_OPTION_LENGTH 32
CCP_HDRLEN 4
CCP_OPT_MINLEN 2
CI_BSD_COMPRESS 21
CILEN_BSD_COMPRESS 3
BSD_CURRENT_VERSION 1
BSD_MAKE_OPT(v, n)      (((v) << 5) | (n))
BSD_MIN_BITS 9
BSD_MAX_BITS 15
CI_DEFLATE 26
CI_DEFLATE_DRAFT 24
CILEN_DEFLATE 4
DEFLATE_MIN_SIZE 8
DEFLATE_MAX_SIZE 15
DEFLATE_METHOD_VAL 8
DEFLATE_CHK_SEQUENCE 0
CI_PREDICTOR_1 1
CILEN_PREDICTOR_1 2
CI_PREDICTOR_2 2
CILEN_PREDICTOR_2 2
_PPP_DEFS_H_ None
PPP_HDRLEN 4
PPP_FCSLEN 2
PPP_MRU 1500
PPP_ALLSTATIONS 0xff
PPP_UI 0x03
PPP_FLAG 0x7e
PPP_ESCAPE 0x7d
PPP_TRANS 0x20
PPP_IP 0x21
PPP_XNS 0x25
PPP_AT 0x29
PPP_IPX 0x2b
PPP_VJC_COMP 0x2d
PPP_VJC_UNCOMP 0x2f
PPP_COMP 0xfd
PPP_IPCP 0x8021
PPP_ATCP 0x8029
PPP_IPXCP 0x802b
PPP_CCP 0x80fd
PPP_LCP 0xc021
PPP_PAP 0xc023
PPP_LQR 0xc025
PPP_CHAP 0xc223
PPP_CBCP 0xc029
PPP_IPV6 0x57
PPP_IPV6CP 0x8057
PPP_INITFCS 0xffff
PPP_GOODFCS 0xf0b8
PPP_FCS(fcs, c) (((fcs) >> 8) ^ fcstab[((fcs) ^ (c)) & 0xff])
Bcmp(a, b, l) 	(l == 0 ? 0 : bcmp((caddr_t)(a), (caddr_t)(b), (uint32_t)l))
RN_MATCHF(rn, f, arg)   (f == NULL || (*f)((rn), arg))
_RADIX_H_ None
RNF_NORMAL 1
RNF_ROOT 2
RNF_ACTIVE 4
rn_dupedkey rn_u.rn_leaf.rn_Dupedkey
rn_offset rn_u.rn_node.rn_Off
rn_left rn_u.rn_node.rn_L
rn_right rn_u.rn_node.rn_R
__rn_key rn_u.rn_leaf.rn_Key
__rn_mask rn_u.rn_leaf.rn_Mask
MKGet(m) {	if (rn_mkfreelist) {	        m = rn_mkfreelist; 	        rn_mkfreelist = (m)->rm_mklist; 	} else { 	        m = kalloc_type(struct radix_mask, Z_WAITOK_ZERO_NOFAIL); 	} }
MKFree(m) { (m)->rm_mklist = rn_mkfreelist; rn_mkfreelist = (m);}
_NET_RAW_CB_H_ None
RAWSNDQ 8192
RAWRCVQ 8192
RVI_IF_NAME "rvi"
RVI_DIR_IN IFF_LINK0
RVI_DIR_OUT IFF_LINK1
RVI_IF_FAMILY IFNET_FAMILY_LOOPBACK
RVI_IF_TYPE IFT_OTHER
__REMOTE_VIF_H__ None
RVI_CONTROL_NAME "com.apple.net.rvi_control"
RVI_VERSION_1 0x1
RVI_VERSION_2 0x2
RVI_VERSION_CURRENT RVI_VERSION_2
ENTITLEMENT_TEST_PORT "com.apple.private.network.restricted.port.test"
ENTITLEMENT_TEST_CONTROL "com.apple.private.network.restricted.port.control"
RPE_FLAG_SUPERUSER 0x01
RPE_FLAG_ENTITLEMENT 0x02
RPE_FLAG_TCP 0x04
RPE_FLAG_UDP 0x08
RPE_FLAG_TEST 0x10
_NETINET_IN_RESTRICTED_PORT_H_ None
PORT_FLAGS_LISTENER 0x00
PORT_FLAGS_BSD 0x02
PORT_FLAGS_PF 0x03
PORT_FLAGS_MAX 0x03
RTD_DEBUG 0x1
RTD_TRACE 0x2
RTD_NO_FREE 0x4
RTE_NAME "rtentry"
RTE_ZONE_MAX 65536
RTE_ZONE_NAME RTE_NAME
RTD_INUSE 0xFEEDFACE
RTD_FREED 0xDEADBEEF
RTENTRY_DBG(rte) __container_of(rte, struct rtentry_dbg, rtd_entry)
ASSERT_SINIFSCOPE(sa) {                                         	if ((sa)->sa_family != AF_INET ||                               	    (sa)->sa_len < sizeof (struct sockaddr_in))                 	        panic("%s: bad sockaddr_in %p", __func__, sa);        }
ASSERT_SIN6IFSCOPE(sa) {                                        	if ((sa)->sa_family != AF_INET6 ||                              	    (sa)->sa_len < sizeof (struct sockaddr_in6))                	        panic("%s: bad sockaddr_in6 %p", __func__, sa);       }
RN(r) rt_node((r))
ROUTE_VERBOSE_LOGGING 0
senderr(x) { error = x; goto bad; }
senderr(e) { error = (e); goto bad; }
_NET_ROUTE_H_ None
RTM_RTTUNIT 1000000
RTF_UP 0x1
RTF_GATEWAY 0x2
RTF_HOST 0x4
RTF_REJECT 0x8
RTF_DYNAMIC 0x10
RTF_MODIFIED 0x20
RTF_DONE 0x40
RTF_DELCLONE 0x80
RTF_CLONING 0x100
RTF_XRESOLVE 0x200
RTF_LLINFO 0x400
RTF_STATIC 0x800
RTF_BLACKHOLE 0x1000
RTF_NOIFREF 0x2000
RTF_PROTO2 0x4000
RTF_PROTO1 0x8000
RTF_PRCLONING 0x10000
RTF_WASCLONED 0x20000
RTF_PROTO3 0x40000
RTF_PINNED 0x100000
RTF_LOCAL 0x200000
RTF_BROADCAST 0x400000
RTF_MULTICAST 0x800000
RTF_IFSCOPE 0x1000000
RTF_CONDEMNED 0x2000000
RTF_IFREF 0x4000000
RTF_PROXY 0x8000000
RTF_ROUTER 0x10000000
RTF_DEAD 0x20000000
RTF_GLOBAL 0x40000000
RTPRF_OURS RTF_PROTO3
RTM_VERSION 5
RTM_ADD 0x1
RTM_DELETE 0x2
RTM_CHANGE 0x3
RTM_GET 0x4
RTM_LOSING 0x5
RTM_REDIRECT 0x6
RTM_MISS 0x7
RTM_LOCK 0x8
RTM_OLDADD 0x9
RTM_OLDDEL 0xa
RTM_RESOLVE 0xb
RTM_NEWADDR 0xc
RTM_DELADDR 0xd
RTM_IFINFO 0xe
RTM_NEWMADDR 0xf
RTM_DELMADDR 0x10
RTM_IFINFO2 0x12
RTM_NEWMADDR2 0x13
RTM_GET2 0x14
RTV_MTU 0x1
RTV_HOPCOUNT 0x2
RTV_EXPIRE 0x4
RTV_RPIPE 0x8
RTV_SPIPE 0x10
RTV_SSTHRESH 0x20
RTV_RTT 0x40
RTV_RTTVAR 0x80
RTA_DST 0x1
RTA_GATEWAY 0x2
RTA_NETMASK 0x4
RTA_GENMASK 0x8
RTA_IFP 0x10
RTA_IFA 0x20
RTA_AUTHOR 0x40
RTA_BRD 0x80
RTAX_DST 0
RTAX_GATEWAY 1
RTAX_NETMASK 2
RTAX_GENMASK 3
RTAX_IFP 4
RTAX_IFA 5
RTAX_AUTHOR 6
RTAX_BRD 7
RTAX_MAX 8
_NET_ROUTE_PRIVATE_H_ None
ROF_SRCIF_SELECTED 0x0001
_ROUTE_RELEASE_COMMON(_ro, _rnh_locked) do {                    	if ((_ro)->ro_rt != NULL) {                                     	        RT_LOCK_ASSERT_NOTHELD((_ro)->ro_rt);                   	        if (_rnh_locked)                                        	                rtfree_locked((_ro)->ro_rt);                    	        else                                                    	                rtfree((_ro)->ro_rt);                           	        (_ro)->ro_rt = NULL;                                    	}                                                               	if ((_ro)->ro_srcia != NULL) {                                  	        ifa_remref((_ro)->ro_srcia);                            	        (_ro)->ro_srcia = NULL;                                 	        (_ro)->ro_flags &= ~ROF_SRCIF_SELECTED;                 	}                                                               } while (0)
ROUTE_RELEASE_LOCKED(_ro) _ROUTE_RELEASE_COMMON(_ro, TRUE)
ROUTE_RELEASE(_ro) _ROUTE_RELEASE_COMMON(_ro, FALSE)
NRTT_HIST 10
rt_node(r) &((r)->rt_nodes[0])
rt_key(r) SA(rn_get_key(rt_node(r)))
rt_mask(r) SA(rn_get_mask(rt_node(r)))
rt_use rt_rmx.rmx_pksent
RT(r) rn_rtentry((r))
RT_GENID_SYNC(_rt) do {                                         	if ((_rt)->rt_tree_genid != NULL)                               	        (_rt)->rt_genid = *(_rt)->rt_tree_genid;                } while (0)
RTM_GET_SILENT 0x11
RTM_GET_EXT 0x15
RTV_REFRESH_HOST 0x100
IFSCOPE_NONE 0
IFSCOPE_UNKNOWN IFSCOPE_NONE
CTRACE_STACK_SIZE 8
CTRACE_HIST_SIZE 4
RT_LOCK_ASSERT_HELD(_rt) LCK_MTX_ASSERT(&(_rt)->rt_lock, LCK_MTX_ASSERT_OWNED)
RT_LOCK_ASSERT_NOTHELD(_rt) LCK_MTX_ASSERT(&(_rt)->rt_lock, LCK_MTX_ASSERT_NOTOWNED)
RT_LOCK(_rt) do {                                               	rt_lock(_rt, FALSE);                                            } while (0)
RT_LOCK_SPIN(_rt) do {                                          	rt_lock(_rt, TRUE);                                             } while (0)
RT_CONVERT_LOCK(_rt) do {                                       	RT_LOCK_ASSERT_HELD(_rt);                                       	lck_mtx_convert_spin(&(_rt)->rt_lock);                          } while (0)
RT_UNLOCK(_rt) do {                                             	rt_unlock(_rt);                                                 } while (0)
RT_ADDREF_LOCKED(_rt) do {                                      	rtref(_rt);                                                     } while (0)
RT_ADDREF(_rt) do {                                             	RT_LOCK_SPIN(_rt);                                              	RT_ADDREF_LOCKED(_rt);                                          	RT_UNLOCK(_rt);                                                 } while (0)
RT_REMREF_LOCKED(_rt) do {                                      	(void) rtunref(_rt);                                            } while (0)
RT_REMREF(_rt) do {                                             	RT_LOCK_SPIN(_rt);                                              	RT_REMREF_LOCKED(_rt);                                          	RT_UNLOCK(_rt);                                                 } while (0)
NET_CALCULATE_CLOCKSKEW(cc, ic, cu, iu)                         	((cc.tv_sec - ic) - (cu - iu))
rtev_ipaddr rt_addr._rtev_ipaddr
rtev_addr_bytes rt_addr._rtev_addr_bytes
ALIGN_BYTES(x) do {                                             	x = (uint32_t)P2ALIGN(x, 1024);                         } while(0)
RTM _rtm_hdr(rtm_buf)
senderr(e) { error = (e); goto flush; }
metric(f, e) if (which & (f)) out->rt_rmx.e = in->e;
CLAT46_ENTITLEMENT "com.apple.private.route.iflist.include-clat46"
RTSTAT_COMPAT(_field) rtstat_compat._field = rtstat._field < SHRT_MAX ? (short)rtstat._field : SHRT_MAX
X(type, field, default_value) 	        extern struct sysctl_oid sysctl__net_inet_tcp_##field;                          	        sysctls->tcp.field = *(type*)sysctl__net_inet_tcp_##field.oid_arg1;
_NET_SOCKADDR_UTILS_H_ None
__NET_SOCKADDR_UTILS_H_INCLUDED None
__SA_UTILS_STATIC_CAST(EXPR, DST_TYPENAME, ...)  _Generic((EXPR),                         	__STC_BYTES_TO_OBJ_CNV_CLAUSE(DST_TYPENAME),                                         	__STC_IDENTITY_CNV_CLAUSE(struct, DST_TYPENAME),                                     	__STC_TYPE_TO_OBJ_CNV_CLAUSE(struct, sockaddr, DST_TYPENAME),                        	__STC_TYPE_TO_OBJ_CNV_CLAUSE(struct, sockaddr_storage, DST_TYPENAME),                    ##__VA_ARGS__                                                                        )((EXPR))
__SA_UTILS_DECONST_CAST(EXPR, DST_TYPENAME, ...)  _Generic((EXPR),                        	__STC_CONST_IDENTITY_CNV_CLAUSE(struct, DST_TYPENAME),                               	__STC_CONST_TYPE_TO_OBJ_CNV_CLAUSE(struct, sockaddr, DST_TYPENAME),                  	__STC_CONST_TYPE_TO_OBJ_CNV_CLAUSE(struct, sockaddr_storage, DST_TYPENAME),              ##__VA_ARGS__                                                                        )((EXPR))
__SA_UTILS_CONV_TO_BYTES(X) _Generic((X),                                                 	        __STC_OBJ_TO_BYTES_CNV_CLAUSE(struct, sockaddr),                                      	        __STC_OBJ_TO_BYTES_CNV_CLAUSE(struct, sockaddr_storage),                              	        __STC_OBJ_TO_BYTES_CNV_CLAUSE(union, sockaddr_in_4_6),                                	        __STC_OBJ_TO_BYTES_CNV_CLAUSE(union, necp_sockaddr_union),                            	        __STC_OBJ_TO_BYTES_CNV_CLAUSE(struct, sockaddr_ctl),                                  	        __STC_OBJ_TO_BYTES_CNV_CLAUSE(struct, sockaddr_dl),                                   	        __STC_OBJ_TO_BYTES_CNV_CLAUSE(struct, sockaddr_in),                                   	        __STC_OBJ_TO_BYTES_CNV_CLAUSE(struct, sockaddr_in6),                                  	        __STC_OBJ_TO_BYTES_CNV_CLAUSE(struct, sockaddr_inarp),                                	        __STC_OBJ_TO_BYTES_CNV_CLAUSE(struct, sockaddr_inifscope),                            	        __STC_OBJ_TO_BYTES_CNV_CLAUSE(struct, sockaddr_ndrv),                                 	        __STC_OBJ_TO_BYTES_CNV_CLAUSE(struct, sockaddr_sys),                                  	        __STC_OBJ_TO_BYTES_CNV_CLAUSE(struct, sockaddr_un),                                   	        __STC_BYTES_TO_BYTES_CNV_CLAUSE()                                                     	)((X))
__SA_UTILS_CONV_TO_SOCKADDR(X) _Generic((X),                                              	        __STC_BYTES_TO_OBJ_CNV_CLAUSE(sockaddr),                                              	        __STC_TYPE_TO_OBJ_CNV_CLAUSE(struct, sockaddr_storage, sockaddr),                     	        __STC_TYPE_TO_OBJ_CNV_CLAUSE(union, sockaddr_in_4_6, sockaddr),                       	        __STC_TYPE_TO_OBJ_CNV_CLAUSE(union, necp_sockaddr_union, sockaddr),                   	        __STC_TYPE_TO_OBJ_CNV_CLAUSE(struct, sockaddr_ctl, sockaddr),                         	        __STC_TYPE_TO_OBJ_CNV_CLAUSE(struct, sockaddr_dl, sockaddr),                          	        __STC_TYPE_TO_OBJ_CNV_CLAUSE(struct, sockaddr_in, sockaddr),                          	        __STC_TYPE_TO_OBJ_CNV_CLAUSE(struct, sockaddr_in6, sockaddr),                         	        __STC_TYPE_TO_OBJ_CNV_CLAUSE(struct, sockaddr_inarp, sockaddr),                       	        __STC_TYPE_TO_OBJ_CNV_CLAUSE(struct, sockaddr_inifscope, sockaddr),                   	        __STC_TYPE_TO_OBJ_CNV_CLAUSE(struct, sockaddr_ndrv, sockaddr),                        	        __STC_TYPE_TO_OBJ_CNV_CLAUSE(struct, sockaddr_sys, sockaddr),                         	        __STC_TYPE_TO_OBJ_CNV_CLAUSE(struct, sockaddr_un, sockaddr),                          	        __STC_IDENTITY_CNV_CLAUSE(struct, sockaddr)                                           	)((X))
__SA_UTILS_DECONST_AND_CONV_TO_SOCKADDR(X) _Generic((X),                                  	        __STC_CONST_TYPE_TO_OBJ_CNV_CLAUSE(struct, sockaddr_storage, sockaddr),               	        __STC_CONST_TYPE_TO_OBJ_CNV_CLAUSE(union, sockaddr_in_4_6, sockaddr),                 	        __STC_CONST_TYPE_TO_OBJ_CNV_CLAUSE(union, necp_sockaddr_union, sockaddr),             	        __STC_CONST_TYPE_TO_OBJ_CNV_CLAUSE(struct, sockaddr_ctl, sockaddr),                   	        __STC_CONST_TYPE_TO_OBJ_CNV_CLAUSE(struct, sockaddr_dl, sockaddr),                    	        __STC_CONST_TYPE_TO_OBJ_CNV_CLAUSE(struct, sockaddr_in, sockaddr),                    	        __STC_CONST_TYPE_TO_OBJ_CNV_CLAUSE(struct, sockaddr_in6, sockaddr),                   	        __STC_CONST_TYPE_TO_OBJ_CNV_CLAUSE(struct, sockaddr_inarp, sockaddr),                 	        __STC_CONST_TYPE_TO_OBJ_CNV_CLAUSE(struct, sockaddr_inifscope, sockaddr),             	        __STC_CONST_TYPE_TO_OBJ_CNV_CLAUSE(struct, sockaddr_ndrv, sockaddr),                  	        __STC_CONST_TYPE_TO_OBJ_CNV_CLAUSE(struct, sockaddr_sys, sockaddr),                   	        __STC_CONST_TYPE_TO_OBJ_CNV_CLAUSE(struct, sockaddr_un, sockaddr),                    	        __STC_CONST_IDENTITY_CNV_CLAUSE(struct, sockaddr)                                     	)((X))
SA(s) __SA_UTILS_CONV_TO_SOCKADDR((s))
__DECONST_SA(s) __SA_UTILS_DECONST_AND_CONV_TO_SOCKADDR((s))
SA_BYTES(s) __SA_UTILS_CONV_TO_BYTES(s)
SOCKADDR_COPY(SRC, DST, LEN)  do {                                                        	const uint8_t* __sau_sbytes = __SA_UTILS_CONV_TO_BYTES((SRC));                                	uint8_t* __sau_dbytes = __SA_UTILS_CONV_TO_BYTES((DST));                                      	bcopy(__sau_sbytes, __sau_dbytes, (LEN));                                                     } while(0)
SOCKADDR_ZERO(SRC, LEN)  do {                                                             	uint8_t* __sau_src_bytes = __SA_UTILS_CONV_TO_BYTES((SRC));                                   	bzero(__sau_src_bytes, (LEN));                                                                } while(0)
SOCKADDR_CMP(LH, RH, LEN)  ({                                                             	int __sac_rv = 0;                                                                             	const uint8_t* __sau_lhb = __SA_UTILS_CONV_TO_BYTES((LH));                                    	const uint8_t* __sau_rhb = __SA_UTILS_CONV_TO_BYTES((RH));                                    	__sac_rv = bcmp(__sau_lhb, __sau_rhb, (LEN));                                                 	__sac_rv;                                                                                     })
__SA_UTILS_CONV_TO_SOCKADDR_CTL(X) __SA_UTILS_STATIC_CAST(X, sockaddr_ctl)
__SA_UTILS_DECONST_AND_CONV_TO_SOCKADDR_CTL(X) __SA_UTILS_DECONST_CAST(X, sockaddr_ctl)
SCTL(s) __SA_UTILS_CONV_TO_SOCKADDR_CTL((s))
__DECONST_SCTL(s) __SA_UTILS_DECONST_AND_CONV_TO_SOCKADDR_CTL((s))
__SA_UTILS_CONV_TO_SOCKADDR_DL(X) __SA_UTILS_STATIC_CAST(X, sockaddr_dl)
__SA_UTILS_DECONST_AND_CONV_TO_SOCKADDR_DL(X) __SA_UTILS_DECONST_CAST (X, sockaddr_dl)
SDL(s) __SA_UTILS_CONV_TO_SOCKADDR_DL((s))
__DECONST_SDL(s) __SA_UTILS_DECONST_AND_CONV_TO_SOCKADDR_DL((s))
__SA_UTILS_CONV_TO_SOCKADDR_IN(X) __SA_UTILS_STATIC_CAST(X, sockaddr_in,                                                        	__STC_ENABLE_STATIC_CAST(union, sockaddr_in_4_6, sockaddr_in),                                	__STC_ENABLE_STATIC_CAST(union, necp_sockaddr_union, sockaddr_in))
__SA_UTILS_DECONST_AND_CONV_TO_SOCKADDR_IN(X) __SA_UTILS_DECONST_CAST (X, sockaddr_in,                                                      	    __STC_ENABLE_DECONST_CAST(union, sockaddr_in_4_6, sockaddr_in),                           	    __STC_ENABLE_DECONST_CAST(union, necp_sockaddr_union, sockaddr_in))
SIN(s) __SA_UTILS_CONV_TO_SOCKADDR_IN((s))
__DECONST_SIN(s) __SA_UTILS_DECONST_AND_CONV_TO_SOCKADDR_IN((s))
satosin(sa) SIN(sa)
sintosa(sin) SA(sin)
__SA_UTILS_CONV_TO_SOCKADDR_INARP(X) __SA_UTILS_STATIC_CAST(X, sockaddr_inarp)
__SA_UTILS_DECONST_AND_CONV_TO_SOCKADDR_INARP(X) __SA_UTILS_DECONST_CAST(X, sockaddr_inarp)
SINARP(s) __SA_UTILS_CONV_TO_SOCKADDR_INARP((s))
__DECONST_SINARP(s) __SA_UTILS_DECONST_AND_CONV_TO_SOCKADDR_INARP((s))
__SA_UTILS_CONV_TO_SOCKADDR_INIFSCOPE(X) __SA_UTILS_STATIC_CAST(X, sockaddr_inifscope,                                                 	   __STC_ENABLE_STATIC_CAST(union, sockaddr_in_4_6, sockaddr_inifscope),                      	   __STC_ENABLE_STATIC_CAST(union, necp_sockaddr_union, sockaddr_inifscope))
__SA_UTILS_DECONST_AND_CONV_TO_SOCKADDR_INIFSCOPE(X) __SA_UTILS_DECONST_CAST(X, sockaddr_inifscope,                                                	    __STC_ENABLE_DECONST_CAST(union, sockaddr_in_4_6, sockaddr_inifscope),                    	    __STC_ENABLE_DECONST_CAST(union, necp_sockaddr_union, sockaddr_inifscope))
SINIFSCOPE(s) __SA_UTILS_CONV_TO_SOCKADDR_INIFSCOPE((s))
__DECONST_SINIFSCOPE(s) __SA_UTILS_DECONST_AND_CONV_TO_SOCKADDR_INIFSCOPE((s))
__SA_UTILS_CONV_TO_SOCKADDR_IN6(X) __SA_UTILS_STATIC_CAST(X, sockaddr_in6,                                                       	__STC_ENABLE_STATIC_CAST(union, sockaddr_in_4_6, sockaddr_in6),                               	__STC_ENABLE_STATIC_CAST(union, necp_sockaddr_union, sockaddr_in6))
__SA_UTILS_DECONST_AND_CONV_TO_SOCKADDR_IN6(X) __SA_UTILS_DECONST_CAST(X, sockaddr_in6,                                                      	    __STC_ENABLE_DECONST_CAST(union, sockaddr_in_4_6, sockaddr_in6),                          	    __STC_ENABLE_DECONST_CAST(union, necp_sockaddr_union, sockaddr_in6))
SIN6(s) __SA_UTILS_CONV_TO_SOCKADDR_IN6((s))
__DECONST_SIN6(s) __SA_UTILS_DECONST_AND_CONV_TO_SOCKADDR_IN6((s))
satosin6(sa) SIN6(sa)
sin6tosa(sin6) SA((sin6))
SIN6IFSCOPE(s) SIN6(s)
__SA_UTILS_CONV_TO_SOCKADDR_NDRV(X) __SA_UTILS_STATIC_CAST(X, sockaddr_ndrv)
__SA_UTILS_DECONST_AND_CONV_TO_SOCKADDR_NDRV(X) __SA_UTILS_DECONST_CAST(X, sockaddr_ndrv)
SNDRV(s) __SA_UTILS_CONV_TO_SOCKADDR_NDRV((s))
__DECONST_SNDRV(s) __SA_UTILS_DECONST_AND_CONV_TO_SOCKADDR_NDRV((s))
__SA_UTILS_CONV_TO_SOCKADDR_SYS(X) __SA_UTILS_STATIC_CAST(X, sockaddr_sys)
__SA_UTILS_DECONST_AND_CONV_TO_SOCKADDR_SYS(X) __SA_UTILS_DECONST_CAST(X, sockaddr_sys)
SSYS(s) __SA_UTILS_CONV_TO_SOCKADDR_SYS((s))
__DECONST_SSYS(s) __SA_UTILS_DECONST_AND_CONV_TO_SOCKADDR_SYS((s))
__SA_UTILS_CONV_TO_SOCKADDR_UN(X) __SA_UTILS_STATIC_CAST(X, sockaddr_un)
__SA_UTILS_DECONST_AND_CONV_TO_SOCKADDR_UN(X) __SA_UTILS_DECONST_CAST(X, sockaddr_un)
SUN(s) __SA_UTILS_CONV_TO_SOCKADDR_UN((s))
__DECONST_SUN(s) __SA_UTILS_DECONST_AND_CONV_TO_SOCKADDR_UN((s))
_NET_STRICT_TYPE_CNV_PRIVATE_H_ None
__WCAST_ALIGN "clang diagnostic ignored \"-Wcast-align\""
__WITH_SUPPRESSION(SUPPRESSION, ...) ({                                                   	_Pragma("clang diagnostic push");                                                             	_Pragma(SUPPRESSION);                                                                         	__VA_ARGS__                                                                                   	_Pragma("clang diagnostic pop");                                                              })
__STC_DECONST_AND_CONVERT(STAG, STYPE, DTAG, DTYPE, VAL) ({                                    STAG STYPE *__single __sau_deconst_val;                                                        	__sau_deconst_val = __DECONST(STAG STYPE * __single, (VAL));                                       __WITH_SUPPRESSION(__WCAST_ALIGN, (DTAG DTYPE * __single)(__sau_deconst_val));                 })
__STC_CONV_TO(STAG, STYPE, DTAG, DTYPE, VAL) ({                                               __WITH_SUPPRESSION(__WCAST_ALIGN, (DTAG DTYPE * __single)((VAL)));                            })
__STC_CONV_CONST_TO_CONST(STYPE, DTYPE, VAL) ({                                               __WITH_SUPPRESSION(__WCAST_ALIGN, (const struct DTYPE * __single)((VAL)));                    })
__STC_CONV_TO_BYTES_LEN(VAL, MAX_LEN) ({                                                      __WITH_SUPPRESSION(__WCAST_ALIGN, __unsafe_forge_bidi_indexable(uint8_t*, (VAL), (MAX_LEN))); })
__STC_CONV_FROM_BYTES_LEN(DTAG, DTYPE, VAL, LEN) ({                                           __WITH_SUPPRESSION(__WCAST_ALIGN, __unsafe_forge_single(DTAG DTYPE *, (VAL)));                })
__STC_OBJ_TO_BY_CNV(T) __stc_convert_##T##_to_bytes
__STC_COBJ_TO_CBY_CNV(T) __stc_convert_const_##T##_to_const_bytes
__STC_BY_TO_OBJ_CNV(T) __stc_convert_bytes_to_##T
__STC_CBY_TO_COBJ_CNV(T) __stc_convert_const_bytes_to_const_##T
__STC_CBY_TO_CBY_CNV() __stc_convert_const_bytes_to_const_bytes
__STC_BY_TO_BY_CNV() __stc_convert_bytes_to_bytes
__STC_TY_TY_CNV_F(F, T)      __stc_convert_##F##_to_##T
__STC_CTY_TY_CNV_F(F, T)     __stc_convert_const_##F##_to_##T
__STC_CTY_CTY_CNV_F(F, T)    __stc_convert_const_##F##_to_const_##T
__STC_TY_ID_CNV_F(F) __stc_convert_##F##_identity
__STC_CTY_ID_CNV_F(F) __stc_convert_const_##F##_identity
__STC_CTY_CID_CNV_F(F) __stc_convert_##F##_const_identity
__STC_OBJ_TO_BYTES_CNV_IMPL(CV, TAG, TYPE, MAX_LEN, CNV_F)                                __STC_CONV_ATTRS__                                                                                static inline CV uint8_t* __header_indexable                                                      CNV_F(const TAG TYPE *ptr __single)                                                               {                                                                                                     return __STC_CONV_TO_BYTES_LEN(__DECONST(TAG TYPE *__single, ptr), (MAX_LEN));                }
__STC_BYTES_TO_OBJ_CNV_IMPL(CV, TAG, TYPE, BTYPE, MIN_LEN, CNV_F)                         static inline CV TAG TYPE * __single                                                              __attribute__((overloadable))                                                                     CNV_F(CV BTYPE * data __header_indexable)                                                         {                                                                                                 	__STC_ENFORCE_MIN_LEN(CV BTYPE, MIN_LEN, data);                                                   return __STC_CONV_FROM_BYTES_LEN(CV TAG, TYPE, data, (MIN_LEN));                              }
__STC_OBJ_TO_OBJ_CNV_IMPL(CV, STAG, STYPE, DTAG, DTYPE, CNV_F)                            __STC_CONV_ATTRS__                                                                                static inline CV DTAG DTYPE * __single                                                            __attribute__((overloadable))                                                                     CNV_F(CV STAG STYPE *ptr __single)                                                                {                                                                                                     return __STC_CONV_TO(CV STAG, STYPE, CV DTAG, DTYPE, ptr);                                    }
__STC_COBJ_TO_OBJ_CNV_IMPL(STAG, STYPE, DTAG, DTYPE, CNV_F)                               __STC_CONV_ATTRS__                                                                                static inline DTAG DTYPE * __single                                                               __attribute__((overloadable))                                                                     CNV_F(const STAG STYPE *ptr __single)                                                             {                                                                                                     return __STC_DECONST_AND_CONVERT(STAG, STYPE, DTAG, DTYPE, ptr);                              }
__STC_DEFINE_OBJECT_CONVERTERS(STAG, STYPE, DTAG, DTYPE)                                                                                                              __STC_OBJ_TO_OBJ_CNV_IMPL(, STAG, STYPE, DTAG, DTYPE,  __STC_TY_TY_CNV_F(STYPE, DTYPE))                                                                                                                                                                                          __STC_OBJ_TO_OBJ_CNV_IMPL(, DTAG, DTYPE, STAG, STYPE,  __STC_TY_TY_CNV_F(DTYPE, STYPE))                                                                                                                                                                                   __STC_OBJ_TO_OBJ_CNV_IMPL(const, STAG, STYPE, DTAG, DTYPE, __STC_CTY_CTY_CNV_F(STYPE, DTYPE))                                                                                                                                                                             __STC_OBJ_TO_OBJ_CNV_IMPL(const, DTAG, DTYPE, STAG, STYPE, __STC_CTY_CTY_CNV_F(DTYPE, STYPE))                                                                                                                                                                           __STC_COBJ_TO_OBJ_CNV_IMPL(STAG, STYPE, DTAG, DTYPE, __STC_CTY_TY_CNV_F(STYPE, DTYPE))                                                                                                                                                                                  __STC_COBJ_TO_OBJ_CNV_IMPL(DTAG, DTYPE, STAG, STYPE, __STC_CTY_TY_CNV_F(DTYPE, STYPE))
__STC_DEFINE_SELF_CONVERTERS(DTAG, DTYPE)                                                                                                                            __STC_CONV_ATTRS__                                                                                static inline DTAG DTYPE *__single                                                                __STC_TY_ID_CNV_F(DTYPE)(DTAG DTYPE *sin __single)                                                {                                                                                                     return sin;                                                                                   }                                                                                                                                                                                                                                                                        __STC_CONV_ATTRS__                                                                                static inline const DTAG DTYPE *__single                                                          __STC_CTY_CID_CNV_F(DTYPE)(const DTAG DTYPE *sin __single)                                        {                                                                                                     return sin;                                                                                   }                                                                                                                                                                                                                                                                      __STC_CONV_ATTRS__                                                                                static inline DTAG DTYPE *__single                                                                __STC_CTY_ID_CNV_F(DTYPE)(const DTAG DTYPE *sin __single)                                         {                                                                                                     return __DECONST(DTAG DTYPE *__single, sin);                                                  }
__STC_DEFINE_BYTE_TO_OBJ_CNVS(TAG, TYPE, MIN_LEN, MAX_LEN)                                                                                                       __STC_OBJ_TO_BYTES_CNV_IMPL(, TAG, TYPE, MAX_LEN, __STC_OBJ_TO_BY_CNV(TYPE))                                                                                                                                                                                   __STC_OBJ_TO_BYTES_CNV_IMPL(, TAG, TYPE, MAX_LEN, __STC_COBJ_TO_CBY_CNV(TYPE))                                                                                                                                                                                             __STC_BYTES_TO_OBJ_CNV_IMPL(, TAG, TYPE, void, MIN_LEN, __STC_BY_TO_OBJ_CNV(TYPE))                                                                                                                                                                             __STC_BYTES_TO_OBJ_CNV_IMPL(const, TAG, TYPE, void, MIN_LEN, __STC_CBY_TO_COBJ_CNV(TYPE))
__STC_TYPE_TO_OBJ_CNV_CLAUSE(STAG, STYPE, DTYPE)                                           	__STC_GENERIC_CV_CNV_CLAUSE(, STAG, STYPE, __STC_TY_TY_CNV_F(STYPE, DTYPE)),                 	__STC_GENERIC_CV_CNV_CLAUSE(const, STAG, STYPE, __STC_CTY_CTY_CNV_F(STYPE, DTYPE))
__STC_BYTES_TO_OBJ_CNV_CLAUSE(TYPE) __STC_GENERIC_CV_CNV_CLAUSE(     , , char,     __STC_BY_TO_OBJ_CNV(TYPE)),                   	__STC_GENERIC_CV_CNV_CLAUSE(     , , uint8_t,  __STC_BY_TO_OBJ_CNV(TYPE)),                   	__STC_GENERIC_CV_CNV_CLAUSE(     , , void,     __STC_BY_TO_OBJ_CNV(TYPE)),                   	__STC_GENERIC_CV_CNV_CLAUSE(const, , char,     __STC_CBY_TO_COBJ_CNV(TYPE)),                 	__STC_GENERIC_CV_CNV_CLAUSE(const, , uint8_t,  __STC_CBY_TO_COBJ_CNV(TYPE)),                 	__STC_GENERIC_CV_CNV_CLAUSE(const, , void,     __STC_CBY_TO_COBJ_CNV(TYPE))
__STC_OBJ_TO_BYTES_CNV_CLAUSE(TAG, TYPE)                                                              	__STC_GENERIC_CV_CNV_CLAUSE(     , TAG, TYPE,  __STC_OBJ_TO_BY_CNV(TYPE)),                    	__STC_GENERIC_CV_CNV_CLAUSE(const, TAG, TYPE,  __STC_COBJ_TO_CBY_CNV(TYPE))
__STC_BYTES_TO_BYTES_CNV_CLAUSE() __STC_GENERIC_CV_CNV_CLAUSE(     , , char,     __STC_BY_TO_BY_CNV()),                          	__STC_GENERIC_CV_CNV_CLAUSE(     , , uint8_t,  __STC_BY_TO_BY_CNV()),                          	__STC_GENERIC_CV_CNV_CLAUSE(     , , void,     __STC_BY_TO_BY_CNV()),                          	__STC_GENERIC_CV_CNV_CLAUSE(const, , char,     __STC_CBY_TO_CBY_CNV()),                        	__STC_GENERIC_CV_CNV_CLAUSE(const, , uint8_t,  __STC_CBY_TO_CBY_CNV()),                        	__STC_GENERIC_CV_CNV_CLAUSE(const, , void,     __STC_CBY_TO_CBY_CNV())
__STC_CONST_TYPE_TO_OBJ_CNV_CLAUSE(STAG, STYPE, DTYPE)                                     	__STC_GENERIC_CV_CNV_CLAUSE(const, STAG, STYPE,   __STC_CTY_TY_CNV_F(STYPE, DTYPE))
__STC_CONST_IDENTITY_CNV_CLAUSE(TAG, TYPE)                                                 	__STC_GENERIC_CV_CNV_CLAUSE(const, TAG, TYPE, __STC_CTY_ID_CNV_F(TYPE))
__STC_IDENTITY_CNV_CLAUSE(TAG, TYPE)                                                     	__STC_GENERIC_CV_CNV_CLAUSE(const, TAG, TYPE, __STC_CTY_ID_CNV_F(TYPE)),                     	__STC_GENERIC_CV_CNV_CLAUSE(,      TAG, TYPE, __STC_TY_ID_CNV_F(TYPE))
__STC_ENABLE_STATIC_CAST(SRC_TAG, SRC_TYPENAME, DST_TYPENAME)                             	__STC_TYPE_TO_OBJ_CNV_CLAUSE(SRC_TAG, SRC_TYPENAME, DST_TYPENAME)
__STC_ENABLE_DECONST_CAST(SRC_TAG, SRC_TYPENAME, DST_TYPENAME)                            	__STC_CONST_TYPE_TO_OBJ_CNV_CLAUSE(SRC_TAG, SRC_TYPENAME, DST_TYPENAME)
__STC_COUNT_ARGS1(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, N, ...) N
__STC_COUNT_ARGS(...) __STC_COUNT_ARGS1(, ##__VA_ARGS__, _9, _8, _7, _6, _5, _4, _3, _2, _1, _0)
__STC_DISPATCH1(base, N, ...) __CONCAT(base, N)(__VA_ARGS__)
__STC_DISPATCH(base, ...)                                                                 	__STC_DISPATCH1(base, __STC_COUNT_ARGS(__VA_ARGS__), ##__VA_ARGS__)
__STC_DEFINE_STATIC_CAST(SRC_TAG, SRC_TYPENAME, DST_TAG, DST_TYPENAME)                    __STC_DEFINE_OBJECT_CONVERTERS(SRC_TAG, SRC_TYPENAME, DST_TAG, DST_TYPENAME)
__STC_DEFINE_SUBTYPE_IMPL_4(TAG, TYPENAME, MIN_LEN, MAX_LEN)                              	__STC_DEFINE_SELF_CONVERTERS(TAG, TYPENAME);                                         	__STC_DEFINE_STATIC_CAST(TAG, TYPENAME, struct, sockaddr)                                     	__STC_DEFINE_STATIC_CAST(TAG, TYPENAME, struct, sockaddr_storage)                             	__STC_DEFINE_BYTE_TO_OBJ_CNVS(TAG, TYPENAME, MIN_LEN, MAX_LEN)
__STC_DEFINE_SUBTYPE_IMPL_6(TAG, TYPENAME, MIN_LEN, MAX_LEN, TAG1, TYPENAME1)             	__STC_DEFINE_SUBTYPE_IMPL_4(TAG, TYPENAME, MIN_LEN, MAX_LEN)                                  	__STC_DEFINE_STATIC_CAST(TAG, TYPENAME, TAG1, TYPENAME1)
__STC_DEFINE_SUBTYPE_IMPL_8(TAG, TYPENAME, MIN_LEN, MAX_LEN,                              	    TAG1, TYPENAME1, TAG2, TYPENAME2)                             	__STC_DEFINE_SUBTYPE_IMPL_6(TAG, TYPENAME, MIN_LEN, MAX_LEN, TAG1, TYPENAME1)                 	__STC_DEFINE_STATIC_CAST(TAG, TYPENAME, TAG2, TYPENAME2)
__STC_DEFINE_VARIABLE_SIZE_SUBTYPE_2(TAG, TYPENAME)                                           __STC_DEFINE_SUBTYPE_IMPL_4(TAG, TYPENAME, sizeof(TAG TYPENAME), 255)
__STC_DEFINE_VARIABLE_SIZE_SUBTYPE_4(TAG, TYPENAME, TAG1, TYPENAME1)                      	__STC_DEFINE_SUBTYPE_IMPL_6(TAG, TYPENAME, sizeof(TAG TYPENAME), 255, TAG1, TYPENAME1)
__STC_DEFINE_VARIABLE_SIZE_SUBTYPE_6(TAG, TYPENAME, TAG1, TYPENAME1, TAG2, TYPENAME2)     	__STC_DEFINE_SUBTYPE_IMPL_6(TAG, TYPENAME, sizeof(TAG TYPENAME), 255,                         	                                                        TAG1, TYPENAME1, TAG2, TYPENAME2)
__SA_UTILS_DEFINE_VARIABLE_SIZE_SUBTYPE(...) __STC_DISPATCH(__STC_DEFINE_VARIABLE_SIZE_SUBTYPE, ##__VA_ARGS__)
__STC_DEFINE_FIXED_SIZE_SUBTYPE_2(TAG, TYPENAME)                                              __STC_DEFINE_SUBTYPE_IMPL_4(TAG, TYPENAME, sizeof(TAG TYPENAME), sizeof(TAG TYPENAME))
__STC_DEFINE_FIXED_SIZE_SUBTYPE_4(TAG, TYPENAME, TAG1, TYPENAME1)                             __STC_DEFINE_SUBTYPE_IMPL_6(TAG, TYPENAME, sizeof(TAG TYPENAME), sizeof(TAG TYPENAME),        	                                                        TAG1, TYPENAME1)
__STC_DEFINE_FIXED_SIZE_SUBTYPE_6(TAG, TYPENAME, TAG1, TYPENAME1, TAG2, TYPENAME2)            __STC_DEFINE_SUBTYPE_IMPL_8(TAG, TYPENAME, sizeof(TAG TYPENAME), sizeof(TAG TYPENAME),        	                                                        TAG1, TYPENAME1, TAG2, TYPENAME2)
__SA_UTILS_DEFINE_FIXED_SIZE_SUBTYPE(...) __STC_DISPATCH(__STC_DEFINE_FIXED_SIZE_SUBTYPE, ##__VA_ARGS__)
NET_TRIE_DEBUG_SEARCH 0
NET_TRIE_LOG(level, fmt, ...)                                                                                   do {                                                                                                                        if (net_trie_log_level >= level && net_trie_log_handle) {                                                           	if (level == LOG_ERR) {                                                                                         	    os_log_error(net_trie_log_handle, "NET_TRIE - %s:%d " fmt "\n", __FUNCTION__, __LINE__, ##__VA_ARGS__);     	} else {                                                                                                        	    os_log(net_trie_log_handle, "NET_TRIE - %s:%d " fmt "\n", __FUNCTION__, __LINE__, ##__VA_ARGS__);           	}                                                                                                                   }                                                                                                                   } while (0)
TRIE_CHILD_SET(t, i, b, node)                                                                                       {                                                                                                                   	if (b >= FIRST_PRINTABLE_ASCII && b <= LAST_PRINTABLE_ASCII) {                                                  	    (((t)->child_maps + (CHILD_MAP_SIZE * TRIE_NODE(t, i).child_map))[(b - FIRST_PRINTABLE_ASCII)]) = node;     	}  else {                                                                                                       	    NET_TRIE_LOG(LOG_ERR, "NETrie - out of printable acsii range <%X>", b);                                     	}                                                                                                                   }
_TRIE_UTILITY_H_ None
FIRST_PRINTABLE_ASCII 32
LAST_PRINTABLE_ASCII 127
NULL_TRIE_IDX 0xffff
TRIE_NODE(t, i)                 ((t)->nodes[(i)])
TRIE_CHILD_GET(t, i, b)         ((b >= FIRST_PRINTABLE_ASCII && b <= LAST_PRINTABLE_ASCII) ? 	                                 (((t)->child_maps + (CHILD_MAP_SIZE * TRIE_NODE(t, i).child_map))[(b - FIRST_PRINTABLE_ASCII)]) : 	                                 NULL_TRIE_IDX)
TRIE_BYTE(t, i)                 ((t)->bytes[(i)])
NET_TRIE_MAGIC 0x5061747269636961
NET_TRIE_FORMAT_VERSION 2
_NETINET_BOOTP_H_ None
iaddr_t struct in_addr
BOOTREQUEST 1
BOOTREPLY 2
IPPORT_BOOTPS 67
IPPORT_BOOTPC 68
VM_STANFORD "STAN"
VF_PCBOOT 1
VF_HELP 2
NVMAXTEXT 55
nv_unused nv_U.NV0
nv_opcode nv_U.NV1.NV1_opcode
nv_xid nv_U.NV1.NV1_xid
nv_text nv_U.NV1.NV1_text
nv_null nv_U.NV1.NV1_null
VM_NEXT "NeXT"
BPOP_OK 0
BPOP_QUERY 1
BPOP_QUERY_NE 2
BPOP_ERROR 3
BOOTP_MIN_BACKOFF 0x7ff
BOOTP_MAX_BACKOFF 0xffff
BOOTP_RETRY 6
CKSUM_ERR(fmt, args...) kprintf(fmt, ## args)
_CASSERT(x) _Static_assert(x, "compile-time assertion failed")
CKSUM_ERR(fmt, args...) ((void)0)
PREDICT_TRUE(x) __builtin_expect(!!((long)(x)), 1L)
PREDICT_FALSE(x) __builtin_expect(!!((long)(x)), 0L)
_NETINET_DHCP_H None
DHCP_OPTIONS_MIN 312
DHCPDISCOVER 1
DHCPOFFER 2
DHCPREQUEST 3
DHCPDECLINE 4
DHCPACK 5
DHCPNAK 6
DHCPRELEASE 7
DHCPINFORM 8
dhcp_time_hton htonl
dhcp_time_ntoh ntohl
dhcp_lease_hton htonl
dhcp_lease_ntoh ntohl
PTRLIST_NUMBER 16
_NETINET_DHCP_OPTIONS_H None
DHCP_OVERLOAD_FILE 1
DHCP_OVERLOAD_SNAME 2
DHCP_OVERLOAD_BOTH 3
DHCP_OPTION_SIZE_MAX 255
DHCP_TAG_OFFSET 0
DHCP_LEN_OFFSET 1
DHCP_OPTION_OFFSET 2
RFC_OPTIONS_MAGIC { 99, 130, 83, 99 }
RFC_MAGIC_SIZE 4
FLOW_DIVERT_CONNECT_STARTED 0x00000001
FLOW_DIVERT_READ_CLOSED 0x00000002
FLOW_DIVERT_WRITE_CLOSED 0x00000004
FLOW_DIVERT_TUNNEL_RD_CLOSED 0x00000008
FLOW_DIVERT_TUNNEL_WR_CLOSED 0x00000010
FLOW_DIVERT_HAS_HMAC 0x00000040
FLOW_DIVERT_NOTIFY_ON_RECEIVED 0x00000080
FLOW_DIVERT_IMPLICIT_CONNECT 0x00000100
FLOW_DIVERT_DID_SET_LOCAL_ADDR 0x00000200
FLOW_DIVERT_HAS_TOKEN 0x00000400
FLOW_DIVERT_SHOULD_SET_LOCAL_ADDR 0x00000800
FLOW_DIVERT_FLOW_IS_TRANSPARENT 0x00001000
FDLOG(level, pcb, format, ...) 	os_log_with_type(OS_LOG_DEFAULT, flow_divert_syslog_type_to_oslog_type(level), "(%u): " format "\n", (pcb)->hash, __VA_ARGS__)
FDLOG0(level, pcb, msg) 	os_log_with_type(OS_LOG_DEFAULT, flow_divert_syslog_type_to_oslog_type(level), "(%u): " msg "\n", (pcb)->hash)
FDRETAIN(pcb) if ((pcb) != NULL) OSIncrementAtomic(&(pcb)->ref_count)
FDRELEASE(pcb) do {                                                                                                                                    	        if ((pcb) != NULL && 1 == OSDecrementAtomic(&(pcb)->ref_count)) {       	                flow_divert_pcb_destroy(pcb);                                                                   	        }                                                                                                                                       	} while (0)
FDGRP_RETAIN(grp) if ((grp) != NULL) OSIncrementAtomic(&(grp)->ref_count)
FDGRP_RELEASE(grp) if ((grp) != NULL && 1 == OSDecrementAtomic(&(grp)->ref_count)) flow_divert_group_destroy(grp)
FDLOCK(pcb) lck_mtx_lock(&(pcb)->mtx)
FDUNLOCK(pcb) lck_mtx_unlock(&(pcb)->mtx)
GROUP_BIT_CTL_ENQUEUE_BLOCKED 0
GROUP_COUNT_MAX 31
FLOW_DIVERT_MAX_NAME_SIZE 4096
FLOW_DIVERT_MAX_KEY_SIZE 1024
CHILD_MAP_SIZE 256
NULL_TRIE_IDX 0xffff
TRIE_NODE(t, i)                 ((t)->nodes[(i)])
TRIE_CHILD(t, i, b)             (((t)->child_maps + (CHILD_MAP_SIZE * TRIE_NODE(t, i).child_map))[(b)])
TRIE_BYTE(t, i)                 ((t)->bytes[(i)])
APPLE_WEBCLIP_ID_PREFIX "com.apple.webapp"
__FLOW_DIVERT_H__ None
FLOW_DIVERT_ORDER_LAST INT_MAX
__FLOW_DIVERT_PROTO_H__ None
FLOW_DIVERT_CONTROL_NAME "com.apple.flow-divert"
FLOW_DIVERT_TLV_LENGTH_UINT32 1
FLOW_DIVERT_PKT_CONNECT 1
FLOW_DIVERT_PKT_CONNECT_RESULT 2
FLOW_DIVERT_PKT_DATA 3
FLOW_DIVERT_PKT_CLOSE 4
FLOW_DIVERT_PKT_READ_NOTIFY 5
FLOW_DIVERT_PKT_GROUP_INIT 6
FLOW_DIVERT_PKT_PROPERTIES_UPDATE 7
FLOW_DIVERT_PKT_APP_MAP_CREATE 9
FLOW_DIVERT_PKT_FLOW_STATES_REQUEST 10
FLOW_DIVERT_PKT_FLOW_STATES 11
FLOW_DIVERT_TLV_NIL 0
FLOW_DIVERT_TLV_ERROR_CODE 5
FLOW_DIVERT_TLV_HOW 7
FLOW_DIVERT_TLV_READ_COUNT 8
FLOW_DIVERT_TLV_SPACE_AVAILABLE 9
FLOW_DIVERT_TLV_CTL_UNIT 10
FLOW_DIVERT_TLV_LOCAL_ADDR 11
FLOW_DIVERT_TLV_REMOTE_ADDR 12
FLOW_DIVERT_TLV_OUT_IF_INDEX 13
FLOW_DIVERT_TLV_TRAFFIC_CLASS 14
FLOW_DIVERT_TLV_NO_CELLULAR 15
FLOW_DIVERT_TLV_FLOW_ID 16
FLOW_DIVERT_TLV_TOKEN_KEY 17
FLOW_DIVERT_TLV_HMAC 18
FLOW_DIVERT_TLV_KEY_UNIT 19
FLOW_DIVERT_TLV_LOG_LEVEL 20
FLOW_DIVERT_TLV_TARGET_HOSTNAME 21
FLOW_DIVERT_TLV_TARGET_ADDRESS 22
FLOW_DIVERT_TLV_TARGET_PORT 23
FLOW_DIVERT_TLV_CDHASH 24
FLOW_DIVERT_TLV_SIGNING_ID 25
FLOW_DIVERT_TLV_AGGREGATE_UNIT 26
FLOW_DIVERT_TLV_IS_FRAGMENT 27
FLOW_DIVERT_TLV_PREFIX_COUNT 28
FLOW_DIVERT_TLV_FLAGS 29
FLOW_DIVERT_TLV_FLOW_TYPE 30
FLOW_DIVERT_TLV_APP_DATA 31
FLOW_DIVERT_TLV_APP_AUDIT_TOKEN 32
FLOW_DIVERT_TLV_APP_REAL_SIGNING_ID 33
FLOW_DIVERT_TLV_APP_REAL_CDHASH 34
FLOW_DIVERT_TLV_APP_REAL_AUDIT_TOKEN 35
FLOW_DIVERT_TLV_CFIL_ID 36
FLOW_DIVERT_TLV_DATAGRAM_SIZE 37
FLOW_DIVERT_TLV_ORDER 38
FLOW_DIVERT_TLV_FLOW_STATE 39
FLOW_DIVERT_FLOW_TYPE_TCP 1
FLOW_DIVERT_FLOW_TYPE_UDP 3
FLOW_DIVERT_CHUNK_SIZE 65600
FLOW_DIVERT_TOKEN_GETOPT_MAX_SIZE 128
FLOW_DIVERT_TOKEN_FLAG_VALIDATED 0x0000001
FLOW_DIVERT_TOKEN_FLAG_TFO 0x0000002
FLOW_DIVERT_TOKEN_FLAG_MPTCP 0x0000004
FLOW_DIVERT_TOKEN_FLAG_BOUND 0x0000008
FLOW_DIVERT_GROUP_FLAG_NO_APP_MAP 0x0000001
FLOW_DIVERT_GROUP_FLAG_DEFUNCT 0x0000002
FLOW_DIVERT_IS_TRANSPARENT 0x80000000
FLOW_DIVERT_IN_PROCESS_UNIT 0x0FFFFFFF
FLOW_DIVERT_IN_PROCESS_UNIT_MIN 0x0000FFFF
FLOW_DIVERT_IN_PROCESS_UNIT_MAX 0xFFFFFFFF
_NETINET_ICMP6_H_ None
ICMPV6_PLD_MAXLEN 1232
icmp6_data32 icmp6_dataun.icmp6_un_data32
icmp6_data16 icmp6_dataun.icmp6_un_data16
icmp6_data8 icmp6_dataun.icmp6_un_data8
icmp6_pptr icmp6_data32[0]
icmp6_mtu icmp6_data32[0]
icmp6_id icmp6_data16[0]
icmp6_seq icmp6_data16[1]
icmp6_maxdelay icmp6_data16[0]
ICMP6_DST_UNREACH 1
ICMP6_PACKET_TOO_BIG 2
ICMP6_TIME_EXCEEDED 3
ICMP6_PARAM_PROB 4
ICMP6_ECHO_REQUEST 128
ICMP6_ECHO_REPLY 129
MLD_LISTENER_QUERY 130
MLD_LISTENER_REPORT 131
MLD_LISTENER_DONE 132
MLD_LISTENER_REDUCTION MLD_LISTENER_DONE
ICMP6_MEMBERSHIP_QUERY 130
ICMP6_MEMBERSHIP_REPORT 131
ICMP6_MEMBERSHIP_REDUCTION 132
ND_ROUTER_SOLICIT 133
ND_ROUTER_ADVERT 134
ND_NEIGHBOR_SOLICIT 135
ND_NEIGHBOR_ADVERT 136
ND_REDIRECT 137
ICMP6_ROUTER_RENUMBERING 138
ICMP6_WRUREQUEST 139
ICMP6_WRUREPLY 140
ICMP6_FQDN_QUERY 139
ICMP6_FQDN_REPLY 140
ICMP6_NI_QUERY 139
ICMP6_NI_REPLY 140
MLDV2_LISTENER_REPORT 143
MLD_MTRACE_RESP 200
MLD_MTRACE 201
ICMP6_MAXTYPE 201
ICMP6_DST_UNREACH_NOROUTE 0
ICMP6_DST_UNREACH_ADMIN 1
ICMP6_DST_UNREACH_NOTNEIGHBOR 2
ICMP6_DST_UNREACH_BEYONDSCOPE 2
ICMP6_DST_UNREACH_ADDR 3
ICMP6_DST_UNREACH_NOPORT 4
ICMP6_TIME_EXCEED_TRANSIT 0
ICMP6_TIME_EXCEED_REASSEMBLY 1
ICMP6_PARAMPROB_HEADER 0
ICMP6_PARAMPROB_NEXTHEADER 1
ICMP6_PARAMPROB_OPTION 2
ICMP6_PARAMPROB_FIRSTFRAG_INCOMP_HDR 3
ICMP6_INFOMSG_MASK 0x80
ICMP6_NI_SUBJ_IPV6 0
ICMP6_NI_SUBJ_FQDN 1
ICMP6_NI_SUBJ_IPV4 2
ICMP6_NI_SUCCESS 0
ICMP6_NI_REFUSED 1
ICMP6_NI_UNKNOWN 2
ICMP6_ROUTER_RENUMBERING_COMMAND 0
ICMP6_ROUTER_RENUMBERING_RESULT 1
ICMP6_ROUTER_RENUMBERING_SEQNUM_RESET 255
ND_REDIRECT_ONLINK 0
ND_REDIRECT_ROUTER 1
mld_type mld_icmp6_hdr.icmp6_type
mld_code mld_icmp6_hdr.icmp6_code
mld_cksum mld_icmp6_hdr.icmp6_cksum
mld_maxdelay mld_icmp6_hdr.icmp6_data16[0]
mld_reserved mld_icmp6_hdr.icmp6_data16[1]
mld_v2_reserved mld_icmp6_hdr.icmp6_data16[0]
mld_v2_numrecs mld_icmp6_hdr.icmp6_data16[1]
nd_rs_type nd_rs_hdr.icmp6_type
nd_rs_code nd_rs_hdr.icmp6_code
nd_rs_cksum nd_rs_hdr.icmp6_cksum
nd_rs_reserved nd_rs_hdr.icmp6_data32[0]
nd_ra_type nd_ra_hdr.icmp6_type
nd_ra_code nd_ra_hdr.icmp6_code
nd_ra_cksum nd_ra_hdr.icmp6_cksum
nd_ra_curhoplimit nd_ra_hdr.icmp6_data8[0]
nd_ra_flags_reserved nd_ra_hdr.icmp6_data8[1]
ND_RA_FLAG_MANAGED 0x80
ND_RA_FLAG_OTHER 0x40
ND_RA_FLAG_HA 0x20
ND_RA_FLAG_RTPREF_MASK 0x18
ND_RA_FLAG_RTPREF_HIGH 0x08
ND_RA_FLAG_RTPREF_MEDIUM 0x00
ND_RA_FLAG_RTPREF_LOW 0x18
ND_RA_FLAG_RTPREF_RSV 0x10
nd_ra_router_lifetime nd_ra_hdr.icmp6_data16[1]
nd_ns_type nd_ns_hdr.icmp6_type
nd_ns_code nd_ns_hdr.icmp6_code
nd_ns_cksum nd_ns_hdr.icmp6_cksum
nd_ns_reserved nd_ns_hdr.icmp6_data32[0]
nd_na_type nd_na_hdr.icmp6_type
nd_na_code nd_na_hdr.icmp6_code
nd_na_cksum nd_na_hdr.icmp6_cksum
nd_na_flags_reserved nd_na_hdr.icmp6_data32[0]
ND_NA_FLAG_ROUTER 0x80000000
ND_NA_FLAG_SOLICITED 0x40000000
ND_NA_FLAG_OVERRIDE 0x20000000
nd_rd_type nd_rd_hdr.icmp6_type
nd_rd_code nd_rd_hdr.icmp6_code
nd_rd_cksum nd_rd_hdr.icmp6_cksum
nd_rd_reserved nd_rd_hdr.icmp6_data32[0]
ND_OPT_SOURCE_LINKADDR 1
ND_OPT_TARGET_LINKADDR 2
ND_OPT_PREFIX_INFORMATION 3
ND_OPT_REDIRECTED_HEADER 4
ND_OPT_MTU 5
ND_OPT_NONCE 14
ND_OPT_PVD 21
ND_OPT_ROUTE_INFO 24
ND_OPT_RDNSS 25
ND_OPT_DNSSL 31
ND_OPT_CAPTIVE_PORTAL 37
ND_OPT_PREF64 38
ND_OPT_PI_FLAG_ONLINK 0x80
ND_OPT_PI_FLAG_AUTO 0x40
ND_OPT_PREF64_SCALED_LIFETIME_MASK 0xfff8
ND_OPT_PREF64_PLC_MASK 0x0007
ND_OPT_PREF64_LIFETIME_MAX 65528
ND_OPT_PREF64_PLC_32 5
ND_OPT_PREF64_PLC_40 4
ND_OPT_PREF64_PLC_48 3
ND_OPT_PREF64_PLC_56 2
ND_OPT_PREF64_PLC_64 1
ND_OPT_PREF64_PLC_96 0
ND_OPT_PVD_MIN_LENGTH offsetof(struct nd_opt_pvd, nd_opt_pvd_id)
ND_OPT_PVD_FLAGS_HTTP 0x80
ND_OPT_PVD_FLAGS_LEGACY 0x40
ND_OPT_PVD_FLAGS_RA 0x20
ND_OPT_PVD_DELAY_MASK 0x0f
ni_type icmp6_ni_hdr.icmp6_type
ni_code icmp6_ni_hdr.icmp6_code
ni_cksum icmp6_ni_hdr.icmp6_cksum
ni_qtype icmp6_ni_hdr.icmp6_data16[0]
ni_flags icmp6_ni_hdr.icmp6_data16[1]
NI_QTYPE_NOOP 0
NI_QTYPE_SUPTYPES 1
NI_QTYPE_FQDN 2
NI_QTYPE_DNSNAME 2
NI_QTYPE_NODEADDR 3
NI_QTYPE_IPV4ADDR 4
NI_SUPTYPE_FLAG_COMPRESS 0x1
NI_FQDN_FLAG_VALIDTTL 0x1
ICMP6_RR_FLAGS_TEST 0x80
ICMP6_RR_FLAGS_REQRESULT 0x40
ICMP6_RR_FLAGS_FORCEAPPLY 0x20
ICMP6_RR_FLAGS_SPECSITE 0x10
ICMP6_RR_FLAGS_PREVDONE 0x08
rr_type rr_hdr.icmp6_type
rr_code rr_hdr.icmp6_code
rr_cksum rr_hdr.icmp6_cksum
rr_seqnum rr_hdr.icmp6_data32[0]
RPM_PCO_ADD 1
RPM_PCO_CHANGE 2
RPM_PCO_SETGLOBAL 3
RPM_PCO_MAX 4
ICMP6_RR_PCOUSE_RAFLAGS_ONLINK 0x80
ICMP6_RR_PCOUSE_RAFLAGS_AUTO 0x40
ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME 0x80000000
ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME 0x40000000
ICMP6_RR_RESULT_FLAGS_OOB 0x0002
ICMP6_RR_RESULT_FLAGS_FORBIDDEN 0x0001
ICMP6_FILTER_SETPASSALL(filterp) memset(filterp, 0xff, sizeof(struct icmp6_filter))
ICMP6_FILTER_SETBLOCKALL(filterp) memset(filterp, 0x00, sizeof(struct icmp6_filter))
ICMP6_FILTER_SETPASS(type, filterp) 	(((filterp)->icmp6_filt[(type) >> 5]) |= (1u << ((type) & 31)))
ICMP6_FILTER_SETBLOCK(type, filterp) 	(((filterp)->icmp6_filt[(type) >> 5]) &= ~(1u << ((type) & 31)))
ICMP6_FILTER_WILLPASS(type, filterp) 	((((filterp)->icmp6_filt[(type) >> 5]) & (1u << ((type) & 31))) != 0)
ICMP6_FILTER_WILLBLOCK(type, filterp) 	((((filterp)->icmp6_filt[(type) >> 5]) & (1u << ((type) & 31))) == 0)
icp6s_odst_unreach_noroute icp6s_outerrhist.icp6errs_dst_unreach_noroute
icp6s_odst_unreach_admin icp6s_outerrhist.icp6errs_dst_unreach_admin
icp6s_odst_unreach_beyondscope icp6s_outerrhist.icp6errs_dst_unreach_beyondscope
icp6s_odst_unreach_addr icp6s_outerrhist.icp6errs_dst_unreach_addr
icp6s_odst_unreach_noport icp6s_outerrhist.icp6errs_dst_unreach_noport
icp6s_opacket_too_big icp6s_outerrhist.icp6errs_packet_too_big
icp6s_otime_exceed_transit icp6s_outerrhist.icp6errs_time_exceed_transit
icp6s_otime_exceed_reassembly icp6s_outerrhist.icp6errs_time_exceed_reassembly
icp6s_oparamprob_header icp6s_outerrhist.icp6errs_paramprob_header
icp6s_oparamprob_nextheader icp6s_outerrhist.icp6errs_paramprob_nextheader
icp6s_oparamprob_option icp6s_outerrhist.icp6errs_paramprob_option
icp6s_oredirect icp6s_outerrhist.icp6errs_redirect
icp6s_ounknown icp6s_outerrhist.icp6errs_unknown
ICMPV6CTL_STATS 1
ICMPV6CTL_REDIRACCEPT 2
ICMPV6CTL_REDIRTIMEOUT 3
ICMPV6CTL_ND6_PRUNE 6
ICMPV6CTL_ND6_DELAY 8
ICMPV6CTL_ND6_UMAXTRIES 9
ICMPV6CTL_ND6_MMAXTRIES 10
ICMPV6CTL_ND6_USELOOPBACK 11
ICMPV6CTL_NODEINFO 13
ICMPV6CTL_ERRPPSLIMIT 14
ICMPV6CTL_ND6_MAXNUDHINT 15
ICMPV6CTL_MTUDISC_HIWAT 16
ICMPV6CTL_MTUDISC_LOWAT 17
ICMPV6CTL_ND6_DEBUG 18
ICMPV6CTL_ND6_DRLIST 19
ICMPV6CTL_ND6_PRLIST 20
ICMPV6CTL_MLD_MAXSRCFILTER 21
ICMPV6CTL_MLD_SOMAXSRC 22
ICMPV6CTL_MLD_VERSION 23
ICMPV6CTL_ND6_MAXQLEN 24
ICMPV6CTL_ND6_ACCEPT_6TO4 25
ICMPV6CTL_ND6_OPTIMISTIC_DAD 26
ICMPV6CTL_ERRPPSLIMIT_RANDOM_INCR 27
ICMPV6CTL_MAXID 28
ICMPV6CTL_NAMES { 	{ 0, 0 }, 	{ 0, 0 }, 	{ "rediraccept", CTLTYPE_INT }, 	{ "redirtimeout", CTLTYPE_INT }, 	{ 0, 0 }, 	{ 0, 0 }, 	{ "nd6_prune", CTLTYPE_INT }, 	{ 0, 0 }, 	{ "nd6_delay", CTLTYPE_INT }, 	{ "nd6_umaxtries", CTLTYPE_INT }, 	{ "nd6_mmaxtries", CTLTYPE_INT }, 	{ "nd6_useloopback", CTLTYPE_INT }, 	{ 0, 0 }, 	{ "nodeinfo", CTLTYPE_INT }, 	{ "errppslimit", CTLTYPE_INT }, 	{ "nd6_maxnudhint", CTLTYPE_INT }, 	{ "mtudisc_hiwat", CTLTYPE_INT }, 	{ "mtudisc_lowat", CTLTYPE_INT }, 	{ "nd6_debug", CTLTYPE_INT }, 	{ 0, 0 }, 	{ 0, 0 }, 	{ 0, 0 }, 	{ 0, 0 }, 	{ 0, 0 }, 	{ 0, 0 }, 	{ "nd6_accept_6to4", CTLTYPE_INT }, 	{ "nd6_optimistic_dad", CTLTYPE_INT }, }
ICMP6_ERROR_RST_MRCVIF 0x1
icmp6_ifstat_inc(_ifp, _tag) do {                       	if (_ifp != NULL && IN6_IFEXTRA(_ifp) != NULL) {        	        IN6_IFEXTRA(_ifp)->icmp6_ifstat._tag++;         	}                                                       } while (0)
icmp6_ifoutstat_inc(ifp, type, code) do {               	icmp6_ifstat_inc(ifp, ifs6_out_msg);                    	if (type < ICMP6_INFOMSG_MASK)                          	        icmp6_ifstat_inc(ifp, ifs6_out_error);          	switch (type) {                                         	case ICMP6_DST_UNREACH:                                 	        icmp6_ifstat_inc(ifp, ifs6_out_dstunreach);     	        if (code == ICMP6_DST_UNREACH_ADMIN)            	                icmp6_ifstat_inc(ifp, ifs6_out_adminprohib);	         break;                                         	case ICMP6_PACKET_TOO_BIG:                              	        icmp6_ifstat_inc(ifp, ifs6_out_pkttoobig);      	        break;                                          	case ICMP6_TIME_EXCEEDED:                               	        icmp6_ifstat_inc(ifp, ifs6_out_timeexceed);     	        break;                                          	case ICMP6_PARAM_PROB:                                  	        icmp6_ifstat_inc(ifp, ifs6_out_paramprob);      	        break;                                          	case ICMP6_ECHO_REQUEST:                                	        icmp6_ifstat_inc(ifp, ifs6_out_echo);           	        break;                                          	case ICMP6_ECHO_REPLY:                                  	        icmp6_ifstat_inc(ifp, ifs6_out_echoreply);      	        break;                                          	case MLD_LISTENER_QUERY:                                	        icmp6_ifstat_inc(ifp, ifs6_out_mldquery);       	        break;                                          	case MLD_LISTENER_REPORT:                               	        icmp6_ifstat_inc(ifp, ifs6_out_mldreport);      	        break;                                          	case MLD_LISTENER_DONE:                                 	        icmp6_ifstat_inc(ifp, ifs6_out_mlddone);        	        break;                                          	case ND_ROUTER_SOLICIT:                                 	        icmp6_ifstat_inc(ifp, ifs6_out_routersolicit);  	        break;                                          	case ND_ROUTER_ADVERT:                                  	        icmp6_ifstat_inc(ifp, ifs6_out_routeradvert);   	        break;                                          	case ND_NEIGHBOR_SOLICIT:                               	        icmp6_ifstat_inc(ifp, ifs6_out_neighborsolicit);	        break;                                          	case ND_NEIGHBOR_ADVERT:                                	        icmp6_ifstat_inc(ifp, ifs6_out_neighboradvert); 	        break;                                          	case ND_REDIRECT:                                       	        icmp6_ifstat_inc(ifp, ifs6_out_redirect);       	        break;                                          	}                                                       } while (0)
ICMP6_REDIRACCEPT_DEFAULT 1
ICMP6_NODEINFO_FQDNOK 0x1
ICMP6_NODEINFO_NODEADDROK 0x2
ICMP6_NODEINFO_TMPADDROK 0x4
ICMP6_NODEINFO_GLOBALOK 0x8
_NETINET_ICMP_VAR_H_ None
ICMPCTL_MASKREPL 1
ICMPCTL_STATS 2
ICMPCTL_ICMPLIM 3
ICMPCTL_TIMESTAMP 4
ICMPCTL_ICMPLIM_INCR 5
ICMPCTL_MAXID 6
ICMPCTL_NAMES { 	{ 0, 0 }, 	{ "maskrepl", CTLTYPE_INT }, 	{ "stats", CTLTYPE_STRUCT }, 	{ "icmplim", CTLTYPE_INT }, 	{ "icmptimestamp", CTLTYPE_INT }, }
_NETINET_IF_ETHER_H_ None
ea_byte ether_addr_octet
ETHER_MAP_IP_MULTICAST(ipaddr, enaddr) 	 	 { 	(enaddr)[0] = 0x01; 	(enaddr)[1] = 0x00; 	(enaddr)[2] = 0x5e; 	(enaddr)[3] = ((const u_char *)ipaddr)[1] & 0x7f; 	(enaddr)[4] = ((const u_char *)ipaddr)[2]; 	(enaddr)[5] = ((const u_char *)ipaddr)[3]; }
ETHER_MAP_IPV6_MULTICAST(ip6addr, enaddr)                                                                                        {                                                                       	(enaddr)[0] = 0x33;                                             	(enaddr)[1] = 0x33;                                             	(enaddr)[2] = ((const u_char *)ip6addr)[12];                            	(enaddr)[3] = ((const u_char *)ip6addr)[13];                            	(enaddr)[4] = ((const u_char *)ip6addr)[14];                            	(enaddr)[5] = ((const u_char *)ip6addr)[15];                            }
arp_hrd ea_hdr.ar_hrd
arp_pro ea_hdr.ar_pro
arp_hln ea_hdr.ar_hln
arp_pln ea_hdr.ar_pln
arp_op ea_hdr.ar_op
SIN_PROXY 0x1
SIN_ROUTER 0x2
RTF_USETRAILERS RTF_PROTO1
RTF_ANNOUNCE RTF_PROTO2
_NET_IF_TUN_H_ None
TUN_OPEN 0x0001
TUN_INITED 0x0002
TUN_RCOLL 0x0004
TUN_IASET 0x0008
TUN_DSTADDR 0x0010
TUN_RWAIT 0x0040
TUN_ASYNC 0x0080
TUN_NBIO 0x0100
TUNSDEBUG _IOW('t', 90, int)
TUNGDEBUG _IOR('t', 89, int)
TUNMTU 1500
IGMP_LOCK() lck_mtx_lock(&igmp_mtx)
IGMP_LOCK_ASSERT_HELD() LCK_MTX_ASSERT(&igmp_mtx, LCK_MTX_ASSERT_OWNED)
IGMP_LOCK_ASSERT_NOTHELD() LCK_MTX_ASSERT(&igmp_mtx, LCK_MTX_ASSERT_NOTOWNED)
IGMP_UNLOCK() lck_mtx_unlock(&igmp_mtx)
IGMP_ADD_DETACHED_INM(_head, _inm) {                            	SLIST_INSERT_HEAD(_head, _inm, inm_dtle);                       }
IGMP_REMOVE_DETACHED_INM(_head) {                               	struct in_multi *_inm, *_inm_tmp;                               	SLIST_FOREACH_SAFE(_inm, _head, inm_dtle, _inm_tmp) {           	        SLIST_REMOVE(_head, _inm, in_multi, inm_dtle);          	        INM_REMREF(_inm);                                       	}                                                               	VERIFY(SLIST_EMPTY(_head));                                     }
vt_nrecs pkt_mpriv.__mpriv_u.__mpriv32[0].__mpriv32_u.__val16[0]
_NETINET_IGMP_H_ None
IGMP_MINLEN 8
IGMP_V3_QUERY_MINLEN 12
IGMP_V3_QUERY_MAX_SRCS 366
IGMP_GRPREC_HDRLEN 8
IGMP_V3_REPORT_MINLEN 8
IGMP_V3_REPORT_MAXRECS 65535
IGMP_HOST_MEMBERSHIP_QUERY 0x11
IGMP_v1_HOST_MEMBERSHIP_REPORT 0x12
IGMP_DVMRP 0x13
IGMP_PIM 0x14
IGMP_v2_HOST_MEMBERSHIP_REPORT 0x16
IGMP_HOST_LEAVE_MESSAGE 0x17
IGMP_MTRACE_REPLY 0x1e
IGMP_MTRACE_QUERY 0x1f
IGMP_v3_HOST_MEMBERSHIP_REPORT 0x22
IGMP_DO_NOTHING 0
IGMP_MODE_IS_INCLUDE 1
IGMP_MODE_IS_EXCLUDE 2
IGMP_CHANGE_TO_INCLUDE_MODE 3
IGMP_CHANGE_TO_EXCLUDE_MODE 4
IGMP_ALLOW_NEW_SOURCES 5
IGMP_BLOCK_OLD_SOURCES 6
IGMP_V3_GENERAL_QUERY 1
IGMP_V3_GROUP_QUERY 2
IGMP_V3_GROUP_SOURCE_QUERY 3
IGMP_V1V2_MAX_RI 10
IGMP_MAX_HOST_REPORT_DELAY IGMP_V1V2_MAX_RI
IGMP_TIMER_SCALE 10
_NETINET_IGMP_VAR_H_ None
IGPS_VERSION_3 3
IGPS_VERSION3_LEN 168
IGIF_SILENT 0x00000001
IGIF_LOOPBACK 0x00000002
IGMP_VERSION_NONE 0
IGMP_VERSION_1 1
IGMP_VERSION_2 2
IGMP_VERSION_3 3
IGMP_DEBUG 1
IGMP_PRINTF(x) do { if (igmp_debug) printf x; } while (0)
IGMP_INET_PRINTF(addr, x) do {                                  	if (igmp_debug) {                                               	        char _igmp_inet_buf[MAX_IPv4_STR_LEN];                  	        inet_ntop(AF_INET, &(addr), _igmp_inet_buf,             	            sizeof(_igmp_inet_buf));                            	        printf x;                                               	}                                                               } while (0)
OIGMPSTAT_ADD(name, val)        os_atomic_add(&igmpstat.name, (val), relaxed)
OIGMPSTAT_INC(name) OIGMPSTAT_ADD(name, 1)
IGMPSTAT_ADD(name, val)         os_atomic_add(&igmpstat_v3.name, (val), relaxed)
IGMPSTAT_INC(name) IGMPSTAT_ADD(name, 1)
IGMP_MAX_STATE_CHANGES 24
IGMP_NOT_MEMBER 0
IGMP_SILENT_MEMBER 1
IGMP_REPORTING_MEMBER 2
IGMP_IDLE_MEMBER 3
IGMP_LAZY_MEMBER 4
IGMP_SLEEPING_MEMBER 5
IGMP_AWAKENING_MEMBER 6
IGMP_G_QUERY_PENDING_MEMBER 7
IGMP_SG_QUERY_PENDING_MEMBER 8
IGMP_LEAVING_MEMBER 9
IGMP_RV_INIT 2
IGMP_RV_MIN 1
IGMP_RV_MAX 7
IGMP_QI_INIT 125
IGMP_QI_MIN 1
IGMP_QI_MAX 255
IGMP_QRI_INIT 10
IGMP_QRI_MIN 1
IGMP_QRI_MAX 255
IGMP_URI_INIT 3
IGMP_URI_MIN 0
IGMP_URI_MAX 10
IGMP_MAX_G_GS_PACKETS 8
IGMP_MAX_STATE_CHANGE_PACKETS 8
IGMP_MAX_RESPONSE_PACKETS 16
IGMP_MAX_RESPONSE_BURST 4
IGMP_RESPONSE_BURST_INTERVAL 1
M_IGMPV2 M_PROTO1
M_IGMPV3_HDR M_PROTO2
M_GROUPREC M_PROTO3
M_IGMP_LOOP M_LOOP
RAOPT_LEN 4
IGI_LOCK_ASSERT_HELD(_igi) LCK_MTX_ASSERT(&(_igi)->igi_lock, LCK_MTX_ASSERT_OWNED)
IGI_LOCK_ASSERT_NOTHELD(_igi) LCK_MTX_ASSERT(&(_igi)->igi_lock, LCK_MTX_ASSERT_NOTOWNED)
IGI_LOCK(_igi) lck_mtx_lock(&(_igi)->igi_lock)
IGI_LOCK_SPIN(_igi) lck_mtx_lock_spin(&(_igi)->igi_lock)
IGI_CONVERT_LOCK(_igi) do {                                     	IGI_LOCK_ASSERT_HELD(_igi);                                     	lck_mtx_convert_spin(&(_igi)->igi_lock);                        } while (0)
IGI_UNLOCK(_igi) lck_mtx_unlock(&(_igi)->igi_lock)
IGI_ADDREF(_igi) igi_addref(_igi, 0)
IGI_ADDREF_LOCKED(_igi) igi_addref(_igi, 1)
IGI_REMREF(_igi) igi_remref(_igi)
IGMPCTL_STATS 1
IGMPCTL_MAXID 2
IGMPCTL_NAMES { 	{ 0, 0 }, 	{ "stats", CTLTYPE_STRUCT }, }
IA_HASH_INIT(ia) {                                      	(ia)->ia_hash.tqe_next = __unsafe_forge_single(void *, ~(uintptr_t)0); 	(ia)->ia_hash.tqe_prev = __unsafe_forge_single(void *, ~(uintptr_t)0); }
_NETINET_IN_H_ None
IPPROTO_IP 0
IPPROTO_ICMP 1
IPPROTO_TCP 6
IPPROTO_UDP 17
IPPROTO_IPV6 41
IPPROTO_RAW 255
__DARWIN_IPPORT_RESERVED 1024
IN_ARE_ADDR_EQUAL(a, b)     (bcmp(&(a)->s_addr, &(b)->s_addr, 	sizeof (struct in_addr)) == 0)
INET_ADDRSTRLEN 16
__KAME_NETINET_IN_H_INCLUDED_ None
MAX_IPv4_STR_LEN 16
MAX_IPv6_STR_LEN 64
_NETINET_INP_LOG_H_ None
LLINFO_RTRFAIL_EVTSENT 0x1
LLINFO_PROBING 0x2
ARP_PROBE_TIME 7
ARP_UNICAST_LIMIT 3
BDG_MEMBER_MATCHES_ARP(addr, ifp, ia)                                	(ia->ia_ifp->if_bridge == ifp->if_softc &&                           	bcmp(IF_LLADDR(ia->ia_ifp), IF_LLADDR(ifp), ifp->if_addrlen) == 0 && 	addr == ia->ia_addr.sin_addr.s_addr)
_NETINET_IN_ARP_H_ None
inet_arp_lookup arp_lookup_ip
inet_arp_handle_input arp_ip_handle_input
inet_arp_init_ifaddr arp_ifinit
_IP_VHL None
REDUCE16 {                                                        	q_util.q = sum;                                                   	l_util.l = q_util.s[0] + q_util.s[1] + q_util.s[2] + q_util.s[3]; 	sum = l_util.s[0] + l_util.s[1];                                  	ADDCARRY(sum);                                                    }
_NETINET_IN_GIF_H_ None
GIF_TTL 30
INM_TRACE_HIST_SIZE 32
INPCB_GCREQ_THRESHOLD 50000
DBG_FNC_PCB_LOOKUP NETDBG_CODE(DBG_NETTCP, (6 << 8))
DBG_FNC_PCB_HLOOKUP NETDBG_CODE(DBG_NETTCP, ((6 << 8) | 1))
RANGECHK(var, min, max) 	if ((var) < (min)) { (var) = (min); } 	else if ((var) > (max)) { (var) = (max); }
apn_fallbk_log(x) do { if (apn_fallbk_debug >= 1) log x; } while (0)
INPFC_SOLOCKED 0x1
INPFC_REMOVE 0x2
INP_ALIGN_AND_CAST(_type, _ptr) ({                                	typeof((_type)(void *__header_bidi_indexable)NULL) __roundup_type;	const volatile char *__roundup_align_ptr = (const volatile char *)(_ptr); 	__roundup_align_ptr += P2ROUNDUP((uintptr_t)__roundup_align_ptr,  	                                 _Alignof(typeof(*__roundup_type))) - (uintptr_t)__roundup_align_ptr; 	__DEQUALIFY(_type, __roundup_align_ptr);                          })
APN_FALLBACK_NOTIF_INTERVAL 2
_NETINET_IN_PCB_H_ None
IFNET_COUNT_TYPE(_ifp) IFNET_IS_CELLULAR(_ifp) ? stats_functional_type_cell:           	IFNET_IS_WIFI(_ifp) ?     stats_functional_type_wifi:           	IFNET_IS_WIRED(_ifp) ?    stats_functional_type_wired:          	IFNET_IS_COMPANION_LINK_BLUETOOTH(_ifp)? stats_functional_type_bluetooth: stats_functional_type_none;
INP_ADD_STAT(_inp, _stats_functional_type, _a, _n)          do {                                                                	locked_add_64(&((_inp)->inp_stat->_a), (_n));                       switch(_stats_functional_type) {                                	        case stats_functional_type_cell:                            	            locked_add_64(&((_inp)->inp_cstat->_a), (_n));          	            break;                                                  	        case stats_functional_type_wifi:                            	            locked_add_64(&((_inp)->inp_wstat->_a), (_n));          	            break;                                                  	        case stats_functional_type_wired:                           	            locked_add_64(&((_inp)->inp_Wstat->_a), (_n));          	            break;                                                  	        case stats_functional_type_bluetooth:                       	            locked_add_64(&((_inp)->inp_btstat->_a), (_n));         	            break;                                                  	        default:                                                    	            break;                                                  	};                                                              } while (0);
_INPCB_PTR(x) u_int32_t
_INPCB_LIST_ENTRY(x) struct _inpcb_list_entry
INP_IPV4 0x1
INP_IPV6 0x2
INP_V4MAPPEDV6 0x4
inp_faddr inp_dependfaddr.inp46_foreign.ia46_addr4
inp_laddr inp_dependladdr.inp46_local.ia46_addr4
in6p_faddr inp_dependfaddr.inp6_foreign
in6p_laddr inp_dependladdr.inp6_local
inp_route inp_dependroute.inp4_route
inp_ip_tos inp_depend4.inp4_ip_tos
inp_options inp_depend4.inp4_options
inp_moptions inp_depend4.inp4_moptions
in6p_route inp_dependroute.inp6_route
in6p_ip6_hlim inp_depend6.inp6_hlim
in6p_hops inp_depend6.inp6_hops
in6p_ip6_nxt inp_ip_p
in6p_vflag inp_vflag
in6p_options inp_depend6.inp6_options
in6p_outputopts inp_depend6.inp6_outputopts
in6p_moptions inp_depend6.inp6_moptions
in6p_icmp6filt inp_depend6.inp6_icmp6filt
in6p_cksum inp_depend6.inp6_cksum
in6p_ifindex inp_depend6.inp6_ifindex
in6p_flags inp_flags
in6p_flags2 inp_flags2
in6p_socket inp_socket
in6p_lport inp_lport
in6p_fport inp_fport
in6p_ppcb inp_ppcb
in6p_state inp_state
in6p_wantcnt inp_wantcnt
in6p_last_outifp inp_last_outifp
in6pcb inpcb
INP_INC_IFNET_STAT(_inp_, _stat_) { 	if ((_inp_)->inp_last_outifp != NULL) { 	        if ((_inp_)->inp_vflag & INP_IPV6) { 	                (_inp_)->inp_last_outifp->if_ipv6_stat->_stat_++;	        } else { 	                (_inp_)->inp_last_outifp->if_ipv4_stat->_stat_++;	        }	}}
INPCBINFO_UPDATE_MSS 0x1
INPCBINFO_HANDLE_LQM_ABORT 0x2
INP_PCBHASH(faddr, lport, fport, mask) 	(((faddr) ^ ((faddr) >> 16) ^ ntohs((lport) ^ (fport))) & (mask))
INP_PCBPORTHASH(lport, mask) 	(ntohs((lport)) & (mask))
INP_RECVOPTS 0x00000001
INP_RECVRETOPTS 0x00000002
INP_RECVDSTADDR 0x00000004
INP_HDRINCL 0x00000008
INP_HIGHPORT 0x00000010
INP_LOWPORT 0x00000020
INP_ANONPORT 0x00000040
INP_RECVIF 0x00000080
INP_MTUDISC 0x00000100
INP_STRIPHDR 0x00000200
INP_RECV_ANYIF 0x00000400
INP_INADDR_ANY 0x00000800
INP_IN6ADDR_ANY INP_INADDR_ANY
INP_RECVTTL 0x00001000
INP_UDP_NOCKSUM 0x00002000
INP_BOUND_IF 0x00004000
IN6P_IPV6_V6ONLY 0x00008000
IN6P_PKTINFO 0x00010000
IN6P_HOPLIMIT 0x00020000
IN6P_HOPOPTS 0x00040000
IN6P_DSTOPTS 0x00080000
IN6P_RTHDR 0x00100000
IN6P_RTHDRDSTOPTS 0x00200000
IN6P_TCLASS 0x00400000
INP_RECVTOS IN6P_TCLASS
IN6P_AUTOFLOWLABEL 0x00800000
IN6P_BINDV6ONLY 0x01000000
IN6P_RFC2292 0x02000000
IN6P_MTU 0x04000000
INP_PKTINFO 0x08000000
INP_FLOW_SUSPENDED 0x10000000
INP_NO_IFT_CELLULAR 0x20000000
INP_FLOW_CONTROLLED 0x40000000
INP_FC_FEEDBACK 0x80000000
INP2_TIMEWAIT 0x00000001
INP2_IN_FCTREE 0x00000002
INP2_WANT_APP_POLICY 0x00000004
INP2_NO_IFF_EXPENSIVE 0x00000008
INP2_INHASHLIST 0x00000010
INP2_AWDL_UNRESTRICTED 0x00000020
INP2_KEEPALIVE_OFFLOAD 0x00000040
INP2_INTCOPROC_ALLOWED 0x00000080
INP2_CONNECT_IN_PROGRESS 0x00000100
INP2_CLAT46_FLOW 0x00000200
INP2_EXTERNAL_PORT 0x00000400
INP2_NO_IFF_CONSTRAINED 0x00000800
INP2_DONTFRAG 0x00001000
INP2_SCOPED_BY_NECP 0x00002000
INP2_LOGGING_ENABLED 0x00004000
INP2_LOGGED_SUMMARY 0x00008000
INP2_MANAGEMENT_ALLOWED 0x00010000
INP2_MANAGEMENT_CHECKED 0x00020000
INP2_BIND_IN_PROGRESS 0x00040000
INP2_LAST_ROUTE_LOCAL 0x00080000
INP2_ULTRA_CONSTRAINED_ALLOWED 0x00100000
INP2_ULTRA_CONSTRAINED_CHECKED 0x00200000
INPLOOKUP_WILDCARD 1
sotoin6pcb(so) sotoinpcb(so)
UDP_RANDOM_PORT_RESERVE 4096
INPCB_STATE_INUSE 0x1
INPCB_STATE_CACHED 0x2
INPCB_STATE_DEAD 0x3
WNT_STOPUSING 0xffff
WNT_ACQUIRE 0x1
WNT_RELEASE 0x2
INPCB_OPPORTUNISTIC_THROTTLEON 0x0001
INPCB_OPPORTUNISTIC_SETCMD 0x0002
ROUNDUP64(x) P2ROUNDUP((x), sizeof (u_int64_t))
ADVANCE64(p, n) (void*)((char *)(p) + ROUNDUP64(n))
_NETINET_IN_PRIVATE_H_ None
sin_scope_id un._in_index.ifscope
__KAME_NETINET_IN_PRIVATE_H_INCLUDED_ None
_DSCP_DF 0
_DSCP_CS0 0
_DSCP_CS1 8
_DSCP_CS2 16
_DSCP_CS3 24
_DSCP_CS4 32
_DSCP_CS5 40
_DSCP_CS6 48
_DSCP_CS7 56
_DSCP_EF 46
_DSCP_VA 44
_DSCP_AF11 10
_DSCP_AF12 12
_DSCP_AF13 14
_DSCP_AF21 18
_DSCP_AF22 20
_DSCP_AF23 22
_DSCP_AF31 26
_DSCP_AF32 28
_DSCP_AF33 30
_DSCP_AF41 34
_DSCP_AF42 36
_DSCP_AF43 38
_DSCP_52 52
_MAX_DSCP 63
in_cksum(_m, _l)                            inet_cksum(_m, 0, 0, _l)
in_cksum_buffer(_b, _l)                     inet_cksum_buffer(_b, 0, 0, _l)
ip_cksum_hdr_in(_m, _l)                     ip_cksum_hdr_dir(_m, _l, 0)
ip_cksum_hdr_out(_m, _l)                    ip_cksum_hdr_dir(_m, _l, 1)
in_cksum_offset(_m, _o)             ((void) in_finalize_cksum(_m, _o, CSUM_DELAY_IP))
in_delayed_cksum_offset(_m, _o)     ((void) in_finalize_cksum(_m, _o, CSUM_DELAY_DATA))
in_hosteq(s, t) ((s).s_addr == (t).s_addr)
satosin(sa) SIN(sa)
IPTOS_MASK 0xFF
RTQ_TIMEOUT 60*10
IN_STAT_ACTIVITY_GRANULARITY 8
IN_STAT_ACTIVITY_TIME_SEC_SHIFT 3
__NETINET_IN_STAT_H__ None
_NETINET_IN_SYSTM_H_ None
TCP_BG_SWITCH_TIME 2
RETURN_USE_BK 1
RETURN_USE_DEFAULT 0
__NETINET_IN_TCLASS_H__ None
SO_TCDBG_PID 0x01
SO_TCDBG_PNAME 0x02
SO_TCDBG_PURGE 0x04
SO_TCDBG_FLUSH 0x08
SO_TCDBG_COUNT 0x10
SO_TCDBG_LIST 0x20
SO_TCDBG_DELETE 0x40
SO_TCDBG_TCFLUSH_PID 0x80
QOS_MODE_MARKING_POLICY_DEFAULT 0
QOS_MODE_MARKING_POLICY_ENABLE 1
QOS_MODE_MARKING_POLICY_DISABLE 2
NET_QOS_MARKING_POLICY_DEFAULT QOS_MODE_MARKING_POLICY_DEFAULT
NET_QOS_MARKING_POLICY_ENABLE QOS_MODE_MARKING_POLICY_ENABLE
NET_QOS_MARKING_POLICY_DISABLE QOS_MODE_MARKING_POLICY_DISABLE
_NETINET_IN_VAR_H_ None
ia_ifp ia_ifa.ifa_ifp
ia_flags ia_ifa.ifa_flags
ia_broadaddr ia_dstaddr
ifra_dstaddr ifra_broadaddr
IN_LNAOF(in, ifa) 	(ntohl((in).s_addr) & ~(IA((ifa))->ia_subnetmask))
INADDR_HASH(x) inaddr_hashlookup(x)
INADDR_TO_IFP(addr, ifp)                                        	                                      	                                        {                                                                       	struct in_ifaddr *ia;                                                                                                                   	lck_rw_lock_shared(&in_ifaddr_rwlock);                          	TAILQ_FOREACH(ia, INADDR_HASH((addr).s_addr), ia_hash) {        	        IFA_LOCK_SPIN(&ia->ia_ifa);                             	        if (IA_SIN(ia)->sin_addr.s_addr == (addr).s_addr) {     	                IFA_UNLOCK(&ia->ia_ifa);                        	                break;                                          	        }                                                       	        IFA_UNLOCK(&ia->ia_ifa);                                	}                                                               	(ifp) = (ia == NULL) ? NULL : ia->ia_ifp;                       	lck_rw_done(&in_ifaddr_rwlock);                                 }
IFP_TO_IA(ifp, ia)                                              	                                        	                                     {                                                                       	lck_rw_lock_shared(&in_ifaddr_rwlock);                          	for ((ia) = TAILQ_FIRST(&in_ifaddrhead);                        	    (ia) != NULL && (ia)->ia_ifp != (ifp);                      	    (ia) = TAILQ_NEXT((ia), ia_link))                           	        continue;                                               	if ((ia) != NULL)                                               	        ifa_addref(&(ia)->ia_ifa);                              	lck_rw_done(&in_ifaddr_rwlock);                                 }
INM_LOCK_ASSERT_HELD(_inm) LCK_MTX_ASSERT(&(_inm)->inm_lock, LCK_MTX_ASSERT_OWNED)
INM_LOCK_ASSERT_NOTHELD(_inm) LCK_MTX_ASSERT(&(_inm)->inm_lock, LCK_MTX_ASSERT_NOTOWNED)
INM_LOCK(_inm) lck_mtx_lock(&(_inm)->inm_lock)
INM_LOCK_SPIN(_inm) lck_mtx_lock_spin(&(_inm)->inm_lock)
INM_CONVERT_LOCK(_inm) do {                                     	INM_LOCK_ASSERT_HELD(_inm);                                     	lck_mtx_convert_spin(&(_inm)->inm_lock);                        } while (0)
INM_UNLOCK(_inm) lck_mtx_unlock(&(_inm)->inm_lock)
INM_ADDREF(_inm) inm_addref(_inm, 0)
INM_ADDREF_LOCKED(_inm) inm_addref(_inm, 1)
INM_REMREF(_inm) inm_remref(_inm, 0)
INM_REMREF_LOCKED(_inm) inm_remref(_inm, 1)
IN_LOOKUP_MULTI(addr, ifp, inm)                                 	                                     	                                        	                                     do {                                                                    	struct in_multistep _step;                                      	IN_FIRST_MULTI(_step, inm);                                     	while ((inm) != NULL) {                                         	        INM_LOCK_SPIN(inm);                                     	        if ((inm)->inm_ifp == (ifp) &&                          	            (inm)->inm_addr.s_addr == (addr)->s_addr) {         	                INM_ADDREF_LOCKED(inm);                         	                INM_UNLOCK(inm);                                	                break;                                          	        }                                                       	        INM_UNLOCK(inm);                                        	        IN_NEXT_MULTI(_step, inm);                              	}                                                               } while (0)
IN_NEXT_MULTI(step, inm)                                        	                                	                                     do {                                                                    	in_multihead_lock_assert(LCK_RW_ASSERT_HELD);                   	if (((inm) = (step).i_inm) != NULL)                             	        (step).i_inm = LIST_NEXT((step).i_inm, inm_link);       } while (0)
IN_FIRST_MULTI(step, inm)                                       	                                 	                                     do {                                                                    	in_multihead_lock_assert(LCK_RW_ASSERT_HELD);                   	(step).i_inm = LIST_FIRST(&in_multihead);                       	IN_NEXT_MULTI((step), (inm));                                   } while (0)
MCAST_PASS 0
MCAST_NOTGMEMBER 1
MCAST_NOTSMEMBER 2
MCAST_MUTED 3
_NETINET_IP_H_ None
IPVERSION 4
IP_RF 0x8000
IP_DF 0x4000
IP_MF 0x2000
IP_OFFMASK 0x1fff
IP_MAXPACKET 65535
IPTOS_LOWDELAY 0x10
IPTOS_THROUGHPUT 0x08
IPTOS_RELIABILITY 0x04
IPTOS_MINCOST 0x02
IPTOS_CE 0x01
IPTOS_ECT 0x02
IPTOS_DSCP_SHIFT 2
IPTOS_ECN_NOTECT 0x00
IPTOS_ECN_ECT1 0x01
IPTOS_ECN_ECT0 0x02
IPTOS_ECN_CE 0x03
IPTOS_ECN_MASK 0x03
IPTOS_PREC_NETCONTROL 0xe0
IPTOS_PREC_INTERNETCONTROL 0xc0
IPTOS_PREC_CRITIC_ECP 0xa0
IPTOS_PREC_FLASHOVERRIDE 0x80
IPTOS_PREC_FLASH 0x60
IPTOS_PREC_IMMEDIATE 0x40
IPTOS_PREC_PRIORITY 0x20
IPTOS_PREC_ROUTINE 0x00
IP_TCLASS_BE 0x00
IP_TCLASS_BK 0x20
IP_TCLASS_VI 0x80
IP_TCLASS_VO 0xc0
IPOPT_CONTROL 0x00
IPOPT_RESERVED1 0x20
IPOPT_DEBMEAS 0x40
IPOPT_RESERVED2 0x60
IPOPT_EOL 0
IPOPT_NOP 1
IPOPT_RR 7
IPOPT_TS 68
IPOPT_SECURITY 130
IPOPT_LSRR 131
IPOPT_SATID 136
IPOPT_SSRR 137
IPOPT_RA 148
IPOPT_OPTVAL 0
IPOPT_OLEN 1
IPOPT_OFFSET 2
IPOPT_MINOFF 4
IPOPT_TS_TSONLY 0
IPOPT_TS_TSANDADDR 1
IPOPT_TS_PRESPEC 3
IPOPT_SECUR_UNCLASS 0x0000
IPOPT_SECUR_CONFID 0xf135
IPOPT_SECUR_EFTO 0x789a
IPOPT_SECUR_MMMM 0xbc4d
IPOPT_SECUR_RESTR 0xaf13
IPOPT_SECUR_SECRET 0xd788
IPOPT_SECUR_TOPSECRET 0x6bc5
MAXTTL 255
IPDEFTTL 64
IPFRAGTTL 30
IPTTLDEC 1
IP_MSS 576
_NETINET_IP6_H_ None
ip6_vfc ip6_ctlun.ip6_un2_vfc
ip6_flow ip6_ctlun.ip6_un1.ip6_un1_flow
ip6_plen ip6_ctlun.ip6_un1.ip6_un1_plen
ip6_nxt ip6_ctlun.ip6_un1.ip6_un1_nxt
ip6_hlim ip6_ctlun.ip6_un1.ip6_un1_hlim
ip6_hops ip6_ctlun.ip6_un1.ip6_un1_hlim
IPV6_VERSION 0x60
IPV6_VERSION_MASK 0xf0
IPV6_FLOWINFO_MASK 0x0fffffff
IPV6_FLOWLABEL_MASK 0x000fffff
IPV6_FLOW_ECN_MASK 0x00300000
IP6TOS_CE 0x01
IP6TOS_ECT 0x02
IP6FLOW_DSCP_MASK 0x0fc00000
IP6FLOW_DSCP_SHIFT 22
IP6OPT_PAD1 0x00
IP6OPT_PADN 0x01
IP6OPT_JUMBO 0xC2
IP6OPT_NSAP_ADDR 0xC3
IP6OPT_TUNNEL_LIMIT 0x04
IP6OPT_ROUTER_ALERT 0x05
IP6OPT_RTALERT_LEN 4
IP6OPT_RTALERT_MLD 0
IP6OPT_RTALERT_RSVP 1
IP6OPT_RTALERT_ACTNET 2
IP6OPT_MINLEN 2
IP6OPT_EID 0x8a
IP6OPT_TYPE_SKIP 0x00
IP6OPT_TYPE_DISCARD 0x40
IP6OPT_TYPE_FORCEICMP 0x80
IP6OPT_TYPE_ICMP 0xC0
IP6OPT_MUTABLE 0x20
IP6OPT_JUMBO_LEN 6
IP6_ALERT_MLD 0x0000
IP6_ALERT_RSVP 0x0001
IP6_ALERT_AN 0x0002
IP6F_OFF_MASK 0xfff8
IP6F_RESERVED_MASK 0x0006
IP6F_MORE_FRAG 0x0001
IPV6_MAXHLIM 255
IPV6_DEFHLIM 64
IPV6_FRAGTTL 60
IPV6_HLIMDEC 1
IPV6_MMTU 1280
IPV6_MAXPACKET 65535
IPV6_MAXOPTHDR 2048
IP6_EXTHDR_CHECK(m, off, hlen, action)                          do {                                                                        if ((m)->m_next != NULL) {                                          	if (((m)->m_flags & M_LOOP) &&                                  	    ((m)->m_len < (off) + (hlen)) &&                            	    (((m) = m_pullup((m), (off) + (hlen))) == NULL)) {          	        ip6stat.ip6s_exthdrtoolong++;                           	        action;                                                 	} else if ((m)->m_flags & M_EXT) {                              	        if ((m)->m_len < (off) + (hlen)) {                      	                ip6stat.ip6s_exthdrtoolong++;                   	                m_freem(m);                                     	                (m) = NULL;                                     	                action;                                         	        }                                                       	} else {                                                        	        if ((m)->m_len < (off) + (hlen)) {                      	                ip6stat.ip6s_exthdrtoolong++;                   	                m_freem(m);                                     	                (m) = NULL;                                     	                action;                                         	        }                                                       	}                                                                   } else {                                                            	if ((m)->m_len < (off) + (hlen)) {                              	        ip6stat.ip6s_tooshort++;                                	        in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_truncated);   	        m_freem(m);                                             	        (m) = NULL;                                             	        action;                                                 	}                                                                   }                                                                   } while (0)
IP6_EXTHDR_GET(val, typ, m, off, len)                           	M_STRUCT_GET(val, typ, m, off, len)
IP6_EXTHDR_GET0(val, typ, m, off, len)                          	M_STRUCT_GET0(val, typ, m, off, len)
DUMMYNET_DEBUG 0
HASHSIZE 16
DPRINTF(X) if (dummynet_debug) printf X
IP_DN_DBG_LOG(fmt, ...) os_log_error(OS_LOG_DEFAULT, "ip_dn_debug %s:%d : " fmt "\n", __func__, __LINE__, ## __VA_ARGS__)
IP_DN_ERR_LOG(fmt, ...) os_log_error(OS_LOG_DEFAULT, fmt, ## __VA_ARGS__)
HEAP_SWAP(a, b, buffer) { buffer = a ; a = b ; b = buffer ; }
HEAP_INCREMENT 15
GET_OFFSET(heap, obj, obj_size) dn_heap_get_node_offset((heap), (obj), (obj_size))
SET_OFFSET(heap, node) dn_heap_update_node_offset((heap), (node), (node))
RESET_OFFSET(heap, node) dn_heap_update_node_offset((heap), (node), DN_INVALID_OFFSET)
SET_TICKS(_m, q, p)         ((_m)->m_pkthdr.len*8*(hz*10) - (q)->numbytes + p->bandwidth - 1 ) / 	    p->bandwidth ;
DN_FREE_PKT(_m) do {                                                  	struct m_tag *tag = m_tag_locate(                                         	    (_m), KERNEL_MODULE_TAG_ID, KERNEL_TAG_TYPE_DUMMYNET);                	if (tag) {                                                                	    VERIFY(sizeof(struct dn_pkt_tag) <= tag->m_tag_len);                  	    struct dn_pkt_tag *n = (struct dn_pkt_tag *)(tag->m_tag_data);        	    ROUTE_RELEASE(&n->dn_ro);                                             	}                                                                         	m_tag_delete((_m), tag);                                                  	m_freem((_m));                                                            } while (0)
DUMMYNET_EVENT_TO_STRING(type) case type: return #type;
_IP_DUMMYNET_H None
APPLY_MASK(addr, mask)                              (addr)->__u6_addr.__u6_addr32[0] &= (mask)->__u6_addr.__u6_addr32[0];     (addr)->__u6_addr.__u6_addr32[1] &= (mask)->__u6_addr.__u6_addr32[1];     (addr)->__u6_addr.__u6_addr32[2] &= (mask)->__u6_addr.__u6_addr32[2];     (addr)->__u6_addr.__u6_addr32[3] &= (mask)->__u6_addr.__u6_addr32[3];
DN_KEY_LT(a, b)     ((int64_t)((a)-(b)) < 0)
DN_KEY_LEQ(a, b)    ((int64_t)((a)-(b)) <= 0)
DN_KEY_GT(a, b)     ((int64_t)((a)-(b)) > 0)
DN_KEY_GEQ(a, b)    ((int64_t)((a)-(b)) >= 0)
MAX64(x, y)  (( (int64_t) ( (y)-(x) )) > 0 ) ? (y) : (x)
MY_M 16
DN_MAX_HASH_SIZE 65536
DN_TO_IP_OUT 1
DN_TO_IP_IN 2
DN_TO_BDG_FWD 3
DN_TO_IP6_IN 4
DN_TO_IP6_OUT 5
dn_dst dn_dst_._dn_dst
dn_dst6 dn_dst_._dn_dst6
dn_ro dn_ro_._dn_ro
dn_ro6 dn_ro_._dn_ro6
dn_ipoa dn_ipoa_._dn_ipoa
dn_ip6oa dn_ipoa_._dn_ip6oa
DN_HAVE_FLOW_MASK 0x0001
DN_IS_RED 0x0002
DN_IS_GENTLE_RED 0x0004
DN_QSIZE_IS_BYTES 0x0008
DN_NOERROR 0x0010
DN_IS_PIPE 0x4000
DN_IS_QUEUE 0x8000
SCALE_RED 16
SCALE_MUL(x, y)          ( ( (x) * (y) ) >> SCALE_RED )
DN_HAVE_FLOW_MASK 0x0001
DN_IS_RED 0x0002
DN_IS_GENTLE_RED 0x0004
DN_QSIZE_IS_BYTES 0x0008
DN_NOERROR 0x0010
DN_IS_PIPE 0x4000
DN_IS_QUEUE 0x8000
SCALE_RED 16
SCALE_MUL(x, y)          ( ( (x) * (y) ) >> SCALE_RED )
DN_HAVE_FLOW_MASK 0x0001
DN_IS_RED 0x0002
DN_IS_GENTLE_RED 0x0004
DN_QSIZE_IS_BYTES 0x0008
DN_NOERROR 0x0010
DN_IS_PIPE 0x4000
DN_IS_QUEUE 0x8000
SCALE_RED 16
SCALE_MUL(x, y)          ( ( (x) * (y) ) >> SCALE_RED )
dn_event_pipe_config dn_event._dnev_pipe_config
dn_event_rule_config dn_event._dnev_rule_config
ECN_NORMAL 1
ECN_COMPATIBILITY 0
_NETINET_IP_ENCAP_H_ None
__IP_FLOWID_H__ None
fwa_ipoa fwa_ipoa_._fwa_ipoa
fwa_ip6oa fwa_ipoa_._fwa_ip6oa
fwa_ro fwa_ro_._fwa_ro
fwa_ro6 fwa_ro_._fwa_ro6
fwa_dst fwa_dst_._fwa_dst
fwa_dst6 fwa_dst_._fwa_dst6
_IP_VHL None
_NETINET_IP_ICMP_H_ None
icmp_pptr icmp_hun.ih_pptr
icmp_gwaddr icmp_hun.ih_gwaddr
icmp_id icmp_hun.ih_idseq.icd_id
icmp_seq icmp_hun.ih_idseq.icd_seq
icmp_void icmp_hun.ih_void
icmp_pmvoid icmp_hun.ih_pmtu.ipm_void
icmp_nextmtu icmp_hun.ih_pmtu.ipm_nextmtu
icmp_num_addrs icmp_hun.ih_rtradv.irt_num_addrs
icmp_wpa icmp_hun.ih_rtradv.irt_wpa
icmp_lifetime icmp_hun.ih_rtradv.irt_lifetime
icmp_otime icmp_dun.id_ts.its_otime
icmp_rtime icmp_dun.id_ts.its_rtime
icmp_ttime icmp_dun.id_ts.its_ttime
icmp_ip icmp_dun.id_ip.idi_ip
icmp_radv icmp_dun.id_radv
icmp_mask icmp_dun.id_mask
icmp_data icmp_dun.id_data
ICMP_MINLEN 8
ICMP_MASKLEN 12
ICMP_ECHOREPLY 0
ICMP_UNREACH 3
ICMP_UNREACH_NET 0
ICMP_UNREACH_HOST 1
ICMP_UNREACH_PROTOCOL 2
ICMP_UNREACH_PORT 3
ICMP_UNREACH_NEEDFRAG 4
ICMP_UNREACH_SRCFAIL 5
ICMP_UNREACH_NET_UNKNOWN 6
ICMP_UNREACH_HOST_UNKNOWN 7
ICMP_UNREACH_ISOLATED 8
ICMP_UNREACH_NET_PROHIB 9
ICMP_UNREACH_HOST_PROHIB 10
ICMP_UNREACH_TOSNET 11
ICMP_UNREACH_TOSHOST 12
ICMP_UNREACH_FILTER_PROHIB 13
ICMP_UNREACH_HOST_PRECEDENCE 14
ICMP_UNREACH_PRECEDENCE_CUTOFF 15
ICMP_SOURCEQUENCH 4
ICMP_REDIRECT 5
ICMP_REDIRECT_NET 0
ICMP_REDIRECT_HOST 1
ICMP_REDIRECT_TOSNET 2
ICMP_REDIRECT_TOSHOST 3
ICMP_ALTHOSTADDR 6
ICMP_ECHO 8
ICMP_ROUTERADVERT 9
ICMP_ROUTERADVERT_NORMAL 0
ICMP_ROUTERADVERT_NOROUTE_COMMON 16
ICMP_ROUTERSOLICIT 10
ICMP_TIMXCEED 11
ICMP_TIMXCEED_INTRANS 0
ICMP_TIMXCEED_REASS 1
ICMP_PARAMPROB 12
ICMP_PARAMPROB_ERRATPTR 0
ICMP_PARAMPROB_OPTABSENT 1
ICMP_PARAMPROB_LENGTH 2
ICMP_TSTAMP 13
ICMP_TSTAMPREPLY 14
ICMP_IREQ 15
ICMP_IREQREPLY 16
ICMP_MASKREQ 17
ICMP_MASKREPLY 18
ICMP_TRACEROUTE 30
ICMP_DATACONVERR 31
ICMP_MOBILE_REDIRECT 32
ICMP_IPV6_WHEREAREYOU 33
ICMP_IPV6_IAMHERE 34
ICMP_MOBILE_REGREQUEST 35
ICMP_MOBILE_REGREPLY 36
ICMP_SKIP 39
ICMP_PHOTURIS 40
ICMP_PHOTURIS_UNKNOWN_INDEX 1
ICMP_PHOTURIS_AUTH_FAILED 2
ICMP_PHOTURIS_DECRYPT_FAILED 3
ICMP_MAXTYPE 40
_IP_VHL None
DBG_LAYER_BEG NETDBG_CODE(DBG_NETIP, 0)
DBG_LAYER_END NETDBG_CODE(DBG_NETIP, 2)
DBG_FNC_IP_INPUT NETDBG_CODE(DBG_NETIP, (2 << 8))
IPREASS_NHASH_LOG2 6
IPREASS_HASH(x, y) 	(((((x) & 0xF) | ((((x) >> 8) & 0xF) << 4)) ^ (y)) & IPREASS_HMASK)
IP_CHECKINTERFACE_WEAK_ES 0
IP_CHECKINTERFACE_HYBRID_ES 1
IP_CHECKINTERFACE_STRONG_ES 2
INADDR_NHASH 61
IP_HDR_ALIGNMENT_FIXUP(_m, _ifp, _action) do { } while (0)
PKTTBL_SZ 7
INA struct in_ifaddr *
_IP_VHL None
DBG_LAYER_BEG NETDBG_CODE(DBG_NETIP, 1)
DBG_LAYER_END NETDBG_CODE(DBG_NETIP, 3)
DBG_FNC_IP_OUTPUT NETDBG_CODE(DBG_NETIP, (1 << 8) | 1)
DBG_FNC_IPSEC4_OUTPUT NETDBG_CODE(DBG_NETIP, (2 << 8) | 1)
IMO_TRACE_HIST_SIZE 32
IMO_ZONE_NAME "ip_moptions"
ipsec_state ipobz.ipsec_state
necp_route ipobz.necp_route
sro_fwd ipobz.sro_fwd
saved_route ipobz.saved_route
ipf_pktopts ipobz.ipf_pktopts
IP_CHECK_RESTRICTIONS(_ifp, _ipobf)                                 	(((_ipobf).nocell && IFNET_IS_CELLULAR(_ifp)) ||                    	 ((_ipobf).noexpensive && IFNET_IS_EXPENSIVE(_ifp)) ||              	 ((_ipobf).noconstrained && IFNET_IS_CONSTRAINED(_ifp)) ||          	  (IFNET_IS_INTCOPROC(_ifp)) ||                                     	 (!(_ipobf).management_allowed && IFNET_IS_MANAGEMENT(_ifp)) ||     	 (!(_ipobf).ultra_constrained_allowed && IFNET_IS_ULTRA_CONSTRAINED(_ifp)) || 	 (!(_ipobf).awdl_unrestricted && IFNET_IS_AWDL_RESTRICTED(_ifp)))
OPTSET(bit) do {                                                	if (optval) {                                                   	    inp->inp_flags |= bit;                                      	} else {                                                        	    inp->inp_flags &= ~bit;                                     	}                                                               } while (0)
OPTSET2(bit) do {                                               	if (optval) {                                                   	    inp->inp_flags2 |= bit;                                     	} else {                                                        	    inp->inp_flags2 &= ~bit;                                    	}                                                               } while (0)
_NETINET_IP_VAR_H_ None
MAX_IPOPTLEN 40
IMO_LOCK_ASSERT_HELD(_imo) LCK_MTX_ASSERT(&(_imo)->imo_lock, LCK_MTX_ASSERT_OWNED)
IMO_LOCK_ASSERT_NOTHELD(_imo) LCK_MTX_ASSERT(&(_imo)->imo_lock, LCK_MTX_ASSERT_NOTOWNED)
IMO_LOCK(_imo) lck_mtx_lock(&(_imo)->imo_lock)
IMO_LOCK_SPIN(_imo) lck_mtx_lock_spin(&(_imo)->imo_lock)
IMO_CONVERT_LOCK(_imo) do {                                     	IMO_LOCK_ASSERT_HELD(_imo);                                     	lck_mtx_convert_spin(&(_imo)->imo_lock);                        } while (0)
IMO_UNLOCK(_imo) lck_mtx_unlock(&(_imo)->imo_lock)
IMO_ADDREF(_imo) imo_addref(_imo, 0)
IMO_ADDREF_LOCKED(_imo) imo_addref(_imo, 1)
IMO_REMREF(_imo) imo_remref(_imo)
IMO_PURGE_LOCKED(_imo) do {                                 	IMO_LOCK_ASSERT_HELD((_imo));                                   	for (int i = 0; i < (_imo)->imo_num_memberships; ++i) {         	        struct in_mfilter *imf;                                 	        struct in_multi   *imn;                                 	        imf = (_imo)->imo_mfilters != NULL                      	            ? &(_imo)->imo_mfilters[i]                          	            : NULL;                                             	        if (imf != NULL) {                                      	            imf_leave(imf);                                     	        }                                                       	        imn = (_imo)->imo_membership[i];                        	        (_imo)->imo_membership[i] = NULL;                       	        if (imn != NULL) {                                      	            (void) in_leavegroup(imn, imf);                     	        }                                                       	        if (imf != NULL) {                                      	            imf_purge(imf);                                     	        }                                                       	                if (imn != NULL) {                              	            INM_REMREF(imn);                                    	        }                                                       	}                                                               	(_imo)->imo_num_memberships = 0;                                } while (0)
IP_FORWARDING 0x1
IP_RAWOUTPUT 0x2
IP_NOIPSEC 0x4
IP_ROUTETOIF SO_DONTROUTE
IP_ALLOWBROADCAST SO_BROADCAST
IP_OUTARGS 0x100
IP_HDR_STRICT_ALIGNMENT_CHECK(_ip) do { } while (0)
IPOAF_SELECT_SRCIF 0x00000001
IPOAF_BOUND_IF 0x00000002
IPOAF_BOUND_SRCADDR 0x00000004
IPOAF_NO_CELLULAR 0x00000010
IPOAF_NO_EXPENSIVE 0x00000020
IPOAF_AWDL_UNRESTRICTED 0x00000040
IPOAF_QOSMARKING_ALLOWED 0x00000080
IPOAF_NO_CONSTRAINED 0x00000400
IPOAF_REDO_QOSMARKING_POLICY 0x00002000
IPOAF_R_IFDENIED 0x00004000
IPOAF_MANAGEMENT_ALLOWED 0x00008000
IPOAF_ULTRA_CONSTRAINED_ALLOWED 0x00010000
_NETINET_ISAKMP_H_ None
ISAKMP_VERS_MAJOR 0xf0
ISAKMP_VERS_MAJOR_SHIFT 4
ISAKMP_VERS_MINOR 0x0f
ISAKMP_VERS_MINOR_SHIFT 0
_IP_VHL None
__KPI_IPFILTER__ None
IPPOF_MCAST_OPTS 0x1
IPPOF_BOUND_IF 0x2
IPPOF_NO_IFT_CELLULAR 0x4
IPPOF_SELECT_SRCIF 0x8
IPPOF_BOUND_SRCADDR 0x10
IPPOF_SHIFT_IFSCOPE 16
IPPOF_NO_IFF_EXPENSIVE 0x20
IPPOF_NO_IFF_CONSTRAINED 0x40
ipf_addv4(filter, filter_ref)     ipf_addv4_internal((filter), (filter_ref))
ipf_addv6(filter, filter_ref)     ipf_addv6_internal((filter), (filter_ref))
__KPI_IPFILTER_VAR__ None
IPFF_INTERNAL 0x1
DUMP_BUF_CHK() {        	clen -= k;                  if (clen < 1)           	    goto done;              c += k;                 }
_NETINET_MPTCP_H_ None
MPO_CAPABLE 0x0
MPO_JOIN 0x1
MPO_DSS 0x2
MPO_ADD_ADDR 0x3
MPO_REMOVE_ADDR 0x4
MPO_PRIO 0x5
MPO_FAIL 0x6
MPO_FASTCLOSE 0x7
MPTCP_VERSION_0 0x0
MPTCP_VERSION_1 0x1
MPCAP_PROPOSAL_SBIT 0x01
MPCAP_GBIT 0x02
MPCAP_FBIT 0x04
MPCAP_EBIT 0x08
MPCAP_DBIT 0x10
MPCAP_UNICAST_IPBIT 0x20
MPCAP_BBIT 0x40
MPCAP_CHECKSUM_CBIT 0x80
MPTCP_BACKUP 0x1
MPTCP_BACKUP 0x1
MDSS_A 0x01
MDSS_a 0x02
MDSS_M 0x04
MDSS_m 0x08
MDSS_F 0x10
MPTCP_V0_ADD_ADDR_IPV4 4
MPTCP_V0_ADD_ADDR_IPV6 6
MPTCP_V1_ADD_ADDR_ECHO 0x1
MPTCP_V0_ADD_ADDR_OPT_LEN_V4 8
MPTCP_V0_ADD_ADDR_OPT_LEN_V6 20
MPTCP_V1_ADD_ADDR_OPT_LEN_V4 16
MPTCP_V1_ADD_ADDR_OPT_LEN_V6 28
MPTCP_V1_ADD_ADDR_ECHO_OPT_LEN_V4 8
MPTCP_V1_ADD_ADDR_ECHO_OPT_LEN_V6 20
MPTCP_MPPRIO_BKP 0x1
CHECK_OPTLEN {                                                                   	if (MAX_TCPOPTLEN - optlen < dssoptlen) {                                         	        os_log_error(mptcp_log_handle, "%s: dssoptlen %d optlen %d \n", __func__,   	            dssoptlen, optlen);                                                     	            goto ret_optlen;                                                        	}                                                                                   }
DO_FIN(dsn_opt) {                                               	int sndfin = 0;                                                 	sndfin = mptcp_ok_to_fin(tp, dsn_opt.mdss_dsn, len);            	if (sndfin) {                                                   	        dsn_opt.mdss_copt.mdss_flags |= MDSS_F;                 	        dsn_opt.mdss_data_len += 1;                             	        if (do_csum)                                            	                dss_csum = in_addword(dss_csum, 1);             	}                                                               }
CHECK_DATALEN {                                                             	                              	if ((len + optlen + dssoptlen) > tp->t_maxopd) {                            	        os_log_error(mptcp_log_handle, "%s: nosp %d len %d opt %d %d %d\n", 	            __func__, len, dssoptlen, optlen,                               	            tp->t_maxseg, tp->t_maxopd);                                    	                         	        len = tp->t_maxopd - optlen - dssoptlen;                            	}                                                                           }
VERBOSE_OPTION_PARSING_LOGGING 0
MPTCP_OPT_CHECK_UNDERRUN(shadow_opt, optlen)  do {                                  	if (__improbable(sizeof((shadow_opt)) < (optlen))) {                                    	        size_t ignored = (optlen) - sizeof((shadow_opt));                               	        os_log(mptcp_log_handle,                                                        	                "%s - option length exceeds the size of underlying storage "            	                "(optlen=%lu, storage size=%lu) %lu bytes will be ignored\n",           	                __func__, (size_t)(optlen), sizeof((shadow_opt)), ignored);             	}                                                                                       } while(0)
MPTCP_OPT_REPORT_COPY(shadow_opt, available)  do {                                  	os_log(mptcp_log_handle,                                                                	        "%s - insufficent input to use cast-parsing (required=%lu; available=%ld); "    	        " option data will be copied to local storage\n",                               	                __func__, sizeof((shadow_opt)), available);                                                                                                                         } while(0)
MPTCP_OPT_GET(shadow_opt, optp, optend, optlen)   ({                                	__typeof__((shadow_opt)) * __single opt_ptr;                                                                                                                                        	ptrdiff_t available = (optend) - (optp);                                                                                                                                                MPTCP_OPT_CHECK_UNDERRUN(shadow_opt, optlen);                                                                                                                                       	if (__improbable(available < sizeof((shadow_opt)))) {                                   	        MPTCP_OPT_REPORT_COPY(shadow_opt, available);                                   	        memset((caddr_t)&(shadow_opt) + available,                                      	                0, sizeof((shadow_opt)) - available);                                   	        memcpy(&(shadow_opt), (optp), available);                                       	        opt_ptr = &(shadow_opt);                                                        	} else {                                                                                	        opt_ptr = __unsafe_forge_single(__typeof__((shadow_opt))*, (optp));             	}                                                                                       	opt_ptr;                                                                                })
MPTCP_JOPT_ERROR_PATH(tp) {                                     	tcpstat.tcps_invalid_joins++;                                   	if (tp->t_inpcb->inp_socket != NULL) {                          	        soevent(tp->t_inpcb->inp_socket,                        	            SO_FILT_HINT_LOCKED | SO_FILT_HINT_MUSTRST);        	}                                                               }
MPTCP_DSS_OPT_SZ_CHK(len, expected_len) {                                 	if (len != expected_len) {                                                	        os_log_error(mptcp_log_handle, "%s - %lx: bad len = %d dss: %x\n",	            __func__, (unsigned long)VM_KERNEL_ADDRPERM(mp_tp->mpt_mpte), 	            len, dss_rsp->mdss_flags);                                    	        return;                                                           	}                                                                         }
_NETINET_MPTCP_OPT_H_ None
_NETINET_MPTCP_SEQ_H_ None
MPTCP_SEQ_LT(a, b)      ((int64_t)((a) - (b)) < 0)
MPTCP_SEQ_LEQ(a, b)     ((int64_t)((a) - (b)) <= 0)
MPTCP_SEQ_GT(a, b)      ((int64_t)((a) - (b)) > 0)
MPTCP_SEQ_GEQ(a, b)     ((int64_t)((a) - (b)) >= 0)
MPTCP_COMPUTE_LEN {                             	mss_lower = sizeof (struct mptcp_dss_ack_opt);  	if (mp_tp->mpt_flags & MPTCPF_CHECKSUM)         	        mss_lower += 2;                         	else                                            	   	        mss_lower += 2;                         }
_NETINET_MPTCP_TIMER_H_ None
_NETINET_MPTCP_VAR_H_ None
MPTCP_MAX_NUM_SUBFLOWS 256
mpte_src mpte_u_src._mpte_src
__mpte_src_v4 mpte_u_src._mpte_src_v4
__mpte_src_v6 mpte_u_src._mpte_src_v6
mpte_dst mpte_u_dst._mpte_dst
__mpte_dst_v4 mpte_u_dst._mpte_dst_v4
__mpte_dst_v6 mpte_u_dst._mpte_dst_v6
MPTE_SND_REM_ADDR 0x01
MPTE_SVCTYPE_CHECKED 0x02
MPTE_FIRSTPARTY 0x04
MPTE_ACCESS_GRANTED 0x08
MPTE_FORCE_ENABLE 0x10
MPTE_IN_WORKLOOP 0x20
MPTE_WORKLOOP_RELAUNCH 0x40
MPTE_UNICAST_IP 0x80
MPTE_CELL_PROHIBITED 0x100
MPTE_FORCE_V0 0x200
MPTE_FORCE_V1 0x400
MPTE_ITFINFO_INIT 0x800
MPTE_ITFINFO_SIZE 4
MPOF_ATTACHED 0x1
MPOF_SUBFLOW_OK 0x2
MPOF_INTERIM 0x4
mpts_dst mpts_u_dst._mpts_dst
__mpts_dst_v4 mpts_u_dst._mpts_dst_v4
__mpts_dst_v6 mpts_u_dst._mpts_dst_v6
MPTSF_CONNECTING 0x00000002
MPTSF_CONNECT_PENDING 0x00000004
MPTSF_CONNECTED 0x00000008
MPTSF_DISCONNECTING 0x00000010
MPTSF_DISCONNECTED 0x00000020
MPTSF_MP_CAPABLE 0x00000040
MPTSF_MP_READY 0x00000080
MPTSF_MP_DEGRADED 0x00000100
MPTSF_PREFERRED 0x00000200
MPTSF_SOPT_OLDVAL 0x00000400
MPTSF_SOPT_INPROG 0x00000800
MPTSF_FAILINGOVER 0x00001000
MPTSF_ACTIVE 0x00002000
MPTSF_MPCAP_CTRSET 0x00004000
MPTSF_CLOSED 0x00008000
MPTSF_TFO_REQD 0x00010000
MPTSF_CLOSE_REQD 0x00020000
MPTSF_INITIAL_SUB 0x00040000
MPTSF_READ_STALL 0x00080000
MPTSF_WRITE_STALL 0x00100000
MPTSF_FULLY_ESTABLISHED 0x00200000
MPTSF_CELLICON_SET 0x00400000
MPTCPF_CHECKSUM 0x001
MPTCPF_FALLBACK_TO_TCP 0x002
MPTCPF_JOIN_READY 0x004
MPTCPF_RECVD_MPFAIL 0x008
MPTCPF_SND_64BITDSN 0x010
MPTCPF_SND_64BITACK 0x020
MPTCPF_RCVD_64BITACK 0x040
MPTCPF_POST_FALLBACK_SYNC 0x080
MPTCPF_FALLBACK_HEURISTIC 0x100
MPTCPF_HEURISTIC_TRAC 0x200
MPTCPF_REASS_INPROG 0x400
MPTT_REXMT 0x01
MPTT_TW 0x02
MPTT_FASTCLOSE 0x04
MPCE_CLOSE 0x1
MPCE_RECV_DATA_ACK 0x2
MPCE_RECV_DATA_FIN 0x4
HMAC_TRUNCATED_SYNACK 8
HMAC_TRUNCATED_ACK 20
HMAC_TRUNCATED_ADD_ADDR 8
MPTCP_EXTEND_DSN(x, y, z) {                                     	if ((MPTCP_DATASEQ_LOW32(x) > y) &&                             	    ((((u_int32_t)MPTCP_DATASEQ_LOW32(x)) - (u_int32_t)y) >=    	    (u_int32_t)(1U << 31))) {                                    	                                                             	        z = MPTCP_DATASEQ_HIGH32(x) + 0x100000000;              	        z |= y;                                                 	} else if ((MPTCP_DATASEQ_LOW32(x) < y) &&                      	    (((u_int32_t)y -                                            	    ((u_int32_t)MPTCP_DATASEQ_LOW32(x))) >=                     	    (u_int32_t)(1U << 31))) {                                    	                                                             	        z = MPTCP_DATASEQ_HIGH32(x) - 0x100000000;              	        z |= y;                                                 	} else {                                                        	        z = MPTCP_DATASEQ_HIGH32(x) | y;                        	}                                                               }
MPTCP_SUBOUT_PROBING 0x01
MPTCP_KERN_CTL_NAME "com.apple.network.advisory"
SYMPTOMS_ADVISORY_NOCOMMENT 0x0000
SYMPTOMS_ADVISORY_USEAPP 0xFFFF
SYMPTOMS_ADVISORY_WIFI_BAD 0x01
SYMPTOMS_ADVISORY_WIFI_OK 0x02
SYMPTOMS_ADVISORY_CELL_BAD 0x01
SYMPTOMS_ADVISORY_CELL_OK 0x02
MPTCP_TARGET_BASED_RSSI_THRESHOLD -75
MPTCP_SYMPTOMS_ASK_UUID 1
MPTCP_SYMPTOMS_UNKNOWN 0
MPTCP_SYMPTOMS_BACKGROUND 1
MPTCP_SYMPTOMS_FOREGROUND 2
_NETINET_MP_PCB_H_ None
MPP_ATTACHED 0x001
MPP_INSIDE_OUTPUT 0x002
MPP_INSIDE_INPUT 0x004
MPP_INPUT_HANDLE 0x008
MPP_WUPCALL 0x010
MPP_SHOULD_WORKLOOP 0x020
MPP_SHOULD_RWAKEUP 0x040
MPP_SHOULD_WWAKEUP 0x080
MPP_CREATE_SUBFLOWS 0x100
MPP_INSIDE_SETGETOPT 0x200
_IP_VHL None
RIPSNDQ 8192
RIPRCVQ 8192
_NETINET_TCP_H_ None
TCP_NODELAY 0x01
_NETINET_TCPIP_H_ None
ti_x1 ti_i.ih_x1
ti_pr ti_i.ih_pr
ti_len ti_i.ih_len
ti_src ti_i.ih_src
ti_dst ti_i.ih_dst
ti_sport ti_t.th_sport
ti_dport ti_t.th_dport
ti_seq ti_t.th_seq
ti_ack ti_t.th_ack
ti_x2 ti_t.th_x2
ti_off ti_t.th_off
ti_flags ti_t.th_flags
ti_win ti_t.th_win
ti_sum ti_t.th_sum
ti_urp ti_t.th_urp
th_val_start th_tfo_data_loss
MPTCP_VERSION_SUPPORTED 1
MPTCP_VERSION_UNSUPPORTED -1
MPTCP_VERSION_SUPPORTED_UNKNOWN 0
TCP_CACHE_BUCKET_SIZE 5
TCP_CACHE_OVERFLOW_PROTECT 9
TFO_MAX_COOKIE_LOSS 2
ECN_MAX_SYN_LOSS 2
MPTCP_MAX_SYN_LOSS 2
MPTCP_SUCCESS_TRIGGER 10
MPTCP_VERSION_MAX_FAIL 2
ECN_MAX_DROPRST 1
ECN_MAX_DROPRXMT 4
ECN_MAX_SYNRST 4
TCPCACHE_F_TFO_REQ 0x01
TCPCACHE_F_TFO_DATA 0x02
TCPCACHE_F_ECN 0x04
TCPCACHE_F_MPTCP 0x08
TCPCACHE_F_ECN_DROPRST 0x10
TCPCACHE_F_ECN_DROPRXMT 0x20
TCPCACHE_F_TFO_REQ_RST 0x40
TCPCACHE_F_TFO_DATA_RST 0x80
TCPCACHE_F_ECN_SYNRST 0x100
ECN_RETRY_LIMIT 9
TCP_CACHE_INC_IFNET_STAT(_ifp_, _af_, _stat_) { 	if ((_ifp_) != NULL) { 	        if ((_af_) == AF_INET6) { 	                (_ifp_)->if_ipv6_stat->_stat_++;	        } else { 	                (_ifp_)->if_ipv4_stat->_stat_++;	        }	}}
_NETINET_TCP_CACHE_H None
ECN_MIN_CE_PROBES 10
ECN_MAX_CE_RATIO 7
SET_SNDSB_IDEAL_SIZE(sndsb, size) 	sndsb->sb_idealsize = min(max(tcp_sendspace, tp->snd_ssthresh), 	tcp_autosndbuf_max);
_NETINET_CC_H_ None
TCP_CC_ALGO_NONE 0
TCP_CC_ALGO_NEWRENO_INDEX 1
TCP_CC_ALGO_BACKGROUND_INDEX 2
TCP_CC_ALGO_CUBIC_INDEX 3
TCP_CC_ALGO_PRAGUE_INDEX 4
TCP_CC_ALGO_COUNT 5
TCP_CC_EVENT_LIST X(TCP_CC_CWND_INIT)                     	X(TCP_CC_INSEQ_ACK_RCVD)                	X(TCP_CC_ACK_RCVD)                      	X(TCP_CC_ENTER_FASTRECOVERY)            	X(TCP_CC_IN_FASTRECOVERY)               	X(TCP_CC_EXIT_FASTRECOVERY)             	X(TCP_CC_PARTIAL_ACK)                   	X(TCP_CC_IDLE_TIMEOUT)                  	X(TCP_CC_REXMT_TIMEOUT)                 	X(TCP_CC_ECN_RCVD)                      	X(TCP_CC_BAD_REXMT_RECOVERY)            	X(TCP_CC_OUTPUT_ERROR)                  	X(TCP_CC_CHANGE_ALGO)                   	X(TCP_CC_FLOW_CONTROL)                  	X(TCP_CC_SUSPEND)                       	X(TCP_CC_LIMITED_TRANSMIT)              	X(TCP_CC_EARLY_RETRANSMIT)              	X(TCP_CC_TLP_RECOVERY)                  	X(TCP_CC_TLP_RECOVER_LASTPACKET)        	X(TCP_CC_DELAY_FASTRECOVERY)            	X(TCP_CC_TLP_IN_FASTRECOVERY)           	X(TCP_CC_DSACK_BAD_REXMT)               	X(TCP_CC_FIRST_REXMT)                   	X(MAX_TCP_CC_EVENTS)
X(name, ...) name,
TCP_CC_CONTROL_NAME "com.apple.network.tcp_ccdebug"
TCP_CA_NAME_MAX 16
TCP_CC_CWND_INIT_PKTS 10
TCP_CC_CWND_INIT_BYTES 4380
TCP_CCDBG_NOUNIT 0xffffffff
_NETINET_TCP_FSM_H_ None
TCP_NSTATES 11
TCPS_CLOSED 0
TCPS_LISTEN 1
TCPS_SYN_SENT 2
TCPS_SYN_RECEIVED 3
TCPS_ESTABLISHED 4
TCPS_CLOSE_WAIT 5
TCPS_FIN_WAIT_1 6
TCPS_CLOSING 7
TCPS_LAST_ACK 8
TCPS_FIN_WAIT_2 9
TCPS_TIME_WAIT 10
TCP6_NSTATES TCP_NSTATES
TCP6S_CLOSED TCPS_CLOSED
TCP6S_LISTEN TCPS_LISTEN
TCP6S_SYN_SENT TCPS_SYN_SENT
TCP6S_SYN_RECEIVED TCPS_SYN_RECEIVED
TCP6S_ESTABLISHED TCPS_ESTABLISHED
TCP6S_CLOSE_WAIT TCPS_CLOSE_WAIT
TCP6S_FIN_WAIT_1 TCPS_FIN_WAIT_1
TCP6S_CLOSING TCPS_CLOSING
TCP6S_LAST_ACK TCPS_LAST_ACK
TCP6S_FIN_WAIT_2 TCPS_FIN_WAIT_2
TCP6S_TIME_WAIT TCPS_TIME_WAIT
_NETINET_TCP_INCLUDES_H_ None
DBG_LAYER_BEG NETDBG_CODE(DBG_NETTCP, 0)
DBG_LAYER_END NETDBG_CODE(DBG_NETTCP, 2)
DBG_FNC_TCP_INPUT NETDBG_CODE(DBG_NETTCP, (3 << 8))
DBG_FNC_TCP_NEWCONN NETDBG_CODE(DBG_NETTCP, (7 << 8))
TCP_STRETCHACK_ENABLE_PKTCNT 2000
tcb6 tcb
TCPTV_RCVNOTS_QUANTUM 100
TCP_RCVNOTS_BYTELEVEL 204800
TCP_EARLY_REXMT_LIMIT 10
DELAY_ACK(tp, th) 	(CC_ALGO(tp)->delay_ack != NULL && CC_ALGO(tp)->delay_ack(tp, th))
TCP_INC_VAR(stat, npkts) do {                   	        stat += npkts;                          } while (0)
DUMP_BUF_CHK() {        	clen -= k;              	if (clen < 1)           	        goto done;      	c += k;                 }
TCPSTATES None
X(name, value, description, ...) #description ":" #value " "
TCP_LOG_RATE_LIMIT 1000
TCP_LOG_RATE_DURATION 60
TCP_LOG_COMMON_FMT "[%s:%u<->%s:%u] " 	    "interface: %s " 	    "(skipped: %lu)\n"
TCP_LOG_COMMON_ARGS laddr_buf, ntohs(local_port), faddr_buf, ntohs(foreign_port), 	    ifp != NULL ? if_name(ifp) : "", 	    tcp_log_rate_exceeded_total
TCP_LOG_COMMON_PCB_FMT TCP_LOG_COMMON_FMT 	"so_gencnt: %llu " 	"t_state: %s " 	"process: %s:%u "
TCP_LOG_COMMON_PCB_ARGS TCP_LOG_COMMON_ARGS, 	so != NULL ? so->so_gencnt : 0, 	tcpstates[tp->t_state], 	inp->inp_last_proc_name, so->last_pid
P_MS(ms, shift) ((ms) >> (shift)), (((ms) * 1000) >> (shift)) % 1000
TCP_LOG_CONNECT_FMT "tcp %s: " 	    TCP_LOG_COMMON_PCB_FMT 	    "SYN in/out: %u/%u " 	    "bytes in/out: %llu/%llu " 	    "pkts in/out: %llu/%llu " 	    "rtt: %u.%u ms " 	    "rttvar: %u.%u ms " 	    "base_rtt: %u ms " 	    "error: %d " 	    "so_error: %d " 	    "svc/tc: %u " 	    "flow: 0x%x"
TCP_LOG_CONNECT_ARGS event, 	    TCP_LOG_COMMON_PCB_ARGS, 	    tp->t_syn_rcvd, tp->t_syn_sent, 	    inp->inp_stat->rxbytes, inp->inp_stat->txbytes, 	    inp->inp_stat->rxpackets, inp->inp_stat->txpackets, 	    P_MS(tp->t_srtt, TCP_RTT_SHIFT), 	    P_MS(tp->t_rttvar, TCP_RTTVAR_SHIFT), 	    get_base_rtt(tp), 	    error, 	    so->so_error, 	    (so->so_flags1 & SOF1_TC_NET_SERV_TYPE) ? so->so_netsvctype : so->so_traffic_class, 	    inp->inp_flowhash
TCP_LOG_CONN_Q_FMT "so_qlimit: %d "	"so_qlen: %d "	"so_incqlen: %d "
TCP_LOG_CONN_Q_ARGS so->so_head->so_qlimit, 	so->so_head->so_qlen, 	so->so_head->so_incqlen
TCP_LOG_LISTEN_FMT "tcp listen: " 	    TCP_LOG_COMMON_PCB_FMT 	    "so_qlimit: %d "	    "error: %d " 	    "so_error: %d " 	    "svc/tc: %u"
TCP_LOG_LISTEN_ARGS TCP_LOG_COMMON_PCB_ARGS, 	    so->so_qlimit, 	    error, 	    so->so_error, 	    (so->so_flags1 & SOF1_TC_NET_SERV_TYPE) ? so->so_netsvctype : so->so_traffic_class
ECN_STATE_TO_STRING(_s, _str) 	case tcp_connection_client_accurate_ecn_##_s: { 	        return _str; 	}
ECN_STATE_TO_STRING(_s, _str) 	case tcp_connection_server_accurate_ecn_##_s: { 	        return _str; 	}
TCP_LOG_CONNECTION_SUMMARY_FMT "tcp_connection_summary (%s:%d)" 	    TCP_LOG_COMMON_PCB_FMT 	    "Duration: %u.%03u sec " 	    "Conn_Time: %u.%03u sec " 	    "bytes in/out: %llu/%llu " 	    "pkts in/out: %llu/%llu " 	    "pkt rxmit: %u " 	    "ooo pkts: %u dup bytes in: %u ACKs delayed: %u delayed ACKs sent: %u\n" 	    "rtt: %u.%03u ms "  	    "rttvar: %u.%03u ms " 	    "base rtt: %u ms " 	    "so_error: %d " 	    "svc/tc: %u " 	    "flow: 0x%x"
TCP_LOG_CONNECTION_SUMMARY_ARGS func_name, line_no, 	    TCP_LOG_COMMON_PCB_ARGS,  	    duration / TCP_RETRANSHZ, duration % TCP_RETRANSHZ, 	    conntime / TCP_RETRANSHZ, conntime % TCP_RETRANSHZ,  	    inp->inp_stat->rxbytes, inp->inp_stat->txbytes, 	    inp->inp_stat->rxpackets, inp->inp_stat->txpackets, 	    tp->t_stat.rxmitpkts, 	    tp->t_rcvoopack, tp->t_stat.rxduplicatebytes, tp->t_stat.acks_delayed, tp->t_stat.delayed_acks_sent, 	    P_MS(tp->t_srtt, TCP_RTT_SHIFT), 	    P_MS(tp->t_rttvar, TCP_RTTVAR_SHIFT), 	    get_base_rtt(tp), 	    so->so_error, 	    (so->so_flags1 & SOF1_TC_NET_SERV_TYPE) ? so->so_netsvctype : so->so_traffic_class, 	    inp->inp_flowhash
TCP_LOG_CONNECTION_SUMMARY_FMT "tcp_connection_summary " 	    TCP_LOG_COMMON_PCB_FMT 	    "flowctl: %lluus (%llux) " 	    "SYN in/out: %u/%u " 	    "FIN in/out: %u/%u " 	    "RST in/out: %u/%u " 	    "AccECN (client/server): %s/%s\n"
TCP_LOG_CONNECTION_SUMMARY_ARGS TCP_LOG_COMMON_PCB_ARGS, 	    inp->inp_fadv_total_time, 	    inp->inp_fadv_cnt, 	    tp->t_syn_rcvd, tp->t_syn_sent, 	    tp->t_fin_rcvd, tp->t_fin_sent, 	    tp->t_rst_rcvd, tp->t_rst_sent, 	    tcp_connection_client_accurate_ecn_state_to_string(tp->t_client_accecn_state), 	    tcp_connection_server_accurate_ecn_state_to_string(tp->t_server_accecn_state)
TCP_LOG_DROP_PCB_FMT "tcp drop %s" 	    TCP_LOG_COMMON_PCB_FMT 	    "t_state: %s " 	    "so_error: %d " 	    "reason: %s"
TCP_LOG_DROP_PCB_ARGS direction, 	    TCP_LOG_COMMON_PCB_ARGS, 	    tcpstates[tp->t_state], 	    so->so_error, 	    reason
TCP_LOG_TH_FLAGS_COMMON_FMT "tcp control %s " 	"%s" 	"%s" 	"%s" 	"%s"
TCP_LOG_TH_FLAGS_COMMON_ARGS outgoing ? "outgoing" : "incoming", 	thflags & TH_SYN ? "SYN " : "", 	thflags & TH_FIN ? "FIN " : "", 	thflags & TH_RST ? "RST " : "", 	thflags & TH_ACK ? "ACK " : ""
TCP_LOG_TH_FLAGS_NO_PCB_FMT TCP_LOG_TH_FLAGS_COMMON_FMT 	    TCP_LOG_COMMON_FMT
TCP_LOG_TH_FLAGS_NO_PCB_ARGS TCP_LOG_TH_FLAGS_COMMON_ARGS, 	    TCP_LOG_COMMON_ARGS
TCP_LOG_TH_FLAGS_PCB_FMT TCP_LOG_TH_FLAGS_COMMON_FMT 	    TCP_LOG_COMMON_PCB_FMT 	    "SYN in/out: %u/%u "
TCP_LOG_TH_FLAGS_PCB_ARGS TCP_LOG_TH_FLAGS_COMMON_ARGS, 	    TCP_LOG_COMMON_PCB_ARGS, 	    tp->t_syn_rcvd, tp->t_syn_sent
TCP_LOG_DROP_PKT_FMT "tcp drop incoming control packet " 	        TCP_LOG_TH_FLAGS_COMMON_FMT 	    "reason: %s"
TCP_LOG_DROP_PKT_ARGS TCP_LOG_TH_FLAGS_COMMON_ARGS, 	    reason != NULL ? reason : ""
TCP_LOG_MESSAGE_FMT "tcp (%s:%d) " 	TCP_LOG_COMMON_PCB_FMT 	"bytes in/out: %llu/%llu " 	"pkts in/out: %llu/%llu " 	"%s"
TCP_LOG_MESSAGE_ARGS func_name, line_no, 	TCP_LOG_COMMON_PCB_ARGS, 	inp->inp_stat->rxbytes, inp->inp_stat->txbytes, 	inp->inp_stat->rxpackets, inp->inp_stat->txpackets, 	message
TCP_LOG_STATE_FMT "tcp_state_changed (%s:%d) " 	    TCP_LOG_COMMON_PCB_FMT 	    "%s "
TCP_LOG_STATE_ARGS func_name, line_no, 	TCP_LOG_COMMON_PCB_ARGS, 	tcpstates[new_state]
TCP_LOG_MESSAGE_FMT "tcp (%s:%d) " 	TCP_LOG_COMMON_PCB_FMT 	"bytes in/out: %llu/%llu " 	"pkts in/out: %llu/%llu " 	"rxmit pkts/bytes: %u/%u" 	"%s"
TCP_LOG_MESSAGE_ARGS func_name, line_no, 	TCP_LOG_COMMON_PCB_ARGS, 	inp->inp_stat->rxbytes, inp->inp_stat->txbytes, 	inp->inp_stat->rxpackets, inp->inp_stat->txpackets, 	tp->t_stat.rxmitpkts, tp->t_stat.txretransmitbytes, 	message
_NETINET_TCP_LOG_H_ None
TCP_ENABLE_FLAG_LIST X(TLEF_CONNECTION,	0x00000001, connection) 	X(TLEF_RTT,		0x00000002, rtt)        	X(TLEF_KEEP_ALIVE,	0x00000004, ka)         	X(TLEF_LOG,		0x00000008, log)        	X(TLEF_DST_LOOPBACK,	0x00000010, loop)       	X(TLEF_DST_LOCAL,	0x00000020, local)      	X(TLEF_DST_GW,		0x00000040, gw)         	X(TLEF_THF_SYN,		0x00000100, syn)        	X(TLEF_THF_FIN,		0x00000200, fin)        	X(TLEF_THF_RST,		0x00000400, rst)        	X(TLEF_DROP_NECP,	0x00001000, dropnecp)   	X(TLEF_DROP_PCB,	0x00002000, droppcb)    	X(TLEF_DROP_PKT,	0x00004000, droppkt)    	X(TLEF_FSW_FLOW,	0x00008000, fswflow)    	X(TLEF_STATE,           0x00010000, state)      	X(TLEF_SYN_RXMT,	0x00020000, synrxmt)    	X(TLEF_OUTPUT,	        0x00040000, output)     	X(TLEF_BIND,	        0x00080000, bind)
X(name, value, ...) name = value,
TCP_LOG_RTT_INFO(tp) if (tcp_is_log_enabled(tp, TLEF_RTT))     tcp_log_rtt_info(__func__, __LINE__, (tp))
TCP_LOG_RTM_RTT(tp, rt) if (tcp_is_log_enabled(tp, TLEF_RTT))     tcp_log_rt_rtt(__func__, __LINE__, (tp), (rt))
TCP_LOG_RTT_CHANGE(tp, old_srtt, old_rttvar) if (tcp_is_log_enabled(tp, TLEF_RTT))     tcp_log_rtt_change(__func__, __LINE__, (tp), (old_srtt), (old_rttvar))
TCP_LOG_KEEP_ALIVE(tp, idle_time) if (tcp_is_log_enabled(tp, TLEF_KEEP_ALIVE))     tcp_log_keepalive(__func__, __LINE__, (tp), (idle_time))
TCP_LOG_CONNECT(tp, outgoing, error) if (tcp_is_log_enabled(tp, TLEF_CONNECTION))     tcp_log_connection((tp), __unsafe_forge_null_terminated(const char *, ((outgoing) ? "connect outgoing" : "connect incoming")), (error))
TCP_LOG_CONNECTED(tp, error) if (tcp_is_log_enabled(tp, TLEF_CONNECTION))     tcp_log_connection((tp), "connected", (error))
TCP_LOG_LISTEN(tp, error) if (tcp_is_log_enabled(tp, TLEF_CONNECTION))     tcp_log_listen((tp), (error))
TCP_LOG_ACCEPT(tp, error) if (tcp_is_log_enabled(tp, TLEF_CONNECTION))     tcp_log_connection((tp), "accept", (error))
TCP_LOG_CONNECTION_SUMMARY(tp) if (tcp_log_summary_needed(tp))     tcp_log_connection_summary(__func__, __LINE__, (tp))
TCP_LOG_DROP_NECP(hdr, th, tp, outgoing) if (tcp_is_log_enabled(tp, TLEF_DROP_NECP))     tcp_log_drop_pcb((hdr), (th), (tp), (outgoing), "NECP")
TCP_LOG_DROP_PCB(hdr, th, tp, outgoing, reason) if (tcp_is_log_enabled(tp, TLEF_DROP_PCB))     tcp_log_drop_pcb((hdr), (th), (tp), (outgoing), reason)
TCP_LOG_TH_FLAGS(hdr, th, tp, outgoing, ifp)     if ((th) != NULL && ((th)->th_flags & (TH_SYN|TH_FIN|TH_RST))) 	    tcp_log_th_flags((hdr), (th), (tp), (outgoing), (ifp))
TCP_LOG_DROP_PKT(hdr, th, ifp, reason)     if ((th) != NULL && ((th->th_flags) & (TH_SYN|TH_FIN|TH_RST)) && 	(tcp_log_enable_flags & TLEF_DROP_PKT)) 	        tcp_log_drop_pkt((hdr), (th), (ifp), (reason))
TCP_LOG_FSW_FLOW(tp, format, ...) if (tcp_is_log_enabled(tp, TLEF_FSW_FLOW))     tcp_log_fsw_flow(__func__, __LINE__, (tp), format, ##__VA_ARGS__)
TCP_LOG(tp, format, ...) if (tcp_is_log_enabled(tp, TLEF_LOG))     tcp_log_message(__func__, __LINE__, tp, format, ## __VA_ARGS__)
TCP_LOG_STATE(tp, new_state) if (tcp_is_log_enabled(tp, TLEF_STATE))     tcp_log_state_change(__func__, __LINE__, (tp), (new_state))
TCP_LOG_OUTPUT(tp, format, ...) if (tcp_is_log_enabled(tp, TLEF_OUTPUT))     tcp_log_output(__func__, __LINE__, tp, format, ## __VA_ARGS__)
TCP_LOG_BIND(tp, error) if (tcp_is_log_enabled(tp, TLEF_BIND))     tcp_log_connection((tp), "bind", (error))
_IP_VHL None
DBG_LAYER_BEG NETDBG_CODE(DBG_NETTCP, 1)
DBG_LAYER_END NETDBG_CODE(DBG_NETTCP, 3)
DBG_FNC_TCP_OUTPUT NETDBG_CODE(DBG_NETTCP, (4 << 8) | 1)
ROUNDUP(a, b) (((a) + ((b) - 1)) & (~((b) - 1)))
ro route_u_._ro
ro6 route_u_._ro6
ipoa out_args_u_._ipoa
ip6oa out_args_u_._ip6oa
_NETINET_TCP_PRIVATE_H_ None
_IP_VHL None
TCP_VALIDATE_SACK_SEQ_NUMBERS(_tp_, _sb_, _ack_)     (SEQ_GT((_sb_)->end, (_sb_)->start) &&     SEQ_GT((_sb_)->start, (_tp_)->snd_una) &&     SEQ_GT((_sb_)->start, (_ack_)) &&     SEQ_LT((_sb_)->start, (_tp_)->snd_max) &&     SEQ_GT((_sb_)->end, (_tp_)->snd_una) &&     SEQ_LEQ((_sb_)->end, (_tp_)->snd_max))
_NETINET_TCP_SEQ_H_ None
SEQ_LT(a, b)     ((int)((a)-(b)) < 0)
SEQ_LEQ(a, b)    ((int)((a)-(b)) <= 0)
SEQ_GT(a, b)     ((int)((a)-(b)) > 0)
SEQ_GEQ(a, b)    ((int)((a)-(b)) >= 0)
SEQ_MIN(a, b)   ((SEQ_LT(a, b)) ? (a) : (b))
SEQ_MAX(a, b)   ((SEQ_GT(a, b)) ? (a) : (b))
TSTMP_LT(a, b)   ((int)((a)-(b)) < 0)
TSTMP_GT(a, b)   ((int)((a)-(b)) > 0)
TSTMP_LEQ(a, b)  ((int)((a)-(b)) <= 0)
TSTMP_GEQ(a, b)  ((int)((a)-(b)) >= 0)
CC_LT(a, b)      ((int)((a)-(b)) < 0)
CC_LEQ(a, b)     ((int)((a)-(b)) <= 0)
CC_GT(a, b)      ((int)((a)-(b)) > 0)
CC_GEQ(a, b)     ((int)((a)-(b)) >= 0)
tcp_minmssoverload fring
_IP_VHL None
DBG_FNC_TCP_CLOSE NETDBG_CODE(DBG_NETTCP, ((5 << 8) | 2))
TCP_BWMEAS_BURST_MINSIZE 6
TCP_BWMEAS_BURST_MAXSIZE 25
TCBHASHSIZE CONFIG_TCBHASHSIZE
ALIGNMENT 32
xchg(a, b, type) { type t; t = a; a = b; b = t; }
ISN_BYTES_PER_SECOND 1048576
IFP_PER_FLOW_STAT(_ipv4_, _stat_) { 	if (_ipv4_) { 	        ifp->if_ipv4_stat->_stat_++; 	} else { 	        ifp->if_ipv6_stat->_stat_++; 	} }
_NETINET_TCP_SYSCTLS_H_ None
TCP_STRETCHACK_DELAY_THRESHOLD 5
TCP_REPORT_STATS_INTERVAL 43200
VERIFY_NEXT_LINK(elm, field) do {       	if (LIST_NEXT((elm),field) != NULL &&   	    LIST_NEXT((elm),field)->field.le_prev !=    	        &((elm)->field.le_next))        	        panic("Bad link elm %p next->prev != elm", (elm));      } while(0)
VERIFY_PREV_LINK(elm, field) do {       	if (*(elm)->field.le_prev != (elm))     	        panic("Bad link elm %p prev->next != elm", (elm));      } while(0)
TCP_SET_TIMER_MODE(mode, i) do { 	if (IS_TIMER_HZ_10MS(i)) 	        (mode) |= TCP_TIMERLIST_10MS_MODE; 	else if (IS_TIMER_HZ_100MS(i)) 	        (mode) |= TCP_TIMERLIST_100MS_MODE; 	else 	        (mode) |= TCP_TIMERLIST_500MS_MODE; } while(0)
stat data.u.tcp_stats
_NETINET_TCP_TIMER_H_ None
TCPT_NTIMERS_EXT 4
TCPT_PTO 0
TCPT_DELAYFR 1
TCPT_REORDER 2
TCPT_REXMT 3
TCPT_DELACK 4
TCPT_PERSIST 5
TCPT_KEEP 6
TCPT_2MSL 7
TCPT_REXMT_EXT 0
TCPT_PERSIST_EXT 1
TCPT_KEEP_EXT 2
TCPT_2MSL_EXT 3
TCPT_DELACK_EXT 4
TCPTV_SRTTBASE 0
TCPTV_KEEPCNT 8
TCP_RCV_SS_PKTCOUNT 512
TCPTV_TWTRUNC 8
TCP_LINGERTIME 120
TCP_MAXRXTSHIFT 12
TCP_TIMERLIST_10MS_MODE 0x1
TCP_TIMERLIST_100MS_MODE 0x2
TCP_TIMERLIST_500MS_MODE 0x4
TCP_FASTMODE_IDLERUN_MAX 10
TCPT_RANGESET(tv, value, tvmin, tvmax, addslop) do { 	(tv) = ((addslop) ? tcp_rexmt_slop : 0) + (value); 	if ((uint32_t)(tv) < (uint32_t)(tvmin)) 	        (tv) = (tvmin); 	else if ((uint32_t)(tv) > (uint32_t)(tvmax)) 	        (tv) = (tvmax); } while(0)
OFFSET_FROM_START(tp, off) ((tcp_now + (off)) - (tp)->tentry.timer_start)
COMMON_START_ALLOW_FLOW_DIVERT(allow) do {                                                                    	if (inp == NULL || inp->inp_state == INPCB_STATE_DEAD)          	        return (EINVAL);                                        	if (!(allow) && necp_socket_should_use_flow_divert(inp))        	        return (EPROTOTYPE);                                    	tp = intotcpcb(inp);                                            	calculate_tcp_clock();                                          } while (0)
COMMON_START() COMMON_START_ALLOW_FLOW_DIVERT(false)
COMMON_END(req) out: return error; goto out
_NETINET_TCP_UTILS_H_ None
_NETINET_TCP_VAR_H_ None
_TCPCB_PTR(x) u_int32_t
_TCPCB_LIST_HEAD(name, type)    struct name {                           	u_int32_t	lh_first;       }
TCP_RETRANSHZ 1000
TCP_RETRANSHZ_TO_USEC 1000
N_TIME_WAIT_SLOTS 128
MIN_IAJ_WIN 16
ALLOWED_IAJ 5
IAJ_IGNORE_PKTCNT 40
ACC_IAJ_HIGH_THRESH 100
ACC_IAJ_REACT_LIMIT 200
RESET_IAJ_SIZE_THRESH 20
TCP_ADAPTIVE_TIMEOUT_MAX 10
TCP_CONNECTIVITY_PROBES_MAX 5
TCP_RXT_SPURIOUS 0x1
TCP_SEGMENT_SACKED 0x1
TCP_SEGMENT_LOST 0x2
TCP_RACK_RETRANSMITTED 0x4
TCP_SEGMENT_RETRANSMITTED_ATLEAST_ONCE 0x8
tcp6cb tcpcb
cub_last_max __u__._cubic_state_.tc_last_max
cub_epoch_start __u__._cubic_state_.tc_epoch_start
cub_origin_point __u__._cubic_state_.tc_origin_point
cub_tcp_win __u__._cubic_state_.tc_tcp_win
cub_tcp_bytes_acked __u__._cubic_state_.tc_tcp_bytes_acked
cub_epoch_period __u__._cubic_state_.tc_epoch_period
cub_avg_lastmax __u__._cubic_state_.tc_avg_lastmax
cub_mean_dev __u__._cubic_state_.tc_mean_deviation
num_cong_events_loss __u__._prague_state_.num_cong_events_loss
num_cong_events_ce __u__._prague_state_.num_cong_events_ce
prague_packets_acked __u__._prague_state_.packets_acked
prague_packets_marked __u__._prague_state_.packets_marked
prague_ce_counter __u__._prague_state_.ce_counter
prague_bytes_acked __u__._prague_state_.bytes_acked
snd_nxt_alpha __u__._prague_state_.snd_nxt_alpha
snd_nxt_cwr __u__._prague_state_.snd_nxt_cwr
prague_scaled_alpha __u__._prague_state_.scaled_alpha
prague_alpha_ai __u__._prague_state_.alpha_ai
ever_saw_ce __u__._prague_state_.ever_saw_ce
in_loss __u__._prague_state_.in_loss
reduced_due_to_ce __u__._prague_state_.reduced_due_to_ce
cubic_K __u__._prague_state_.cubic_state.tc_epoch_period
cubic_epoch_start __u__._prague_state_.cubic_state.tc_epoch_start
cubic_origin_point __u__._prague_state_.cubic_state.tc_origin_point
cubic_W_max __u__._prague_state_.cubic_state.tc_last_max
reno_acked __u__._prague_state_.cubic_state.tc_tcp_bytes_acked
reno_cwnd __u__._prague_state_.cubic_state.tc_tcp_win
ledbat_slowdown_events __u__._ledbat_state_.num_slowdown_events
ledbat_slowdown_ts __u__._ledbat_state_.slowdown_ts
ledbat_slowdown_begin __u__._ledbat_state_.slowdown_begin
ledbat_md_bytes_acked __u__._ledbat_state_.md_bytes_acked
TF_ACKNOW 0x00001
TF_DELACK 0x00002
TF_NODELAY 0x00004
TF_NOOPT 0x00008
TF_SENTFIN 0x00010
TF_REQ_SCALE 0x00020
TF_RCVD_SCALE 0x00040
TF_REQ_TSTMP 0x00080
TF_RCVD_TSTMP 0x00100
TF_SACK_PERMIT 0x00200
TF_NEEDSYN 0x00400
TF_NEEDFIN 0x00800
TF_NOPUSH 0x01000
TF_UNUSED1 0x02000
TF_UNUSED2 0x04000
TF_UNUSED3 0x08000
TF_MORETOCOME 0x10000
TF_LOCAL 0x20000
TF_RXWIN0SENT 0x40000
TF_SLOWLINK 0x80000
TF_LASTIDLE 0x100000
TF_FASTRECOVERY 0x200000
TF_WASFRECOVERY 0x400000
TF_SIGNATURE 0x800000
TF_MAXSEGSNT 0x1000000
TF_STREAMING_ON 0x2000000
TF_PMTUD 0x4000000
TF_CLOSING 0x8000000
TF_TSO 0x10000000
TF_BLACKHOLE 0x20000000
TF_TIMER_ONLIST 0x40000000
TF_STRETCHACK 0x80000000
TCPOOB_HAVEDATA 0x01
TCPOOB_HADDATA 0x02
TCP_FORCED_ACKS_COUNT 16
TE_SETUPSENT 0x00000001
TE_SETUPRECEIVED 0x00000002
TE_SENDIPECT 0x00000004
TE_SENDCWR 0x00000008
TE_SENDECE 0x00000010
TE_INRECOVERY 0x00000020
TE_RECV_ECN_CE 0x00000040
TE_RECV_ECN_ECE 0x00000080
TE_LOST_SYN 0x00000100
TE_LOST_SYNACK 0x00000200
TE_ECN_MODE_ENABLE 0x00000400
TE_ECN_MODE_DISABLE 0x00000800
TE_ENABLE_ECN 0x00001000
TE_CEHEURI_SET 0x00002000
TE_CLIENT_SETUP 0x00004000
TE_RCVD_SYN_RST 0x00008000
TE_ACE_SETUP_NON_ECT 0x00010000
TE_ACE_SETUP_ECT1 0x00020000
TE_ACE_SETUP_ECT0 0x00040000
TE_ACE_SETUP_CE 0x00080000
TE_ACE_SETUPSENT 0x00100000
TE_ACE_SETUPRECEIVED 0x00200000
TE_ACE_FINAL_ACK_3WHS 0x00400000
TE_ACO_ECT1 0x00800000
TE_ACO_ECT0 0x01000000
TE_RETRY_WITHOUT_ACO 0x02000000
TE_FORCE_ECT1 0x40000000
TE_FORCE_ECT0 0x80000000
TF_RXTFINDROP 0x1
TF_RCVUNACK_WAITSS 0x2
TF_BWMEAS_INPROGRESS 0x4
TF_MEASURESNDBW 0x8
TF_LAST_IS_PSH 0x10
TF_SACK_ENABLE 0x20
TF_RECOMPUTE_RTT 0x40
TF_DETECT_READSTALL 0x80
TF_RECV_THROTTLE 0x100
TF_NOSTRETCHACK 0x200
TF_NOTIMEWAIT 0x800
TF_SENT_TLPROBE 0x1000
TF_PKTS_REORDERED 0x2000
TF_DELAY_RECOVERY 0x4000
TF_FORCE 0x8000
TF_DISABLE_STRETCHACK 0x10000
TF_NOBLACKHOLE_DETECTION 0x20000
TF_RESCUE_RXT 0x80000
TF_CWND_NONVALIDATED 0x100000
TF_IF_PROBING 0x200000
TF_FASTOPEN 0x400000
TF_REASS_INPROG 0x800000
TF_FASTOPEN_FORCE_ENABLE 0x1000000
TF_USR_OUTPUT 0x2000000
TF_L4S_ENABLED 0x8000000
TF_L4S_DISABLED 0x10000000
TF_RACK_ENABLED 0x20000000
TF_TLP_IS_RETRANS 0x40000000
TCP_PIPEACK_SAMPLE_COUNT 3
TFO_F_OFFER_COOKIE 0x01
TFO_F_COOKIE_VALID 0x02
TFO_F_COOKIE_REQ 0x04
TFO_F_COOKIE_SENT 0x08
TFO_F_SYN_LOSS 0x10
TFO_F_NO_SNDPROBING 0x20
TFO_F_HEURISTIC_DONE 0x40
TFO_S_SYNDATA_RCV 0x01
TFO_S_COOKIEREQ_RECV 0x02
TFO_S_COOKIE_SENT 0x04
TFO_S_COOKIE_INVALID 0x08
TFO_S_COOKIE_REQ 0x10
TFO_S_COOKIE_RCV 0x20
TFO_S_SYN_DATA_SENT 0x40
TFO_S_SYN_DATA_ACKED 0x80
TFO_S_SYN_LOSS 0x0100
TFO_S_COOKIE_WRONG 0x0200
TFO_S_NO_COOKIE_RCV 0x0400
TFO_S_HEURISTICS_DISABLE 0x0800
TFO_S_SEND_BLACKHOLE 0x1000
TFO_S_RECV_BLACKHOLE 0x2000
TFO_S_ONE_BYTE_PROXY 0x4000
TFO_PROBE_NONE 0
TFO_PROBE_PROBING 1
TFO_PROBE_WAIT_DATA 2
TCP_COMP_CHANGE_RATE 5
NCURR_RTT_HIST 4
ENTER_FASTRECOVERY(_tp_) do {                                           	(_tp_)->t_flags |= TF_FASTRECOVERY;                                     	if (INP_IS_FLOW_CONTROLLED((_tp_)->t_inpcb))                            	        inp_reset_fc_state((_tp_)->t_inpcb);                            	if (!SLIST_EMPTY(&tp->t_rxt_segments))                                  	        tcp_rxtseg_clean(tp);                                           } while(0)
EXIT_FASTRECOVERY(_tp_) do {                                            	(_tp_)->t_flags &= ~TF_FASTRECOVERY;                                    	(_tp_)->t_dupacks = 0;                                                  	(_tp_)->t_rexmtthresh = (uint8_t)tcprexmtthresh;                        	(_tp_)->t_bytes_acked = 0;                                              	(_tp_)->ecn_flags &= ~TE_INRECOVERY;                                    	(_tp_)->t_timer[TCPT_PTO] = 0;                                          	(_tp_)->t_flagsext &= ~TF_RESCUE_RXT;                                   	(_tp_)->t_lossflightsize = 0;                                           	(_tp_)->sackhint.sack_bytes_acked = 0;                                  } while(0)
BYTES_ACKED(_th_, _tp_) 	((_th_)->th_ack - (_tp_)->snd_una)
TCP_DSACK_SEQ_IN_WINDOW(_tp_, _seq_, _una_)     (SEQ_LEQ((_seq_), (_tp_)->snd_max) &&     SEQ_GEQ((_seq_), ((_una_) - TCP_DSACK_MAX_SEND_WINDOW(_tp_))))
TCP_RESET_REXMT_STATE(_tp_) do { 	(_tp_)->t_rxtshift = 0; 	(_tp_)->t_rxtstart = 0; 	mptcp_reset_rexmit_state((_tp_)); } while(0);
TCP_IF_STATE_CHANGED(tp, probe_if_index)                        	(probe_if_index > 0 && tp->t_inpcb->inp_last_outifp != NULL &&  	probe_if_index == tp->t_inpcb->inp_last_outifp->if_index)
TCP_USE_RLEDBAT(_tp, _so)     TCP_RLEDBAT_ENABLED(_tp) && TCP_RECV_BG(_so)
TOF_TS 0x0001
TOF_MSS 0x0010
TOF_SCALE 0x0020
TOF_SIGNATURE 0x0040
TOF_SIGLEN 0x0080
TOF_SACK 0x0100
TOF_MPTCP 0x0200
TOF_TFO 0x0400
TOF_TFOREQ 0x0800
TFO_COOKIE_LEN_MIN 4
TFO_COOKIE_LEN_DEFAULT 8
TFO_COOKIE_LEN_MAX 16
TCP_REXMTVAL(tp) max((tp)->t_rttmin, (((tp)->t_srtt >> (TCP_RTT_SHIFT - TCP_DELTA_SHIFT))  	  + (tp)->t_rttvar) >> TCP_DELTA_SHIFT)
TF_ACKNOW 0x00001
TF_DELACK 0x00002
TF_NODELAY 0x00004
TF_NOOPT 0x00008
TF_SENTFIN 0x00010
TF_REQ_SCALE 0x00020
TF_RCVD_SCALE 0x00040
TF_REQ_TSTMP 0x00080
TF_RCVD_TSTMP 0x00100
TF_SACK_PERMIT 0x00200
TF_NEEDSYN 0x00400
TF_NEEDFIN 0x00800
TF_NOPUSH 0x01000
TF_REQ_CC 0x02000
TF_RCVD_CC 0x04000
TF_SENDCCNEW 0x08000
TF_MORETOCOME 0x10000
TF_LQ_OVERFLOW 0x20000
TF_RXWIN0SENT 0x40000
TF_SLOWLINK 0x80000
TCPOOB_HAVEDATA 0x01
TCPOOB_HADDATA 0x02
tcps_ecn_setup tcps_ecn_client_success
tcps_sent_cwr tcps_ecn_recv_ece
tcps_sent_ece tcps_ecn_sent_ece
TCP_RTT_SCALE 32
TCP_RTT_SHIFT 5
TCP_RTTVAR_SCALE 16
TCP_RTTVAR_SHIFT 4
TCP_DELTA_SHIFT 2
TCPCTL_DO_RFC1323 1
TCPCTL_DO_RFC1644 2
TCPCTL_MSSDFLT 3
TCPCTL_STATS 4
TCPCTL_RTTDFLT 5
TCPCTL_KEEPIDLE 6
TCPCTL_KEEPINTVL 7
TCPCTL_SENDSPACE 8
TCPCTL_RECVSPACE 9
TCPCTL_KEEPINIT 10
TCPCTL_PCBLIST 11
TCPCTL_DELACKTIME 12
TCPCTL_V6MSSDFLT 13
TCPCTL_MAXID 14
TCP_PKTLIST_CLEAR(tp) {                                         	(tp)->t_pktlist_head = (tp)->t_pktlist_tail = NULL;             	(tp)->t_lastchain = (tp)->t_pktlist_sentlen = 0;                }
TCP_FASTOPEN_SERVER 0x01
TCP_FASTOPEN_CLIENT 0x02
TCP_LINK_HEUR_RXMT_COMP 0x0001
TCP_LINK_HEUR_NOACKPRI 0x0002
TCP_LINK_HEUR_SYNRMXT 0x0004
TCP_LINK_HEUR_STEALTH 0x0008
TCP_LINK_HEUR_RTOMIN 0x0010
TCP_LINK_HEUR_NOTLP 0x0020
TCP_COMP_RXMT_GENCNT_MASK 0x80000000
TCP_DEFAULT_LINK_HEUR_RTOMIN 3000
TCP_ACK_COMPRESSION_DUMMY 1
TCP_FASTOPEN_KEYLEN 16
TCP_ACK_STRATEGY_LEGACY 0
TCP_ACK_STRATEGY_MODERN 1
_NETINET_UDP_H_ None
UDP_NOCKSUM 0x01
UDP_KEEPALIVE_OFFLOAD 0x02
UDP_KEEPALIVE_OFFLOAD_DATA_SIZE 32
UDP_KEEPALIVE_INTERVAL_MAX_SECONDS 65536
UDP_KEEPALIVE_OFFLOAD_TYPE_AIRPLAY 0x1
X(name, value, description, ...) #description ":" #value " "
UDP_LOG_RATE_LIMIT 1000
UDP_LOG_RATE_DURATION 60
UDP_LOG_COMMON_FMT "[%s:%u<->%s:%u] " 	    "interface: %s " 	    "(skipped: %lu)\n"
UDP_LOG_COMMON_ARGS laddr_buf, ntohs(local_port), faddr_buf, ntohs(foreign_port), 	    ifp != NULL ? if_name(ifp) : "", 	    udp_log_rate_exceeded_total
UDP_LOG_COMMON_PCB_FMT UDP_LOG_COMMON_FMT 	"so_gencnt: %llu " 	"so_state: 0x%04x " 	"process: %s:%u "
UDP_LOG_COMMON_PCB_ARGS UDP_LOG_COMMON_ARGS, 	so != NULL ? so->so_gencnt : 0, 	so != NULL ? so->so_state : 0, 	inp->inp_last_proc_name, so->last_pid
UDP_LOG_CONNECTION_FMT "udp %s: " 	    UDP_LOG_COMMON_PCB_FMT 	    "bytes in/out: %llu/%llu " 	    "pkts in/out: %llu/%llu " 	    "error: %d " 	    "so_error: %d " 	    "svc/tc: %u " 	    "flow: 0x%x"
UDP_LOG_CONNECTION_ARGS event, 	    UDP_LOG_COMMON_PCB_ARGS, 	    inp->inp_stat->rxbytes, inp->inp_stat->txbytes, 	    inp->inp_stat->rxpackets, inp->inp_stat->txpackets, 	    error, 	    so->so_error, 	    (so->so_flags1 & SOF1_TC_NET_SERV_TYPE) ? so->so_netsvctype : so->so_traffic_class, 	    inp->inp_flowhash
UDP_LOG_CONNECTION_SUMMARY_FMT "udp_connection_summary " 	    UDP_LOG_COMMON_PCB_FMT 	    "Duration: %lu.%03d sec " 	    "Conn_Time: %lu.%03d sec " 	    "bytes in/out: %llu/%llu " 	    "pkts in/out: %llu/%llu " 	    "rxnospace pkts/bytes: %llu/%llu " 	    "so_error: %d " 	    "svc/tc: %u " 	    "flow: 0x%x" 	    "flowctl: %lluus (%llux) "
UDP_LOG_CONNECTION_SUMMARY_ARGS UDP_LOG_COMMON_PCB_ARGS, 	    duration_secs, duration_microsecs / 1000, 	    connection_secs, connection_microsecs / 1000, 	    inp->inp_stat->rxbytes, inp->inp_stat->txbytes, 	    inp->inp_stat->rxpackets, inp->inp_stat->txpackets, 	    so->so_tc_stats[SO_STATS_SBNOSPACE].rxpackets, 	    so->so_tc_stats[SO_STATS_SBNOSPACE].rxbytes, 	    so->so_error, 	    (so->so_flags1 & SOF1_TC_NET_SERV_TYPE) ? so->so_netsvctype : so->so_traffic_class, 	    inp->inp_flowhash, 	    inp->inp_fadv_total_time, 	    inp->inp_fadv_cnt
UDP_LOG_MESSAGE_FMT "udp (%s:%d): " 	    UDP_LOG_COMMON_PCB_FMT 	    "%s"
UDP_LOG_MESSAGE_ARGS func_name, line_no, 	    UDP_LOG_COMMON_PCB_ARGS, 	    format
UDP_LOG_DROP_PCB_FMT "udp drop %s" 	    UDP_LOG_COMMON_PCB_FMT 	    "so_error: %d " 	    "reason: %s"
UDP_LOG_DROP_PCB_ARGS direction, 	    UDP_LOG_COMMON_PCB_ARGS, 	    so->so_error, 	    reason
_NETINET_UDP_LOG_H_ None
UDP_ENABLE_FLAG_LIST X(ULEF_CONNECT,         0x00000001, connect)    	X(ULEF_BIND,            0x00000002, bind)       	X(ULEF_LOG,             0x00000008, log)        	X(ULEF_DST_LOOPBACK,    0x00000010, loop)       	X(ULEF_DST_LOCAL,       0x00000020, local)      	X(ULEF_DST_GW,          0x00000040, gw)         	X(ULEF_DROP_NECP,       0x00001000, dropnecp)   	X(ULEF_DROP_PCB,        0x00002000, droppcb)    	X(ULEF_DROP_PKT,        0x00004000, droppkt)
X(name, value, ...) name = value,
UDP_LOG_BIND(inp, error) if (udp_is_log_enabled((inp), ULEF_BIND))     udp_log_bind((inp), (error))
UDP_LOG_CONNECT(inp, error) if (udp_is_log_enabled((inp), ULEF_CONNECT))     udp_log_connect((inp), (error))
UDP_LOG_CONNECTION_SUMMARY(inp) if ((inp) != NULL && ((inp)->inp_flags2 & INP2_LOGGING_ENABLED))     udp_log_connection_summary((inp))
UDP_LOG(inp, format, ...) if (udp_is_log_enabled((inp), ULEF_LOG))     udp_log_message(__func__, __LINE__, (inp), format, ## __VA_ARGS__)
UDP_LOG_DROP_NECP(hdr, uh, inp, outgoing) if (udp_is_log_enabled(inp, ULEF_DROP_NECP))     udp_log_drop_pcb((hdr), (uh), (inp), (outgoing), "NECP")
UDP_LOG_DROP_PCB(hdr, uh, inp, outgoing, reason) if (udp_is_log_enabled(inp, ULEF_DROP_PCB))     udp_log_drop_pcb((hdr), (uh), (inp), (outgoing), (reason))
DBG_LAYER_IN_BEG NETDBG_CODE(DBG_NETUDP, 0)
DBG_LAYER_IN_END NETDBG_CODE(DBG_NETUDP, 2)
DBG_LAYER_OUT_BEG NETDBG_CODE(DBG_NETUDP, 1)
DBG_LAYER_OUT_END NETDBG_CODE(DBG_NETUDP, 3)
DBG_FNC_UDP_INPUT NETDBG_CODE(DBG_NETUDP, (5 << 8))
DBG_FNC_UDP_OUTPUT NETDBG_CODE(DBG_NETUDP, (6 << 8) | 1)
udb6 udb
UDBHASHSIZE 16
log_in_vain_log(a) { log a; }
_NETINET_UDP_VAR_H_ None
ui_x1 ui_i.ih_x1
ui_pr ui_i.ih_pr
ui_len ui_i.ih_len
ui_src ui_i.ih_src
ui_dst ui_i.ih_dst
ui_sport ui_u.uh_sport
ui_dport ui_u.uh_dport
ui_ulen ui_u.uh_ulen
ui_sum ui_u.uh_sum
ui_next ui_i.ih_next
ui_prev ui_i.ih_prev
UDPCTL_CHECKSUM 1
UDPCTL_STATS 2
UDPCTL_MAXDGRAM 3
UDPCTL_RECVSPACE 4
UDPCTL_PCBLIST 5
UDPCTL_MAXID 6
UDPCTL_NAMES {                                                  	{ 0, 0 },                                                       	{ "checksum", CTLTYPE_INT },                                    	{ "stats", CTLTYPE_STRUCT },                                    	{ "maxdgram", CTLTYPE_INT },                                    	{ "recvspace", CTLTYPE_INT },                                   	{ "pcblist", CTLTYPE_STRUCT },                                  }
udp6stat udpstat
udp6s_opackets udps_opackets
_NETINET6_AH_H_ None
AH_MAXSUMSIZE 64
_NETINET6_AH6_H_ None
IPLEN_FLIPPED None
_IP_VHL None
_NETINET6_ESP_H_ None
ESP_AUTH_MAXSUMSIZE 64
ESP_ASSERT(_cond, _format, ...)                                                  	do {                                                                             	        if (__improbable(!(_cond))) {                                            	                panic("%s:%d " _format, __FUNCTION__, __LINE__, ##__VA_ARGS__);  	        }                                                                        	} while (0)
ESP_CHECK_ARG(_arg) ESP_ASSERT(_arg != NULL, #_arg " is NULL")
_esp_log(_level, _format, ...)  	log(_level, "%s:%d " _format, __FUNCTION__, __LINE__, ##__VA_ARGS__)
esp_log_err(_format, ...) _esp_log(LOG_ERR, _format, ##__VA_ARGS__)
esp_log_default(_format, ...) _esp_log(LOG_NOTICE, _format, ##__VA_ARGS__)
esp_log_info(_format, ...) _esp_log(LOG_INFO, _format, ##__VA_ARGS__)
_esp_packet_log(_level, _format, ...)  	ipseclog((_level, "%s:%d " _format, __FUNCTION__, __LINE__, ##__VA_ARGS__))
esp_packet_log_err(_format, ...) _esp_packet_log(LOG_ERR, _format, ##__VA_ARGS__)
_NETINET6_ESP6_H_ None
ESP_CHACHAPOLY_SALT_LEN 4
ESP_CHACHAPOLY_KEY_LEN 32
ESP_CHACHAPOLY_NONCE_LEN 12
_ESP_CHACHA_POLY_H_ None
ESP_CHACHAPOLY_PAD_BOUND 1
ESP_CHACHAPOLY_IV_LEN 8
ESP_CHACHAPOLY_ICV_LEN 16
ESP_CHACHAPOLY_KEYBITS_WITH_SALT 288
_IP_VHL None
DBG_LAYER_BEG NETDBG_CODE(DBG_NETIPSEC, 1)
DBG_LAYER_END NETDBG_CODE(DBG_NETIPSEC, 3)
DBG_FNC_ESPAUTH NETDBG_CODE(DBG_NETIPSEC, (8 << 8))
MAX_SBUF_LEN 2000
MAXIVLEN 16
ESP_AESGCM_KEYLEN128 160
ESP_AESGCM_KEYLEN192 224
ESP_AESGCM_KEYLEN256 288
ESP_CBC_DES_BLOCKLEN 8
ESP_CBC_3DES_BLOCKLEN 8
_IP_VHL None
DBG_LAYER_BEG NETDBG_CODE(DBG_NETIPSEC, 1)
DBG_LAYER_END NETDBG_CODE(DBG_NETIPSEC, 3)
DBG_FNC_ESPIN NETDBG_CODE(DBG_NETIPSEC, (6 << 8))
DBG_FNC_DECRYPT NETDBG_CODE(DBG_NETIPSEC, (7 << 8))
IPLEN_FLIPPED None
_IP_VHL None
DBG_LAYER_BEG NETDBG_CODE(DBG_NETIPSEC, 1)
DBG_LAYER_END NETDBG_CODE(DBG_NETIPSEC, 3)
DBG_FNC_ESPOUT NETDBG_CODE(DBG_NETIPSEC, (4 << 8))
DBG_FNC_ENCRYPT NETDBG_CODE(DBG_NETIPSEC, (5 << 8))
MAX_REALIGN_LEN 2000
AES_BLOCKLEN 16
ESP_GCM_SALT_LEN 4
ESP_GCM_IVLEN 8
ESP_GCM_ALIGN 16
P2ROUNDUP_GCM(p, ctx)                                                 	intptr_t aligned_p = P2ROUNDUP(p, ESP_GCM_ALIGN);                     	intptr_t diff = (aligned_p - (intptr_t)p);                            	ctx = (aes_gcm_ctx *)(void *)((uint8_t *)p + diff)
IN6_IFSTAT_STRICT None
IA6_HASH_INIT(ia) {                                      	(ia)->ia6_hash.tqe_next = __unsafe_forge_single(void *, ~(uintptr_t)0);         	(ia)->ia6_hash.tqe_prev = __unsafe_forge_single(void *, ~(uintptr_t)0);         }
MLTMASK_LEN 4
MLTMASK_LEN_8_BITS 1
IN6_EVHDLR_CODE_STRING(type) case type: return #type;
_NETINET6_IN6_H_ None
__KAME__ None
__KAME_VERSION "2009/apple-darwin"
s6_addr __u6_addr.__u6_addr8
s6_addr8 __u6_addr.__u6_addr8
s6_addr16 __u6_addr.__u6_addr16
s6_addr32 __u6_addr.__u6_addr32
INET6_ADDRSTRLEN 46
IN6MASK0 {{{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }}}
IN6MASK7 {{{ 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 	                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }}}
IN6MASK8 {{{ 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 	                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }}}
IN6MASK16 {{{ 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 	                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }}}
IN6MASK32 {{{ 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 	                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }}}
IN6MASK64 {{{ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 	                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }}}
IN6MASK96 {{{ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 	                    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00 }}}
IN6MASK128 {{{ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 	                    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }}}
IPV6_ADDR_INT32_ONE 1
IPV6_ADDR_INT32_TWO 2
IPV6_ADDR_INT32_MNL 0xff010000
IPV6_ADDR_INT32_MLL 0xff020000
IPV6_ADDR_INT32_SMP 0x0000ffff
IPV6_ADDR_INT16_ULL 0xfe80
IPV6_ADDR_INT16_USL 0xfec0
IPV6_ADDR_INT16_MLL 0xff02
IN6ADDR_ANY_INIT {{{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }}}
IN6ADDR_LOOPBACK_INIT {{{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 }}}
IN6_ARE_ADDR_EQUAL(a, b) 	(bcmp(&(a)->s6_addr[0], &(b)->s6_addr[0], 	sizeof (struct in6_addr)) == 0)
SA6_ARE_ADDR_EQUAL(a, b) 	(((a)->sin6_scope_id == 0 || (b)->sin6_scope_id == 0 || 	((a)->sin6_scope_id == (b)->sin6_scope_id)) && 	(bcmp(&(a)->sin6_addr, &(b)->sin6_addr, sizeof (struct in6_addr)) == 0))
IPV6_ADDR_SCOPE_NODELOCAL 0x01
IPV6_ADDR_SCOPE_INTFACELOCAL 0x01
IPV6_ADDR_SCOPE_LINKLOCAL 0x02
IPV6_ADDR_SCOPE_SITELOCAL 0x05
IPV6_ADDR_SCOPE_ORGLOCAL 0x08
IPV6_ADDR_SCOPE_GLOBAL 0x0e
IPV6_ADDR_MC_FLAGS_TRANSIENT 0x10
IPV6_ADDR_MC_FLAGS_PREFIX 0x20
IFA6_IS_DEPRECATED(a, t) 	((a)->ia6_lifetime.ia6ti_preferred != 0 && 	(a)->ia6_lifetime.ia6ti_preferred < (t))
IFA6_IS_INVALID(a, t) 	((a)->ia6_lifetime.ia6ti_expire != 0 && 	(a)->ia6_lifetime.ia6ti_expire < (t))
IPV6_UNICAST_HOPS 4
IPV6_MULTICAST_IF 9
IPV6_MULTICAST_HOPS 10
IPV6_MULTICAST_LOOP 11
IPV6_JOIN_GROUP 12
IPV6_LEAVE_GROUP 13
IPV6_V6ONLY 27
IN6_CGA_HASH1_LENGTH 8
IN6_CGA_HASH2_LENGTH 14
IN6_CGA_PREPARE_ZEROES 9
_NETINET6_IN6_GIF_H_ None
GIF_HLIM 30
_NETINET6_IN6_IFATTACH_H_ None
IN6M_TRACE_HIST_SIZE 32
_NETINET6_IN6_PCB_H_ None
_NETINET6_IN6_PRIVATE_H_ None
satosin6(sa) SIN6(sa)
SIN6IFSCOPE(s) SIN6(s)
IPV6_SENDREDIRECTS 1
RIPV6SNDQ 8192
RIPV6RCVQ 8192
RTQ_TIMEOUT 60*10
SASEL_LOG(fmt, ...) do { 	if (ip6_select_srcaddr_debug) 	        os_log(OS_LOG_DEFAULT, "%s:%d " fmt,	            __FUNCTION__, __LINE__, ##__VA_ARGS__); } while (0);
REPLACE(r) do {	SASEL_LOG("REPLACE r %s ia %s ifp1 %s\n", 	    (#r), s_src, ifp1->if_xname); 	srcrule = (r); 	goto replace; } while (0)
NEXTSRC(r) do {	SASEL_LOG("NEXTSRC r %s ia %s ifp1 %s\n", 	    (#r), s_src, ifp1->if_xname); 	goto next;               } while (0)
BREAK(r) do { 	SASEL_LOG("BREAK r %s ia %s ifp1 %s\n", 	    (#r), s_src, ifp1->if_xname); 	srcrule = (r); 	goto out;                } while (0)
CHECK_RESTRICTIONS(_ip6oa, _ifp)                        	((((_ip6oa)->ip6oa_flags & IP6OAF_NO_CELLULAR) &&       	    IFNET_IS_CELLULAR(_ifp)) ||                         	(((_ip6oa)->ip6oa_flags & IP6OAF_NO_EXPENSIVE) &&       	    IFNET_IS_EXPENSIVE(_ifp)) ||                        	(((_ip6oa)->ip6oa_flags & IP6OAF_NO_CONSTRAINED) &&     	    IFNET_IS_CONSTRAINED(_ifp)) ||                      	(!((_ip6oa)->ip6oa_flags & IP6OAF_INTCOPROC_ALLOWED) && 	    IFNET_IS_INTCOPROC(_ifp)) ||                        	(!((_ip6oa)->ip6oa_flags & IP6OAF_AWDL_UNRESTRICTED) && 	    IFNET_IS_AWDL_RESTRICTED(_ifp)) &&                  	(!((_ip6oa)->ip6oa_flags & IP6OAF_MANAGEMENT_ALLOWED) && 	    IFNET_IS_MANAGEMENT(_ifp)) &&                       	(!((_ip6oa)->ip6oa_flags & IP6OAF_ULTRA_CONSTRAINED_ALLOWED) && 	    IFNET_IS_ULTRA_CONSTRAINED(_ifp)))
_NETINET6_IN6_VAR_H_ None
ia_ifp ia_ifa.ifa_ifp
ia_flags ia_ifa.ifa_flags
IN6_CGA_MODIFIER_LENGTH 16
IN6_CGA_KEY_MAXSIZE 2048
IN6_PREFIX_ND 1
IN6_PREFIX_RR 2
PR_ORIG_RA 0
PR_ORIG_RR 1
PR_ORIG_STATIC 2
PR_ORIG_KERNEL 3
ipr_raf_onlink ipr_flags.prf_ra.onlink
ipr_raf_auto ipr_flags.prf_ra.autonomous
ipr_statef_onlink ipr_flags.prf_state.onlink
ipr_rrf_decrvalid ipr_flags.prf_rr.decrvalid
ipr_rrf_decrprefd ipr_flags.prf_rr.decrprefd
irr_raf_mask_onlink irr_raflagmask.onlink
irr_raf_mask_auto irr_raflagmask.autonomous
irr_raf_mask_reserved irr_raflagmask.reserved
irr_raf_onlink irr_flags.prf_ra.onlink
irr_raf_auto irr_flags.prf_ra.autonomous
irr_statef_onlink irr_flags.prf_state.onlink
irr_rrf irr_flags.prf_rr
irr_rrf_decrvalid irr_flags.prf_rr.decrvalid
irr_rrf_decrprefd irr_flags.prf_rr.decrprefd
IN6_ARE_MASKED_ADDR_EQUAL(d, a, m)      (       	(((d)->s6_addr32[0] ^ (a)->s6_addr32[0]) & (m)->s6_addr32[0]) == 0 && 	(((d)->s6_addr32[1] ^ (a)->s6_addr32[1]) & (m)->s6_addr32[1]) == 0 && 	(((d)->s6_addr32[2] ^ (a)->s6_addr32[2]) & (m)->s6_addr32[2]) == 0 && 	(((d)->s6_addr32[3] ^ (a)->s6_addr32[3]) & (m)->s6_addr32[3]) == 0)
SIOCSIFADDR_IN6 _IOW('i', 12, struct in6_ifreq)
SIOCGIFADDR_IN6 _IOWR('i', 33, struct in6_ifreq)
SIOCSIFDSTADDR_IN6 _IOW('i', 14, struct in6_ifreq)
SIOCSIFNETMASK_IN6 _IOW('i', 22, struct in6_ifreq)
SIOCGIFDSTADDR_IN6 _IOWR('i', 34, struct in6_ifreq)
SIOCGIFNETMASK_IN6 _IOWR('i', 37, struct in6_ifreq)
SIOCDIFADDR_IN6 _IOW('i', 25, struct in6_ifreq)
SIOCAIFADDR_IN6 _IOW('i', 26, struct in6_aliasreq)
SIOCAIFADDR_IN6_32 _IOW('i', 26, struct in6_aliasreq_32)
SIOCAIFADDR_IN6_64 _IOW('i', 26, struct in6_aliasreq_64)
SIOCSIFPHYADDR_IN6 _IOW('i', 62, struct in6_aliasreq)
SIOCSIFPHYADDR_IN6_32 _IOW('i', 62, struct in6_aliasreq_32)
SIOCSIFPHYADDR_IN6_64 _IOW('i', 62, struct in6_aliasreq_64)
SIOCGIFPSRCADDR_IN6 _IOWR('i', 63, struct in6_ifreq)
SIOCGIFPDSTADDR_IN6 _IOWR('i', 64, struct in6_ifreq)
SIOCGIFAFLAG_IN6 _IOWR('i', 73, struct in6_ifreq)
OSIOCGIFINFO_IN6 _IOWR('i', 108, struct in6_ondireq)
SIOCGIFINFO_IN6 _IOWR('i', 76, struct in6_ondireq)
SIOCSNDFLUSH_IN6 _IOWR('i', 77, struct in6_ifreq)
SIOCGNBRINFO_IN6 _IOWR('i', 78, struct in6_nbrinfo)
SIOCGNBRINFO_IN6_32 _IOWR('i', 78, struct in6_nbrinfo_32)
SIOCGNBRINFO_IN6_64 _IOWR('i', 78, struct in6_nbrinfo_64)
SIOCSPFXFLUSH_IN6 _IOWR('i', 79, struct in6_ifreq)
SIOCSRTRFLUSH_IN6 _IOWR('i', 80, struct in6_ifreq)
SIOCGIFALIFETIME_IN6 _IOWR('i', 81, struct in6_ifreq)
SIOCSIFALIFETIME_IN6 _IOWR('i', 82, struct in6_ifreq)
SIOCGIFSTAT_IN6 _IOWR('i', 83, struct in6_ifreq)
SIOCGIFSTAT_ICMP6 _IOWR('i', 84, struct in6_ifreq)
SIOCSDEFIFACE_IN6 _IOWR('i', 85, struct in6_ndifreq)
SIOCGDEFIFACE_IN6 _IOWR('i', 86, struct in6_ndifreq)
SIOCSDEFIFACE_IN6_32 _IOWR('i', 85, struct in6_ndifreq_32)
SIOCSDEFIFACE_IN6_64 _IOWR('i', 85, struct in6_ndifreq_64)
SIOCGDEFIFACE_IN6_32 _IOWR('i', 86, struct in6_ndifreq_32)
SIOCGDEFIFACE_IN6_64 _IOWR('i', 86, struct in6_ndifreq_64)
SIOCSIFINFO_FLAGS _IOWR('i', 87, struct in6_ndireq)
SIOCSSCOPE6 _IOW('i', 88, struct in6_ifreq)
SIOCGSCOPE6 _IOWR('i', 89, struct in6_ifreq)
SIOCGSCOPE6DEF _IOWR('i', 90, struct in6_ifreq)
SIOCSIFPREFIX_IN6 _IOW('i', 100, struct in6_prefixreq)
SIOCGIFPREFIX_IN6 _IOWR('i', 101, struct in6_prefixreq)
SIOCDIFPREFIX_IN6 _IOW('i', 102, struct in6_prefixreq)
SIOCAIFPREFIX_IN6 _IOW('i', 103, struct in6_rrenumreq)
SIOCCIFPREFIX_IN6 _IOW('i', 104, struct in6_rrenumreq)
SIOCSGIFPREFIX_IN6 _IOW('i', 105, struct in6_rrenumreq)
SIOCGETSGCNT_IN6 _IOWR('u', 28, struct sioc_sg_req6)
SIOCGETMIFCNT_IN6 _IOWR('u', 107, struct sioc_mif_req6)
SIOCGETMIFCNT_IN6_32 _IOWR('u', 107, struct sioc_mif_req6_32)
SIOCGETMIFCNT_IN6_64 _IOWR('u', 107, struct sioc_mif_req6_64)
SIOCAADDRCTL_POLICY _IOW('u', 108, struct in6_addrpolicy)
SIOCDADDRCTL_POLICY _IOW('u', 109, struct in6_addrpolicy)
SIOCPROTOATTACH_IN6 _IOWR('i', 110, struct in6_aliasreq)
SIOCPROTOATTACH_IN6_32 _IOWR('i', 110, struct in6_aliasreq_32)
SIOCPROTOATTACH_IN6_64 _IOWR('i', 110, struct in6_aliasreq_64)
SIOCPROTODETACH_IN6 _IOWR('i', 111, struct in6_ifreq)
SIOCLL_START _IOWR('i', 130, struct in6_aliasreq)
SIOCLL_START_32 _IOWR('i', 130, struct in6_aliasreq_32)
SIOCLL_START_64 _IOWR('i', 130, struct in6_aliasreq_64)
SIOCLL_STOP _IOWR('i', 131, struct in6_ifreq)
SIOCAUTOCONF_START _IOWR('i', 132, struct in6_ifreq)
SIOCAUTOCONF_STOP _IOWR('i', 133, struct in6_ifreq)
SIOCDRADD_IN6 _IOWR('u', 134, struct in6_defrouter)
SIOCDRADD_IN6_32 _IOWR('u', 134, struct in6_defrouter_32)
SIOCDRADD_IN6_64 _IOWR('u', 134, struct in6_defrouter_64)
SIOCDRDEL_IN6 _IOWR('u', 135, struct in6_defrouter)
SIOCDRDEL_IN6_32 _IOWR('u', 135, struct in6_defrouter_32)
SIOCDRDEL_IN6_64 _IOWR('u', 135, struct in6_defrouter_64)
IPV6_ROUTER_MODE_DISABLED 0
IPV6_ROUTER_MODE_EXCLUSIVE 1
IPV6_ROUTER_MODE_HYBRID 2
SIOCSETROUTERMODE_IN6 _IOWR('i', 136, struct in6_ifreq)
SIOCGETROUTERMODE_IN6 _IOWR('i', 137, struct in6_ifreq)
SIOCLL_CGASTART _IOW('i', 160, struct in6_cgareq)
SIOCLL_CGASTART_32 _IOW('i', 160, struct in6_cgareq_32)
SIOCLL_CGASTART_64 _IOW('i', 160, struct in6_cgareq_64)
SIOCGIFCGAPREP_IN6 _IOWR('i', 187, struct in6_cgareq)
SIOCSIFCGAPREP_IN6 _IOWR('i', 188, struct in6_cgareq)
SIOCGIFCGAPREP_IN6_32 _IOWR('i', 187, struct in6_cgareq_32)
SIOCGIFCGAPREP_IN6_64 _IOWR('i', 187, struct in6_cgareq_64)
SIOCSIFCGAPREP_IN6_32 _IOWR('i', 188, struct in6_cgareq_32)
SIOCSIFCGAPREP_IN6_64 _IOWR('i', 188, struct in6_cgareq_64)
SIOCCLAT46_START _IOWR('i', 189, struct in6_ifreq)
SIOCCLAT46_STOP _IOWR('i', 190, struct in6_ifreq)
IN6_IFF_ANYCAST 0x0001
IN6_IFF_TENTATIVE 0x0002
IN6_IFF_DUPLICATED 0x0004
IN6_IFF_DETACHED 0x0008
IN6_IFF_DEPRECATED 0x0010
IN6_IFF_NODAD 0x0020
IN6_IFF_AUTOCONF 0x0040
IN6_IFF_TEMPORARY 0x0080
IN6_IFF_DYNAMIC 0x0100
IN6_IFF_OPTIMISTIC 0x0200
IN6_IFF_SECURED 0x0400
IN6_IFF_SWIFTDAD 0x0800
IN6_IFF_CLAT46 0x1000
IN6_IFF_NOPFX 0x8000
IN6_ARE_SCOPE_CMP(a, b)         ((a) - (b))
IN6_ARE_SCOPE_EQUAL(a, b)       ((a) == (b))
in6_ifstat_add_common(_ifp, _tag, _count, _atomic) do {         	if (_ifp != NULL && IN6_IFEXTRA(_ifp) != NULL) {                	        if (_atomic)                                            	                os_atomic_add(                                  	                        &IN6_IFEXTRA(_ifp)->in6_ifstat._tag,    	                        _count, relaxed);                       	        else                                                    	                IN6_IFEXTRA(_ifp)->in6_ifstat._tag += _count;   	}                                                               } while (0)
in6_ifstat_inc(_ifp, _tag) 	in6_ifstat_add_common(_ifp, _tag, 1, TRUE)
in6_ifstat_inc_na(_ifp, _tag) 	in6_ifstat_add_common(_ifp, _tag, 1, FALSE)
in6_ifstat_add(_ifp, _tag, _count) 	in6_ifstat_add_common(_ifp, _tag, _count, TRUE)
IFP_TO_IA6(ifp, ia)                                         	                                        	                                    do {                                                                	struct ifaddr *_ifa;                                            	ifnet_lock_assert(ifp, LCK_RW_ASSERT_HELD);                     	for (_ifa = (ifp)->if_addrlist.tqh_first; _ifa != NULL;         	    _ifa = _ifa->ifa_list.tqe_next) {                           	        IFA_LOCK(_ifa);                                         	        if (_ifa->ifa_addr->sa_family == AF_INET6) {            	                ifa_addref(_ifa);                               	                IFA_UNLOCK(_ifa);                               	                break;                                          	        }                                                       	        IFA_UNLOCK(_ifa);                                       	}                                                               	(ia) = ifatoia6(_ifa);                                          } while (0)
IN6M_LOCK_ASSERT_HELD(_in6m) LCK_MTX_ASSERT(&(_in6m)->in6m_lock, LCK_MTX_ASSERT_OWNED)
IN6M_LOCK_ASSERT_NOTHELD(_in6m) LCK_MTX_ASSERT(&(_in6m)->in6m_lock, LCK_MTX_ASSERT_NOTOWNED)
IN6M_LOCK(_in6m) lck_mtx_lock(&(_in6m)->in6m_lock)
IN6M_LOCK_SPIN(_in6m) lck_mtx_lock_spin(&(_in6m)->in6m_lock)
IN6M_CONVERT_LOCK(_in6m) do {                                   	IN6M_LOCK_ASSERT_HELD(_in6m);                                   	lck_mtx_convert_spin(&(_in6m)->in6m_lock);                      } while (0)
IN6M_UNLOCK(_in6m) lck_mtx_unlock(&(_in6m)->in6m_lock)
IN6M_ADDREF(_in6m) in6m_addref(_in6m, 0)
IN6M_ADDREF_LOCKED(_in6m) in6m_addref(_in6m, 1)
IN6M_REMREF(_in6m) in6m_remref(_in6m, 0)
IN6M_REMREF_LOCKED(_in6m) in6m_remref(_in6m, 1)
IN6_IFAUPDATE_NOWAIT 0x1
IN6_IFAUPDATE_1STADDR 0x2
IN6_IFAUPDATE_NEWADDR 0x4
IN6_IFAUPDATE_DADDELAY 0x8
IN6_LOOKUP_MULTI(addr, ifp, in6m)                               	                                    	                                        	                                   do {                                                                    	struct in6_multistep _step;                                     	IN6_FIRST_MULTI(_step, in6m);                                   	while ((in6m) != NULL) {                                        	        IN6M_LOCK_SPIN(in6m);                                   	        if ((in6m)->in6m_ifp == (ifp) &&                        	            IN6_ARE_ADDR_EQUAL(&(in6m)->in6m_addr, (addr))) {   	                IN6M_ADDREF_LOCKED(in6m);                       	                IN6M_UNLOCK(in6m);                              	                break;                                          	        }                                                       	        IN6M_UNLOCK(in6m);                                      	        IN6_NEXT_MULTI(_step, in6m);                            	}                                                               } while (0)
IN6_NEXT_MULTI(step, in6m)                                      	                                	                                   do {                                                                    	in6_multihead_lock_assert(LCK_RW_ASSERT_HELD);                  	if (((in6m) = (step).i_in6m) != NULL)                           	        (step).i_in6m = (step).i_in6m->in6m_entry.le_next;      } while (0)
IN6_FIRST_MULTI(step, in6m)                                     	                                	                                    do {                                                                    	in6_multihead_lock_assert(LCK_RW_ASSERT_HELD);                  	(step).i_in6m = in6_multihead.lh_first;                         	        IN6_NEXT_MULTI((step), (in6m));                         } while (0)
_NETINET6_IP6PROTOSW_H_ None
IN6ADDR_NHASH 61
IN6_IFSTAT_REQUIRE_ALIGNED_64(f) _CASSERT(!(offsetof(struct in6_ifstat, f) % sizeof (uint64_t)))
ICMP6_IFSTAT_REQUIRE_ALIGNED_64(f) _CASSERT(!(offsetof(struct icmp6_ifstat, f) % sizeof (uint64_t)))
IP6_CHECKINTERFACE_WEAK_ES 0
IP6_CHECKINTERFACE_HYBRID_ES 1
IP6_CHECKINTERFACE_STRONG_ES 2
IP6_HDR_ALIGNMENT_FIXUP(_m, _ifp, _action) do { } while (0)
IS2292(inp, x, y)       (((inp)->inp_flags & IN6P_RFC2292) ? (x) : (y))
IM6O_TRACE_HIST_SIZE 32
GET_IP6EXTHDR(s, t, f)     __unsafe_forge_bidi_indexable(t, s->f, (((struct ip6_ext *)s->f)->ip6e_len + 1) << 3)
IM6O_ZONE_NAME "ip6_moptions"
ipf_pktopts ip6obz.ipf_pktopts
exthdrs ip6obz.exthdrs
ip6route ip6obz.ip6route
ipsec_state ip6obz.ipsec_state
necp_route ip6obz.necp_route
saved_route ip6obz.saved_route
saved_ro_pmtu ip6obz.saved_ro_pmtu
args ip6obz.args
IP6_CHECK_RESTRICTIONS(_ifp, _ip6obf)                              ((!(_ip6obf).management_allowed && IFNET_IS_MANAGEMENT(_ifp)) ||     	 (!(_ip6obf).ultra_constrained_allowed && IFNET_IS_ULTRA_CONSTRAINED(_ifp)))
MAKE_EXTHDR(hp, mp) do {                                    	if (hp != NULL) {                                               	        struct ip6_ext *__single eh = (struct ip6_ext *)(hp);   	        error = ip6_copyexthdr((mp), (caddr_t)(hp),             	            ((eh)->ip6e_len + 1) << 3);                         	        if (error)                                              	                goto freehdrs;                                  	}                                                               } while (0)
MAKE_CHAIN(m, mp, p, i) do {                                    	if (m != NULL) {                                                	        if (!ip6obf.hdrsplit) {                                 	                panic("assumption failed: hdr not split");      	                                	        }                                                       	        *mtod((m), u_char *) = *(p);                            	        *(p) = (i);                                             	        p = mtod((m), u_char *);                                	        (m)->m_next = (mp)->m_next;                             	        (mp)->m_next = (m);                                     	        (mp) = (m);                                             	}                                                               } while (0)
JUMBOOPTLEN 8
OPTSET(bit) do {                                                	if (optval)                                                     	        in6p->inp_flags |= (bit);                               	else                                                            	        in6p->inp_flags &= ~(bit);                              } while (0)
OPTSET2(bit) do {                                           	if (optval) {                                                   	        in6p->inp_flags2 |= (bit);                              	} else {                                                        	        in6p->inp_flags2 &= ~(bit);                             	}                                                               } while (0)
OPTSET2292(bit) do {                                            	in6p->inp_flags |= IN6P_RFC2292;                                	if (optval)                                                     	        in6p->inp_flags |= (bit);                               	else                                                            	        in6p->inp_flags &= ~(bit);                              } while (0)
PKTOPT_EXTHDRCPY(t, f) do {                              	if (src->f != NULL) {                                        	        int hlen =                                           	            (((struct ip6_ext *)src->f)->ip6e_len + 1) << 3; 	        dst->f = kalloc_data(hlen, canwait);                 	        if (dst->f == NULL && canwait == Z_NOWAIT)           	            goto bad;                                        	        bcopy(GET_IP6EXTHDR(src, t, f),                      	              GET_IP6EXTHDR(dst, t, f),                      	              hlen);                                         	}                                                            } while (0)
GET_IP6_DEST_OPT(b, d, dlen) {                               do {                                                         	        struct ip6_dest *t = (struct ip6_dest *)(void *)buf; 	        (dlen) = (t->ip6d_len + 1) << 3;                     	        (d) = __unsafe_forge_bidi_indexable(struct ip6_dest *, (b), len);     } while(0);                                                  }
_NETINET6_IP6_VAR_H_ None
IP6QF_DIRTY 0x00000001
IM6O_LOCK_ASSERT_HELD(_im6o) LCK_MTX_ASSERT(&(_im6o)->im6o_lock, LCK_MTX_ASSERT_OWNED)
IM6O_LOCK_ASSERT_NOTHELD(_im6o) LCK_MTX_ASSERT(&(_im6o)->im6o_lock, LCK_MTX_ASSERT_NOTOWNED)
IM6O_LOCK(_im6o) lck_mtx_lock(&(_im6o)->im6o_lock)
IM6O_LOCK_SPIN(_im6o) lck_mtx_lock_spin(&(_im6o)->im6o_lock)
IM6O_CONVERT_LOCK(_im6o) do {                                   	IM6O_LOCK_ASSERT_HELD(_im6o);                                   	lck_mtx_convert_spin(&(_im6o)->im6o_lock);                      } while (0)
IM6O_UNLOCK(_im6o) lck_mtx_unlock(&(_im6o)->im6o_lock)
IM6O_ADDREF(_im6o) im6o_addref(_im6o, 0)
IM6O_ADDREF_LOCKED(_im6o) im6o_addref(_im6o, 1)
IM6O_REMREF(_im6o) im6o_remref(_im6o)
ip6po_rthdr ip6po_rhinfo.ip6po_rhi_rthdr
ip6po_route ip6po_rhinfo.ip6po_rhi_route
ip6po_nexthop ip6po_nhinfo.ip6po_nhi_nexthop
ip6po_nextroute ip6po_nhinfo.ip6po_nhi_route
IP6PO_MINMTU_MCASTONLY -1
IP6PO_MINMTU_DISABLE 0
IP6PO_MINMTU_ALL 1
IP6PO_TEMPADDR_SYSTEM -1
IP6PO_TEMPADDR_NOTPREFER 0
IP6PO_TEMPADDR_PREFER 1
IP6PO_DONTFRAG 0x04
IP6PO_USECOA 0x08
IP6S_SRCRULE_COUNT 16
IP6A_HASEEN 0x01
IPV6_UNSPECSRC 0x01
IPV6_FORWARDING 0x02
IPV6_MINMTU 0x04
IPV6_FLAG_NOSRCIFSEL 0x80
IPV6_OUTARGS 0x100
IP6_HDR_STRICT_ALIGNMENT_CHECK(_ip6) do { } while (0)
IP6OAF_SELECT_SRCIF 0x00000001
IP6OAF_BOUND_IF 0x00000002
IP6OAF_BOUND_SRCADDR 0x00000004
IP6OAF_NO_CELLULAR 0x00000010
IP6OAF_NO_EXPENSIVE 0x00000020
IP6OAF_AWDL_UNRESTRICTED 0x00000040
IP6OAF_QOSMARKING_ALLOWED 0x00000080
IP6OAF_INTCOPROC_ALLOWED 0x00000100
IP6OAF_NO_LOW_POWER 0x00000200
IP6OAF_NO_CONSTRAINED 0x00000400
IP6OAF_SKIP_PF 0x00000800
IP6OAF_DONT_FRAG 0x00001000
IP6OAF_REDO_QOSMARKING_POLICY 0x00002000
IP6OAF_R_IFDENIED 0x00004000
IP6OAF_MANAGEMENT_ALLOWED 0x00008000
IP6OAF_ULTRA_CONSTRAINED_ALLOWED 0x00010000
IPV6_CGA_CONFLICT_RETRIES_DEFAULT 3
IPV6_CGA_CONFLICT_RETRIES_MAX 10
IPV6_SRCSEL_HINT_PREFER_TMPADDR 0x00000001
_NETINET6_IPCOMP_H_ None
IPCOMP_OUI 1
IPCOMP_DEFLATE 2
IPCOMP_LZS 3
IPCOMP_MAX 4
IPCOMP_CPI_NEGOTIATE_MIN 256
DBG_LAYER_BEG NETDBG_CODE(DBG_NETIPSEC, 1)
DBG_LAYER_END NETDBG_CODE(DBG_NETIPSEC, 3)
DBG_FNC_GETPOL_SOCK NETDBG_CODE(DBG_NETIPSEC, (1 << 8))
DBG_FNC_GETPOL_ADDR NETDBG_CODE(DBG_NETIPSEC, (2 << 8))
DBG_FNC_IPSEC_OUT NETDBG_CODE(DBG_NETIPSEC, (3 << 8))
IP_FORWARDING 1
IPSEC_HISTORY_MAX 8
_NETINET6_IPSEC_H_ None
IPSEC_STAT_INCREMENT(x) OSIncrementAtomic64((SInt64 *)&x)
IPSEC_SPSTATE_DEAD 0
IPSEC_SPSTATE_ALIVE 1
IPSEC_PORT_ANY 0
IPSEC_ULPROTO_ANY 255
IPSEC_PROTO_ANY 255
IPSEC_MODE_ANY 0
IPSEC_MODE_TRANSPORT 1
IPSEC_MODE_TUNNEL 2
IPSEC_DIR_ANY 0
IPSEC_DIR_INBOUND 1
IPSEC_DIR_OUTBOUND 2
IPSEC_DIR_MAX 3
IPSEC_DIR_INVALID 4
IPSEC_POLICY_DISCARD 0
IPSEC_POLICY_NONE 1
IPSEC_POLICY_IPSEC 2
IPSEC_POLICY_ENTRUST 3
IPSEC_POLICY_BYPASS 4
IPSEC_POLICY_GENERATE 5
IPSEC_LEVEL_DEFAULT 0
IPSEC_LEVEL_USE 1
IPSEC_LEVEL_REQUIRE 2
IPSEC_LEVEL_UNIQUE 3
IPSEC_MANUAL_REQID_MAX 0x3fff
IPSEC_REPLAYWSIZE 32
IPSEC_KEY_AUTH_MAX_BYTES 256
IPSEC_KEY_ENCRYPT_MAX_BYTES 256
IPSEC_MAX_WAKE_PKT_LEN 100
IPSECCTL_STATS 1
IPSECCTL_DEF_POLICY 2
IPSECCTL_DEF_ESP_TRANSLEV 3
IPSECCTL_DEF_ESP_NETLEV 4
IPSECCTL_DEF_AH_TRANSLEV 5
IPSECCTL_DEF_AH_NETLEV 6
IPSECCTL_AH_CLEARTOS 8
IPSECCTL_AH_OFFSETMASK 9
IPSECCTL_DFBIT 10
IPSECCTL_ECN 11
IPSECCTL_DEBUG 12
IPSECCTL_ESP_RANDPAD 13
IPSECCTL_MAXID 14
IPSECCTL_NAMES { 	{ 0, 0 }, 	{ 0, 0 }, 	{ "def_policy", CTLTYPE_INT }, 	{ "esp_trans_deflev", CTLTYPE_INT }, 	{ "esp_net_deflev", CTLTYPE_INT }, 	{ "ah_trans_deflev", CTLTYPE_INT }, 	{ "ah_net_deflev", CTLTYPE_INT }, 	{ 0, 0 }, 	{ "ah_cleartos", CTLTYPE_INT }, 	{ "ah_offsetmask", CTLTYPE_INT }, 	{ "dfbit", CTLTYPE_INT }, 	{ "ecn", CTLTYPE_INT }, 	{ "debug", CTLTYPE_INT }, 	{ "esp_randpad", CTLTYPE_INT }, }
IPSEC6CTL_NAMES { 	{ 0, 0 }, 	{ 0, 0 }, 	{ "def_policy", CTLTYPE_INT }, 	{ "esp_trans_deflev", CTLTYPE_INT }, 	{ "esp_net_deflev", CTLTYPE_INT }, 	{ "ah_trans_deflev", CTLTYPE_INT }, 	{ "ah_net_deflev", CTLTYPE_INT }, 	{ 0, 0 }, 	{ 0, 0 }, 	{ 0, 0 }, 	{ 0, 0 }, 	{ "ecn", CTLTYPE_INT }, 	{ "debug", CTLTYPE_INT }, 	{ "esp_randpad", CTLTYPE_INT }, }
_ipsec_log(level, fmt, ...) do {                            	os_log_type_t type;                                         	switch (level) {                                            	default:                                                    	        type = OS_LOG_TYPE_DEFAULT;                         	        break;                                              	case LOG_INFO:                                              	        type = OS_LOG_TYPE_INFO;                            	        break;                                              	case LOG_DEBUG:                                             	        type = OS_LOG_TYPE_DEBUG;                           	        break;                                              	case LOG_ERR:                                               	        type = OS_LOG_TYPE_ERROR;                           	        break;                                              	}                                                           	os_log_with_type(OS_LOG_DEFAULT, type, fmt, ##__VA_ARGS__); } while (0)
ipseclog(x) do { if (ipsec_debug != 0) _ipsec_log x; } while (0)
_NETINET6_IPSEC6_H_ None
MLD_LOCK() lck_mtx_lock(&mld_mtx)
MLD_LOCK_ASSERT_HELD() LCK_MTX_ASSERT(&mld_mtx, LCK_MTX_ASSERT_OWNED)
MLD_LOCK_ASSERT_NOTHELD() LCK_MTX_ASSERT(&mld_mtx, LCK_MTX_ASSERT_NOTOWNED)
MLD_UNLOCK() lck_mtx_unlock(&mld_mtx)
MLD_ADD_DETACHED_IN6M(_head, _in6m) {                           	SLIST_INSERT_HEAD(_head, _in6m, in6m_dtle);                     }
MLD_REMOVE_DETACHED_IN6M(_head) {                               	struct in6_multi *_in6m, *_inm_tmp;                             	SLIST_FOREACH_SAFE(_in6m, _head, in6m_dtle, _inm_tmp) {         	        SLIST_REMOVE(_head, _in6m, in6_multi, in6m_dtle);       	        IN6M_REMREF(_in6m);                                     	}                                                               	VERIFY(SLIST_EMPTY(_head));                                     }
vt_nrecs pkt_mpriv.__mpriv_u.__mpriv32[0].__mpriv32_u.__val16[0]
_NETINET6_MLD6_H_ None
MLD_MINLEN sizeof(struct icmp6_hdr)
MLD_V2_QUERY_MINLEN sizeof(struct mldv2_query)
mld_numrecs mld_icmp6_hdr.icmp6_data16[1]
MLD_V2_REPORT_MAXRECS 65535
MLD_DO_NOTHING 0
MLD_MODE_IS_INCLUDE 1
MLD_MODE_IS_EXCLUDE 2
MLD_CHANGE_TO_INCLUDE_MODE 3
MLD_CHANGE_TO_EXCLUDE_MODE 4
MLD_ALLOW_NEW_SOURCES 5
MLD_BLOCK_OLD_SOURCES 6
MLD_V2_GENERAL_QUERY 1
MLD_V2_GROUP_QUERY 2
MLD_V2_GROUP_SOURCE_QUERY 3
MLD_V1_MAX_RI 10
MLD_TIMER_SCALE 1000
_NETINET6_MLD6_VAR_H_ None
MLIF_SILENT 0x00000001
MLIF_USEALLOW 0x00000002
MLIF_PROCESSED 0x00000004
MLD_VERSION_NONE 0
MLD_VERSION_1 1
MLD_VERSION_2 2
MLD_DEBUG 1
MLD_PRINTF(x) do { if (mld_debug) printf x; } while (0)
MLD_MAX_STATE_CHANGES 24
MLD_NOT_MEMBER 0
MLD_SILENT_MEMBER 1
MLD_REPORTING_MEMBER 2
MLD_IDLE_MEMBER 3
MLD_LAZY_MEMBER 4
MLD_SLEEPING_MEMBER 5
MLD_AWAKENING_MEMBER 6
MLD_G_QUERY_PENDING_MEMBER 7
MLD_SG_QUERY_PENDING_MEMBER 8
MLD_LEAVING_MEMBER 9
MLD_RV_INIT 2
MLD_RV_MIN 1
MLD_RV_MAX 7
MLD_QI_INIT 125
MLD_QI_MIN 1
MLD_QI_MAX 255
MLD_QRI_INIT 10
MLD_QRI_MIN 1
MLD_QRI_MAX 255
MLD_URI_INIT 3
MLD_URI_MIN 0
MLD_URI_MAX 10
MLD_MAX_GS_SOURCES 256
MLD_MAX_G_GS_PACKETS 8
MLD_MAX_STATE_CHANGE_PACKETS 8
MLD_MAX_RESPONSE_PACKETS 16
MLD_MAX_RESPONSE_BURST 4
MLD_RESPONSE_BURST_INTERVAL 1
M_MLDV1 M_PROTO1
M_GROUPREC M_PROTO3
MLI_LOCK_ASSERT_HELD(_mli) LCK_MTX_ASSERT(&(_mli)->mli_lock, LCK_MTX_ASSERT_OWNED)
MLI_LOCK_ASSERT_NOTHELD(_mli) LCK_MTX_ASSERT(&(_mli)->mli_lock, LCK_MTX_ASSERT_NOTOWNED)
MLI_LOCK(_mli) lck_mtx_lock(&(_mli)->mli_lock)
MLI_LOCK_SPIN(_mli) lck_mtx_lock_spin(&(_mli)->mli_lock)
MLI_CONVERT_LOCK(_mli) do {                                     	MLI_LOCK_ASSERT_HELD(_mli);                                     	lck_mtx_convert_spin(&(_mli)->mli_lock);                        } while (0)
MLI_UNLOCK(_mli) lck_mtx_unlock(&(_mli)->mli_lock)
MLI_ADDREF(_mli) mli_addref(_mli, 0)
MLI_ADDREF_LOCKED(_mli) mli_addref(_mli, 1)
MLI_REMREF(_mli) mli_remref(_mli)
LN_DEQUEUE(_ln) do {                                            	LCK_MTX_ASSERT(rnh_lock, LCK_MTX_ASSERT_OWNED);                 	RT_LOCK_ASSERT_HELD((_ln)->ln_rt);                              	(_ln)->ln_next->ln_prev = (_ln)->ln_prev;                       	(_ln)->ln_prev->ln_next = (_ln)->ln_next;                       	(_ln)->ln_prev = (_ln)->ln_next = NULL;                         	(_ln)->ln_flags &= ~ND6_LNF_IN_USE;                             } while (0)
LN_INSERTHEAD(_ln) do {                                         	LCK_MTX_ASSERT(rnh_lock, LCK_MTX_ASSERT_OWNED);                 	RT_LOCK_ASSERT_HELD((_ln)->ln_rt);                              	(_ln)->ln_next = llinfo_nd6.ln_next;                            	llinfo_nd6.ln_next = (_ln);                                     	(_ln)->ln_prev = &llinfo_nd6;                                   	(_ln)->ln_next->ln_prev = (_ln);                                	(_ln)->ln_flags |= ND6_LNF_IN_USE;                              } while (0)
senderr(e) { error = (e); goto bad; }
_NETINET6_ND6_H_ None
RTF_ANNOUNCE RTF_PROTO2
ND6_LNF_TIMER_SKIP 0x1
ND6_LNF_IN_USE 0x2
ND6_LLINFO_PURGE -3
ND6_LLINFO_NOSTATE -2
ND6_LLINFO_INCOMPLETE 0
ND6_LLINFO_REACHABLE 1
ND6_LLINFO_STALE 2
ND6_LLINFO_DELAY 3
ND6_LLINFO_PROBE 4
ND6_CACHE_STATE_TRANSITION(ln, nstate) do {	DTRACE_IP2(nd6_state_transition, struct llinfo_nd6 *, (ln), int, (nstate));	if (nd6_debug >= 3) {	        struct rtentry *ln_rt = (ln) != NULL ? (ln)->ln_rt : NULL; 	        nd6log3(info,	            "[%s:%d]: NDP cache entry changed from %s -> %s for address %s.\n",	            __func__,	            __LINE__,	            ndcache_state2str((ln)->ln_state),	            ndcache_state2str((nstate)),	            ln_rt != NULL ? ip6_sprintf(&SIN6(rt_key(ln_rt))->sin6_addr) : "N/A");	}	if ((ln) != NULL) {	        if ((ln)->ln_rt != NULL && (ln)->ln_rt->rt_ifp != NULL &&	            ((ln)->ln_rt->rt_ifp->if_eflags & IFEF_IPV6_ND6ALT) &&	            ((ln)->ln_state == ND6_LLINFO_REACHABLE)) {	                VERIFY((nstate) != ND6_LLINFO_STALE &&	                    (nstate) != ND6_LLINFO_DELAY &&	                    (nstate) != ND6_LLINFO_PROBE);	        }	        (ln)->ln_state = (nstate);	}} while(0)
ND6_EUI64_GBIT 0x01
ND6_EUI64_UBIT 0x02
ND6_EUI64_TO_IFID(in6) do {(in6)->s6_addr[8] ^= ND6_EUI64_UBIT; } while (0)
ND6_IFF_PERFORMNUD 0x1
ND6_IFF_ACCEPT_RTADV 0x2
ND6_IFF_PREFER_SOURCE 0x4
ND6_IFF_IFDISABLED 0x8
ND6_IFF_DONT_SET_IFROUTE 0x10
ND6_IFF_PROXY_PREFIXES 0x20
ND6_IFF_IGNORE_NA 0x40
ND6_IFF_INSECURE 0x80
ND6_IFF_REPLICATED 0x100
ND6_IFF_DAD 0x200
ND6_DAD_ENHANCED_DEFAULT 1
ND6_PROCESS_RTI_ENABLE 1
ND6_PROCESS_RTI_DISABLE 0
ND6_PROCESS_RTI_DEFAULT ND6_PROCESS_RTI_ENABLE
NDDRF_INSTALLED 0x01
NDDRF_IFSCOPE 0x02
NDDRF_STATIC 0x04
NDDRF_MAPPED 0x08
NDDRF_INELIGIBLE 0x10
NDDRF_LOCAL 0x20
MAX_RTR_SOLICITATION_DELAY 1
RTR_SOLICITATION_INTERVAL 4
NDPRF_ONLINK 0x1
NDPRF_DETACHED 0x2
NDPRF_STATIC 0x100
NDPRF_IFSCOPE 0x1000
NDPRF_PRPROXY 0x2000
NDPRF_PROCESSED_ONLINK 0x08000
NDPRF_PROCESSED_SERVICE 0x10000
NDPRF_DEFUNCT 0x20000
NDPRF_CLAT46 0x40000
CLAT46_COLLISION_COUNT_OFFSET 128
MAX_RTR_SOLICITATION_DELAY 1
RTR_SOLICITATION_INTERVAL 4
MAX_RTR_SOLICITATIONS 3
ND6_INFINITE_LIFETIME 0xffffffff
ND6_MAX_LIFETIME 0x7fffffff
MAX_REACHABLE_TIME 3600000
REACHABLE_TIME 30000
RETRANS_TIMER 1000
MIN_RANDOM_FACTOR 512
MAX_RANDOM_FACTOR 1536
DEF_TEMP_VALID_LIFETIME 604800
DEF_TEMP_PREFERRED_LIFETIME 86400
TEMPADDR_REGEN_ADVANCE 5
MAX_TEMP_DESYNC_FACTOR 600
IP6_USE_TMPADDR_DEFAULT 1
IP6_ULA_USE_TMPADDR_DEFAULT 0
ND6_PREFIX_EXPIRY_UNSPEC -1
ND6_PREFIX_EXPIRY_NEVER 0
NDDR_LOCK_ASSERT_HELD(_nddr) LCK_MTX_ASSERT(&(_nddr)->nddr_lock, LCK_MTX_ASSERT_OWNED)
NDDR_LOCK_ASSERT_NOTHELD(_nddr) LCK_MTX_ASSERT(&(_nddr)->nddr_lock, LCK_MTX_ASSERT_NOTOWNED)
NDDR_LOCK(_nddr) lck_mtx_lock(&(_nddr)->nddr_lock)
NDDR_LOCK_SPIN(_nddr) lck_mtx_lock_spin(&(_nddr)->nddr_lock)
NDDR_CONVERT_LOCK(_nddr) do {                                   	NDPR_LOCK_ASSERT_HELD(_nddr);                                   	lck_mtx_convert_spin(&(_nddr)->nddr_lock);                      } while (0)
NDDR_UNLOCK(_nddr) lck_mtx_unlock(&(_nddr)->nddr_lock)
NDDR_REF_LOCK(_nddr) lck_mtx_lock(&(_nddr)->nddr_ref_lock)
NDDR_REF_LOCK_SPIN(_nddr) lck_mtx_lock_spin(&(_nddr)->nddr_ref_lock)
NDDR_REF_UNLOCK(_nddr) lck_mtx_unlock(&(_nddr)->nddr_ref_lock)
NDDR_ADDREF(_nddr) nddr_addref(_nddr)
NDDR_REMREF(_nddr) nddr_remref(_nddr)
ndpr_next ndpr_entry.le_next
ndpr_raf ndpr_flags
ndpr_raf_onlink ndpr_flags.onlink
ndpr_raf_auto ndpr_flags.autonomous
ndpr_raf_router ndpr_flags.router
NDPR_LOCK_ASSERT_HELD(_ndpr) LCK_MTX_ASSERT(&(_ndpr)->ndpr_lock, LCK_MTX_ASSERT_OWNED)
NDPR_LOCK_ASSERT_NOTHELD(_ndpr) LCK_MTX_ASSERT(&(_ndpr)->ndpr_lock, LCK_MTX_ASSERT_NOTOWNED)
NDPR_LOCK(_ndpr) lck_mtx_lock(&(_ndpr)->ndpr_lock)
NDPR_LOCK_SPIN(_ndpr) lck_mtx_lock_spin(&(_ndpr)->ndpr_lock)
NDPR_CONVERT_LOCK(_ndpr) do {                                   	NDPR_LOCK_ASSERT_HELD(_ndpr);                                   	lck_mtx_convert_spin(&(_ndpr)->ndpr_lock);                      } while (0)
NDPR_UNLOCK(_ndpr) lck_mtx_unlock(&(_ndpr)->ndpr_lock)
NDPR_REF_LOCK(_ndpr) lck_mtx_lock(&(_ndpr)->ndpr_ref_lock)
NDPR_REF_LOCK_SPIN(_ndpr) lck_mtx_lock_spin(&(_ndpr)->ndpr_ref_lock)
NDPR_REF_UNLOCK(_ndpr) lck_mtx_unlock(&(_ndpr)->ndpr_ref_lock)
NDPR_ADDREF(_ndpr) ndpr_addref(_ndpr)
NDPR_REMREF(_ndpr) ndpr_remref(_ndpr)
prm_raf_onlink prm_flags.prf_ra.onlink
prm_raf_auto prm_flags.prf_ra.autonomous
prm_statef_onlink prm_flags.prf_state.onlink
prm_rrf_decrvalid prm_flags.prf_rr.decrvalid
prm_rrf_decrprefd prm_flags.prf_rr.decrprefd
pfr_next pfr_entry.le_next
ll_dest_sdl ll_dest_._sdl
nd6log0(type, ...)      do { os_log_##type(OS_LOG_DEFAULT, ##__VA_ARGS__); } while (0)
nd6log(type, ...)       do { if (nd6_debug >= 1) os_log_##type(OS_LOG_DEFAULT, ##__VA_ARGS__); } while (0)
nd6log2(type, ...)      do { if (nd6_debug >= 2) os_log_##type(OS_LOG_DEFAULT, ##__VA_ARGS__); } while (0)
nd6log3(type, ...)      do { if (nd6_debug >= 3) os_log_##type(OS_LOG_DEFAULT, ##__VA_ARGS__); } while (0)
nd_opts_src_lladdr nd_opt_each.src_lladdr
nd_opts_tgt_lladdr nd_opt_each.tgt_lladdr
nd_opts_pi nd_opt_each.pi_beg
nd_opts_pi_end nd_opt_each.pi_end
nd_opts_rh nd_opt_each.rh
nd_opts_mtu nd_opt_each.mtu
nd_opts_nonce nd_opt_each.nonce
nd_opts_rti nd_opt_each.rti_beg
nd_opts_rti_end nd_opt_each.rti_end
nd_opts_search nd_opt_each.search
nd_opts_last nd_opt_each.last
nd_opts_done nd_opt_each.done
nd_opts_initialized nd_opt_each.initialized
ND_OPT_LLADDR(opt, optlen, val, vallen) ({                                    (vallen) = opt->optlen << 3;                                                      struct nd_opt_hdr* __hdr = __unsafe_forge_bidi_indexable(struct nd_opt_hdr *,     (opt), sizeof(struct nd_opt_hdr) + (vallen));                                     (val) = (char *)(__hdr + 1);                                                  })
ND6_SEND_OPMODE_DISABLED 0
ND6_SEND_OPMODE_CGA_QUIET 1
DAD_LOCK_ASSERT_HELD(_dp) LCK_MTX_ASSERT(&(_dp)->dad_lock, LCK_MTX_ASSERT_OWNED)
DAD_LOCK_ASSERT_NOTHELD(_dp) LCK_MTX_ASSERT(&(_dp)->dad_lock, LCK_MTX_ASSERT_NOTOWNED)
DAD_LOCK(_dp) lck_mtx_lock(&(_dp)->dad_lock)
DAD_LOCK_SPIN(_dp) lck_mtx_lock_spin(&(_dp)->dad_lock)
DAD_CONVERT_LOCK(_dp) do {                                      	DAD_LOCK_ASSERT_HELD(_dp);                                      	lck_mtx_convert_spin(&(_dp)->dad_lock);                         } while (0)
DAD_UNLOCK(_dp) lck_mtx_unlock(&(_dp)->dad_lock)
DAD_ADDREF(_dp) dad_addref(_dp, 0)
DAD_ADDREF_LOCKED(_dp) dad_addref(_dp, 1)
DAD_REMREF(_dp) dad_remref(_dp)
ND6_TGT_SOLS_EXPIRE 5
ND6_MAX_SRC_SOLS_DEFAULT 4
ND6_MAX_TGT_SOLS_DEFAULT 8
NDRTI_ZONE_NAME "nd6_route_info"
equal(a1, a2) (bcmp((caddr_t)(a1), (caddr_t)(a2), (a1)->sa_len) == 0)
RTPREF_HIGH 1
RTPREF_MEDIUM 0
NDPR_TRACE_HIST_SIZE 32
NDPR_ZONE_NAME "nd6_prefix"
NDDR_TRACE_HIST_SIZE 32
NDDR_ZONE_NAME "nd6_defrouter"
ND_OPT_LEN_TO_BYTE_SCALE 3
ND_OPT_LEN_RTI_MIN 1
ND_OPT_LEN_RTI_MAX 3
ND_OPT_RTI_PFXLEN_MAX 128
IA6_NONCONST(ifa) __DECONST(struct in6_ifaddr *, (ifa))
_NETINET6_ND6_VAR_H_ None
_NETINET6_RAW_IP6_H_ None
SID(ifp) &IN6_IFEXTRA(ifp)->scope6_id
_NETINET6_SCOPE6_VAR_H_ None
SCOPE6_ID_MAX 16
_NETINET_TCP6_VAR_H_ None
_NETINET6_UDP6_VAR_H_ None
FULLMASK 0xff
SPIHASHSIZE 128
LIST_FOREACH(elm, head, field)                                     for (elm = LIST_FIRST(head); elm; elm = LIST_NEXT(elm, field))
LIST_INSERT_TAIL(head, elm, type, field) do {struct type *curelm = LIST_FIRST(head); if (curelm == NULL) {LIST_INSERT_HEAD(head, elm, field); } else { while (LIST_NEXT(curelm, field)) curelm = LIST_NEXT(curelm, field);LIST_INSERT_AFTER(curelm, elm, field);}} while (0)
KEY_CHKSASTATE(head, sav, name) if ((head) != (sav)) {                                          ipseclog((LOG_DEBUG, "%s: state mismatched (TREE=%d SA=%d)\n", (name), (head), (sav)));                        continue;                                               }
KEY_CHKSPDIR(head, sp, name) do { if ((head) != (sp)) {                                           ipseclog((LOG_DEBUG, "%s: direction mismatched (TREE=%d SP=%d), " "anyway continue.\n",                           (name), (head), (sp)));                         }                                                               } while (0)
KEY_SETSECSPIDX(_dir, s, d, ps, pd, ulp, ifp, s_s, s_e, d_s, d_e, idx) do { bzero((idx), sizeof(struct secpolicyindex));                         (idx)->dir = (_dir);                                                 (idx)->prefs = (ps);                                                 (idx)->prefd = (pd);                                                 (idx)->ul_proto = (ulp);                                             (idx)->internal_if = (ifp);                                          if (s) { SOCKADDR_COPY((s), &(idx)->src, (SA(s))->sa_len); }    if (d) { SOCKADDR_COPY((d), &(idx)->dst, (SA(d))->sa_len); }   if (s_s) { SOCKADDR_COPY((s_s), &(idx)->src_range.start, (SA(s_s))->sa_len); }   if (s_e) { SOCKADDR_COPY((s_e), &(idx)->src_range.end, (SA(s_e))->sa_len); }     if (d_s) { SOCKADDR_COPY((d_s), &(idx)->dst_range.start, (SA(d_s))->sa_len); }   if (d_e) { SOCKADDR_COPY((d_e), &(idx)->dst_range.end, (SA(d_e))->sa_len); }     } while (0)
KEY_SETSECASIDX(p, m, r, s, d, ifi, idx) do { bzero((idx), sizeof(struct secasindex));                             (idx)->proto = (p);                                                  (idx)->mode = (m);                                                   (idx)->reqid = (r);                                                  SOCKADDR_COPY((s), &(idx)->src, (SA(s))->sa_len);           SOCKADDR_COPY((d), &(idx)->dst, (SA(d))->sa_len);           (idx)->ipsec_ifindex = (ifi);                                                                           } while (0)
CMP_HEAD 0x1
CMP_PORT 0x2
CMP_REQID 0x4
CMP_MODE 0x8
CMP_EXACTLY 0xF
_NETKEY_KEY_H_ None
KEY_SADB_UNLOCKED 0
KEY_SADB_LOCKED 1
_NETKEY_KEYDB_H_ None
SECURITY_ASSOCIATION_ANY 0x0000
SECURITY_ASSOCIATION_PFKEY 0x0001
SECURITY_ASSOCIATION_CUSTOM_IPSEC 0x0010
MAX_REPLAY_WINDOWS 4
PER_TC_REPLAY_WINDOW_SN_SHIFT 30
SADB_KILL_INTERVAL 600
_NETKEY_KEYSOCK_H_ None
KEY_SENDUP_ONE 0
KEY_SENDUP_ALL 1
KEY_SENDUP_REGISTERED 2
PFKEY_STAT_INCREMENT(x) {lck_mtx_lock(&pfkey_stat_mutex); (x)++; lck_mtx_unlock(&pfkey_stat_mutex);}
_NETKEY_KEY_DEBUG_H_ None
KEYDEBUG_STAMP 0x00000001
KEYDEBUG_DATA 0x00000002
KEYDEBUG_DUMP 0x00000004
KEYDEBUG_KEY 0x00000010
KEYDEBUG_ALG 0x00000020
KEYDEBUG_IPSEC 0x00000040
_NETKEY_KEY_VAR_H_ None
KEYCTL_DEBUG_LEVEL 1
KEYCTL_SPI_TRY 2
KEYCTL_SPI_MIN_VALUE 3
KEYCTL_SPI_MAX_VALUE 4
KEYCTL_RANDOM_INT 5
KEYCTL_LARVAL_LIFETIME 6
KEYCTL_BLOCKACQ_COUNT 7
KEYCTL_BLOCKACQ_LIFETIME 8
KEYCTL_ESP_KEYMIN 9
KEYCTL_ESP_AUTH 10
KEYCTL_AH_KEYMIN 11
KEYCTL_PREFERED_OLDSA 12
KEYCTL_NATT_KEEPALIVE_INTERVAL 13
KEYCTL_PFKEYSTAT 14
KEYCTL_MAXID 15
KEYCTL_NAMES { 	{ 0, 0 }, 	{ "debug", CTLTYPE_INT }, 	{ "spi_try", CTLTYPE_INT }, 	{ "spi_min_value", CTLTYPE_INT }, 	{ "spi_max_value", CTLTYPE_INT }, 	{ "random_int", CTLTYPE_INT }, 	{ "larval_lifetime", CTLTYPE_INT }, 	{ "blockacq_count", CTLTYPE_INT }, 	{ "blockacq_lifetime", CTLTYPE_INT }, 	{ "esp_keymin", CTLTYPE_INT }, 	{ "esp_auth", CTLTYPE_INT }, 	{ "ah_keymin", CTLTYPE_INT }, 	{ "prefered_oldsa", CTLTYPE_INT }, 	{ "natt_keepalive_interval", CTLTYPE_INT }, 	{ "pfkeystat", CTLTYPE_STRUCT }, }
KEYCTL_VARS { 	0, 	&key_debug_level, 	&key_spi_trycnt, 	&key_spi_minval, 	&key_spi_maxval, 	&key_int_random, 	&key_larval_lifetime, 	&key_blockacq_count, 	&key_blockacq_lifetime, 	&ipsec_esp_keymin, 	&ipsec_ah_keymin, 	&ipsec_prefered_oldsa, 	&natt_keepalive_interval, }
__NFS_KRPC_H__ None
_NFS_NFS_H_ None
_NFS_NFSDISKLESS_H_ None
_NFS_NFSM_SUBS_H_ None
_NFS_NFSPROTO_H_ None
_NFS_NFSRVCACHE_H_ None
_BSD_NFS_NFS_CONF_H_ None
_NFS_NFS_GSS_H_ None
RPCSEC_GSS 6
RPCSEC_GSS_VERS_1 1
GSS_MAX_TOKEN_LEN 64*1024
GSS_MAX_MIC_LEN 2048
GSS_MAXSEQ 0x80000000
GSS_SVC_MAXCONTEXTS 500000
GSS_SVC_SEQWINDOW 256
MAX_SKEYLEN 32
SVC_CTX_HASHSZ 64
win_getbit(bits, bit)      ((bits[(bit) / 32] &   (1 << (bit) % 32)) != 0)
win_setbit(bits, bit)   do { bits[(bit) / 32] |=  (1 << (bit) % 32); } while (0)
win_resetbit(bits, bit) do { bits[(bit) / 32] &= ~(1 << (bit) % 32); } while (0)
GSS_CTX_PEND 5
GSS_CTX_TTL_MIN 1
GSS_TIMER_PERIOD 300
MSECS_PER_SEC 1000
_NFS_RPCV2_H_ None
_NFS_XDR_SUBS_H_ None
_PTHREAD_BSDTHREAD_PRIVATE_H_ None
_PTHREAD_PRIORITY_PRIVATE_H_ None
PTHREAD_EXPOSE_LAYOUT 1
_PTHREAD_PRIORITY_OVERCOMMIT_FLAG 0x80000000u
_PTHREAD_PRIORITY_INHERIT_FLAG 0x40000000u
_PTHREAD_PRIORITY_ROOTQUEUE_FLAG 0x20000000u
_PTHREAD_PRIORITY_SCHED_PRI_FLAG 0x20000000u
_PTHREAD_PRIORITY_ENFORCE_FLAG 0x10000000u
_PTHREAD_PRIORITY_FALLBACK_FLAG 0x04000000u
_PTHREAD_PRIORITY_COOPERATIVE_FLAG 0x08000000u
_PTHREAD_PRIORITY_EVENT_MANAGER_FLAG 0x02000000u
_PTHREAD_PRIORITY_NEEDS_UNBIND_FLAG 0x01000000u
_PTHREAD_PRIORITY_DEFAULTQUEUE_FLAG _PTHREAD_PRIORITY_FALLBACK_FLAG
_PTHREAD_PRIORITY_OVERRIDE_QOS_FLAG 0x00800000u
_PTHREAD_PRIORITY_FLAGS_MASK 0xff000000u
_PTHREAD_PRIORITY_SCHED_PRI_MASK 0x0000ffffu
_PTHREAD_PRIORITY_QOS_CLASS_MASK 0x003fff00u
_PTHREAD_PRIORITY_VALID_QOS_CLASS_MASK 0x00003f00u
_PTHREAD_PRIORITY_VALID_OVERRIDE_QOS_MASK 0x003fc000u
_PTHREAD_PRIORITY_PRIORITY_MASK 0x000000ffu
QOS_MIN_RELATIVE_PRIORITY -15
PTHREAD_INTERNAL 1
PTHREAD_SHIMS_VERSION 1
PTHREAD_CALLBACK_MEMBER kevent_workq_internal
PTHREAD_STRUCT_ACCESSOR(get, set, rettype, structtype, member) 	static rettype 	get(structtype x) { 	        return (x)->member; 	} 	static void 	set(structtype x, rettype y) { 	        (x)->member = y; 	}
WORKQ_SYSCTL_USECS(var, init) 	        static struct workq_usec_var var = { .usecs = init }; 	        SYSCTL_OID(_kern, OID_AUTO, var##_usecs, 	                        CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED, &var, 0, 	                        workq_sysctl_handle_usecs, "I", "")
WQ_COOPERATIVE_POOL_SIZE_DEFAULT 0
WQ_COOPERATIVE_POOL_SIZE_STRICT_PER_QOS -1
WQ_THACTIVE_BUCKET_WIDTH 16
WORKQ_UNPARK_FOR_DEATH_WAS_IDLE 0x1
workq_threadreq_is_overcommit(req) workq_tr_is_overcommit((req)->tr_flags)
workq_threadreq_is_nonovercommit(req) workq_tr_is_nonovercommit((req)->tr_flags)
workq_threadreq_is_cooperative(req) workq_tr_is_cooperative((req)->tr_flags)
WQ_COOPERATIVE_POOL_UNSATURATED 1
WQ_COOPERATIVE_BUCKET_UNSERVICED 2
WQ_COOPERATIVE_POOL_SATURATED_UP_TO_QOS 3
WORKQ_SCHEDULE_DELAYED_THREAD_CREATION_RESTART 0x1
_WORKQUEUE_INTERNAL_H_ None
SCHED_CALL_BLOCK 0x1
SCHED_CALL_UNBLOCK 0x2
WORKQUEUE_HIGH_PRIOQUEUE 0
WORKQUEUE_DEFAULT_PRIOQUEUE 1
WORKQUEUE_LOW_PRIOQUEUE 2
WORKQUEUE_BG_PRIOQUEUE 3
WORKQUEUE_CONSTRAINED_FACTOR 5
UT_WORKQ_NEW 0x01
UT_WORKQ_RUNNING 0x02
UT_WORKQ_DYING 0x04
UT_WORKQ_OVERCOMMIT 0x08
UT_WORKQ_OUTSIDE_QOS 0x10
UT_WORKQ_IDLE_CLEANUP 0x20
UT_WORKQ_EARLY_BOUND 0x40
UT_WORKQ_CPUPERCENT 0x80
UT_WORKQ_COOPERATIVE 0x100
UT_WORKQ_PERMANENT_BIND 0x200
UT_WORKQ_WORK_INTERVAL_JOINED 0x400
UT_WORKQ_WORK_INTERVAL_FAILED 0x800
TRP_PRIORITY 0x1
TRP_POLICY 0x2
TRP_CPUPERCENT 0x4
TRP_BOUND_THREAD 0x8
TRP_RELEASED 0x8000
WORKQUEUE_MAXTHREADS 512
WQ_STALLED_WINDOW_USECS 200
WQ_REDUCE_POOL_WINDOW_USECS 5000000
WQ_MAX_TIMER_INTERVAL_USECS 50000
_PTHREAD_WORKQUEUE_PRIVATE_H_ None
WORKQ_DISPATCH_CONFIG_VERSION 2
WORKQ_DISPATCH_MIN_SUPPORTED_VERSION 1
WORKQ_DISPATCH_SUPPORTED_FLAGS 0
_WORKQUEUE_TRACE_H_ None
WQ_TRACE_WORKQUEUE_SUBCLASS 1
WQ_TRACE_REQUESTS_SUBCLASS 2
WQ_TRACE_QUANTUM_SUBCLASS 7
WQ_TRACE_BSDTHREAD_SUBCLASS 16
TRACE_wq_pthread_exit KDBG_CODE(DBG_PTHREAD, WQ_TRACE_WORKQUEUE_SUBCLASS, 0x01)
TRACE_wq_workqueue_exit KDBG_CODE(DBG_PTHREAD, WQ_TRACE_WORKQUEUE_SUBCLASS, 0x02)
TRACE_wq_runthread KDBG_CODE(DBG_PTHREAD, WQ_TRACE_WORKQUEUE_SUBCLASS, 0x03)
TRACE_wq_death_call KDBG_CODE(DBG_PTHREAD, WQ_TRACE_WORKQUEUE_SUBCLASS, 0x05)
TRACE_wq_thread_block KDBG_CODE(DBG_PTHREAD, WQ_TRACE_WORKQUEUE_SUBCLASS, 0x09)
TRACE_wq_thactive_update KDBG_CODE(DBG_PTHREAD, WQ_TRACE_WORKQUEUE_SUBCLASS, 0x0a)
TRACE_wq_add_timer KDBG_CODE(DBG_PTHREAD, WQ_TRACE_WORKQUEUE_SUBCLASS, 0x0b)
TRACE_wq_start_add_timer KDBG_CODE(DBG_PTHREAD, WQ_TRACE_WORKQUEUE_SUBCLASS, 0x0c)
TRACE_wq_override_dispatch KDBG_CODE(DBG_PTHREAD, WQ_TRACE_WORKQUEUE_SUBCLASS, 0x14)
TRACE_wq_override_reset KDBG_CODE(DBG_PTHREAD, WQ_TRACE_WORKQUEUE_SUBCLASS, 0x15)
TRACE_wq_thread_create_failed KDBG_CODE(DBG_PTHREAD, WQ_TRACE_WORKQUEUE_SUBCLASS, 0x1d)
TRACE_wq_thread_terminate KDBG_CODE(DBG_PTHREAD, WQ_TRACE_WORKQUEUE_SUBCLASS, 0x1e)
TRACE_wq_thread_create KDBG_CODE(DBG_PTHREAD, WQ_TRACE_WORKQUEUE_SUBCLASS, 0x1f)
TRACE_wq_select_threadreq KDBG_CODE(DBG_PTHREAD, WQ_TRACE_WORKQUEUE_SUBCLASS, 0x20)
TRACE_wq_creator_select KDBG_CODE(DBG_PTHREAD, WQ_TRACE_WORKQUEUE_SUBCLASS, 0x23)
TRACE_wq_creator_yield KDBG_CODE(DBG_PTHREAD, WQ_TRACE_WORKQUEUE_SUBCLASS, 0x24)
TRACE_wq_constrained_admission KDBG_CODE(DBG_PTHREAD, WQ_TRACE_WORKQUEUE_SUBCLASS, 0x25)
TRACE_wq_wqops_reqthreads KDBG_CODE(DBG_PTHREAD, WQ_TRACE_WORKQUEUE_SUBCLASS, 0x26)
TRACE_wq_cooperative_admission KDBG_CODE(DBG_PTHREAD, WQ_TRACE_WORKQUEUE_SUBCLASS, 0x27)
TRACE_wq_create KDBG_CODE(DBG_PTHREAD, WQ_TRACE_REQUESTS_SUBCLASS, 0x01)
TRACE_wq_destroy KDBG_CODE(DBG_PTHREAD, WQ_TRACE_REQUESTS_SUBCLASS, 0x02)
TRACE_wq_thread_logical_run KDBG_CODE(DBG_PTHREAD, WQ_TRACE_REQUESTS_SUBCLASS, 0x03)
TRACE_wq_thread_request_initiate KDBG_CODE(DBG_PTHREAD, WQ_TRACE_REQUESTS_SUBCLASS, 0x05)
TRACE_wq_thread_request_modify KDBG_CODE(DBG_PTHREAD, WQ_TRACE_REQUESTS_SUBCLASS, 0x06)
TRACE_wq_thread_request_fulfill KDBG_CODE(DBG_PTHREAD, WQ_TRACE_REQUESTS_SUBCLASS, 0x08)
TRACE_bsdthread_set_qos_self KDBG_CODE(DBG_PTHREAD, WQ_TRACE_BSDTHREAD_SUBCLASS, 0x1)
TRACE_wq_quantum_arm KDBG_CODE(DBG_PTHREAD, WQ_TRACE_QUANTUM_SUBCLASS, 0x01)
TRACE_wq_quantum_expired KDBG_CODE(DBG_PTHREAD, WQ_TRACE_QUANTUM_SUBCLASS, 0x02)
TRACE_wq_quantum_disarm KDBG_CODE(DBG_PTHREAD, WQ_TRACE_QUANTUM_SUBCLASS, 0x03)
TRACE_wq_quantum_expiry_reevaluate KDBG_CODE(DBG_PTHREAD, WQ_TRACE_QUANTUM_SUBCLASS, 0x04)
WQ_TRACE(x, a, b, c, d) 	        ({ KERNEL_DEBUG_CONSTANT(x, a, b, c, d, 0); })
WQ_TRACE_WQ(x, wq, b, c, d) 	        ({ KERNEL_DEBUG_CONSTANT(x, proc_getpid((wq)->wq_proc), b, c, d, 0); })
_SKYWALK_OS_SKYWALK_H None
SK_KTRACE_AON_IF_STATS SKYWALKDBG_CODE(DBG_SKYWALK_ALWAYSON, 0x001)
SK_KTRACE_FSW_DEV_RING_FLUSH SKYWALKDBG_CODE(DBG_SKYWALK_FLOWSWITCH, 0x001)
SK_KTRACE_FSW_USER_RING_FLUSH SKYWALKDBG_CODE(DBG_SKYWALK_FLOWSWITCH, 0x002)
SK_KTRACE_FSW_FLOW_TRACK_RTT SKYWALKDBG_CODE(DBG_SKYWALK_FLOWSWITCH, 0x004)
SK_KTRACE_NETIF_RING_TX_REFILL SKYWALKDBG_CODE(DBG_SKYWALK_NETIF, 0x001)
SK_KTRACE_NETIF_HOST_ENQUEUE SKYWALKDBG_CODE(DBG_SKYWALK_NETIF, 0x002)
SK_KTRACE_NETIF_MIT_RX_INTR SKYWALKDBG_CODE(DBG_SKYWALK_NETIF, 0x003)
SK_KTRACE_NETIF_COMMON_INTR SKYWALKDBG_CODE(DBG_SKYWALK_NETIF, 0x004)
SK_KTRACE_NETIF_RX_NOTIFY_DEFAULT SKYWALKDBG_CODE(DBG_SKYWALK_NETIF, 0x005)
SK_KTRACE_NETIF_RX_NOTIFY_FAST SKYWALKDBG_CODE(DBG_SKYWALK_NETIF, 0x006)
SK_KTRACE_CHANNEL_TX_REFILL SKYWALKDBG_CODE(DBG_SKYWALK_CHANNEL, 0x1)
SK_KTRACE_PKT_RX_DRV SKYWALKDBG_CODE(DBG_SKYWALK_PACKET, 0x001)
SK_KTRACE_PKT_RX_FSW SKYWALKDBG_CODE(DBG_SKYWALK_PACKET, 0x002)
SK_KTRACE_PKT_RX_CHN SKYWALKDBG_CODE(DBG_SKYWALK_PACKET, 0x003)
SK_KTRACE_PKT_TX_FSW SKYWALKDBG_CODE(DBG_SKYWALK_PACKET, 0x010)
SK_KTRACE_PKT_TX_AQM SKYWALKDBG_CODE(DBG_SKYWALK_PACKET, 0x011)
SK_KTRACE_PKT_TX_DRV SKYWALKDBG_CODE(DBG_SKYWALK_PACKET, 0x012)
_SKYWALK_OS_SKYWALK_PRIVATE_H None
SK_ALIGN64_CASSERT(type, field) 	_CASSERT((__builtin_offsetof(type, field) % sizeof (uint64_t)) == 0)
IF_ATTACH_NX_NETIF_COMPAT 0x01
IF_ATTACH_NX_FLOWSWITCH 0x02
IF_ATTACH_NX_FSW_TRANSPORT_NETAGENT 0x04
IF_ATTACH_NX_NETIF_NETAGENT 0x08
IF_ATTACH_NX_NETIF_ALL 0x10
IF_ATTACH_NX_FSW_IP_NETAGENT 0x20
SKYWALK_NETWORKING_DISABLED IF_ATTACH_NX_FLOWSWITCH
SK_VERBOSE_SYSCTL "kern.skywalk.verbose"
SK_VERB_FLAGS_TABLE(X) X(SK_VERB_DEFAULT,		0)       	X(SK_VERB_DUMP,			1)       	X(SK_VERB_LOCKS,		2)       	X(SK_VERB_REFCNT,		3)       	X(SK_VERB_MEM,			4)       	X(SK_VERB_MEM_ARENA,		5)       	X(SK_VERB_MEM_CACHE,		6)       	X(SK_VERB_MEM_REGION,		7)       	X(SK_VERB_EVENTS,		8)       	X(SK_VERB_SYNC,			9)       	X(SK_VERB_NOTIFY,		10)      	X(SK_VERB_INTR,			11)      	X(SK_VERB_MONITOR,		12)      	X(SK_VERB_DEV,			13)      	X(SK_VERB_HOST,			14)      	X(SK_VERB_USER,			15)      	X(SK_VERB_RX,			16)      	X(SK_VERB_TX,			17)      	X(SK_VERB_LOOKUP,		18)      	X(SK_VERB_RING,			19)      	X(SK_VERB_NETIF,		20)      	X(SK_VERB_NETIF_MIT,		21)      	X(SK_VERB_IOSK,			22)      	X(SK_VERB_CHANNEL,		23)      	X(SK_VERB_AQM,			25)      	X(SK_VERB_FSW,			24)      	X(SK_VERB_FSW_DP,		26)      	X(SK_VERB_LLINK,		27)      	X(SK_VERB_FLOW,			28)      	X(SK_VERB_FLOW_CLASSIFY,	29)      	X(SK_VERB_FLOW_TRACK,		30)      	X(SK_VERB_FLOW_ADVISORY,	31)      	X(SK_VERB_FLOW_ROUTE,		32)      	X(SK_VERB_FPD,		        33)      	X(__SK_VERB_34__,		34)      	X(__SK_VERF_35__,		35)      	X(SK_VERB_USER_PIPE,		36)      	X(SK_VERB_NA,			37)      	X(SK_VERB_KERNEL_PIPE,		38)      	X(SK_VERB_NS_PROTO,		39)      	X(SK_VERB_NS_TCP,		40)      	X(SK_VERB_NS_UDP,		41)      	X(SK_VERB_NS_IPV4,		42)      	X(SK_VERB_NS_IPV6,		43)      	X(SK_VERB_COPY,			44)      	X(SK_VERB_COPY_MBUF,		45)      	X(SK_VERB_MOVE,			46)      	X(SK_VERB_MOVE_MBUF,		47)      	X(SK_VERB_IP_FRAG,		48)      	X(SK_VERB_ERROR_INJECT,		49)      	X(SK_VERB_QOS,			50)      	X(SK_VERB_NXPORT,		51)      	X(SK_VERB_FILTER,		52)      	X(SK_VERB_VP,			53)      	X(SK_VERB_NETIF_POLL,		54)      	X(SK_VERB_DROP,			55)      	X(__SK_VERB_56__,		56)      	X(__SK_VERB_57__,		57)      	X(__SK_VERB_58__,		58)      	X(__SK_VERB_59__,		59)      	X(__SK_VERB_60__,		60)      	X(__SK_VERB_61__,		61)      	X(SK_VERB_PRIV,			62)      	X(SK_VERB_ERROR,		63)
EXPAND_TO_STRING(name, bitshift) #name,
EXPAND_TO_ENUMERATION(name, bitshift) name = (1ULL << bitshift),
SK_INLINE_ATTRIBUTE __attribute__((always_inline))
SK_NO_INLINE_ATTRIBUTE __attribute__((noinline))
SK_LOG_ATTRIBUTE __attribute__((noinline, cold, not_tail_called))
_SKYWALK_OS_STATS_H_ None
IP_STATS_TABLE(X) X(IP_STATS_TOTAL,		"TotalRcvd",	"\t%llu total packet received\n")       	X(IP_STATS_BADSUM,		"BadCsum",	"\t\t%llu bad header checksum\n")       	X(IP_STATS_RCV_SWCSUM,		"RcvSWCsumPkt",	"\t\t%llu header checksummed in software")      	X(IP_STATS_RCV_SWCSUM_BYTES,	"RcvSWCsumByte"," (%llu byte)\n")       	X(IP_STATS_TOOSMALL,		"DataTooSmall",	"\t\t%llu with size smaller than minimum\n")	X(IP_STATS_TOOSHORT,		"PktTooShort",	"\t\t%llu with data size < data length\n")      	X(IP_STATS_ADJ,			"TotalAdj",	"\t\t%llu with data size > data length\n")      	X(IP_STATS_ADJ_HWCSUM_CLR,	"HWCsumDisc",	"\t\t\t%llu packet forced to software checksum\n")      	X(IP_STATS_TOOLONG,		"TooLong",	"\t\t%llu with ip length > max ip packet size\n")       	X(IP_STATS_BADHLEN,		"BadHdrLen",	"\t\t%llu with header length < data size\n")    	X(IP_STATS_BADLEN,		"BadLen",	"\t\t%llu with data length < header length\n")  	X(IP_STATS_BADOPTIONS,		"BadOptions",	"\t\t%llu with bad options\n")  	X(IP_STATS_BADVERS,		"BadVer",	"\t\t%llu with incorrect version number\n")     	X(IP_STATS_FRAGMENTS,		"FragRcvd",	"\t\t%llu fragment received\n") 	X(IP_STATS_FRAGDROPPED,		"FragDrop",	"\t\t\t%llu dropped (dup or out of space)\n")   	X(IP_STATS_FRAGTIMEOUT,		"FragTimeO",	"\t\t\t%llu dropped after timeout\n")   	X(IP_STATS_REASSEMBLED,		"Reassembled",	"\t\t\t%llu reassembled ok\n")  	X(IP_STATS_DELIVERED,		"Delivered",	"\t\t%llu packet for this host\n")      	X(IP_STATS_NOPROTO,		"UnkwnProto",	"\t\t%llu packet for unknown/unsupported protocol\n")   	X(IP_STATS_FORWARD,		"Fwd",		"\t\t%llu packet forwarded")    	X(IP_STATS_FASTFORWARD,		"FastFwd",	" (%llu packet fast forwarded)\n")      	X(IP_STATS_CANTFORWARD,		"CantFwd",	"\t\t%llu packet not forwardable\n")    	X(IP_STATS_NOTMEMBER,		"UnRegGroup",	"\t\t%llu packet received for unknown multicast group\n")       	X(IP_STATS_REDIRECTSENT,	"FwdSameNet",	"\t\t%llu redirect sent\n")     	X(IP_STATS_RXC_COLLISIONS,	"RxChnColl",	"\t\t%llu input packet not chained due to collision\n") 	X(IP_STATS_RXC_CHAINED,		"RxChn",	"\t\t%llu input packet processed in a chain\n") 	X(IP_STATS_RXC_NOTCHAIN,	"RxBypChn",	"\t\t%llu input packet unable to chain\n")      	X(IP_STATS_RXC_CHAINSZ_GT2,	"RxChnGT2",	"\t\t%llu input packet chain processed with length greater than 2\n")   	X(IP_STATS_RXC_CHAINSZ_GT4,	"RxChnGT4",	"\t\t%llu input packet chain processed with length greater than 4\n")           	      	X(IP_STATS_LOCALOUT,		"LocalOut",	"\t%llu packet sent from this host\n")  	X(IP_STATS_RAWOUT,		"RawPktOut",	"\t\t%llu packet sent with fabricated ip header\n")     	X(IP_STATS_ODROPPED,		"DropNoBuf",	"\t\t%llu output packet dropped due to no bufs, etc.\n")        	X(IP_STATS_NOROUTE,		"NoRoute",	"\t\t%llu output packet discarded due to no route\n")   	X(IP_STATS_FRAGMENTED,		"Fragmented",	"\t\t%llu output datagram fragmented\n")        	X(IP_STATS_OFRAGMENTS,		"OutFraged",	"\t\t%llu fragment created\n")  	X(IP_STATS_CANTFRAG,		"CantFrag",	"\t\t%llu datagram that can't be fragmented\n") 	X(IP_STATS_NOGIF,		"NoGif",	"\t\t%llu tunneling packet that can't find gif\n")      	X(IP_STATS_BADADDR,		"BadAddr",	"\t\t%llu datagram with bad address in header\n")       	X(IP_STATS_PKTDROPCNTRL,	"DropNoCtl",	"\t\t%llu packet dropped due to no bufs for control data\n")    	X(IP_STATS_SND_SWCSUM,		"SndSWCsumPkt",	"\t\t%llu header checksummed in software")      	X(IP_STATS_SND_SWCSUM_BYTES,	"SndSWCsumByte"," (%llu byte)\n")       	X(IP_STATS_RXC_NOTLIST,		"IPInPkt",	"\t\t%llu input packet did not go through list processing path\n")      	X(__IP_STATS_MAX,		"",		"end of ip stats")
IP6_STATS_TABLE(X) X(IP6_STATS_TOTAL,		"TotalRcvd",	"\t%llu total packet received\n")       	X(IP6_STATS_TOOSMALL,		"DataTooSmall",	"\t\t%llu with size smaller than minimum\n")    	X(IP6_STATS_TOOSHORT,		"PktTooShort",	"\t\t%llu with data size < data length\n")      	X(IP6_STATS_ADJ,		"TotalAdj",	"\t\t%llu with data size > data length\n")      	X(IP6_STATS_ADJ_HWCSUM_CLR,	"HWCsumDisc",	"\t\t\t%llu packet forced to software checksum\n")      	X(IP6_STATS_BADOPTIONS,		"BadOptions",	"\t\t%llu with bad options\n")  	X(IP6_STATS_BADVERS,		"BadVer",	"\t\t%llu with incorrect version number\n")     	X(IP6_STATS_FRAGMENTS,		"FrafRcvd",	"\t\t%llu fragment received\n") 	X(IP6_STATS_FRAGDROPPED,	"FragDrop",	"\t\t\t%llu dropped (dup or out of space)\n")   	X(IP6_STATS_FRAGTIMEOUT,	"FragTimeO",	"\t\t\t%llu dropped after timeout\n")   	X(IP6_STATS_FRAGOVERFLOW,	"FragOverFlow",	"\t\t\t%llu exceeded limit\n")  	X(IP6_STATS_REASSEMBLED,	"FragReassembled","\t\t\t%llu reassembled ok\n")                	X(IP6_STATS_ATMFRAG_RCVD,	"RAtomicFrag",	"\t\t\t%llu atomic fragments received\n")               	X(IP6_STATS_DELIVERED,		"Delivered",	"\t\t%llu packet for this host\n")      	X(IP6_STATS_FORWARD,		"Fwd",		"\t\t%llu packet forwarded\n")  	X(IP6_STATS_CANTFORWARD,	"CantFwd",	"\t\t%llu packet not forwardable\n")    	X(IP6_STATS_REDIRECTSENT,	"RedirectSent",	"\t\t%llu redirect sent\n")     	X(IP6_STATS_NOTMEMBER,		"NoMCGrp",	"\t\t%llu multicast packet which we don't join\n")      	X(IP6_STATS_EXTHDRTOOLONG,	"ExtHdrNotCont","\t\t\t%llu packet whose headers are not continuous\n") 	X(IP6_STATS_NOGIF,		"NoGif",	"\t\t%llu tunneling packet that can't find gif\n")      	X(IP6_STATS_TOOMANYHDR,		"TooManyHdr",	"\t\t%llu packet discarded due to too may headers\n")   	X(IP6_STATS_FORWARD_CACHEHIT,	"FwdCacheHit",	"\t\t%llu forward cache hit\n") 	X(IP6_STATS_FORWARD_CACHEMISS,	"FwdCacheMiss",	"\t\t%llu forward cache miss\n")        	X(IP6_STATS_PKTDROPCNTRL,	"DropNoCtl",	"\t\t%llu packet dropped due to no bufs for control data\n")    	      	X(IP6_STATS_LOCALOUT,		"LocalOut",	"\t%llu packet sent from this host\n")  	X(IP6_STATS_RAWOUT,		"RawPktOut",	"\t\t%llu packet sent with fabricated ip header\n")     	X(IP6_STATS_ODROPPED,		"DropNoBuf",	"\t\t%llu output packet dropped due to no bufs, etc.\n")        	X(IP6_STATS_NOROUTE,		"NoRoute",	"\t\t%llu output packet discarded due to no route\n")   	X(IP6_STATS_FRAGMENTED,		"Fragmented",	"\t\t%llu output datagram fragmented\n")        	X(IP6_STATS_OFRAGMENTS,		"OutFraged",	"\t\t%llu fragment created\n")  	X(IP6_STATS_CANTFRAG,		"CantFrag",	"\t\t%llu datagram that can't be fragmented\n")	X(IP6_STATS_BADSCOPE,		"BadScope",	"\t\t%llu packet that violated scope rules\n")  	X(IP6_STATS_SOURCES_NONE,	"AddrSelFail",	"\t\t%llu failure of source address selection\n")       	X(IP6_STATS_DAD_COLLIDE,	"DADColl",	"\t\t%llu duplicate address detection collision\n")     	X(IP6_STATS_DAD_LOOPCOUNT,	"DADLoop",	"\t\t%llu duplicate address detection NS loop\n")       	X(IP6_STATS_SOURCES_SKIP6_EXPENSIVE_SECONDARY_IF,"Ign2ndIf",	"\t\t%llu time ignored source on secondary expensive I/F\n")    	X(__IP6_STATS_MAX,		"",		"end of ipv6 stats")
TCP_STATS_TABLE(X) X(TCP_STATS_SNDTOTAL,		"SndTotalPkt",	"\t%llu packet sent\n") 	X(TCP_STATS_SNDPACK,		"SndTotalDP",	"\t\t%llu data packet") 	X(TCP_STATS_SNDBYTE,		"SndDataByte",	" (%llu byte)\n")       	X(TCP_STATS_SNDREXMITPACK,	"SndDPktReXmt",	"\t\t%llu data packet retransmitted")   	X(TCP_STATS_SNDREXMITBYTE,	"SndDByteReXmt"," (%llu byte)\n")       	X(TCP_STATS_MTURESENT,		"MTUReSnd",	"\t\t%llu resend initiated by MTU discovery\n") 	X(TCP_STATS_SNDACKS,		"SndAck",	"\t\t%llu ack-only packet")     	X(TCP_STATS_DELACK,		"DelayAck",	" (%llu delayed)\n")    	X(TCP_STATS_SNDURG,		"SndURG",	"\t\t%llu URG only packet\n")   	X(TCP_STATS_SNDPROBE,		"SndWinProb",	"\t\t%llu window probe packet\n")       	X(TCP_STATS_SNDWINUP,		"SndWinUpd",	"\t\t%llu window update packet\n")      	X(TCP_STATS_SNDCTRL,		"SndCtlPkt",	"\t\t%llu control packet\n")    	X(TCP_STATS_FCHOLDPACKET,	"FlowCtlWh",	"\t\t%llu data packet sent after flow control\n")       	X(TCP_STATS_SYNCHALLENGE,	"SYNChallenge",	"\t\t%llu challenge ACK sent due to unexpected SYN\n")  	X(TCP_STATS_RSTCHALLENGE,	"RSTChallenge",	"\t\t%llu challenge ACK sent due to unexpected RST\n")  	X(TCP_STATS_SND_SWCSUM,		"SndSWCsumPkt",	"\t\t%llu checksummed in software")     	X(TCP_STATS_SND_SWCSUM_BYTES,	"SndSWCsumByte"," (%llu byte) over IPv4\n")     	X(TCP_STATS_SND6_SWCSUM,	"SndSWCsumPkt6","\t\t%llu checksummed in software")     	X(TCP_STATS_SND6_SWCSUM_BYTES,	"SndSWCsumByte6"," (%llu byte) over IPv6\n")            	       	X(TCP_STATS_RCVTOTAL,		"RcvTotalPkt",	"\t%llu packet received\n")     	X(TCP_STATS_RCVACKPACK,		"RcvAckPkt",	"\t\t%llu ack") 	X(TCP_STATS_RCVACKBYTE,		"RcvAckByte",	" (for %llu byte)\n")   	X(TCP_STATS_RCVDUPACK,		"RcvDupAck",	"\t\t%llu duplicate ack\n")     	X(TCP_STATS_RCVACKTOOMUCH,	"RcvAckUnSnd",	"\t\t%llu ack for unsent data\n")       	X(TCP_STATS_RCVPACK,		"RcvPktInSeq",	"\t\t%llu packet received in-sequence") 	X(TCP_STATS_RCVBYTE,		"RcvBInSeq",	" (%llu byte)\n")       	X(TCP_STATS_RCVDUPPACK,		"RcvDupPkt",	"\t\t%llu completely duplicate packet") 	X(TCP_STATS_RCVDUPBYTE,		"RcvDupByte",	" (%llu byte)\n")       	X(TCP_STATS_PAWSDROP,		"PAWSDrop",	"\t\t%llu old duplicate packet\n")      	X(TCP_STATS_RCVMEMDROP,		"RcvMemDrop",	"\t\t%llu received packet dropped due to low memory\n") 	X(TCP_STATS_RCVPARTDUPPACK,	"RcvDupData",	"\t\t%llu packet with some dup. data")  	X(TCP_STATS_RCVPARTDUPBYTE,	"RcvPDupByte",	" (%llu byte duped)\n") 	X(TCP_STATS_RCVOOPACK,		"RcvOOPkt",	"\t\t%llu out-of-order packet") 	X(TCP_STATS_RCVOOBYTE,		"RcvOOByte",	" (%llu byte)\n")               	X(TCP_STATS_RCVPACKAFTERWIN,	"RcvAftWinPkt",	"\t\t%llu packet of data after window") 	X(TCP_STATS_RCVBYTEAFTERWIN,	"RcvAftWinByte"," (%llu byte)\n")               	X(TCP_STATS_RCVWINPROBE,	"RcvWinProbPkt","\t\t%llu window probe\n")              	X(TCP_STATS_RCVWINUPD,		"RcvWinUpdPkt",	"\t\t%llu window update packet\n")              	X(TCP_STATS_RCVAFTERCLOSE,	"RcvAftCloPkt",	"\t\t%llu packet received after close\n")       	X(TCP_STATS_BADRST,		"BadRST",	"\t\t%llu bad reset\n") 	X(TCP_STATS_RCVBADSUM,		"RcvBadCsum",	"\t\t%llu discarded for bad checksum\n")        	X(TCP_STATS_RCV_SWCSUM,		"RcvSWCsumPkt",	"\t\t%llu checksummed in software")     	X(TCP_STATS_RCV_SWCSUM_BYTES,	"RcvSWCsumByte"," (%llu byte) over IPv4\n")     	X(TCP_STATS_RCV6_SWCSUM,	"RcvSWCsumPkt6","\t\t%llu checksummed in software")     	X(TCP_STATS_RCV6_SWCSUM_BYTES,	"RcvSWCsumByte6"," (%llu byte) over IPv6\n")    	X(TCP_STATS_RCVBADOFF,		"RcvBadOff",	"\t\t%llu discarded for bad header offset field\n")     	X(TCP_STATS_RCVSHORT,		"RcvTooShort",	"\t\t%llu discarded because packet too short\n")        	X(TCP_STATS_CONNATTEMPT,	"ConnInit",	"\t\t%llu discarded because packet too short\n")                	  	X(TCP_STATS_ACCEPTS,		"ConnAcpt",	"\t%llu connection accept\n")   	X(TCP_STATS_BADSYN,		"BadSYN",	"\t%llu bad connection attempt\n")      	X(TCP_STATS_LISTENDROP,		"ListenDrop",	"\t%llu listen queue overflow\n")               	X(TCP_STATS_CONNECTS,		"ConnEst",	"\t%llu connection established (including accepts)\n")  	X(TCP_STATS_CLOSED,		"ConnClosed",	"\t%llu connection closed")     	X(TCP_STATS_DROPS,		"ConnDrop",	" (including %llu drop)\n")     	X(TCP_STATS_CACHEDRTT,		"RTTCacheUpd",	"\t\t%llu connection updated cached RTT on close\n")    	X(TCP_STATS_CACHEDRTTVAR,	"RTTVarCacheUpd","\t\t%llu connection updated cached RTT variance on close\n")  	X(TCP_STATS_CACHEDSSTHRESH,	"SSTholdCacheUpd","\t\t%llu connection updated cached ssthresh on close\n")     	X(TCP_STATS_CONNDROPS,		"EConnDrop",	"\t%llu embryonic connection dropped\n")        	X(TCP_STATS_RTTUPDATED,		"RTTUpdated",	"\t%llu segment updated rtt")   	X(TCP_STATS_SEGSTIMED,		"RTTTimed",	" (of %llu attempt)\n") 	X(TCP_STATS_REXMTTIMEO,		"ReXmtTO",	"\t%llu retransmit timeout\n")  	X(TCP_STATS_TIMEOUTDROP,	"DropTO",	"\t\t%llu connection dropped by rexmit timeout\n")      	X(TCP_STATS_RXTFINDROP,		"ReXmtFINDrop",	"\t\t%llu connection dropped after retransmitting FIN\n")       	X(TCP_STATS_PERSISTTIMEO,	"PersistTO",	"\t%llu persist timeout\n")                     	X(TCP_STATS_PERSISTDROP,	"PersisStateTO","\t\t%llu connection dropped by persist timeout\n")     	X(TCP_STATS_KEEPTIMEO,		"KATO",		"\t%llu keepalive timeout\n")   	X(TCP_STATS_KEEPPROBE,		"KAProbe",	"\t\t%llu keepalive probe sent\n")      	X(TCP_STATS_KEEPDROPS,		"KADrop",	"\t\t%llu connection dropped by keepalive\n")   	X(TCP_STATS_PREDACK,		"PredAck",	"\t%llu correct ACK header prediction\n")       	X(TCP_STATS_PREDDAT,		"PredData",	"\t%llu correct data packet header prediction\n")       	X(TCP_STATS_PCBCACHEMISS,	"Pcb$Miss",	"\t%llu times pcb cahce miss")          	        	X(TCP_STATS_SACK_RECOVERY_EPISODE,	"SACKRecEpi",	"\t%llu SACK recovery episode\n")       	X(TCP_STATS_SACK_REXMITS,	        "SACKReXmt",	"\t%llu segment rexmit in SACK recovery episodes\n")    	X(TCP_STATS_SACK_REXMIT_BYTES,		"SACKReXmtB",	"\t%llu byte rexmit in SACK recovery episodes\n")       	X(TCP_STATS_SACK_RCV_BLOCKS,		"SACKRcvBlk",	"\t%llu SACK option (SACK blocks) received\n")  	X(TCP_STATS_SACK_SEND_BLOCKS,		"SACKSntBlk",	"\t%llu SACK option (SACK blocks) sent\n")      	X(TCP_STATS_SACK_SBOVERFLOW,		"SACKSndBlkOF",	"\t%llu SACK scoreboard overflow\n")    	X(TCP_STATS_RACK_REXMITS,			"RACKReXmt",	"\t%llu segment rexmit in RACK recovery episodes\n")    	X(TCP_STATS_RACK_RECOVERY_EPISODE,	"RACKRecEpi",	"\t%llu RACK recovery episode\n")    	X(TCP_STATS_RACK_REORDERING_TIMEOUT_RECOVERY_EPISODE,	"RACKReorderTimeoutRecEpi",	"\t%llu RACK recovery episode due to reordering timeout\n")            	 	X(TCP_STATS_COALESCED_PACK,		"CoalPkt",	"\t%llu LRO coalesced packet\n")        	X(TCP_STATS_FLOWTBL_FULL,		"FlowTblFull",	"\t\t%llu time LRO flow table was full\n")      	X(TCP_STATS_FLOWTBL_COLLISION,		"FlowTblColl",	"\t\t%llu collision in LRO flow table\n")               	X(TCP_STATS_LRO_TWOPACK,		"LRO2Pkt",	"\t\t%llu time LRO coalesced 2 packets\n")              	X(TCP_STATS_LRO_MULTPACK,		"LROMultiPkt",	"\t\t%llu time LRO coalesced 3 or 4 packets\n") 	X(TCP_STATS_LRO_LARGEPACK,		"LROLargePkt",	"\t\t%llu time LRO coalesced 5 or more packets\n")              	X(TCP_STATS_LIMITED_TXT,		"LimitedXmt",	"\t%llu limited transmit done\n")               	X(TCP_STATS_EARLY_REXMT,		"EarlyReXmt",	"\t%llu early retransmit done\n")               	X(TCP_STATS_SACK_ACKADV,		"SACKAdvAck",	"\t%llu time cumulative ack advanced along with SACK\n")        	X(TCP_STATS_PTO,			"ProbTO",	"\t%llu probe timeout\n")               	X(TCP_STATS_RTO_AFTER_PTO,		"RTOAfProb",	"\t\t%llu time retransmit timeout triggered after probe\n")     	X(TCP_STATS_PROBE_IF,			"ProbeIF",	"\t\t%llu time probe packets were sent for an interface\n")     	X(TCP_STATS_PROBE_IF_CONFLICT,		"ProbeIFConfl",	"\t\t%llu time couldn't send probe packets for an interface\n") 	X(TCP_STATS_TLP_RECOVERY,		"TLPFastRecvr", "\t\t%llu time fast recovery after tail loss\n")        	X(TCP_STATS_TLP_RECOVERLASTPKT,		"TLPRecvrLPkt",	"\t\t%llu time recovered last packet \n")       	X(TCP_STATS_PTO_IN_RECOVERY,		"PTOInRecvr",	"\t\t%llu SACK based rescue retransmit\n")              	 	X(TCP_STATS_ECN_CLIENT_SETUP,		"ECNCliSetup",	"\t%llu client connection attempted to negotiate ECN\n")        	X(TCP_STATS_ECN_CLIENT_SUCCESS,		"ECNNegoSucc",	"\t\t%llu client connection successfully negotiated ECN\n")     	X(TCP_STATS_ECN_NOT_SUPPORTED,		"ECNSvrNoSupt", "\t\t%llu time graceful fallback to Non-ECN connection\n")      	X(TCP_STATS_ECN_LOST_SYN,		"ECNLOSSSYN",	"\t\t%llu time lost ECN negotiating SYN, followed by retransmission\n") 	X(TCP_STATS_ECN_SERVER_SETUP,		"ECNSvrSetup",	"\t\t%llu server connection attempted to negotiate ECN\n")      	X(TCP_STATS_ECN_SERVER_SUCCESS,		"ECNSvrSucc",	"\t\t%llu server connection successfully negotiate ECN\n")      	X(TCP_STATS_ECN_ACE_SYN_NOT_ECT,	"ACESynNotECT",	"\t\t%llu received AccECN SYN packet with Not-ECT\n")           	X(TCP_STATS_ECN_ACE_SYN_ECT1,		"ACESynECT1",	"\t\t%llu received AccECN SYN packet with ECT1\n")              	X(TCP_STATS_ECN_ACE_SYN_ECT0,		"ACESynECT0",	"\t\t%llu received AccECN SYN packet with ECT0\n")              	X(TCP_STATS_ECN_ACE_SYN_CE,		"ACESynCE",	"\t\t%llu received AccECN SYN packet with CE\n")                	X(TCP_STATS_ECN_LOST_SYNACK,		"ECNLossSYNACK","\t\t%llu time lost ECN negotiating SYN-ACK, followed by retransmission\n")     	X(TCP_STATS_ECN_RECV_CE,		"ECNRcv",	"\t\t%llu time received congestion experienced (CE) notification\n")    	X(TCP_STATS_ECN_RECV_ECE,		"ECNRcvECE",	"\t\t%llu time CWR was sent in response to ECE\n")      	X(TCP_STATS_ECN_SENT_ECE,		"ECNSndECE",	"\t\t%llu time sent ECE notification\n")        	X(TCP_STATS_ECN_ACE_RECV_CE,            "ACERcvECE",    "\t\t%llu CE count received in ACE field\n")      	X(TCP_STATS_ECN_CONN_RECV_CE,		"ECNConnRcvCE",	"\t\t%llu connection received CE atleast once\n")       	X(TCP_STATS_ECN_CONN_RECV_ECE,		"ECNConnRcvECE","\t\t%llu connection received ECE atleast once\n")      	X(TCP_STATS_ECN_CONN_PLNOCE,		"ECNConnPLNoCE","\t\t%llu connection using ECN have seen packet loss but no CE\n")      	X(TCP_STATS_ECN_CONN_PL_CE,		"ECNConnPLCE",	"\t\t%llu connection using ECN have seen packet loss and CE\n")         	X(TCP_STATS_ECN_CONN_NOPL_CE,		"ECNConnNoPLCE","\t\t%llu connection using ECN received CE but no packet loss\n")               	X(TCP_STATS_ECN_FALLBACK_SYNLOSS,	"ECNFbSYNLoss",	"\t\t%llu connection fell back to non-ECN due to SYN-loss\n")   	X(TCP_STATS_ECN_FALLBACK_REORDER,	"ECNFbReOrd",	"\t\t%llu connection fell back to non-ECN due to reordering\n") 	X(TCP_STATS_ECN_FALLBACK_CE,		"ECNFbCE",	"\t\t%llu connection fell back to non-ECN due to excessive CE-markings\n")      	X(TCP_STATS_ECN_FALLBACK_DROPRST,	"ECNFbDrpRST",	"\t\t%llu ECN fallback caused by connection drop due to RST\n") 	X(TCP_STATS_ECN_FALLBACK_DROPRXMT,	"ECNFbDrpReXmt","\t\t%llu ECN fallback due to drop after multiple retransmits\n")       	X(TCP_STATS_DETECT_REORDERING,		"ReOrdDetect",	"\t%llu time packet reordering was detected on a connection\n") 	X(TCP_STATS_REORDERED_PKTS,		"ReOrdPkt",	"\t\t%llu time transmitted packets were reordered\n")   	X(TCP_STATS_DELAY_RECOVERY,		"DlyFastRecvr",	"\t\t%llu time fast recovery was delayed to handle reordering\n")               	X(TCP_STATS_AVOID_RXMT,			"AvoidReXmt",	"\t\t%llu time retransmission was avoided by delaying recovery\n")      	X(TCP_STATS_UNNECESSARY_RXMT,		"UnNeedReXmt",	"\t\t%llu retransmission not needed\n")        	  	X(TCP_STATS_DSACK_SENT,			"DSACKSnd",	"\t%llu time DSACK option was sent\n")  	X(TCP_STATS_DSACK_RECVD,		"DSACKRcv",	"\t\t%llu time DSACK option was received\n")    	X(TCP_STATS_DSACK_DISABLE,		"DSACKDisable",	"\t\t%llu time DSACK was disabled on a connection\n")   	X(TCP_STATS_DSACK_BADREXMT,		"DSACKBadReXmt","\t\t%llu time recovered from bad retransmission using DSACK\n")        	X(TCP_STATS_DSACK_ACKLOSS,		"DSACKAckLoss",	"\t\t%llu time ignored DSACK due to ack loss\n")        	X(TCP_STATS_DSACK_RECVD_OLD,		"DSACKRcvOld",	"\t\t%llu time ignored old DSACK options\n")    	X(TCP_STATS_PMTUDBH_REVERTED,		"PMTUDBHRevert","\t%llu time PMTU Blackhole detection, size reverted\n")        	X(TCP_STATS_DROP_AFTER_SLEEP,		"DropAPSleep",	"\t%llu connection were dropped after long sleep\n")            	    	X(TCP_STATS_TFO_COOKIE_SENT,		"TFOCkSnd",	"\t%llu time a TFO-cookie has been announced\n")        	X(TCP_STATS_TFO_SYN_DATA_RCV,		"TFOSYNDataRcv","\t%llu SYN with data and a valid TFO-cookie have been received\n")     	X(TCP_STATS_TFO_COOKIE_REQ_RCV,		"TFOCkReqRcv",	"\t%llu SYN with TFO-cookie-request received\n")        	X(TCP_STATS_TFO_COOKIE_INVALID,		"TFOCkInv",	"\t%llu time an invalid TFO-cookie has been received\n")        	X(TCP_STATS_TFO_COOKIE_REQ,		"TFOCkReq",	"\t%llu time we requested a TFO-cookie\n")      	X(TCP_STATS_TFO_COOKIE_RCV,		"TFOCkRcv",	"\t\t%llu time the peer announced a TFO-cookie\n")      	X(TCP_STATS_TFO_SYN_DATA_SENT,		"TFOSYNDataSnd","\t%llu time we combined SYN with data and a TFO-cookie\n")     	X(TCP_STATS_TFO_SYN_DATA_ACKED,		"TDOSYNDataAck","\t\t%llu time our SYN with data has been acknowledged\n")      	X(TCP_STATS_TFO_SYN_LOSS,		"TFOSYNLoss",	"\t%llu time a connection-attempt with TFO fell back to regular TCP\n") 	X(TCP_STATS_TFO_BLACKHOLE,		"TFOBlackhole",	"\t%llu time a TFO-connection blackhole'd\n")   	X(TCP_STATS_TFO_COOKIE_WRONG,		"TFOCkWrong",	"\t%llu time TFO-cookie we sent was wrong\n")   	X(TCP_STATS_TFO_NO_COOKIE_RCV,		"TFONoCkRcv",	"\t%llu time ee asked for a cookie but didn't get one\n")       	X(TCP_STATS_TFO_HEURISTICS_DISABLE,	"TFOHeuDisable","\t%llu time TFO got disabled due to heuristics\n")     	X(TCP_STATS_TFO_SNDBLACKHOLE,		"TFOSndBH",	"\t%llu time TFO got blackholed in the sending direction\n")    	X(TCP_STATS_MSS_TO_DEFAULT,		"MSSToDefault",	"\t%llu time maximum segment size was changed to default\n")    	X(TCP_STATS_MSS_TO_MEDIUM,		"MSSToMedium",	"\t%llu time maximum segment size was changed to medium\n")     	X(TCP_STATS_MSS_TO_LOW,			"MSSToLow",	"\t%llu time maximum segment size was changed to low\n")                	      	X(TCP_STATS_TIMER_DRIFT_LE_1_MS,	"TmrDriftLE1Ms",	"\t%llu timer drift less or equal to 1 ms\n")   	X(TCP_STATS_TIMER_DRIFT_LE_10_MS,	"TmrDriftLE10Ms",	"\t%llu timer drift less or equal to 10 ms\n")  	X(TCP_STATS_TIMER_DRIFT_LE_20_MS,	"TmrDriftLE20Ms",	"\t%llu timer drift less or equal to 20 ms\n")  	X(TCP_STATS_TIMER_DRIFT_LE_50_MS,	"TmrDriftLE50Ms",	"\t%llu timer drift less or equal to 50 ms\n")  	X(TCP_STATS_TIMER_DRIFT_LE_100_MS,	"TmrDriftLE100Ms",	"\t%llu timer drift less or equal to 100 ms\n") 	X(TCP_STATS_TIMER_DRIFT_LE_200_MS,	"TmrDriftLE200Ms",	"\t%llu timer drift less or equal to 200 ms\n") 	X(TCP_STATS_TIMER_DRIFT_LE_500_MS,	"TmrDriftLE500Ms",	"\t%llu timer drift less or equal to 500 ms\n") 	X(TCP_STATS_TIMER_DRIFT_LE_1000_MS,	"TmrDriftLE1000Ms",	"\t%llu timer drift less or equal to 1000 ms\n")        	X(TCP_STATS_TIMER_DRIFT_GT_1000_MS,	"TmrDriftGT1000Ms",	"\t%llu timer drift greater than 1000 ms\n")    	X(TCP_STATS_USEDRTT,			"RTTUsed",	"\t%llu times RTT initialized from route\n")    	X(TCP_STATS_USEDRTTVAR,			"RTTVarUsed",	"\t%llu times RTTVAR initialized from rt\n")    	X(TCP_STATS_USEDSSTHRESH,		"SSTholdUsed",	"\t%llu times ssthresh initialized from rt\n")  	X(TCP_STATS_MINMSSDROPS,		"MinMssDrop",	"\t%llu average minmss too low drops\n")        	X(TCP_STATS_SNDREXMITBAD,		"BadReXmt",	"\t%llu unnecessary packet retransmissions\n")          	   	X(TCP_STATS_SC_ADDED,			"SCAdded",	"\t%llu entry added to syncache\n")     	X(TCP_STATS_SC_RETRANSMITTED,		"SCReXmt",	"\t%llu syncache entry was retransmitted\n")    	X(TCP_STATS_SC_DUPSYN,			"SCDupSYN",	"\t%llu duplicate SYN packet\n")        	X(TCP_STATS_SC_DROPPED,			"SCDrop",	"\t%llu could not reply to packet\n")   	X(TCP_STATS_SC_COMPLETED,		"SCCompl",	"\t%llu successful extraction of entry\n")      	X(TCP_STATS_SC_BUCKETOVERFLOW,		"SCBktOF",	"\t%llu syncache per-bucket limit hit\n")       	X(TCP_STATS_SC_CACHEOVERFLOW,		"SCOF",		"\t%llu syncache cache limit hit\n")    	X(TCP_STATS_SC_RESET,			"SCReset",	"\t%llu RST removed entry from syncache\n")     	X(TCP_STATS_SC_STALE,			"SCStale",	"\t%llu timed out or listen socket gone\n")     	X(TCP_STATS_SC_ABORTED,			"SCAbrt",	"\t%llu syncache entry aborted\n")      	X(TCP_STATS_SC_BADACK,			"SCBadAck",	"\t%llu removed due to bad ACK\n")      	X(TCP_STATS_SC_UNREACH,			"SCUnReach",	"\t%llu ICMP unreachable received\n")   	X(TCP_STATS_SC_ZONEFAIL,		"SCZoneFail",	"\t%llu zalloc() failed\n")     	X(TCP_STATS_SC_SENDCOOKIE,		"SCSndCookie",	"\t%llu SYN cookie sent\n")     	X(TCP_STATS_SC_RECVCOOKIE,		"SCRvcCookie",	"\t%llu SYN cookie received\n")         	  	X(TCP_STATS_HC_ADDED,			"HCAdd",	"\t%llu entry added to hostcache\n")            	X(TCP_STATS_HC_BUCKETOVERFLOW,		"HCBktOF",	"\t%llu hostcache per bucket limit hit\n")              	     	X(TCP_STATS_BG_RCVTOTAL,		"RcvBkgrdPkt",	"\t%llu total background packets received\n")   	X(TCP_STATS_MSG_UNOPKTS,		"MsgUnOrdPkt",	"\t%llu unordered packet on TCP msg stream\n")  	X(TCP_STATS_MSG_UNOAPPENDFAIL,		"MsgUnOrdFail",	"\t%llu failed to append unordered pkt\n")      	X(TCP_STATS_MSG_SNDWAITHIPRI,		"MsgSndW8HPrio","\t%llu send waiting for high priority data\n")         	       	X(TCP_STATS_MP_SNDPACKS,		"MPSndPkt",	"\t%llu data packet sent\n")    	X(TCP_STATS_MP_SNDBYTES,		"MPSndByte",	"\t%llu data byte sent\n")      	X(TCP_STATS_MP_RCVTOTAL,		"MPRcvTotal",	"\t%llu data packet received\n")        	X(TCP_STATS_MP_RCVBYTES,		"MPRcvByte",	"\t%llu data byte received\n")  	X(TCP_STATS_INVALID_MPCAP,		"InvMPCap",	"\t%llu packet with an invalid MPCAP option\n") 	X(TCP_STATS_INVALID_JOINS,		"InvMPJoin",	"\t%llu packet with an invalid MPJOIN option\n")        	X(TCP_STATS_MPCAP_FALLBACK,		"MPCapFail",	"\t%llu time primary subflow fell back to TCP\n")       	X(TCP_STATS_JOIN_FALLBACK,		"MPJoinFallBk",	"\t%llu time secondary subflow fell back to TCP\n")     	X(TCP_STATS_ESTAB_FALLBACK,		"EstFallBk",	"\t%llu DSS option drop\n")     	X(TCP_STATS_INVALID_OPT,		"InvOpt",	"\t%llu other invalid MPTCP option\n")  	X(TCP_STATS_MP_REDUCEDWIN,		"MPReducedWin",	"\t%llu time the MPTCP subflow window was reduced\n")   	X(TCP_STATS_MP_BADCSUM,			"MPBadCSum",	"\t%llu bad DSS checksum\n")    	X(TCP_STATS_MP_OODATA,			"MPOOData",	"\t%llu time received out of order data\n")     	X(TCP_STATS_MP_OUTOFWIN,		"MPOutOfWin",	"\t%llu Packet lies outside the shared recv window\n")  	X(TCP_STATS_JOIN_RXMTS,			"JoinAckReXmt",	"\t%llu join ack retransmits\n")        	X(TCP_STATS_TAILLOSS_RTO,		"TailLossTRO",	"\t%llu RTO due to tail loss\n")        	X(TCP_STATS_RECOVERED_PKTS,		"RecoveryPkt",	"\t%llu recovered after loss\n")        	X(TCP_STATS_NOSTRETCHACK,		"NoStrechAck",	"\t%llu disabled stretch ack algorithm on a connection\n")      	X(TCP_STATS_RESCUE_RXMT,		"SACKRsqReXmt", "\t%llu SACK rescue retransmit\n")              	     	X(TCP_STATS_MP_SWITCHES,		"MPSwitches",	"\t%llu subflow switch\n")      	X(TCP_STATS_MP_SEL_SYMTOMSD,		"MPSelSymp",	"\t%llu subflow switch due to advisory\n")      	X(TCP_STATS_MP_SEL_RTT,			"MPSelRTT",	"\t%llu subflow switch due to rtt\n")   	X(TCP_STATS_MP_SEL_RTO,			"MPSelRTO",	"\t%llu subflow switch due to rto\n")   	X(TCP_STATS_MP_SEL_PEER,		"MPSelPeer",	"\t%llu subflow switch due to peer\n")  	X(TCP_STATS_MP_NUM_PROBES,		"MPProbe",	"\t%llu number of subflow probe\n")     	X(TCP_STATS_MP_VERDOWNGRADE,		"MPVerDowngrd",	"\t%llu times MPTCP version downgrade\n")               	  	X(TCP_STATS_TW_PCBCOUNT,		"TWPcbCount",	"\t%llu pcbs in time-wait state\n")             	X(__TCP_STATS_MAX,			"",		"end of tcp stats")
UDP_STATS_TABLE(X) X(UDP_STATS_IPACKETS,			"RcvPkt",		"\t%llu datagram received\n")   	X(UDP_STATS_HDROPS,			"HdrDrop",		"\t\t%llu with incomplete header\n")    	X(UDP_STATS_BADSUM,			"BadCsum",		"\t\t%llu with bad data length field\n")        	X(UDP_STATS_BADLEN,			"BadLen",		"\t\t%llu with bad checksum\n") 	X(UDP_STATS_NOSUM,			"NoCsum",		"\t\t%llu with no checksum\n")  	X(UDP_STATS_RCV_SWCSUM,			"RcvSWCsum",		"\t\t%llu checksummed in software")     	X(UDP_STATS_RCV_SWCSUM_BYTES,		"RcvSWCsumBytes",	" (%llu bytes) over IPv4\n")    	X(UDP_STATS_RCV6_SWCSUM,		"RcvSWCsum",		"\t\t%llu checksummed in software")     	X(UDP_STATS_RCV6_SWCSUM_BYTES,		"RcvSWCsumBytes",	" (%llu bytes) over IPv6\n")    	X(UDP_STATS_NOPORT,			"NoPort",		"\t\t%llu dropped due to no socket\n")  	X(UDP_STATS_NOPORTBCAST,		"NoPortBCast",		"\t\t%llu broadcast/multicast datagram undelivered\n")  	X(UDP_STATS_FILTERMCAST,		"FilterMCast",		"\t\t%llu time multicast source filter matched\n")      	X(UDP_STATS_FULLSOCK,			"FullSock",		"\t\t%llu dropped due to full socket buffers\n")        	X(UDP_STATS_PCBCACHEMISS,		"PCBCacheMiss",		"\t\t%llu not for hashed pcb\n")        	X(UDP_STATS_PCBHASHMISS,		"PCBHashMiss",		"\t\t%llu input packets not for hashed pcb")            	      	X(UDP_STATS_OPACKETS,			"SndPkt",		"\t%llu datagram output\n")     	X(UDP_STATS_SND_SWCSUM,			"SndSWCsum",		"\t\t%llu checksummed in software")     	X(UDP_STATS_SND_SWCSUM_BYTES,		"SndSWCsumBytes",	" (%llu bytes) over IPv4\n")    	X(UDP_STATS_SND6_SWCSUM,		"SndSWCsum6",		"\t\t%llu checksummed in software")     	X(UDP_STATS_SND6_SWCSUM_BYTES,		"SndSWCsumBytes6",	" (%llu bytes) over IPv6\n")    	X(UDP_STATS_FASTOUT,			"SndFastPath",		"\t\t%llu output packets on fast path\n")       	X(UDP_STATS_NOPORTMCAST,		"SndNoPortMCast",	"\t\t%llu output no socket on port, multicast\n")               	X(__UDP_STATS_MAX,			"",			"end of UDP stats")
QUIC_STATS_TABLE(X) X(QUIC_STATS_SNDPKT,			"SndTotalPkt",		"\t%llu packets sent")  	X(QUIC_STATS_SNDBYTE,			"SndTotalByte",		" (%llu bytes)\n")      	 	X(QUIC_STATS_SNDSTREAMFRAME,		"SndStreamFrame",	"\t\tSTREAM\n\t\t\t%llu stream frames sent")    	X(QUIC_STATS_SNDSTREAMBYTE,		"SndStreamByte",	" (%llu bytes)\n")      	X(QUIC_STATS_SNDSTREAMRESET,		"SndStreamReset",	"\t\t\t%llu RESET_STREAM frames sent\n")        	X(QUIC_STATS_SNDSTOPSENDING,		"SndStopSending",	"\t\t\t%llu STOP_SENDING frames sent\n")        	X(QUIC_STATS_SNDSTREAMBLKFRAME,		"SndStreamBlockedFrame","\t\t\t%llu STREAM_BLOCKED frames sent\n")      	X(QUIC_STATS_SNDSTMDATABLKFRAME,	"SndStreamDataBlocked",	"\t\t\t%llu STREAM_DATA_BLOCKED frames sent\n") 	 	X(QUIC_STATS_SNDINITCRYPTOFRAME,	"SndInitCryptoFrame",	"\t\tCRYPTO\n\t\t\t%llu initial CRYPTO frames sent")    	X(QUIC_STATS_SNDINITCRYPTOBYTE,		"SndInitCryptoByte",	" (%llu bytes)\n")      	X(QUIC_STATS_SNDHDSHKCRYPTOFRAME,	"SndHdShkCryptoFrame",	"\t\t\t%llu handshake CRYPTO frames sent")      	X(QUIC_STATS_SNDHDSHKCRYPTOBYTE,	"SndHdShkCryptoByte",	" (%llu bytes)\n")      	X(QUIC_STATS_SND1RTTCRYPTOFRAME,	"Snd1RttCryptoFrame",	"\t\t\t%llu 1-RTT CRYPTO frames sent")  	X(QUIC_STATS_SND1RTTCRYPTOBYTE,		"Snd1RttCryptoByte",	" (%llu bytes)\n")      	X(QUIC_STATS_SND0RTTCRYPTOFRAME,	"Snd1RttCryptoFrame",	"\t\t\t%llu 0-RTT CRYPTO frames sent")  	X(QUIC_STATS_SND0RTTCRYPTOBYTE,		"Snd1RttCryptoByte",	" (%llu bytes)\n")      	X(QUIC_STATS_SNDCRYPTOREXMTFRAME,	"SndReXmtCryptoFrame",	"\t\t\t%llu CRYPTO frames retransmitted")       	X(QUIC_STATS_SNDCRYPTOREXMTBYTE,	"SndReXmtCryptoByte",	" (%llu bytes)\n")      	X(QUIC_STATS_SNDDATABLKFRAME,		"SndDataBlockedFrame",	"\t\t%llu DATA_BLOCKED frames sent\n")  	X(QUIC_STATS_SNDREXMTPKT,		"SndReXmtPkt",		"\t\t%llu packets retransmitted")       	X(QUIC_STATS_SNDREXMTBYTE,		"SndReXmtByte",		" (%llu bytes)\n")      	X(QUIC_STATS_SNDLOSTPKT,		"SndLostPkt",		"\t\t%llu packets lost")        	X(QUIC_STATS_SNDLOSTBYTE,		"SndLostByte",		" (%llu bytes)\n")      	 	        	X(QUIC_STATS_RCVPKT,			"RcvTotalPkt",		"\t%llu packets received")      	X(QUIC_STATS_RECVBYTE,			"RcvTotalByte",		" (%llu bytes)\n")      	 	X(QUIC_STATS_RCVSTREAMFRAME,		"RcvStreamFrame",	"\t\tSTREAM\n\t\t\t%llu stream frames received")        	X(QUIC_STATS_RCVSTREAMBYTE,		"RcvStreamByte",	" (%llu bytes)\n")      	X(QUIC_STATS_RCVSTREAMRESET,		"RcvStreamReset",	"\t\t\t%llu RESET_STREAM frames received\n")    	X(QUIC_STATS_RCVSTOPSENDING,		"RcvStopSending",	"\t\t\t%llu STOP_SENDING frames received\n")    	X(QUIC_STATS_RCVSTREAMBLKFRAME,		"RcvStreamBlockedFrame","\t\t\t%llu STREAM_BLOCKED frames received\n")  	X(QUIC_STATS_RCVSTMDATABLKFRAME,	"RcvStreamDataBlocked",	"\t\t\t%llu STREAM_DATA_BLOCKED frames received\n")     	 	X(QUIC_STATS_RCVINITCRYPTOFRAME,	"RcvInitCryptoFrame",	"\t\tCRYPTO\n\t\t\t%llu initial CRYPTO frames received")        	X(QUIC_STATS_RCVINITCRYPTOBYTE,		"RcvInitCryptoByte",	" (%llu bytes)\n")      	X(QUIC_STATS_RCVHDSHKCRYPTOFRAME,	"RcvHdShkCryptoFrame",	"\t\t\t%llu handshake CRYPTO frames received")  	X(QUIC_STATS_RCVHDSHKCRYPTOBYTE,	"RcvHdShkCryptoByte",	" (%llu bytes)\n")      	X(QUIC_STATS_RCV1RTTCRYPTOFRAME,	"Rcv1RttCryptoFrame",	"\t\t\t%llu 1-RTT CRYPTO frames received")      	X(QUIC_STATS_RCV1RTTCRYPTOBYTE,		"Rcv1RttCryptoByte",	" (%llu bytes)\n")      	X(QUIC_STATS_RCV0RTTCRYPTOFRAME,	"Rcv0RttCryptoFrame",	"\t\t\t%llu 0-RTT CRYPTO frames received")      	X(QUIC_STATS_RCV0RTTCRYPTOBYTE,		"Rcv0RttCryptoByte",	" (%llu bytes)\n")      	X(QUIC_STATS_RCVDATABLKFRAME,		"RcvDataBlockedFrame",	"\t\t%llu DATA_BLOCKED frames received\n")      	X(QUIC_STATS_RCVREORDERPKT,		"RcvReorderedPkt",	"\t\t%llu packets received reordered")  	X(QUIC_STATS_RCVREORDERBYTE,		"RcvReorderedByte",	" (%llu bytes)\n")      	       	X(QUIC_STATS_CONNECTS,			"ConnEst",		"\t%llu connections established\n")     	X(QUIC_STATS_SNDCCR,			"SndCCR",		"\t\t%llu connection close reasons sent\n")     	X(QUIC_STATS_SNDCCRINTERROR,		"SndCCRInternalError",	"\t\t\t%llu INTERNAL_ERROR sent\n")     	X(QUIC_STATS_SNDCCRSVRBUSY,		"SndCCRSererBusy",	"\t\t\t%llu SERVER_BUSY sent\n")        	X(QUIC_STATS_SNDCCRFLOWCTLERR,		"SndCCRFlowCtl",	"\t\t\t%llu FLOW_CONTROL_ERROR sent\n") 	X(QUIC_STATS_SNDCCRSTREAMLIMIT,		"SndCCRStreamLimit",	"\t\t\t%llu STREAM_LIMIT_ERROR sent\n") 	X(QUIC_STATS_SNDCCRSTREAMSTATE,		"SndCCRStreamState",	"\t\t\t%llu STREAM_STATE_ERROR sent\n") 	X(QUIC_STATS_SNDCCRFINALOFFSET,		"SndCCRFinalOffset",	"\t\t\t%llu FINAL_SIZE_ERROR sent\n")   	X(QUIC_STATS_SNDCCRFRAMEENCODING,	"SndCCRFrameEncoding",	"\t\t\t%llu FRAME_ENCODING_ERROR sent\n")       	X(QUIC_STATS_SNDCCRTRNASPARAMS,		"SndCCRTransportParams","\t\t\t%llu TRANSPORT_PARAMETER_ERROR sent\n")  	X(QUIC_STATS_SNDCCRVERSIONNEGO,		"SndCCRVersionNego",	"\t\t\t%llu VERSION_NEGOTIATION_ERROR sent\n")  	X(QUIC_STATS_SNDCCRPROTOVIOLATION,	"SndCCRProtoViolation",	"\t\t\t%llu PROTOCOL_VIOLATION sent\n") 	X(QUIC_STATS_SNDCCRINVALMIGRATION,	"SndCCRInvalMigration",	"\t\t\t%llu INVALID_MIGRATION sent\n")  	X(QUIC_STATS_SNDCCRCRYPTO,		"SndCCRCryptoError",	"\t\t\t%llu CRYPTO_ERROR sent\n")       	X(QUIC_STATS_RCVCCR,			"RcvCCR",		"\t\t%llu connection close reasons received\n") 	X(QUIC_STATS_RCVCCRINTERROR,		"RcvCCRInternalError",	"\t\t\t%llu INTERNAL_ERROR received\n") 	X(QUIC_STATS_RCVCCRSVRBUSY,		"RcvCCRSererBusy",	"\t\t\t%llu SERVER_BUSY received\n")    	X(QUIC_STATS_RCVCCRFLOWCTLERR,		"RcvCCRFlowCtl",	"\t\t\t%llu FLOW_CONTROL_ERROR received\n")     	X(QUIC_STATS_RCVCCRSTREAMLIMIT,		"RcvCCRStreamLimit",	"\t\t\t%llu STREAM_LIMIT_ERROR received\n")     	X(QUIC_STATS_RCVCCRSTREAMSTATE,		"RcvCCRStreamState",	"\t\t\t%llu STREAM_STATE_ERROR received\n")     	X(QUIC_STATS_RCVCCRFINALOFFSET,		"RcvCCRFinalOffset",	"\t\t\t%llu FINAL_SIZE_ERROR received\n")       	X(QUIC_STATS_RCVCCRFRAMEENCODING,	"RcvCCRFrameEncoding",	"\t\t\t%llu FRAME_ENCODING_ERROR received\n")   	X(QUIC_STATS_RCVCCRTRNASPARAMS,		"RcvCCRTransportParams","\t\t\t%llu TRANSPORT_PARAMETER_ERROR received\n")      	X(QUIC_STATS_RCVCCRVERSIONNEGO,		"RcvCCRVersionNego",	"\t\t\t%llu VERSION_NEGOTIATION_ERROR received\n")      	X(QUIC_STATS_RCVCCRPROTOVIOLATION,	"RcvCCRProtoViolation",	"\t\t\t%llu PROTOCOL_VIOLATION received\n")     	X(QUIC_STATS_RCVCCRINVALMIGRATION,	"RcvCCRInvalMigration",	"\t\t\t%llu INVALID_MIGRATION received\n")      	X(QUIC_STATS_RCVCCRCRYPTO,		"RcvCCRCryptoError",	"\t\t\t%llu CRYPTO_ERROR received\n")   	X(QUIC_STATS_SNDECT0,			"SndECT0",		"\t%llu ECT0 sent\n")   	X(QUIC_STATS_RCVECT0,			"RcvECT0",		"\t%llu ECT0 received\n")       	X(QUIC_STATS_SNDECT1,			"SndECT1",		"\t%llu ECT1 sent\n")   	X(QUIC_STATS_RCVECT1,			"RcvECT1",		"\t%llu ECT1 received\n")       	X(QUIC_STATS_SNDECTCE,			"SndECTCE",		"\t%llu ECT-CE sent\n") 	X(QUIC_STATS_RCVECTCE,			"RcvECTCE",		"\t%llu ECT-CE received\n")     	X(QUIC_STATS_REXMTTIMEOUT,		"ReXmtTimeOut",		"\t%llu retransmit timeout\n")  	X(QUIC_STATS_KEEPALIVETTIMEOUT,		"KeepAliveTimeOut",	"\t%llu keepalive timeout\n")   	X(QUIC_STATS_PTO,			"ProbeTimeOut",		"\t%llu probe timeout\n")               	X(__QUIC_STATS_MAX,			"",			"end of quic stats\n")
NETIF_STATS_TABLE(X) X(NETIF_STATS_RX_PACKETS,		"RxPackets",		"\t%llu total Rx packets\n")    	X(NETIF_STATS_RX_IRQ,			"RxIRQ",		"\t\t%llu interrupts\n")        	X(NETIF_STATS_RX_IRQ_MIT,		"RxIRQMIT",		"\t\t\t%llu interrupt mitigation thread wakeup\n")      	X(NETIF_STATS_RX_IRQ_BUSY,		"RxIRQBusy",		"\t\t\t%llu interrupt notify return busy\n")    	X(NETIF_STATS_RX_IRQ_AGAIN,		"RxIRQAgain",		"\t\t\t%llu interrupt notify return retry again\n")     	X(NETIF_STATS_RX_IRQ_ERR,		"RxIRQErr",		"\t\t\t%llu interrupt notify return error\n")   	X(NETIF_STATS_RX_COPY_SUM,		"RxCopySum",		"\t\t%llu copy+checksumed\n")   	X(NETIF_STATS_RX_COPY_DIRECT,		"RxCopyDirect",         "\t\t%llu copy from pkt\n")     	X(NETIF_STATS_RX_COPY_MBUF,		"RxCopyMbuf",		"\t\t%llu copy from mbuf\n")    	X(NETIF_STATS_RX_COPY_ATTACH,		"RxCopyAttach",         "\t\t%llu copy by attaching mbuf under pkt\n")  	X(NETIF_STATS_RX_SYNC,			"RxSYNC",		"\t\t%llu sync\n")              	  	X(NETIF_STATS_TX_PACKETS,		"TxPkt",		"\t%llu total Tx packets\n")    	X(NETIF_STATS_TX_IRQ,			"TxIRQ",		"\t\t%llu interupts\n") 	X(NETIF_STATS_TX_IRQ_MIT,		"TxIRQMIT",		"\t\t\t%llu interrupt mitigation thread wakeup\n")      	X(NETIF_STATS_TX_IRQ_BUSY,		"TxIRQBusy",		"\t\t\t%llu interrupt notify return busy\n")    	X(NETIF_STATS_TX_IRQ_AGAIN,		"TxIRQAgain",		"\t\t\t%llu interrupt notify return retry again\n")     	X(NETIF_STATS_TX_IRQ_ERR,		"TxIRQErr",		"\t\t\t%llu interrupt notify return error\n")   	X(NETIF_STATS_TX_COPY_SUM,		"TxCopySum",		"\t\t%llu copy+checksumed\n")   	X(NETIF_STATS_TX_COPY_DIRECT,		"TxCopyDirect",		"\t\t%llu copy from pkt\n")     	X(NETIF_STATS_TX_COPY_MBUF,		"TxCopyMbuf",		"\t\t%llu copy from mbuf\n")    	X(NETIF_STATS_TX_SYNC,			"TxSYNC",		"\t\t%llu sync\n")      	X(NETIF_STATS_TX_REPL,			"TxRepl",		"\t\t%llu pool replenished\n")  	X(NETIF_STATS_TX_DROP_ENQ_AQM,		"TxDropEnqueueAQM",     "\t\t%llu dropped due to AQM enqueue failure\n")        	X(NETIF_STATS_GSO_SEG,			"GSOSegments",          "\t\t%llu GSO segments created\n") 	X(NETIF_STATS_GSO_PKT,			"GSOPackets",           "\t\t%llu GSO packets \n") 	X(NETIF_STATS_GSO_PKT_DROP_NOMEM,	"GSODropNoMem",         "\t\t%llu GSO packet dropped due to allocation failure\n") 	X(NETIF_STATS_GSO_PKT_DROP_NA_INACTIVE,	"GSODropNaInactive",    "\t\t%llu GSO packet dropped due to inactive netif\n") 	X(NETIF_STATS_GSO_PKT_DROP_BADLEN,	"GSODropBadLen",        "\t\t%llu GSO packet dropped due to bad packet length\n") 	X(NETIF_STATS_GSO_PKT_DROP_NONTCP,	"GSODropNonTcp",        "\t\t%llu GSO packet dropped as it is not a TCP packet\n")         	X(NETIF_STATS_DROP,			"Drop",			"\t%llu dropped\n")     	X(NETIF_STATS_DROP_NOMEM_BUF,		"DropNoMemBuf",		"\t\t%llu dropped due to packet alloc failure\n")       	X(NETIF_STATS_DROP_NOMEM_PKT,		"DropNoMemPkt",		"\t\t%llu dropped due to buflet alloc failure\n")       	X(NETIF_STATS_DROP_NOMEM_MBUF,		"DropNoMemMbuf",	"\t\t%llu dropped due to mbuf alloc failure\n") 	X(NETIF_STATS_DROP_BADLEN,		"DropBadLen",		"\t\t%llu dropped due to bad packet length\n")  	X(NETIF_STATS_DROP_NA_INACTIVE,		"DropNaInactive",	"\t\t%llu dropped due to dst na inactive\n")    	X(NETIF_STATS_DROP_KRDROP_MODE,		"DropKrDropMode",	"\t\t%llu dropped due to dst kring in drop mode\n")     	X(NETIF_STATS_DROP_RXQ_OVFL,		"DropRxqOverflow",	"\t\t%llu dropped due to RX Queue overflow\n")     	X(NETIF_STATS_DROP_NO_RX_CB,		"DropNoRxCallback",	"\t\t%llu dropped due to missing RX callback\n") 	X(NETIF_STATS_DROP_NO_DELEGATE,		"DropNoDelegate",	"\t\t%llu dropped due to missing delegate interface\n") 	X(NETIF_STATS_DROP_INPUT_DISABLED,	"DropInputDisabled",	"\t\t%llu dropped due to input disabled on interface\n")         	  	X(NETIF_STATS_EV_RECV,			"EvRecv",		"\t%llu channel event received\n")     	X(NETIF_STATS_EV_RECV_TX_STATUS,	"EvRecvTxStatus",	"\t\t%llu channel event received, TX status\n")     	X(NETIF_STATS_EV_RECV_TX_EXPIRED,       "EvRecvTxExpired",	"\t\t%llu channel event received, TX expired\n")     	X(NETIF_STATS_EV_SENT,			"EvSent",		"\t%llu channel event delivered\n")     	X(NETIF_STATS_EV_DROP,			"EvDrop",		"\t%llu channel event dropped\n")     	X(NETIF_STATS_EV_DROP_NOMEM_PKT,	"EvDropNoMemPkt",	"\t%llu channel event dropped due to packet alloc failure\n")     	X(NETIF_STATS_EV_DROP_NA_INACTIVE,	"EvDropNaInactive",	"\t%llu channel event dropped due to na inactive\n")     	X(NETIF_STATS_EV_DROP_NA_DEFUNCT,	"EvDropNaDefunct",	"\t%llu channel event dropped due to na defunct\n")     	X(NETIF_STATS_EV_DROP_KRDROP_MODE,	"EvDropKrDropMode",	"\t%llu channel event dropped due to dst kring in drop mode\n")     	X(NETIF_STATS_EV_DROP_KEVENT_INACTIVE,	"EvDropKevInactive",	"\t%llu channel event dropped due to kevent not registered on channel\n")     	X(NETIF_STATS_EV_DROP_KRSPACE,		"EvDropKrSpaceDrop",	"\t%llu channel event dropped due to lack of space in user channel ring\n") 	X(NETIF_STATS_EV_DROP_DEMUX_ERR,	"EvDropDemuxErr",	"\t%llu channel event dropped due to demux error\n") 	X(NETIF_STATS_EV_DROP_EV_VPNA_NOTSUP,	"EvDropVpnaEvNotSup",	"\t%llu channel event dropped due to vpna not having event ring\n") 	X(NETIF_STATS_EV_DROP_NO_VPNA,		"EvDropNoVpna",		"\t%llu channel event dropped due to no vpna ports\n")         	  	X(NETIF_STATS_IF_ADV_UPD_RECV,		"IfAdvUpdRecv",		"\t%llu interface advisory update received\n") 	X(NETIF_STATS_IF_ADV_UPD_SENT,		"IfAdvUpdSent",		"\t%llu interface advisory update event sent\n") 	X(NETIF_STATS_IF_ADV_UPD_DROP,		"IfAdvUpdDrop",		"\t%llu interface advisory update event dropped\n")         	 	X(NETIF_STATS_FILTER_DROP_NO_RX_CB,	"FilterDropNoRxCB",	"\t%llu dropped due to missing RX callback\n") 	X(NETIF_STATS_FILTER_DROP_DISABLED,	"FilterDropDisabled",	"\t%llu dropped due to disabled filter\n") 	X(NETIF_STATS_FILTER_DROP_REMOVED,	"FilterDropRemoved",	"\t%llu dropped due to removed filter\n") 	X(NETIF_STATS_FILTER_DROP_PKTQ_FULL,	"FilterDropPktqFull",	"\t%llu dropped due to packet queue full\n") 	X(NETIF_STATS_FILTER_DROP_MBQ_FULL,	"FilterDropMbqFull",	"\t%llu dropped due to mbuf queue full\n") 	X(NETIF_STATS_FILTER_DROP_DISABLED_RING,"FilterDropDisabledRing","\t%llu dropped due to disabled ring\n") 	X(NETIF_STATS_FILTER_DROP_NO_SPACE,	"FilterDropNoSpace",	"\t%llu dropped due to lack of space in RX ring\n") 	X(NETIF_STATS_FILTER_DROP_INTERNALIZE,	"FilterDropInternalize","\t%llu dropped due to internalize failure\n") 	X(NETIF_STATS_FILTER_DROP_PKT_ALLOC_FAIL,"FilterDropPktAllocFail","\t%llu dropped due to packet allocation failure\n") 	X(NETIF_STATS_FILTER_DROP_DEFAULT,	"FilterDropDefault",	"\t%llu dropped due to default drop policy\n") 	X(NETIF_STATS_FILTER_PKT_TRUNCATED,	"FilterPktTruncated",	"\t%llu inbound packets truncated\n") 	X(NETIF_STATS_FILTER_TX_DELIVER,	"FilterTxDeliver",	"\t%llu outbound packets delivered to filter\n") 	X(NETIF_STATS_FILTER_RX_DELIVER,	"FilterRxDeliver",	"\t%llu inbound packets delivered to filter\n") 	X(NETIF_STATS_FILTER_TX_INJECT,		"FilterTxInject",	"\t%llu outbound packets injected by filter\n") 	X(NETIF_STATS_FILTER_RX_INJECT,		"FilterRxInject",	"\t%llu inbound packets injected by filter\n") 	X(NETIF_STATS_FILTER_TX_ENTER,		"FilterTxEnter",	"\t%llu outbound packets entered the filter chain\n") 	X(NETIF_STATS_FILTER_RX_ENTER,		"FilterRxEnter",	"\t%llu inbound packets entered the filter chain\n") 	X(NETIF_STATS_FILTER_TX_EXIT,		"FilterTxExit",		"\t%llu outbound packets exited the filter chain\n") 	X(NETIF_STATS_FILTER_RX_EXIT,		"FilterRxExit",		"\t%llu inbound packets exited the filter chain\n") 	X(NETIF_STATS_FILTER_SYNC_NO_PKTS,	"FilterSyncNoPkts",	"\t%llu filter syncs called with an empty ring\n") 	X(NETIF_STATS_FILTER_ADD,		"FilterAdd",		"\t%llu filters added\n") 	X(NETIF_STATS_FILTER_REMOVE,		"FilterRemove",		"\t%llu filters removed\n") 	X(NETIF_STATS_FILTER_TX_FLUSH,		"FilterTxFlush",	"\t%llu TX packets flushed due to closing filters\n") 	X(NETIF_STATS_FILTER_RX_NOT_FILTERABLE,	"FilterRxNotFilterable","\t%llu RX packets not filterable\n") 	X(NETIF_STATS_FILTER_BAD_PKT_LEN,	"FilterBadPktLen",	"\t%llu invalid packet length\n")         	 	X(NETIF_STATS_VP_DROP_USER_RING_DISABLED,"VPDropUserRingDisabled","\t%llu dropped due to disabled user ring\n") 	X(NETIF_STATS_VP_DROP_DEV_RING_DISABLED,"VPDropDevRingDisabled","\t%llu dropped due to disabled device ring\n") 	X(NETIF_STATS_VP_DROP_USER_RING_NO_SPACE,"VPDropUserRingNoSpace","\t%llu dropped due to lack of user ring space\n") 	X(NETIF_STATS_VP_DROP_DEV_RING_NO_SPACE,"VPDropDevRingNoSpace",	"\t%llu dropped due to lack of device ring space\n") 	X(NETIF_STATS_VP_DROP_RX_ALLOC_FAIL,	"VPDropRxAllocFail",	"\t%llu dropped due to RX allocation failure\n") 	X(NETIF_STATS_VP_DROP_TX_ALLOC_FAIL,	"VPDropTxAllocFail",	"\t%llu dropped due to TX allocation failure\n") 	X(NETIF_STATS_VP_DROP_PKT_TOO_BIG,	"VPDropPktTooBig",	"\t%llu dropped due to packet being too big\n") 	X(NETIF_STATS_VP_DROP_INTERNALIZE_FAIL,	"VPDropInternalizeFail","\t%llu dropped due to internalize failure\n") 	X(NETIF_STATS_VP_DROP_UNEXPECTED_ERR,	"VPDropUnexpectedErr",	"\t%llu dropped due to unexpected TX sync error\n") 	X(NETIF_STATS_VP_BAD_MADDR_LEN,		"VPBadMaddrLen",	"\t%llu packets with invalid mac address length\n") 	X(NETIF_STATS_VP_BAD_MADDR,		"VPBadMaddr",		"\t%llu packets with invalid mac address\n") 	X(NETIF_STATS_VP_BAD_PKT_LEN,		"VPBadPktLen",		"\t%llu packets invalid packet length\n") 	X(NETIF_STATS_VP_FLOW_INFO_ERR,		"VPFlowInfoErr",	"\t%llu packets cannot be classified due to flow info error\n") 	X(NETIF_STATS_VP_FLOW_NOT_MATCH,	"VPFlowNotMatch",	"\t%llu packets not matching flow description\n") 	X(NETIF_STATS_VP_KR_ENTER_FAIL,		"VPKrEnterFail",	"\t%llu failed attempts to acquire RX ring lock\n") 	X(NETIF_STATS_VP_DEV_RING_DISABLED,	"VPDevRingDisabled",	"\t%llu failed attempts to get packets due to disabled dev ring\n") 	X(NETIF_STATS_VP_SYNC_UNKNOWN_ERR,	"VPSyncUnknownErr",	"\t%llu unknown errors returned by RX sync\n") 	X(NETIF_STATS_VP_SYNC_NO_PKTS,		"VPSyncNoPkts",		"\t%llu syncs called with an empty ring\n") 	X(NETIF_STATS_VP_SPURIOUS_NOTIFY,	"VPSpuriousNotify",	"\t%llu spurious notifies delivered\n") 	X(NETIF_STATS_VP_ENQUEUE_FAILED,	"VPEnqueueFailed",	"\t%llu packets failed to enqueue\n") 	X(NETIF_STATS_VP_ENQUEUED,		"VPEnqueued",		"\t%llu packets enqueued\n") 	X(NETIF_STATS_VP_LL_ENQUEUED,		"VPLLEnqueued",		"\t%llu low latency packets enqueued\n") 	X(NETIF_STATS_VP_LL_SENT,		"VPLLSent",		"\t%llu low latency packets sent\n") 	X(NETIF_STATS_VP_LL_DELIVERED,		"VPLLDelivered",	"\t%llu low latency packets delivered\n") 	X(NETIF_STATS_VP_DELIVERED,		"VPDelivered",		"\t%llu packets delivered\n") 	X(NETIF_STATS_VP_FLOW_FOUND,		"VPFlowFound",		"\t%llu packets found a matching flow\n") 	X(NETIF_STATS_VP_FLOW_NOT_FOUND,	"VPFlowNotFound",	"\t%llu packets found no matching flow\n") 	X(NETIF_STATS_VP_FLOW_DISABLED,		"VPFlowDisabled",	"\t%llu lookup failures due to disabled flow\n") 	X(NETIF_STATS_VP_FLOW_EMPTY_TABLE,	"VPFlowEmptyTable",	"\t%llu lookup failures due to empty flow table\n") 	X(NETIF_STATS_VP_FLOW_TABLE_INIT_FAIL,	"VPFlowTableInitFail",	"\t%llu failed attempts to initialize flow table\n") 	X(NETIF_STATS_VP_FLOW_INSERT_FAIL,	"VPFlowInsertFail",	"\t%llu failed attempts to insert flow\n") 	X(NETIF_STATS_VP_FLOW_ADD,		"VPFlowAdd",		"\t%llu flows added\n") 	X(NETIF_STATS_VP_FLOW_REMOVE,		"VPFlowRemove",		"\t%llu flows removed\n")         	 	X(NETIF_STATS_AGENT_BAD_ETHERTYPE,	"AgentBadEthertype",	"\t%llu flow add failures due to invalid ethertype\n") 	X(NETIF_STATS_AGENT_BAD_IPV6_ADDR,	"AgentBadIPv6Addr",	"\t%llu flow add failures due to invalid IPv6 address\n") 	X(NETIF_STATS_AGENT_DUP_FLOW,		"AgentDupFlow",		"\t%llu duplicate flows added\n")         	 	X(NETIF_STATS_LLINK_ADD,		"LLinkAdd",		"\t%llu logical links added\n") 	X(NETIF_STATS_LLINK_REMOVE,		"LLinkRemove",		"\t%llu logical links removed\n") 	X(NETIF_STATS_LLINK_DEF_QSET_USED,	"LLinkDefQSetUsed",	"\t%llu uses of the default qset\n") 	X(NETIF_STATS_LLINK_NONDEF_QSET_USED,	"LLinkNonDefQSetUsed",	"\t%llu uses of a non-default qset\n") 	X(NETIF_STATS_LLINK_HINT_NOT_USEFUL,	"LLinkHintNotUseful",	"\t%llu hints specified but qset not found\n") 	X(NETIF_STATS_LLINK_DUP_INT_ID_GENERATED, "LLinkDupIntIDGenerated", "\t%llu duplicate internal llink IDs generated\n") 	X(NETIF_STATS_LLINK_DUP_ID_GIVEN,	"LLinkDupIDGiven",	"\t%llu duplicate llink IDs given by the provider\n") 	X(NETIF_STATS_LLINK_QSET_INIT_FAIL,	"LLinkQSetInitFail",	"\t%llu queue set initialization failures\n") 	X(NETIF_STATS_LLINK_RXQ_INIT_FAIL,	"LLinkRXQInitFail",	"\t%llu RX queue initialization failures\n") 	X(NETIF_STATS_LLINK_TXQ_INIT_FAIL,	"LLinkTXQInitFail",	"\t%llu TX queue initialization failures\n") 	X(NETIF_STATS_LLINK_NOT_FOUND_REMOVE,	"LLinkNotFoundRemove",	"\t%llu not found during remove\n") 	X(NETIF_STATS_LLINK_TX_DROP_BAD_STATE,	"LLinkTxDroppedBadState", "\t%llu TX packets dropped due to bad llink state\n") 	X(NETIF_STATS_LLINK_RX_DROP_BAD_STATE,	"LLinkRxDroppedBadState", "\t%llu RX packets dropped due to bad llink state\n") 	X(NETIF_STATS_LLINK_AQM_QFULL,		"LLinkAQMQFull",	"\t%llu occurances of the queue full condition\n") 	X(NETIF_STATS_LLINK_AQM_DROPPED,	"LLinkAQMDropped",	"\t%llu packets dropped due to AQM\n") 	X(NETIF_STATS_LLINK_AQM_DEQ_BAD_STATE,	"LLinkAQMDeqBadState",	"\t%llu dequeues occurred while llink is in a bad state\n") 	X(NETIF_STATS_LLINK_QSET_BAD_STATE,	"LLinkQSetAccessBadState", "\t%llu attempts to access a queue set while in bad llink state\n") 	X(NETIF_STATS_LLINK_ADD_BAD_PARAMS,	"LLinkAddBadParams",	"\t%llu attempts to add an llink with bad parameters\n")         	X(__NETIF_STATS_MAX,			"",			"end of netif stats")
FSW_FPD_STATS(X) X(FSW_STATS_FPD_0,			"",	"\t%llu")       	X(FSW_STATS_FPD_1,			"",	"\t%llu")       	X(FSW_STATS_FPD_2,			"",	"\t%llu")       	X(FSW_STATS_FPD_3,			"",	"\t%llu")       	X(FSW_STATS_FPD_4,			"",	"\t%llu")       	X(FSW_STATS_FPD_5,			"",	"\t%llu")       	X(FSW_STATS_FPD_6,			"",	"\t%llu")       	X(FSW_STATS_FPD_7,			"",	"\t%llu")       	X(FSW_STATS_FPD_8,			"",	"\t%llu")       	X(FSW_STATS_FPD_9,			"",	"\t%llu")       	X(FSW_STATS_FPD_10,		        "",	"\t%llu")       	X(FSW_STATS_FPD_11,			"",	"\t%llu")
FSW_STATS_TABLE(X) X(FSW_STATS_RX_PACKETS,			"RxPackets",		"\t%llu total Rx packet\n")     	X(FSW_STATS_RX_DEMUX_ERR,		"RxDemuxErr",		"\t\t%llu demux error (passed to BSD)\n")       	X(FSW_STATS_RX_DEMUX_UNSPEC,		"RxDemuxUnspec",	"\t\t%llu demux AF unkown (passed to BSD)\n")       	X(FSW_STATS_RX_DEMUX_PROMISC,		"RxDemuxPromisc",	"\t\t%llu promiscuous packets (passed to BSD)\n")  	X(FSW_STATS_RX_FLOW_EXTRACT_ERR,	"RxFlowExtractErr",	"\t\t%llu flow extract error (passed to BSD)\n")       	X(FSW_STATS_RX_PKT_NOT_FINALIZED,	"RxPktNotFinalized",	"\t\t%llu packet not finalized\n")  	X(FSW_STATS_RX_FLOW_NOT_FOUND,		"RxFlowNotFound",	"\t\t%llu dropped, flow lookup failure\n")        	X(FSW_STATS_RX_FLOW_TRACK_ERR,		"RxFlowTrackErr",	"\t\t%llu dropped, flow tracker error\n") 	X(FSW_STATS_RX_FLOW_NONVIABLE,		"RxFlowNonviable",	"\t\t%llu dropped, flow already nonviable\n") 	X(FSW_STATS_RX_FLOW_TORNDOWN,		"RxFlowTornDown",	"\t\t%llu dropped, flow already torndown\n")      	X(FSW_STATS_RX_DST_RING_FULL,		"RxDstRingFull",	"\t\t%llu dropped, destination ring full\n") 	X(FSW_STATS_RX_COPY_PKT2PKT,		"RxCopyPktToPkt",	"\t\t%llu copied pkt  -> pkt\n")        	X(FSW_STATS_RX_COPY_PKT2MBUF,		"RxCopyPktToMbuf",	"\t\t%llu copied pkt  -> mbuf\n")       	X(FSW_STATS_RX_COPY_MBUF2PKT,		"RxCopyMbufToPkt",	"\t\t%llu copied mbuf -> pkt\n")        	X(FSW_STATS_RX_COPY_SUM,		"RxCopySum",		"\t\t%llu copy+checksumed\n")   	X(FSW_STATS_RX_COPY_BAD_LEN,		"RxCopyBadLen",		"\t\t%llu dropped, bad packet length\n")  	X(FSW_STATS_RX_DROP_NOMEM_BUF,		"RxDropNoMemBuf",	"\t\t%llu dropped due to mbuf alloc failure\n") 	X(FSW_STATS_RX_DEMUX_SHORT_ERR,		"RxDemuxShortErr",	"\t\t%llu demux failed, classify length short\n") 	X(FSW_STATS_RX_WASTED_16KMBUF,		 "RxWasted16KMbuf",	"\t\t%llu wasted an entire pre-allocated 16K mbuf\n") 	X(FSW_STATS_RX_PKT_NOT_LISTENER,	"RxPktNotListener",	"\t\t%llu packet not for listener\n") 	X(FSW_STATS_RX_FLOW_IN_USE,		    "RxFlowInUse",	"\t\t%llu flow in use\n") 	X(FSW_STATS_RX_STALL,                    "RxRingStall",         "\t\t%llu Rx rings stalled\n") 	        	X(FSW_STATS_RX_FRAG_V4,			"RxFragV4",		"\t\t%llu total received ipv4 fragments\n")     	X(FSW_STATS_RX_FRAG_V6,			"RxFragV6",		"\t\t%llu total received ipv6 fragments\n")     	X(FSW_STATS_RX_FRAG_REASSED,		"RxFragReassed",	"\t\t\t%llu frag successfully reassembled\n")   	X(FSW_STATS_RX_FRAG_DROP_NOSLOT,	"RxFragDropNoSlot",	"\t\t\t%llu dropped no slot in dring\n")        	X(FSW_STATS_RX_FRAG_BAD,		"RxFragBad",		"\t\t\t%llu dropped due to bad fragments\n")    	X(FSW_STATS_RX_FRAG_DROP_BAD_LEN,	"RxFragBadLen",		"\t\t\t%llu dropped due to bad fragment length\n")      	X(FSW_STATS_RX_FRAG_DROP_NOMEM,		"RxFragNoMem",		"\t\t\t%llu dropped due to no memory\n")        	X(FSW_STATS_RX_FRAG_DROP_TIMEOUT,	"RxFragTimeOut",	"\t\t\t%llu dropped due to time out\n") 	X(FSW_STATS_RX_FRAG_DROP_FRAG_LIMIT,	"RxFragHitFragLimit",	"\t\t\t%llu dropped due to ipf max limit\n")    	X(FSW_STATS_RX_FRAG_DROP_REAPED,	"RxFragDrained",	"\t\t\t%llu dropped due to draining\n") 	X(FSW_STATS_RX_FRAG_DROP_PER_QUEUE_LIMIT,"RxFragHitPerQueueLimit","\t\t\t%llu dropped due to ipf max per queue limit\n")        	                                      	X(FSW_STATS_RX_AGG_PKT2PKT,             "RxAggPktToPkt",        "\t\t%llu aggregated pkt  -> super pkt\n")             	X(FSW_STATS_RX_AGG_PKT2MBUF,            "RxAggPktToMbuf",       "\t\t%llu aggregated pkt  -> super mbuf\n")          	X(FSW_STATS_RX_AGG_MBUF2PKT,            "RxAggMbufToPkt",       "\t\t%llu aggregated mbuf  -> super pkt\n")          	X(FSW_STATS_RX_AGG_MBUF2MBUF,           "RxAggMbufToMbuf",      "\t\t%llu aggregated mbuf  -> super mbuf\n")       	X(FSW_STATS_RX_AGG_LIMIT,               "RxAggHitAggLimit",     "\t\t%llu reached aggregation limit\n") 	X(FSW_STATS_RX_AGG_NO_HLEN_IP,          "RxAggNoHdrLenIP",      "\t\t%llu IP header length compare mismatch\n") 	X(FSW_STATS_RX_AGG_NO_TTL_IP,           "RxAggNoTTLIP",         "\t\t%llu IP TTL compare mismatch\n") 	X(FSW_STATS_RX_AGG_NO_TOS_IP,           "RxAggNoTOSIP",         "\t\t%llu IP TOS compare mismatch\n") 	X(FSW_STATS_RX_AGG_NO_OFF_IP,           "RxAggNoOffsetIP",      "\t\t%llu IP offset compare mismatch\n") 	X(FSW_STATS_RX_AGG_NO_OPT_IP,           "RxAggNoOptionIP",      "\t\t%llu IP option compare mismatch\n") 	X(FSW_STATS_RX_AGG_MERGE_FASTPATH_IP,   "RxAggMergeFastpathIP", "\t\t%llu IP header merge via fastpath\n") 	X(FSW_STATS_RX_AGG_MERGE_SLOWPATH_IP,   "RxAggMergeSlowpathIP", "\t\t%llu IP header merge via slowpath\n") 	X(FSW_STATS_RX_AGG_MERGE_FASTPATH_TCP,  "RxAggMergeFastpathTCP", "\t\t%llu TCP header merge via fastpath\n") 	X(FSW_STATS_RX_AGG_MERGE_SLOWPATH_TCP,  "RxAggMergeSlowpathTCP", "\t\t%llu TCP header merge via slowpath\n") 	X(FSW_STATS_RX_AGG_OK_FASTPATH_TCP,     "RxAggFastpathTCP",     "\t\t%llu TCP aggregation via fastpath\n") 	X(FSW_STATS_RX_AGG_OK_SLOWPATH_TCP,     "RxAggSlowpathTCP",     "\t\t%llu TCP aggregation via slowpath\n") 	X(FSW_STATS_RX_AGG_NO_SHORT_TCP,        "RxAggNoShortTCP",      "\t\t%llu TCP packet too short for mask compare\n") 	X(FSW_STATS_RX_AGG_NO_MASK_TCP,         "RxAggNoMaskTCP",       "\t\t%llu TCP mask compare mismatch\n") 	X(FSW_STATS_RX_AGG_NO_HLEN_TCP,         "RxAggNoHdrLenTCP",     "\t\t%llu TCP header length compare mismatch\n") 	X(FSW_STATS_RX_AGG_NO_ULEN_TCP,         "RxAggNoULenTCP",       "\t\t%llu TCP ulength compare mismatch\n") 	X(FSW_STATS_RX_AGG_NO_SEQN_TCP,         "RxAggNoSeqNTCP",       "\t\t%llu TCP sequence number compare mismatch\n") 	X(FSW_STATS_RX_AGG_NO_ACKWIN_TCP,       "RxAggNoAckWinTCP",     "\t\t%llu TCP ACK or window compare mismatch\n") 	X(FSW_STATS_RX_AGG_NO_FLAGS_TCP,        "RxAggNoFlagsTCP",      "\t\t%llu TCP flags compare mismatch\n") 	X(FSW_STATS_RX_AGG_NO_EXOPT_TCP,        "RxAggNoExtraOptionTCP",  "\t\t%llu TCP extra option compare mismatch\n") 	X(FSW_STATS_RX_AGG_NO_OPTTS_TCP,        "RxAggNoOptionTStampTCP", "\t\t%llu TCP timestamp option compare mismatch\n") 	X(FSW_STATS_RX_AGG_BAD_CSUM,            "RxAggIncorrectChecksum", "\t\t%llu Incorrect TCP/IP checksum\n") 	X(FSW_STATS_RX_AGG_NO_SHORT_MBUF,       "RxAggNoShortMbuf",      "\t\t%llu mbuf too short for mask compare\n") 	X(FSW_STATS_RX_WASTED_MBUF,                     "RxAggWastedMbuf",      "\t\t%llu wasted pre-allocate mbufs\n") 	X(FSW_STATS_RX_WASTED_BFLT,                     "RxAggWastedBflt",      "\t\t%llu wasted pre-allocate buflets\n")         	  	X(FSW_STATS_TX_PACKETS,			"TXPackets",		"\t%llu total Tx packets\n")    	X(FSW_STATS_TX_DEMUX_ERR,		"TxDemuxErr",		"\t\t%llu dropped, demux error\n")        	X(FSW_STATS_TX_FLOW_EXTRACT_ERR,	"TxFlowExtractErr",	"\t\t%llu dropped, flow extract error\n") 	X(FSW_STATS_TX_FRAG_BAD_ID,		"TxFragID",		"\t\t%llu dropped, invalid fragment ID\n")    	X(FSW_STATS_TX_FRAG_BAD_CONT,		"TxContFrag",		"\t\t%llu dropped, invalid continuation fragment\n")    	X(FSW_STATS_TX_FLOW_NOT_FOUND,		"TxFlowNotFound",	"\t\t%llu dropped, flow lookup failure\n")        	X(FSW_STATS_TX_FLOW_TRACK_ERR,		"TxFlowTrackErr",	"\t\t%llu dropped, flow tracker error\n") 	X(FSW_STATS_TX_FLOW_BAD_ID,		"TxFLowBadID",		"\t\t%llu dropped, flow id invalid\n") 	X(FSW_STATS_TX_FLOW_NONVIABLE,		"TxFlowNonviable",	"\t\t%llu dropped, flow already nonviable\n") 	X(FSW_STATS_TX_FLOW_TORNDOWN,		"TxFlowTornDown",	"\t\t%llu dropped, flow already torndown\n") 	X(FSW_STATS_TX_BAD_LISTENER,		"TxBadListener",	"\t\t%llu dropped, flow as listener only\n")      	X(FSW_STATS_TX_AQM_DROP,		"TxAQMDrop",		"\t\t%llu dropped, AQM enqueue failure\n")        	X(FSW_STATS_TX_RESOLV_PENDING,		"TxResolvePending",	"\t\t%llu pending resolve\n")   	X(FSW_STATS_TX_RESOLV_FAIL,		"TxResolveFail",	"\t\t%llu dropped due to resolution failure\n") 	X(FSW_STATS_TX_RESOLV_STALE,		"TxResolveStale",	"\t\t%llu resolved using existing info\n")      	X(FSW_STATS_TX_COPY_PKT2PKT,		"TxCopyPktToPkt",	"\t\t%llu copied pkt  ->  pkt\n")       	X(FSW_STATS_TX_COPY_PKT2MBUF,		"TxCopyPktToMbuf",	"\t\t%llu copied pkt  ->  mbuf\n")      	X(FSW_STATS_TX_COPY_SUM,		"TxCopySum",		"\t\t%llu copy+checksumed\n")   	X(FSW_STATS_TX_COPY_BAD_LEN,		"TxCopyBadLen",		"\t\t%llu dropped, bad packet length\n")          	 	X(FSW_STATS_DROP,			"Drop",			"\t%llu total dropped\n")       	X(FSW_STATS_DROP_NOMEM_PKT,		"DropNoMemPkt",		"\t\t%llu dropped, packet alloc failure\n")       	X(FSW_STATS_DROP_NOMEM_MBUF,		"DropNoMemMbuf",	"\t\t%llu dropped, mbuf alloc failure\n")         	  	X(FSW_STATS_EV_RECV,			"EvRecv",		"\t%llu channel event received\n")     	X(FSW_STATS_EV_RECV_TX_STATUS,		"EvRecvTxStatus",	"\t\t%llu channel event received, TX status\n")     	X(FSW_STATS_EV_RECV_TX_EXPIRED,		"EvRecvTxExpired",	"\t\t%llu channel event received, TX expired\n")     	X(FSW_STATS_EV_SENT,			"EvSent",		"\t%llu channel event delivered\n")     	X(FSW_STATS_EV_DROP,			"EvDrop",		"\t%llu channel event dropped\n")     	X(FSW_STATS_EV_DROP_NOMEM_PKT,	"EvDropNoMemPkt",	"\t%llu channel event dropped due to packet alloc failure\n")     	X(FSW_STATS_EV_DROP_NA_INACTIVE,	"EvDropNaInactive",	"\t%llu channel event dropped due to na inactive\n")     	X(FSW_STATS_EV_DROP_NA_DEFUNCT,	"EvDropNaDefunct",	"\t%llu channel event dropped due to na defunct\n")     	X(FSW_STATS_EV_DROP_KRDROP_MODE,	"EvDropKrDropMode",	"\t%llu channel event dropped due to dst kring in drop mode\n")     	X(FSW_STATS_EV_DROP_KEVENT_INACTIVE,	"EvDropKevInactive",	"\t%llu channel event dropped due to kevent not registered on channel\n")     	X(FSW_STATS_EV_DROP_KRSPACE,		"EvDropKrSpaceDrop",	"\t%llu channel event dropped due to lack of space in user channel ring\n") 	X(FSW_STATS_EV_DROP_DEMUX_ERR,	"EvDropDemuxErr",	"\t%llu channel event dropped due to demux error\n") 	X(FSW_STATS_EV_DROP_EV_VPNA_NOTSUP,	"EvDropVpnaEvNotSup",	"\t%llu channel event dropped due to vpna not having event ring\n") 	 	X(FSW_STATS_FLOWS_ABORTED,		"FlowsAborted",		"\t%llu flow aborted\n")        	X(FSW_STATS_DST_NXPORT_INVALID,		"DestNexusPortInvalid", "\t%llu times dst nexus port invalid\n")        	X(FSW_STATS_DST_NXPORT_INACTIVE,	"DestNexusPortInactive","\t%llu times dst nexus port inactive\n")       	X(FSW_STATS_DST_NXPORT_DEFUNCT,		"DestNexusPortDefunct", "\t%llu times dst nexus port defunct\n")        	X(FSW_STATS_DST_RING_DROPMODE,		"DestRingDropMode",	"\t\t%llu dropped, dst kring in drop mode\n")     	X(FSW_STATS_CHAN_ERR_UPP_ALLOC,		"ChanErrUppAlloc",	"\t%llu user packet pool alloc failure\n")      	X(FSW_STATS_CHAN_DEFUNCT_SKIP,		"ChanDefunctSkipped",	"\t%llu defunct skipped due to outstanding packets\n")          	X(_FSW_STATS_ERROR_INJECTIONS,		"_ErrorInjections",	"(\t%llu errors injected)\n")  	X(FSW_STATS_IF_ADV_UPD_SENT,		"IfAdvUpdSent",		"\t%llu interface advisory update event sent\n")         	X(FSW_STATS_IF_ADV_UPD_DROP,		"IfAdvUpdDrop",		"\t%llu interface advisory update event dropped\n")         	 	FSW_FPD_STATS(X)                	X(__FSW_STATS_MAX,			"",			"end of flowswitch stats")
EXPAND_TO_ENUMERATION(a, b, c) a,
EXPAND_TO_STRING(a, b, c) b,
EXPAND_TO_FORMAT(a, b, c) c,
DEFINE_STATS_STR_FUNC(type, table)                      __attribute__((always_inline))                                  static inline const char *                                      type##_str(enum _##type value)                                  {                                                               	static const char *table[] = {                          	    table(EXPAND_TO_STRING)                             	};                                                      	return (table[value]);                                  }
DEFINE_STATS_FMT_FUNC(type, table)                      __attribute__((always_inline))                                  static inline const char *                                      type##_fmt(enum _##type value)                                  {                                                               	static const char *table[] = {                          	    table(EXPAND_TO_FORMAT)                             	};                                                      	return (table[value]);                                  }
STATS_VAL(s_ptr, t) ((s_ptr)->_arr[(t)])
STATS_INC(s_ptr, t) ((s_ptr)->_arr[(t)]++)
STATS_DEC(s_ptr, t) ((s_ptr)->_arr[(t)]--)
STATS_ADD(s_ptr, t, v) ((s_ptr)->_arr[(t)] += (v))
DEFINE_STATS_FOLD_FUNC(type, len)               static inline void __attribute__((always_inline))       type##_fold(struct type *dst, struct type *src)         {                                                       	__stats_fold(dst->_arr, src->_arr, len);        }
DEFINE_STATS_RESET_FUNC(type, len)              static inline void __attribute__((always_inline))       type##_reset(struct type *s)                            {                                                       	__stats_reset(s->_arr, len);                    }
STATS_ALIGN 16
STATS_REGISTER(name, NAME)                      enum _##name { NAME##_TABLE(EXPAND_TO_ENUMERATION) };   struct name {                                           	uint64_t	_arr[__##NAME##_MAX];           } __attribute__((aligned(STATS_ALIGN)));                DEFINE_STATS_STR_FUNC(name, NAME##_TABLE)               DEFINE_STATS_FMT_FUNC(name, NAME##_TABLE)               DEFINE_STATS_FOLD_FUNC(name, __##NAME##_MAX)            DEFINE_STATS_RESET_FUNC(name, __##NAME##_MAX)
SK_STATS_NETIF_QUEUE_SYSCTL "kern.skywalk.stats.netif_queue"
NQI_QUEUE_FLAG_IS_RX 0x00000001
NEXUS_PROVIDER_LIST_SYSCTL "kern.skywalk.nexus_provider_list"
NEXUS_PROVIDER_INFO_SIZE(a) offsetof(nexus_provider_info, npi_instance_uuids[a])
NEXUS_CHANNEL_LIST_SYSCTL "kern.skywalk.nexus_channel_list"
NEXUS_CHANNEL_RING_STAT_ENABLE_SYSCTL "kern.skywalk.ring_stat_enable"
SCHF_MONITOR_TX 0x00000001
SCHF_MONITOR_RX 0x00000002
SCHF_MONITOR_NO_COPY 0x00000004
SCHF_USER_PACKET_POOL 0x00000008
SCHF_DEFUNCT_OK 0x00000010
SCHF_EXCLUSIVE 0x00000020
SCHF_FILTER 0x00000040
SCHF_EVENT_RING 0x00000080
SCHF_IF_ADV 0x00000100
SCHF_DEFUNCT_SKIP 0x00000200
SCHF_LOW_LATENCY 0x00000400
SCHF_CLOSING 0x40000000
SCHF_DEFUNCT 0x80000000
SCHF_BITS "\020\01MON_TX\02MON_RX\03NO_COPY\04USER_PACKET_POOL\05DEFUNCT_OK" 	"\06EXCLUSIVE\07FILTER\010EVENT_RING\011IF_ADV\012DEFUNCT_SKIP"    	"\013LOW_LATENCY\037CLOSING\040DEFUNCT"
NEXUS_CHANNEL_ENTRY_SIZE(n_rings) offsetof(nexus_channel_entry, nce_ring_entries[n_rings])
NX_ADVISORY_MD_VERSION 1
NX_ADVISORY_MD_CURRENT_VERSION NX_ADVISORY_MD_VERSION
NX_NETIF_ADVISORY_VERSION 1
NX_NETIF_ADVISORY_CURRENT_VERSION NX_NETIF_ADVISORY_VERSION
NX_ADVISORY_VERSION 1
NX_ADVISORY_VERSION_2 2
NX_ADVISORY_CURRENT_VERSION NX_ADVISORY_VERSION_2
NX_FLOWSWITCH_ADVISORY_CURRENT_VERSION NX_ADVISORY_CURRENT_VERSION
FLOW_STATS_IN_ADD(fe, stat, cnt) { 	volatile struct sk_stats_flow_track *fst; 	fst = &(fe)->fe_stats->fs_rtrack; 	fst->sft_##stat += (cnt); }
FLOW_STATS_OUT_ADD(fe, stat, cnt) { 	volatile struct sk_stats_flow_track *fst; 	fst = &(fe)->fe_stats->fs_ltrack; 	fst->sft_##stat += (cnt); }
SK_STATS_FLOW "kern.skywalk.stats.flow"
sf_obytes sf_ltrack.sft_bytes
sf_opackets sf_ltrack.sft_packets
sf_ospackets sf_ltrack.sft_spackets
sf_ibytes sf_rtrack.sft_bytes
sf_ipackets sf_rtrack.sft_packets
sf_ispackets sf_rtrack.sft_spackets
sf_lrtt sf_ltrack.sft_rtt
sf_rrtt sf_rtrack.sft_rtt
sf_lseq sf_ltrack.sft_seq
sf_rseq sf_rtrack.sft_seq
sf_lmax_win sf_ltrack.sft_max_win
sf_rmax_win sf_rtrack.sft_max_win
sf_lwscale sf_ltrack.sft_wscale
sf_rwscale sf_rtrack.sft_wscale
SFLOWF_TRACK 0x00000010
SFLOWF_CONNECTED 0x00000020
SFLOWF_LISTENER 0x00000040
SFLOWF_QOS_MARKING 0x00000100
SFLOWF_BOUND_IP 0x00000200
SFLOWF_ONLINK 0x00000400
SFLOWF_LOW_LATENCY 0x00000800
SFLOWF_WAIT_CLOSE 0x00001000
SFLOWF_CLOSE_NOTIFY 0x00002000
SFLOWF_NOWAKEFROMSLEEP 0x00004000
SFLOWF_ABORTED 0x01000000
SFLOWF_NONVIABLE 0x02000000
SFLOWF_WITHDRAWN 0x04000000
SFLOWF_TORN_DOWN 0x08000000
SFLOWF_PARENT 0x10000000
SFLOWF_CHILD 0x20000000
SFLOWF_DESTROYED 0x40000000
SFLOWF_LINGERING 0x80000000
fs_ltrack fs_stats.sf_ltrack
fs_rtrack fs_stats.sf_rtrack
fs_activity fs_stats.sf_activity
fs_lrtt fs_stats.sf_lrtt
fs_rrtt fs_stats.sf_rrtt
SK_STATS_FLOW_OWNER "kern.skywalk.stats.flow_owner"
SK_STATS_FLOW_ROUTE "kern.skywalk.stats.flow_route"
SFLOWRTF_ATTACHED 0x00000001
SFLOWRTF_ONLINK 0x00000010
SFLOWRTF_GATEWAY 0x00000020
SFLOWRTF_RESOLVED 0x00000040
SFLOWRTF_HAS_LLINFO 0x00000080
SFLOWRTF_DELETED 0x00000100
SFLOWRTF_DST_LL_MCAST 0x00000200
SFLOWRTF_DST_LL_BCAST 0x00000400
SK_STATS_NET_IF "kern.skywalk.stats.net_if"
SK_STATS_FLOW_SWITCH "kern.skywalk.stats.flow_switch"
SK_STATS_USERSTACK "kern.skywalk.stats.userstack"
SK_STATS_FLOW_ADV "kern.skywalk.stats.flow_adv"
SK_STATS_NETNS "kern.skywalk.stats.netns"
SK_STATS_PROTONS "kern.skywalk.stats.protons"
SK_STATS_FLOWIDNS "kern.skywalk.stats.flowidns"
SFH_DOMAIN_IPSEC 0
SFH_DOMAIN_FLOWSWITCH 1
SFH_DOMAIN_INPCB 2
SFH_DOMAIN_PF 3
sfr_laddr_v4 sfr_laddr._v4
sfr_laddr_v6 sfr_laddr._v6
sfr_raddr_v4 sfr_raddr._v4
sfr_raddr_v6 sfr_raddr._v6
sfr_lport sfr_ports._lport
sfr_rport sfr_ports._rport
SK_STATS_REGION "kern.skywalk.stats.region"
SREG_MODE_NOREDIRECT 0x1
SREG_MODE_MMAPOK 0x2
SREG_MODE_KREADONLY 0x4
SREG_MODE_UREADONLY 0x8
SREG_MODE_PERSISTENT 0x10
SREG_MODE_MONOLITHIC 0x20
SREG_MODE_NOMAGAZINES 0x40
SREG_MODE_NOCACHE 0x80
SREG_MODE_SEGPHYSCONTIG 0x100
SREG_MODE_SHAREOK 0x200
SREG_MODE_IODIR_IN 0x400
SREG_MODE_IODIR_OUT 0x800
SREG_MODE_GUARD 0x1000
SREG_MODE_PUREDATA 0x2000
SREG_MODE_PSEUDO 0x4000
SREG_MODE_THREADSAFE 0x8000
SREG_MODE_BITS "\020\01NOREDIRECT\02MMAPOK\03KREADONLY\04UREADONLY"            	"\05PERSISTENT\06MONOLITHIC\07NOMAGAZINES\10NOCACHE"            	"\11SEGPHYSCONTIG\012SHAREOK\013IODIR_IN\014IODIR_OUT"          	"\015GUARD\016PUREDATA\017PSEUDO\020THREADSAFE\037SLAB"         	"\040MIRRORED"
SK_STATS_ARENA "kern.skywalk.stats.arena"
SK_STATS_ARENA_MAPPED_PID_MAX 8
SK_STATS_CACHE "kern.skywalk.stats.cache"
SCA_MODE_NOMAGAZINES 0x00000001
SCA_MODE_AUDIT 0x00000002
SCA_MODE_NOREDIRECT 0x00000004
SCA_MODE_BATCH 0x00000008
SCA_MODE_DYNAMIC 0x00000010
SCA_MODE_CLEARONFREE 0x00000020
SCA_MODE_PSEUDO 0x00000040
SCA_MODE_RECLAIM 0x00000080
SCA_MODE_BITS "\020\01NOMAGAZINES\02AUDIT\03NOREDIRECT\04BATCH\05DYNAMIC"     	"\06CLEARONFREE\07PSEUDO\10RECLAIM"
_SKYWALK_OS_SYSCTLS_H_ None
SKMEM_SYSCTL_TCP_LIST X(int32_t, bg_target_qdelay, 40)                                	X(int32_t, bg_allowed_increase, 8)                              	X(int32_t, bg_tether_shift, 1)                                  	X(uint32_t, bg_ss_fltsz, 2)                                     	X(int32_t, use_newreno, 0)                                      	X(int32_t, cubic_tcp_friendliness, 0)                           	X(int32_t, cubic_fast_convergence, 0)                           	X(int32_t, cubic_use_minrtt, 0)                                 	X(int32_t, delayed_ack, 3)                                      	X(int32_t, recvbg, 0)                                           	X(int32_t, drop_synfin, 1)                                      	X(int32_t, slowlink_wsize, 8192)                                	X(int32_t, maxseg_unacked, 8)                                   	X(int32_t, rfc3465, 1)                                          	X(int32_t, rfc3465_lim2, 1)                                     	X(int32_t, recv_allowed_iaj, 5)                                 	X(uint32_t, doautorcvbuf, 1)                                    	X(uint32_t, autorcvbufmax, 2 * 1024 * 1024)                     	X(int32_t, rcvsspktcnt, 512)                                    	X(int32_t, path_mtu_discovery, 1)                               	X(int32_t, local_slowstart_flightsize, 8)                       	X(uint32_t, ecn_setup_percentage, 50)                           	X(int32_t, ecn_initiate_out, 0)                                 	X(int32_t, ecn_negotiate_in, 0)                                 	X(int32_t, packetchain, 50)                                     	X(int32_t, socket_unlocked_on_output, 1)                        	X(int32_t, min_iaj_win, 16)                                     	X(int32_t, acc_iaj_react_limit, 200)                            	X(uint32_t, autosndbufinc, 8 * 1024)                            	X(uint32_t, autosndbufmax, 2 * 1024 * 1024)                     	X(uint32_t, rtt_recvbg, 1)                                      	X(uint32_t, recv_throttle_minwin, 16 * 1024)                    	X(int32_t, enable_tlp, 1)                                       	X(int32_t, sack, 1)                                             	X(int32_t, sack_maxholes, 128)                                  	X(int32_t, sack_globalmaxholes, 65536)                          	X(int32_t, mssdflt, 512)                                        	X(int32_t, v6mssdflt, 1024)                                     	X(int32_t, fastopen_backlog, 10)                                	X(int32_t, fastopen, 0x3)                                       	X(int32_t, minmss, 216)                                         	X(int32_t, icmp_may_rst, 1)                                     	X(int32_t, rtt_min, 100)                                        	X(int32_t, rexmt_slop, 200)                                     	X(int32_t, randomize_ports, 0)                                  	X(int32_t, win_scale_factor, 3)                                 	X(int32_t, keepinit, 75 * 1000)                                 	X(int32_t, keepidle, 120 * 60 * 1000)                           	X(int32_t, keepintvl, 75 * 1000)                                	X(int32_t, keepcnt, 8)                                          	X(int32_t, msl, 15 * 1000)                                      	X(uint32_t, max_persist_timeout, 0)                             	X(int32_t, always_keepalive, 0)                                 	X(uint32_t, timer_fastmode_idlemax, 10)                         	X(int32_t, broken_peer_syn_rexmit_thres, 10)                    	X(int32_t, pmtud_blackhole_detection, 1)                        	X(uint32_t, pmtud_blackhole_mss, 1200)                          	X(int32_t, sendspace, 1448*256)                                 	X(int32_t, recvspace, 1448*384)                                 	X(uint32_t, microuptime_init, 0)                                	X(uint32_t, now_init, 0)                                        	X(uint32_t, challengeack_limit, 10)                             	X(int32_t, do_rfc5961, 1)                                       	X(int32_t, init_rtt_from_cache, 1)                              	X(uint32_t, autotunereorder, 1)                                 	X(uint32_t, do_ack_compression, 1)                              	X(uint32_t, ack_compression_rate, 5)                            	X(int32_t, do_better_lr, 1)                                     	X(int32_t, cubic_minor_fixes, 1)                                	X(int32_t, cubic_rfc_compliant, 1)                              	X(int32_t, aggressive_rcvwnd_inc, 1)                            	X(int32_t, ack_strategy, 1)                                     	X(int32_t, flow_control_response, 1)                            	X(int32_t, randomize_timestamps, 1)                             	X(uint32_t, ledbat_plus_plus, 1)                                	X(uint32_t, use_ledbat, 0)                                      	X(uint32_t, rledbat, 1)                                         	X(uint32_t, use_min_curr_rtt, 1)                                	X(uint32_t, fin_timeout, 30)                                    	X(uint32_t, accurate_ecn, 0)                                    	X(int32_t, tso, 1)                                              	X(int32_t, awdl_rtobase, 100)                                   	X(int32_t, rack, 1)                                             	X(int32_t, l4s, 0)                                              	X(int32_t, link_heuristics_flags, 0)                            	X(int32_t, link_heuristics_rto_min, 0)
SKMEM_SYSCTL_KERN_IPC_LIST X(uint32_t, throttle_best_effort, 0)
SKMEM_SYSCTL_TCP_HAS_DEFAULT_VALUES 1
SKMEM_SYSCTL_TCP_HAS_INIT_TIME 1
SKMEM_SYSCTL_TCP_HAS_LEDBAT_PLUS_PLUS 1
SKMEM_SYSCTL_TCP_HAS_RLEDBAT 1
SKMEM_SYSCTL_TCP_HAS_FIN_TIMEOUT 1
SKMEM_SYSCTL_TCP_HAS_ACC_ECN 1
SKMEM_SYSCTL_TCP_HAS_ACC_ECN_OPTION 1
SKMEM_SYSCTL_TCP_HAS_AWDL_RTOBASE 1
SKMEM_SYSCTL_TCP_HAS_RACK 1
SKMEM_SYSCTL_TCP_HAS_L4S 1
SKMEM_SYSCTL_TCP_HAS_LINK_HEURISTICS 1
NW_SYSCTL_PRI_int32_t PRIi32
NW_SYSCTL_PRI_uint32_t PRIu32
SKMEM_SYSCTL_VERSION 3
X(type, field, ...)     type field;
X(type, field, ...)     type field;
SK_LLINK_LIST_SYSCTL "kern.skywalk.llink_list"
SYSCTL_SKMEM_UPDATE_FIELD(field, value) do {                    	skmem_sysctl *__single swptr = skmem_get_sysctls_obj(NULL);     	if (swptr) {                                                    	        swptr->field = value;                                   	}                                                               } while (0)
SYSCTL_SKMEM_UPDATE_AT_OFFSET(offset, value) do {               	if (offset >= 0 &&                                              	    offset + sizeof (typeof(value)) <= sizeof (skmem_sysctl)) { 	        skmem_sysctl *__single swptr = skmem_get_sysctls_obj(NULL);     	        void *offp = (u_int8_t *__bidi_indexable)               	            (skmem_sysctl *__bidi_indexable)swptr + offset;     	        if (swptr &&                                            	            ((uintptr_t)offp) % _Alignof(typeof(value)) == 0) { 	                *(typeof(value)*)offp = (value);                	        }                                                       	}                                                               } while (0)
SYSCTL_SKMEM_INT(parent, oid, sysctl_name, access, ptr, offset, descr) 	SYSCTL_OID(parent, oid, sysctl_name, CTLTYPE_INT|access,        	    ptr, offset, skmem_sysctl_handle_int, "I", descr);          	_Static_assert((__builtin_constant_p(ptr) ||                    	    sizeof (*(ptr)) == sizeof (int)), "invalid ptr");           	_Static_assert(offset % _Alignof(int) == 0, "invalid offset")
SYSCTL_SKMEM_TCP_INT(oid, sysctl_name, access, variable_type,   	    variable_name, initial_value, descr)                                	variable_type variable_name = initial_value;                    	SYSCTL_SKMEM_INT(_net_inet_tcp, oid, sysctl_name, access,       	    &variable_name, offsetof(skmem_sysctl, tcp.sysctl_name), descr)
SYSCTL_SKMEM_KERN_IPC_INT(oid, sysctl_name, access, variable_type,      	    variable_name, initial_value, descr)                                	variable_type variable_name = initial_value;                    	SYSCTL_SKMEM_INT(_kern_ipc, oid, sysctl_name, access,           	    &variable_name, offsetof(skmem_sysctl, kern.ipc.sysctl_name), descr)
_SYS_ACCT_H_ None
AFORK 0x01
ASU 0x02
ACOMPAT 0x04
ACORE 0x08
AXSIG 0x10
AHZ 64
_SYS_AIO_H_ None
AIO_ALLDONE 0x1
AIO_CANCELED 0x2
AIO_NOTCANCELED 0x4
LIO_NOP 0x0
LIO_READ 0x1
LIO_WRITE 0x2
LIO_NOWAIT 0x1
LIO_WAIT 0x2
AIO_LISTIO_MAX 16
_SYS_AIO_KERN_H_ None
__SYS_APPLEAPIOPTS_H__ None
__APPLE_API_STANDARD None
__APPLE_API_STABLE None
__APPLE_API_EVOLVING None
__APPLE_API_UNSTABLE None
__APPLE_API_PRIVATE None
__APPLE_API_OBSOLETE None
_SYS_ATTR_H_ None
_SYS_ATTR_PRIVATE_H_ None
FSOPT_NOFIRMLINKPATH 0x00000080
FSOPT_ISREALFSID FSOPT_RETURN_REALDEV
_SYS_BITSTRING_H_ None
bit_decl(name, nbits)                                           	((name)[bitstr_size(nbits)])
bitstr_test(name, bit)                                          	((name)[_bitstr_byte(bit)] & _bitstr_mask(bit))
bitstr_set(name, bit)                                           	((name)[_bitstr_byte(bit)] |= _bitstr_mask(bit))
bitstr_set_atomic(name, bit)                                    	(void)os_atomic_or(&((name)[_bitstr_byte(bit)]), _bitstr_mask(bit), relaxed)
bitstr_clear(name, bit)                                         	((name)[_bitstr_byte(bit)] &= ~_bitstr_mask(bit))
bitstr_clear_atomic(name, bit)                                  	(void)os_atomic_andnot(&((name)[_bitstr_byte(bit)]), _bitstr_mask(bit), relaxed)
bitstr_nclear(name, start, stop) do {                           	bitstr_t *_name = (name);                                       	int _start = (start), _stop = (stop);                           	int _startbyte = _bitstr_byte(_start);                          	int _stopbyte = _bitstr_byte(_stop);                            	if (_startbyte == _stopbyte) {                                  	        _name[_startbyte] &= ((0xff >> (8 - (_start & 0x7))) |  	            (0xff << ((_stop & 0x7) + 1)));                     	} else {                                                        	        _name[_startbyte] &= 0xff >> (8 - (_start & 0x7));      	        while (++_startbyte < _stopbyte)                        	                _name[_startbyte] = 0;                          	        _name[_stopbyte] &= 0xff << ((_stop & 0x7) + 1);        	}                                                               } while (0)
bitstr_nset(name, start, stop) do {                             	bitstr_t *_name = (name);                                       	int _start = (start), _stop = (stop);                           	int _startbyte = _bitstr_byte(_start);                          	int _stopbyte = _bitstr_byte(_stop);                            	if (_startbyte == _stopbyte) {                                  	        _name[_startbyte] |= ((0xff << (_start & 0x7)) &        	            (0xff >> (7 - (_stop & 0x7))));                     	} else {                                                        	        _name[_startbyte] |= 0xff << ((_start) & 0x7);          	        while (++_startbyte < _stopbyte)                        	                _name[_startbyte] = 0xff;                       	        _name[_stopbyte] |= 0xff >> (7 - (_stop & 0x7));        	}                                                               } while (0)
bitstr_ffc(name, nbits, value) do {                             	bitstr_t *_name = (name);                                       	int _byte, _nbits = (nbits);                                    	int _stopbyte = _bitstr_byte(_nbits - 1), _value = -1;          	if (_nbits > 0)                                                 	        for (_byte = 0; _byte <= _stopbyte; ++_byte)            	                if (_name[_byte] != 0xff) {                     	                        bitstr_t _lb;                           	                        _value = _byte << 3;                    	                        for (_lb = _name[_byte]; (_lb & 0x1);   	                            ++_value, _lb >>= 1);               	                        break;                                  	                }                                               	if (_value >= nbits)                                            	        _value = -1;                                            	*(value) = _value;                                              } while (0)
bitstr_ffs(name, nbits, value) do {                             	bitstr_t *_name = (name);                                       	int _byte, _nbits = (nbits);                                    	int _stopbyte = _bitstr_byte(_nbits - 1), _value = -1;          	if (_nbits > 0)                                                 	        for (_byte = 0; _byte <= _stopbyte; ++_byte)            	                if (_name[_byte]) {                             	                        bitstr_t _lb;                           	                        _value = _byte << 3;                    	                        for (_lb = _name[_byte]; !(_lb & 0x1);  	                            ++_value, _lb >>= 1);               	                        break;                                  	                }                                               	if (_value >= nbits)                                            	        _value = -1;                                            	*(value) = _value;                                              } while (0)
_SYS_BSDTASK_INFO_H None
MAXTHREADNAMESIZE 64
PROC_REGION_SUBMAP 1
PROC_REGION_SHARED 2
_SYS_BUF_H_ None
B_WRITE 0x00000000
B_READ 0x00000001
B_ASYNC 0x00000002
B_NOCACHE 0x00000004
B_DELWRI 0x00000008
B_LOCKED 0x00000010
B_PHYS 0x00000020
B_CLUSTER 0x00000040
B_PAGEIO 0x00000080
B_META 0x00000100
B_RAW 0x00000200
B_FUA 0x00000400
B_PASSIVE 0x00000800
B_IOSTREAMING 0x00001000
B_THROTTLED_IO 0x00002000
B_ENCRYPTED_IO 0x00004000
B_STATICCONTENT 0x00008000
BUF_WAIT 0x01
BUF_WRITE_DATA 0x0001
BUF_SKIP_META 0x0002
BUF_INVALIDATE_LOCKED 0x0004
BUF_SKIP_NONLOCKED 0x01
BUF_SKIP_LOCKED 0x02
BUF_SCAN_CLEAN 0x04
BUF_SCAN_DIRTY 0x08
BUF_NOTIFY_BUSY 0x10
BUF_RETURNED 0
BUF_RETURNED_DONE 1
BUF_CLAIMED 2
BUF_CLAIMED_DONE 3
BLK_READ 0x01
BLK_WRITE 0x02
BLK_META 0x10
BLK_ONLYVALID 0x80000000
BAC_NOWAIT 0x01
BAC_REMOVE 0x02
BAC_SKIP_NONLOCKED 0x04
BAC_SKIP_LOCKED 0x08
SET(t, f)       (t) |= (f)
CLR(t, f)       (t) &= ~(f)
ISSET(t, f)     ((t) & (f))
_SYS_BUF_INTERNAL_H_ None
b_uploffset b_bufsize
b_orig b_freelist.tqe_prev
b_shadow b_freelist.tqe_next
b_shadow_ref b_validoff
b_trans_head b_freelist.tqe_prev
b_trans_next b_freelist.tqe_next
b_iostate b_rcred
b_cliodone b_wcred
b_clfoffset b_lblksize
BL_BUSY 0x00000001
BL_WANTED 0x00000002
BL_IOBUF 0x00000004
BL_WANTDEALLOC 0x00000010
BL_SHADOW 0x00000020
BL_EXTERNAL 0x00000040
BL_WAITSHADOW 0x00000080
BL_IOBUF_ALLOC 0x00000100
BL_WANTED_REF 0x00000200
BL_IOBUF_VDEV 0x00000400
BUF_STALE_THRESHHOLD 30
BUF_MAX_GC_BATCH_SIZE 64
B_CACHE 0x00010000
B_DONE 0x00020000
B_INVAL 0x00040000
B_ERROR 0x00080000
B_EINTR 0x00100000
B_AGE 0x00200000
B_FILTER 0x00400000
B_CALL 0x00800000
B_EOT 0x01000000
B_WASDIRTY 0x02000000
B_HDRALLOC 0x04000000
B_ZALLOC 0x08000000
B_COMMIT_UPL 0x40000000
B_TDONE 0x80000000
B_CLRBUF 0x01
B_SYNC 0x02
B_NOBUFF 0x04
BA_RAW_ENCRYPTED_IO 0x00000001
BA_THROTTLED_IO 0x00000002
BA_DELAYIDLESLEEP 0x00000004
BA_NOCACHE 0x00000008
BA_META 0x00000010
BA_GREEDY_MODE 0x00000020
BA_QUICK_COMPLETE 0x00000040
BA_PASSIVE 0x00000080
BA_IO_TIER_MASK 0x00000f00
BA_IO_TIER_SHIFT 8
BA_ISOCHRONOUS 0x00001000
BA_STRATEGY_TRACKED_IO 0x00002000
BA_IO_TIER_UPGRADE 0x00004000
BA_IO_SCHEDULED 0x00008000
BA_EXPEDITED_META_IO 0x00010000
BA_WILL_VERIFY 0x00020000
BA_ASYNC_VERIFY 0x00040000
SET_BUFATTR_IO_TIER(bap, tier)                                          do {                                                                            	(bap)->ba_flags &= (~BA_IO_TIER_MASK);                                  	(bap)->ba_flags |= (((tier) << BA_IO_TIER_SHIFT) & BA_IO_TIER_MASK);    } while(0)
CLUSTER_IO_BLOCK_SIZE 0x1000
_CDEFS_H_ None
__has_builtin(x) 0
__has_include(x) 0
__has_feature(x) 0
__has_attribute(x) 0
__has_cpp_attribute(x) 0
__has_extension(x) 0
__dead2 __attribute__((__noreturn__))
__pure2 __attribute__((__const__))
__stateful_pure __attribute__((__pure__))
__unused __attribute__((__unused__))
__used __attribute__((__used__))
__exported __attribute__((__visibility__("default")))
__exported_push _Pragma("GCC visibility push(default)")
__exported_pop _Pragma("GCC visibility pop")
__deprecated __attribute__((__deprecated__))
__kpi_deprecated_arm64_macos_unavailable None
__dead None
__pure None
__restrict None
__abortlike __dead2 __cold __not_tail_called
__printflike(fmtarg, firstvararg) 	__attribute__((__format__ (__printf__, fmtarg, firstvararg)))
__printf0like(fmtarg, firstvararg) 	__attribute__((__format__ (__printf0__, fmtarg, firstvararg)))
__scanflike(fmtarg, firstvararg) 	__attribute__((__format__ (__scanf__, fmtarg, firstvararg)))
__osloglike(fmtarg, firstvararg) 	__attribute__((__format__ (__os_log__, fmtarg, firstvararg)))
__IDSTRING(name, string) static const char name[] __used = string
__COPYRIGHT(s) __IDSTRING(copyright,s)
__RCSID(s) __IDSTRING(rcsid,s)
__SCCSID(s) __IDSTRING(sccsid,s)
__PROJECT_VERSION(s) __IDSTRING(project_version,s)
__FBSDID(s) None
__DECONST(type, var)    __CAST_AWAY_QUALIFIER(var, const, type)
__DEVOLATILE(type, var) __CAST_AWAY_QUALIFIER(var, volatile, type)
__DEQUALIFY(type, var)  __CAST_AWAY_QUALIFIER(var, const volatile, type)
__DARWIN_ONLY_64_BIT_INO_T 0
__DARWIN_ONLY_UNIX_CONFORMANCE 0
__DARWIN_ONLY_VERS_1050 0
__DARWIN_SUF_EXTSN "$DARWIN_EXTSN"
__DARWIN_ALIAS(sym) __asm("_" __STRING(sym) __DARWIN_SUF_UNIX03)
__DARWIN_ALIAS_C(sym) __asm("_" __STRING(sym) __DARWIN_SUF_NON_CANCELABLE __DARWIN_SUF_UNIX03)
__DARWIN_ALIAS_I(sym) __asm("_" __STRING(sym) __DARWIN_SUF_64_BIT_INO_T __DARWIN_SUF_UNIX03)
__DARWIN_NOCANCEL(sym) __asm("_" __STRING(sym) __DARWIN_SUF_NON_CANCELABLE)
__DARWIN_INODE64(sym) __asm("_" __STRING(sym) __DARWIN_SUF_64_BIT_INO_T)
__DARWIN_1050(sym) __asm("_" __STRING(sym) __DARWIN_SUF_1050)
__DARWIN_1050ALIAS(sym) __asm("_" __STRING(sym) __DARWIN_SUF_1050 __DARWIN_SUF_UNIX03)
__DARWIN_1050ALIAS_C(sym) __asm("_" __STRING(sym) __DARWIN_SUF_1050 __DARWIN_SUF_NON_CANCELABLE __DARWIN_SUF_UNIX03)
__DARWIN_1050ALIAS_I(sym) __asm("_" __STRING(sym) __DARWIN_SUF_1050 __DARWIN_SUF_64_BIT_INO_T __DARWIN_SUF_UNIX03)
__DARWIN_1050INODE64(sym) __asm("_" __STRING(sym) __DARWIN_SUF_1050 __DARWIN_SUF_64_BIT_INO_T)
__DARWIN_EXTSN(sym) __asm("_" __STRING(sym) __DARWIN_SUF_EXTSN)
__DARWIN_EXTSN_C(sym) __asm("_" __STRING(sym) __DARWIN_SUF_EXTSN __DARWIN_SUF_NON_CANCELABLE)
__XNU_INTERNAL(sym) __asm("_" __STRING(sym) "$XNU_INTERNAL") __attribute__((used))
__DARWIN_ALIAS_STARTING(_mac, _iphone, x)
__POSIX_C_DEPRECATED(ver) None
__DARWIN_C_ANSI 010000L
__DARWIN_C_FULL 900000L
_DARWIN_FEATURE_ONLY_64_BIT_INODE 1
_DARWIN_FEATURE_ONLY_VERS_1050 1
_DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE 1
__CAST_AWAY_QUALIFIER(variable, qualifier, type) 	_Pragma("GCC diagnostic push") 	_Pragma("GCC diagnostic ignored \"-Wcast-qual\"") 	_Pragma("GCC diagnostic ignored \"-Wcast-align\"") 	_Pragma("GCC diagnostic ignored \"-Waddress-of-packed-member\"") 	((type)(variable)) 	_Pragma("GCC diagnostic pop")
__XNU_PRIVATE_EXTERN __attribute__((visibility("hidden")))
__ASSUME_PTR_ABI_SINGLE_BEGIN __ptrcheck_abi_assume_single()
__ASSUME_PTR_ABI_SINGLE_END __ptrcheck_abi_assume_unsafe_indexable()
__IGNORE_WCASTALIGN(x) _Pragma("clang diagnostic push")                     	                       _Pragma("clang diagnostic ignored \"-Wcast-align\"") 	                       x                                                    	                       _Pragma("clang diagnostic pop")
__container_of(ptr, type_t, field) __extension__({ 	const __typeof__(((type_t *)NULL)->field) *__ptr = (ptr);               	uintptr_t __result = (uintptr_t)__ptr - offsetof(type_t, field);        	if (__ptr) __builtin_assume(__result != 0);                             	__unsafe_forge_single(type_t *, __result);                              })
__container_of_safe(ptr, type_t, field) __extension__({ 	const __typeof__(((type_t *)NULL)->field) *__ptr_or_null = (ptr);       	__ptr_or_null ? __container_of(__ptr_or_null, type_t, field) : NULL;    })
__compiler_materialize_and_prevent_reordering_on(var) __asm__ ("" : "=r"(var) : "0"(var))
__compiler_barrier() __asm__ __volatile__("" ::: "memory")
_SYS_CLONEFILE_H_ None
CLONE_NOFOLLOW 0x0001
CLONE_NOOWNERCOPY 0x0002
CLONE_ACL 0x0004
CLONE_NOFOLLOW_ANY 0x0008
_SYS_COALITION_H_ None
_SYS_COALITION_PRIVATE_H_ None
COALITION_POLICY_ENTITLEMENT "com.apple.private.coalition-policy"
_SYS_CODEDIR_INTERNAL_H_ None
_SYS_CODESIGN_H_ None
MAC_VNODE_CHECK_DYLD_SIM 0x1
CLEAR_LV_ENTITLEMENT "com.apple.private.security.clear-library-validation"
OVERRIDE_PLUGIN_HOST_ENTITLEMENT "com.apple.private.security.override-plugin-host-detection"
CS_OPS_STATUS 0
CS_OPS_MARKINVALID 1
CS_OPS_MARKHARD 2
CS_OPS_MARKKILL 3
CS_OPS_CDHASH 5
CS_OPS_PIDOFFSET 6
CS_OPS_ENTITLEMENTS_BLOB 7
CS_OPS_MARKRESTRICT 8
CS_OPS_SET_STATUS 9
CS_OPS_BLOB 10
CS_OPS_IDENTITY 11
CS_OPS_CLEARINSTALLER 12
CS_OPS_CLEARPLATFORM 13
CS_OPS_TEAMID 14
CS_OPS_CLEAR_LV 15
CS_OPS_DER_ENTITLEMENTS_BLOB 16
CS_OPS_VALIDATION_CATEGORY 17
CS_MAX_TEAMID_LEN 64
_SYS_CODE_SIGNING_H_ None
XNU_SUPPORTS_CSM_TYPE 1
XNU_SUPPORTS_CSM_APPLE_IMAGE4 1
XNU_SUPPORTS_PROFILE_GARBAGE_COLLECTION 1
XNU_SUPPORTS_COMPILATION_SERVICE 1
XNU_SUPPORTS_LOCAL_SIGNING 1
XNU_SUPPORTS_CE_ACCELERATION 1
XNU_SUPPORTS_DISABLE_CODE_SIGNING_FEATURE 1
XNU_SUPPORTS_IMAGE4_MONITOR_TRAP 1
XNU_SUPPORTS_RESTRICTED_EXECUTION_MODE 1
XNU_SUPPORTS_SECURE_CHANNEL_SHARED_PAGE 1
XNU_SUPPORTS_CSM_DEVICE_STATE 1
XNU_SUPPORTS_REGISTER_PROFILE 1
XNU_LOCAL_SIGNING_KEY_SIZE 97
_SYS_CODE_SIGNING_INTERNAL_H_ None
__CSM_PREFIX(prefix, name) prefix##_##name
_CSM_PREFIX(prefix, name)  __CSM_PREFIX(prefix, name)
CSM_PREFIX(name) _CSM_PREFIX(CODE_SIGNING_MONITOR_PREFIX, name)
_COMMPAGE_H None
_COMM_PAGE32_SIGNATURE_STRING "commpage 32-bit"
_COMM_PAGE64_SIGNATURE_STRING "commpage 64-bit"
COMM_PAGE_SLOT(type_t, name)    ((COMM_PAGE_SLOT_TYPE(type_t))_COMM_PAGE_##name)
COMM_PAGE_READ(type_t, slot)    (*(COMM_PAGE_SLOT(type_t, slot)))
_SYS_CONF_H_ 1
D_TAPE 1
D_DISK 2
D_TTY 3
d_open_t open_close_fcn_t
d_close_t open_close_fcn_t
d_read_t read_write_fcn_t
d_write_t read_write_fcn_t
d_ioctl_t ioctl_fcn_t
d_stop_t stop_fcn_t
d_reset_t reset_fcn_t
d_select_t select_fcn_t
d_mmap_t mmap_fcn_t
d_strategy_t strategy_fcn_t
NO_BDEVICE { eno_opcl,	eno_opcl,	eno_strat, eno_ioctl,   	  eno_dump,	eno_psize,	0       }
CDEVSW_SELECT_KQUEUE 0x01
CDEVSW_USE_OFFSET 0x02
CDEVSW_IS_PTC 0x04
CDEVSW_IS_PTS 0x08
NO_CDEVICE {                                                                   	eno_opcl,	eno_opcl,	eno_rdwrt,	eno_rdwrt,      	eno_ioctl,	eno_stop,	eno_reset,	0,              	(select_fcn_t *)(void (*)(void))seltrue,	eno_mmap,       	eno_strat,	eno_getc,                                       	eno_putc,	0                                                   }
LDISC_LOAD -1
SW_FREED 0x01
SW_SEQUENTIAL 0x02
sw_freed sw_flags
__CONSTRAINED_CTYPES__ None
__CCT_CONTRACT_TAG___CCT_REF _ref
__CCT_CONTRACT_TAG___CCT_CREF _cref
__CCT_CONTRACT_TAG___CCT_BPTR _bptr
__CCT_CONTRACT_TAG___CCT_PTR _ptr
__CCT_DEFER(F, ...) F(__VA_ARGS__)
__CCT_CONTRACT_TO_ATTR(kind) __CONCAT(__CCT_CONTRACT_ATTR_, kind)
__CCT_CONTRACT_TO_TAG(kind) __CCT_DEFER(__CONCAT, __CCT_CONTRACT_TAG_, kind)
__CCT_COUNT_ARGS1(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, N, ...) N
__CCT_COUNT_ARGS(...) __CCT_COUNT_ARGS1(, __VA_ARGS__, _9, _8, _7, _6, _5, _4, _3, _2, _1, _0)
__CCT_DISPATCH1(base, N, ...) __CONCAT(base, N)(__VA_ARGS__)
__CCT_DISPATCH(base, ...) 	__CCT_DISPATCH1(base, __CCT_COUNT_ARGS(__VA_ARGS__), __VA_ARGS__)
__CCT_CONTRACT_LIST_TO_TAGGED_SUFFIX_1(kind) __CCT_DEFER(__CONCAT, __CCT_CONTRACT_TO_TAG(kind), _t)
__CCT_CONTRACT_LIST_TO_TAGGED_SUFFIX_2(kind1, kind2)                                        	__CCT_DEFER(__CONCAT, __CCT_CONTRACT_TO_TAG(kind1),                                             	         __CCT_CONTRACT_LIST_TO_TAGGED_SUFFIX_1(kind2))
__CCT_CONTRACT_LIST_TO_TAGGED_SUFFIX_3(kind1, kind2, kind3)                                 	__CCT_DEFER(__CONCAT, __CCT_CONTRACT_TO_TAG(kind1),                                             	         __CCT_CONTRACT_LIST_TO_TAGGED_SUFFIX_2(kind2, kind3))
__CCT_DECLARE_CONSTRAINED_PTR_TYPE_3(basetype, basetag, kind)                               typedef basetype * __CCT_CONTRACT_TO_ATTR(kind)                                                     	__CCT_DEFER(__CONCAT, basetag,  __CCT_CONTRACT_LIST_TO_TAGGED_SUFFIX_1(kind))
__CCT_DECLARE_CONSTRAINED_PTR_TYPE_4(basetype, basetag, kind1, kind2)                       typedef basetype * __CCT_CONTRACT_TO_ATTR(kind1)                                                    	         * __CCT_CONTRACT_TO_ATTR(kind2)                                                        	__CCT_DEFER(__CONCAT, basetag,  __CCT_CONTRACT_LIST_TO_TAGGED_SUFFIX_2(kind1, kind2))
__CCT_DECLARE_CONSTRAINED_PTR_TYPE_5(basetype, basetag, kind1, kind2, kind3)                typedef basetype * __CCT_CONTRACT_TO_ATTR(kind1)                                                    	         * __CCT_CONTRACT_TO_ATTR(kind2)                                                        	         * __CCT_CONTRACT_TO_ATTR(kind3)                                                        	__CCT_DEFER(__CONCAT, basetag,  __CCT_CONTRACT_LIST_TO_TAGGED_SUFFIX_3(kind1, kind2, kind3))
__CCT_DECLARE_CONSTRAINED_PTR_TYPE(basetype, basetag, ...)                                  	__CCT_DISPATCH(__CCT_DECLARE_CONSTRAINED_PTR_TYPE, basetype, basetag, __VA_ARGS__)
__CCT_DECLARE_CONSTRAINED_PTR_TYPES(basetype, basetag)                                      __CCT_DECLARE_CONSTRAINED_PTR_TYPE(basetype, basetag, __CCT_REF);                                   __CCT_DECLARE_CONSTRAINED_PTR_TYPE(basetype, basetag, __CCT_BPTR);                                  __CCT_DECLARE_CONSTRAINED_PTR_TYPE(basetype, basetag, __CCT_PTR);                                   __CCT_DECLARE_CONSTRAINED_PTR_TYPE(basetype, basetag, __CCT_REF, __CCT_REF);                        __CCT_DECLARE_CONSTRAINED_PTR_TYPE(basetype, basetag, __CCT_REF, __CCT_PTR);                        __CCT_DECLARE_CONSTRAINED_PTR_TYPE(basetype, basetag, __CCT_PTR, __CCT_REF)
_SYS_CONTENT_PROTECTION_H_ None
PROTECTION_CLASS_DIR_NONE 0
PROTECTION_CLASS_A 1
PROTECTION_CLASS_B 2
PROTECTION_CLASS_C 3
PROTECTION_CLASS_D 4
PROTECTION_CLASS_E 5
PROTECTION_CLASS_F 6
PROTECTION_CLASS_CX 7
PROTECTION_CLASS_MIN PROTECTION_CLASS_A
PROTECTION_CLASS_MAX PROTECTION_CLASS_CX
_SYS_CPROTECT_H_ None
CP_CODE(code) FSDBG_CODE(DBG_CONTENT_PROT, code)
CP_DEBUG(x, a, b, c, d, e) do {} while (0);
CP_MAX_WRAPPEDKEYSIZE 128
VFS_CP_MAX_CACHEBUFLEN 64
CP_RAW_KEY_WRAPPEDKEY 0x00000001
_SYS_CROSSARCH_H_ None
CROSSARCH_ROSETTA 0
CROSSARCH_MAX_VALID_NAMESPACE CROSSARCH_ROSETTA
_SYS_CSR_H_ None
_SYS_DECMPFS_H_ 1
DECMPDBG_CODE(code) FSDBG_CODE(DBG_DECMP, code)
MAX_DECMPFS_XATTR_SIZE 3802
DECMPFS_MAGIC 0x636d7066
DECMPFS_XATTR_NAME "com.apple.decmpfs"
DECMPFS_PKG_SIZE_MASK 0x000000ffffffffffULL
DECMPFS_PKG_COUNT_MASK 0xffffff
DECMPFS_PKG_CHLD_COUNT_SHIFT 40
DECMPFS_PKG_VALUE_FROM_SIZE_COUNT(size, count) 	(((size) & DECMPFS_PKG_SIZE_MASK) | ((uint64_t)(count) << DECMPFS_PKG_CHLD_COUNT_SHIFT))
DATALESS_CMPFS_TYPE 0x80000001
DATALESS_PKG_CMPFS_TYPE 0x80000002
DECMPFS_REGISTRATION_VERSION_V1 1
DECMPFS_REGISTRATION_VERSION_V3 3
_SYS_DIR_H_ None
direct dirent
_SYS_DIRENT_H None
__DARWIN_MAXNAMLEN 255
__DARWIN_MAXPATHLEN 1024
__DARWIN_STRUCT_DIRENTRY { 	__uint64_t  d_ino;       	__uint64_t  d_seekoff;   	__uint16_t  d_reclen;    	__uint16_t  d_namlen;    	__uint8_t   d_type;      	char      d_name[__DARWIN_MAXPATHLEN];  }
_SYS_DIRENT_PRIVATE_H None
GETDIRENTRIES64_EXTENDED_BUFSIZE 1024
_SYS_DISK_H_ None
DK_FEATURE_BARRIER 0x00000002
DK_FEATURE_PRIORITY 0x00000004
DK_FEATURE_UNMAP 0x00000010
DK_SYNCHRONIZE_OPTION_BARRIER 0x00000002
DK_CORESTORAGE_PIN_YOUR_METADATA 0x00000001
DK_CORESTORAGE_ENABLE_HOTFILES 0x00000002
DK_CORESTORAGE_PIN_YOUR_SWAPFILE 0x00000004
DK_PROVISION_TYPE_MAPPED 0x00
DK_PROVISION_TYPE_DEALLOCATED 0x01
DK_PROVISION_TYPE_ANCHORED 0x02
DK_LOCATION_INTERNAL 0x00000000
DK_LOCATION_EXTERNAL 0x00000001
_DK_UNMAP_INITIALIZE 0x00000100
DKIOCEJECT _IO('d', 21)
DKIOCSYNCHRONIZE _IOW('d', 22, dk_synchronize_t)
DKIOCFORMAT _IOW('d', 26, dk_format_capacity_t)
DKIOCGETFORMATCAPACITIES _IOWR('d', 26, dk_format_capacities_t)
DKIOCGETBLOCKSIZE _IOR('d', 24, uint32_t)
DKIOCGETBLOCKCOUNT _IOR('d', 25, uint64_t)
DKIOCGETFIRMWAREPATH _IOR('d', 28, dk_firmware_path_t)
DKIOCISFORMATTED _IOR('d', 23, uint32_t)
DKIOCISWRITABLE _IOR('d', 29, uint32_t)
DKIOCREQUESTIDLE _IO('d', 30)
DKIOCUNMAP _IOW('d', 31, dk_unmap_t)
DKIOCCORESTORAGE _IOR('d', 32, dk_corestorage_info_t)
DKIOCGETLOCATION _IOR('d', 33, uint64_t)
DKIOCGETMAXBLOCKCOUNTREAD _IOR('d', 64, uint64_t)
DKIOCGETMAXBLOCKCOUNTWRITE _IOR('d', 65, uint64_t)
DKIOCGETMAXBYTECOUNTREAD _IOR('d', 70, uint64_t)
DKIOCGETMAXBYTECOUNTWRITE _IOR('d', 71, uint64_t)
DKIOCGETMAXSEGMENTCOUNTREAD _IOR('d', 66, uint64_t)
DKIOCGETMAXSEGMENTCOUNTWRITE _IOR('d', 67, uint64_t)
DKIOCGETMAXSEGMENTBYTECOUNTREAD _IOR('d', 68, uint64_t)
DKIOCGETMAXSEGMENTBYTECOUNTWRITE _IOR('d', 69, uint64_t)
DKIOCGETMINSEGMENTALIGNMENTBYTECOUNT _IOR('d', 74, uint64_t)
DKIOCGETMAXSEGMENTADDRESSABLEBITCOUNT _IOR('d', 75, uint64_t)
DKIOCGETFEATURES _IOR('d', 76, uint32_t)
DKIOCGETPHYSICALBLOCKSIZE _IOR('d', 77, uint32_t)
DKIOCGETCOMMANDPOOLSIZE _IOR('d', 78, uint32_t)
DKIOCGETPROVISIONSTATUS _IOWR('d', 79, dk_provision_status_t)
DKIOCGETERRORDESCRIPTION _IOR('d', 80, dk_error_description_t)
DKIOCSYNCHRONIZECACHE _IO('d', 22)
DK_FEATURE_FORCE_UNIT_ACCESS 0x00000001
DK_ENCRYPTION_TYPE_AES_CBC 1
DK_ENCRYPTION_TYPE_AES_XEX 2
DK_ENCRYPTION_TYPE_AES_XTS 3
DK_TIER_MASK 0xC0
DK_TIER_SHIFT 6
DKIOCSETBLOCKSIZE _IOW('d', 24, uint32_t)
DKIOCGETBSDUNIT _IOR('d', 27, uint32_t)
DKIOCISSOLIDSTATE _IOR('d', 79, uint32_t)
DKIOCISVIRTUAL _IOR('d', 72, uint32_t)
DKIOCGETBASE _IOR('d', 73, uint64_t)
DKIOCGETTHROTTLEMASK _IOR('d', 80, uint64_t)
DKIOCLOCKPHYSICALEXTENTS _IO('d', 81)
DKIOCGETPHYSICALEXTENT _IOWR('d', 82, dk_physical_extent_t)
DKIOCUNLOCKPHYSICALEXTENTS _IO('d', 83)
DKIOCSETTIER _IOW('d', 85, dk_set_tier_t)
DKIOCGETENCRYPTIONTYPE _IOR('d', 86, uint32_t)
DKIOCISLOWPOWERMODE _IOR('d', 87, uint32_t)
DKIOCGETIOMINSATURATIONBYTECOUNT _IOR('d', 88, uint32_t)
DKIOCGETMEMDEVINFO _IOR('d', 90, dk_memdev_info_t)
_DKIOCCSSETLVNAME _IOW('d', 198, char[256])
_DKIOCCSPINEXTENT _IOW('d', 199, _dk_cs_pin_t)
_DKIOCCSUNPINEXTENT _IOW('d', 200, _dk_cs_pin_t)
_DKIOCGETMIGRATIONUNITBYTESIZE _IOR('d', 201, uint32_t)
_DKIOCCSMAP _IOWR('d', 202, _dk_cs_map_t)
_DKIOCCSUNMAP _IOWR('d', 205, _dk_cs_unmap_t)
DKIOCGETAPFSFLAVOUR _IOR('d', 91, dk_apfs_flavour_t)
DKIOCAPFSGETWBCRANGE _IOR('d', 92, dk_apfs_wbc_range_t)
DKIOCAPFSRELEASEWBCRANGE _IO('d', 93)
DKIOCGETMAXSWAPWRITE _IOR('d', 94, uint64_t)
_DKIOCSETSTATIC _IO('d', 84)
_SYS_DISKLABEL_H_ None
_SYS_DISKTAB_ None
_SYS_DIS_TABLES_H_ None
_SYS_DKSTAT_H_ None
_SYS_DMAP_H_ None
SYS_DOC_TOMBSTONE_H_ None
_SYS_DOMAIN_H_ None
DOM_REENTRANT 0x1
DOM_INITIALIZED 0x2
DOM_ATTACHED 0x4
DOM_OLD 0x10000000
_SYS_DTRACE_H None
DTRACE_CPUALL -1
DTRACE_IDNONE 0
DTRACE_EPIDNONE 0
DTRACE_AGGIDNONE 0
DTRACE_AGGVARIDNONE 0
DTRACE_CACHEIDNONE 0
DTRACE_PROVNONE 0
DTRACE_METAPROVNONE 0
DTRACE_ARGNONE -1
DTRACE_PROVNAMELEN 64
DTRACE_MODNAMELEN 64
DTRACE_FUNCNAMELEN 128
DTRACE_NAMELEN 64
DTRACE_ARGTYPELEN 128
DIF_VERSION_1 1
DIF_VERSION_2 2
DIF_VERSION DIF_VERSION_2
DIF_DIR_NREGS 8
DIF_DTR_NREGS 8
DIF_OP_OR 1
DIF_OP_XOR 2
DIF_OP_AND 3
DIF_OP_SLL 4
DIF_OP_SRL 5
DIF_OP_SUB 6
DIF_OP_ADD 7
DIF_OP_MUL 8
DIF_OP_SDIV 9
DIF_OP_UDIV 10
DIF_OP_SREM 11
DIF_OP_UREM 12
DIF_OP_NOT 13
DIF_OP_MOV 14
DIF_OP_CMP 15
DIF_OP_TST 16
DIF_OP_BA 17
DIF_OP_BE 18
DIF_OP_BNE 19
DIF_OP_BG 20
DIF_OP_BGU 21
DIF_OP_BGE 22
DIF_OP_BGEU 23
DIF_OP_BL 24
DIF_OP_BLU 25
DIF_OP_BLE 26
DIF_OP_BLEU 27
DIF_OP_LDSB 28
DIF_OP_LDSH 29
DIF_OP_LDSW 30
DIF_OP_LDUB 31
DIF_OP_LDUH 32
DIF_OP_LDUW 33
DIF_OP_LDX 34
DIF_OP_RET 35
DIF_OP_NOP 36
DIF_OP_SETX 37
DIF_OP_SETS 38
DIF_OP_SCMP 39
DIF_OP_LDGA 40
DIF_OP_LDGS 41
DIF_OP_STGS 42
DIF_OP_LDTA 43
DIF_OP_LDTS 44
DIF_OP_STTS 45
DIF_OP_SRA 46
DIF_OP_CALL 47
DIF_OP_PUSHTR 48
DIF_OP_PUSHTV 49
DIF_OP_POPTS 50
DIF_OP_FLUSHTS 51
DIF_OP_LDGAA 52
DIF_OP_LDTAA 53
DIF_OP_STGAA 54
DIF_OP_STTAA 55
DIF_OP_LDLS 56
DIF_OP_STLS 57
DIF_OP_ALLOCS 58
DIF_OP_COPYS 59
DIF_OP_STB 60
DIF_OP_STH 61
DIF_OP_STW 62
DIF_OP_STX 63
DIF_OP_ULDSB 64
DIF_OP_ULDSH 65
DIF_OP_ULDSW 66
DIF_OP_ULDUB 67
DIF_OP_ULDUH 68
DIF_OP_ULDUW 69
DIF_OP_ULDX 70
DIF_OP_RLDSB 71
DIF_OP_RLDSH 72
DIF_OP_RLDSW 73
DIF_OP_RLDUB 74
DIF_OP_RLDUH 75
DIF_OP_RLDUW 76
DIF_OP_RLDX 77
DIF_OP_XLATE 78
DIF_OP_XLARG 79
DIF_OP_STRIP 80
DIF_INTOFF_MAX 0xffff
DIF_STROFF_MAX 0xffff
DIF_REGISTER_MAX 0xff
DIF_VARIABLE_MAX 0xffff
DIF_SUBROUTINE_MAX 0xffff
DIF_VAR_ARRAY_MIN 0x0000
DIF_VAR_ARRAY_UBASE 0x0080
DIF_VAR_ARRAY_MAX 0x00ff
DIF_VAR_OTHER_MIN 0x0100
DIF_VAR_OTHER_UBASE 0x0500
DIF_VAR_OTHER_MAX 0xffff
DIF_VAR_ARGS 0x0000
DIF_VAR_REGS 0x0001
DIF_VAR_UREGS 0x0002
DIF_VAR_VMREGS 0x0003
DIF_VAR_CURTHREAD 0x0100
DIF_VAR_TIMESTAMP 0x0101
DIF_VAR_VTIMESTAMP 0x0102
DIF_VAR_IPL 0x0103
DIF_VAR_EPID 0x0104
DIF_VAR_ID 0x0105
DIF_VAR_ARG0 0x0106
DIF_VAR_ARG1 0x0107
DIF_VAR_ARG2 0x0108
DIF_VAR_ARG3 0x0109
DIF_VAR_ARG4 0x010a
DIF_VAR_ARG5 0x010b
DIF_VAR_ARG6 0x010c
DIF_VAR_ARG7 0x010d
DIF_VAR_ARG8 0x010e
DIF_VAR_ARG9 0x010f
DIF_VAR_STACKDEPTH 0x0110
DIF_VAR_CALLER 0x0111
DIF_VAR_PROBEPROV 0x0112
DIF_VAR_PROBEMOD 0x0113
DIF_VAR_PROBEFUNC 0x0114
DIF_VAR_PROBENAME 0x0115
DIF_VAR_PID 0x0116
DIF_VAR_TID 0x0117
DIF_VAR_EXECNAME 0x0118
DIF_VAR_ZONENAME 0x0119
DIF_VAR_WALLTIMESTAMP 0x011a
DIF_VAR_USTACKDEPTH 0x011b
DIF_VAR_UCALLER 0x011c
DIF_VAR_PPID 0x011d
DIF_VAR_UID 0x011e
DIF_VAR_GID 0x011f
DIF_VAR_ERRNO 0x0120
DIF_VAR_PTHREAD_SELF 0x0200
DIF_VAR_DISPATCHQADDR 0x0201
DIF_VAR_MACHTIMESTAMP 0x0202
DIF_VAR_CPU 0x0203
DIF_VAR_CPUINSTRS 0x0204
DIF_VAR_CPUCYCLES 0x0205
DIF_VAR_VINSTRS 0x0206
DIF_VAR_VCYCLES 0x0207
DIF_VAR_MACHCTIMESTAMP 0x0208
DIF_SUBR_RAND 0
DIF_SUBR_MUTEX_OWNED 1
DIF_SUBR_MUTEX_OWNER 2
DIF_SUBR_MUTEX_TYPE_ADAPTIVE 3
DIF_SUBR_MUTEX_TYPE_SPIN 4
DIF_SUBR_RW_READ_HELD 5
DIF_SUBR_RW_WRITE_HELD 6
DIF_SUBR_RW_ISWRITER 7
DIF_SUBR_COPYIN 8
DIF_SUBR_COPYINSTR 9
DIF_SUBR_SPECULATION 10
DIF_SUBR_PROGENYOF 11
DIF_SUBR_STRLEN 12
DIF_SUBR_COPYOUT 13
DIF_SUBR_COPYOUTSTR 14
DIF_SUBR_ALLOCA 15
DIF_SUBR_BCOPY 16
DIF_SUBR_COPYINTO 17
DIF_SUBR_MSGDSIZE 18
DIF_SUBR_MSGSIZE 19
DIF_SUBR_GETMAJOR 20
DIF_SUBR_GETMINOR 21
DIF_SUBR_DDI_PATHNAME 22
DIF_SUBR_STRJOIN 23
DIF_SUBR_LLTOSTR 24
DIF_SUBR_BASENAME 25
DIF_SUBR_DIRNAME 26
DIF_SUBR_CLEANPATH 27
DIF_SUBR_STRCHR 28
DIF_SUBR_STRRCHR 29
DIF_SUBR_STRSTR 30
DIF_SUBR_STRTOK 31
DIF_SUBR_SUBSTR 32
DIF_SUBR_INDEX 33
DIF_SUBR_RINDEX 34
DIF_SUBR_HTONS 35
DIF_SUBR_HTONL 36
DIF_SUBR_HTONLL 37
DIF_SUBR_NTOHS 38
DIF_SUBR_NTOHL 39
DIF_SUBR_NTOHLL 40
DIF_SUBR_INET_NTOP 41
DIF_SUBR_INET_NTOA 42
DIF_SUBR_INET_NTOA6 43
DIF_SUBR_TOUPPER 44
DIF_SUBR_TOLOWER 45
DIF_SUBR_JSON 46
DIF_SUBR_STRTOLL 47
DIF_SUBR_STRIP 48
DIF_SUBR_MAX 48
DIF_SUBR_APPLE_MIN 200
DIF_SUBR_VM_KERNEL_ADDRPERM 200
DIF_SUBR_KDEBUG_TRACE 201
DIF_SUBR_KDEBUG_TRACE_STRING 202
DIF_SUBR_MTONS 203
DIF_SUBR_PHYSMEM_READ 204
DIF_SUBR_PHYSMEM_WRITE 205
DIF_SUBR_KVTOPHYS 206
DIF_SUBR_LIVEDUMP 207
DIF_SUBR_APPLE_MAX 207
DIF_INSTR_FMT(op, r1, r2, d)         (((op) << 24) | ((r1) << 16) | ((r2) << 8) | (d))
DIF_INSTR_NOT(r1, d)            (DIF_INSTR_FMT(DIF_OP_NOT, r1, 0, d))
DIF_INSTR_MOV(r1, d)            (DIF_INSTR_FMT(DIF_OP_MOV, r1, 0, d))
DIF_INSTR_CMP(op, r1, r2)       (DIF_INSTR_FMT(op, r1, r2, 0))
DIF_INSTR_BRANCH(op, label)     (((op) << 24) | (label))
DIF_INSTR_LOAD(op, r1, d)       (DIF_INSTR_FMT(op, r1, 0, d))
DIF_INSTR_STORE(op, r1, d)      (DIF_INSTR_FMT(op, r1, 0, d))
DIF_INSTR_SETX(i, d)            ((DIF_OP_SETX << 24) | ((i) << 8) | (d))
DIF_INSTR_SETS(s, d)            ((DIF_OP_SETS << 24) | ((s) << 8) | (d))
DIF_INSTR_LDA(op, v, r, d)      (DIF_INSTR_FMT(op, v, r, d))
DIF_INSTR_LDV(op, v, d)         (((op) << 24) | ((v) << 8) | (d))
DIF_INSTR_STV(op, v, rs)        (((op) << 24) | ((v) << 8) | (rs))
DIF_INSTR_CALL(s, d)            ((DIF_OP_CALL << 24) | ((s) << 8) | (d))
DIF_INSTR_PUSHTS(op, t, r2, rs) (DIF_INSTR_FMT(op, t, r2, rs))
DIF_INSTR_ALLOCS(r1, d)         (DIF_INSTR_FMT(DIF_OP_ALLOCS, r1, 0, d))
DIF_INSTR_COPYS(r1, r2, d)      (DIF_INSTR_FMT(DIF_OP_COPYS, r1, r2, d))
DIF_INSTR_XLATE(op, r, d)       (((op) << 24) | ((r) << 8) | (d))
DIF_REG_R0 0
DIF_TYPE_CTF 0
DIF_TYPE_STRING 1
DIF_TF_BYREF 0x1
DIF_TF_BYUREF 0x2
DIFV_KIND_ARRAY 0
DIFV_KIND_SCALAR 1
DIFV_SCOPE_GLOBAL 0
DIFV_SCOPE_THREAD 1
DIFV_SCOPE_LOCAL 2
DIFV_F_REF 0x1
DIFV_F_MOD 0x2
DTRACEACT_NONE 0
DTRACEACT_DIFEXPR 1
DTRACEACT_EXIT 2
DTRACEACT_PRINTF 3
DTRACEACT_PRINTA 4
DTRACEACT_LIBACT 5
DTRACEACT_TRACEMEM 6
DTRACEACT_TRACEMEM_DYNSIZE 7
DTRACEACT_APPLEBINARY 50
DTRACEACT_PROC 0x0100
DTRACEACT_PROC_DESTRUCTIVE 0x0200
DTRACEACT_PROC_CONTROL 0x0300
DTRACEACT_KERNEL 0x0400
DTRACEACT_KERNEL_DESTRUCTIVE 0x0500
DTRACEACT_SPECULATIVE 0x0600
DTRACEACT_AGGREGATION 0x0700
DTRACE_LQUANTIZE_STEPSHIFT 48
DTRACE_LQUANTIZE_LEVELSHIFT 32
DTRACE_LQUANTIZE_BASESHIFT 0
DTRACE_LQUANTIZE_BASEMASK UINT32_MAX
DTRACE_LLQUANTIZE_FACTORSHIFT 48
DTRACE_LLQUANTIZE_LOWSHIFT 32
DTRACE_LLQUANTIZE_HIGHSHIFT 16
DTRACE_LLQUANTIZE_NSTEPSHIFT 0
DTRACE_LLQUANTIZE_NSTEPMASK UINT16_MAX
DTRACE_USTACK_ARG(x, y)                 ((((uint64_t)(y)) << 32) | ((x) & UINT32_MAX))
DOF_ID_SIZE 16
DOF_ID_MAG0 0
DOF_ID_MAG1 1
DOF_ID_MAG2 2
DOF_ID_MAG3 3
DOF_ID_MODEL 4
DOF_ID_ENCODING 5
DOF_ID_VERSION 6
DOF_ID_DIFVERS 7
DOF_ID_DIFIREG 8
DOF_ID_DIFTREG 9
DOF_ID_PAD 10
DOF_MAG_MAG0 0x7F
DOF_MAG_MAG1 'D'
DOF_MAG_MAG2 'O'
DOF_MAG_MAG3 'F'
DOF_MAG_STRING "\177DOF"
DOF_MAG_STRLEN 4
DOF_MODEL_NONE 0
DOF_MODEL_ILP32 1
DOF_MODEL_LP64 2
DOF_ENCODE_NONE 0
DOF_ENCODE_LSB 1
DOF_ENCODE_MSB 2
DOF_VERSION_1 1
DOF_VERSION_2 2
DOF_FL_VALID 0
DOF_SECT_NONE 0
DOF_SECT_COMMENTS 1
DOF_SECT_SOURCE 2
DOF_SECT_ECBDESC 3
DOF_SECT_PROBEDESC 4
DOF_SECT_ACTDESC 5
DOF_SECT_DIFOHDR 6
DOF_SECT_DIF 7
DOF_SECT_STRTAB 8
DOF_SECT_VARTAB 9
DOF_SECT_RELTAB 10
DOF_SECT_TYPTAB 11
DOF_SECT_URELHDR 12
DOF_SECT_KRELHDR 13
DOF_SECT_OPTDESC 14
DOF_SECT_PROVIDER 15
DOF_SECT_PROBES 16
DOF_SECT_PRARGS 17
DOF_SECT_PROFFS 18
DOF_SECT_INTTAB 19
DOF_SECT_UTSNAME 20
DOF_SECT_XLTAB 21
DOF_SECT_XLMEMBERS 22
DOF_SECT_XLIMPORT 23
DOF_SECT_XLEXPORT 24
DOF_SECT_PREXPORT 25
DOF_SECT_PRENOFFS 26
DOF_SECF_LOAD 1
DOF_RELO_NONE 0
DOF_RELO_SETX 1
DOF_ATTR(n, d, c)       (((n) << 24) | ((d) << 16) | ((c) << 8))
DTRACEOPT_BUFSIZE 0
DTRACEOPT_BUFPOLICY 1
DTRACEOPT_DYNVARSIZE 2
DTRACEOPT_AGGSIZE 3
DTRACEOPT_SPECSIZE 4
DTRACEOPT_NSPEC 5
DTRACEOPT_STRSIZE 6
DTRACEOPT_CLEANRATE 7
DTRACEOPT_CPU 8
DTRACEOPT_BUFRESIZE 9
DTRACEOPT_GRABANON 10
DTRACEOPT_FLOWINDENT 11
DTRACEOPT_QUIET 12
DTRACEOPT_STACKFRAMES 13
DTRACEOPT_USTACKFRAMES 14
DTRACEOPT_AGGRATE 15
DTRACEOPT_SWITCHRATE 16
DTRACEOPT_STATUSRATE 17
DTRACEOPT_DESTRUCTIVE 18
DTRACEOPT_STACKINDENT 19
DTRACEOPT_RAWBYTES 20
DTRACEOPT_JSTACKFRAMES 21
DTRACEOPT_JSTACKSTRSIZE 22
DTRACEOPT_AGGSORTKEY 23
DTRACEOPT_AGGSORTREV 24
DTRACEOPT_AGGSORTPOS 25
DTRACEOPT_AGGSORTKEYPOS 26
DTRACEOPT_AGGHIST 27
DTRACEOPT_AGGPACK 28
DTRACEOPT_AGGZOOM 29
DTRACEOPT_TEMPORAL 30
DTRACEOPT_BUFPOLICY_RING 0
DTRACEOPT_BUFPOLICY_FILL 1
DTRACEOPT_BUFPOLICY_SWITCH 2
DTRACEOPT_BUFRESIZE_AUTO 0
DTRACEOPT_BUFRESIZE_MANUAL 1
DTRACE_RECORD_STORE_TIMESTAMP(dtrh, hrtime) {			(dtrh)->dtrh_timestamp_lo = (uint32_t)hrtime;			(dtrh)->dtrh_timestamp_hi = hrtime >> 32;		}
DTRACEFLT_UNKNOWN 0
DTRACEFLT_BADADDR 1
DTRACEFLT_BADALIGN 2
DTRACEFLT_ILLOP 3
DTRACEFLT_DIVZERO 4
DTRACEFLT_NOSCRATCH 5
DTRACEFLT_KPRIV 6
DTRACEFLT_UPRIV 7
DTRACEFLT_TUPOFLOW 8
DTRACEFLT_BADSTACK 9
DTRACEFLT_LIBRARY 1000
DTRACE_STABILITY_INTERNAL 0
DTRACE_STABILITY_PRIVATE 1
DTRACE_STABILITY_OBSOLETE 2
DTRACE_STABILITY_EXTERNAL 3
DTRACE_STABILITY_UNSTABLE 4
DTRACE_STABILITY_EVOLVING 5
DTRACE_STABILITY_STABLE 6
DTRACE_STABILITY_STANDARD 7
DTRACE_STABILITY_MAX 7
DTRACE_CLASS_UNKNOWN 0
DTRACE_CLASS_CPU 1
DTRACE_CLASS_PLATFORM 2
DTRACE_CLASS_GROUP 3
DTRACE_CLASS_ISA 4
DTRACE_CLASS_COMMON 5
DTRACE_CLASS_MAX 5
DTRACE_PRIV_NONE 0x0000
DTRACE_PRIV_KERNEL 0x0001
DTRACE_PRIV_USER 0x0002
DTRACE_PRIV_PROC 0x0004
DTRACE_PRIV_OWNER 0x0008
DTRACE_PRIV_ZONEOWNER 0x0010
DTRACEMNR_DTRACE "dtrace"
DTRACEMNRN_DTRACE 0
DTRACEMNRN_HELPER 1
DTRACEMNRN_CLONE 2
DTRACE_INVOP_NOP 4
DTRACE_INVOP_RET 5
DTRACE_INVOP_B 6
_DTRACE_GLUE_H None
_SYS_DTRACE_IMPL_H None
DTRACE_MAXPROPLEN 128
DTRACE_DYNVAR_CHUNKSIZE 256
DTRACEBUF_RING 0x0001
DTRACEBUF_FILL 0x0002
DTRACEBUF_NOSWITCH 0x0004
DTRACEBUF_WRAPPED 0x0008
DTRACEBUF_DROPPED 0x0010
DTRACEBUF_ERROR 0x0020
DTRACEBUF_FULL 0x0040
DTRACEBUF_CONSUMED 0x0080
DTRACEBUF_INACTIVE 0x0100
DTRACE_MSTATE_ARGS 0x00000001
DTRACE_MSTATE_PROBE 0x00000002
DTRACE_MSTATE_EPID 0x00000004
DTRACE_MSTATE_TIMESTAMP 0x00000008
DTRACE_MSTATE_STACKDEPTH 0x00000010
DTRACE_MSTATE_CALLER 0x00000020
DTRACE_MSTATE_IPL 0x00000040
DTRACE_MSTATE_FLTOFFS 0x00000080
DTRACE_MSTATE_WALLTIMESTAMP 0x00000100
DTRACE_MSTATE_USTACKDEPTH 0x00000200
DTRACE_MSTATE_UCALLER 0x00000400
DTRACE_MSTATE_MACHTIMESTAMP 0x00000800
DTRACE_MSTATE_MACHCTIMESTAMP 0x00001000
DTRACE_COND_OWNER 0x1
DTRACE_COND_USERMODE 0x2
DTRACE_COND_ZONEOWNER 0x4
DTRACE_PROBEKEY_MAXDEPTH 8
DTRACE_ACCESS_KERNEL 0x1
DTRACE_DOF_MODE_NEVER 0
DTRACE_DOF_MODE_LAZY_ON 1
DTRACE_DOF_MODE_LAZY_OFF 2
DTRACE_DOF_MODE_NON_LAZY 3
DTRACE_KERNEL_SYMBOLS_NEVER 0
DTRACE_KERNEL_SYMBOLS_FROM_KERNEL 1
DTRACE_KERNEL_SYMBOLS_FROM_USERSPACE 2
DTRACE_KERNEL_SYMBOLS_ALWAYS_FROM_KERNEL 3
DTRACE_HELPER_ACTION_USTACK 0
DTRACE_NHELPER_ACTIONS 1
DTRACE_CRV_ALLPROC 0x01
DTRACE_CRV_KERNEL 0x02
DTRACE_CRV_ALLZONE 0x04
DTRACE_CRA_PROC 0x0001
DTRACE_CRA_PROC_CONTROL 0x0002
DTRACE_CRA_PROC_DESTRUCTIVE_ALLUSER 0x0004
DTRACE_CRA_PROC_DESTRUCTIVE_ALLZONE 0x0008
DTRACE_CRA_PROC_DESTRUCTIVE_CREDCHG 0x0010
DTRACE_CRA_KERNEL 0x0020
DTRACE_CRA_KERNEL_DESTRUCTIVE 0x0040
_DTRACE_PTSS_H_ None
_SYS_ERRNO_H_ None
EPERM 1
ENOENT 2
ESRCH 3
EINTR 4
EIO 5
ENXIO 6
E2BIG 7
ENOEXEC 8
EBADF 9
ECHILD 10
EDEADLK 11
ENOMEM 12
EACCES 13
EFAULT 14
ENOTBLK 15
EBUSY 16
EEXIST 17
EXDEV 18
ENODEV 19
ENOTDIR 20
EISDIR 21
EINVAL 22
ENFILE 23
EMFILE 24
ENOTTY 25
ETXTBSY 26
EFBIG 27
ENOSPC 28
ESPIPE 29
EROFS 30
EMLINK 31
EPIPE 32
EDOM 33
ERANGE 34
EAGAIN 35
EWOULDBLOCK EAGAIN
EINPROGRESS 36
EALREADY 37
ENOTSOCK 38
EDESTADDRREQ 39
EMSGSIZE 40
EPROTOTYPE 41
ENOPROTOOPT 42
EPROTONOSUPPORT 43
ESOCKTNOSUPPORT 44
ENOTSUP 45
EPFNOSUPPORT 46
EAFNOSUPPORT 47
EADDRINUSE 48
EADDRNOTAVAIL 49
ENETDOWN 50
ENETUNREACH 51
ENETRESET 52
ECONNABORTED 53
ECONNRESET 54
ENOBUFS 55
EISCONN 56
ENOTCONN 57
ESHUTDOWN 58
ETOOMANYREFS 59
ETIMEDOUT 60
ECONNREFUSED 61
ELOOP 62
ENAMETOOLONG 63
EHOSTDOWN 64
EHOSTUNREACH 65
ENOTEMPTY 66
EPROCLIM 67
EUSERS 68
EDQUOT 69
ESTALE 70
EREMOTE 71
EBADRPC 72
ERPCMISMATCH 73
EPROGUNAVAIL 74
EPROGMISMATCH 75
EPROCUNAVAIL 76
ENOLCK 77
ENOSYS 78
EFTYPE 79
EAUTH 80
ENEEDAUTH 81
EPWROFF 82
EDEVERR 83
EOVERFLOW 84
EBADEXEC 85
EBADARCH 86
ESHLIBVERS 87
EBADMACHO 88
ECANCELED 89
EIDRM 90
ENOMSG 91
EILSEQ 92
ENOATTR 93
EBADMSG 94
EMULTIHOP 95
ENODATA 96
ENOLINK 97
ENOSR 98
ENOSTR 99
EPROTO 100
ETIME 101
EOPNOTSUPP 102
ENOPOLICY 103
EQFULL 106
ELAST 106
ECVCERORR 256
ECVPERORR 512
_SYS_EV_H_ None
EV_FD 1
EV_RE 1
EV_WR 2
EV_EX 4
EV_RM 8
EV_MASK 0xf
EV_RBYTES 0x100
EV_WBYTES 0x200
EV_RCLOSED 0x400
EV_RCONN 0x800
EV_WCLOSED 0x1000
EV_WCONN 0x2000
EV_OOB 0x4000
EV_FIN 0x8000
EV_RESET 0x10000
EV_TIMEOUT 0x20000
EV_DMASK 0xffffff00
_SYS_EVENT_H_ None
EVFILT_SYSCOUNT 18
EVFILT_THREADMARKER EVFILT_SYSCOUNT
EV_SET(kevp, a, b, c, d, e, f) do {     	struct kevent *__kevp__ = (kevp);       	__kevp__->ident = (a);                  	__kevp__->filter = (b);                 	__kevp__->flags = (c);                  	__kevp__->fflags = (d);                 	__kevp__->data = (e);                   	__kevp__->udata = (f);                  } while(0)
EV_SET64(kevp, a, b, c, d, e, f, g, h) do {     	struct kevent64_s *__kevp__ = (kevp);           	__kevp__->ident = (a);                          	__kevp__->filter = (b);                         	__kevp__->flags = (c);                          	__kevp__->fflags = (d);                         	__kevp__->data = (e);                           	__kevp__->udata = (f);                          	__kevp__->ext[0] = (g);                         	__kevp__->ext[1] = (h);                         } while(0)
KEVENT_FLAG_NONE 0x000000
KEVENT_FLAG_IMMEDIATE 0x000001
KEVENT_FLAG_ERROR_EVENTS 0x000002
EV_ADD 0x0001
EV_DELETE 0x0002
EV_ENABLE 0x0004
EV_DISABLE 0x0008
EV_ONESHOT 0x0010
EV_CLEAR 0x0020
EV_RECEIPT 0x0040
EV_DISPATCH 0x0080
EV_UDATA_SPECIFIC 0x0100
EV_VANISHED 0x0200
EV_SYSFLAGS 0xF000
EV_FLAG0 0x1000
EV_FLAG1 0x2000
EV_EOF 0x8000
EV_ERROR 0x4000
EV_POLL EV_FLAG0
EV_OOBAND EV_FLAG1
NOTE_TRIGGER 0x01000000
NOTE_FFNOP 0x00000000
NOTE_FFAND 0x40000000
NOTE_FFOR 0x80000000
NOTE_FFCOPY 0xc0000000
NOTE_FFCTRLMASK 0xc0000000
NOTE_FFLAGSMASK 0x00ffffff
NOTE_LOWAT 0x00000001
NOTE_OOB 0x00000002
NOTE_DELETE 0x00000001
NOTE_WRITE 0x00000002
NOTE_EXTEND 0x00000004
NOTE_ATTRIB 0x00000008
NOTE_LINK 0x00000010
NOTE_RENAME 0x00000020
NOTE_REVOKE 0x00000040
NOTE_NONE 0x00000080
NOTE_FUNLOCK 0x00000100
NOTE_LEASE_DOWNGRADE 0x00000200
NOTE_LEASE_RELEASE 0x00000400
NOTE_EXIT 0x80000000
NOTE_FORK 0x40000000
NOTE_EXEC 0x20000000
NOTE_SIGNAL 0x08000000
NOTE_EXITSTATUS 0x04000000
NOTE_EXIT_DETAIL 0x02000000
NOTE_PDATAMASK 0x000fffff
NOTE_EXIT_DETAIL_MASK 0x00070000
NOTE_EXIT_DECRYPTFAIL 0x00010000
NOTE_EXIT_MEMORY 0x00020000
NOTE_EXIT_CSERROR 0x00040000
NOTE_VM_PRESSURE 0x80000000
NOTE_VM_PRESSURE_TERMINATE 0x40000000
NOTE_VM_PRESSURE_SUDDEN_TERMINATE 0x20000000
NOTE_VM_ERROR 0x10000000
NOTE_SECONDS 0x00000001
NOTE_USECONDS 0x00000002
NOTE_NSECONDS 0x00000004
NOTE_ABSOLUTE 0x00000008
NOTE_LEEWAY 0x00000010
NOTE_CRITICAL 0x00000020
NOTE_BACKGROUND 0x00000040
NOTE_MACH_CONTINUOUS_TIME 0x00000080
NOTE_MACHTIME 0x00000100
NOTE_TRACK 0x00000001
NOTE_TRACKERR 0x00000002
NOTE_CHILD 0x00000004
_SYS_EVENTHANDLER_H_ None
EVENTHANDLER_MAX_NAME 32
EHL_LOCK_INIT(p) lck_mtx_init(&(p)->el_lock, &el_lock_grp, &el_lock_attr)
EHL_LOCK(p) lck_mtx_lock(&(p)->el_lock)
EHL_LOCK_SPIN(p) lck_mtx_lock_spin(&(p)->el_lock)
EHL_LOCK_CONVERT(p) lck_mtx_convert_spin(&(p)->el_lock)
EHL_UNLOCK(p) lck_mtx_unlock(&(p)->el_lock)
EHL_LOCK_ASSERT(p, x)   LCK_MTX_ASSERT(&(p)->el_lock, x)
EHL_LOCK_DESTROY(p) lck_mtx_destroy(&(p)->el_lock, &el_lock_grp)
evhlog(type, ...)       do { if (__improbable(evh_debug >= 1)) os_log_##type(OS_LOG_DEFAULT, __VA_ARGS__); } while (0)
evhlog2(type, ...)      do { if (__improbable(evh_debug >= 2)) os_log_##type(OS_LOG_DEFAULT, __VA_ARGS__); } while (0)
_EVENTHANDLER_INVOKE(name, list, ...) do {                  	struct eventhandler_entry * _ep __single;                       	struct eventhandler_entry_ ## name * _t __single;                                                                                   	VERIFY((list)->el_flags & EHL_INITTED);                         	EHL_LOCK_ASSERT((list), LCK_MTX_ASSERT_OWNED);                  	(list)->el_runcount++;                                          	VERIFY((list)->el_runcount > 0);                                	evhlog2(debug, "eventhandler_invoke(\"" __STRING(name) "\")");  	TAILQ_FOREACH(_ep, &((list)->el_entries), ee_link) {            	        if (_ep->ee_priority != EHE_DEAD_PRIORITY) {            	                EHL_UNLOCK((list));                             	                _t = (struct eventhandler_entry_ ## name *)_ep; 	                evhlog2(debug, "eventhandler_invoke: executing %p", 	                    (void *)VM_KERNEL_UNSLIDE((uint64_t)(_t->eh_func)));   	                _t->eh_func(_ep->ee_arg , ## __VA_ARGS__);      	                EHL_LOCK_SPIN((list));                          	        }                                                       	}                                                               	VERIFY((list)->el_runcount > 0);                                	(list)->el_runcount--;                                          	if ((list)->el_runcount == 0) {                                 	        EHL_LOCK_CONVERT((list));                               	        eventhandler_prune_list(list);                          	}                                                               	EHL_UNLOCK((list));                                             } while (0)
EVENTHANDLER_DECLARE(name, type)                                struct eventhandler_entry_ ## name                                      {                                                                       	struct eventhandler_entry	ee;                             	type				eh_func;                        };                                                                      struct __hack
EVENTHANDLER_DEFINE(evthdlr_ref, name, func, arg, priority)                     	static eventhandler_tag name ## _tag;                           	static void name ## _evh_init(void *ctx)                        	{                                                               	        name ## _tag = EVENTHANDLER_REGISTER(evthdlr_ref, name, func, ctx,      	            priority);                                          	}                                                               	SYSINIT(name ## _evh_init, SI_SUB_CONFIGURE, SI_ORDER_ANY,      	    name ## _evh_init, arg);                                    	struct __hack
EVENTHANDLER_INVOKE(evthdlr_ref, name, ...)                                     do {                                                                    	struct eventhandler_list *__single _el;                                                                                                          	if ((_el = eventhandler_find_list(evthdlr_ref, #name)) != NULL)                 	        _EVENTHANDLER_INVOKE(name, _el , ## __VA_ARGS__);       } while (0)
EVENTHANDLER_REGISTER(evthdlr_ref, name, func, arg, priority)           	eventhandler_register(evthdlr_ref, NULL, #name, ptrauth_nop_cast(void * __single, func), arg, priority)
EVENTHANDLER_DEREGISTER(evthdlr_ref, name, tag)                                 do {                                                                    	struct eventhandler_list *__single _el;                                                                                                          	if ((_el = eventhandler_find_list(evthdlr_ref, #name)) != NULL)         	{                                                               	        evhlog2(debug, "eventhandler_deregister event_type=" __STRING(name) ); 	        eventhandler_deregister(_el, tag);                      	}                                                               } while(0)
EVENTHANDLER_PRI_FIRST 0
EVENTHANDLER_PRI_ANY 10000
EVENTHANDLER_PRI_LAST 20000
_SYS_EVENTVAR_H_ None
KQEXTENT 256
kqf_lock kqf_kqueue.kq_lock
kqf_state kqf_kqueue.kq_state
kqf_level kqf_kqueue.kq_level
kqf_count kqf_kqueue.kq_count
kqf_p kqf_kqueue.kq_p
QOS_INDEX_KQFILE 0
kqwq_lock kqwq_kqueue.kq_lock
kqwq_state kqwq_kqueue.kq_state
kqwq_waitq_hook kqwq_kqueue.kq_waitq_hook
kqwq_count kqwq_kqueue.kq_count
kqwq_p kqwq_kqueue.kq_p
kqwl_lock kqwl_kqueue.kq_lock
kqwl_state kqwl_kqueue.kq_state
kqwl_waitq_hook kqwl_kqueue.kq_waitq_hook
kqwl_count kqwl_kqueue.kq_count
kqwl_p kqwl_kqueue.kq_p
KQ_WORKLOOP_RETAINS_MAX UINT32_MAX
KQUEUE_THREADREQ_BIND_NO_INHERITOR_UPDATE 0x1
KQUEUE_THREADREQ_BIND_SOFT 0x2
_SYSTEM_EVENT_LOG_H_ None
SYSTEM_EVENT_ENTITLEMENT "com.apple.private.record_system_event"
SYSTEM_EVENT_EVENT_MAX 64
SYSTEM_EVENT_PAYLOAD_MAX 96
_SYS_EVENT_PRIVATE_H_ None
KEVENT_FLAG_STACK_DATA 0x000008
KEVENT_FLAG_WORKQ 0x000020
KEVENT_FLAG_WORKQ_MANAGER 0x000200
KEVENT_FLAG_WORKLOOP 0x000400
KEVENT_FLAG_PARKING 0x000800
KEVENT_FLAG_WORKLOOP_SERVICER_ATTACH 0x008000
KEVENT_FLAG_WORKLOOP_SERVICER_DETACH 0x010000
KEVENT_FLAG_DYNAMIC_KQ_MUST_EXIST 0x020000
KEVENT_FLAG_DYNAMIC_KQ_MUST_NOT_EXIST 0x040000
KEVENT_FLAG_WORKLOOP_NO_WQ_THREAD 0x080000
KEVENT_FLAG_POLL 0x0010
KEVENT_FLAG_LEGACY32 0x0040
KEVENT_FLAG_LEGACY64 0x0080
KEVENT_FLAG_PROC64 0x0100
KEVENT_FLAG_KERNEL 0x1000
KEVENT_FLAG_DYNAMIC_KQUEUE 0x2000
KEVENT_FLAG_NEEDS_END_PROCESSING 0x4000
EV_SET_QOS 0
NOTE_WL_THREAD_REQUEST 0x00000001
NOTE_WL_SYNC_WAIT 0x00000004
NOTE_WL_SYNC_WAKE 0x00000008
NOTE_WL_SYNC_IPC 0x80000000
NOTE_WL_COMMANDS_MASK 0x8000000f
NOTE_WL_UPDATE_QOS 0x00000010
NOTE_WL_END_OWNERSHIP 0x00000020
NOTE_WL_DISCOVER_OWNER 0x00000080
NOTE_WL_IGNORE_ESTALE 0x00000100
NOTE_WL_UPDATES_MASK 0x000001f0
NOTE_WL_UPDATE_OWNER 0
EV_EXTIDX_WL_LANE 0
EV_EXTIDX_WL_ADDR 1
EV_EXTIDX_WL_MASK 2
EV_EXTIDX_WL_VALUE 3
NOTE_EXIT_MEMORY_DETAIL_MASK 0xfe000000
NOTE_EXIT_MEMORY_VMPAGESHORTAGE 0x80000000
NOTE_EXIT_MEMORY_VMTHRASHING 0x40000000
NOTE_EXIT_MEMORY_HIWAT 0x20000000
NOTE_EXIT_MEMORY_PID 0x10000000
NOTE_EXIT_MEMORY_IDLE 0x08000000
NOTE_EXIT_MEMORY_VNODE 0X04000000
NOTE_EXIT_MEMORY_FCTHRASHING 0x02000000
NOTE_MEMORYSTATUS_PRESSURE_NORMAL 0x00000001
NOTE_MEMORYSTATUS_PRESSURE_WARN 0x00000002
NOTE_MEMORYSTATUS_PRESSURE_CRITICAL 0x00000004
NOTE_MEMORYSTATUS_LOW_SWAP 0x00000008
NOTE_MEMORYSTATUS_PROC_LIMIT_WARN 0x00000010
NOTE_MEMORYSTATUS_PROC_LIMIT_CRITICAL 0x00000020
NOTE_MEMORYSTATUS_MSL_STATUS 0xf0000000
NOTE_MEMORYSTATUS_PROC_LIMIT_WARN_ACTIVE 0x00000040
NOTE_MEMORYSTATUS_PROC_LIMIT_WARN_INACTIVE 0x00000080
NOTE_MEMORYSTATUS_PROC_LIMIT_CRITICAL_ACTIVE 0x00000100
NOTE_MEMORYSTATUS_PROC_LIMIT_CRITICAL_INACTIVE 0x00000200
NOTE_MEMORYSTATUS_JETSAM_FG_BAND 0x00000400
kVMPressureJetsam kVMPressureForegroundJetsam
NOTE_CONNRESET 0x00000001
NOTE_READCLOSED 0x00000002
NOTE_WRITECLOSED 0x00000004
NOTE_TIMEOUT 0x00000008
NOTE_NOSRCADDR 0x00000010
NOTE_IFDENIED 0x00000020
NOTE_SUSPEND 0x00000040
NOTE_RESUME 0x00000080
NOTE_KEEPALIVE 0x00000100
NOTE_ADAPTIVE_WTIMO 0x00000200
NOTE_ADAPTIVE_RTIMO 0x00000400
NOTE_CONNECTED 0x00000800
NOTE_DISCONNECTED 0x00001000
NOTE_CONNINFO_UPDATED 0x00002000
NOTE_NOTIFY_ACK 0x00004000
NOTE_WAKE_PKT 0x00008000
NOTE_FLOW_ADV_UPDATE 0x00000001
NOTE_CHANNEL_EVENT 0x00000002
NOTE_IF_ADV_UPD 0x00000004
KNOTE_KQ_PACKED_BITS 42
KNOTE_KQ_PACKED_SHIFT 0
KNOTE_KQ_PACKED_BASE 0
kn_id kn_kevent.kei_ident
kn_filtid kn_kevent.kei_filtid
kn_filter kn_kevent.kei_filter
kn_flags kn_kevent.kei_flags
kn_qos kn_kevent.kei_qos
kn_udata kn_kevent.kei_udata
kn_fflags kn_kevent.kei_fflags
kn_sfflags kn_kevent.kei_sfflags
kn_sdata kn_kevent.kei_sdata
kn_ext kn_kevent.kei_ext
FILTER_ACTIVE 0x00000001
FILTER_REGISTER_WAIT 0x00000002
FILTER_UPDATE_REQ_QOS 0x00000004
FILTER_ADJUST_EVENT_QOS_BIT 0x00000008
FILTER_ADJUST_EVENT_QOS_MASK 0x00000070
FILTER_ADJUST_EVENT_QOS_SHIFT 4
FILTER_RESET_EVENT_QOS FILTER_ADJUST_EVENT_QOS_BIT
FILTER_THREADREQ_NODEFEER 0x00000080
FILTER_ADJUST_EVENT_IOTIER_BIT 0x00000100
filter_call(_ops, call)  	        ((_ops)->f_extended_codes ? (_ops)->call : !!((_ops)->call))
KNOTE(list, hint)       knote(list, hint, false)
KNOTE_ATTACH(list, kn)  knote_attach(list, kn)
KNOTE_DETACH(list, kn)  knote_detach(list, kn)
R2K_WORKLOOP_PENDING_EVENTS 0x1
R2K_WORKQ_PENDING_EVENTS 0x2
PTHREAD_WQ_QUANTUM_EXPIRY_NARROW 0x1
PTHREAD_WQ_QUANTUM_EXPIRY_SHUFFLE 0x2
_SYS_EXEC_H_ None
_SYS_FASTTRAP_H None
FASTTRAP_PID_NAME "pid"
FASTTRAP_OBJC_NAME "objc"
FASTTRAP_ONESHOT_NAME "oneshot"
PT_SUNWDTRACE_SIZE FASTTRAP_SUNWDTRACE_SIZE
_FASTTRAP_IMPL_H None
proc_t struct proc
fasttrap_copyout copyout
fasttrap_fuword32 fuword32
fasttrap_suword32 suword32
fasttrap_fuword64 fuword64
fasttrap_suword64 suword64
fasttrap_fuword64_noerr fuword64_noerr
fasttrap_fuword32_noerr fuword32_noerr
FASTTRAP_TPOINTS_INDEX(pid, pc) 	(((pc) / sizeof (fasttrap_instr_t) + (pid)) & fasttrap_tpoints.fth_mask)
_SYS_FASTTRAP_ISA_H_ None
_FBT_H None
MAX_FBTP_NAME_CHARS 16
_SYS_FCNTL_H_ None
O_RDONLY 0x0000
O_WRONLY 0x0001
O_RDWR 0x0002
O_ACCMODE 0x0003
O_NONBLOCK 0x00000004
O_APPEND 0x00000008
O_CREAT 0x00000200
O_TRUNC 0x00000400
O_EXCL 0x00000800
O_RESOLVE_BENEATH 0x00001000
FMARK 0x00001000
FDEFER 0x00002000
FWASLOCKED 0x00004000
FHASLOCK FWASLOCKED
FWASWRITTEN 0x00010000
O_NOCTTY 0x00020000
FNOCACHE 0x00040000
FNORDAHEAD 0x00080000
FNODIRECT 0x00800000
FENCRYPTED 0x02000000
FSINGLE_WRITER 0x04000000
O_CLOFORK 0x08000000
FUNENCRYPTED 0x10000000
O_NOFOLLOW_ANY 0x20000000
FEXEC O_EXEC
FSEARCH FEXEC
F_DUPFD 0
F_GETFD 1
F_SETFD 2
F_GETFL 3
F_SETFL 4
F_GETOWN 5
F_SETOWN 6
F_GETLK 7
F_SETLK 8
F_SETLKW 9
F_SETLKWTIMEOUT 10
FD_CLOEXEC 1
FD_CLOFORK 2
F_RDLCK 1
F_UNLCK 2
F_WRLCK 3
F_WAIT 0x010
F_FLOCK 0x020
F_POSIX 0x040
F_PROV 0x080
F_WAKE1_SAFE 0x100
F_ABORT 0x200
F_OFD_LOCK 0x400
F_TRANSFER 0x800
F_CONFINED 0x1000
F_IOTYPE_ISOCHRONOUS 0x0001
_SYS_FILE_H_ None
_KAUTH_CRED_T None
GEN_FILEPERM_EXCEPTION 1
_SYS_FILEDESC_H_ None
NDFILE 25
NDEXTENT 50
fdt_flag_test(fdt, flag)        (((fdt)->fd_flags & (flag)) != 0)
fdt_flag_set(fdt, flag)         ((void)((fdt)->fd_flags |= (flag)))
fdt_flag_clear(fdt, flag)       ((void)((fdt)->fd_flags &= ~(flag)))
UF_RESERVED 0x04
UF_CLOSING 0x08
UF_RESVWAIT 0x10
UF_INHERIT 0x20
fdt_foreach(fp, p) 	for (struct fdt_iterator __fdt_it = fdt_next(p, -1, true); 	    ((fp) = __fdt_it.fdti_fp); 	    __fdt_it = fdt_next(p, __fdt_it.fdti_fd, true))
fdt_foreach_fd() __fdt_it.fdti_fd
fdfile(p, fd)                                   	                (&(p)->p_fd.fd_ofiles[(fd)])
fdflags(p, fd)                                  	                (&(p)->p_fd.fd_ofileflags[(fd)])
falloc(p, rfp, rfd)  ({ 	struct proc *__p = (p);                                                 	falloc_withinit(__p, current_cached_proc_cred(__p),                     	    vfs_context_current(), rfp, rfd, NULL, NULL);                       })
falloc_exec(p, ctx, rfp, rfd)  ({ 	struct vfs_context *__c = (ctx);                                        	falloc_withinit(p, vfs_context_ucred(__c), __c, rfp, rfd, NULL, NULL);  })
_SYS_FILEPORT_H_ None
_SYS_FILE_INTERNAL_H_ None
_KAUTH_CRED_T None
FG_INSMSGQ 0x02
FG_WINSMSGQ 0x04
FG_RMMSGQ 0x08
FG_WRMMSGQ 0x10
FG_PORTMADE 0x20
FG_NOSIGPIPE 0x40
FG_OFF_LOCKED 0x80
FG_OFF_LOCKWANT 0x100
FG_CONFINED 0x200
FG_HAS_OFDLOCK 0x400
FOF_OFFSET 0x00000001
_SYS_FILIO_H_ None
FIOCLEX _IO('f', 1)
FIONCLEX _IO('f', 2)
FIONREAD _IOR('f', 127, int)
FIONBIO _IOW('f', 126, int)
FIOASYNC _IOW('f', 125, int)
FIOSETOWN _IOW('f', 124, int)
FIOGETOWN _IOR('f', 123, int)
FIODTYPE _IOR('f', 122, int)
FIODEVICELOCKED _IO('f', 121)
FIOPINSWAP _IO('f', 120)
FIODEVICEEPSTATE _IOR('f', 119, int)
FIODEVICECXSTATE _IO('f', 118)
_SYS_FSCTL_H_ None
NAMESPACE_HANDLER_READ_OP 0x0001
NAMESPACE_HANDLER_WRITE_OP 0x0002
NAMESPACE_HANDLER_DELETE_OP 0x0004
NAMESPACE_HANDLER_TRUNCATE_OP 0x0008
NAMESPACE_HANDLER_RENAME_OP 0x0010
NAMESPACE_HANDLER_METADATA_WRITE_OP 0x0020
NAMESPACE_HANDLER_METADATA_DELETE_OP 0x0040
NAMESPACE_HANDLER_METADATA_MOD 0x0080
NAMESPACE_HANDLER_LINK_CREATE 0x0200
NAMESPACE_HANDLER_RENAME_SUCCESS_OP 0x0400
NAMESPACE_HANDLER_RENAME_FAILED_OP 0x0800
NAMESPACE_HANDLER_NSPACE_EVENT 0x1000
NAMESPACE_HANDLER_SNAPSHOT_EVENT 0x0100
NAMESPACE_HANDLER_TRACK_EVENT 0x2000
NAMESPACE_HANDLER_LOOKUP_OP 0x4000
FSIOC_GRAFT_VERSION 2
FSCTL_GRAFT_PRESERVE_MOUNT 0x0001
FSCTL_GRAFT_ALTERNATE_SHARED_REGION 0x0002
FSCTL_GRAFT_SYSTEM_CONTENT 0x0004
FSCTL_GRAFT_PANIC_ON_AUTHFAIL 0x0008
FSCTL_GRAFT_STRICT_AUTH 0x0010
FSCTL_GRAFT_PRESERVE_GRAFT 0x0020
FSCTL_UNGRAFT_UNGRAFTALL 0x0001
AUTH_FS_ALLOW_UNAUTH_ROOT_HASH 0x0001
FSIOC_SYNC_VOLUME _IOW('A', 1, uint32_t)
FSCTL_SYNC_VOLUME IOCBASECMD(FSIOC_SYNC_VOLUME)
FSIOC_SET_PACKAGE_EXTS _IOW('A', 2, struct package_ext_info)
FSCTL_SET_PACKAGE_EXTS IOCBASECMD(FSIOC_SET_PACKAGE_EXTS)
FSIOC_UNSUPPORTED _IOR('A', 3, int32_t)
FSIOC_SET_FSTYPENAME_OVERRIDE _IOW('A', 10, fstypename_t)
FSCTL_SET_FSTYPENAME_OVERRIDE IOCBASECMD(FSIOC_SET_FSTYPENAME_OVERRIDE)
FSIOC_ROUTEFS_SETROUTEID _IO('A', 15)
FSCTL_ROUTEFS_SETROUTEID IOCBASECMD(FSIOC_ROUTEFS_SETROUTEID)
FSIOC_FIOSEEKHOLE _IOWR('A', 16, off_t)
FSCTL_FIOSEEKHOLE IOCBASECMD(FSIOC_FIOSEEKHOLE)
FSIOC_FIOSEEKDATA _IOWR('A', 17, off_t)
FSCTL_FIOSEEKDATA IOCBASECMD(FSIOC_FIOSEEKDATA)
DISK_CONDITIONER_IOC_GET _IOR('A', 18, disk_conditioner_info)
DISK_CONDITIONER_FSCTL_GET IOCBASECMD(DISK_CONDITIONER_IOC_GET)
DISK_CONDITIONER_IOC_SET _IOW('A', 19, disk_conditioner_info)
DISK_CONDITIONER_FSCTL_SET IOCBASECMD(DISK_CONDITIONER_IOC_SET)
FSIOC_CAS_BSDFLAGS _IOWR('A', 20, struct fsioc_cas_bsdflags)
FSIOC_FD_ONLY_OPEN_ONCE _IOWR('A', 21, uint32_t)
FSIOC_GRAFT_FS _IOW('A', 22, fsioc_graft_fs_t)
FSIOC_UNGRAFT_FS _IOW('A', 23, fsioc_ungraft_fs_t)
FSIOC_AUTH_FS _IOW('A', 24, fsioc_auth_fs_t)
FSIOC_EXCLAVE_FS_REGISTER _IOW('A', 25, fsioc_exclave_fs_register_t)
FSIOC_EXCLAVE_FS_UNREGISTER _IOW('A', 26, uint32_t)
FSIOC_EXCLAVE_FS_GET_BASE_DIRS _IOWR('A', 27, exclave_fs_get_base_dirs_t)
FSIOC_GET_GRAFT_INFO _IOWR('J', 102, fsioc_get_graft_info_t)
SPOTLIGHT_IOC_GET_MOUNT_TIME _IOR('h', 18, u_int32_t)
SPOTLIGHT_FSCTL_GET_MOUNT_TIME IOCBASECMD(SPOTLIGHT_IOC_GET_MOUNT_TIME)
SPOTLIGHT_IOC_GET_LAST_MTIME _IOR('h', 19, u_int32_t)
SPOTLIGHT_FSCTL_GET_LAST_MTIME IOCBASECMD(SPOTLIGHT_IOC_GET_LAST_MTIME)
FSIOC_FREEZE_EXTENTS _IO('h', 20)
FSCTL_FREEZE_EXTENTS IOCBASECMD(FSIOC_FREEZE_EXTENTS)
FSIOC_THAW_EXTENTS _IO('h', 21)
FSCTL_THAW_EXTENTS IOCBASECMD(FSIOC_THAW_EXTENTS)
FSIOC_EVAL_ROOTAUTH _IO('h', 50)
FSCTL_EVAL_ROOTAUTH IOCBASECMD(FSIOC_EVAL_ROOTAUTH)
FSIOC_KERNEL_ROOTAUTH _IOW('h', 51, uint32_t)
FIRMLINK_STRUCT_LEN 1032
FSIOC_FIRMLINK_CTL _IOWR ('J', 60, generic_firmlink_t)
FSIOC_TEST_FSE_ACCESS_GRANTED _IO('h', 52)
FSEVENT_H 1
FSE_INVALID -1
FSE_CREATE_FILE 0
FSE_DELETE 1
FSE_STAT_CHANGED 2
FSE_RENAME 3
FSE_CONTENT_MODIFIED 4
FSE_EXCHANGE 5
FSE_FINDER_INFO_CHANGED 6
FSE_CREATE_DIR 7
FSE_CHOWN 8
FSE_XATTR_MODIFIED 9
FSE_XATTR_REMOVED 10
FSE_DOCID_CREATED 11
FSE_DOCID_CHANGED 12
FSE_UNMOUNT_PENDING 13
FSE_CLONE 14
FSE_ACTIVITY 15
FSE_ACTIVITY_VERSION_1 1
FSE_ACTIVITY_ATTR_DEV 0x00000001
FSE_ACTIVITY_ATTR_INO 0x00000002
FSE_ACTIVITY_ATTR_ORIGIN_ID 0x00000004
FSE_ACTIVITY_ATTR_AGE 0x00000008
FSE_ACTIVITY_ATTR_USE_STATE 0x00000010
FSE_ACTIVITY_ATTR_URGENCY 0x00000020
FSE_ACTIVITY_ATTR_SIZE 0x00000040
FSE_MAX_EVENTS 16
FSE_ACCESS_GRANTED FSE_INVALID
FSE_CONTENT_MODIFIED_NO_HLINK 997
FSE_ALL_EVENTS 998
FSE_EVENTS_DROPPED 999
FSE_TYPE_MASK 0x0fff
FSE_FLAG_MASK 0xf000
FSE_FLAG_SHIFT 12
FSE_COMBINED_EVENTS 0x0001
FSE_CONTAINS_DROPPED_EVENTS 0x0002
FSE_IGNORE 0
FSE_REPORT 1
FSE_ASK 2
FSE_ARG_VNODE 0x0001
FSE_ARG_STRING 0x0002
FSE_ARG_PATH 0x0003
FSE_ARG_INT32 0x0004
FSE_ARG_INT64 0x0005
FSE_ARG_RAW 0x0006
FSE_ARG_INO 0x0007
FSE_ARG_UID 0x0008
FSE_ARG_DEV 0x0009
FSE_ARG_MODE 0x000a
FSE_ARG_GID 0x000b
FSE_ARG_FINFO 0x000c
FSE_ARG_AUDIT_TOKEN 0x000d
FSE_ARG_DONE 0xb33f
FSE_MAX_ARGS 13
FSEVENTS_CLONE _IOW('s', 1, fsevent_clone_args)
FSEVENTS_DEVICE_FILTER _IOW('s', 100, fsevent_dev_filter_args)
FSEVENTS_WANT_COMPACT_EVENTS _IO('s', 101)
FSEVENTS_WANT_EXTENDED_INFO _IO('s', 102)
FSEVENTS_GET_CURRENT_ID _IOR('s', 103, uint64_t)
FSEVENTS_UNMOUNT_PENDING_ACK _IOW('s', 104, dev_t)
_FSGETPATH_H_ None
_FSGETPATH_PRIVATE_H_ None
_FSLOG_H_ None
FSLOG_KEY_LEVEL "Level"
FSLOG_VAL_FACILITY "com.apple.system.fs"
_SYS_GMON_H_ None
GMONVERSION 0x00051879
HISTCOUNTER unsigned short
HISTFRACTION 2
HASHFRACTION 2
ARCDENSITY 2
MINARCS 50
ROUNDDOWN(x, y)  (((x)/(y))*(y))
ROUNDUP(x, y)    ((((x)+(y)-1)/(y))*(y))
GMON_PROF_ON 0
GMON_PROF_BUSY 1
GMON_PROF_ERROR 2
GMON_PROF_OFF 3
GMON_MAGIC 0xbeefbabe
GMON_MAGIC_64 0xbeefbabf
GMONTYPE_SAMPLES 1
GMONTYPE_RAWARCS 2
GMONTYPE_ARCS_ORDERS 3
GMONTYPE_DYLD_STATE 4
GMONTYPE_DYLD2_STATE 5
_SYS_GUARDED_H_ None
_IMAGEBOOT_H_ None
IMAGEBOOT_CONTAINER_ARG "container-dmg"
IMAGEBOOT_ROOT_ARG "root-dmg"
IMAGEBOOT_AUTHROOT_ARG "auth-root-dmg"
_SYS_IMGACT_H_ None
IMG_SHSIZE 512
IMGPF_NONE 0x00000000
IMGPF_INTERPRET 0x00000001
IMGPF_RESERVED 0x00000002
IMGPF_WAS_64BIT_ADDR 0x00000004
IMGPF_IS_64BIT_ADDR 0x00000008
IMGPF_SPAWN 0x00000010
IMGPF_DISABLE_ASLR 0x00000020
IMGPF_ALLOW_DATA_EXEC 0x00000040
IMGPF_3P_PLUGINS 0x00000080
IMGPF_EXEC 0x00000100
IMGPF_HIGH_BITS_ASLR 0x00000200
IMGPF_IS_64BIT_DATA 0x00000400
IMGPF_DRIVER 0x00000800
IMGPF_RESLIDE 0x00001000
IMGPF_PLUGIN_HOST_DISABLE_A_KEYS 0x00002000
IMGPF_HW_TPRO 0x00004000
IMGPF_HARDENED_HEAP 0x00008000
IMGPF_RESERVED_3 0x01000000
IMGPF_ROSETTA 0x10000000
IMGPF_ALT_ROSETTA 0x20000000
IMGPF_RESERVED_2 0x40000000
IMGPF_NOJOP 0x80000000
IMGPF_SB_DEFAULT 0
IMGPF_SB_TRUE 1
IMGPF_SB_FALSE 2
_SYS_IMGSRC_H_ None
MNT_IMGSRC_BY_INDEX 0x20000000
_SYS_IOCCOM_H_ None
IOCPARM_MASK 0x1fff
_IOC(inout, group, num, len) 	(inout | ((len & IOCPARM_MASK) << 16) | ((group) << 8) | (num))
_IO(g, n)        _IOC(IOC_VOID,	(g), (n), 0)
_IOR(g, n, t)     _IOC(IOC_OUT,	(g), (n), sizeof(t))
_IOW(g, n, t)     _IOC(IOC_IN,	(g), (n), sizeof(t))
_IOWR(g, n, t)    _IOC(IOC_INOUT,	(g), (n), sizeof(t))
_SYS_IOCTL_H_ None
TIOCGSIZE TIOCGWINSZ
TIOCSSIZE TIOCSWINSZ
_SYS_IOCTL_COMPAT_H_ None
_SGTTYB_ None
TIOCHPCL _IO('t', 2)
TIOCGETP _IOR('t', 8,struct sgttyb)
TIOCSETP _IOW('t', 9,struct sgttyb)
TIOCSETN _IOW('t',10,struct sgttyb)
TIOCSETC _IOW('t',17,struct tchars)
TIOCGETC _IOR('t',18,struct tchars)
TANDEM 0x00000001
CBREAK 0x00000002
LCASE 0x00000004
ECHO 0x00000008
CRMOD 0x00000010
RAW 0x00000020
ODDP 0x00000040
EVENP 0x00000080
ANYP 0x000000c0
NLDELAY 0x00000300
TBDELAY 0x00000c00
XTABS 0x00000c00
CRDELAY 0x00003000
VTDELAY 0x00004000
BSDELAY 0x00008000
NL0 0x00000000
NL1 0x00000100
NL2 0x00000200
NL3 0x00000300
TAB0 0x00000000
TAB1 0x00000400
TAB2 0x00000800
CR0 0x00000000
CR1 0x00001000
CR2 0x00002000
CR3 0x00003000
FF0 0x00000000
FF1 0x00004000
BS0 0x00000000
BS1 0x00008000
CRTBS 0x00010000
PRTERA 0x00020000
CRTERA 0x00040000
TILDE 0x00080000
MDMBUF 0x00100000
LITOUT 0x00200000
TOSTOP 0x00400000
FLUSHO 0x00800000
NOHANG 0x01000000
L001000 0x02000000
CRTKIL 0x04000000
PASS8 0x08000000
CTLECH 0x10000000
PENDIN 0x20000000
DECCTQ 0x40000000
NOFLSH 0x80000000
TIOCLBIS _IOW('t', 127, int)
TIOCLBIC _IOW('t', 126, int)
TIOCLSET _IOW('t', 125, int)
TIOCLGET _IOR('t', 124, int)
TIOCSLTC _IOW('t',117,struct ltchars)
TIOCGLTC _IOR('t',116,struct ltchars)
OTIOCCONS _IO('t', 98)
OTTYDISC 0
NETLDISC 1
NTTYDISC 2
TIOCGSID _IOR('t', 99, int)
_SYS_IPC_H_ None
__ipc_perm_new ipc_perm
IPC_CREAT 001000
IPC_EXCL 002000
IPC_NOWAIT 004000
IPC_RMID 0
IPC_SET 1
IPC_STAT 2
IXSEQ_TO_IPCID(ix, perm) (((perm._seq) << 16L) | ((ix) & 0xffff))
_SYS_IPCS_H_ None
IPCS_MAGIC 0x00000001
IPCS_SHM_CONF 0x00000001
IPCS_SHM_ITER 0x00000002
IPCS_SEM_CONF 0x00000010
IPCS_SEM_ITER 0x00000020
IPCS_MSG_CONF 0x00000100
IPCS_MSG_ITER 0x00000200
IPCS_SHM_SYSCTL "kern.sysv.ipcs.shm"
IPCS_SEM_SYSCTL "kern.sysv.ipcs.sem"
IPCS_MSG_SYSCTL "kern.sysv.ipcs.msg"
_SYS_KAS_INFO_H_ None
_SYS_KAUTH_H None
BSD_SYS_KDEBUG_H None
BSD_SYS_KDEBUG_COMMON_H None
TRIAGE_EVENTS_PER_STORAGE_UNIT 128
TRIAGE_MIN_STORAGE_UNITS_PER_CPU 1
TRACE_EVENTS_PER_STORAGE_UNIT 2048
TRACE_MIN_STORAGE_UNITS_PER_CPU 4
KDS_PTR_NULL 0xffffffff
POINTER_FROM_KDS_PTR(kd_bufs, x) (&kd_bufs[x.buffer_index].kdr_addr[x.offset])
BSD_SYS_KDEBUG_KERNEL_H None
KDBG(x, ...) KDBG_(, x, ## __VA_ARGS__, 4, 3, 2, 1, 0)
KDBG_FILTERED(x, ...) KDBG_(_FILTERED, x, ## __VA_ARGS__, 4, 3, 2, 1, 0)
KDBG_RELEASE_NOPROCFILT(x, ...) 	        KDBG_(_RELEASE_NOPROCFILT, x, ## __VA_ARGS__, 4, 3, 2, 1, 0)
KDBG_RELEASE(x, ...) KDBG_(_RELEASE, x, ## __VA_ARGS__, 4, 3, 2, 1, 0)
KDBG_DEBUG(x, ...) KDBG_(_DEBUG, x, ## __VA_ARGS__, 4, 3, 2, 1, 0)
KDBG_(f, x, a, b, c, d, n, ...) KDBG##n(f, x, a, b, c, d)
KDBG0(f, x, a, b, c, d) KERNEL_DEBUG_CONSTANT##f(x, 0, 0, 0, 0, 0)
KDBG1(f, x, a, b, c, d) KERNEL_DEBUG_CONSTANT##f(x, a, 0, 0, 0, 0)
KDBG2(f, x, a, b, c, d) KERNEL_DEBUG_CONSTANT##f(x, a, b, 0, 0, 0)
KDBG3(f, x, a, b, c, d) KERNEL_DEBUG_CONSTANT##f(x, a, b, c, 0, 0)
KDBG4(f, x, a, b, c, d) KERNEL_DEBUG_CONSTANT##f(x, a, b, c, d, 0)
KDBG_IMPROBABLE __improbable
KDEBUG_LEVEL_NONE 0
KDEBUG_LEVEL_IST 1
KDEBUG_LEVEL_STANDARD 2
KDEBUG_LEVEL_FULL 3
KERNEL_DEBUG_CONSTANT_RELEASE(x, a, b, c, d, e) 	KERNEL_DEBUG_CONSTANT_IST(~KDEBUG_ENABLE_PPT, x, a, b, c, d, 0)
KERNEL_DEBUG_CONSTANT_DEBUG(x, a, b, c, d, e) 	KERNEL_DEBUG(x, a, b, c, d, e)
KDBG_FLAG_FILTERED 0x01
KDBG_FLAG_NOPROCFILT 0x02
KDBG_VFS_LOOKUP_FLAG_LOOKUP 0x01
KDBG_VFS_LOOKUP_FLAG_NOPROCFILT 0x02
NUMPARMS 23
KERNEL_DBG_IST_SANE KDBG_RELEASE
ENTR_KDTRACEFUNC KDBG_RELEASE
KERNEL_ENERGYTRACE(opcode, lifespan, id, quality, value)        	    ENTR_KDTRACE(kEnTrCompKernel, opcode, lifespan, id,         	                 quality, value)
KERNEL_ENTR_ASSOCIATE(par_opcode, par_act_id, sub_opcode, sub_act_id) 	    ENTR_KDASSOCIATE(kEnTrCompKernel, par_opcode, par_act_id,   	                     kEnTrCompKernel, sub_opcode, sub_act_id)
BSD_KDEBUG_PRIVATE_H None
DBG_PPT 36
DBG_PERFCTRL 39
DBG_CLPC 50
DBG_MUSE 52
DBG_ANS 128
DBG_SIO 129
DBG_SEP 130
DBG_ISP 131
DBG_OSCAR 132
DBG_EMBEDDEDGFX 133
DBG_PMP 134
DBG_RTKIT 135
DBG_DCP 136
DBG_KMP 137
DBG_SKYWALK_ALWAYSON 0x10
DBG_SKYWALK_FLOWSWITCH 0x11
DBG_SKYWALK_NETIF 0x12
DBG_SKYWALK_CHANNEL 0x13
DBG_SKYWALK_PACKET 0x14
DBG_AQM_ALWAYSON 0x30
DBG_AQM_STATS 0x31
PPT_TEST 0x01
PPT_JETSAM_HIWAT 0x02
PPT_JETSAM_TOPPROC 0x03
DBG_SEC_SSMA 0x02
SKYWALKDBG_CODE(SubClass, code) KDBG_CODE(DBG_DLIL, SubClass, code)
PPTDBG_CODE(SubClass, code) KDBG_CODE(DBG_PPT, SubClass, code)
PERFCTRL_CODE(SubClass, code) KDBG_CODE(DBG_PERFCTRL, SubClass, code)
AQMDBG_CODE(SubClass, code) KDBG_CODE(DBG_DLIL, SubClass, code)
BSD_SYS_KDEBUG_SIGNPOST_H None
BSD_SYS_KDEBUG_TRIAGE_H None
KDBG_TRIAGE_EVENTID(Class, Reserved, Code)                	(((unsigned)((Class)    &   0xff) << KDBG_TRIAGE_CLASS_OFFSET)    | 	 ((unsigned)((Reserved) &   0xff) << KDBG_TRIAGE_RESERVED_OFFSET) | 	 ((unsigned)((Code)     & 0x3fff) << KDBG_TRIAGE_CODE_OFFSET))
KDBG_TRIAGE_SUBSYS_MAX KDBG_TRIAGE_SUBSYS_VM_SANITIZE
_SYS_KERNEL_H_ None
_KERN_SYS_KERNELTYPES_H_ None
_KAUTH_ACE None
_KAUTH_ACL None
_KAUTH_FILESEC None
_KAUTH_ACTION_T None
KPI_KERN_CONTROL_H None
KEV_CTL_SUBCLASS 2
KEV_CTL_REGISTERED 1
KEV_CTL_DEREGISTERED 2
CTLIOCGCOUNT _IOR('N', 2, int)
CTLIOCGINFO _IOWR('N', 3, struct ctl_info)
MAX_KCTL_NAME 96
CTL_FLAG_PRIVILEGED 0x1
CTL_FLAG_REG_ID_UNIT 0x2
CTL_FLAG_REG_SOCK_STREAM 0x4
CTL_FLAG_REG_EXTENDED 0x8
CTL_FLAG_REG_CRIT 0x10
CTL_FLAG_REG_SETUP 0x20
CTL_DATA_NOWAKEUP 0x1
CTL_DATA_EOR 0x2
CTL_DATA_CRIT 0x4
_SYS_KERN_DEBUG_H_ None
SYSCALL_REJECTION_NON_MASK_BITS 1
SYSCALL_REJECTION_SELECTOR_BITS 7
SYSCALL_REJECTION_NULL 0
SYSCALL_REJECTION_ALL 1
SYSCALL_REJECTION_FLAGS_DEFAULT 0
SYSCALL_REJECTION_FLAGS_FORCE_FATAL 1
SYSCALL_REJECTION_FLAGS_ONCE 2
SYS_KERN_EVENT_H None
KEV_ANY_VENDOR 0
KEV_ANY_CLASS 0
KEV_ANY_SUBCLASS 0
KEV_VENDOR_APPLE 1
KEV_NETWORK_CLASS 1
KEV_IOKIT_CLASS 2
KEV_SYSTEM_CLASS 3
KEV_APPLESHARE_CLASS 4
KEV_FIREWALL_CLASS 5
KEV_IEEE80211_CLASS 6
KEV_NKE_CLASS 7
KEV_NKE_ALF_SUBCLASS 1
KEV_NKE_ALF_STATE_CHANGED 1
XNU_KERN_EVENT_DATA_SIZE None
KEV_VENDOR_CODE_MAX_STR_LEN 200
SIOCGKEVID _IOR('e', 1, u_int32_t)
SIOCSKEVFILT _IOW('e', 2, struct kev_request)
SIOCGKEVFILT _IOR('e', 3, struct kev_request)
SIOCGKEVVENDOR _IOWR('e', 4, struct kev_vendor_code)
N_KEV_VECTORS 5
SYS_MEMORYSTATUS_H None
MEMORYSTATUS_ENTITLEMENT "com.apple.private.memorystatus"
JETSAM_PRIORITY_REVISION 2
JETSAM_PRIORITY_IDLE_HEAD -2
JETSAM_PRIORITY_IDLE 0
JETSAM_PRIORITY_ENTITLED_MAX 9
JETSAM_PRIORITY_IDLE_DEFERRED 10
JETSAM_PRIORITY_AGING_BAND1 JETSAM_PRIORITY_IDLE_DEFERRED
JETSAM_PRIORITY_AGING_BAND1_STUCK 15
JETSAM_PRIORITY_BACKGROUND_OPPORTUNISTIC 20
JETSAM_PRIORITY_AGING_BAND2 JETSAM_PRIORITY_BACKGROUND_OPPORTUNISTIC
JETSAM_PRIORITY_BACKGROUND 30
JETSAM_PRIORITY_MAIL 40
JETSAM_PRIORITY_ELEVATED_INACTIVE JETSAM_PRIORITY_MAIL
JETSAM_PRIORITY_PHONE 50
JETSAM_PRIORITY_FREEZER 75
JETSAM_PRIORITY_UI_SUPPORT 80
JETSAM_PRIORITY_FOREGROUND_SUPPORT 90
JETSAM_PRIORITY_FOREGROUND 100
JETSAM_PRIORITY_AUDIO_AND_ACCESSORY 120
JETSAM_PRIORITY_CONDUCTOR 130
JETSAM_PRIORITY_DRIVER_APPLE 150
JETSAM_PRIORITY_HOME 160
JETSAM_PRIORITY_EXECUTIVE 170
JETSAM_PRIORITY_IMPORTANT 180
JETSAM_PRIORITY_CRITICAL 190
JETSAM_PRIORITY_MAX 210
JETSAM_PRIORITY_INTERNAL 999
JETSAM_PRIORITY_DEFAULT 180
JETSAM_PRIORITY_TELEPHONY 190
DEFAULT_JETSAM_PRIORITY 180
KEV_MEMORYSTATUS_SUBCLASS 3
MEMORYSTATUS_MPE_VERSION_1 1
MEMORYSTATUS_MPE_VERSION_1_SIZE sizeof(struct memorystatus_properties_entry_v1)
kMaxSnapshotEntries 192
memorystatus_jetsam_snapshot_list memorystatus_jetsam_snapshot->entries
JETSAM_SNAPSHOT_TIMEOUT_SECS 30
kMemorystatusSuspended 0x001
kMemorystatusFrozen 0x002
kMemorystatusWasThawed 0x004
kMemorystatusTracked 0x008
kMemorystatusSupportsIdleExit 0x010
kMemorystatusDirty 0x020
kMemorystatusAssertion 0x040
kMemorystatusActive 0x080
kMemorystatusRelaunchLow 0x100
kMemorystatusRelaunchMed 0x200
kMemorystatusRelaunchHigh 0x400
JETSAM_REASON_INVALID 0
JETSAM_REASON_GENERIC 1
JETSAM_REASON_MEMORY_HIGHWATER 2
JETSAM_REASON_VNODE 3
JETSAM_REASON_MEMORY_VMPAGESHORTAGE 4
JETSAM_REASON_MEMORY_PROCTHRASHING 5
JETSAM_REASON_MEMORY_FCTHRASHING 6
JETSAM_REASON_MEMORY_PERPROCESSLIMIT 7
JETSAM_REASON_MEMORY_DISK_SPACE_SHORTAGE 8
JETSAM_REASON_MEMORY_IDLE_EXIT 9
JETSAM_REASON_ZONE_MAP_EXHAUSTION 10
JETSAM_REASON_MEMORY_VMCOMPRESSOR_THRASHING 11
JETSAM_REASON_MEMORY_VMCOMPRESSOR_SPACE_SHORTAGE 12
JETSAM_REASON_LOWSWAP 13
JETSAM_REASON_MEMORY_SUSTAINED_PRESSURE 14
JETSAM_REASON_MEMORY_VMPAGEOUT_STARVATION 15
JETSAM_REASON_MEMORY_LONGIDLE_EXIT 17
JETSAM_REASON_MEMORYSTATUS_MAX JETSAM_REASON_MEMORY_LONGIDLE_EXIT
JETSAM_REASON_CPULIMIT 100
kMemorystatusKilledDiagnostic kMemorystatusKilledDiskSpaceShortage
kMemorystatusKilledVMThrashing kMemorystatusKilledVMCompressorThrashing
JETSAM_REASON_MEMORY_VMTHRASHING JETSAM_REASON_MEMORY_VMCOMPRESSOR_THRASHING
MEMORYSTATUS_BUFFERSIZE_MAX 65536
MEMORYSTATUS_CMD_GET_PRIORITY_LIST 1
MEMORYSTATUS_CMD_SET_PRIORITY_PROPERTIES 2
MEMORYSTATUS_CMD_GET_JETSAM_SNAPSHOT 3
MEMORYSTATUS_CMD_GET_PRESSURE_STATUS 4
MEMORYSTATUS_CMD_SET_JETSAM_HIGH_WATER_MARK 5
MEMORYSTATUS_CMD_SET_JETSAM_TASK_LIMIT 6
MEMORYSTATUS_CMD_SET_MEMLIMIT_PROPERTIES 7
MEMORYSTATUS_CMD_GET_MEMLIMIT_PROPERTIES 8
MEMORYSTATUS_CMD_PRIVILEGED_LISTENER_ENABLE 9
MEMORYSTATUS_CMD_PRIVILEGED_LISTENER_DISABLE 10
MEMORYSTATUS_CMD_AGGRESSIVE_JETSAM_LENIENT_MODE_ENABLE 11
MEMORYSTATUS_CMD_AGGRESSIVE_JETSAM_LENIENT_MODE_DISABLE 12
MEMORYSTATUS_CMD_GET_MEMLIMIT_EXCESS 13
MEMORYSTATUS_CMD_ELEVATED_INACTIVEJETSAMPRIORITY_ENABLE 14
MEMORYSTATUS_CMD_ELEVATED_INACTIVEJETSAMPRIORITY_DISABLE 15
MEMORYSTATUS_CMD_SET_PROCESS_IS_MANAGED 16
MEMORYSTATUS_CMD_GET_PROCESS_IS_MANAGED 17
MEMORYSTATUS_CMD_SET_PROCESS_IS_FREEZABLE 18
MEMORYSTATUS_CMD_GET_PROCESS_IS_FREEZABLE 19
MEMORYSTATUS_CMD_FREEZER_CONTROL 20
MEMORYSTATUS_CMD_GET_AGGRESSIVE_JETSAM_LENIENT_MODE 21
MEMORYSTATUS_CMD_INCREASE_JETSAM_TASK_LIMIT 22
MEMORYSTATUS_CMD_SET_TESTING_PID 23
MEMORYSTATUS_CMD_GET_PROCESS_IS_FROZEN 24
MEMORYSTATUS_CMD_MARK_PROCESS_COALITION_SWAPPABLE 25
MEMORYSTATUS_CMD_GET_PROCESS_COALITION_IS_SWAPPABLE 26
MEMORYSTATUS_CMD_CONVERT_MEMLIMIT_MB 28
MEMORYSTATUS_CMD_SET_DIAG_LIMIT 30
MEMORYSTATUS_CMD_GET_DIAG_LIMIT 31
MEMORYSTATUS_CMD_GET_JETSAM_ZPRINT_NAMES 32
MEMORYSTATUS_CMD_GET_JETSAM_ZPRINT_INFO 33
MEMORYSTATUS_CMD_GET_JETSAM_ZPRINT_MEMINFO 34
MEMORYSTATUS_CMD_GET_PRIORITY_LIST_V2 35
MEMORYSTATUS_CMD_GET_KILL_COUNTS 37
MEMORYSTATUS_CMD_GRP_SET_PROPERTIES 100
MEMORYSTATUS_CMD_TEST_JETSAM 1000
MEMORYSTATUS_CMD_TEST_JETSAM_SORT 1001
JETSAM_SORT_NOSORT 0
JETSAM_SORT_DEFAULT 1
MEMORYSTATUS_FLAGS_SNAPSHOT_ON_DEMAND 0x1
MEMORYSTATUS_FLAGS_SNAPSHOT_AT_BOOT 0x2
MEMORYSTATUS_FLAGS_SNAPSHOT_COPY 0x4
MEMORYSTATUS_FLAGS_GRP_SET_PRIORITY 0x8
MEMORYSTATUS_FLAGS_GRP_SET_PROBABILITY 0x10
MEMORYSTATUS_FLAGS_SET_TESTING_PID 0x20
MEMORYSTATUS_FLAGS_UNSET_TESTING_PID 0x40
MEMORYSTATUS_FLAGS_SET_IMP_TESTING_PID 0x80
MEMORYSTATUS_FLAGS_SNAPSHOT_FREEZER 0x80
MEMORYSTATUS_FLAGS_GRP_SET_FREEZE_PRIORITY 0x100
MEMORYSTATUS_FLAGS_GRP_SET_DEMOTE_PRIORITY 0x200
MEMORYSTATUS_SNAPSHOT_ON_DEMAND MEMORYSTATUS_FLAGS_SNAPSHOT_ON_DEMAND
MEMORYSTATUS_SNAPSHOT_AT_BOOT MEMORYSTATUS_FLAGS_SNAPSHOT_AT_BOOT
MEMORYSTATUS_SNAPSHOT_COPY MEMORYSTATUS_FLAGS_SNAPSHOT_COPY
MEMORYSTATUS_SET_PRIORITY_ASSERTION 0x1
MEMORYSTATUS_MEMLIMIT_ATTR_FATAL 0x1
P_MEMSTAT_SUSPENDED 0x00000001
P_MEMSTAT_FROZEN 0x00000002
P_MEMSTAT_FREEZE_DISABLED 0x00000004
P_MEMSTAT_ERROR 0x00000008
P_MEMSTAT_LOCKED 0x00000010
P_MEMSTAT_TERMINATED 0x00000020
P_MEMSTAT_FREEZE_IGNORE 0x00000040
P_MEMSTAT_PRIORITYUPDATED 0x00000080
P_MEMSTAT_FOREGROUND 0x00000100
P_MEMSTAT_REFREEZE_ELIGIBLE 0x00000400
P_MEMSTAT_MANAGED 0x00000800
P_MEMSTAT_INTERNAL 0x00001000
P_MEMSTAT_FATAL_MEMLIMIT 0x00002000
P_MEMSTAT_MEMLIMIT_ACTIVE_FATAL 0x00004000
P_MEMSTAT_MEMLIMIT_INACTIVE_FATAL 0x00008000
P_MEMSTAT_USE_ELEVATED_INACTIVE_BAND 0x00010000
P_MEMSTAT_PRIORITY_ASSERTION 0x00020000
P_MEMSTAT_FREEZE_CONSIDERED 0x00040000
P_MEMSTAT_SKIP 0x00080000
P_MEMSTAT_FROZEN_XPC_SERVICE 0x00100000
P_MEMSTAT_FROZEN_FOCAL_THAW 0x00200000
P_MEMSTAT_TEST_IMP_ASSERTION 0x00400000
P_MEMSTAT_RELAUNCH_UNKNOWN 0x0
P_MEMSTAT_RELAUNCH_LOW 0x1
P_MEMSTAT_RELAUNCH_MED 0x2
P_MEMSTAT_RELAUNCH_HIGH 0x4
SYS_MEMORYSTATUS_FREEZE_H None
FREEZE_PROCESSES_MAX_DEFAULT 20
FREEZE_PROCESSES_MAX_SWAP_ENABLED_DEFAULT 36
FREEZE_DAILY_MB_MAX_DEFAULT 2048
FREEZE_DEGRADATION_BUDGET_THRESHOLD 25
MAX_FROZEN_SHARED_MB_PERCENT 10
MAX_FROZEN_PROCESS_DEMOTIONS_DEFAULT 2
MAX_FROZEN_PROCESS_DEMOTIONS_SWAP_ENABLED_DEFAULT 4
MIN_THAW_DEMOTION_THRESHOLD_DEFAULT 5
SYS_MEMORYSTATUS_NOTIFY_H None
_SYS_KERN_OVERRIDES_H None
SYS_OVERRIDE_IO_THROTTLE 0x1
SYS_OVERRIDE_CPU_THROTTLE 0x2
SYS_OVERRIDE_FAST_JETSAM 0x4
_KERN_SYSCTL_H_ None
__KPI_MBUF__ None
MBUF_COPYALL 1000000000
MBUF_GSO_TYPE_NONE MBUF_GSO_TYPE_NONE
IF_ENQUEUE_MBUF(ifq, m) {                                       	mbuf_setnextpkt((m), 0);                                        	if ((ifq)->ifq_tail == 0)                                       	        (ifq)->ifq_head = (m);                                  	else                                                            	        mbuf_setnextpkt((mbuf_t)(ifq)->ifq_tail, (m));          	(ifq)->ifq_tail = (m);                                          	(ifq)->ifq_len++;                                               }
IF_PREPEND_MBUF(ifq, m) {                                       	mbuf_setnextpkt((m), (ifq)->ifq_head);                          	if ((ifq)->ifq_tail == 0)                                       	        (ifq)->ifq_tail = (m);                                  	(ifq)->ifq_head = (m);                                          	(ifq)->ifq_len++;                                               }
IF_DEQUEUE_MBUF(ifq, m) {                                       	(m) = (ifq)->ifq_head;                                          	if (m) {                                                        	        if (((ifq)->ifq_head = mbuf_nextpkt((m))) == 0)         	                (ifq)->ifq_tail = 0;                            	        mbuf_setnextpkt((m), 0);                                	        (ifq)->ifq_len--;                                       	}                                                               }
_SYS_KPI_PRIVATE_H None
__KPI_SOCKET__ None
sock_accept(so, from, fromlen, flags, callback, cookie, new_so) 	sock_accept_internal((so), (from), (fromlen), (flags), (callback), 	(cookie), (new_so))
HAS_SOCK_SENDMBUF_CAN_WAIT 1
sock_socket(domain, type, protocol, callback, cookie, new_so) 	sock_socket_internal((domain), (type), (protocol), 	(callback), (cookie), (new_so))
__KPI_SOCKETFILTER__ None
sf_len sf_ext.sf_ext_len
sf_accept sf_ext.sf_ext_accept
sflt_register(filter, domain, type, protocol)     sflt_register_internal((filter), (domain), (type), (protocol))
SYS_KTRACE_H None
_SYS_LCTX_H_ None
_SYS_LINKER_SET_H_ None
_SYS_LOADABLE_FS_ None
FS_DIR_LOCATION "/System/Library/Filesystems"
FS_DIR_SUFFIX ".fs"
FS_UTIL_SUFFIX ".util"
FSUC_PROBE 'p'
FSUC_PROBEFORINIT 'P'
FSUC_MOUNT 'm'
FSUC_REPAIR 'r'
FSUC_UNMOUNT 'u'
FSUC_MOUNT_FORCE 'M'
DEVICE_READONLY "readonly"
DEVICE_WRITABLE "writable"
DEVICE_REMOVABLE "removable"
DEVICE_FIXED "fixed"
_SYS_LOCK_H_ None
_KERN_LOCKDOWN_MODE_H_ None
_SYS_LOCKF_H_ None
_SYS_LOCKSTAT_H None
LS_LCK_MTX_LOCK_SPIN "lck_mtx_lock_spin"
LS_LCK_MTX_LOCK "lck_mtx_lock"
LS_LCK_MTX_TRY_LOCK_SPIN "lck_mtx_try_lock_spin"
LS_LCK_MTX_TRY_LOCK "lck_mtx_try_lock"
LS_LCK_MTX_UNLOCK "lck_mtx_unlock"
LS_LCK_SPIN_LOCK "lck_spin_lock"
LS_LCK_SPIN_TRY_LOCK "lck_spin_try_lock"
LS_LCK_SPIN_UNLOCK "lck_spin_unlock"
LS_LCK_RW_LOCK_SHARED "lck_rw_lock_shared"
LS_LCK_RW_LOCK_EXCL "lck_rw_lock_exclusive"
LS_LCK_RW_DONE "lck_rw_done"
LS_LCK_RW_TRY_LOCK_EXCL "lck_rw_try_lock_exclusive"
LS_LCK_RW_TRY_LOCK_SHARED "lck_rw_try_lock_shared"
LS_LCK_RW_LOCK_SHARED_TO_EXCL "lck_rw_lock_shared_to_exclusive"
LS_LCK_RW_LOCK_EXCL_TO_SHARED "lck_rw_lock_exclusive_to_shared"
LS_LCK_TICKET_LOCK "lck_ticket_lock"
LS_LCK_TICKET_UNLOCK "lck_ticket_unlock"
LS_ACQUIRE "acquire"
LS_RELEASE "release"
LS_SPIN "spin"
LS_BLOCK "block"
LS_UPGRADE "upgrade"
LS_DOWNGRADE "downgrade"
LS_TYPE_ADAPTIVE "adaptive"
LS_TYPE_SPIN "spin"
LS_TYPE_RW "rw"
LS_TYPE_TICKET "ticket"
_DATA_LOG_H_ None
_MACH_SWAPON_H None
_SYS_MALLOC_H_ None
M_WAITOK 0x0000
M_NOWAIT 0x0001
M_ZERO 0x0004
M_NULL 0x0008
M_PCB 4
M_RTABLE 5
M_IFADDR 9
M_SONAME 11
M_PGRP 17
M_FHANDLE 21
M_VNODE 25
M_CACHE 26
M_DQUOT 27
M_PROC_UUID_POLICY 28
M_SHM 29
M_LOCKF 40
M_PROC 41
M_NETADDR 49
M_NFSSVC 50
M_NFSD 52
M_IPMOPTS 53
M_TTYS 65
M_OFILETABL 73
M_TEMP 80
M_SECA 81
M_UDFNODE 84
M_UDFMNT 85
M_KQUEUE 94
M_KAUTH 100
M_SBUF 105
M_SELECT 107
M_IP6MOPTS 113
M_IP6CGA 117
M_NECP 118
M_FD_VN_DATA 122
M_FD_DIRBUF 123
M_EVENTHANDLER 125
M_LLTABLE 126
M_CFIL 128
M_TRACKER 129
_SYS_MBUF_H_ None
mtod(m, t)      ((t)(void *)m_mtod_current(m))
mtodo(m, o)     ((void *)(mtod(m, uint8_t *) + (o)))
M_TAG_INIT(tag, id, type, len, data, mb_cl) {   	VERIFY(IS_P2ALIGNED((tag), sizeof(u_int64_t)));     	(tag)->m_tag_type = (type);                         	(tag)->m_tag_len = (uint16_t)(len);                 	(tag)->m_tag_id = (id);                             	(tag)->m_tag_data = (data);                         	(tag)->m_tag_mb_cl = (mb_cl);                       	m_tag_create_cookie(tag);                           }
M_TAG_VALID_PATTERN 0xfeedfacefeedfaceULL
M_TAG_FREE_PATTERN 0xdeadbeefdeadbeefULL
PF_TAG_GENERATED 0x1
PF_TAG_FRAGCACHE 0x2
PF_TAG_TRANSLATE_LOCALHOST 0x4
PF_TAG_REASSEMBLED 0x20
PF_TAG_REFRAGMENTED 0x40
PF_TAG_ID_SYSTEM_SERVICE 0xff00
PF_TAG_ID_STACK_DROP 0xff01
tx_seg_size proto_mtag.__pr_u.tcp.tm_tcp.__offload.__tx.seg_size
tso_segsz tx_seg_size
tx_hdr_len proto_mtag.__pr_u.tcp.tm_tcp.__offload.__tx.hdr_len
tx_start_seq proto_mtag.__pr_u.tcp.tm_tcp.__offload.__tx.start_seq
tx_tcp_pid proto_mtag.__pr_u.tcp.tm_tcp.__offload.__tx.pid
tx_tcp_e_pid proto_mtag.__pr_u.tcp.tm_tcp.__offload.__tx.e_pid
rx_seg_cnt proto_mtag.__pr_u.tcp.tm_tcp.__offload.__rx.seg_cnt
mp_dsn proto_mtag.__pr_u.tcp.tm_mptcp.mtpi_dsn
mp_rseq proto_mtag.__pr_u.tcp.tm_mptcp.mtpi_rel_seq
mp_rlen proto_mtag.__pr_u.tcp.tm_mptcp.mtpi_length
mp_csum proto_mtag.__pr_u.tcp.tm_mptcp.mtpi_csum
tx_udp_pid proto_mtag.__pr_u.udp._pid
tx_udp_e_pid proto_mtag.__pr_u.udp._e_pid
tx_rawip_pid proto_mtag.__pr_u.rawip._pid
tx_rawip_e_pid proto_mtag.__pr_u.rawip._e_pid
drv_tx_compl_arg builtin_mtag._drv_mtag._drv_tx_compl_arg
drv_tx_compl_data builtin_mtag._drv_mtag._drv_tx_compl_data
drv_tx_status builtin_mtag._drv_mtag._drv_tx_status
drv_flowid builtin_mtag._drv_mtag._drv_flowid
necp_mtag builtin_mtag._net_mtag._necp_mtag
proto_mtag builtin_mtag._net_mtag._proto_mtag
driver_mtag builtin_mtag._drv_mtag
csum_rx_val _csum_rx.val
csum_rx_start _csum_rx.start
csum_tx_start _csum_tx.start
csum_tx_stuff _csum_tx.stuff
src_ifindex _pkt_iaif.src
src_iff _pkt_iaif.src_flags
dst_ifindex _pkt_iaif.dst
dst_iff _pkt_iaif.dst_flags
bufstatus_if _pkt_bsr.if_data
bufstatus_sndbuf _pkt_bsr.sndbuf_data
pkt_mpriv_hash pkt_mpriv.__mpriv_u.__mpriv32[0].__mpriv32_u.__val32
pkt_mpriv_flags pkt_mpriv.__mpriv_u.__mpriv32[1].__mpriv32_u.__val32
pkt_mpriv_srcid pkt_mpriv.__mpriv_u.__mpriv32[2].__mpriv32_u.__val32
pkt_mpriv_fidx pkt_mpriv.__mpriv_u.__mpriv32[3].__mpriv32_u.__val32
FLOWSRC_INPCB 1
FLOWSRC_IFNET 2
FLOWSRC_PF 3
FLOWSRC_CHANNEL 4
PKTF_FLOW_ID 0x1
PKTF_FLOW_ADV 0x2
PKTF_FLOW_LOCALSRC 0x4
PKTF_FLOW_RAWSOCK 0x8
PKTF_PRIO_PRIVILEGED 0x10
PKTF_PROXY_DST 0x20
PKTF_INET_RESOLVE 0x40
PKTF_INET6_RESOLVE 0x80
PKTF_RESOLVE_RTR 0x100
PKTF_SKIP_PKTAP 0x200
PKTF_WAKE_PKT 0x400
PKTF_MPTCP 0x800
PKTF_MPSO 0x1000
PKTF_LOOP 0x2000
PKTF_IFAINFO 0x4000
PKTF_SO_BACKGROUND 0x8000
PKTF_FORWARDED 0x10000
PKTF_PRIV_GUARDED 0x20000
PKTF_KEEPALIVE 0x40000
PKTF_SO_REALTIME 0x80000
PKTF_VALID_UNSENT_DATA 0x100000
PKTF_TCP_REXMT 0x200000
PKTF_REASSEMBLED 0x400000
PKTF_TX_COMPL_TS_REQ 0x800000
PKTF_TS_VALID 0x1000000
PKTF_DRIVER_MTAG 0x2000000
PKTF_NEW_FLOW 0x4000000
PKTF_START_SEQ 0x8000000
PKTF_LAST_PKT 0x10000000
PKTF_MPTCP_REINJ 0x20000000
PKTF_MPTCP_DFIN 0x40000000
PKTF_HBH_CHKED 0x80000000
PKTF_EXT_OUTPUT_SCOPE 0x1
PKTF_EXT_L4S 0x2
PKTF_EXT_QUIC 0x4
PKT_CRUMB_TS_COMP_REQ 0x0001
PKT_CRUMB_TS_COMP_CB 0x0002
PKT_CRUMB_DLIL_OUTPUT 0x0004
PKT_CRUMB_FLOW_TX 0x0008
PKT_CRUMB_FQ_ENQUEUE 0x0010
PKT_CRUMB_FQ_DEQUEUE 0x0020
PKT_CRUMB_SK_PKT_COPY 0x0040
PKT_CRUMB_TCP_OUTPUT 0x0080
PKT_CRUMB_UDP_OUTPUT 0x0100
PKT_CRUMB_SOSEND 0x0200
PKT_CRUMB_DLIL_INPUT 0x0400
PKT_CRUMB_IP_INPUT 0x0800
PKT_CRUMB_TCP_INPUT 0x1000
PKT_CRUMB_UDP_INPUT 0x2000
CRUMB_INPUT_FLAG 0x0000000000010000
CRUMB_INTERFACE_FLAG 0x000000000001ffff
m_act m_nextpkt
m_dat M_dat.M_databuf
M_EXT 0x0001
M_PKTHDR 0x0002
M_EOR 0x0004
M_PROTO1 0x0008
M_PROTO2 0x0010
M_PROTO3 0x0020
M_LOOP 0x0040
M_PROTO5 0x0080
M_BCAST 0x0100
M_MCAST 0x0200
M_FRAG 0x0400
M_FIRSTFRAG 0x0800
M_LASTFRAG 0x1000
M_PROMISC 0x2000
M_HASFCS 0x4000
M_TAGHDR 0x8000
CSUM_IP 0x0001
CSUM_TCP 0x0002
CSUM_UDP 0x0004
CSUM_IP_FRAGS 0x0008
CSUM_FRAGMENT 0x0010
CSUM_TCPIPV6 0x0020
CSUM_UDPIPV6 0x0040
CSUM_FRAGMENT_IPV6 0x0080
CSUM_IP_CHECKED 0x0100
CSUM_IP_VALID 0x0200
CSUM_DATA_VALID 0x0400
CSUM_PSEUDO_HDR 0x0800
CSUM_PARTIAL 0x1000
CSUM_ZERO_INVERT 0x2000
CSUM_DATA_IPV6_VALID CSUM_DATA_VALID
CSUM_VLAN_TAG_VALID 0x00010000
CSUM_ADJUST_DONE 0x00020000
CSUM_VLAN_ENCAP_PRESENT 0x00040000
CSUM_TSO_IPV4 0x00100000
CSUM_TSO_IPV6 0x00200000
TSO_IPV4_OK(_ifp, _m)                                               (((_ifp)->if_hwassist & IFNET_TSO_IPV4) &&                              ((_m)->m_pkthdr.csum_flags & CSUM_TSO_IPV4))
TSO_IPV4_NOTOK(_ifp, _m)                                            (!((_ifp)->if_hwassist & IFNET_TSO_IPV4) &&                             ((_m)->m_pkthdr.csum_flags & CSUM_TSO_IPV4))
TSO_IPV6_OK(_ifp, _m)                                               (((_ifp)->if_hwassist & IFNET_TSO_IPV6) &&                              ((_m)->m_pkthdr.csum_flags & CSUM_TSO_IPV6))
TSO_IPV6_NOTOK(_ifp, _m)                                            (!((_ifp)->if_hwassist & IFNET_TSO_IPV6) &&                             ((_m)->m_pkthdr.csum_flags & CSUM_TSO_IPV6))
MT_FREE 0
MT_DATA 1
MT_HEADER 2
MT_SOCKET 3
MT_PCB 4
MT_RTABLE 5
MT_HTABLE 6
MT_ATABLE 7
MT_SONAME 8
MT_SOOPTS 10
MT_FTABLE 11
MT_RIGHTS 12
MT_IFADDR 13
MT_CONTROL 14
MT_OOBDATA 15
MT_TAG 16
MT_MAX 32
MCHECK(m) m_mcheck(m)
MGET(m, how, type) ((m) = m_get((how), (type)))
MGETHDR(m, how, type)   ((m) = m_gethdr((how), (type)))
MCLALLOC(p, how)        ((p) = m_mclalloc(how))
MCLFREE(p) m_mclfree(p)
MCLGET(m, how)          ((m) = m_mclget(m, how))
MCLHASREFERENCE(m) m_mclhasreference(m)
MFREE(m, n) ((n) = m_free(m))
M_COPY_PKTHDR(to, from)         m_copy_pkthdr(to, from)
M_COPY_PFTAG(to, from)          m_copy_pftag(to, from)
M_COPY_NECPTAG(to, from)        m_copy_necptag(to, from)
M_COPY_CLASSIFIER(to, from)     m_copy_classifier(to, from)
MLEN _MLEN
MHLEN _MHLEN
M_ALIGN(m, len)         m_align(m, len)
MH_ALIGN(m, len)        m_align(m, len)
MEXT_ALIGN(m, len)      m_align(m, len)
M_PREPEND(m, plen, how, align)      ((m) = m_prepend_2((m), (plen), (how), (align)))
MCHTYPE(m, t)           m_mchtype(m, t)
m_copy(m, o, l)         m_copym((m), (o), (l), M_DONTWAIT)
MBSHIFT 20
GBSHIFT 30
M_STRUCT_GET(val, typ, m, off, len)                             do {                                                                    	struct mbuf *t;                                                 	int tmp;                                                                                                                                	if ((m)->m_len >= (off) + (len)) {                              	        (val) = (typ)(mtod((m), caddr_t) + (off));              	} else {                                                        	        t = m_pulldown((m), (off), (len), &tmp);                	        if (t != NULL) {                                        	                if (t->m_len < tmp + (len))                     	                        panic("m_pulldown malfunction");        	                (val) = (typ)(mtod(t, caddr_t) + tmp);          	        } else {                                                	                (val) = (typ)NULL;                              	                (m) = NULL;                                     	        }                                                       	}                                                               } while (0)
M_STRUCT_GET0(val, typ, m, off, len)                            do {                                                                    	struct mbuf *t;                                                                                                                         	if ((off) == 0 && ((m)->m_len >= (len))) {                      	        (val) = (typ)(void *)mtod(m, caddr_t);                  	} else {                                                        	        t = m_pulldown((m), (off), (len), NULL);                	        if (t != NULL) {                                        	                if (t->m_len < (len))                           	                        panic("m_pulldown malfunction");        	                (val) = (typ)(void *)mtod(t, caddr_t);          	        } else {                                                	                (val) = (typ)NULL;                              	                (m) = NULL;                                     	        }                                                       	}                                                               } while (0)
MBUF_INPUT_CHECK(m, rcvif)                                      do {                                                                    	if (!(m->m_flags & MBUF_PKTHDR) ||                              	    m->m_len < 0 ||                                             	    m->m_len > ((njcl > 0) ? njclbytes : MBIGCLBYTES) ||        	    m->m_type == MT_FREE ||                                     	    ((m->m_flags & M_EXT) != 0 && m->m_ext.ext_buf == NULL)) {  	        panic_plain("Failed mbuf validity check: mbuf %p len %d "  	            "type %d flags 0x%x data %p rcvif %s ifflags 0x%x", 	            m, m->m_len, m->m_type, m->m_flags,                 	            ((m->m_flags & M_EXT)                               	                                ? m->m_ext.ext_buf                              	                                : (caddr_t __unsafe_indexable)m->m_data),       	            if_name(rcvif),                                     	            (rcvif->if_flags & 0xffff));                        	}                                                               } while (0)
MBUFQ_HEAD(name) struct name {                                                   	struct mbuf *mq_first;                	struct mbuf **mq_last;    }
MBUFQ_INIT(q) do {                            	MBUFQ_FIRST(q) = NULL;                                  	(q)->mq_last = &MBUFQ_FIRST(q);                         } while (0)
MBUFQ_PREPEND(q, m)     do {                            	if ((MBUFQ_NEXT(m) = MBUFQ_FIRST(q)) == NULL)           	        (q)->mq_last = &MBUFQ_NEXT(m);                  	MBUFQ_FIRST(q) = (m);                                   } while (0)
MBUFQ_ENQUEUE(q, m)     do {                            	MBUFQ_NEXT(m) = NULL;                                   	*(q)->mq_last = (m);                                    	(q)->mq_last = &MBUFQ_NEXT(m);                          } while (0)
MBUFQ_ENQUEUE_MULTI(q, m, n)    do {                    	MBUFQ_NEXT(n) = NULL;                                   	*(q)->mq_last = (m);                                    	(q)->mq_last = &MBUFQ_NEXT(n);                          } while (0)
MBUFQ_DEQUEUE(q, m)     do {                            	if (((m) = MBUFQ_FIRST(q)) != NULL) {                   	        if ((MBUFQ_FIRST(q) = MBUFQ_NEXT(m)) == NULL)   	                (q)->mq_last = &MBUFQ_FIRST(q);         	        else                                            	                MBUFQ_NEXT(m) = NULL;                   	}                                                       } while (0)
MBUFQ_REMOVE(q, m)      do {                            	if (MBUFQ_FIRST(q) == (m)) {                            	        MBUFQ_DEQUEUE(q, m);                            	} else {                                                	        struct mbuf *_m = MBUFQ_FIRST(q);               	        while (MBUFQ_NEXT(_m) != (m))                   	                _m = MBUFQ_NEXT(_m);                    	        if ((MBUFQ_NEXT(_m) =                           	            MBUFQ_NEXT(MBUFQ_NEXT(_m))) == NULL)        	                (q)->mq_last = &MBUFQ_NEXT(_m);         	}                                                       } while (0)
MBUFQ_DRAIN(q) do {                            	struct mbuf *__m0;                                      	while ((__m0 = MBUFQ_FIRST(q)) != NULL) {               	        MBUFQ_FIRST(q) = MBUFQ_NEXT(__m0);              	        MBUFQ_NEXT(__m0) = NULL;                        	        m_freem(__m0);                                  	}                                                       	(q)->mq_last = &MBUFQ_FIRST(q);                         } while (0)
MBUFQ_DROP_AND_DRAIN(q, d, r) do {                  	struct mbuf *__m0;                                      	while ((__m0 = MBUFQ_FIRST(q)) != NULL) {               	        MBUFQ_FIRST(q) = MBUFQ_NEXT(__m0);              	        MBUFQ_NEXT(__m0) = NULL;                        	        m_drop(__m0, (d) | DROPTAP_FLAG_L2_MISSING, (r), NULL, 0); 	}                                                       	(q)->mq_last = &MBUFQ_FIRST(q);                         } while (0)
MBUFQ_FOREACH(m, q)                                     	for ((m) = MBUFQ_FIRST(q);                              	    (m);                                                	    (m) = MBUFQ_NEXT(m))
MBUFQ_FOREACH_SAFE(m, q, tvar)                          	for ((m) = MBUFQ_FIRST(q);                              	    (m) && ((tvar) = MBUFQ_NEXT(m), 1);                 	    (m) = (tvar))
MAX_MBUF_CNAME 15
MCS_DISABLED 0
MCS_ONLINE 1
MCS_PURGING 2
MCS_OFFLINE 3
MB_STAT_MAX_MB_CLASSES 8
MLEAK_STACK_DEPTH 16
HAS_M_TAG_STATS 1
M_TAG_TYPE_NAMES "other,dummynet,ipfilt,encap,inet6,ipsec,cfil_udp,pf_reass,aqm,drvaux"
M_COPYALL 1000000000
M_DONTWAIT M_NOWAIT
M_WAIT M_WAITOK
M_COPYM_NOOP_HDR 0
M_COPYM_COPY_HDR 1
M_COPYM_MOVE_HDR 2
M_COPYM_MUST_COPY_HDR 3
M_COPYM_MUST_MOVE_HDR 4
MBUF_STRICT_DATA_ALIGNMENT_CHECK_32(_m) None
MBUF_SC_MAX_CLASSES 10
SCIDX_BK_SYS MBUF_SCIDX(MBUF_SC_BK_SYS)
SCIDX_BK MBUF_SCIDX(MBUF_SC_BK)
SCIDX_BE MBUF_SCIDX(MBUF_SC_BE)
SCIDX_RD MBUF_SCIDX(MBUF_SC_RD)
SCIDX_OAM MBUF_SCIDX(MBUF_SC_OAM)
SCIDX_AV MBUF_SCIDX(MBUF_SC_AV)
SCIDX_RV MBUF_SCIDX(MBUF_SC_RV)
SCIDX_VI MBUF_SCIDX(MBUF_SC_VI)
SCIDX_SIG MBUF_SCIDX(MBUF_SC_SIG)
SCIDX_VO MBUF_SCIDX(MBUF_SC_VO)
SCIDX_CTL MBUF_SCIDX(MBUF_SC_CTL)
SCVAL_BK_SYS MBUF_SCVAL(MBUF_SC_BK_SYS)
SCVAL_BK MBUF_SCVAL(MBUF_SC_BK)
SCVAL_BE MBUF_SCVAL(MBUF_SC_BE)
SCVAL_RD MBUF_SCVAL(MBUF_SC_RD)
SCVAL_OAM MBUF_SCVAL(MBUF_SC_OAM)
SCVAL_AV MBUF_SCVAL(MBUF_SC_AV)
SCVAL_RV MBUF_SCVAL(MBUF_SC_RV)
SCVAL_VI MBUF_SCVAL(MBUF_SC_VI)
SCVAL_SIG MBUF_SCVAL(MBUF_SC_SIG)
SCVAL_VO MBUF_SCVAL(MBUF_SC_VO)
SCVAL_CTL MBUF_SCVAL(MBUF_SC_CTL)
KERNEL_MODULE_TAG_ID 0
ADDCARRY(_x) do {                                              	while (((_x) >> 16) != 0)                                       	        (_x) = ((_x) >> 16) + ((_x) & 0xffff);                  } while (0)
_SYS_MCACHE_H None
_CASSERT(x) _Static_assert(x, "compile-time assertion failed")
MAX_CPU_CACHE_LINE_SIZE 128
CPU_CACHE_LINE_SIZE mcache_cache_line_size()
IS_P2ALIGNED(v, a) 	((((uintptr_t)(v)) & ((uintptr_t)(a) - 1)) == 0)
P2ROUNDUP(x, align) 	(-(-((uintptr_t)(x)) & -((uintptr_t)align)))
P2ROUNDDOWN(x, align) 	(((uintptr_t)(x)) & ~((uintptr_t)(align) - 1))
P2ALIGN(x, align) 	((uintptr_t)(x) & -((uintptr_t)(align)))
MCACHE_FREE_PATTERN 0xdeadbeefdeadbeefULL
MCACHE_UNINITIALIZED_PATTERN 0xbaddcafebaddcafeULL
MCR_SLEEP 0x0000
MCR_NOSLEEP 0x0001
MCR_FAILOK 0x0100
MCR_TRYHARD 0x0200
MCR_USR1 0x1000
MCACHE_ALIGN 8
MCF_VERIFY 0x00000001
MCF_TRACE 0x00000002
MCF_NOCPUCACHE 0x00000010
MCF_NOLEAKLOG 0x00000100
MCF_EXPLEAKLOG 0x00000200
MCN_RETRYALLOC 0x00000001
MCACHE_STACK_DEPTH 16
MCA_TRN_MAX 2
DUMP_MCA_BUF_SIZE 512
_SYS_MD5_H_ None
_SYS_MEMORY_MAINTENANCE_H_ None
MEMORY_MAINTENANCE_DARK_BOOT_NVRAM_NAME "darkboot"
_SYS_MMAN_H_ None
PROT_NONE 0x00
PROT_READ 0x01
PROT_WRITE 0x02
PROT_EXEC 0x04
MAP_SHARED 0x0001
MAP_PRIVATE 0x0002
MAP_FIXED 0x0010
MCL_CURRENT 0x0001
MCL_FUTURE 0x0002
MS_ASYNC 0x0001
MS_INVALIDATE 0x0002
MS_SYNC 0x0010
POSIX_MADV_NORMAL 0
POSIX_MADV_RANDOM 1
POSIX_MADV_SEQUENTIAL 2
POSIX_MADV_WILLNEED 3
POSIX_MADV_DONTNEED 4
CRYPTID_NO_ENCRYPTION 0
CRYPTID_APP_ENCRYPTION 1
CRYPTID_MODEL_ENCRYPTION 2
SYS_MONOTONIC_H None
_SYS_MOUNT_H_ None
MFSNAMELEN 15
MFSTYPENAMELEN 16
MNT_EXT_ROOT_DATA_VOL 0x00000001
MNT_EXT_FSKIT 0x00000002
__DARWIN_STRUCT_STATFS64 { 	uint32_t	f_bsize;         	int32_t		f_iosize;        	uint64_t	f_blocks;        	uint64_t	f_bfree;         	uint64_t	f_bavail;        	uint64_t	f_files;         	uint64_t	f_ffree;         	fsid_t		f_fsid;          	uid_t		f_owner;         	uint32_t	f_type;          	uint32_t	f_flags;         	uint32_t	f_fssubtype;     	char		f_fstypename[MFSTYPENAMELEN];    	char		f_mntonname[MAXPATHLEN];         	char		f_mntfromname[MAXPATHLEN];       	uint32_t    f_flags_ext;     	uint32_t	f_reserved[7];   }
VFSATTR_SET_SUPPORTED(s, a)     ((s)->f_supported |= VFSATTR_ ## a)
VFSATTR_IS_SUPPORTED(s, a)      ((s)->f_supported & VFSATTR_ ## a)
VFSATTR_CLEAR_ACTIVE(s, a)      ((s)->f_active &= ~VFSATTR_ ## a)
VFSATTR_IS_ACTIVE(s, a)         ((s)->f_active & VFSATTR_ ## a)
VFSATTR_WANTED(s, a)            ((s)->f_active |= VFSATTR_ ## a)
VFSATTR_RETURN(s, a, x)         do { (s)-> a = (x); VFSATTR_SET_SUPPORTED(s, a);} while(0)
MNT_RDONLY 0x00000001
MNT_SYNCHRONOUS 0x00000002
MNT_NOEXEC 0x00000004
MNT_NOSUID 0x00000008
MNT_NODEV 0x00000010
MNT_UNION 0x00000020
MNT_ASYNC 0x00000040
MNT_CPROTECT 0x00000080
MNT_EXPORTED 0x00000100
MNT_REMOVABLE 0x00000200
MNT_QUARANTINE 0x00000400
MNT_LOCAL 0x00001000
MNT_QUOTA 0x00002000
MNT_ROOTFS 0x00004000
MNT_DOVOLFS 0x00008000
MNT_DONTBROWSE 0x00100000
MNT_IGNORE_OWNERSHIP 0x00200000
MNT_AUTOMOUNTED 0x00400000
MNT_JOURNALED 0x00800000
MNT_NOUSERXATTR 0x01000000
MNT_DEFWRITE 0x02000000
MNT_MULTILABEL 0x04000000
MNT_NOFOLLOW 0x08000000
MNT_NOATIME 0x10000000
MNT_SNAPSHOT 0x40000000
MNT_STRICTATIME 0x80000000
MNT_UNKNOWNPERMISSIONS MNT_IGNORE_OWNERSHIP
MNT_UPDATE 0x00010000
MNT_NOBLOCK 0x00020000
MNT_RELOAD 0x00040000
MNT_FORCE 0x00080000
VFS_GENERIC 0
VFS_NUMMNTOPS 1
VFS_MAXTYPENUM 1
VFS_CONF 2
MNT_WAIT 1
MNT_NOWAIT 2
MNT_DWAIT 4
MNT_VOLUME 8
VFS_CTL_VERS1 0x01
VFS_CTL_OSTATFS 0x00010001
VFS_CTL_UMOUNT 0x00010002
VFS_CTL_QUERY 0x00010003
VFS_CTL_NEWADDR 0x00010004
VFS_CTL_TIMEO 0x00010005
VFS_CTL_NOLOCKS 0x00010006
VFS_CTL_SADDR 0x00010007
VFS_CTL_DISC 0x00010008
VFS_CTL_SERVERINFO 0x00010009
VFS_CTL_NSTATUS 0x0001000A
VFS_CTL_STATFS64 0x0001000B
VQ_NOTRESP 0x0001
VQ_NEEDAUTH 0x0002
VQ_LOWDISK 0x0004
VQ_MOUNT 0x0008
VQ_UNMOUNT 0x0010
VQ_DEAD 0x0020
VQ_ASSIST 0x0040
VQ_NOTRESPLOCK 0x0080
VQ_UPDATE 0x0100
VQ_VERYLOWDISK 0x0200
VQ_SYNCEVENT 0x0400
VQ_SERVEREVENT 0x0800
VQ_QUOTA 0x1000
VQ_NEARLOWDISK 0x2000
VQ_DESIRED_DISK 0x4000
VQ_FREE_SPACE_CHANGE 0x8000
VQ_PURGEABLE_SPACE_CHANGE 0x10000
VQ_FLAG20000 0x20000
VFS_IOATTR_FLAGS_FUA 0x00000001
VFS_IOATTR_FLAGS_UNMAP 0x00000002
VFS_IOATTR_FLAGS_SWAPPIN_SUPPORTED 0x00000010
VFS_TBLTHREADSAFE 0x0001
VFS_TBLFSNODELOCK 0x0002
VFS_TBLNOTYPENUM 0x0008
VFS_TBLLOCALVOL 0x0010
VFS_TBL64BITREADY 0x0020
VFS_TBLNATIVEXATTR 0x0040
VFS_TBLDIRLINKS 0x0080
VFS_TBLUNMOUNT_PREFLIGHT 0x0100
VFS_TBLGENERICMNTARGS 0x0200
VFS_TBLREADDIR_EXTENDED 0x0400
VFS_TBLNOMACLABEL 0x1000
VFS_TBLVNOP_PAGEINV2 0x2000
VFS_TBLVNOP_PAGEOUTV2 0x4000
VFS_TBLVNOP_NOUPDATEID_RENAME 0x8000
VFS_TBLVNOP_SECLUDE_RENAME 0x10000
VFS_TBLCANMOUNTROOT 0x20000
VFSIOC_MOUNT_SNAPSHOT _IOW('V', 1, struct fs_snapshot_mount_args)
VFSIOC_REVERT_SNAPSHOT _IOW('V', 2, struct fs_snapshot_revert_args)
VFSIOC_ROOT_SNAPSHOT _IOW('V', 3, struct fs_snapshot_root_args)
VFSIOC_MOUNT_BYROLE _IOW('V', 4, fs_role_mount_args_t)
VFSIOC_MOUNT_BYROLE_has_recovery 1
VFS_RETURNED 0
VFS_RETURNED_DONE 1
VFS_CLAIMED 2
VFS_CLAIMED_DONE 3
CACHED_RIGHT_INFINITE_TTL ~0
VFS_USER_EVENT 0
VFS_KERNEL_EVENT 1
LK_NOWAIT 1
VFS_MOUNT_FLAG_NOAUTH 0x01
VFS_MOUNT_FLAG_PERMIT_UNMOUNT 0x02
VFS_MOUNT_FLAG_CURRENT_CONTEXT 0x04
NFS_MAX_FH_SIZE NFSV4_MAX_FH_SIZE
NFSV4_MAX_FH_SIZE 128
NFSV3_MAX_FH_SIZE 64
NFSV2_MAX_FH_SIZE 32
CRYPTEX_AUTH_STRUCT_VERSION 2
STATFS_EXT_NOBLOCK 0x0001
_SYS_MOUNT_INTERNAL_H_ None
CACHED_LOOKUP_RIGHT_TTL 2
MNT_IOFLAGS_FUA_SUPPORTED 0x00000001
MNT_IOFLAGS_UNMAP_SUPPORTED 0x00000002
MNT_IOFLAGS_IOSCHED_SUPPORTED 0x00000004
MNT_IOFLAGS_CSUNMAP_SUPPORTED 0x00000008
MNT_IOFLAGS_SWAPPIN_SUPPORTED 0x00000010
MNT_IOFLAGS_FUSION_DRIVE 0x00000020
MNT_IOFLAGS_PERIPHERAL_DRIVE 0x00000040
MNT_DEFAULT_IOQUEUE_DEPTH 32
MNTK_FSKIT 0x00000020
MNTK_SYSTEM 0x00000040
MNTK_NOSWAP 0x00000080
MNTK_SWAP_MOUNT 0x00000100
MNTK_DENY_READDIREXT 0x00000200
MNTK_PERMIT_UNMOUNT 0x00000400
MNTK_TYPENAME_OVERRIDE 0x00000800
MNTK_KERNEL_MOUNT 0x00001000
MNTK_BACKS_ROOT 0x00004000
MNTK_AUTH_CACHE_TTL 0x00008000
MNTK_PATH_FROM_ID 0x00010000
MNTK_UNMOUNT_PREFLIGHT 0x00020000
MNTK_NAMED_STREAMS 0x00040000
MNTK_EXTENDED_ATTRS 0x00080000
MNTK_LOCK_LOCAL 0x00100000
MNTK_VIRTUALDEV 0x00200000
MNTK_ROOTDEV 0x00400000
MNTK_SSD 0x00800000
MNTK_UNMOUNT 0x01000000
MNTK_MWAIT 0x02000000
MNTK_WANTRDWR 0x04000000
MNTK_SYSTEMDATA 0x08000000
MNTK_DIR_HARDLINKS 0x10000000
MNTK_AUTH_OPAQUE 0x20000000
MNTK_AUTH_OPAQUE_ACCESS 0x40000000
MNTK_EXTENDED_SECURITY 0x80000000
MNTK_SUPL_BASESYSTEM 0x00000001
MNTK_SUPL_USE_FULLSYNC 0x00000002
MNT_LNOTRESP 0x00000001
MNT_LUNMOUNT 0x00000002
MNT_LFORCE 0x00000004
MNT_LDRAIN 0x00000008
MNT_LITER 0x00000010
MNT_LNEWVN 0x00000020
MNT_LWAIT 0x00000040
MNT_LMOUNT 0x00000080
MNT_LDEAD 0x00000100
MNT_LNOSUB 0x00000200
VFC_VFSLOCALARGS 0x002
VFC_VFSGENERICARGS 0x004
VFC_VFSNATIVEXATTR 0x010
VFC_VFSCANMOUNTROOT 0x020
VFC_VFSPREFLIGHT 0x040
VFC_VFSREADDIR_EXTENDED 0x080
VFC_VFS64BITREADY 0x100
VFC_VFSNOMACLABEL 0x1000
VFC_VFSVNOP_PAGEINV2 0x2000
VFC_VFSVNOP_PAGEOUTV2 0x4000
VFC_VFSVNOP_NOUPDATEID_RENAME 0x8000
VFC_VFSVNOP_SECLUDE_RENAME 0x10000
LOWPRI_MAX_NUM_DEV 64
VFSSR_VIRTUALDEV_PROHIBITED 0x01
KERNEL_MOUNT_NOAUTH 0x01
KERNEL_MOUNT_PERMIT_UNMOUNT 0x02
KERNEL_MOUNT_SNAPSHOT 0x04
KERNEL_MOUNT_DATAVOL 0x08
KERNEL_MOUNT_VMVOL 0x10
KERNEL_MOUNT_PREBOOTVOL 0x20
KERNEL_MOUNT_RECOVERYVOL 0x40
KERNEL_MOUNT_BASESYSTEMROOT 0x80
KERNEL_MOUNT_DEVFS 0x100
KERNEL_MOUNT_FMOUNT 0x200
KERNEL_MOUNT_KMOUNT 0x400
_SYS_MSG_H_ None
MSG_NOERROR 010000
_SYS_MSGBUF_H_ None
MSG_MAGIC 0x063061
__MUNGE_H__ None
_SYS_NAMEI_H_ None
LOCKLEAF 0x0004
LOCKPARENT 0x0008
WANTPARENT 0x0010
CN_SECLUDE_RENAME 0x10000000
CN_RAW_ENCRYPTED 0x80000000
NAMEDRSRCFORK NAMEDSTREAMS
PATHBUFLEN 256
NAMEI_CONTLOOKUP 0x002
NAMEI_TRAILINGSLASH 0x004
NAMEI_UNFINISHED 0x008
NAMEI_COMPOUNDOPEN 0x010
NAMEI_COMPOUNDREMOVE 0x020
NAMEI_COMPOUNDMKDIR 0x040
NAMEI_COMPOUNDRMDIR 0x080
NAMEI_COMPOUNDRENAME 0x100
NAMEI_NOFOLLOW_ANY 0x1000
NAMEI_ROOTDIR 0x2000
NAMEI_RESOLVE_BENEATH 0x4000
NOCACHE 0x00000020
NOFOLLOW 0x00000000
SHAREDLEAF 0x00000080
MODMASK 0x100000fc
SAVENAME 0
NOCROSSMOUNT 0x00000100
RDONLY 0x00000200
HASBUF 0x00000400
DONOTAUTH 0x00000800
SAVESTART 0x00001000
ISSYMLINK 0x00010000
WILLBEDIR 0x00080000
AUDITVNPATH1 0x00100000
AUDITVNPATH2 0x00200000
USEDVP 0x00400000
CN_VOLFSPATH 0x00800000
CN_FIRMLINK_NOFOLLOW 0x01000000
UNIONCREATED 0x02000000
CN_WANTSRSRCFORK 0x04000000
CN_ALLOWRSRCFORK 0x08000000
CN_NBMOUNTLOOK 0x20000000
CN_SKIPNAMECACHE 0x40000000
NDINIT(ndp, op, pop, flags, segflg, namep, ctx) { 	(ndp)->ni_cnd.cn_nameiop = op; 	(ndp)->ni_op = pop; 	(ndp)->ni_cnd.cn_flags = flags; 	if ((segflg) == UIO_USERSPACE) { 	        (ndp)->ni_segflg = (vfs_context_is64bit(ctx) ? UIO_USERSPACE64 : UIO_USERSPACE32); 	} 	else { 	        (ndp)->ni_segflg = segflg; 	} 	(ndp)->ni_dirp = namep; 	(ndp)->ni_cnd.cn_context = ctx; 	(ndp)->ni_flag = 0; 	(ndp)->ni_cnd.cn_ndp = (ndp); }
NC_VALID 0x01
_SYS_NETBOOT_H None
_SYS_NETPORT_H_ None
_OS_LOG_COPROCESSOR_H_ None
_SYS_PARAM_H_ None
BSD 199506
BSD4_3 1
BSD4_4 1
NeXTBSD 1995064
NeXTBSD4_0 0
MAXCOMLEN 16
MAXINTERP 64
MAXLOGNAME 255
MAXUPRC CHILD_MAX
NCARGS ARG_MAX
NGROUPS NGROUPS_MAX
NOFILE 256
NOGROUP 65535
MAXHOSTNAMELEN 256
MAXDOMNAMELEN 256
PSWP 0
PVM 4
PINOD 8
PRIBIO 16
PVFS 20
PZERO 22
PSOCK 24
PWAIT 32
PLOCK 36
PPAUSE 40
PUSER 50
MAXPRI 127
PRIMASK 0x0ff
PCATCH 0x100
PTTYBLOCK 0x200
PDROP 0x400
PSPIN 0x800
NBPW sizeof(int)
CMASK 022
CLOFF CLOFSET
CBLOCK 64
MAXPHYSIO MAXPHYS
MAXFRAG 8
MAXPATHLEN PATH_MAX
MAXSYMLINKS 32
setbit(a, i)     (((unsigned char *)(a))[(i)/NBBY] |= 1u<<((i)%NBBY))
clrbit(a, i)     (((unsigned char *)(a))[(i)/NBBY] &= ~(1u<<((i)%NBBY)))
isset(a, i)      (((unsigned char *)(a))[(i)/NBBY] & (1u<<((i)%NBBY)))
isclr(a, i)      ((((unsigned char *)(a))[(i)/NBBY] & (1u<<((i)%NBBY))) == 0)
howmany(x, y)   ((((x) % (y)) == 0) ? ((x) / (y)) : (((x) / (y)) + 1))
roundup(x, y)   ((((x) % (y)) == 0) ? 	                (x) : ((x) + ((y) - ((x) % (y)))))
MIN(a, b) (((a)<(b))?(a):(b))
MAX(a, b) (((a)>(b))?(a):(b))
FSHIFT 11
_SYS_PATHS_H_ None
_SYS_PERSONA_H_ None
PERSONA_INFO_V1 1
PERSONA_INFO_V2 2
PERSONA_OP_ALLOC 1
PERSONA_OP_PALLOC 2
PERSONA_OP_DEALLOC 3
PERSONA_OP_GET 4
PERSONA_OP_INFO 5
PERSONA_OP_PIDINFO 6
PERSONA_OP_FIND 7
PERSONA_OP_GETPATH 8
PERSONA_OP_FIND_BY_TYPE 9
PERSONA_MGMT_ENTITLEMENT "com.apple.private.persona-mgmt"
persona_lock(persona) lck_mtx_lock(&(persona)->pna_lock)
persona_unlock(persona) lck_mtx_unlock(&(persona)->pna_lock)
persona_try_lock(persona) lck_mtx_try_lock(&(persona)->pna_lock)
persona_lock_assert_held(persona) LCK_MTX_ASSERT(&(persona)->pna_lock, LCK_MTX_ASSERT_OWNED)
_KAUTH_CRED_T None
_SYS_PGO_H_ None
_SYS_PIPE_H_ None
PIPE_SIZE 16384
SMALL_PIPE_SIZE PAGE_SIZE
PIPE_MINDIRECT 8192
PIPE_ASYNC 0x004
PIPE_WANTR 0x008
PIPE_WANTW 0x010
PIPE_WANT 0x020
PIPE_EOF 0x080
PIPE_LOCKFL 0x100
PIPE_LWANT 0x200
PIPE_DIRECTW 0x400
PIPE_DIRECTOK 0x800
PIPE_DRAIN 0x2000
PIPE_WSELECT 0x4000
PIPE_DEAD 0x8000
PIPE_LOCK(pipe) lck_mtx_lock(PIPE_MTX(pipe))
PIPE_UNLOCK(pipe) lck_mtx_unlock(PIPE_MTX(pipe))
PIPE_LOCK_ASSERT(pipe, type)  LCK_MTX_ASSERT(PIPE_MTX(pipe), (type))
_SYS_POLL_H_ None
POLLIN 0x0001
POLLPRI 0x0002
POLLOUT 0x0004
POLLRDNORM 0x0040
POLLWRNORM POLLOUT
POLLRDBAND 0x0080
POLLWRBAND 0x0100
POLLEXTEND 0x0200
POLLATTRIB 0x0400
POLLNLINK 0x0800
POLLWRITE 0x1000
POLLERR 0x0008
POLLHUP 0x0010
POLLNVAL 0x0020
_SYS_POSIX_SEM_H_ None
PSEMNAMLEN 31
PSEM_NONE 1
PSEM_DEFINED 2
PSEM_ALLOCATED 4
PSEM_MAPPED 8
PSEM_INUSE 0x10
PSEM_REMOVED 0x20
PSEM_INCREATE 0x40
PSEM_INDELETE 0x80
_SYS_POSIX_SHM_H_ None
PSHMNAMLEN 31
_SYS_PREOSLOG_H_ None
PREOSLOG_MAGIC 'LSOP'
PREOSLOG_SYSCTL "kern.preoslog"
_SYS_PRIV_H_ None
PRIV_ADJTIME 1000
PRIV_PROC_UUID_POLICY 1001
PRIV_GLOBAL_PROC_INFO 1002
PRIV_SYSTEM_OVERRIDE 1003
PRIV_HW_DEBUG_DATA 1004
PRIV_SELECTIVE_FORCED_IDLE 1005
PRIV_PROC_TRACE_INSPECT 1006
PRIV_DARKBOOT 1007
PRIV_WORK_INTERVAL 1008
PRIV_SMB_TIMEMACHINE_CONTROL 1009
PRIV_AUDIO_LATENCY 1010
PRIV_KTRACE_BACKGROUND 1011
PRIV_SETPRIORITY_DARWIN_ROLE 1012
PRIV_PACKAGE_EXTENSIONS 1013
PRIV_TRIM_ACTIVE_FILE 1014
PRIV_PROC_CPUMON_OVERRIDE 1015
PRIV_ENDPOINTSECURITY_CLIENT 1016
PRIV_AUDIT_SESSION_PORT 1017
PRIV_VM_PRESSURE 6000
PRIV_VM_JETSAM 6001
PRIV_VM_FOOTPRINT_LIMIT 6002
PRIV_NET_PRIVILEGED_TRAFFIC_CLASS 10000
PRIV_NET_PRIVILEGED_SOCKET_DELEGATE 10001
PRIV_NET_INTERFACE_CONTROL 10002
PRIV_NET_PRIVILEGED_NETWORK_STATISTICS 10003
PRIV_NET_PRIVILEGED_NECP_POLICIES 10004
PRIV_NET_RESTRICTED_AWDL 10005
PRIV_NET_PRIVILEGED_NECP_MATCH 10006
PRIV_NET_QOSMARKING_POLICY_OVERRIDE 10007
PRIV_NET_RESTRICTED_INTCOPROC 10008
PRIV_NET_RESTRICTED_MULTIPATH_EXTENDED 10010
PRIV_NET_RESTRICTED_ROUTE_NC_READ 10011
PRIV_NET_PRIVILEGED_CLIENT_ACCESS 10012
PRIV_NET_PRIVILEGED_SERVER_ACCESS 10013
PRIV_NET_VALIDATED_RESOLVER 10014
PRIV_NET_CUSTOM_PROTOCOL 10015
PRIV_NET_PRIVILEGED_NECP_DROP_ALL_BYPASS 10016
PRIV_NET_PRIVILEGED_IPSEC_WAKE_PACKET 10017
PRIV_NET_RESTRICTED_MANAGEMENT_DATA 10018
PRIV_NETINET_RESERVEDPORT 11000
PRIV_NETINET_TCP_KA_OFFLOAD 11001
PRIV_SKYWALK_REGISTER_USER_PIPE 12000
PRIV_SKYWALK_REGISTER_KERNEL_PIPE 12001
PRIV_SKYWALK_REGISTER_NET_IF 12002
PRIV_SKYWALK_REGISTER_FLOW_SWITCH 12003
PRIV_SKYWALK_LOW_LATENCY_CHANNEL 12004
PRIV_SKYWALK_OBSERVE_ALL 12010
PRIV_SKYWALK_OBSERVE_STATS 12011
PRIV_VFS_OPEN_BY_ID 14000
PRIV_VFS_MOVE_DATA_EXTENTS 14001
PRIV_VFS_SNAPSHOT 14002
PRIV_VFS_DATALESS_RESOLVER 14004
PRIV_VFS_SETSIZE 14006
_SYS_PROC_H_ None
SYSCALL_MASK_UNIX 0
SYSCALL_MASK_MACH 1
SYSCALL_MASK_KOBJ 2
SYSCALL_FILTER_CALLBACK_VERSION 1
SHUTDOWN_SOCKET_LEVEL_DISCONNECT_SVC 0x00000001
SHUTDOWN_SOCKET_LEVEL_DISCONNECT_ALL 0x00000002
SHUTDOWN_SOCKET_LEVEL_DISCONNECT_INTERNAL 0x10000000
SHUTDOWN_SOCKET_LEVEL_NECP 0x20000000
SHUTDOWN_SOCKET_LEVEL_CONTENT_FILTER 0x40000000
PROCESS_RESUME_SUSPEND_ENTITLEMENT "com.apple.private.process.suspend-resume.any"
_SYS_PROCESS_POLICY_H None
PROCESS_POLICY_OSX 1
PROC_POLICY_SCOPE_PROCESS 1
PROC_POLICY_SCOPE_THREAD 2
PROC_POLICY_ACTION_APPLY 1
PROC_POLICY_ACTION_RESTORE 2
PROC_POLICY_ACTION_DENYINHERIT 3
PROC_POLICY_ACTION_DENYSELFSET 4
PROC_POLICY_ACTION_ENABLE 5
PROC_POLICY_ACTION_DISABLE 6
PROC_POLICY_ACTION_SET 10
PROC_POLICY_ACTION_GET 11
PROC_POLICY_ACTION_ADD 12
PROC_POLICY_ACTION_REMOVE 13
PROC_POLICY_ACTION_HOLD 14
PROC_POLICY_ACTION_DROP 15
PROC_POLICY NONE		0
PROC_POLICY_BACKGROUND 1
PROC_POLICY_HARDWARE_ACCESS 2
PROC_POLICY_RESOURCE_STARVATION 3
PROC_POLICY_RESOURCE_USAGE 4
PROC_POLICY_APPTYPE 6
PROC_POLICY_BOOST 7
PROC_POLICY_NO_SMT 8
PROC_POLICY_TECS 9
PROC_POLICY_BG_NONE 0
PROC_POLICY_BG_LOWCPUPRI 1
PROC_POLICY_BG_DISKTHROTTLE 2
PROC_POLICY_BG_NETTHROTTLE 4
PROC_POLICY_BG_GPUDENY 8
PROC_POLICY_BG_DEFAULT PROC_POLICY_BG_ALL
PROC_POLICY_HWACCESS_NONE 0
PROC_POLICY_HWACCESS_DISK 1
PROC_POLICY_HWACCESS_GPU 2
PROC_POLICY_HWACCESS_NETWORK 3
PROC_POLICY_HWACCESS_CPU 4
PROC_POLICY_DISKACC_NONE 0
PROC_POLICY_DISKACC_NORMAL 1
PROC_POLICY_DISKACC_FULLACCESS 1
PROC_POLICY_DISKACC_PASSIVE 2
PROC_POLICY_DISKACC_THROTTLE 3
PROC_POLICY_DISKACC_DEFAULT PROC_POLICY_DISKACC_FULLACCESS
PROC_POLICY_GPUACC_NONE 0
PROC_POLICY_GPUACC_FULLACCESS 0
PROC_POLICY_GPUACC_DENYACCESS 1
PROC_POLICY_GPUACC_DEFAULT PROC_POLICY_GPUACC_FULLACCESS
PROC_POLICY_NETACC_NONE 0
PROC_POLICY_NETACC_FULLACCESS 0
PROC_POLICY_NETACC_THROTTLE 1
PROC_POLICY_NETACC_DEFAULT PROC_POLICY_NETACC_FULLACCESS
PROC_POLICY_CPUACC_NONE 0
PROC_POLICY_CPUACC_FULLACCESS 0
PROC_POLICY_CPUACC_ONE 1
PROC_POLICY_CPUACC_LLCACHE 2
PROC_POLICY_CPUACC_DEFAULT PROC_POLICY_CPUACC_FULLACCESS
PROC_POLICY_RS_NONE 0
PROC_POLICY_RS_VIRTUALMEM 1
PROC_POLICY_RUSAGE_NONE 0
PROC_POLICY_RUSAGE_WIREDMEM 1
PROC_POLICY_RUSAGE_VIRTMEM 2
PROC_POLICY_RUSAGE_CPU 3
PROC_POLICY_RUSAGE_DISK 4
PROC_POLICY_RUSAGE_NETWORK 5
PROC_POLICY_RUSAGE_POWER 6
PROC_POLICY_RSRCACT_NONE 0
PROC_POLICY_RSRCACT_THROTTLE 1
PROC_POLICY_RSRCACT_SUSPEND 2
PROC_POLICY_RSRCACT_TERMINATE 3
PROC_POLICY_RSRCACT_NOTIFY_KQ 4
PROC_POLICY_RSRCACT_NOTIFY_EXC 5
PROC_POLICY_CPUMON_DISABLE 0xFF
PROC_POLICY_CPUMON_DEFAULTS 0xFE
PROC_POLICY_IMP_IMPORTANT 1
PROC_POLICY_IMP_STANDARD 2
PROC_POLICY_IMP_DONATION 3
PROC_POLICY_APPTYPE_NONE 0
PROC_POLICY_APPTYPE_MODIFY 1
PROC_POLICY_OSX_APPTYPE_TAL 1
PROC_POLICY_OSX_APPTYPE_DASHCLIENT 2
PROC_POLICY_IOS_DONATEIMP 6
PROC_POLICY_IOS_HOLDIMP 7
PROC_POLICY_IOS_DROPIMP 8
_SYS_PROC_INFO_H None
PROC_ALL_PIDS 1
PROC_PGRP_ONLY 2
PROC_TTY_ONLY 3
PROC_UID_ONLY 4
PROC_RUID_ONLY 5
PROC_PPID_ONLY 6
PROC_KDBG_ONLY 7
PROC_FLAG_SYSTEM 1
PROC_FLAG_TRACED 2
PROC_FLAG_INEXIT 4
PROC_FLAG_PPWAIT 8
PROC_FLAG_LP64 0x10
PROC_FLAG_SLEADER 0x20
PROC_FLAG_CTTY 0x40
PROC_FLAG_CONTROLT 0x80
PROC_FLAG_THCWD 0x100
PROC_FLAG_PC_THROTTLE 0x200
PROC_FLAG_PC_SUSP 0x400
PROC_FLAG_PC_KILL 0x600
PROC_FLAG_PC_MASK 0x600
PROC_FLAG_PA_THROTTLE 0x800
PROC_FLAG_PA_SUSP 0x1000
PROC_FLAG_PSUGID 0x2000
PROC_FLAG_EXEC 0x4000
MAXTHREADNAMESIZE 64
PROC_REGION_SUBMAP 1
PROC_REGION_SHARED 2
SM_COW 1
SM_PRIVATE 2
SM_EMPTY 3
SM_SHARED 4
SM_TRUESHARED 5
SM_PRIVATE_ALIASED 6
SM_SHARED_ALIASED 7
SM_LARGE_PAGE 8
TH_STATE_RUNNING 1
TH_STATE_STOPPED 2
TH_STATE_WAITING 3
TH_STATE_UNINTERRUPTIBLE 4
TH_STATE_HALTED 5
TH_FLAGS_SWAPPED 0x1
TH_FLAGS_IDLE 0x2
WQ_EXCEEDED_CONSTRAINED_THREAD_LIMIT 0x1
WQ_EXCEEDED_TOTAL_THREAD_LIMIT 0x2
WQ_FLAGS_AVAILABLE 0x4
WQ_EXCEEDED_COOPERATIVE_THREAD_LIMIT 0x8
WQ_EXCEEDED_ACTIVE_CONSTRAINED_THREAD_LIMIT 0x10
PROC_FP_SHARED 1
PROC_FP_CLEXEC 2
PROC_FP_GUARDED 4
PROC_FP_CLFORK 8
INI_IPV4 0x1
INI_IPV6 0x2
TSI_T_REXMT 0
TSI_T_PERSIST 1
TSI_T_KEEP 2
TSI_T_2MSL 3
TSI_T_NTIMERS 4
TSI_S_CLOSED 0
TSI_S_LISTEN 1
TSI_S_SYN_SENT 2
TSI_S_SYN_RECEIVED 3
TSI_S_ESTABLISHED 4
TSI_S__CLOSE_WAIT 5
TSI_S_FIN_WAIT_1 6
TSI_S_CLOSING 7
TSI_S_LAST_ACK 8
TSI_S_FIN_WAIT_2 9
TSI_S_TIME_WAIT 10
TSI_S_RESERVED 11
SOI_S_NOFDREF 0x0001
SOI_S_ISCONNECTED 0x0002
SOI_S_ISCONNECTING 0x0004
SOI_S_ISDISCONNECTING 0x0008
SOI_S_CANTSENDMORE 0x0010
SOI_S_CANTRCVMORE 0x0020
SOI_S_RCVATMARK 0x0040
SOI_S_PRIV 0x0080
SOI_S_NBIO 0x0100
SOI_S_ASYNC 0x0200
SOI_S_INCOMP 0x0800
SOI_S_COMP 0x1000
SOI_S_ISDISCONNECTED 0x2000
SOI_S_DRAINING 0x4000
PROC_KQUEUE_SELECT 0x0001
PROC_KQUEUE_SLEEP 0x0002
PROC_KQUEUE_32 0x0008
PROC_KQUEUE_64 0x0010
PROC_KQUEUE_QOS 0x0020
PROX_FDTYPE_ATALK 0
PROX_FDTYPE_VNODE 1
PROX_FDTYPE_SOCKET 2
PROX_FDTYPE_PSHM 3
PROX_FDTYPE_PSEM 4
PROX_FDTYPE_KQUEUE 5
PROX_FDTYPE_PIPE 6
PROX_FDTYPE_FSEVENTS 7
PROX_FDTYPE_NETPOLICY 9
PROX_FDTYPE_CHANNEL 10
PROX_FDTYPE_NEXUS 11
PROC_CHANNEL_TYPE_USER_PIPE 0
PROC_CHANNEL_TYPE_KERNEL_PIPE 1
PROC_CHANNEL_TYPE_NET_IF 2
PROC_CHANNEL_TYPE_FLOW_SWITCH 3
PROC_CHANNEL_FLAGS_MONITOR_TX 0x1
PROC_CHANNEL_FLAGS_MONITOR_RX 0x2
PROC_CHANNEL_FLAGS_MONITOR_NO_COPY 0x4
PROC_CHANNEL_FLAGS_EXCLUSIVE 0x10
PROC_CHANNEL_FLAGS_USER_PACKET_POOL 0x20
PROC_CHANNEL_FLAGS_DEFUNCT_OK 0x40
PROC_CHANNEL_FLAGS_LOW_LATENCY 0x80
PROC_PIDLISTFDS 1
PROC_PIDTASKALLINFO 2
PROC_PIDTBSDINFO 3
PROC_PIDTASKINFO 4
PROC_PIDTHREADINFO 5
PROC_PIDLISTTHREADS 6
PROC_PIDREGIONINFO 7
PROC_PIDREGIONPATHINFO 8
PROC_PIDVNODEPATHINFO 9
PROC_PIDTHREADPATHINFO 10
PROC_PIDPATHINFO 11
PROC_PIDWORKQUEUEINFO 12
PROC_PIDT_SHORTBSDINFO 13
PROC_PIDLISTFILEPORTS 14
PROC_PIDTHREADID64INFO 15
PROC_PID_RUSAGE 16
PROC_PID_RUSAGE_SIZE 0
PROC_PIDFDVNODEINFO 1
PROC_PIDFDVNODEPATHINFO 2
PROC_PIDFDSOCKETINFO 3
PROC_PIDFDPSEMINFO 4
PROC_PIDFDPSHMINFO 5
PROC_PIDFDPIPEINFO 6
PROC_PIDFDKQUEUEINFO 7
PROC_PIDFDATALKINFO 8
PROC_PIDFDCHANNELINFO 10
PROC_PIDFILEPORTVNODEPATHINFO 2
PROC_PIDFILEPORTVNODEPATHINFO_SIZE PROC_PIDFDVNODEPATHINFO_SIZE
PROC_PIDFILEPORTSOCKETINFO 3
PROC_PIDFILEPORTSOCKETINFO_SIZE PROC_PIDFDSOCKETINFO_SIZE
PROC_PIDFILEPORTPSHMINFO 5
PROC_PIDFILEPORTPSHMINFO_SIZE PROC_PIDFDPSHMINFO_SIZE
PROC_PIDFILEPORTPIPEINFO 6
PROC_PIDFILEPORTPIPEINFO_SIZE PROC_PIDFDPIPEINFO_SIZE
PROC_SELFSET_PCONTROL 1
PROC_SELFSET_THREADNAME 2
PROC_SELFSET_VMRSRCOWNER 3
PROC_SELFSET_DELAYIDLESLEEP 4
PROC_DIRTYCONTROL_TRACK 1
PROC_DIRTYCONTROL_SET 2
PROC_DIRTYCONTROL_GET 3
PROC_DIRTYCONTROL_CLEAR 4
PROC_DIRTY_TRACK 0x1
PROC_DIRTY_ALLOW_IDLE_EXIT 0x2
PROC_DIRTY_DEFER 0x4
PROC_DIRTY_LAUNCH_IN_PROGRESS 0x8
PROC_DIRTY_DEFER_ALWAYS 0x10
PROC_DIRTY_TRACKED 0x1
PROC_DIRTY_ALLOWS_IDLE_EXIT 0x2
PROC_DIRTY_IS_DIRTY 0x4
PROC_DIRTY_LAUNCH_IS_IN_PROGRESS 0x8
PROC_UDATA_INFO_GET 1
PROC_UDATA_INFO_SET 2
_SYS_PROC_INFO_PRIVATE_H None
PROC_FLAG_DARWINBG 0x8000
PROC_FLAG_EXT_DARWINBG 0x10000
PROC_FLAG_IOS_APPLEDAEMON 0x20000
PROC_FLAG_DELAYIDLESLEEP 0x40000
PROC_FLAG_IOS_IMPPROMOTION 0x80000
PROC_FLAG_ADAPTIVE 0x100000
PROC_FLAG_ADAPTIVE_IMPORTANT 0x200000
PROC_FLAG_IMPORTANCE_DONOR 0x400000
PROC_FLAG_SUPPRESSED 0x800000
PROC_FLAG_APPLICATION 0x1000000
PROC_FLAG_IOS_APPLICATION PROC_FLAG_APPLICATION
PROC_FLAG_ROSETTA 0x2000000
PROC_FLAG_SEC_ENABLED 0x4000000
PROC_FLAG_SEC_BYPASS_ENABLED 0x8000000
PROC_KQUEUE_WORKQ 0x0040
PROC_KQUEUE_WORKLOOP 0x0080
PROC_PIDUNIQIDENTIFIERINFO 17
PROC_PIDT_BSDINFOWITHUNIQID 18
PROC_PIDARCHINFO 19
PROC_PIDCOALITIONINFO 20
PROC_PIDNOTEEXIT 21
PROC_PIDREGIONPATHINFO2 22
PROC_PIDREGIONPATHINFO3 23
PROC_PIDEXITREASONINFO 24
PROC_PIDEXITREASONBASICINFO 25
PROC_PIDLISTUPTRS 26
PROC_PIDLISTDYNKQUEUES 27
PROC_PIDLISTTHREADIDS 28
PROC_PIDVMRTFAULTINFO 29
PROC_PIDPLATFORMINFO 30
PROC_PIDREGIONPATH 31
PROC_PIDIPCTABLEINFO 32
PROC_PIDTHREADSCHEDINFO 33
PROC_PIDTHREADCOUNTS 34
PROC_PIDFDKQUEUE_EXTINFO 9
PROC_PIDORIGINATOR_UUID 0x1
PROC_PIDORIGINATOR_BGSTATE 0x2
PROC_PIDORIGINATOR_PID_UUID 0x3
LISTCOALITIONS_ALL_COALS 1
LISTCOALITIONS_SINGLE_TYPE 2
PROC_FGHW_OK 0
PROC_FGHW_DAEMON_OK 1
PROC_FGHW_DAEMON_LEADER 10
PROC_FGHW_LEADER_NONUI 11
PROC_FGHW_LEADER_BACKGROUND 12
PROC_FGHW_DAEMON_NO_VOUCHER 13
PROC_FGHW_NO_VOUCHER_ATTR 14
PROC_FGHW_NO_ORIGINATOR 15
PROC_FGHW_ORIGINATOR_BACKGROUND 16
PROC_FGHW_VOUCHER_ERROR 98
PROC_FGHW_ERROR 99
PROC_PIDDYNKQUEUE_INFO 0
PROC_PIDDYNKQUEUE_EXTINFO 1
PROC_INFO_CALL_LISTPIDS 0x1
PROC_INFO_CALL_PIDINFO 0x2
PROC_INFO_CALL_PIDFDINFO 0x3
PROC_INFO_CALL_KERNMSGBUF 0x4
PROC_INFO_CALL_SETCONTROL 0x5
PROC_INFO_CALL_PIDFILEPORTINFO 0x6
PROC_INFO_CALL_TERMINATE 0x7
PROC_INFO_CALL_DIRTYCONTROL 0x8
PROC_INFO_CALL_PIDRUSAGE 0x9
PROC_INFO_CALL_PIDORIGINATORINFO 0xa
PROC_INFO_CALL_LISTCOALITIONS 0xb
PROC_INFO_CALL_CANUSEFGHW 0xc
PROC_INFO_CALL_PIDDYNKQUEUEINFO 0xd
PROC_INFO_CALL_UDATA_INFO 0xe
PROC_INFO_CALL_SET_DYLD_IMAGES 0xf
PROC_INFO_CALL_TERMINATE_RSR 0x10
PROC_INFO_CALL_SIGNAL_AUDITTOKEN 0x11
PROC_INFO_CALL_TERMINATE_AUDITTOKEN 0x12
PROC_INFO_CALL_DELEGATE_SIGNAL 0x13
PROC_INFO_CALL_DELEGATE_TERMINATE 0x14
PIF_COMPARE_IDVERSION 0x01
PIF_COMPARE_UNIQUEID 0x02
_SYS_PROC_INTERNAL_H_ None
SESSION_REF_BITS 4
PGRP_REF_BITS 1
P_REF_BITS 8
PGRPID_DEAD 0xdeaddead
P_LIST_WAITING 0x00000010
P_LIST_CHILDDRSTART 0x00000080
P_LIST_CHILDDRAINED 0x00000100
P_LIST_CHILDDRWAIT 0x00000200
P_LIST_CHILDLKWAIT 0x00000400
P_LIST_DEADPARENT 0x00000800
P_LIST_PARENTREFWAIT 0x00001000
P_LIST_EXITCOUNT 0x00100000
P_LDELAYTERM 0x00000001
P_LHASTASK 0x00000002
P_LTERM 0x00000004
P_LEXIT 0x00000008
P_LPEXIT 0x00000010
P_LTRANSCOMMIT 0x00000020
P_LINTRANSIT 0x00000040
P_LTRANSWAIT 0x00000080
P_LTRACED 0x00000400
P_LSIGEXC 0x00000800
P_LNOATTACH 0x00001000
P_LPPWAIT 0x00002000
P_LPTHREADJITALLOWLIST 0x00004000
P_LPTHREADJITFREEZELATE 0x00008000
P_LTRACE_WAIT 0x00010000
P_LLIMCHANGE 0x00020000
P_LLIMWAIT 0x00040000
P_LWAITED 0x00080000
P_LINSIGNAL 0x00100000
P_LCUSTOM_STACK 0x00200000
P_LRAGE_VNODES 0x00400000
P_LREGISTER 0x00800000
P_LVMRSRCOWNER 0x01000000
P_LTERM_DECRYPTFAIL 0x04000000
P_LTERM_JETSAM 0x08000000
P_JETSAM_VMPAGESHORTAGE 0x00000000
P_JETSAM_VMTHRASHING 0x10000000
P_JETSAM_HIWAT 0x20000000
P_JETSAM_PID 0x30000000
P_JETSAM_IDLEEXIT 0x40000000
P_JETSAM_VNODE 0x50000000
P_JETSAM_FCTHRASHING 0x60000000
P_JETSAM_MASK 0x70000000
P_LNSPACE_RESOLVER 0x80000000
P_PCTHROTTLE 1
P_PCSUSP 2
P_PCKILL 3
P_PCMAX 3
PROC_ACTION_MASK 0xffff0000;
PROC_EXITREASON_FLAGS(p) p->p_exit_reason->osr_flags
P_LADVLOCK 0x01
P_LXBKIDLEINPROG 0x02
P_RSR 0x04
P_VFS_IOPOLICY_FORCE_HFS_CASE_SENSITIVITY 0x0001
P_VFS_IOPOLICY_ATIME_UPDATES 0x0002
P_VFS_IOPOLICY_MATERIALIZE_DATALESS_FILES 0x0004
P_VFS_IOPOLICY_STATFS_NO_DATA_VOLUME 0x0008
P_VFS_IOPOLICY_TRIGGER_RESOLVE_DISABLE 0x0010
P_VFS_IOPOLICY_IGNORE_CONTENT_PROTECTION 0x0020
P_VFS_IOPOLICY_IGNORE_NODE_PERMISSIONS 0x0040
P_VFS_IOPOLICY_SKIP_MTIME_UPDATE 0x0080
P_VFS_IOPOLICY_ALLOW_LOW_SPACE_WRITES 0x0100
P_VFS_IOPOLICY_DISALLOW_RW_FOR_O_EVTONLY 0x0200
P_VFS_IOPOLICY_ALTLINK 0x0400
P_VFS_IOPOLICY_NOCACHE_WRITE_FS_BLKSIZE 0x0800
P_VFS_IOPOLICY_SUPPORT_LONG_PATHS 0x1000
PROC_CREATE_FORK 0
PROC_CREATE_SPAWN 1
PID_MAX 99999
NO_PID 100000
BSD_SIMUL_EXECS 33
SESS_LEADER(p, sessp)   ((sessp)->s_leader == (p))
ALLPROC_FOREACH(var) LIST_FOREACH((var), &allproc, p_list)
ZOMBPROC_FOREACH(var) LIST_FOREACH((var), &zombproc, p_list)
PGMEMBERS_FOREACH(group, var) 	LIST_FOREACH((var), &((struct pgrp *)(group))->pg_members, p_pglist)
PCHILDREN_FOREACH(parent, var) 	LIST_FOREACH((var), &(((struct proc *)(parent))->p_children), p_sibling)
_SYS_PROC_REQUIRE_H_ None
_SYS_PROC_RO_H_ None
_SYS_PROC_UUID_POLICY_H None
PROC_UUID_POLICY_OPERATION_CLEAR 0x00000000
PROC_UUID_POLICY_OPERATION_ADD 0x00000001
PROC_UUID_POLICY_OPERATION_REMOVE 0x00000002
PROC_UUID_POLICY_FLAGS_NONE 0x00000000
PROC_UUID_NO_CELLULAR 0x00000001
PROC_UUID_NECP_APP_POLICY 0x00000002
PROC_UUID_ALT_DYLD_POLICY 0x00000004
PROC_UUID_ALT_ROSETTA_POLICY 0x00000008
PROC_UUID_FLOW_DIVERT 0x00000002
_SYS_PROTOSW_H_ None
PR_SLOWHZ 2
PRC_IFDOWN 0
PRC_ROUTEDEAD 1
PRC_IFUP 2
PRC_QUENCH2 3
PRC_QUENCH 4
PRC_MSGSIZE 5
PRC_HOSTDEAD 6
PRC_HOSTUNREACH 7
PRC_UNREACH_NET 8
PRC_UNREACH_HOST 9
PRC_UNREACH_PROTOCOL 10
PRC_UNREACH_PORT 11
PRC_UNREACH_SRCFAIL 13
PRC_REDIRECT_NET 14
PRC_REDIRECT_HOST 15
PRC_REDIRECT_TOSNET 16
PRC_REDIRECT_TOSHOST 17
PRC_TIMXCEED_INTRANS 18
PRC_TIMXCEED_REASS 19
PRC_PARAMPROB 20
PRC_UNREACH_ADMIN_PROHIB 21
PRC_NCMDS 22
PR_F_WILLUNLOCK 0x01
PR_ATOMIC 0x01
PR_ADDR 0x02
PR_CONNREQUIRED 0x04
PR_WANTRCVD 0x08
PR_RIGHTS 0x10
PR_IMPLOPCL 0x20
PR_LASTHDR 0x40
PR_PROTOLOCK 0x80
PR_PCBLOCK 0x100
PR_DISPOSE 0x200
PR_INITIALIZED 0x400
PR_ATTACHED 0x800
PR_MULTICONN 0x1000
PR_EVCONNINFO 0x2000
PR_PRECONN_WRITE 0x4000
PR_DATA_IDEMPOTENT 0x8000
PR_OLD 0x10000000
PRCO_GETOPT 0
PRCO_SETOPT 1
PRCO_NCMDS 2
PRU_ATTACH 0
PRU_DETACH 1
PRU_BIND 2
PRU_LISTEN 3
PRU_CONNECT 4
PRU_ACCEPT 5
PRU_DISCONNECT 6
PRU_SHUTDOWN 7
PRU_RCVD 8
PRU_SEND 9
PRU_ABORT 10
PRU_CONTROL 11
PRU_SENSE 12
PRU_RCVOOB 13
PRU_SENDOOB 14
PRU_SOCKADDR 15
PRU_PEERADDR 16
PRU_CONNECT2 17
PRU_FASTTIMO 18
PRU_SLOWTIMO 19
PRU_PROTORCV 20
PRU_PROTOSEND 21
PRU_SEND_EOF 22
PRU_NREQ 22
PRUS_OOB 0x1
PRUS_EOF 0x2
PRUS_MORETOCOME 0x4
PRUF_OLD 0x10000000
_SYS_PTHREAD_INTERNAL_H_ None
_PTHREAD_SHIMS_H_ None
M_PROC 41
PTHREAD_FUNCTIONS_TABLE_VERSION 1
_SYS_PTRACE_H_ None
PT_TRACE_ME 0
PT_READ_I 1
PT_READ_D 2
PT_READ_U 3
PT_WRITE_I 4
PT_WRITE_D 5
PT_WRITE_U 6
PT_CONTINUE 7
PT_KILL 8
PT_STEP 9
PT_ATTACH ePtAttachDeprecated
PT_DETACH 11
PT_SIGEXC 12
PT_THUPDATE 13
PT_ATTACHEXC 14
PT_FORCEQUOTA 30
PT_DENY_ATTACH 31
PT_FIRSTMACH 32
_SYS_QUEUE_H_ None
SLIST_HEAD(name, type)                                          __MISMATCH_TAGS_PUSH                                                    __NULLABILITY_COMPLETENESS_PUSH                                         struct name {                                                           	struct type *slh_first;                      }                                                                       __NULLABILITY_COMPLETENESS_POP                                          __MISMATCH_TAGS_POP
SLIST_HEAD_INITIALIZER(head) { NULL }
SLIST_ENTRY(type) __MISMATCH_TAGS_PUSH                                                    __NULLABILITY_COMPLETENESS_PUSH                                         struct {                                                                	struct type *sle_next;                        }                                                                       __NULLABILITY_COMPLETENESS_POP                                          __MISMATCH_TAGS_POP
SLIST_FOREACH(var, head, field)                                 	for ((var) = SLIST_FIRST((head));                               	    (var);                                                      	    (var) = SLIST_NEXT((var), field))
SLIST_FOREACH_SAFE(var, head, field, tvar)                      	for ((var) = SLIST_FIRST((head));                               	    (var) && ((tvar) = SLIST_NEXT((var), field), 1);            	    (var) = (tvar))
SLIST_FOREACH_PREVPTR(var, varp, head, field)                   	for ((varp) = &SLIST_FIRST((head));                             	    ((var) = *(varp)) != NULL;                                  	    (varp) = &SLIST_NEXT((var), field))
SLIST_INIT(head) do {                                           	SLIST_FIRST((head)) = NULL;                                     } while (0)
SLIST_INSERT_AFTER(slistelm, elm, field) do {                   	SLIST_NEXT((elm), field) = SLIST_NEXT((slistelm), field);       	SLIST_NEXT((slistelm), field) = (elm);                          } while (0)
SLIST_INSERT_HEAD(head, elm, field) do {                        	SLIST_NEXT((elm), field) = SLIST_FIRST((head));                 	SLIST_FIRST((head)) = (elm);                                    } while (0)
SLIST_NEXT(elm, field)  ((elm)->field.sle_next)
SLIST_REMOVE(head, elm, type, field)                            __MISMATCH_TAGS_PUSH                                                    __NULLABILITY_COMPLETENESS_PUSH                                         do {                                                                    	if (SLIST_FIRST((head)) == (elm)) {                             	        SLIST_REMOVE_HEAD((head), field);                       	}                                                               	else {                                                          	        struct type *curelm = SLIST_FIRST((head));              	        while (SLIST_NEXT(curelm, field) != (elm))              	                curelm = SLIST_NEXT(curelm, field);             	        SLIST_REMOVE_AFTER(curelm, field);                      	}                                                               	TRASHIT((elm)->field.sle_next);                                 } while (0)                                                             __NULLABILITY_COMPLETENESS_POP                                      __MISMATCH_TAGS_POP
SLIST_REMOVE_AFTER(elm, field) do {                             	SLIST_NEXT(elm, field) =                                        	    SLIST_NEXT(SLIST_NEXT(elm, field), field);                  } while (0)
SLIST_REMOVE_HEAD(head, field) do {                             	SLIST_FIRST((head)) = SLIST_NEXT(SLIST_FIRST((head)), field);   } while (0)
STAILQ_HEAD(name, type)                                         __MISMATCH_TAGS_PUSH                                                    __NULLABILITY_COMPLETENESS_PUSH                                         struct name {                                                           	struct type *stqh_first;                     	struct type **stqh_last;         }                                                                       __NULLABILITY_COMPLETENESS_POP                                          __MISMATCH_TAGS_POP
STAILQ_HEAD_INITIALIZER(head) { NULL, &(head).stqh_first }
STAILQ_ENTRY(type) __MISMATCH_TAGS_PUSH                                                    __NULLABILITY_COMPLETENESS_PUSH                                         struct {                                                                	struct type *stqe_next;                       }                                                                       __NULLABILITY_COMPLETENESS_POP                                         __MISMATCH_TAGS_POP
STAILQ_CONCAT(head1, head2) do {                                	if (!STAILQ_EMPTY((head2))) {                                   	        *(head1)->stqh_last = (head2)->stqh_first;              	        (head1)->stqh_last = (head2)->stqh_last;                	        STAILQ_INIT((head2));                                   	}                                                               } while (0)
STAILQ_FOREACH(var, head, field)                                	for((var) = STAILQ_FIRST((head));                               	   (var);                                                       	   (var) = STAILQ_NEXT((var), field))
STAILQ_FOREACH_SAFE(var, head, field, tvar)                     	for ((var) = STAILQ_FIRST((head));                              	    (var) && ((tvar) = STAILQ_NEXT((var), field), 1);           	    (var) = (tvar))
STAILQ_INIT(head) do {                                          	STAILQ_FIRST((head)) = NULL;                                    	(head)->stqh_last = &STAILQ_FIRST((head));                      } while (0)
STAILQ_INSERT_AFTER(head, tqelm, elm, field) do {               	if ((STAILQ_NEXT((elm), field) = STAILQ_NEXT((tqelm), field)) == NULL)	        (head)->stqh_last = &STAILQ_NEXT((elm), field);         	STAILQ_NEXT((tqelm), field) = (elm);                            } while (0)
STAILQ_INSERT_HEAD(head, elm, field) do {                       	if ((STAILQ_NEXT((elm), field) = STAILQ_FIRST((head))) == NULL) 	        (head)->stqh_last = &STAILQ_NEXT((elm), field);         	STAILQ_FIRST((head)) = (elm);                                   } while (0)
STAILQ_INSERT_TAIL(head, elm, field) do {                       	STAILQ_NEXT((elm), field) = NULL;                               	*(head)->stqh_last = (elm);                                     	(head)->stqh_last = &STAILQ_NEXT((elm), field);                 } while (0)
STAILQ_LAST(head, type, field)                                  __MISMATCH_TAGS_PUSH                                                    __NULLABILITY_COMPLETENESS_PUSH                                         	(STAILQ_EMPTY((head)) ?                                         	        NULL :                                                  	        ((struct type *)(void *)                                	        ((char *)((head)->stqh_last) - __offsetof(struct type, field))))__NULLABILITY_COMPLETENESS_POP                                         __MISMATCH_TAGS_POP
STAILQ_NEXT(elm, field) ((elm)->field.stqe_next)
STAILQ_REMOVE(head, elm, type, field)                           __MISMATCH_TAGS_PUSH                                                    __NULLABILITY_COMPLETENESS_PUSH                                         do {                                                                    	if (STAILQ_FIRST((head)) == (elm)) {                            	        STAILQ_REMOVE_HEAD((head), field);                      	}                                                               	else {                                                          	        struct type *curelm = STAILQ_FIRST((head));             	        while (STAILQ_NEXT(curelm, field) != (elm))             	                curelm = STAILQ_NEXT(curelm, field);            	        STAILQ_REMOVE_AFTER(head, curelm, field);               	}                                                               	TRASHIT((elm)->field.stqe_next);                                } while (0)                                                             __NULLABILITY_COMPLETENESS_POP                                      __MISMATCH_TAGS_POP
STAILQ_REMOVE_HEAD(head, field) do {                            	if ((STAILQ_FIRST((head)) =                                     	     STAILQ_NEXT(STAILQ_FIRST((head)), field)) == NULL)         	        (head)->stqh_last = &STAILQ_FIRST((head));              } while (0)
STAILQ_REMOVE_HEAD_UNTIL(head, elm, field) do {                        if ((STAILQ_FIRST((head)) = STAILQ_NEXT((elm), field)) == NULL) 	       (head)->stqh_last = &STAILQ_FIRST((head));              } while (0)
STAILQ_REMOVE_AFTER(head, elm, field) do {                      	if ((STAILQ_NEXT(elm, field) =                                  	     STAILQ_NEXT(STAILQ_NEXT(elm, field), field)) == NULL)      	        (head)->stqh_last = &STAILQ_NEXT((elm), field);         } while (0)
STAILQ_SWAP(head1, head2, type)                                 __MISMATCH_TAGS_PUSH                                                    __NULLABILITY_COMPLETENESS_PUSH                                         do {                                                                    	struct type *swap_first = STAILQ_FIRST(head1);                  	struct type **swap_last = (head1)->stqh_last;                   	STAILQ_FIRST(head1) = STAILQ_FIRST(head2);                      	(head1)->stqh_last = (head2)->stqh_last;                        	STAILQ_FIRST(head2) = swap_first;                               	(head2)->stqh_last = swap_last;                                 	if (STAILQ_EMPTY(head1))                                        	        (head1)->stqh_last = &STAILQ_FIRST(head1);              	if (STAILQ_EMPTY(head2))                                        	        (head2)->stqh_last = &STAILQ_FIRST(head2);              } while (0)                                                             __NULLABILITY_COMPLETENESS_POP                                          __MISMATCH_TAGS_POP
LIST_HEAD(name, type)                                           __MISMATCH_TAGS_PUSH                                                    __NULLABILITY_COMPLETENESS_PUSH                                         struct name {                                                           	struct type *lh_first;                       }                                                                       __NULLABILITY_COMPLETENESS_POP                                          __MISMATCH_TAGS_POP
LIST_HEAD_INITIALIZER(head) { NULL }
LIST_ENTRY(type) __MISMATCH_TAGS_PUSH                                                    __NULLABILITY_COMPLETENESS_PUSH                                         struct {                                                                	struct type *le_next;                         	struct type **le_prev;    }                                                                       __NULLABILITY_COMPLETENESS_POP                                          __MISMATCH_TAGS_POP
LIST_CHECK_HEAD(head, field) do {                               	if (__improbable(                                               	    LIST_FIRST((head)) != NULL &&                               	    LIST_FIRST((head))->field.le_prev !=                        	    &LIST_FIRST((head))))                                       	        ml_fatal_trap_invalid_list_linkage((uintptr_t)(head));  } while (0)
LIST_CHECK_NEXT(elm, field) do {                                	if (__improbable(                                               	    LIST_NEXT((elm), field) != NULL &&                          	    LIST_NEXT((elm), field)->field.le_prev !=                   	    &((elm)->field.le_next)))                                   	        ml_fatal_trap_invalid_list_linkage((uintptr_t)(elm));   } while (0)
LIST_CHECK_PREV(elm, field) do {                                	if (__improbable(*(elm)->field.le_prev != (elm)))               	        ml_fatal_trap_invalid_list_linkage((uintptr_t)(elm));   } while (0)
LIST_FOREACH(var, head, field)                                  	for ((var) = LIST_FIRST((head));                                	    (var);                                                      	    (var) = LIST_NEXT((var), field))
LIST_FOREACH_SAFE(var, head, field, tvar)                       	for ((var) = LIST_FIRST((head));                                	    (var) && ((tvar) = LIST_NEXT((var), field), 1);             	    (var) = (tvar))
LIST_INIT(head) do {                                            	LIST_FIRST((head)) = NULL;                                      } while (0)
LIST_INSERT_AFTER(listelm, elm, field) do {                     	LIST_CHECK_NEXT(listelm, field);                                	if ((LIST_NEXT((elm), field) = LIST_NEXT((listelm), field)) != NULL)	        LIST_NEXT((listelm), field)->field.le_prev =            	            &LIST_NEXT((elm), field);                           	LIST_NEXT((listelm), field) = (elm);                            	(elm)->field.le_prev = &LIST_NEXT((listelm), field);            } while (0)
LIST_INSERT_BEFORE(listelm, elm, field) do {                    	LIST_CHECK_PREV(listelm, field);                                	(elm)->field.le_prev = (listelm)->field.le_prev;                	LIST_NEXT((elm), field) = (listelm);                            	*(listelm)->field.le_prev = (elm);                              	(listelm)->field.le_prev = &LIST_NEXT((elm), field);            } while (0)
LIST_INSERT_HEAD(head, elm, field) do {                         	LIST_CHECK_HEAD((head), field);                         	if ((LIST_NEXT((elm), field) = LIST_FIRST((head))) != NULL)     	        LIST_FIRST((head))->field.le_prev = &LIST_NEXT((elm), field);	LIST_FIRST((head)) = (elm);                                     	(elm)->field.le_prev = &LIST_FIRST((head));                     } while (0)
LIST_NEXT(elm, field)   ((elm)->field.le_next)
LIST_REMOVE(elm, field) do {                                    	LIST_CHECK_NEXT(elm, field);                            	LIST_CHECK_PREV(elm, field);                            	if (LIST_NEXT((elm), field) != NULL)                            	        LIST_NEXT((elm), field)->field.le_prev =                	            (elm)->field.le_prev;                               	*(elm)->field.le_prev = LIST_NEXT((elm), field);                	TRASHIT((elm)->field.le_next);                                  	TRASHIT((elm)->field.le_prev);                                  } while (0)
LIST_SWAP(head1, head2, type, field)                            __MISMATCH_TAGS_PUSH                                                    __NULLABILITY_COMPLETENESS_PUSH                                         do {                                                                    	struct type *swap_tmp = LIST_FIRST((head1));                    	LIST_FIRST((head1)) = LIST_FIRST((head2));                      	LIST_FIRST((head2)) = swap_tmp;                                 	if ((swap_tmp = LIST_FIRST((head1))) != NULL)                   	        swap_tmp->field.le_prev = &LIST_FIRST((head1));         	if ((swap_tmp = LIST_FIRST((head2))) != NULL)                   	        swap_tmp->field.le_prev = &LIST_FIRST((head2));         } while (0)                                                             __NULLABILITY_COMPLETENESS_POP                                          __MISMATCH_TAGS_POP
TAILQ_HEAD(name, type)                                          __MISMATCH_TAGS_PUSH                                                    __NULLABILITY_COMPLETENESS_PUSH                                         struct name {                                                           	struct type *tqh_first;                      	struct type **tqh_last;          	TRACEBUF                                                        }                                                                       __NULLABILITY_COMPLETENESS_POP                                          __MISMATCH_TAGS_POP
TAILQ_HEAD_INITIALIZER(head) { NULL, &(head).tqh_first }
TAILQ_ENTRY(type) __MISMATCH_TAGS_PUSH                                                    __NULLABILITY_COMPLETENESS_PUSH                                         struct {                                                                	struct type *tqe_next;                        	struct type **tqe_prev;   	TRACEBUF                                                        }                                                                       __NULLABILITY_COMPLETENESS_POP                                          __MISMATCH_TAGS_POP
TAILQ_CHECK_HEAD(head, field) do {                              	if (__improbable(                                               	    TAILQ_FIRST((head)) != NULL &&                              	    TAILQ_FIRST((head))->field.tqe_prev !=                      	    &TAILQ_FIRST((head))))                                      	        ml_fatal_trap_invalid_list_linkage((uintptr_t)(head));  } while (0)
TAILQ_CHECK_NEXT(elm, field) do {                               	if (__improbable(                                               	    TAILQ_NEXT((elm), field) != NULL &&                         	    TAILQ_NEXT((elm), field)->field.tqe_prev !=                 	    &((elm)->field.tqe_next)))                                  	        ml_fatal_trap_invalid_list_linkage((uintptr_t)(elm));   } while(0)
TAILQ_CHECK_PREV(elm, field) do {                               	if (__improbable(*(elm)->field.tqe_prev != (elm)))              	        ml_fatal_trap_invalid_list_linkage((uintptr_t)(elm));   } while(0)
TAILQ_CONCAT(head1, head2, field) do {                          	if (!TAILQ_EMPTY(head2)) {                                      	        *(head1)->tqh_last = (head2)->tqh_first;                	        (head2)->tqh_first->field.tqe_prev = (head1)->tqh_last; 	        (head1)->tqh_last = (head2)->tqh_last;                  	        TAILQ_INIT((head2));                                    	        QMD_TRACE_HEAD(head1);                                  	        QMD_TRACE_HEAD(head2);                                  	}                                                               } while (0)
TAILQ_FOREACH(var, head, field)                                 	for ((var) = TAILQ_FIRST((head));                               	    (var);                                                      	    (var) = TAILQ_NEXT((var), field))
TAILQ_FOREACH_SAFE(var, head, field, tvar)                      	for ((var) = TAILQ_FIRST((head));                               	    (var) && ((tvar) = TAILQ_NEXT((var), field), 1);            	    (var) = (tvar))
TAILQ_FOREACH_REVERSE(var, head, headname, field)               	for ((var) = TAILQ_LAST((head), headname);                      	    (var);                                                      	    (var) = TAILQ_PREV((var), headname, field))
TAILQ_FOREACH_REVERSE_SAFE(var, head, headname, field, tvar)    	for ((var) = TAILQ_LAST((head), headname);                      	    (var) && ((tvar) = TAILQ_PREV((var), headname, field), 1);  	    (var) = (tvar))
TAILQ_INIT_AFTER_BZERO(head) do {                               	(head)->tqh_last = &TAILQ_FIRST((head));                        } while (0)
TAILQ_INIT(head) do {                                           	TAILQ_FIRST((head)) = NULL;                                     	(head)->tqh_last = &TAILQ_FIRST((head));                        	QMD_TRACE_HEAD(head);                                           } while (0)
TAILQ_INSERT_AFTER(head, listelm, elm, field) do {              	TAILQ_CHECK_NEXT(listelm, field);                               	if ((TAILQ_NEXT((elm), field) = TAILQ_NEXT((listelm), field)) != NULL)	        TAILQ_NEXT((elm), field)->field.tqe_prev =              	            &TAILQ_NEXT((elm), field);                          	else {                                                          	        (head)->tqh_last = &TAILQ_NEXT((elm), field);           	        QMD_TRACE_HEAD(head);                                   	}                                                               	TAILQ_NEXT((listelm), field) = (elm);                           	(elm)->field.tqe_prev = &TAILQ_NEXT((listelm), field);          	QMD_TRACE_ELEM(&(elm)->field);                                  	QMD_TRACE_ELEM(&listelm->field);                                } while (0)
TAILQ_INSERT_BEFORE(listelm, elm, field) do {                   	TAILQ_CHECK_PREV(listelm, field);                               	(elm)->field.tqe_prev = (listelm)->field.tqe_prev;              	TAILQ_NEXT((elm), field) = (listelm);                           	*(listelm)->field.tqe_prev = (elm);                             	(listelm)->field.tqe_prev = &TAILQ_NEXT((elm), field);          	QMD_TRACE_ELEM(&(elm)->field);                                  	QMD_TRACE_ELEM(&listelm->field);                                } while (0)
TAILQ_INSERT_HEAD(head, elm, field) do {                        	TAILQ_CHECK_HEAD(head, field);                                  	if ((TAILQ_NEXT((elm), field) = TAILQ_FIRST((head))) != NULL)   	        TAILQ_FIRST((head))->field.tqe_prev =                   	            &TAILQ_NEXT((elm), field);                          	else                                                            	        (head)->tqh_last = &TAILQ_NEXT((elm), field);           	TAILQ_FIRST((head)) = (elm);                                    	(elm)->field.tqe_prev = &TAILQ_FIRST((head));                   	QMD_TRACE_HEAD(head);                                           	QMD_TRACE_ELEM(&(elm)->field);                                  } while (0)
TAILQ_INSERT_TAIL(head, elm, field) do {                        	TAILQ_NEXT((elm), field) = NULL;                                	(elm)->field.tqe_prev = (head)->tqh_last;                       	*(head)->tqh_last = (elm);                                      	(head)->tqh_last = &TAILQ_NEXT((elm), field);                   	QMD_TRACE_HEAD(head);                                           	QMD_TRACE_ELEM(&(elm)->field);                                  } while (0)
TAILQ_LAST(head, headname)                                      __MISMATCH_TAGS_PUSH                                                    __NULLABILITY_COMPLETENESS_PUSH                                         	(*(((struct headname *)((head)->tqh_last))->tqh_last))          __NULLABILITY_COMPLETENESS_POP                                          __MISMATCH_TAGS_POP
TAILQ_NEXT(elm, field) ((elm)->field.tqe_next)
TAILQ_PREV(elm, headname, field)                                __MISMATCH_TAGS_PUSH                                                    __NULLABILITY_COMPLETENESS_PUSH                                         	(*(((struct headname *)((elm)->field.tqe_prev))->tqh_last))     __NULLABILITY_COMPLETENESS_POP                                          __MISMATCH_TAGS_POP
TAILQ_REMOVE(head, elm, field) do {                             	TAILQ_CHECK_NEXT(elm, field);                                   	TAILQ_CHECK_PREV(elm, field);                                   	if ((TAILQ_NEXT((elm), field)) != NULL)                         	        TAILQ_NEXT((elm), field)->field.tqe_prev =              	            (elm)->field.tqe_prev;                              	else {                                                          	        (head)->tqh_last = (elm)->field.tqe_prev;               	        QMD_TRACE_HEAD(head);                                   	}                                                               	*(elm)->field.tqe_prev = TAILQ_NEXT((elm), field);              	TRASHIT((elm)->field.tqe_next);                                 	TRASHIT((elm)->field.tqe_prev);                                 	QMD_TRACE_ELEM(&(elm)->field);                                  } while (0)
TAILQ_SWAP(head1, head2, type, field)                           __MISMATCH_TAGS_PUSH                                                    __NULLABILITY_COMPLETENESS_PUSH                                         do {                                                                    	struct type *swap_first = (head1)->tqh_first;                   	struct type **swap_last = (head1)->tqh_last;                    	(head1)->tqh_first = (head2)->tqh_first;                        	(head1)->tqh_last = (head2)->tqh_last;                          	(head2)->tqh_first = swap_first;                                	(head2)->tqh_last = swap_last;                                  	if ((swap_first = (head1)->tqh_first) != NULL)                  	        swap_first->field.tqe_prev = &(head1)->tqh_first;       	else                                                            	        (head1)->tqh_last = &(head1)->tqh_first;                	if ((swap_first = (head2)->tqh_first) != NULL)                  	        swap_first->field.tqe_prev = &(head2)->tqh_first;       	else                                                            	        (head2)->tqh_last = &(head2)->tqh_first;                } while (0)                                                             __NULLABILITY_COMPLETENESS_POP                                          __MISMATCH_TAGS_POP
CIRCLEQ_HEAD(name, type)                                        __MISMATCH_TAGS_PUSH                                                    __NULLABILITY_COMPLETENESS_PUSH                                         struct name {                                                           	struct type *cqh_first;                      	struct type *cqh_last;                        }                                                                       __NULLABILITY_COMPLETENESS_POP                                          __MISMATCH_TAGS_POP
CIRCLEQ_ENTRY(type) __MISMATCH_TAGS_PUSH                                                    __NULLABILITY_COMPLETENESS_PUSH                                         struct {                                                                	struct type *cqe_next;                        	struct type *cqe_prev;                    }                                                                       __NULLABILITY_COMPLETENESS_POP                                         __MISMATCH_TAGS_POP
CIRCLEQ_CHECK_HEAD(head, field) do {                            	if (__improbable(                                               	    CIRCLEQ_FIRST((head)) != ((void*)(head)) &&                 	    CIRCLEQ_FIRST((head))->field.cqe_prev != ((void*)(head))))  	        ml_fatal_trap_invalid_list_linkage((uintptr_t)(head));  } while(0)
CIRCLEQ_CHECK_NEXT(head, elm, field) do {                       	if (__improbable(                                               	    CIRCLEQ_NEXT((elm), field) != ((void*)(head)) &&            	    CIRCLEQ_NEXT((elm), field)->field.cqe_prev != (elm)))       	        ml_fatal_trap_invalid_list_linkage((uintptr_t)(elm));   } while(0)
CIRCLEQ_CHECK_PREV(head, elm, field) do {                       	if (__improbable(                                               	    CIRCLEQ_PREV((elm), field) != ((void*)(head)) &&            	    CIRCLEQ_PREV((elm), field)->field.cqe_next != (elm)))       	        ml_fatal_trap_invalid_list_linkage((uintptr_t)(elm));   } while(0)
CIRCLEQ_FOREACH(var, head, field)                               	for((var) = (head)->cqh_first;                                  	    (var) != (void *)(head);                                    	    (var) = (var)->field.cqe_next)
CIRCLEQ_INIT(head) do {                                         	(head)->cqh_first = (void *)(head);                             	(head)->cqh_last = (void *)(head);                              } while (0)
CIRCLEQ_INSERT_AFTER(head, listelm, elm, field) do {            	CIRCLEQ_CHECK_NEXT(head, listelm, field);                       	(elm)->field.cqe_next = (listelm)->field.cqe_next;              	(elm)->field.cqe_prev = (listelm);                              	if ((listelm)->field.cqe_next == (void *)(head))                	        (head)->cqh_last = (elm);                               	else                                                            	        (listelm)->field.cqe_next->field.cqe_prev = (elm);      	(listelm)->field.cqe_next = (elm);                              } while (0)
CIRCLEQ_INSERT_BEFORE(head, listelm, elm, field) do {           	CIRCLEQ_CHECK_PREV(head, listelm, field);                       	(elm)->field.cqe_next = (listelm);                              	(elm)->field.cqe_prev = (listelm)->field.cqe_prev;              	if ((listelm)->field.cqe_prev == (void *)(head))                	        (head)->cqh_first = (elm);                              	else                                                            	        (listelm)->field.cqe_prev->field.cqe_next = (elm);      	(listelm)->field.cqe_prev = (elm);                              } while (0)
CIRCLEQ_INSERT_HEAD(head, elm, field) do {                      	CIRCLEQ_CHECK_HEAD(head, field);                                	(elm)->field.cqe_next = (head)->cqh_first;                      	(elm)->field.cqe_prev = (void *)(head);                         	if ((head)->cqh_last == (void *)(head))                         	        (head)->cqh_last = (elm);                               	else                                                            	        (head)->cqh_first->field.cqe_prev = (elm);              	(head)->cqh_first = (elm);                                      } while (0)
CIRCLEQ_INSERT_TAIL(head, elm, field) do {                      	(elm)->field.cqe_next = (void *)(head);                         	(elm)->field.cqe_prev = (head)->cqh_last;                       	if ((head)->cqh_first == (void *)(head))                        	        (head)->cqh_first = (elm);                              	else                                                            	        (head)->cqh_last->field.cqe_next = (elm);               	(head)->cqh_last = (elm);                                       } while (0)
CIRCLEQ_NEXT(elm, field) ((elm)->field.cqe_next)
CIRCLEQ_PREV(elm, field) ((elm)->field.cqe_prev)
CIRCLEQ_REMOVE(head, elm, field) do {                           	CIRCLEQ_CHECK_NEXT(head, elm, field);                           	CIRCLEQ_CHECK_PREV(head, elm, field);                           	if ((elm)->field.cqe_next == (void *)(head))                    	        (head)->cqh_last = (elm)->field.cqe_prev;               	else                                                            	        (elm)->field.cqe_next->field.cqe_prev =                 	            (elm)->field.cqe_prev;                              	if ((elm)->field.cqe_prev == (void *)(head))                    	        (head)->cqh_first = (elm)->field.cqe_next;              	else                                                            	        (elm)->field.cqe_prev->field.cqe_next =                 	            (elm)->field.cqe_next;                              } while (0)
_SYS_QUOTA_H None
__SYS_RANDOM_H__ None
_REASON_H_ None
LAUNCHD_PANIC_REASON_STRING_MAXLEN "800"
PX_FLAGS_NONE 0
OS_REASON_INVALID 0
OS_REASON_JETSAM 1
OS_REASON_SIGNAL 2
OS_REASON_CODESIGNING 3
OS_REASON_HANGTRACER 4
OS_REASON_TEST 5
OS_REASON_DYLD 6
OS_REASON_LIBXPC 7
OS_REASON_OBJC 8
OS_REASON_EXEC 9
OS_REASON_SPRINGBOARD 10
OS_REASON_TCC 11
OS_REASON_REPORTCRASH 12
OS_REASON_COREANIMATION 13
OS_REASON_AGGREGATED 14
OS_REASON_RUNNINGBOARD 15
OS_REASON_ASSERTIOND OS_REASON_RUNNINGBOARD
OS_REASON_SKYWALK 16
OS_REASON_SETTINGS 17
OS_REASON_LIBSYSTEM 18
OS_REASON_FOUNDATION 19
OS_REASON_WATCHDOG 20
OS_REASON_METAL 21
OS_REASON_WATCHKIT 22
OS_REASON_GUARD 23
OS_REASON_ANALYTICS 24
OS_REASON_SANDBOX 25
OS_REASON_SECURITY 26
OS_REASON_ENDPOINTSECURITY 27
OS_REASON_PAC_EXCEPTION 28
OS_REASON_BLUETOOTH_CHIP 29
OS_REASON_PORT_SPACE 30
OS_REASON_WEBKIT 31
OS_REASON_BACKLIGHTSERVICES 32
OS_REASON_MEDIA 33
OS_REASON_ROSETTA 34
OS_REASON_LIBIGNITION 35
OS_REASON_BOOTMOUNT 36
OS_REASON_REALITYKIT 38
OS_REASON_AUDIO 39
OS_REASON_WAKEBOARD 40
OS_REASON_CORERC 41
OS_REASON_SELF_RESTRICT 42
OS_REASON_ARKIT 43
OS_REASON_MAX_VALID_NAMESPACE OS_REASON_ARKIT
OS_REASON_BUFFER_MAX_SIZE 5120
OS_REASON_FLAG_NO_CRASH_REPORT 0x1
OS_REASON_FLAG_GENERATE_CRASH_REPORT 0x2
OS_REASON_FLAG_FROM_USERSPACE 0x4
OS_REASON_FLAG_FAILED_DATA_COPYIN 0x8
OS_REASON_FLAG_PAYLOAD_TRUNCATED 0x10
OS_REASON_FLAG_BAD_PARAMS 0x20
OS_REASON_FLAG_CONSISTENT_FAILURE 0x40
OS_REASON_FLAG_ONE_TIME_FAILURE 0x80
OS_REASON_FLAG_NO_CRASHED_TID 0x100
OS_REASON_FLAG_ABORT 0x200
OS_REASON_FLAG_SHAREDREGION_FAULT 0x400
OS_REASON_FLAG_CAPTURE_LOGS 0x800
OS_REASON_FLAG_SECURITY_SENSITIVE 0x1000
ENCODE_OSR_NAMESPACE_TO_MACH_EXCEPTION_CODE(code, osr_namespace) 	(code) = (code) | (((osr_namespace) & ((uint64_t)UINT32_MAX)) << 32)
ENCODE_OSR_CODE_TO_MACH_EXCEPTION_CODE(code, osr_code) 	(code) = (code) | ((osr_code) & ((uint64_t)UINT32_MAX))
CODESIGNING_EXIT_REASON_TASKGATED_INVALID_SIG 1
CODESIGNING_EXIT_REASON_INVALID_PAGE 2
CODESIGNING_EXIT_REASON_TASK_ACCESS_PORT 3
CODESIGNING_EXIT_REASON_LAUNCH_CONSTRAINT_VIOLATION 4
EXEC_EXIT_REASON_BAD_MACHO 1
EXEC_EXIT_REASON_SUGID_FAILURE 2
EXEC_EXIT_REASON_ACTV_THREADSTATE 3
EXEC_EXIT_REASON_STACK_ALLOC 4
EXEC_EXIT_REASON_APPLE_STRING_INIT 5
EXEC_EXIT_REASON_COPYOUT_STRINGS 6
EXEC_EXIT_REASON_COPYOUT_DYNLINKER 7
EXEC_EXIT_REASON_SECURITY_POLICY 8
EXEC_EXIT_REASON_TASKGATED_OTHER 9
EXEC_EXIT_REASON_FAIRPLAY_DECRYPT 10
EXEC_EXIT_REASON_DECRYPT 11
EXEC_EXIT_REASON_UPX 12
EXEC_EXIT_REASON_NO32EXEC 13
EXEC_EXIT_REASON_WRONG_PLATFORM 14
EXEC_EXIT_REASON_MAIN_FD_ALLOC 15
EXEC_EXIT_REASON_COPYOUT_ROSETTA 16
EXEC_EXIT_REASON_SET_DYLD_INFO 17
EXEC_EXIT_REASON_MACHINE_THREAD 18
EXEC_EXIT_REASON_BAD_PSATTR 19
EXEC_EXIT_REASON_MAP_EXEC_FAILURE 21
GUARD_REASON_VNODE 1
GUARD_REASON_VIRT_MEMORY 2
GUARD_REASON_MACH_PORT 3
GUARD_REASON_EXCLAVES 4
GUARD_REASON_JIT 5
_SYS_REBOOT_H_ None
PROC_SHUTDOWN_LOG "/var/log/kernel-shutdown.log"
_SYS_RESOURCE_H_ None
PRIO_PROCESS 0
PRIO_PGRP 1
PRIO_USER 2
PRIO_DARWIN_THREAD 3
PRIO_DARWIN_PROCESS 4
PRIO_MIN -20
PRIO_MAX 20
PRIO_DARWIN_BG 0x1000
PRIO_DARWIN_NONUI 0x1001
RUSAGE_SELF 0
RUSAGE_CHILDREN -1
RUSAGE_INFO_V0 0
RUSAGE_INFO_V1 1
RUSAGE_INFO_V2 2
RUSAGE_INFO_V3 3
RUSAGE_INFO_V4 4
RUSAGE_INFO_V5 5
RUSAGE_INFO_V6 6
RUSAGE_INFO_CURRENT RUSAGE_INFO_V6
RU_PROC_RUNS_RESLIDE 0x00000001
RLIM_SAVED_MAX RLIM_INFINITY
RLIM_SAVED_CUR RLIM_INFINITY
RLIMIT_CPU 0
RLIMIT_FSIZE 1
RLIMIT_DATA 2
RLIMIT_STACK 3
RLIMIT_CORE 4
RLIMIT_AS 5
RLIMIT_RSS RLIMIT_AS
RLIMIT_MEMLOCK 6
RLIMIT_NPROC 7
RLIMIT_NOFILE 8
RLIM_NLIMITS 9
_RLIMIT_POSIX_FLAG 0x1000
RLIMIT_WAKEUPS_MONITOR 0x1
RLIMIT_CPU_USAGE_MONITOR 0x2
RLIMIT_THREAD_CPULIMITS 0x3
RLIMIT_FOOTPRINT_INTERVAL 0x4
WAKEMON_ENABLE 0x01
WAKEMON_DISABLE 0x02
WAKEMON_GET_PARAMS 0x04
WAKEMON_SET_DEFAULTS 0x08
WAKEMON_MAKE_FATAL 0x10
CPUMON_MAKE_FATAL 0x1000
FOOTPRINT_INTERVAL_RESET 0x1
IOPOL_TYPE_DISK 0
IOPOL_TYPE_VFS_ATIME_UPDATES 2
IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES 3
IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME 4
IOPOL_TYPE_VFS_TRIGGER_RESOLVE 5
IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION 6
IOPOL_TYPE_VFS_IGNORE_PERMISSIONS 7
IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE 8
IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES 9
IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY 10
IOPOL_SCOPE_PROCESS 0
IOPOL_SCOPE_THREAD 1
IOPOL_SCOPE_DARWIN_BG 2
IOPOL_DEFAULT 0
IOPOL_IMPORTANT 1
IOPOL_PASSIVE 2
IOPOL_THROTTLE 3
IOPOL_UTILITY 4
IOPOL_STANDARD 5
IOPOL_APPLICATION IOPOL_STANDARD
IOPOL_NORMAL IOPOL_IMPORTANT
IOPOL_ATIME_UPDATES_DEFAULT 0
IOPOL_ATIME_UPDATES_OFF 1
IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT 0
IOPOL_MATERIALIZE_DATALESS_FILES_OFF 1
IOPOL_MATERIALIZE_DATALESS_FILES_ON 2
IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT 0
IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME 1
IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT 0
IOPOL_VFS_TRIGGER_RESOLVE_OFF 1
IOPOL_VFS_CONTENT_PROTECTION_DEFAULT 0
IOPOL_VFS_CONTENT_PROTECTION_IGNORE 1
IOPOL_VFS_IGNORE_PERMISSIONS_OFF 0
IOPOL_VFS_IGNORE_PERMISSIONS_ON 1
IOPOL_VFS_SKIP_MTIME_UPDATE_OFF 0
IOPOL_VFS_SKIP_MTIME_UPDATE_ON 1
IOPOL_VFS_SKIP_MTIME_UPDATE_IGNORE 2
IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF 0
IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON 1
IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT 0
IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON 1
IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT 0
IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON 1
_SYS_RESOURCEVAR_H_ None
_SYS_RESOURCE_PRIVATE_H_ None
PRIO_DARWIN_GPU 5
PRIO_DARWIN_GPU_ALLOW 0x1
PRIO_DARWIN_GPU_DENY 0x2
PRIO_DARWIN_ROLE 6
PRIO_DARWIN_ROLE_DEFAULT 0x0
PRIO_DARWIN_ROLE_UI_FOCAL 0x1
PRIO_DARWIN_ROLE_UI 0x2
PRIO_DARWIN_ROLE_NON_UI 0x3
PRIO_DARWIN_ROLE_UI_NON_FOCAL 0x4
PRIO_DARWIN_ROLE_TAL_LAUNCH 0x5
PRIO_DARWIN_ROLE_DARWIN_BG 0x6
PRIO_DARWIN_GAME_MODE 7
PRIO_DARWIN_CARPLAY_MODE 8
PRIO_DARWIN_GAME_MODE_OFF 0x0
PRIO_DARWIN_GAME_MODE_ON 0x1
PRIO_DARWIN_CARPLAY_MODE_OFF 0x0
PRIO_DARWIN_CARPLAY_MODE_ON 0x1
IOMON_ENABLE 0x01
IOMON_DISABLE 0x02
IOPOL_TYPE_VFS_HFS_CASE_SENSITIVITY 1
IOPOL_TYPE_VFS_ALTLINK 11
IOPOL_TYPE_VFS_NOCACHE_WRITE_FS_BLKSIZE 12
IOPOL_TYPE_VFS_SUPPORT_LONG_PATHS 13
IOPOL_VFS_HFS_CASE_SENSITIVITY_DEFAULT 0
IOPOL_VFS_HFS_CASE_SENSITIVITY_FORCE_CASE_SENSITIVE 1
IOPOL_VFS_ALTLINK_DISABLED 0
IOPOL_VFS_ALTLINK_ENABLED 1
IOPOL_VFS_SUPPORT_LONG_PATHS_DEFAULT 0
IOPOL_VFS_SUPPORT_LONG_PATHS_ON 1
IOPOL_CMD_GET 0x00000001
IOPOL_CMD_SET 0x00000002
_SYS_SBUF_H_ None
SBUF_FIXEDLEN 0x00000000
SBUF_AUTOEXTEND 0x00000001
SBUF_USRFLAGMSK 0x0000ffff
SBUF_DYNAMIC 0x00010000
SBUF_FINISHED 0x00020000
SBUF_OVERFLOWED 0x00040000
SBUF_DYNSTRUCT 0x00080000
_SYS_SDT_H None
_SDT_IMPL_H None
_SYS_SELECT_H_ None
SI_COLL 0x0001
SI_RECORDED 0x0004
SI_INITED 0x0008
SI_CLEAR 0x0010
SI_KNPOSTING 0x0020
SI_SELSPEC 0x0040
_SYS_SEM_H_ None
GETNCNT 3
GETPID 4
GETVAL 5
GETALL 6
GETZCNT 7
SETVAL 8
SETALL 9
SEM_UNDO 010000
_SYS_SEMAPHORE_H_ None
SEM_VALUE_MAX 32767
_SYS_SEM__INTERNALH_ None
SEMVMX 32767
SEMAEM 16384
SEMMNI SEMMNS
SEMUME 10
SEMMNU SEMMNS
SEMMAP 30
SEMMSL SEMMNS
SEMOPM 5
SEM_ALLOC 01000
SEM_DEST 02000
SEMMNI_INC 32
SEMMNS_INC 64
SEMMNU_INC 32
SEMUSZ sizeof(struct sem_undo)
_SYS_SFI_H_ None
SFI_PROCESS_SET_MANAGED 0x00000001
SFI_PROCESS_SET_UNMANAGED 0x00000002
SFI_PROCESS_SET_MANAGED_MASK 0x00000003
SFI_CTL_OPERATION_SFI_SET_WINDOW 0x00000001
SFI_CTL_OPERATION_SFI_GET_WINDOW 0x00000002
SFI_CTL_OPERATION_SET_CLASS_OFFTIME 0x00000003
SFI_CTL_OPERATION_GET_CLASS_OFFTIME 0x00000004
SFI_PIDCTL_OPERATION_PID_SET_FLAGS 0x00000001
SFI_PIDCTL_OPERATION_PID_GET_FLAGS 0x00000002
_SYS_SHM_H_ None
SHM_RDONLY 010000
SHM_RND 020000
_SYS_SHM_INTERNALH_ None
_SYS_SIGNAL_H_ None
__DARWIN_NSIG 32
SIGHUP 1
SIGINT 2
SIGQUIT 3
SIGILL 4
SIGTRAP 5
SIGABRT 6
SIGFPE 8
SIGKILL 9
SIGBUS 10
SIGSEGV 11
SIGSYS 12
SIGPIPE 13
SIGALRM 14
SIGTERM 15
SIGURG 16
SIGSTOP 17
SIGTSTP 18
SIGCONT 19
SIGCHLD 20
SIGTTIN 21
SIGTTOU 22
SIGXCPU 24
SIGXFSZ 25
SIGVTALRM 26
SIGPROF 27
SIGUSR1 30
SIGUSR2 31
SIGEV_NONE 0
SIGEV_SIGNAL 1
SIGEV_THREAD 3
ILL_ILLOPC 1
ILL_ILLTRP 2
ILL_PRVOPC 3
ILL_ILLOPN 4
ILL_ILLADR 5
ILL_PRVREG 6
ILL_COPROC 7
ILL_BADSTK 8
FPE_FLTDIV 1
FPE_FLTOVF 2
FPE_FLTUND 3
FPE_FLTRES 4
FPE_FLTINV 5
FPE_FLTSUB 6
FPE_INTDIV 7
FPE_INTOVF 8
SEGV_MAPERR 1
SEGV_ACCERR 2
BUS_ADRALN 1
BUS_ADRERR 2
BUS_OBJERR 3
TRAP_BRKPT 1
TRAP_TRACE 2
CLD_EXITED 1
CLD_KILLED 2
CLD_DUMPED 3
CLD_TRAPPED 4
CLD_STOPPED 5
CLD_CONTINUED 6
POLL_IN 1
POLL_OUT 2
POLL_MSG 3
POLL_ERR 4
POLL_PRI 5
POLL_HUP 6
sa_handler __sigaction_u.__sa_handler
sa_sigaction __sigaction_u.__sa_sigaction
SA_ONSTACK 0x0001
SA_RESTART 0x0002
SA_DISABLE 0x0004
SA_RESETHAND 0x0004
SA_NOCLDSTOP 0x0008
SA_NODEFER 0x0010
SA_NOCLDWAIT 0x0020
SA_SIGINFO 0x0040
SA_VALIDATE_SIGRETURN_FROM_SIGTRAMP 0x0400
SIG_BLOCK 1
SIG_UNBLOCK 2
SIG_SETMASK 3
SI_USER 0x10001
SI_QUEUE 0x10002
SI_TIMER 0x10003
SI_ASYNCIO 0x10004
SI_MESGQ 0x10005
SS_ONSTACK 0x0001
SS_DISABLE 0x0004
MINSIGSTKSZ 32768
SIGSTKSZ 131072
_SYS_SIGNALVAR_H_ None
SAS_OLDMASK 0x01
SAS_ALTSTACK 0x02
KERN_SIG_CATCH CAST_USER_ADDR_T(2)
KERN_SIG_HOLD CAST_USER_ADDR_T(3)
KERN_SIG_WAIT CAST_USER_ADDR_T(4)
PS_SIGRETURN_VALIDATION_DEFAULT 0x0u
PS_SIGRETURN_VALIDATION_ENABLED 0x1u
PS_SIGRETURN_VALIDATION_DISABLED 0x2u
SIGACTION(p, sig)       ({ p->p_sigacts.ps_sigact[(sig)]; })
SIGTRAMP(p, sig)        ({ p->p_sigacts.ps_trampact[(sig)]; })
SHOULDissignal(p, uthreadp) 	 (((uthreadp)->uu_siglist)      	  & ~((((uthreadp)->uu_sigmask) 	       | (((p)->p_lflag & P_LTRACED) ? 0 : (p)->p_sigignore)) 	      & ~sigcantmask))
CHECK_SIGNALS(p, thread, uthreadp)      	(!thread_should_halt(thread)    	 && (SHOULDissignal(p,uthreadp)))
SA_KILL 0x01
SA_CORE 0x02
SA_STOP 0x04
SA_TTYSTOP 0x08
SA_IGNORE 0x10
SA_CONT 0x20
SA_CANTMASK 0x40
COREDUMP_IGNORE_ULIMIT 0x0001
COREDUMP_FULLFSYNC 0x0002
_SYS_SNAPSHOT_H_ None
SNAPSHOT_MNT_NOSUID 0x00000008
SNAPSHOT_MNT_NODEV 0x00000010
SNAPSHOT_MNT_DONTBROWSE 0x00100000
SNAPSHOT_MNT_IGNORE_OWNERSHIP 0x00200000
SNAPSHOT_MNT_NOFOLLOW 0x08000000
SNAPSHOT_OP_CREATE 0x01
SNAPSHOT_OP_DELETE 0x02
SNAPSHOT_OP_RENAME 0x03
SNAPSHOT_OP_MOUNT 0x04
SNAPSHOT_OP_REVERT 0x05
SNAPSHOT_OP_ROOT 0x06
_SYS_SOCKET_H_ None
SOCK_STREAM 1
SOCK_DGRAM 2
SOCK_RAW 3
SOCK_SEQPACKET 5
SO_DEBUG 0x0001
SO_ACCEPTCONN 0x0002
SO_REUSEADDR 0x0004
SO_KEEPALIVE 0x0008
SO_DONTROUTE 0x0010
SO_BROADCAST 0x0020
SO_OOBINLINE 0x0100
SO_SNDBUF 0x1001
SO_RCVBUF 0x1002
SO_SNDLOWAT 0x1003
SO_RCVLOWAT 0x1004
SO_SNDTIMEO 0x1005
SO_RCVTIMEO 0x1006
SO_ERROR 0x1007
SO_TYPE 0x1008
SOL_SOCKET 0xffff
AF_UNSPEC 0
AF_UNIX 1
AF_INET 2
AF_INET6 30
_SS_MAXSIZE 128
PF_UNSPEC AF_UNSPEC
PF_LOCAL AF_LOCAL
PF_UNIX PF_LOCAL
PF_INET AF_INET
PF_IMPLINK AF_IMPLINK
PF_PUP AF_PUP
PF_CHAOS AF_CHAOS
PF_NS AF_NS
PF_ISO AF_ISO
PF_OSI AF_ISO
PF_ECMA AF_ECMA
PF_DATAKIT AF_DATAKIT
PF_CCITT AF_CCITT
PF_SNA AF_SNA
PF_DECnet AF_DECnet
PF_DLI AF_DLI
PF_LAT AF_LAT
PF_HYLINK AF_HYLINK
PF_APPLETALK AF_APPLETALK
PF_ROUTE AF_ROUTE
PF_LINK AF_LINK
PF_XTP pseudo_AF_XTP
PF_COIP AF_COIP
PF_CNT AF_CNT
PF_SIP AF_SIP
PF_IPX AF_IPX
PF_RTIP pseudo_AF_RTIP
PF_PIP pseudo_AF_PIP
PF_NDRV AF_NDRV
PF_ISDN AF_ISDN
PF_KEY pseudo_AF_KEY
PF_INET6 AF_INET6
PF_NATM AF_NATM
PF_SYSTEM AF_SYSTEM
PF_NETBIOS AF_NETBIOS
PF_PPP AF_PPP
PF_UTUN AF_UTUN
PF_VSOCK AF_VSOCK
PF_MAX AF_MAX
SOMAXCONN 128
MSG_OOB 0x1
MSG_PEEK 0x2
MSG_DONTROUTE 0x4
MSG_EOR 0x8
MSG_TRUNC 0x10
MSG_CTRUNC 0x20
MSG_WAITALL 0x40
CMSG_NXTHDR(mhdr, cmsg)                                         	((char *)(cmsg) == (char *)0L ? CMSG_FIRSTHDR(mhdr) :           	    ((((unsigned char *)(cmsg) +                                	    __DARWIN_ALIGN32((__uint32_t)(cmsg)->cmsg_len) +            	    __DARWIN_ALIGN32(sizeof(struct cmsghdr))) >                 	    ((unsigned char *)(mhdr)->msg_control +                     	    (mhdr)->msg_controllen)) ?                                  	        (struct cmsghdr *)0L  :                       	        (struct cmsghdr *)(void *)((unsigned char *)(cmsg) +    	            __DARWIN_ALIGN32((__uint32_t)(cmsg)->cmsg_len))))
SCM_RIGHTS 0x01
SHUT_RD 0
SHUT_WR 1
SHUT_RDWR 2
_SYS_SOCKETVAR_H_ None
SOCKET_CACHE_ON None
SO_CACHE_FLUSH_INTERVAL 1
SO_CACHE_MAX_FREE_BATCH 50
MAX_CACHED_SOCKETS 512
TEMPDEBUG 0
SO_TC_STATS_MAX 4
SO_STATS_DATA 0
SO_STATS_SBNOSPACE 1
SB_MSIZE_ADJ 256
SB_LOCK 0x1
SB_NOINTR 0x2
SB_RECV 0x4
SB_SEL 0x8
SB_ASYNC 0x10
SB_UPCALL 0x20
SB_KNOTE 0x40
SB_DROP 0x80
SB_UNIX 0x100
SB_USRSIZE 0x200
SB_AUTOSIZE 0x400
SB_TRIM 0x800
SB_NOCOMPRESS 0x1000
SB_SNDBYTE_CNT 0x2000
SB_UPCALL_LOCK 0x4000
SB_LIMITED 0x8000
SB_KCTL 0x10000
SB_SENDHEAD 0x20000
SOF_NOSIGPIPE 0x00000001
SOF_NOADDRAVAIL 0x00000002
SOF_PCBCLEARING 0x00000004
SOF_DEFUNCT 0x00000008
SOF_CLOSEWAIT 0x00000010
SOF_REUSESHAREUID 0x00000040
SOF_MULTIPAGES 0x00000080
SOF_ABORTED 0x00000100
SOF_OVERFLOW 0x00000200
SOF_NOTIFYCONFLICT 0x00000400
SOF_UPCALLCLOSEWAIT 0x00000800
SOF_BINDRANDOMPORT 0x00001000
SOF_NPX_SETOPTSHUT 0x00002000
SOF_RECV_TRAFFIC_CLASS 0x00004000
SOF_NODEFUNCT 0x00008000
SOF_PRIVILEGED_TRAFFIC_CLASS 0x00010000
SOF_SUSPENDED 0x00020000
SOF_INCOMP_INPROGRESS 0x00040000
SOF_NOTSENT_LOWAT 0x00080000
SOF_KNOTE 0x00100000
SOF_MARK_WAKE_PKT 0x00200000
SOF_RECV_WAKE_PKT 0x00400000
SOF_FLOW_DIVERT 0x00800000
SOF_MP_SUBFLOW 0x01000000
SOF_MP_SEC_SUBFLOW 0x04000000
SOF_MP_TRYFAILOVER 0x08000000
SOF_DELEGATED 0x10000000
SOF_CONTENT_FILTER 0x20000000
SOF1_POST_FALLBACK_SYNC 0x00000001
SOF1_AWDL_PRIVILEGED 0x00000002
SOF1_IF_2KCL 0x00000004
SOF1_DEFUNCTINPROG 0x00000008
SOF1_DATA_IDEMPOTENT 0x00000010
SOF1_PRECONNECT_DATA 0x00000020
SOF1_EXTEND_BK_IDLE_WANTED 0x00000040
SOF1_EXTEND_BK_IDLE_INPROG 0x00000080
SOF1_CACHED_IN_SOCK_LAYER 0x00000100
SOF1_TFO_REWIND 0x00000200
SOF1_CELLFALLBACK 0x00000400
SOF1_QOSMARKING_ALLOWED 0x00000800
SOF1_TC_NET_SERV_TYPE 0x00001000
SOF1_TRAFFIC_MGT_SO_BACKGROUND 0x00002000
SOF1_TRAFFIC_MGT_TCP_RECVBG 0x00004000
SOF1_QOSMARKING_POLICY_OVERRIDE 0x00008000
SOF1_DATA_AUTHENTICATED 0x00010000
SOF1_ACCEPT_LIST_HELD 0x00020000
SOF1_CONTENT_FILTER_SKIP 0x00040000
SOF1_HAS_NECP_CLIENT_UUID 0x00080000
SOF1_IN_KERNEL_SOCKET 0x00100000
SOF1_CONNECT_COUNTED 0x00200000
SOF1_DNS_COUNTED 0x00400000
SOF1_MPKL_SEND_INFO 0x00800000
SOF1_INBOUND 0x01000000
SOF1_WANT_KEV_SOCK_CLOSED 0x02000000
SOF1_FLOW_DIVERT_SKIP 0x04000000
SOF1_KNOWN_TRACKER 0x08000000
SOF1_TRACKER_NON_APP_INITIATED 0x10000000
SOF1_APPROVED_APP_DOMAIN 0x20000000
SOF1_DOMAIN_INFO_SILENT 0x40000000
SO_LCKDBG_MAX 4
SO_FALLBACK_MODE_NONE 0
SO_FALLBACK_MODE_FAILOVER 1
SO_FALLBACK_MODE_SLOW 2
SO_FALLBACK_MODE_FAST 3
SO_FALLBACK_MODE_PREFER 4
M_NXT_CMSGHDR(m, cmsg)                                          	((char *)(cmsg) == (char *)0L ? M_FIRST_CMSGHDR(m) :            	_MIN_NXT_CMSGHDR_PTR(cmsg) > ((char *)(m)->m_data) + (m)->m_len ||  	_MIN_NXT_CMSGHDR_PTR(cmsg) < (char *)(m)->m_data ?              	(struct cmsghdr * __header_bidi_indexable)0L  :              	(struct cmsghdr *)(void *)((unsigned char *)(cmsg) +            	__DARWIN_ALIGN32((__uint32_t)(cmsg)->cmsg_len)))
SS_NOFDREF 0x0001
SS_ISCONNECTED 0x0002
SS_ISCONNECTING 0x0004
SS_ISDISCONNECTING 0x0008
SS_CANTSENDMORE 0x0010
SS_CANTRCVMORE 0x0020
SS_RCVATMARK 0x0040
SS_PRIV 0x0080
SS_NBIO 0x0100
SS_ASYNC 0x0200
SS_ISCONFIRMING 0x0400
SS_INCOMP 0x0800
SS_COMP 0x1000
SS_ISDISCONNECTED 0x2000
SS_DRAINING 0x4000
SS_DEFUNCT 0x8000
_XSOCKET_PTR(x) u_int32_t
SOCKEV_CONNECTED 0x00000001
SOCKEV_DISCONNECTED 0x00000002
XSO_SOCKET 0x001
XSO_RCVBUF 0x002
XSO_SNDBUF 0x004
XSO_STATS 0x008
XSO_INPCB 0x010
XSO_TCPCB 0x020
XSO_KCREG 0x040
XSO_KCB 0x080
XSO_EVT 0x100
XSO_UNPCB 0x200
XSOFF_SO_FILT 0x01
XSOFF_FLOW_DB 0x02
XSOFF_CFIL 0x04
XSOFF_FLOW_DIV 0x08
EXT_NULL 0x0
SO_FILT_HINT_LOCKED 0x00000001
SO_FILT_HINT_CONNRESET 0x00000002
SO_FILT_HINT_CANTRCVMORE 0x00000004
SO_FILT_HINT_CANTSENDMORE 0x00000008
SO_FILT_HINT_TIMEOUT 0x00000010
SO_FILT_HINT_NOSRCADDR 0x00000020
SO_FILT_HINT_IFDENIED 0x00000040
SO_FILT_HINT_SUSPEND 0x00000080
SO_FILT_HINT_RESUME 0x00000100
SO_FILT_HINT_KEEPALIVE 0x00000200
SO_FILT_HINT_ADAPTIVE_WTIMO 0x00000400
SO_FILT_HINT_ADAPTIVE_RTIMO 0x00000800
SO_FILT_HINT_CONNECTED 0x00001000
SO_FILT_HINT_DISCONNECTED 0x00002000
SO_FILT_HINT_CONNINFO_UPDATED 0x00004000
SO_FILT_HINT_MPFAILOVER 0x00008000
SO_FILT_HINT_MPSTATUS 0x00010000
SO_FILT_HINT_MUSTRST 0x00020000
SO_FILT_HINT_MPCANTRCVMORE 0x00040000
SO_FILT_HINT_NOTIFY_ACK 0x00080000
SO_FILT_HINT_MP_SUB_ERROR 0x00100000
SO_FILT_HINT_WAKE_PKT 0x00200000
SO_FILT_HINT_BITS "\020\1LOCKED\2CONNRESET\3CANTRCVMORE\4CANTSENDMORE\5TIMEOUT"   	"\6NOSRCADDR\7IFDENIED\10SUSPEND\11RESUME\12KEEPALIVE\13AWTIMO" 	"\14ARTIMO\15CONNECTED\16DISCONNECTED\17CONNINFO_UPDATED"       	"\20MPFAILOVER\21MPSTATUS\22MUSTRST\23MPCANTRCVMORE\24NOTIFYACK"	"\25MPSUBERROR\26WAKEPKT"
SBLASTRECORDCHK(sb, s)                                          	if (socket_debug) sblastrecordchk(sb, s);
SBLASTMBUFCHK(sb, s)                                            	if (socket_debug) sblastmbufchk(sb, s);
SB_EMPTY_FIXUP(sb) {                                            	if ((sb)->sb_mb == NULL) {                                      	        (sb)->sb_mbtail = NULL;                                 	        (sb)->sb_lastrecord = NULL;                             	}                                                               }
SB_MB_CHECK(sb) do {                                            	if (((sb)->sb_mb != NULL &&                                     	    (sb)->sb_cc == 0) ||                                        	    ((sb)->sb_mb == NULL && (sb)->sb_cc > 0))                   	        panic("corrupt so_rcv: sb_mb %p sb_cc %d\n",            	            (sb)->sb_mb, (sb)->sb_cc);                          } while (0)
SODEFUNCTLOG(fmt, ...)  do {            	if (sodefunctlog)                       	        printf(fmt, __VA_ARGS__);       } while (0)
SOTHROTTLELOG(fmt, ...) do {            	if (sothrottlelog)                      	        printf(fmt, __VA_ARGS__);       } while (0)
SOTCDB_RESERVED 0x01
SOTCDB_NO_MTC 0x02
SOTCDB_NO_SENDTCPBG 0x04
SOTCDB_NO_LCLTST 0x08
SOTCDB_NO_DSCPTST 0x10
SOTCDB_NO_RECVTCPBG 0x20
SOTCDB_NO_PRIVILEGED 0x40
SOCK_CHECK_DOM(so, dom)         (SOCK_DOM(so) == (dom))
SOCK_CHECK_TYPE(so, type)       (SOCK_TYPE(so) == (type))
SOCK_CHECK_PROTO(so, proto)     (SOCK_PROTO(so) == (proto))
SOCK_MSG_SA 0x01
SOCK_MSG_CONTROL 0x02
SOCK_MSG_DATA 0x04
free_sockaddr(sa) do {                                  	__typed_allocators_ignore_push                          	kheap_free_addr(KHEAP_SONAME, (sa));                    	__typed_allocators_ignore_pop                           } while (0)
SBL_WAIT 0x00000001
SBL_NOINTR 0x00000002
SBL_IGNDEFUNCT 0x00000004
SOCF_MPTCP 0x1
TRACKER_DOMAIN_MAX 253
TRACKER_DOMAIN_SHORT_MAX 63
PKT_SCF_IPV6 0x00000001
PKT_SCF_TCP_ACK 0x00000002
PKT_SCF_TCP_SYN 0x00000004
SO_TRACKER_ATTRIBUTE_FLAGS_APP_APPROVED 0x00000001
SO_TRACKER_ATTRIBUTE_FLAGS_TRACKER 0x00000002
SO_TRACKER_ATTRIBUTE_FLAGS_DOMAIN_SHORT 0x00000004
_SYS_SOCKET_PRIVATE_H_ None
PF_AFP AF_AFP
PF_MULTIPATH AF_MULTIPATH
CTL_NET_NAMES { 	{ 0, 0 }, 	{ "local", CTLTYPE_NODE }, 	{ "inet", CTLTYPE_NODE }, 	{ "implink", CTLTYPE_NODE }, 	{ "pup", CTLTYPE_NODE }, 	{ "chaos", CTLTYPE_NODE }, 	{ "xerox_ns", CTLTYPE_NODE }, 	{ "iso", CTLTYPE_NODE }, 	{ "emca", CTLTYPE_NODE }, 	{ "datakit", CTLTYPE_NODE }, 	{ "ccitt", CTLTYPE_NODE }, 	{ "ibm_sna", CTLTYPE_NODE }, 	{ "decnet", CTLTYPE_NODE }, 	{ "dec_dli", CTLTYPE_NODE }, 	{ "lat", CTLTYPE_NODE }, 	{ "hylink", CTLTYPE_NODE }, 	{ "appletalk", CTLTYPE_NODE }, 	{ "route", CTLTYPE_NODE }, 	{ "link_layer", CTLTYPE_NODE }, 	{ "xtp", CTLTYPE_NODE }, 	{ "coip", CTLTYPE_NODE }, 	{ "cnt", CTLTYPE_NODE }, 	{ "rtip", CTLTYPE_NODE }, 	{ "ipx", CTLTYPE_NODE }, 	{ "sip", CTLTYPE_NODE }, 	{ "pip", CTLTYPE_NODE }, 	{ 0, 0 }, 	{ "ndrv", CTLTYPE_NODE }, 	{ "isdn", CTLTYPE_NODE }, 	{ "key", CTLTYPE_NODE }, 	{ "inet6", CTLTYPE_NODE }, 	{ "natm", CTLTYPE_NODE }, 	{ "sys", CTLTYPE_NODE }, 	{ "netbios", CTLTYPE_NODE }, 	{ "ppp", CTLTYPE_NODE }, 	{ "hdrcomplete", CTLTYPE_NODE }, 	{ "vsock", CTLTYPE_NODE }, }
CTL_NET_RT_NAMES { 	{ 0, 0 }, 	{ "dump", CTLTYPE_STRUCT }, 	{ "flags", CTLTYPE_STRUCT }, 	{ "iflist", CTLTYPE_STRUCT }, 	{ "stat", CTLTYPE_STRUCT }, 	{ "trash", CTLTYPE_INT }, 	{ "iflist2", CTLTYPE_STRUCT }, 	{ "dump2", CTLTYPE_STRUCT }, 	{ "dumpx", CTLTYPE_STRUCT }, 	{ "dumpx_flags", CTLTYPE_STRUCT }, }
_SYS_SOCKIO_H_ None
SIOCSHIWAT _IOW('s',  0, int)
SIOCGHIWAT _IOR('s',  1, int)
SIOCSLOWAT _IOW('s',  2, int)
SIOCGLOWAT _IOR('s',  3, int)
SIOCATMARK _IOR('s',  7, int)
SIOCSPGRP _IOW('s',  8, int)
SIOCGPGRP _IOR('s',  9, int)
SIOCSIFADDR _IOW('i', 12, struct ifreq)
SIOCSIFDSTADDR _IOW('i', 14, struct ifreq)
SIOCSIFFLAGS _IOW('i', 16, struct ifreq)
SIOCGIFFLAGS _IOWR('i', 17, struct ifreq)
SIOCSIFBRDADDR _IOW('i', 19, struct ifreq)
SIOCSIFNETMASK _IOW('i', 22, struct ifreq)
SIOCGIFMETRIC _IOWR('i', 23, struct ifreq)
SIOCSIFMETRIC _IOW('i', 24, struct ifreq)
SIOCDIFADDR _IOW('i', 25, struct ifreq)
SIOCAIFADDR _IOW('i', 26, struct ifaliasreq)
SIOCGIFADDR _IOWR('i', 33, struct ifreq)
SIOCGIFDSTADDR _IOWR('i', 34, struct ifreq)
SIOCGIFBRDADDR _IOWR('i', 35, struct ifreq)
SIOCGIFNETMASK _IOWR('i', 37, struct ifreq)
SIOCAUTOADDR _IOWR('i', 38, struct ifreq)
SIOCAUTONETMASK _IOW('i', 39, struct ifreq)
SIOCARPIPLL _IOWR('i', 40, struct ifreq)
SIOCADDMULTI _IOW('i', 49, struct ifreq)
SIOCDELMULTI _IOW('i', 50, struct ifreq)
SIOCGIFMTU _IOWR('i', 51, struct ifreq)
SIOCSIFMTU _IOW('i', 52, struct ifreq)
SIOCGIFPHYS _IOWR('i', 53, struct ifreq)
SIOCSIFPHYS _IOW('i', 54, struct ifreq)
SIOCSIFMEDIA _IOWR('i', 55, struct ifreq)
SIOCGIFMEDIA _IOWR('i', 56, struct ifmediareq)
SIOCSIFGENERIC _IOW('i', 57, struct ifreq)
SIOCGIFGENERIC _IOWR('i', 58, struct ifreq)
SIOCRSLVMULTI _IOWR('i', 59, struct rslvmulti_req)
SIOCSIFLLADDR _IOW('i', 60, struct ifreq)
SIOCGIFSTATUS _IOWR('i', 61, struct ifstat)
SIOCSIFPHYADDR _IOW('i', 62, struct ifaliasreq)
SIOCGIFPSRCADDR _IOWR('i', 63, struct ifreq)
SIOCGIFPDSTADDR _IOWR('i', 64, struct ifreq)
SIOCDIFPHYADDR _IOW('i', 65, struct ifreq)
SIOCGIFDEVMTU _IOWR('i', 68, struct ifreq)
SIOCSIFALTMTU _IOW('i', 69, struct ifreq)
SIOCGIFALTMTU _IOWR('i', 72, struct ifreq)
SIOCSIFBOND _IOW('i', 70, struct ifreq)
SIOCGIFBOND _IOWR('i', 71, struct ifreq)
SIOCGIFXMEDIA _IOWR('i', 72, struct ifmediareq)
SIOCSIFCAP _IOW('i', 90, struct ifreq)
SIOCGIFCAP _IOWR('i', 91, struct ifreq)
SIOCSIFMANAGEMENT _IOWR('i', 92, struct ifreq)
SIOCIFCREATE _IOWR('i', 120, struct ifreq)
SIOCIFDESTROY _IOW('i', 121, struct ifreq)
SIOCIFCREATE2 _IOWR('i', 122, struct ifreq)
SIOCSDRVSPEC _IOW('i', 123, struct ifdrv)
SIOCGDRVSPEC _IOWR('i', 123, struct ifdrv)
SIOCSIFVLAN _IOW('i', 126, struct ifreq)
SIOCGIFVLAN _IOWR('i', 127, struct ifreq)
SIOCSETVLAN SIOCSIFVLAN
SIOCGETVLAN SIOCGIFVLAN
SIOCGIFASYNCMAP _IOWR('i', 124, struct ifreq)
SIOCSIFASYNCMAP _IOW('i', 125, struct ifreq)
SIOCGIFMAC _IOWR('i', 130, struct ifreq)
SIOCSIFMAC _IOW('i', 131, struct ifreq)
SIOCSIFKPI _IOW('i', 134, struct ifreq)
SIOCGIFKPI _IOWR('i', 135, struct ifreq)
SIOCGIFWAKEFLAGS _IOWR('i', 136, struct ifreq)
SIOCGIFFUNCTIONALTYPE _IOWR('i', 173, struct ifreq)
SIOCSIF6LOWPAN _IOW('i', 196, struct ifreq)
SIOCGIF6LOWPAN _IOWR('i', 197, struct ifreq)
SIOCGIFDIRECTLINK _IOWR('i', 222, struct ifreq)
_SYS_SOCKIO_PRIVATE_H_ None
OSIOCGIFADDR _IOWR('i', 13, struct ifreq)
OSIOCGIFDSTADDR _IOWR('i', 15, struct ifreq)
OSIOCGIFBRDADDR _IOWR('i', 18, struct ifreq)
OSIOCGIFCONF _IOWR('i', 20, struct ifconf)
OSIOCGIFCONF32 _IOWR('i', 20, struct ifconf32)
OSIOCGIFCONF64 _IOWR('i', 20, struct ifconf64)
OSIOCGIFNETMASK _IOWR('i', 21, struct ifreq)
SIOCGIFCONF32 _IOWR('i', 36, struct ifconf32)
SIOCGIFCONF64 _IOWR('i', 36, struct ifconf64)
SIOCGIFMEDIA32 _IOWR('i', 56, struct ifmediareq32)
SIOCGIFMEDIA64 _IOWR('i', 56, struct ifmediareq64)
SIOCGIFXMEDIA32 _IOWR('i', 72, struct ifmediareq32)
SIOCGIFXMEDIA64 _IOWR('i', 72, struct ifmediareq64)
SIOCPROTOATTACH _IOWR('i', 80, struct ifreq)
SIOCPROTODETACH _IOWR('i', 81, struct ifreq)
SIOCGLINKHEURISTICS _IOWR('i', 93, struct ifreq)
SIOCSATTACHPROTONULL _IOWR('i', 94, struct ifreq)
SIOCGPOINTOPOINTMDNS _IOWR('i', 95, struct ifreq)
SIOCSPOINTOPOINTMDNS _IOW('i', 95, struct ifreq)
SIOCSDRVSPEC32 _IOW('i', 123, struct ifdrv32)
SIOCGDRVSPEC32 _IOWR('i', 123, struct ifdrv32)
SIOCSDRVSPEC64 _IOW('i', 123, struct ifdrv64)
SIOCGDRVSPEC64 _IOWR('i', 123, struct ifdrv64)
SIOCSIFDEVMTU SIOCSIFALTMTU
SIOCIFGCLONERS32 _IOWR('i', 129, struct if_clonereq32)
SIOCIFGCLONERS64 _IOWR('i', 129, struct if_clonereq64)
SIOCGIFGETRTREFCNT _IOWR('i', 137, struct ifreq)
SIOCGIFLINKQUALITYMETRIC _IOWR('i', 138, struct ifreq)
SIOCSIFOPPORTUNISTIC _IOWR('i', 139, struct ifreq)
SIOCGIFOPPORTUNISTIC _IOWR('i', 140, struct ifreq)
SIOCSETROUTERMODE _IOWR('i', 141, struct ifreq)
SIOCGIFEFLAGS _IOWR('i', 142, struct ifreq)
SIOCSIFDESC _IOWR('i', 143, struct if_descreq)
SIOCGIFDESC _IOWR('i', 144, struct if_descreq)
SIOCSIFLINKPARAMS _IOWR('i', 145, struct if_linkparamsreq)
SIOCGIFLINKPARAMS _IOWR('i', 146, struct if_linkparamsreq)
SIOCGIFQUEUESTATS _IOWR('i', 147, struct if_qstatsreq)
SIOCSIFTHROTTLE _IOWR('i', 148, struct if_throttlereq)
SIOCGIFTHROTTLE _IOWR('i', 149, struct if_throttlereq)
SIOCGASSOCIDS _IOWR('s', 150, struct so_aidreq)
SIOCGCONNIDS _IOWR('s', 151, struct so_cidreq)
SIOCGCONNINFO _IOWR('s', 152, struct so_cinforeq)
SIOCGASSOCIDS32 _IOWR('s', 150, struct so_aidreq32)
SIOCGASSOCIDS64 _IOWR('s', 150, struct so_aidreq64)
SIOCGCONNIDS32 _IOWR('s', 151, struct so_cidreq32)
SIOCGCONNIDS64 _IOWR('s', 151, struct so_cidreq64)
SIOCGCONNINFO32 _IOWR('s', 152, struct so_cinforeq32)
SIOCGCONNINFO64 _IOWR('s', 152, struct so_cinforeq64)
SIOCSCONNORDER _IOWR('s', 153, struct so_cordreq)
SIOCGCONNORDER _IOWR('s', 154, struct so_cordreq)
SIOCSIFLOG _IOWR('i', 155, struct ifreq)
SIOCGIFLOG _IOWR('i', 156, struct ifreq)
SIOCGIFDELEGATE _IOWR('i', 157, struct ifreq)
SIOCGIFLLADDR _IOWR('i', 158, struct ifreq)
SIOCGIFTYPE _IOWR('i', 159, struct ifreq)
SIOCGIFEXPENSIVE _IOWR('i', 160, struct ifreq)
SIOCSIFEXPENSIVE _IOWR('i', 161, struct ifreq)
SIOCGIF2KCL _IOWR('i', 162, struct ifreq)
SIOCSIF2KCL _IOWR('i', 163, struct ifreq)
SIOCGSTARTDELAY _IOWR('i', 164, struct ifreq)
SIOCAIFAGENTID _IOWR('i', 165, struct if_agentidreq)
SIOCDIFAGENTID _IOWR('i', 166, struct if_agentidreq)
SIOCGIFAGENTIDS _IOWR('i', 167, struct if_agentidsreq)
SIOCGIFAGENTDATA _IOWR('i', 168, struct netagent_req)
SIOCGIFAGENTIDS32 _IOWR('i', 167, struct if_agentidsreq32)
SIOCGIFAGENTIDS64 _IOWR('i', 167, struct if_agentidsreq64)
SIOCGIFAGENTDATA32 _IOWR('i', 168, struct netagent_req32)
SIOCGIFAGENTDATA64 _IOWR('i', 168, struct netagent_req64)
SIOCSIFINTERFACESTATE _IOWR('i', 169, struct ifreq)
SIOCGIFINTERFACESTATE _IOWR('i', 170, struct ifreq)
SIOCSIFPROBECONNECTIVITY _IOWR('i', 171, struct ifreq)
SIOCGIFPROBECONNECTIVITY _IOWR('i', 172, struct ifreq)
SIOCSIFNETSIGNATURE _IOWR('i', 174, struct if_nsreq)
SIOCGIFNETSIGNATURE _IOWR('i', 175, struct if_nsreq)
SIOCGECNMODE _IOWR('i', 176, struct ifreq)
SIOCSECNMODE _IOW('i', 177, struct ifreq)
SIOCSIFORDER _IOWR('i', 178, struct if_order)
SIOCGIFORDER _IOWR('i', 179, struct if_order)
SIOCSQOSMARKINGMODE _IOWR('i', 180, struct ifreq)
SIOCSFASTLANECAPABLE SIOCSQOSMARKINGMODE
SIOCSQOSMARKINGENABLED _IOWR('i', 181, struct ifreq)
SIOCSFASTLEENABLED SIOCSQOSMARKINGENABLED
SIOCGQOSMARKINGMODE _IOWR('i', 182, struct ifreq)
SIOCGQOSMARKINGENABLED _IOWR('i', 183, struct ifreq)
SIOCSIFTIMESTAMPENABLE _IOWR('i', 184, struct ifreq)
SIOCSIFTIMESTAMPDISABLE _IOWR('i', 185, struct ifreq)
SIOCGIFTIMESTAMPENABLED _IOWR('i', 186, struct ifreq)
SIOCSIFDISABLEOUTPUT _IOWR('i', 187, struct ifreq)
SIOCSIFSUBFAMILY _IOWR('i', 188, struct ifreq)
SIOCGIFAGENTLIST _IOWR('i', 190, struct netagentlist_req)
SIOCGIFAGENTLIST32 _IOWR('i', 190, struct netagentlist_req32)
SIOCGIFAGENTLIST64 _IOWR('i', 190, struct netagentlist_req64)
SIOCSIFLOWINTERNET _IOWR('i', 191, struct ifreq)
SIOCGIFLOWINTERNET _IOWR('i', 192, struct ifreq)
SIOCGIFNAT64PREFIX _IOWR('i', 193, struct if_nat64req)
SIOCSIFNAT64PREFIX _IOWR('i', 194, struct if_nat64req)
SIOCGIFNEXUS _IOWR('i', 195, struct if_nexusreq)
SIOCGIFPROTOLIST _IOWR('i', 196, struct if_protolistreq)
SIOCGIFPROTOLIST32 _IOWR('i', 196, struct if_protolistreq32)
SIOCGIFPROTOLIST64 _IOWR('i', 196, struct if_protolistreq64)
SIOCGIFTCPKAOMAX _IOWR('i', 198, struct ifreq)
SIOCGIFLOWPOWER _IOWR('i', 199, struct ifreq)
SIOCSIFLOWPOWER _IOWR('i', 200, struct ifreq)
SIOCGIFCLAT46ADDR _IOWR('i', 201, struct if_clat46req)
SIOCGIFMPKLOG _IOWR('i', 202, struct ifreq)
SIOCSIFMPKLOG _IOWR('i', 203, struct ifreq)
SIOCGIFCONSTRAINED _IOWR('i', 204, struct ifreq)
SIOCSIFCONSTRAINED _IOWR('i', 205, struct ifreq)
SIOCGIFXFLAGS _IOWR('i', 206, struct ifreq)
SIOCGIFNOACKPRIO _IOWR('i', 207, struct ifreq)
SIOCSIFNOACKPRIO _IOWR('i', 208, struct ifreq)
SIOCGETROUTERMODE _IOWR('i', 209, struct ifreq)
SIOCSIFNETWORKID _IOWR('i', 210, struct if_netidreq)
SIOCSIFMARKWAKEPKT _IOWR('i', 211, struct ifreq)
SIOCSIFESTTHROUGHPUT _IOWR('i', 212, struct ifreq)
SIOCSIFRADIODETAILS _IOWR('i', 213, struct ifreq)
SIOCSIFLINKQUALITYMETRIC _IOWR('i', 214, struct ifreq)
SIOCSIFNOTRAFFICSHAPING _IOWR('i', 215, struct ifreq)
SIOCGIFNOTRAFFICSHAPING _IOWR('i', 216, struct ifreq)
SIOCGIFGENERATIONID _IOWR('i', 217, struct ifreq)
SIOCGIFULTRACONSTRAINED _IOWR('i', 218, struct ifreq)
SIOCSIFULTRACONSTRAINED _IOWR('i', 219, struct ifreq)
SIOCSIFPEEREGRESSFUNCTIONALTYPE _IOWR('i', 220, struct ifreq)
SIOCSIFDIRECTLINK _IOWR('i', 221, struct ifreq)
SIOCSIFISVPN _IOWR('i', 223, struct ifreq)
SIOCSIFDELAYWAKEPKTEVENT _IOW('i', 224, struct ifreq)
SIOCGIFDELAYWAKEPKTEVENT _IOWR('i', 224, struct ifreq)
SIOCSIFDISABLEINPUT _IOW('i', 225, struct ifreq)
SIOCGIFDISABLEINPUT _IOWR('i', 225, struct ifreq)
SIOCSIFCONGESTEDLINK _IOW('i', 226, struct ifreq)
SIOCGIFCONGESTEDLINK _IOWR('i', 226, struct ifreq)
_SYS_SPAWN_H_ None
POSIX_SPAWN_RESETIDS 0x0001
POSIX_SPAWN_SETPGROUP 0x0002
POSIX_SPAWN_SETSIGDEF 0x0004
POSIX_SPAWN_SETSIGMASK 0x0008
_SYS_SPAWN_INTERNAL_H_ None
PS_ACTION_SIZE(x, _type, _member_type) ({	size_t _ps_count = (size_t)x; 	size_t _ps_size = 0; 	 	if (os_mul_and_add_overflow(_ps_count, 	                            sizeof(_member_type), 	                            sizeof(_type), 	                            &_ps_size)) { 	        _ps_size = 0; 	} 	_ps_size; })
PS_PORT_ACTIONS_SIZE(x) PS_ACTION_SIZE(x, struct _posix_spawn_port_actions, _ps_port_action_t)
NBINPREFS 4
PS_MAC_EXTENSIONS_SIZE(x) PS_ACTION_SIZE(x, struct _posix_spawn_mac_policy_extensions, _ps_mac_policy_extension_t)
PS_MAC_EXTENSIONS_INIT_COUNT 2
POSIX_SPAWN_POSIX_CRED_UID 0x00010000
POSIX_SPAWN_POSIX_CRED_GID 0x00020000
POSIX_SPAWN_POSIX_CRED_GROUPS 0x00040000
POSIX_SPAWN_POSIX_CRED_LOGIN 0x00080000
POSIX_SPAWN_PERSONA_FLAGS_NONE 0x0
POSIX_SPAWN_PERSONA_FLAGS_OVERRIDE 0x1
POSIX_SPAWN_PERSONA_FLAGS_VERIFY 0x2
POSIX_SPAWN_PERSONA_UID POSIX_SPAWN_POSIX_CRED_UID
POSIX_SPAWN_PERSONA_GID POSIX_SPAWN_POSIX_CRED_GID
POSIX_SPAWN_PERSONA_GROUPS POSIX_SPAWN_POSIX_CRED_GROUPS
POSIX_SPAWN_JETSAM_SET 0x8000
POSIX_SPAWN_JETSAM_USE_EFFECTIVE_PRIORITY 0x01
POSIX_SPAWN_JETSAM_HIWATER_BACKGROUND 0x02
POSIX_SPAWN_JETSAM_MEMLIMIT_FATAL 0x04
POSIX_SPAWN_JETSAM_MEMLIMIT_ACTIVE_FATAL 0x04
POSIX_SPAWN_JETSAM_MEMLIMIT_INACTIVE_FATAL 0x08
POSIX_SPAWN_PROCESS_TYPE_NORMAL 0x00000000
POSIX_SPAWN_PROCESS_TYPE_DEFAULT POSIX_SPAWN_PROCESS_TYPE_NORMAL
POSIX_SPAWN_PROC_TYPE_MASK 0x00000F00
POSIX_SPAWN_PROC_TYPE_APP_DEFAULT 0x00000100
POSIX_SPAWN_PROC_TYPE_APP_TAL 0x00000200
POSIX_SPAWN_PROC_TYPE_DAEMON_STANDARD 0x00000300
POSIX_SPAWN_PROC_TYPE_DAEMON_INTERACTIVE 0x00000400
POSIX_SPAWN_PROC_TYPE_DAEMON_BACKGROUND 0x00000500
POSIX_SPAWN_PROC_TYPE_DAEMON_ADAPTIVE 0x00000600
POSIX_SPAWN_PROC_TYPE_DRIVER 0x00000700
POSIX_SPAWN_PROC_CLAMP_NONE 0x00000000
POSIX_SPAWN_PROC_CLAMP_UTILITY 0x00000001
POSIX_SPAWN_PROC_CLAMP_BACKGROUND 0x00000002
POSIX_SPAWN_PROC_CLAMP_MAINTENANCE 0x00000003
POSIX_SPAWN_PROC_CLAMP_LAST 0x00000004
POSIX_SPAWN_ENTITLEMENT_DRIVER "com.apple.private.spawn-driver"
POSIX_SPAWN_DARWIN_ROLE_NONE 0x00000000
PSF_ACTIONS_SIZE(x) PS_ACTION_SIZE(x, struct _posix_spawn_file_actions, _psfa_action_t)
PSF_ACTIONS_INIT_COUNT 2
_SYS_STACKSHOT_H None
STACKSHOT_CONFIG_TYPE 1
_SYS_STAT_H_ None
__DARWIN_STRUCT_STAT64 { 	dev_t		st_dev;                  	mode_t		st_mode;                 	nlink_t		st_nlink;                	__darwin_ino64_t st_ino;                 	uid_t		st_uid;                  	gid_t		st_gid;                  	dev_t		st_rdev;                 	__DARWIN_STRUCT_STAT64_TIMES 	off_t		st_size;                 	blkcnt_t	st_blocks;               	blksize_t	st_blksize;              	__uint32_t	st_flags;                	__uint32_t	st_gen;                  	__int32_t	st_lspare;               	__int64_t	st_qspare[2];            }
EF_MAY_SHARE_BLOCKS 0x00000001
EF_NO_XATTRS 0x00000002
EF_IS_SYNC_ROOT 0x00000004
EF_IS_PURGEABLE 0x00000008
EF_IS_SPARSE 0x00000010
EF_IS_SYNTHETIC 0x00000020
EF_SHARES_ALL_BLOCKS 0x00000040
_SYS_STDIO_H_ None
RENAME_SECLUDE 0x00000001
RENAME_SWAP 0x00000002
RENAME_EXCL 0x00000004
RENAME_RESERVED1 0x00000008
RENAME_NOFOLLOW_ANY 0x00000010
_SYS_SUBRPRF_H_ None
_SYS_SYSCTL_H_ None
CTL_MAXNAME 12
CTLTYPE 0xf
CTLTYPE_NODE 1
CTLTYPE_INT 2
CTLTYPE_STRING 3
CTLTYPE_QUAD 4
CTLTYPE_OPAQUE 5
CTLTYPE_STRUCT CTLTYPE_OPAQUE
CTLFLAG_RD 0x80000000
CTLFLAG_WR 0x40000000
CTLFLAG_NOLOCK 0x20000000
CTLFLAG_ANYBODY 0x10000000
CTLFLAG_SECURE 0x08000000
CTLFLAG_MASKED 0x04000000
CTLFLAG_NOAUTO 0x02000000
CTLFLAG_KERN 0x01000000
CTLFLAG_LOCKED 0x00800000
CTLFLAG_OID2 0x00400000
CTLFLAG_PERMANENT 0x00200000
CTLFLAG_EXPERIMENT 0x00100000
OID_AUTO_START 100
SYSCTL_OID_VERSION 1
SYSCTL_IN(r, p, l) (r->newfunc)(r, p, l)
SYSCTL_OUT(r, p, l) (r->oldfunc)(r, p, l)
nvram_osenvironment "osenvironment"
SYSCTL_DECL(name) extern struct sysctl_oid_list sysctl_##name##_children
SYSCTL_STRUCT_INIT(parent, nbr, name, kind, a1, a2, fn, fmt, desc) {    	    .oid_parent     = &sysctl_##parent##_children,                      	    .oid_number     = nbr,                                              	    .oid_kind       = (int)(kind | CTLFLAG_OID2),                       	    .oid_arg1       = a1,                                               	    .oid_arg2       = (int)(a2),                                        	    .oid_name       = #name,                                            	    .oid_handler    = fn,                                               	    .oid_fmt        = fmt,                                              	    .oid_descr      = desc,                                             	    .oid_version    = SYSCTL_OID_VERSION,                               	}
__SYSCTL_OID(parent, nbr, name, kind, a1, a2, handler, fmt, descr) 	struct sysctl_oid sysctl_##parent##_##name = SYSCTL_STRUCT_INIT(	    parent, nbr, name, kind, a1, a2, handler, fmt, descr)
SYSCTL_OID_MANUAL(parent, nbr, name, kind, a1, a2, handler, fmt, descr) 	__XNU_PRIVATE_EXTERN                                                    	__SYSCTL_OID(parent, nbr, name, kind, a1, a2, handler, fmt, descr)
SYSCTL_NODE_MANUAL(parent, nbr, name, access, handler, descr)           	struct sysctl_oid_list sysctl_##parent##_##name##_children;             	__XNU_PRIVATE_EXTERN                                                    	__SYSCTL_OID(parent, nbr, name, CTLTYPE_NODE|access,                    	    &sysctl_##parent##_##name##_children, 0, handler, "N", descr);
SYSCTL_OID(parent, nbr, name, kind, a1, a2, handler, fmt, descr)        	__security_const_late __XNU_PRIVATE_EXTERN                              	__SYSCTL_OID(parent, nbr, name, CTLFLAG_PERMANENT|kind,                 	    a1, a2, handler, fmt, descr);                                       	__STARTUP_ARG(sysctl_##parent, _##name,                                 	    SYSCTL, STARTUP_RANK_SECOND, sysctl_register_oid_early,             	    &sysctl_##parent##_##name)
__SYSCTL_NODE(parent, nbr, name, access, handler, descr)                	__security_const_late                                                   	struct sysctl_oid_list sysctl_##parent##_##name##_children;             	__security_const_late __XNU_PRIVATE_EXTERN                              	__SYSCTL_OID(parent, nbr, name, CTLFLAG_PERMANENT|CTLTYPE_NODE|access,  	    &sysctl_##parent##_##name##_children, 0, handler, "N", descr);      	__STARTUP_ARG(sysctl_##parent, _##name,                                 	    SYSCTL, STARTUP_RANK_FIRST, sysctl_register_oid_early,              	    &sysctl_##parent##_##name)
__SYSCTL_EXTENSION_NODE(name) static __security_read_write                                            	struct sysctl_oid_list sysctl_##name##_children_mutable;                	static __security_const_late                                            	struct sysctl_oid sysctl_##name##_wranchor = {                          	    .oid_parent     = &sysctl_##name##_children,                        	    .oid_number     = OID_MUTABLE_ANCHOR,                               	    .oid_kind       = CTLFLAG_OID2 | CTLFLAG_PERMANENT,                 	    .oid_arg1       = &sysctl_##name##_children_mutable,                	    .oid_name       = "__anchor__(" #name ")",                          	    .oid_version    = SYSCTL_OID_VERSION,                               	};                                                                      	__STARTUP_ARG(sysctl_##name, _wranchor,                                 	    SYSCTL, STARTUP_RANK_LAST, sysctl_register_oid_early,               	    &sysctl_##name##_wranchor)
SYSCTL_NODE(parent, nbr, name, access, handler, descr)                  	__XNU_PRIVATE_EXTERN                                                    	__SYSCTL_NODE(parent, nbr, name, access, handler, descr)
SYSCTL_EXTENSIBLE_NODE(parent, nbr, name, access, handler, descr)       	__SYSCTL_NODE(parent, nbr, name, access, handler, descr);               	__SYSCTL_EXTENSION_NODE(parent##_##name)
SYSCTL_STRING(parent, nbr, name, access, arg, len, descr) 	SYSCTL_OID(parent, nbr, name, CTLTYPE_STRING|access, 	    arg, len, sysctl_handle_string, "A", descr)
SYSCTL_COMPAT_INT(parent, nbr, name, access, ptr, val, descr) 	SYSCTL_OID(parent, nbr, name, CTLTYPE_INT|access, 	    ptr, val, sysctl_handle_int, "I", descr)
SYSCTL_COMPAT_UINT(parent, nbr, name, access, ptr, val, descr) 	SYSCTL_OID(parent, nbr, name, CTLTYPE_INT|access, 	    ptr, val, sysctl_handle_int, "IU", descr)
SYSCTL_INT(parent, nbr, name, access, ptr, val, descr) 	SYSCTL_OID(parent, nbr, name, CTLTYPE_INT|access, 	    ptr, val, sysctl_handle_int, "I", descr); 	_Static_assert(__builtin_constant_p(ptr) || sizeof(*(ptr)) == sizeof(int), 	    "must be integer sized");
SYSCTL_UINT(parent, nbr, name, access, ptr, val, descr) 	SYSCTL_OID(parent, nbr, name, CTLTYPE_INT|access, 	    ptr, val, sysctl_handle_int, "IU", descr); 	_Static_assert(__builtin_constant_p(ptr) || sizeof(*(ptr)) == sizeof(unsigned int), 	    "must be integer sized");
SYSCTL_LONG(parent, nbr, name, access, ptr, descr) 	SYSCTL_OID(parent, nbr, name, CTLTYPE_INT|access, 	    ptr, 0, sysctl_handle_long, "L", descr); 	_Static_assert(__builtin_constant_p(ptr) || sizeof(*(ptr)) == sizeof(long), 	    "must be long sized");
SYSCTL_ULONG(parent, nbr, name, access, ptr, descr) 	SYSCTL_OID(parent, nbr, name, CTLTYPE_INT|access, 	    ptr, 0, sysctl_handle_long, "LU", descr); 	_Static_assert(__builtin_constant_p(ptr) || sizeof(*(ptr)) == sizeof(unsigned long), 	    "must be long sized");
SYSCTL_QUAD(parent, nbr, name, access, ptr, descr) 	SYSCTL_OID(parent, nbr, name, CTLTYPE_QUAD|access, 	    ptr, 0, sysctl_handle_quad, "Q", descr); 	_Static_assert(__builtin_constant_p(ptr) || sizeof(*(ptr)) == sizeof(long long), 	    "must be long long sized");
SYSCTL_OPAQUE(parent, nbr, name, access, ptr, len, fmt, descr) 	SYSCTL_OID(parent, nbr, name, CTLTYPE_OPAQUE|access, 	        ptr, len, sysctl_handle_opaque, fmt, descr)
SYSCTL_STRUCT(parent, nbr, name, access, ptr, type, descr) 	SYSCTL_OID(parent, nbr, name, CTLTYPE_OPAQUE|access, 	    ptr, sizeof(struct type), sysctl_handle_opaque, 	    "S," #type, descr)
SYSCTL_PROC(parent, nbr, name, access, ptr, arg, handler, fmt, descr) 	SYSCTL_OID(parent, nbr, name, access, 	    ptr, arg, handler, fmt, descr)
experiment_factor_numeric_types X(uint, unsigned int)     X(int, int)     X(ulong, unsigned long)     X(long, long)     X(uint64, uint64_t)     X(int64, int64_t)
X(experiment_factor_typename, _) int experiment_factor_##experiment_factor_typename##_handler SYSCTL_HANDLER_ARGS;
__EXPERIMENT_FACTOR_SPEC(parent, name, p, min, max) 	struct experiment_spec experiment_##parent##_##name = { 	        .ptr = p, 	        .min_value = min, 	        .max_value = max, 	        .original_value = 0, 	        .modified = false 	}
EXPERIMENT_FACTOR_UINT(parent, name, ptr, min, max, descr) 	__EXPERIMENT_FACTOR_SPEC(parent, name, ptr, min, max); 	_Static_assert(sizeof(*(ptr)) == sizeof(unsigned int), "must be integer sized"); 	SYSCTL_PROC(parent, OID_AUTO, name, CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_ANYBODY | CTLFLAG_EXPERIMENT, &experiment_##parent##_##name, 1, &experiment_factor_uint_handler, "IU", descr);
EXPERIMENT_FACTOR_INT(parent, name, ptr, min, max, descr) 	__EXPERIMENT_FACTOR_SPEC(parent, name, ptr, min, max); 	_Static_assert(sizeof(*(ptr)) == sizeof(int), "must be integer sized"); 	SYSCTL_PROC(parent, OID_AUTO, name, CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_ANYBODY | CTLFLAG_EXPERIMENT, &experiment_##parent##_##name, 1, &experiment_factor_int_handler, "I", descr);
EXPERIMENT_FACTOR_ULONG(parent, name, ptr, min, max, descr) 	__EXPERIMENT_FACTOR_SPEC(parent, name, ptr, min, max); 	_Static_assert(sizeof(*(ptr)) == sizeof(unsigned long), "must be long sized"); 	SYSCTL_PROC(parent, OID_AUTO, name, CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_ANYBODY | CTLFLAG_EXPERIMENT, &experiment_##parent##_##name, 1, &experiment_factor_ulong_handler, "LU", descr);
EXPERIMENT_FACTOR_LONG(parent, name, ptr, min, max, descr) 	__EXPERIMENT_FACTOR_SPEC(parent, name, ptr, min, max); 	_Static_assert(sizeof(*(ptr)) == sizeof(long), "must be long sized"); 	SYSCTL_PROC(parent, OID_AUTO, name, CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_ANYBODY | CTLFLAG_EXPERIMENT, &experiment_##parent##_##name, 1, &experiment_factor_long_handler, "L", descr);
EXPERIMENT_FACTOR_UINT64(parent, name, ptr, min, max, descr) 	__EXPERIMENT_FACTOR_SPEC(parent, name, ptr, min, max); 	_Static_assert(sizeof(*(ptr)) == sizeof(uint64_t), "must be 8 bytes"); 	SYSCTL_PROC(parent, OID_AUTO, name, CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_ANYBODY | CTLFLAG_EXPERIMENT, &experiment_##parent##_##name, 1, &experiment_factor_uint64_handler, "QU", descr);
EXPERIMENT_FACTOR_INT64(parent, name, ptr, min, max, descr) 	__EXPERIMENT_FACTOR_SPEC(parent, name, ptr, min, max); 	_Static_assert(sizeof(*(ptr)) == sizeof(int64_t), "must be 8 bytes"); 	SYSCTL_PROC(parent, OID_AUTO, name, CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_ANYBODY | CTLFLAG_EXPERIMENT, &experiment_##parent##_##name, 1, &experiment_factor_int64_handler, "Q", descr);
EXPERIMENT_FACTOR_PROC(parent, name, access, ptr, arg, handler, fmt, descr) 	_Static_assert(arg != 1, "arg can not be 1"); 	SYSCTL_PROC(parent, OID_AUTO, name, access | CTLFLAG_ANYBODY | CTLFLAG_EXPERIMENT, ptr, arg, handler, fmt, descr);
SYSCTL_SCALABLE_COUNTER(parent, name, counter, descr) SYSCTL_PROC(parent, OID_AUTO, name, CTLTYPE_QUAD | CTLFLAG_RD | CTLFLAG_LOCKED,     (void *)(&counter), 0, &scalable_counter_sysctl_handler, "Q", descr);
SYSCTL_SKMEM 0
SYSCTL_SKMEM_UPDATE_FIELD(field, value)
SYSCTL_SKMEM_UPDATE_AT_OFFSET(offset, value)
SYSCTL_SKMEM_INT(parent, oid, sysctl_name, access, ptr, offset, descr) 	SYSCTL_INT(parent, oid, sysctl_name, access, ptr, 0, descr)
SYSCTL_SKMEM_TCP_INT(oid, sysctl_name, access, variable_type,   	    variable_name, initial_value, descr)           	variable_type variable_name = initial_value;                                            	SYSCTL_SKMEM_INT(_net_inet_tcp, oid, sysctl_name, access,                       	                                 &variable_name, 0, descr)
SYSCTL_DEF_ENABLED None
CTL_UNSPEC 0
CTL_KERN 1
CTL_VM 2
CTL_VFS 3
CTL_NET 4
CTL_DEBUG 5
CTL_HW 6
CTL_MACHDEP 7
CTL_USER 8
CTL_MAXID 9
CTL_NAMES { 	{ 0, 0 }, 	{ "kern", CTLTYPE_NODE }, 	{ "vm", CTLTYPE_NODE }, 	{ "vfs", CTLTYPE_NODE }, 	{ "net", CTLTYPE_NODE }, 	{ "debug", CTLTYPE_NODE }, 	{ "hw", CTLTYPE_NODE }, 	{ "machdep", CTLTYPE_NODE }, 	{ "user", CTLTYPE_NODE }, }
KERN_OSTYPE 1
KERN_OSRELEASE 2
KERN_OSREV 3
KERN_VERSION 4
KERN_MAXVNODES 5
KERN_MAXPROC 6
KERN_MAXFILES 7
KERN_ARGMAX 8
KERN_SECURELVL 9
KERN_HOSTNAME 10
KERN_HOSTID 11
KERN_CLOCKRATE 12
KERN_VNODE 13
KERN_PROC 14
KERN_FILE 15
KERN_PROF 16
KERN_POSIX1 17
KERN_NGROUPS 18
KERN_JOB_CONTROL 19
KERN_SAVED_IDS 20
KERN_BOOTTIME 21
KERN_NISDOMAINNAME 22
KERN_DOMAINNAME KERN_NISDOMAINNAME
KERN_MAXPARTITIONS 23
KERN_KDEBUG 24
KERN_UPDATEINTERVAL 25
KERN_OSRELDATE 26
KERN_NTP_PLL 27
KERN_BOOTFILE 28
KERN_MAXFILESPERPROC 29
KERN_MAXPROCPERUID 30
KERN_DUMPDEV 31
KERN_IPC 32
KERN_DUMMY 33
KERN_PS_STRINGS 34
KERN_USRSTACK32 35
KERN_LOGSIGEXIT 36
KERN_SYMFILE 37
KERN_PROCARGS 38
KERN_NETBOOT 40
KERN_SYSV 42
KERN_AFFINITY 43
KERN_TRANSLATE 44
KERN_CLASSIC KERN_TRANSLATE
KERN_EXEC 45
KERN_CLASSICHANDLER KERN_EXEC
KERN_AIOMAX 46
KERN_AIOPROCMAX 47
KERN_AIOTHREADS 48
KERN_COREFILE 50
KERN_COREDUMP 51
KERN_SUGID_COREDUMP 52
KERN_PROCDELAYTERM 53
KERN_SHREG_PRIVATIZABLE 54
KERN_LOW_PRI_WINDOW 56
KERN_LOW_PRI_DELAY 57
KERN_POSIX 58
KERN_USRSTACK64 59
KERN_NX_PROTECTION 60
KERN_TFP 61
KERN_PROCNAME 62
KERN_THALTSTACK 63
KERN_SPECULATIVE_READS 64
KERN_OSVERSION 65
KERN_SAFEBOOT 66
KERN_RAGEVNODE 68
KERN_TTY 69
KERN_CHECKOPENEVT 70
KERN_THREADNAME 71
KERN_MAXID 72
KERN_USRSTACK KERN_USRSTACK64
KERN_RAGE_PROC 1
KERN_RAGE_THREAD 2
KERN_UNRAGE_PROC 3
KERN_UNRAGE_THREAD 4
KERN_OPENEVT_PROC 1
KERN_UNOPENEVT_PROC 2
KERN_TFP_POLICY 1
KERN_TFP_POLICY_DENY 0
KERN_TFP_POLICY_DEFAULT 2
KERN_KDEFLAGS 1
KERN_KDDFLAGS 2
KERN_KDENABLE 3
KERN_KDSETBUF 4
KERN_KDGETBUF 5
KERN_KDSETUP 6
KERN_KDREMOVE 7
KERN_KDSETREG 8
KERN_KDGETREG 9
KERN_KDREADTR 10
KERN_KDPIDTR 11
KERN_KDTHRMAP 12
KERN_KDPIDEX 14
KERN_KDSETRTCDEC 15
KERN_KDGETENTROPY 16
KERN_KDWRITETR 17
KERN_KDWRITEMAP 18
KERN_KDTEST 19
KERN_KDREADCURTHRMAP 21
KERN_KDSET_TYPEFILTER 22
KERN_KDBUFWAIT 23
KERN_KDCPUMAP 24
KERN_KDCPUMAP_EXT 25
KERN_KDSET_EDM 26
KERN_KDGET_EDM 27
KERN_KDWRITETR_V3 28
CTL_KERN_NAMES { 	{ 0, 0 }, 	{ "ostype", CTLTYPE_STRING }, 	{ "osrelease", CTLTYPE_STRING }, 	{ "osrevision", CTLTYPE_INT }, 	{ "version", CTLTYPE_STRING }, 	{ "maxvnodes", CTLTYPE_INT }, 	{ "maxproc", CTLTYPE_INT }, 	{ "maxfiles", CTLTYPE_INT }, 	{ "argmax", CTLTYPE_INT }, 	{ "securelevel", CTLTYPE_INT }, 	{ "hostname", CTLTYPE_STRING }, 	{ "hostid", CTLTYPE_INT }, 	{ "clockrate", CTLTYPE_STRUCT }, 	{ "vnode", CTLTYPE_STRUCT }, 	{ "proc", CTLTYPE_STRUCT }, 	{ "file", CTLTYPE_STRUCT }, 	{ "profiling", CTLTYPE_NODE }, 	{ "posix1version", CTLTYPE_INT }, 	{ "ngroups", CTLTYPE_INT }, 	{ "job_control", CTLTYPE_INT }, 	{ "saved_ids", CTLTYPE_INT }, 	{ "boottime", CTLTYPE_STRUCT }, 	{ "nisdomainname", CTLTYPE_STRING }, 	{ "maxpartitions", CTLTYPE_INT }, 	{ "kdebug", CTLTYPE_INT }, 	{ "update", CTLTYPE_INT }, 	{ "osreldate", CTLTYPE_INT }, 	{ "ntp_pll", CTLTYPE_NODE }, 	{ "bootfile", CTLTYPE_STRING }, 	{ "maxfilesperproc", CTLTYPE_INT }, 	{ "maxprocperuid", CTLTYPE_INT }, 	{ "dumpdev", CTLTYPE_STRUCT },  	{ "ipc", CTLTYPE_NODE }, 	{ "dummy", CTLTYPE_INT }, 	{ "dummy", CTLTYPE_INT }, 	{ "usrstack", CTLTYPE_INT }, 	{ "logsigexit", CTLTYPE_INT }, 	{ "symfile",CTLTYPE_STRING },	{ "procargs",CTLTYPE_STRUCT },	{ "dummy", CTLTYPE_INT },                	{ "netboot", CTLTYPE_INT }, 	{ "dummy", CTLTYPE_INT },                	{ "sysv", CTLTYPE_NODE }, 	{ "dummy", CTLTYPE_INT }, 	{ "dummy", CTLTYPE_INT }, 	{ "exec", CTLTYPE_NODE }, 	{ "aiomax", CTLTYPE_INT }, 	{ "aioprocmax", CTLTYPE_INT }, 	{ "aiothreads", CTLTYPE_INT }, 	{ "procargs2",CTLTYPE_STRUCT }, 	{ "corefile",CTLTYPE_STRING }, 	{ "coredump", CTLTYPE_INT }, 	{ "sugid_coredump", CTLTYPE_INT }, 	{ "delayterm", CTLTYPE_INT }, 	{ "shreg_private", CTLTYPE_INT }, 	{ "proc_low_pri_io", CTLTYPE_INT }, 	{ "low_pri_window", CTLTYPE_INT }, 	{ "low_pri_delay", CTLTYPE_INT }, 	{ "posix", CTLTYPE_NODE }, 	{ "usrstack64", CTLTYPE_QUAD }, 	{ "nx", CTLTYPE_INT }, 	{ "tfp", CTLTYPE_NODE }, 	{ "procname", CTLTYPE_STRING }, 	{ "threadsigaltstack", CTLTYPE_INT }, 	{ "speculative_reads_disabled", CTLTYPE_INT }, 	{ "osversion", CTLTYPE_STRING }, 	{ "safeboot", CTLTYPE_INT }, 	{ "dummy", CTLTYPE_INT },                	{ "rage_vnode", CTLTYPE_INT }, 	{ "tty", CTLTYPE_NODE },        	{ "check_openevt", CTLTYPE_INT }, 	{ "thread_name", CTLTYPE_STRING } }
CTL_VFS_NAMES { 	{ "vfsconf", CTLTYPE_STRUCT } }
KERN_PROC_ALL 0
KERN_PROC_PID 1
KERN_PROC_PGRP 2
KERN_PROC_SESSION 3
KERN_PROC_TTY 4
KERN_PROC_UID 5
KERN_PROC_RUID 6
KERN_PROC_LCID 7
KERN_VFSNSPACE_HANDLE_PROC 1
KERN_VFSNSPACE_UNHANDLE_PROC 2
KIPC_MAXSOCKBUF 1
KIPC_SOCKBUF_WASTE 2
KIPC_SOMAXCONN 3
KIPC_MAX_LINKHDR 4
KIPC_MAX_PROTOHDR 5
KIPC_MAX_HDR 6
KIPC_MAX_DATALEN 7
KIPC_MBSTAT 8
KIPC_NMBCLUSTERS 9
KIPC_SOQLIMITCOMPAT 10
VM_METER 1
VM_LOADAVG 2
VM_MACHFACTOR 4
VM_SWAPUSAGE 5
VM_MAXID 6
CTL_VM_NAMES { 	{ 0, 0 }, 	{ "vmmeter", CTLTYPE_STRUCT }, 	{ "loadavg", CTLTYPE_STRUCT }, 	{ 0, 0 },  	{ "dummy", CTLTYPE_INT }, 	{ "swapusage", CTLTYPE_STRUCT } }
HW_MACHINE 1
HW_MODEL 2
HW_NCPU 3
HW_BYTEORDER 4
HW_PHYSMEM 5
HW_USERMEM 6
HW_PAGESIZE 7
HW_DISKNAMES 8
HW_DISKSTATS 9
HW_EPOCH 10
HW_FLOATINGPT 11
HW_MACHINE_ARCH 12
HW_VECTORUNIT 13
HW_BUS_FREQ 14
HW_CPU_FREQ 15
HW_CACHELINE 16
HW_L1ICACHESIZE 17
HW_L1DCACHESIZE 18
HW_L2SETTINGS 19
HW_L2CACHESIZE 20
HW_L3SETTINGS 21
HW_L3CACHESIZE 22
HW_TB_FREQ 23
HW_MEMSIZE 24
HW_AVAILCPU 25
HW_TARGET 26
HW_PRODUCT 27
HW_MAXID 28
CTL_HW_NAMES { 	{ 0, 0 }, 	{ "machine", CTLTYPE_STRING },           	{ "model", CTLTYPE_STRING },             	{ "ncpu", CTLTYPE_INT }, 	{ "byteorder", CTLTYPE_INT }, 	{ "physmem", CTLTYPE_INT }, 	{ "usermem", CTLTYPE_INT }, 	{ "pagesize", CTLTYPE_INT }, 	{ "disknames", CTLTYPE_STRUCT }, 	{ "diskstats", CTLTYPE_STRUCT }, 	{ "epoch", CTLTYPE_INT }, 	{ "floatingpoint", CTLTYPE_INT }, 	{ "machinearch", CTLTYPE_STRING }, 	{ "vectorunit", CTLTYPE_INT }, 	{ "busfrequency", CTLTYPE_INT }, 	{ "cpufrequency", CTLTYPE_INT }, 	{ "cachelinesize", CTLTYPE_INT }, 	{ "l1icachesize", CTLTYPE_INT }, 	{ "l1dcachesize", CTLTYPE_INT }, 	{ "l2settings", CTLTYPE_INT }, 	{ "l2cachesize", CTLTYPE_INT }, 	{ "l3settings", CTLTYPE_INT }, 	{ "l3cachesize", CTLTYPE_INT }, 	{ "tbfrequency", CTLTYPE_INT }, 	{ "memsize", CTLTYPE_QUAD }, 	{ "availcpu", CTLTYPE_INT }, 	{ "target", CTLTYPE_STRING }, 	{ "product", CTLTYPE_STRING }, }
USER_CS_PATH 1
USER_BC_BASE_MAX 2
USER_BC_DIM_MAX 3
USER_BC_SCALE_MAX 4
USER_BC_STRING_MAX 5
USER_COLL_WEIGHTS_MAX 6
USER_EXPR_NEST_MAX 7
USER_LINE_MAX 8
USER_RE_DUP_MAX 9
USER_POSIX2_VERSION 10
USER_POSIX2_C_BIND 11
USER_POSIX2_C_DEV 12
USER_POSIX2_CHAR_TERM 13
USER_POSIX2_FORT_DEV 14
USER_POSIX2_FORT_RUN 15
USER_POSIX2_LOCALEDEF 16
USER_POSIX2_SW_DEV 17
USER_POSIX2_UPE 18
USER_STREAM_MAX 19
USER_TZNAME_MAX 20
USER_MAXID 21
CTL_USER_NAMES { 	{ 0, 0 }, 	{ "cs_path", CTLTYPE_STRING }, 	{ "bc_base_max", CTLTYPE_INT }, 	{ "bc_dim_max", CTLTYPE_INT }, 	{ "bc_scale_max", CTLTYPE_INT }, 	{ "bc_string_max", CTLTYPE_INT }, 	{ "coll_weights_max", CTLTYPE_INT }, 	{ "expr_nest_max", CTLTYPE_INT }, 	{ "line_max", CTLTYPE_INT }, 	{ "re_dup_max", CTLTYPE_INT }, 	{ "posix2_version", CTLTYPE_INT }, 	{ "posix2_c_bind", CTLTYPE_INT }, 	{ "posix2_c_dev", CTLTYPE_INT }, 	{ "posix2_char_term", CTLTYPE_INT }, 	{ "posix2_fort_dev", CTLTYPE_INT }, 	{ "posix2_fort_run", CTLTYPE_INT }, 	{ "posix2_localedef", CTLTYPE_INT }, 	{ "posix2_sw_dev", CTLTYPE_INT }, 	{ "posix2_upe", CTLTYPE_INT }, 	{ "stream_max", CTLTYPE_INT }, 	{ "tzname_max", CTLTYPE_INT } }
CTL_DEBUG_NAME 0
CTL_DEBUG_VALUE 1
CTL_DEBUG_MAXID 20
OSRELEASETYPE_SIZE 48
_SYS_SYSENT_H_ None
_SYS_SYSLIMITS_H_ None
_SYS_SYSLOG_H_ None
_PATH_LOG "/var/run/syslog"
LOG_EMERG 0
LOG_ALERT 1
LOG_CRIT 2
LOG_ERR 3
LOG_WARNING 4
LOG_NOTICE 5
LOG_INFO 6
LOG_DEBUG 7
LOG_PRIMASK 0x07
LOG_MAKEPRI(fac, pri)   ((fac) | (pri))
LOG_NFACILITIES 25
LOG_FACMASK 0x03f8
LOG_PID 0x01
LOG_CONS 0x02
LOG_ODELAY 0x04
LOG_NDELAY 0x08
LOG_NOWAIT 0x10
LOG_PERROR 0x20
_SYS_SYSTM_H_ None
SYSINIT(a, b, c, d, e)
MALLOC_DEFINE(a, b, c)
getenv_int(a, b) (*b = 0)
KASSERT(exp, msg)
hashinit_counted_by(_elements, _out_ptr, _out_count) do {         	size_t __hashinit_out_count = 0;                                	struct generic_hash_head *__counted_by(__hashinit_out_count) __hashinit_out_hash = NULL; 	hashinit_generic((_elements), &__hashinit_out_hash, &__hashinit_out_count); 	(_out_ptr) = (typeof(*(_out_ptr)) *)__hashinit_out_hash;        	(_out_count) = __hashinit_out_count;                            } while (0)
susize(_a, _s)  sulong((_a), (_s))
suptr(_a, _p)   sulong((_a), (_p))
THROTTLE_DISENGAGED 0
THROTTLE_ENGAGED 1
THROTTLE_NOW 2
_SYS_SYSTRACE_ARGS_H None
_SYSTEM_DOMAIN_H_ None
SYSPROTO_EVENT 1
SYSPROTO_CONTROL 2
AF_SYS_CONTROL 2
_SYS_TERMIOS_H_ None
VEOF 0
VEOL 1
VERASE 3
VKILL 5
VINTR 8
VQUIT 9
VSUSP 10
VSTART 12
VSTOP 13
VMIN 16
VTIME 17
NCCS 20
IGNBRK 0x00000001
BRKINT 0x00000002
IGNPAR 0x00000004
PARMRK 0x00000008
INPCK 0x00000010
ISTRIP 0x00000020
INLCR 0x00000040
IGNCR 0x00000080
ICRNL 0x00000100
IXON 0x00000200
IXOFF 0x00000400
IXANY 0x00000800
OPOST 0x00000001
ONLCR 0x00000002
OCRNL 0x00000010
ONOCR 0x00000020
ONLRET 0x00000040
OFILL 0x00000080
NLDLY 0x00000300
TABDLY 0x00000c04
CRDLY 0x00003000
FFDLY 0x00004000
BSDLY 0x00008000
VTDLY 0x00010000
OFDEL 0x00020000
CSIZE 0x00000300
CS5 0x00000000
CS6 0x00000100
CS7 0x00000200
CS8 0x00000300
CSTOPB 0x00000400
CREAD 0x00000800
PARENB 0x00001000
PARODD 0x00002000
HUPCL 0x00004000
CLOCAL 0x00008000
ECHOE 0x00000002
ECHOK 0x00000004
ECHO 0x00000008
ECHONL 0x00000010
ISIG 0x00000080
ICANON 0x00000100
IEXTEN 0x00000400
TOSTOP 0x00400000
NOFLSH 0x80000000
TCSANOW 0
TCSADRAIN 1
TCSAFLUSH 2
B0 0
B50 50
B75 75
B110 110
B134 134
B150 150
B200 200
B300 300
B600 600
B1200 1200
B1800 1800
B2400 2400
B4800 4800
B9600 9600
B19200 19200
B38400 38400
_SYS_TIME_H_ None
_SYS_TIMEB_H_ None
_SYS_TIMES_H_ None
_SYS_TIMEX_H_ 1
NTP_API 4
MAXPHASE 500000000L
MAXFREQ 500000L
MINSEC 256
MAXSEC 2048
NANOSECOND 1000000000L
MAXTC 10
MOD_OFFSET 0x0001
MOD_FREQUENCY 0x0002
MOD_MAXERROR 0x0004
MOD_ESTERROR 0x0008
MOD_STATUS 0x0010
MOD_TIMECONST 0x0020
MOD_PPSMAX 0x0040
MOD_TAI 0x0080
MOD_MICRO 0x1000
MOD_NANO 0x2000
MOD_CLKB 0x4000
MOD_CLKA 0x8000
STA_PLL 0x0001
STA_PPSFREQ 0x0002
STA_PPSTIME 0x0004
STA_FLL 0x0008
STA_INS 0x0010
STA_DEL 0x0020
STA_UNSYNC 0x0040
STA_FREQHOLD 0x0080
STA_PPSSIGNAL 0x0100
STA_PPSJITTER 0x0200
STA_PPSWANDER 0x0400
STA_PPSERROR 0x0800
STA_CLOCKERR 0x1000
STA_NANO 0x2000
STA_MODE 0x4000
STA_CLK 0x8000
TIME_OK 0
TIME_INS 1
TIME_DEL 2
TIME_OOP 3
TIME_WAIT 4
TIME_ERROR 5
_SYS_TPRINTF_H_ None
_SYS_TRACE_H_ None
_SYS_CODE_SIGNING_TXM_H_ None
_SYS_TRUST_CACHES_H_ None
XNU_HAS_TRUST_CACHE_LOADING 1
XNU_HAS_TRUST_CACHE_CHECK_RUNTIME_FOR_UUID 1
XNU_HAS_TRUST_CACHE_QUERY_FOR_REM 1
XNU_HAS_TRUST_CACHE_UNLOADING 1
_SYS_TTY_H_ None
TTYCLSIZE 1024
t_cc t_termios.c_cc
t_cflag t_termios.c_cflag
t_iflag t_termios.c_iflag
t_ispeed t_termios.c_ispeed
t_lflag t_termios.c_lflag
t_min t_termios.c_min
t_oflag t_termios.c_oflag
t_ospeed t_termios.c_ospeed
t_time t_termios.c_time
TTIPRI 25
TTOPRI 26
IBUFSIZ 384
OBUFSIZ 100
TTYHOG 1024
TTMAXHIWAT roundup(2048, CBSIZE)
TTMINHIWAT roundup(100, CBSIZE)
TTMAXLOWAT 256
TTMINLOWAT 32
TS_SO_OLOWAT 0x00001
TS_ASYNC 0x00002
TS_BUSY 0x00004
TS_CARR_ON 0x00008
TS_FLUSH 0x00010
TS_ISOPEN 0x00020
TS_TBLOCK 0x00040
TS_TIMEOUT 0x00080
TS_TTSTOP 0x00100
TS_XCLUDE 0x00400
TS_BKSL 0x00800
TS_CNTTB 0x01000
TS_ERASE 0x02000
TS_LNCH 0x04000
TS_TYPEN 0x08000
TS_CAN_BYPASS_L_RINT 0x010000
TS_CONNECTED 0x020000
TS_SNOOP 0x040000
TS_SO_OCOMPLETE 0x080000
TS_ZOMBIE 0x100000
TS_CAR_OFLOW 0x200000
TS_IOCTL_NOT_OK 0x1000000
TS_REVOKE 0x2000000
ORDINARY 0
CONTROL 1
BACKSPACE 2
NEWLINE 3
TAB 4
VTAB 5
RETURN 6
DMSET 0
DMBIS 1
DMBIC 2
DMGET 3
TTY_CHARMASK 0x000000ff
TTY_QUOTE 0x00000100
TTY_ERRORMASK 0xff000000
TTY_FE 0x01000000
TTY_PE 0x02000000
TTY_OE 0x04000000
TTY_BI 0x08000000
TTY_LOCK_OWNED(tp) LCK_MTX_ASSERT(&tp->t_lock, LCK_MTX_ASSERT_OWNED)
TTY_LOCK_NOTOWNED(tp) LCK_MTX_ASSERT(&tp->t_lock, LCK_MTX_ASSERT_NOTOWNED)
PTS_MAJOR 4
PTC_MAJOR 5
_SYS_TTYCHARS_H_ None
_SYS_TTYCOM_H_ None
TIOCMODG _IOR('t', 3, int)
TIOCMODS _IOW('t', 4, int)
TIOCM_LE 0001
TIOCM_DTR 0002
TIOCM_RTS 0004
TIOCM_ST 0010
TIOCM_SR 0020
TIOCM_CTS 0040
TIOCM_CAR 0100
TIOCM_CD TIOCM_CAR
TIOCM_RNG 0200
TIOCM_RI TIOCM_RNG
TIOCM_DSR 0400
TIOCEXCL _IO('t', 13)
TIOCNXCL _IO('t', 14)
TIOCFLUSH _IOW('t', 16, int)
TIOCGETA _IOR('t', 19, struct termios)
TIOCSETA _IOW('t', 20, struct termios)
TIOCSETAW _IOW('t', 21, struct termios)
TIOCSETAF _IOW('t', 22, struct termios)
TIOCGETA_32 _IOR('t', 19, struct termios32)
TIOCSETA_32 _IOW('t', 20, struct termios32)
TIOCSETAW_32 _IOW('t', 21, struct termios32)
TIOCSETAF_32 _IOW('t', 22, struct termios32)
TIOCGETA_64 _IOR('t', 19, struct user_termios)
TIOCSETA_64 _IOW('t', 20, struct user_termios)
TIOCSETAW_64 _IOW('t', 21, struct user_termios)
TIOCSETAF_64 _IOW('t', 22, struct user_termios)
TIOCGETD _IOR('t', 26, int)
TIOCSETD _IOW('t', 27, int)
TIOCIXON _IO('t', 129)
TIOCIXOFF _IO('t', 128)
TIOCSBRK _IO('t', 123)
TIOCCBRK _IO('t', 122)
TIOCSDTR _IO('t', 121)
TIOCCDTR _IO('t', 120)
TIOCGPGRP _IOR('t', 119, int)
TIOCSPGRP _IOW('t', 118, int)
TIOCOUTQ _IOR('t', 115, int)
TIOCSTI _IOW('t', 114, char)
TIOCNOTTY _IO('t', 113)
TIOCPKT _IOW('t', 112, int)
TIOCPKT_DATA 0x00
TIOCPKT_FLUSHREAD 0x01
TIOCPKT_FLUSHWRITE 0x02
TIOCPKT_STOP 0x04
TIOCPKT_START 0x08
TIOCPKT_NOSTOP 0x10
TIOCPKT_DOSTOP 0x20
TIOCPKT_IOCTL 0x40
TIOCSTOP _IO('t', 111)
TIOCSTART _IO('t', 110)
TIOCMSET _IOW('t', 109, int)
TIOCMBIS _IOW('t', 108, int)
TIOCMBIC _IOW('t', 107, int)
TIOCMGET _IOR('t', 106, int)
TIOCGWINSZ _IOR('t', 104, struct winsize)
TIOCSWINSZ _IOW('t', 103, struct winsize)
TIOCUCNTL _IOW('t', 102, int)
TIOCSTAT _IO('t', 101)
UIOCCMD(n) _IO('u', n)
TIOCSCONS _IO('t', 99)
TIOCCONS _IOW('t', 98, int)
TIOCSCTTY _IO('t', 97)
TIOCEXT _IOW('t', 96, int)
TIOCSIG _IO('t', 95)
TIOCDRAIN _IO('t', 94)
TIOCMSDTRWAIT _IOW('t', 91, int)
TIOCMGDTRWAIT _IOR('t', 90, int)
TIOCTIMESTAMP _IOR('t', 89, struct timeval)
TIOCDCDTIMESTAMP _IOR('t', 88, struct timeval)
TIOCTIMESTAMP_32 _IOR('t', 89, struct user32_timeval)
TIOCDCDTIMESTAMP_32 _IOR('t', 88, struct user32_timeval)
TIOCTIMESTAMP_64 _IOR('t', 89, struct user64_timeval)
TIOCDCDTIMESTAMP_64 _IOR('t', 88, struct user64_timeval)
TIOCSDRAINWAIT _IOW('t', 87, int)
TIOCGDRAINWAIT _IOR('t', 86, int)
TIOCDSIMICROCODE _IO('t', 85)
TIOCPTYGRANT _IO('t', 84)
TIOCPTYGNAME _IOC(IOC_OUT, 't', 83, 128)
TIOCPTYUNLK _IO('t', 82)
TIOCREVOKE _IO('t', 81)
TIOCREVOKECLEAR _IO('t', 80)
TTYDISC 0
TABLDISC 3
SLIPDISC 4
PPPDISC 5
_SYS_TTYDEFAULTS_H_ None
CEOF CTRL('d')
CEOL 0xff
CERASE 0177
CINTR CTRL('c')
CSTATUS CTRL('t')
CKILL CTRL('u')
CMIN 1
CQUIT 034
CSUSP CTRL('z')
CTIME 0
CDSUSP CTRL('y')
CSTART CTRL('q')
CSTOP CTRL('s')
CLNEXT CTRL('v')
CDISCARD CTRL('o')
CWERASE CTRL('w')
CREPRINT CTRL('r')
CEOT CEOF
CBRK CEOL
CRPRNT CREPRINT
CFLUSH CDISCARD
_SYS_TTYDEV_H_ None
_SYS_TYPES_H_ None
_SYS_UBC_H_ None
UBC_PUSHDIRTY 0x01
UBC_PUSHALL 0x02
UBC_INVALIDATE 0x04
UBC_SYNC 0x08
_SYS_UBC_INTERNAL_H_ None
MAX_CLUSTERS CONFIG_MAX_CLUSTERS
SPARSE_PUSH_LIMIT 4
UI_NONE 0x00000000
UI_HASPAGER 0x00000001
UI_INITED 0x00000002
UI_HASOBJREF 0x00000004
UI_WASMAPPED 0x00000008
UI_ISMAPPED 0x00000010
UI_MAPBUSY 0x00000020
UI_MAPWAITING 0x00000040
UI_MAPPEDWRITE 0x00000080
UI_CSBLOBINVALID 0x00000100
UI_WASMAPPEDWRITE 0x00000200
UBC_FLAGS_NONE 0x0000
UBC_HOLDOBJECT 0x0001
UBC_FOR_PAGEOUT 0x0002
_SYS_UCONTEXT_H_ None
_SYS_UCRED_H_ None
_SYS_UIO_H_ None
UIO_MAXIOV 1024
UIO_SMALLIOV 8
_SYS_UIO_INTERNAL_H_ None
UIO_FLAGS_INITED 0x00000001
UIO_FLAGS_WE_ALLOCED 0x00000002
UIO_FLAGS_IS_COMPRESSED_FILE 0x00000004
P2ROUNDUP(x, align)     (-(-((long)x) & -((long)align)))
UIO_STACKBUF(name, niov) 	uint64_t name[P2ROUNDUP(UIO_SIZEOF(niov), sizeof(uint64_t)) 	    / sizeof(uint64_t)]
_SYS_ULOCK_H None
UL_COMPARE_AND_WAIT 1
UL_UNFAIR_LOCK 2
UL_COMPARE_AND_WAIT_SHARED 3
UL_UNFAIR_LOCK64_SHARED 4
UL_COMPARE_AND_WAIT64 5
UL_COMPARE_AND_WAIT64_SHARED 6
UL_OSSPINLOCK UL_COMPARE_AND_WAIT
UL_HANDOFFLOCK UL_UNFAIR_LOCK
UL_DEBUG_SIMULATE_COPYIN_FAULT 253
UL_DEBUG_HASH_DUMP_ALL 254
UL_DEBUG_HASH_DUMP_PID 255
ULF_WAKE_ALL 0x00000100
ULF_WAKE_THREAD 0x00000200
ULF_WAKE_ALLOW_NON_OWNER 0x00000400
ULF_WAIT_WORKQ_DATA_CONTENTION 0x00010000
ULF_WAIT_CANCEL_POINT 0x00020000
ULF_WAIT_ADAPTIVE_SPIN 0x00040000
ULF_NO_ERRNO 0x01000000
ULF_DEADLINE 0x02000000
UL_OPCODE_MASK 0x000000FF
UL_FLAGS_MASK 0xFFFFFF00
ULF_GENERIC_MASK 0xFFFF0000
_SYS_UN_H_ None
UNP_FORGE_PATH(sun, len) ({                                     	__unsafe_forge_bidi_indexable(char *, &sun->sun_path, len);     })
unicode_h None
_SYS_UNISTD_H_ None
_POSIX_VERSION 200112L
_POSIX2_VERSION 200112L
_POSIX_THREAD_KEYS_MAX 128
F_OK 0
_PC_LINK_MAX 1
_PC_MAX_CANON 2
_PC_MAX_INPUT 3
_PC_NAME_MAX 4
_PC_PATH_MAX 5
_PC_PIPE_BUF 6
_PC_CHOWN_RESTRICTED 7
_PC_NO_TRUNC 8
_PC_VDISABLE 9
_PC_2_SYMLINKS 15
_PC_ALLOC_SIZE_MIN 16
_PC_ASYNC_IO 17
_PC_FILESIZEBITS 18
_PC_PRIO_IO 19
_PC_REC_INCR_XFER_SIZE 20
_PC_REC_MAX_XFER_SIZE 21
_PC_REC_MIN_XFER_SIZE 22
_PC_REC_XFER_ALIGN 23
_PC_SYMLINK_MAX 24
_PC_SYNC_IO 25
_PC_XATTR_SIZE_BITS 26
_PC_MIN_HOLE_SIZE 27
_CS_PATH 1
_SYS_UNPCB_H_ None
_UCPCB_LIST_HEAD(name, type)    struct name {                           	u_int32_t	lh_first;       };
_UNPCB_LIST_ENTRY(x) struct _unpcb_list_entry
_UNPCB_PTR(x) u_int32_t
UNP_HAVEPC 0x00000001
UNP_HAVEPCCACHED 0x00000002
UNP_DONTDISCONNECT 0x00000004
UNP_NOPEERACCEPT 0x00000010
UNP_TRACE_MDNS 0x00001000
_SYS_USER_H_ None
_SYS_UTFCONV_H_ None
_SYS_UTSNAME_H None
_SYS_NAMELEN 256
_SYS_UX_EXCEPTION_H_ None
_SYS_VADVISE_H_ None
_SYS_VARIANT_INTERNAL_H_ None
OS_VARIANT_STATUS_INITIAL_BITS 0x70000000F0000000ULL
OS_VARIANT_STATUS_BIT_WIDTH 2
OS_VARIANT_STATUS_SET 0x2
OS_VARIANT_STATUS_MASK 0x3
_SYS_VCMD_H_ None
VPRINT 0100
VPLOT 0200
VPRINTPLOT 0400
VGETSTATE _IOR('v', 0, int)
VSETSTATE _IOW('v', 1, int)
_BSD_SYS_VFS_CONTEXT_H_ None
_SYS_VLIMIT_H_ None
LIM_NORAISE 0
LIM_CPU 1
LIM_FSIZE 2
LIM_DATA 3
LIM_STACK 4
LIM_CORE 5
LIM_MAXRSS 6
NLIMITS 6
INFINITY 0x7fffffff
_SYS_VM_H None
vm_startcopy vm_rssize
_SYS_VMMETER_H_ None
_SYS_VMPARAM_H_ None
_VNODE_H_ None
HAVE_VT_LOCKERFS 1
VNODE_READ 0x01
VNODE_WRITE 0x02
VNODE_BLOCKMAP_NO_TRACK 0x04
VNODE_CLUSTER_VERIFY 0x08
PREALLOCATE 0x00000001
ALLOCATECONTIG 0x00000002
ALLOCATEALL 0x00000004
ALLOCATEPERSIST 0x00000008
ALLOCATEFROMPEOF 0x00000010
ALLOCATEFROMVOL 0x00000020
IO_UNIT 0x0001
IO_APPEND 0x0002
IO_SYNC 0x0004
IO_NODELOCKED 0x0008
IO_NDELAY 0x0010
IO_NOZEROFILL 0x0020
IO_REVOKE IO_NOZEROFILL
IO_TAILZEROFILL 0x0040
IO_HEADZEROFILL 0x0080
IO_NOZEROVALID 0x0100
IO_NOZERODIRTY 0x0200
IO_CLOSE 0x0400
IO_NOCACHE 0x0800
IO_RAOFF 0x1000
IO_DEFWRITE 0x2000
IO_PASSIVE 0x4000
IO_BACKGROUND IO_PASSIVE
IO_NOAUTH 0x8000
IO_NODIRECT 0x10000
IO_ENCRYPTED 0x20000
IO_RETURN_ON_THROTTLE 0x40000
IO_SINGLE_WRITER 0x80000
IO_SYSCALL_DISPATCH 0x100000
IO_SWAP_DISPATCH 0x200000
IO_SKIP_ENCRYPTION 0x400000
IO_EVTONLY 0x800000
IO_NOCACHE_SYSSPACE 0x1000000
IO_NOCACHE_SWRITE 0x2000000
LOOKUP 0
CREATE 1
DELETE 2
RENAME 3
OPMASK 3
FOLLOW 0x00000040
ISDOTDOT 0x00002000
MAKEENTRY 0x00004000
ISLASTCN 0x00008000
VNFS_NOCACHE 0x01
VNFS_CANTCACHE 0x02
VNFS_ADDFSREF 0x04
VNCREATE_FLAVOR 0
VCREATESIZE sizeof(struct vnode_fsparam)
VNCREATE_TRIGGER_SIZE sizeof(struct vnode_trigger_param)
VATTR_INIT(v) do {(v)->va_supported = (v)->va_active = 0ll; (v)->va_vaflags = 0; } while(0)
VATTR_SET_ACTIVE(v, a)          ((v)->va_active |= VNODE_ATTR_ ## a)
VATTR_SET_SUPPORTED(v, a)       ((v)->va_supported |= VNODE_ATTR_ ## a)
VATTR_IS_SUPPORTED(v, a)        ((v)->va_supported & VNODE_ATTR_ ## a)
VATTR_CLEAR_ACTIVE(v, a)        ((v)->va_active &= ~VNODE_ATTR_ ## a)
VATTR_CLEAR_SUPPORTED(v, a)     ((v)->va_supported &= ~VNODE_ATTR_ ## a)
VATTR_IS_ACTIVE(v, a)           ((v)->va_active & VNODE_ATTR_ ## a)
VATTR_INACTIVE_SUPPORTED(v) do {(v)->va_active &= ~(v)->va_supported; (v)->va_supported = 0;} while(0)
VATTR_SET(v, a, x)              do { (v)-> a = (x); VATTR_SET_ACTIVE(v, a);} while(0)
VATTR_WANTED(v, a)              VATTR_SET_ACTIVE(v, a)
VATTR_RETURN(v, a, x)           do { (v)-> a = (x); VATTR_SET_SUPPORTED(v, a);} while(0)
VATTR_NOT_RETURNED(v, a)        (VATTR_IS_ACTIVE(v, a) && !VATTR_IS_SUPPORTED(v, a))
VATTR_IS(v, a, x)               (VATTR_IS_SUPPORTED(v, a) && (v)-> a == (x))
VATTR_IS_NOT(v, a, x)           (VATTR_IS_SUPPORTED(v, a) && (v)-> a != (x))
VA_DP_RAWENCRYPTED 0x0001
VA_DP_RAWUNENCRYPTED 0x0002
VA_DP_AUTHENTICATE 0x0004
VA_UTIMES_NULL 0x010000
VA_EXCLUSIVE 0x020000
VA_NOINHERIT 0x040000
VA_NOAUTH 0x080000
VA_64BITOBJIDS 0x100000
VA_REALFSID 0x200000
VA_USEFSID 0x400000
VA_FILESEC_ACL 0x800000
VSUID 0x800
VSGID 0x400
VSVTX 0x200
VREAD 0x100
VWRITE 0x080
VEXEC 0x040
MAKEIMODE(indx, mode)   (int)(VTTOIF(indx) | (mode))
SKIPSYSTEM 0x0001
FORCECLOSE 0x0002
WRITECLOSE 0x0004
SKIPSWAP 0x0008
SKIPROOT 0x0010
DOCLOSE 0x0008
V_SAVE 0x0001
V_SAVEMETA 0x0002
REVOKEALL 0x0001
VNODE_REMOVE_NODELETEBUSY 0x0001
VNODE_REMOVE_SKIP_NAMESPACE_EVENT 0x0002
VNODE_REMOVE_NO_AUDIT_PATH 0x0004
VNODE_REMOVE_DATALESS_DIR 0x0008
VNODE_REMOVE_NOFOLLOW_ANY 0x0010
VNODE_REMOVE_SYSTEM_DISCARDED 0x0020
VNODE_READDIR_EXTENDED 0x0001
VNODE_READDIR_REQSEEKOFF 0x0002
VNODE_READDIR_SEEKOFF32 0x0004
VNODE_READDIR_NAMEMAX 0x0008
VNODE_CLONEFILE_DEFAULT 0x0000
VNODE_CLONEFILE_NOOWNERCOPY 0x0001
VNODE_CREATE_DEFAULT VNODE_CREATE_DEFAULT
VNODE_ASYNC_THROTTLE 15
VNODE_EVENT_DELETE 0x00000001
VNODE_EVENT_WRITE 0x00000002
VNODE_EVENT_EXTEND 0x00000004
VNODE_EVENT_ATTRIB 0x00000008
VNODE_EVENT_LINK 0x00000010
VNODE_EVENT_RENAME 0x00000020
VNODE_EVENT_PERMS 0x00000040
VNODE_EVENT_FILE_CREATED 0x00000080
VNODE_EVENT_DIR_CREATED 0x00000100
VNODE_EVENT_FILE_REMOVED 0x00000200
VNODE_EVENT_DIR_REMOVED 0x00000400
VN_GETPATH_NEW 0x0
VN_GETPATH_FSENTER 0x0001
VN_GETPATH_NO_FIRMLINK 0x0002
VN_GETPATH_VOLUME_RELATIVE 0x0004
VN_GETPATH_NO_PROCROOT 0x0008
VN_GETPATH_CHECK_MOVED 0x0010
VNODE_UPDATE_PARENT 0x01
VNODE_UPDATE_NAMEDSTREAM_PARENT VNODE_UPDATE_PARENT
VNODE_UPDATE_NAME 0x02
VNODE_UPDATE_CACHE 0x04
VNODE_UPDATE_PURGE 0x08
VNODE_UPDATE_PURGEFIRMLINK 0x10
VNODE_UPDATE_FORCE_PARENT_REF 0x20
VNODE_ATTR_AUTHORIZE_AVAILABLE 0x01
VNODE_LOOKUP_NOFOLLOW 0x01
VNODE_LOOKUP_NOCROSSMOUNT 0x02
VNODE_LOOKUP_CROSSMOUNTNOWAIT 0x04
VNODE_LOOKUP_NOFOLLOW_ANY 0x08
VNODE_RELOAD 0x01
VNODE_WAIT 0x02
VNODE_WRITEABLE 0x04
VNODE_WITHID 0x08
VNODE_NOLOCK_INTERNAL 0x10
VNODE_NODEAD 0x20
VNODE_NOSUSPEND 0x40
VNODE_ITERATE_ALL 0x80
VNODE_ITERATE_ACTIVE 0x100
VNODE_ITERATE_INACTIVE 0x200
VNODE_ALWAYS 0x400
VNODE_DRAINO 0x800
VNODE_PAGER 0x1000
VNODE_NOBLOCK 0x2000
VNODE_WITHREF 0x4000
VNODE_RETURNED 0
VNODE_RETURNED_DONE 1
VNODE_CLAIMED 2
VNODE_CLAIMED_DONE 3
BUILDPATH_NO_FS_ENTER 0x1
BUILDPATH_CHECKACCESS 0x2
BUILDPATH_CHECK_MOVED 0x4
BUILDPATH_VOLUME_RELATIVE 0x8
BUILDPATH_NO_FIRMLINK 0x10
BUILDPATH_NO_PROCROOT 0x20
VNIO_SUPPORT_PRESENT None
CACHE_LOOKUP_ALLHITS 0x01
IOCS_BUFFER_NUM_SIZE_BUCKETS 10
IOCS_BUFFER_MAX_BUCKET 9
IOCS_BUFFER_NUM_COMPRESSION_BUCKETS 7
IOCS_BLOCK_NUM_SIZE_BUCKETS 16
IOCS_SBE_PATH_LEN 128
IOCS_PATH_START_BYTES_TO_COPY 108
IOCS_PATH_END_BYTES_TO_COPY 20
IOCS_SYSCTL_LIVE 0x00000001
IOCS_SYSCTL_STORE_BUFFER_RD_ONLY 0x00000002
IOCS_SYSCTL_STORE_BUFFER_MARK 0x00000004
_SYS_VNODE_IF_H_ None
COMPOUND_OPEN_STATUS_DID_CREATE 0x00000001
VNODE_MONITOR_BEGIN 0x01
VNODE_MONITOR_END 0x02
VNODE_MONITOR_UPDATE 0x04
_SYS_VNODE_INTERNAL_H_ None
v_mountedhere v_un.vu_mountedhere
v_socket v_un.vu_socket
v_specinfo v_un.vu_specinfo
v_fifoinfo v_un.vu_fifoinfo
v_ubcinfo v_un.vu_ubcinfo
VBI_ITER 0x1
VBI_ITERWANT 0x2
VBI_CLEAN 0x4
VBI_DIRTY 0x8
VBI_NEWBUF 0x10
VLIST_RAGE 0x01
VLIST_DEAD 0x02
VLIST_ASYNC_WORK 0x04
VLIST_NO_REUSE 0x08
VL_SUSPENDED 0x0001
VL_DRAIN 0x0002
VL_TERMINATE 0x0004
VL_TERMWANT 0x0008
VL_DEAD 0x0010
VL_MARKTERM 0x0020
VL_OPSCHANGE 0x0040
VL_NEEDINACTIVE 0x0080
VL_LABEL 0x0100
VL_LABELWAIT 0x0200
VL_LABELED 0x0400
VL_LWARNED 0x0800
VL_HASSTREAMS 0x1000
VNAMED_UBC 0x2000
VNAMED_MOUNT 0x4000
VNAMED_FSHASH 0x8000
VROOT 0x000001
VTEXT 0x000002
VSYSTEM 0x000004
VISTTY 0x000008
VRAGE 0x000010
VBDEVVP 0x000020
VDEVFLUSH 0x000040
VMOUNT 0x000080
VBWAIT 0x000100
VSHARED_DYLD 0x000200
VNOCACHE_DATA 0x000400
VSTANDARD 0x000800
VAGE 0x001000
VRAOFF 0x002000
VNCACHEABLE 0x004000
VSWAP 0x010000
VTHROTTLED 0x020000
VNOFLUSH 0x040000
VLOCKLOCAL 0x080000
VISHARDLINK 0x100000
VISUNION 0x200000
VISNAMEDSTREAM 0x400000
VOPENEVT 0x800000
VCANDEALLOC 0x1000000
VNOCS 0x2000000
VISDIRTY 0x4000000
VFASTDEVCANDIDATE 0x8000000
VAUTOCANDIDATE 0x10000000
VFMLINKTARGET 0x20000000
VMOUNTEDHERE 0x40000000
VE_LINKCHANGE 0x01
VE_LINKCHANGEWAIT 0x02
FV_DIRBUF_START_SIZ FV_DIRBUF_DIRENTRY_SIZ
FV_LOCK(fvd) lck_mtx_lock(&(((struct fd_vn_data *)fvd)->fv_lock))
FV_UNLOCK(fvd) lck_mtx_unlock(&(((struct fd_vn_data *)fvd)->fv_lock))
VDESC_MAX_VPS 16
VDESC_VP0_WILLRELE 0x00001
VDESC_VP1_WILLRELE 0x00002
VDESC_VP2_WILLRELE 0x00004
VDESC_VP3_WILLRELE 0x00008
VDESC_NOMAP_VPP 0x00100
VDESC_VPP_WILLRELE 0x00200
VDESC_DISABLED 0x10000
VDESC_NO_OFFSET -1
VOPARG_OFFSET(p_type, field) 	((int) (((char *) (&(((p_type)NULL)->field))) - ((char *) NULL)))
VOPARG_OFFSETOF(s_type, field) 	VOPARG_OFFSET(s_type*,field)
VOPARG_OFFSETTO(S_TYPE, S_OFFSET, STRUCT_P) 	((S_TYPE)(((char*)(STRUCT_P))+(S_OFFSET)))
VOCALL(OPSV, OFF, AP) (( *((OPSV)[(OFF)])) (AP))
VCALL(VP, OFF, AP) VOCALL((VP)->v_op,(OFF),(AP))
post_event_if_success(_vp, _error, _event) 	do { 	        if (0 == (_error)) {    	                lock_vnode_and_post((_vp), (_event)); 	        } 	} while (0)
vnode_lock_convert(v) lck_mtx_convert_spin(&(v)->v_lock)
VNODE_REF_FORCE 0x1
COMPOUND_VNOP_OPEN 0x01
COMPOUND_VNOP_MKDIR 0x02
COMPOUND_VNOP_RENAME 0x04
COMPOUND_VNOP_REMOVE 0x08
COMPOUND_VNOP_RMDIR 0x10
VFS_SMR_DECLARE extern smr_t vfs_smr
VFS_SMR() vfs_smr
vfs_smr_enter() smr_enter(VFS_SMR())
vfs_smr_leave() smr_leave(VFS_SMR())
vfs_smr_synchronize() smr_synchronize(VFS_SMR())
_VSOCK_H_ None
VMADDR_CID_HYPERVISOR 0
VMADDR_CID_RESERVED 1
VMADDR_CID_HOST 2
IOCTL_VM_SOCKETS_GET_LOCAL_CID _IOR('s',  209, uint32_t)
_VSOCK_DOMAIN_H_ None
_VSOCK_TRANSPORT_H_ None
VSOCK_MAX_PACKET_SIZE 65536
_SYS_VSTAT_H_ None
_SYS_WAIT_H_ None
WNOHANG 0x00000001
WUNTRACED 0x00000002
_WSTOPPED 0177
WEXITED 0x00000004
WCONTINUED 0x00000010
WNOWAIT 0x00000020
_SYS_WORK_INTERVAL_H None
WORK_INTERVAL_OPERATION_CREATE 0x00000001
WORK_INTERVAL_OPERATION_DESTROY 0x00000002
WORK_INTERVAL_OPERATION_NOTIFY 0x00000003
WORK_INTERVAL_OPERATION_CREATE2 0x00000004
WORK_INTERVAL_OPERATION_JOIN 0x00000005
WORK_INTERVAL_OPERATION_GET_FLAGS 0x00000009
WORK_INTERVAL_OPERATION_SET_NAME 0x0000000a
WORK_INTERVAL_OPERATION_SET_WORKLOAD_ID 0x0000000b
WORK_INTERVAL_NAME_MAX 32
WORK_INTERVAL_WORKLOAD_ID_NAME_MAX 64
_SYS_XATTR_H_ None
XATTR_NOFOLLOW 0x0001
XATTR_CREATE 0x0002
XATTR_REPLACE 0x0004
XATTR_NOSECURITY 0x0008
XATTR_NODEFAULT 0x0010
XATTR_SHOWCOMPRESSION 0x0020
XATTR_NOFOLLOW_ANY 0x0040
XATTR_MAXNAMELEN 127
XATTR_FINDERINFO_NAME "com.apple.FinderInfo"
XATTR_RESOURCEFORK_NAME "com.apple.ResourceFork"
XATTR_MAXSIZE INT32_MAX
AD_XATTR_MAXSIZE XATTR_MAXSIZE
AD_XATTR_SIZE_BITS 31
_SYS__ENDIAN_H_ None
_SYS__SELECT_H_ None
_SYS__TYPES_H_ None
USE_CLANG_TYPES 0
__DARWIN_NULL NULL
_SYS___ENDIAN_H_ None
__DARWIN_LITTLE_ENDIAN 1234
__DARWIN_BIG_ENDIAN 4321
__DARWIN_PDP_ENDIAN 3412
_UUID_UUID_H None
_UUID_STRING_T None
UUID_DEFINE(name, u0, u1, u2, u3, u4, u5, u6, u7, u8, u9, u10, u11, u12, u13, u14, u15) 	static const uuid_t name __attribute__ ((unused)) = {u0,u1,u2,u3,u4,u5,u6,u7,u8,u9,u10,u11,u12,u13,u14,u15}
ESUCCESS 0
COMPAT_ONLY None
VFS_CONTEXT_SET_REFERENCED_THREAD(ctx, thr) 	(ctx)->vc_thread = (thread_t)(((uintptr_t)(thr)) | 1UL)
ATTR_TIME_SIZE -1
_ATTRLIST_BUF_INIT(a) do {(a)->base = (a)->fixedcursor = (a)->varcursor = NULL; (a)->allocated = (a)->needed = 0l; ATTRIBUTE_SET_INIT(&((a)->actual)); ATTRIBUTE_SET_INIT(&((a)->valid));} while(0)
ATTR_PACK4(AB, V)                                                 	do {                                                              	        if ((AB.allocated - (AB.fixedcursor - AB.base)) >= 4) {   	                *(uint32_t *)AB.fixedcursor = V;                  	                AB.fixedcursor += 4;                              	        }                                                         	} while (0)
ATTR_PACK8(AB, V)                                                 	do {                                                              	        if ((AB.allocated - (AB.fixedcursor - AB.base)) >= 8) {   	                memcpy(AB.fixedcursor, &V, 8);                    	                AB.fixedcursor += 8;                              	        }                                                         	} while (0)
ATTR_PACK(b, v) attrlist_pack_fixed(b, &v, sizeof(v))
ATTR_PACK_CAST(b, t, v)                                         	do {                                                            	        t _f = (t)v;                                            	        ATTR_PACK(b, _f);                                       	} while (0)
ATTR_PACK_TIME(b, v, is64)                                                      	do {                                                                            	        if (is64) {                                                             	                struct user64_timespec us = {.tv_sec = v.tv_sec, .tv_nsec = v.tv_nsec};         	                ATTR_PACK(&b, us);                                              	        } else {                                                                	                struct user32_timespec us = {.tv_sec = (user32_time_t)v.tv_sec, .tv_nsec = (user32_long_t)v.tv_nsec};         	                ATTR_PACK(&b, us);                                              	        }                                                                       	} while(0)
ATTR_UNPACK(v) do {if ((error = attrlist_unpack_fixed(&cursor, bufend, &v, sizeof(v))) != 0) goto out;} while(0);
ATTR_UNPACK_CAST(t, v)  do { t _f; ATTR_UNPACK(_f); v = (typeof(v))_f;} while(0)
ATTR_UNPACK_TIME(v, is64)                               	do {                                                    	        if (is64) {                                     	                struct user64_timespec us;              	                ATTR_UNPACK(us);                        	                v.tv_sec = (unsigned long)us.tv_sec;                   	                v.tv_nsec = (long)us.tv_nsec;                 	        } else {                                        	                struct user32_timespec us;              	                ATTR_UNPACK(us);                        	                v.tv_sec = us.tv_sec;                   	                v.tv_nsec = us.tv_nsec;                 	        }                                               	} while(0)
BUFHASH(dvp, lbn)       	(&bufhashtbl[((long)(dvp) / sizeof(*(dvp)) + (int)(lbn)) & bufhash])
FS_BUFFER_CACHE_GC_CALLOUTS_MAX_SIZE 16
binsheadfree(bp, dp, whichq)    do { 	                            TAILQ_INSERT_HEAD(dp, bp, b_freelist); 	                        } while (0)
binstailfree(bp, dp, whichq)    do { 	                            TAILQ_INSERT_TAIL(dp, bp, b_freelist); 	                        } while (0)
BHASHENTCHECK(bp) if ((bp)->b_hash.le_prev != (struct buf **)0xdeadbeef)  	        panic("%p: b_hash.le_prev is not deadbeef", (bp));
bufinsvn(bp, dp)        LIST_INSERT_HEAD(dp, bp, b_vnbufs)
bufremvn(bp) {                                                  	LIST_REMOVE(bp, b_vnbufs);                                      	(bp)->b_vnbufs.le_next = NOLIST;                                }
LRU_IS_STALE 120
AGE_IS_STALE 60
META_IS_STALE 180
MAXLAUNDRY 10
MINMETA 512
MAXMETA 16384
NRESERVEDIOBUFS 128
MNT_VIRTUALDEV_MAX_IOBUFS 128
NAME_CACHE_LOCK() name_cache_lock()
NAME_CACHE_UNLOCK() name_cache_unlock()
NUM_STRCACHE_LOCKS 1024
NCHHASH(dvp, hash_val) 	(&nchashtbl[(dvp->v_id ^ (hash_val)) & nchashmask])
MAX_ERROR_RETRY 3
CL_READ 0x01
CL_WRITE 0x02
CL_ASYNC 0x04
CL_COMMIT 0x08
CL_PAGEOUT 0x10
CL_AGE 0x20
CL_NOZERO 0x40
CL_PAGEIN 0x80
CL_DEV_MEMORY 0x100
CL_PRESERVE 0x200
CL_THROTTLE 0x400
CL_KEEPCACHED 0x800
CL_DIRECT_IO 0x1000
CL_PASSIVE 0x2000
CL_IOSTREAMING 0x4000
CL_CLOSE 0x8000
CL_ENCRYPTED 0x10000
CL_RAW_ENCRYPTED 0x20000
CL_NOCACHE 0x40000
CL_DIRECT_IO_FSBLKSZ 0x80000
CL_DIRECT_READ_LOCK_BUCKETS 61
IO_UNKNOWN 0
IO_DIRECT 1
IO_CONTIG 2
IO_COPY 3
PUSH_DELAY 0x01
PUSH_ALL 0x02
PUSH_SYNC 0x04
MAX_IO_CONTIG_SIZE MAX_UPL_SIZE_BYTES
MAX_VECTS 16
WRITE_THROTTLE 6
WRITE_THROTTLE_SSD 2
WRITE_BEHIND 1
WRITE_BEHIND_SSD 1
IO_SCALE(vp, base)              (vp->v_mount->mnt_ioscale * (base))
THROTTLE_MAXCNT 0
MAX_VERIFY_THREADS 4
MAX_REQUESTS_PER_THREAD 2
CLW_ALLOCATE 0x01
CLW_RETURNLOCKED 0x02
CLW_IONOCACHE 0x04
CLW_IOPASSIVE 0x08
reset_vector_run_state() issueVectorUPL = vector_upl_offset = vector_upl_index = vector_upl_iosize = vector_upl_size = 0;
DRT_HASH_GET_ADDRESS(scm, i)    ((scm)->scm_hashtable[(i)].dhe_control & DRT_ADDRESS_MASK)
DRT_HASH_SET_ADDRESS(scm, i, a)                                                                 	do {                                                                                            	        (scm)->scm_hashtable[(i)].dhe_control =                                                 	            ((scm)->scm_hashtable[(i)].dhe_control & ~DRT_ADDRESS_MASK) | DRT_ALIGN_ADDRESS(a); 	} while (0)
DRT_HASH_COUNT_MASK 0x1ff
DRT_HASH_GET_COUNT(scm, i)      ((scm)->scm_hashtable[(i)].dhe_control & DRT_HASH_COUNT_MASK)
DRT_HASH_SET_COUNT(scm, i, c)                                                                                   	do {                                                                                                            	        (scm)->scm_hashtable[(i)].dhe_control =                                                                 	            ((scm)->scm_hashtable[(i)].dhe_control & ~DRT_HASH_COUNT_MASK) | ((c) & DRT_HASH_COUNT_MASK);       	} while (0)
DRT_HASH_CLEAR(scm, i)                                                                                          	do {                                                                                                            	        (scm)->scm_hashtable[(i)].dhe_control =	0;                                                              	} while (0)
DRT_HASH_VACATE(scm, i)         DRT_HASH_SET_COUNT((scm), (i), DRT_HASH_COUNT_MASK)
DRT_HASH_VACANT(scm, i)         (DRT_HASH_GET_COUNT((scm), (i)) == DRT_HASH_COUNT_MASK)
DRT_HASH_COPY(oscm, oi, scm, i)                                                                 	do {                                                                                            	        (scm)->scm_hashtable[(i)].dhe_control = (oscm)->scm_hashtable[(oi)].dhe_control;        	        DRT_BITVECTOR_COPY(oscm, oi, scm, i);                                                   	} while(0);
DRT_HASH_SET_BIT(scm, i, bit)                           	(scm)->scm_hashtable[(i)].dhe_bitvector[(bit) / 32] |= (1 << ((bit) % 32))
DRT_HASH_CLEAR_BIT(scm, i, bit)                         	(scm)->scm_hashtable[(i)].dhe_bitvector[(bit) / 32] &= ~(1 << ((bit) % 32))
DRT_HASH_TEST_BIT(scm, i, bit)                          	((scm)->scm_hashtable[(i)].dhe_bitvector[(bit) / 32] & (1 << ((bit) % 32)))
DRT_BITVECTOR_CLEAR(scm, i)                             	bzero(&(scm)->scm_hashtable[(i)].dhe_bitvector[0], (MAX_DRT_BITVECTOR_PAGES / 32) * sizeof(u_int32_t))
DRT_BITVECTOR_COPY(oscm, oi, scm, i)                    	bcopy(&(oscm)->scm_hashtable[(oi)].dhe_bitvector[0],    	    &(scm)->scm_hashtable[(i)].dhe_bitvector[0],        	    (MAX_DRT_BITVECTOR_PAGES / 32) * sizeof(u_int32_t))
DRT_SCM_MAGIC 0x12020003
DRT_HASH(scm, addr)             ((addr) % (scm)->scm_modulus)
DRT_HASH_NEXT(scm, addr)        (((addr) + 1) % (scm)->scm_modulus)
PTR_ADD(type, base, offset)             (type)((uintptr_t)(base) + (offset))
DISK_CONDITIONER_SET_ENTITLEMENT "com.apple.private.dmc.set"
_VFS_DISK_CONDITIONER_H_ None
OV_EXCLAVE_BASE 1
OV_FORCE_ENOSPC 2
ROOT_DIR_INO_NUM 2
VFS_EXCLAVE_FS_BASE_DIR_GRAFT 1
VFS_EXCLAVE_FS_BASE_DIR_SEALED 2
REGFSTAG_HASH_WIDTH 32
HASHFUNC(dev, file_id) (((dev) + (file_id)) & open_vnodes_hashmask)
OPEN_VNODES_HASH(dev, file_id) (&open_vnodes_hashtbl[HASHFUNC(dev, file_id)])
_VFS_EXCLAVE_FS_H_ None
EXCLAVE_FS_BASEDIR_ROOT_ID 0
EXCLAVE_FS_SYNC_OP_BARRIER 0
EXCLAVE_FS_SYNC_OP_FULL 1
EXCLAVE_FS_SYNC_OP_UBC 2
EXCLAVE_FS_REGISTER_ENTITLEMENT "com.apple.private.vfs.exclave-fs-register"
APFS_VOLUME_OBJECT "AppleAPFSVolume"
kAPFSVolGroupUUIDKey "VolGroupUUID"
BSD_HOST 1
SIZE_COMPRESSION_DIST_SIZE_BUCKET_MIN 4096
IOCS_INDEX_MAP_OFFSET 11
_MISCFS_SPECFS_IO_COMPRESSION_STATS_H_ None
IOCS_STORE_BUFFER_NUM_SLOTS 10000
VOLFS_MIN_PATH_LEN 9
RESOLVE_NOFOLLOW_ANY 0x00000001
RESOLVE_CHECKED 0x80000000
DQHASH(dqvp, id) 	(&dqhashtbl[((((intptr_t)(dqvp)) >> 8) + id) & dqhash])
DQUOTINC 5
RAGE_LIMIT_MIN 100
RAGE_TIME_LIMIT 5
PLATFORM_DATA_VOLUME_MOUNT_POINT "/System/Volumes/Data"
PLATFORM_PREBOOT_VOLUME_MOUNT_POINT "/System/Volumes/Preboot"
PLATFORM_RECOVERY_VOLUME_MOUNT_POINT "/System/Volumes/Recovery"
VLISTNONE(vp) do {    	        (vp)->v_freelist.tqe_next = (struct vnode *)0;  	        (vp)->v_freelist.tqe_prev = (struct vnode **)0xdeadb;   	} while(0)
VREMFREE(fun, vp)       	do {    	        VLISTCHECK((fun), (vp), "free");        	        TAILQ_REMOVE(&vnode_free_list, (vp), v_freelist);       	        VLISTNONE((vp));        	        freevnodes--;   	        reusablevnodes--;    	} while(0)
VREMDEAD(fun, vp)       	do {    	        VLISTCHECK((fun), (vp), "dead");        	        TAILQ_REMOVE(&vnode_dead_list, (vp), v_freelist);       	        VLISTNONE((vp));        	        vp->v_listflag &= ~VLIST_DEAD;  	        deadvnodes--;   	        if (vp->v_listflag & VLIST_NO_REUSE) {        	                deadvnodes_noreuse--;        	        }        	} while(0)
VREMASYNC_WORK(fun, vp) 	do {    	        VLISTCHECK((fun), (vp), "async_work");  	        TAILQ_REMOVE(&vnode_async_work_list, (vp), v_freelist); 	        VLISTNONE((vp));        	        vp->v_listflag &= ~VLIST_ASYNC_WORK;    	        async_work_vnodes--;    	        if (!(vp->v_listflag & VLIST_NO_REUSE)) {        	                reusablevnodes--;    	        }        	} while(0)
VREMRAGE(fun, vp)       	do {    	        if ( !(vp->v_listflag & VLIST_RAGE))                    	                panic("VREMRAGE: vp not on rage list");         	        VLISTCHECK((fun), (vp), "rage");                        	        TAILQ_REMOVE(&vnode_rage_list, (vp), v_freelist);       	        VLISTNONE((vp));                	        vp->v_listflag &= ~VLIST_RAGE;  	        ragevnodes--;                   	        reusablevnodes--;    	} while(0)
AFPFS_VFS_CTL_GETID 0x00020001
AFPFS_VFS_CTL_NETCHANGE 0x00020002
AFPFS_VFS_CTL_VOLCHANGE 0x00020003
SMBFS_SYSCTL_REMOUNT 1
SMBFS_SYSCTL_REMOUNT_INFO 2
SMBFS_SYSCTL_GET_SERVER_SHARE 3
__SHIFT_OR_CLIP(x, s)   ((((x) >> (s)) > INT_MAX) ? INT_MAX : ((x) >> (s)))
MAX_WALK_COUNT 1000
UNAGE_THRESHHOLD 25
UNAGE_DIRTYTHRESHHOLD 6
VATTR_PREPARE_DEFAULTED_UID 0x1
VATTR_PREPARE_DEFAULTED_GID 0x2
VATTR_PREPARE_DEFAULTED_MODE 0x4
UIO_BUFF_SIZE 2048
_VFS_VFS_SUPPORT_H_ None
APFSIOC_REVERT_TO_SNAPSHOT _IOW('J', 1, u_int64_t)
MAX_AUTHORIZE_ENOENT_RETRIES 1024
MAX_RENAME_ERECYCLE_RETRIES 1024
MAX_LINK_ENOENT_RETRIES 1024
MAX_MOUNT_RETRIES 10
MAX_GRAFT_METADATA_SIZE 16384
GRAFTDMG_ENTITLEMENT "com.apple.private.vfs.graftdmg"
MAX_NESTED_UNION_MOUNTS 10
ROLE_ACCOUNT_UNMOUNT_ENTITLEMENT "com.apple.private.vfs.role-account-unmount"
SYSTEM_VOLUME_UNMOUNT_ENTITLEMENT "com.apple.private.vfs.system-volume-unmount"
SYNC_THREAD_RUN 0x0001
SYNC_THREAD_RUNNING 0x0002
PATHSTATICBUFLEN 256
PIVOT_ROOT_ENTITLEMENT "com.apple.private.vfs.pivot-root"
OPEN_BY_ID_ENTITLEMENT "com.apple.private.vfs.open-by-id"
ACCESSX_MAX_DESCR_ON_STACK 10
CLONE_SNAPSHOT_FALLBACKS_ENABLED 1
REVOKE_MOUNTED_DEVICE_ENTITLEMENT "com.apple.private.vfs.revoke-mounted-device"
DATALESS_RESOLVER_ENTITLEMENT "com.apple.private.vfs.dataless-resolver"
DATALESS_MANIPULATION_ENTITLEMENT "com.apple.private.vfs.dataless-manipulation"
SET_PACKAGE_EXTENSION_ENTITLEMENT "com.apple.private.kernel.set-package-extensions"
STK_PARAMS 128
FILESEC_ACCESS_ENTITLEMENT "com.apple.private.vfs.filesec-access"
__SHIFT_OR_CLIP(x, s)   ((((x) >> (s)) > INT_MAX) ? INT_MAX : ((x) >> (s)))
STATIC_UNLESS_TEST static
U8_MASK_LEAD_BYTE_LOC(leadByte, countTrailBytes) ((leadByte)&=(1<<(6-(countTrailBytes)))-1)
vfs_unicode_data_h None
UCS_ALT_NULL 0x2400
SP_HALF_SHIFT 10
SP_HALF_BASE 0x0010000u
SP_HALF_MASK 0x3FFu
SP_HIGH_FIRST 0xD800u
SP_HIGH_LAST 0xDBFFu
SP_LOW_FIRST 0xDC00u
SP_LOW_LAST 0xDFFFu
HANGUL_SBASE 0xAC00
HANGUL_LBASE 0x1100
HANGUL_VBASE 0x1161
HANGUL_TBASE 0x11A7
HANGUL_SCOUNT 11172
HANGUL_LCOUNT 19
HANGUL_VCOUNT 21
HANGUL_TCOUNT 28
MAX_SFM2MAC 0x29
SFMCODE_PREFIX_MASK 0xf000
RETRY_NO_YIELD_COUNT 5
MAX_BATCH_TO_TRIM 256
ROUTE_ONLY 0x10
_VM_PAGER_ None
PAGER_SUCCESS 0
PAGER_ABSENT 1
PAGER_ERROR 2
_SR_FILE_MAPPINGS_MAX_FILES 256
_VNODE_PAGER_ 1
MAXPAGERFILES 16
MAX_BACKING_STORE 100
INDEX_NULL 0
_BLKCNT_T None
_BLKSIZE_T None
_CADDR_T None
_CLOCK_T None
_CT_RUNE_T None
_DEV_T None
_ERRNO_T None
FD_CLR(n, p)    __DARWIN_FD_CLR(n, p)
FD_COPY(f, t)   __DARWIN_FD_COPY(f, t)
_FD_SET None
__DARWIN_NBBY 8
__DARWIN_howmany(x, y)  ((((x) % (y)) == 0) ? ((x) / (y)) : (((x) / (y)) + 1))
__DARWIN_FD_SET(n, p)   __darwin_fd_set((n), (p))
__DARWIN_FD_CLR(n, p)   __darwin_fd_clr((n), (p))
__DARWIN_FD_ISSET(n, p) __darwin_fd_isset((n), (p))
__DARWIN_FD_COPY(f, t)  bcopy(f, t, sizeof(*(f)))
FD_ISSET(n, p)  __DARWIN_FD_ISSET(n, p)
FD_SET(n, p)    __DARWIN_FD_SET(n, p)
FD_SETSIZE __DARWIN_FD_SETSIZE
FD_ZERO(p) __DARWIN_FD_ZERO(p)
_FILESEC_T None
_FSBLKCNT_T None
_FSFILCNT_T None
_FSID_T None
_FSOBJ_ID_T None
_GID_T None
_GRAFTDMG_UN_ None
GRAFTDMG_SECURE_BOOT_CRYPTEX_ARGS_VERSION 1
MAX_GRAFT_ARGS_SIZE 512
SBC_PRESERVE_MOUNT 0x0001
SBC_ALTERNATE_SHARED_REGION 0x0002
SBC_SYSTEM_CONTENT 0x0004
SBC_PANIC_ON_AUTHFAIL 0x0008
SBC_STRICT_AUTH 0x0010
SBC_PRESERVE_GRAFT 0x0020
_KAUTH_GUID None
KAUTH_GUID_SIZE 16
_GUID_T None
_ID_T None
_INO64_T None
_INO_T None
_INT16_T None
_INT32_T None
_INT64_T None
_INT8_T None
_INTPTR_T None
_IN_ADDR_T None
_IN_PORT_T None
_STRUCT_IOVEC None
_KEY_T None
_MACH_PORT_T None
_MBSTATE_T None
_MODE_T None
_MOUNT_T None
_NLINK_T None
USE_CLANG_STDDEF 0
__NULL None
__need_NULL None
USE_CLANG_STDDEF 0
__OFFSETOF None
__need_offsetof None
_OFF_T None
O_DSYNC 0x400000
O_SYNC 0x0080
_PID_T None
USE_CLANG_STDDEF 0
__PTRDIFF_T None
__need_ptrdiff_t None
USE_CLANG_STDDEF 0
__RSIZE_T None
__need_rsize_t None
_RUNE_T None
_SA_FAMILY_T None
_SEEK_SET_H_ None
SEEK_SET 0
SEEK_CUR 1
SEEK_END 2
SEEK_HOLE 3
SEEK_DATA 4
_SIGSET_T None
USE_CLANG_STDDEF 0
__SIZE_T None
__need_size_t None
_SOCKLEN_T None
_SSIZE_T None
_SUSECONDS_T None
S_IFMT 0170000
S_IFIFO 0010000
S_IFCHR 0020000
S_IFDIR 0040000
S_IFBLK 0060000
S_IFREG 0100000
S_IFLNK 0120000
S_IFSOCK 0140000
S_IRWXU 0000700
S_IRUSR 0000400
S_IWUSR 0000200
S_IXUSR 0000100
S_IRWXG 0000070
S_IRGRP 0000040
S_IWGRP 0000020
S_IXGRP 0000010
S_IRWXO 0000007
S_IROTH 0000004
S_IWOTH 0000002
S_IXOTH 0000001
S_ISUID 0004000
S_ISGID 0002000
S_ISVTX 0001000
_STRUCT_TIMESPEC struct timespec
_STRUCT_TIMEVAL struct timeval
_STRUCT_TIMEVAL32 struct timeval32
_STRUCT_TIMEVAL64 None
_TIME_T None
_UID_T None
_UINTPTR_T None
_USECONDS_T None
_STRUCT_USER32_ITIMERVAL struct user32_itimerval
_STRUCT_USER32_NTPTIMEVAL struct user32_ntptimeval
_STRUCT_USER32_TIMESPEC struct user32_timespec
_STRUCT_USER32_TIMEVAL struct user32_timeval
_STRUCT_USER32_TIMEX struct user32_timex
_STRUCT_USER64_ITIMERVAL struct user64_itimerval
_STRUCT_USER64_NTPTIMEVAL struct user64_ntptimeval
_STRUCT_USER64_TIMESPEC struct user64_timespec
_STRUCT_USER64_TIMEVAL struct user64_timeval
_STRUCT_USER64_TIMEX struct user64_timex
_STRUCT_USER_TIMESPEC struct user_timespec
_STRUCT_USER_TIMEVAL struct user_timeval
_UUID_T None
_U_CHAR None
_U_INT None
_U_INT16_T None
_U_INT32_T None
_U_INT64_T None
_U_INT8_T None
_U_SHORT None
_VA_LIST_T None
USE_CLANG_STDARG 0
__need_va_list None
_VNODE_T None
USE_CLANG_STDDEF 0
__WCHAR_T None
__need_wchar_t None
_WINT_T None
KEV_EVTID(code) BSDDBG_CODE(DBG_BSD_KEVENT, (code))
CH_MIT_IVAL_MIN NSEC_PER_USEC
SKMEM_TAG_CH_KEY "com.apple.skywalk.channel.key"
want_tx want[NR_TX]
want_rx want[NR_RX]
KRING_EMPTY_TX(_kring, _index)  	((_kring)->ckr_rhead == (_index))
KRING_FULL_RX(_kring, _index)                                   	((_kring)->ckr_khead == SLOT_NEXT((_index), (_kring)->ckr_lim))
KR_TRANSFER_DECAY 2
KR_ACCUMULATE_INTERVAL 2
KR_EWMA(old, new, decay) do {                                   	u_int64_t _avg;                                                 	if (__probable((_avg = (old)) > 0))                             	        _avg = (((_avg << (decay)) - _avg) + (new)) >> (decay); 	else                                                            	        _avg = (new);                                           	(old) = _avg;                                                   } while (0)
_BUF_DLIM(_buf, _pp)    (BUFLET_HAS_LARGE_BUF(_buf) ?           	PP_BUF_SIZE_LARGE(_pp) : PP_BUF_SIZE_DEF(_pp))
NM_FAIL_ON(t, reason) if (__improbable(t)) { SK_ERR("fail " #t); 	err_reason = reason; goto error; }
_KR_TXRING_VALIDATE(_kring, _ring, _kh, _kt, _rh, _krt) do {	slot_idx_t _n = (_kring)->ckr_num_slots;                        	                                      	NM_FAIL_ON((_kh) >= _n || kring->ckr_rhead >= _n || (_krt) >= _n || 	    (_kt) >= _n, SKYWALK_KILL_REASON_BASIC_SANITY);             	                                  	NM_FAIL_ON((_rh) >= _n, SKYWALK_KILL_REASON_BASIC_SANITY);      	                                                             	if ((_krt) >= kring->ckr_rhead) {                               	               	        NM_FAIL_ON((_rh) < kring->ckr_rhead || (_rh) > (_krt),  	            SKYWALK_KILL_REASON_HEAD_OOB);                      	} else {                        	       	        NM_FAIL_ON((_rh) > (_krt) && (_rh) < kring->ckr_rhead,  	            SKYWALK_KILL_REASON_HEAD_OOB_WRAPPED);              	}                                                               	NM_FAIL_ON(ring->ring_tail != (_krt),                           	    SKYWALK_KILL_REASON_TAIL_MISMATCH);                         } while (0)
_KR_RXRING_VALIDATE(_kring, _ring, _kh, _kt, _rh)       do {    	slot_idx_t _n = (_kring)->ckr_num_slots;                        	                                      	NM_FAIL_ON((_kh) >= _n || (_kt) >= _n,                          	    SKYWALK_KILL_REASON_BASIC_SANITY);                          	                                        	if ((_kt) >= (_kh)) {                                           	                       	        NM_FAIL_ON((_rh) < (_kh) || (_rh) > (_kt),              	            SKYWALK_KILL_REASON_HEAD_OOB);                      	} else {                                                        	                 	        NM_FAIL_ON((_rh) < (_kh) && (_rh) > (_kt),              	            SKYWALK_KILL_REASON_HEAD_OOB_WRAPPED);              	}                                                               	NM_FAIL_ON((_ring)->ring_tail != (_kring)->ckr_rtail,           	    SKYWALK_KILL_REASON_TAIL_MISMATCH);                         } while (0)
USER_ADDR_TO_PTR(chan_init) __unsafe_forge_bidi_indexable(void *, (chan_init).ci_key, (chan_init).ci_key_len)
_SKYWALK_CHANNEL_CHANNELVAR_H_ None
CSI_KNOTE 0x1
CSI_MITIGATION 0x10
CSI_LOCK(_csi) lck_mtx_lock(&(_csi)->csi_lock)
CSI_LOCK_ASSERT_HELD(_csi) LCK_MTX_ASSERT(&(_csi)->csi_lock, LCK_MTX_ASSERT_OWNED)
CSI_LOCK_ASSERT_NOTHELD(_csi) LCK_MTX_ASSERT(&(_csi)->csi_lock, LCK_MTX_ASSERT_NOTOWNED)
CSI_UNLOCK(_csi) lck_mtx_unlock(&(_csi)->csi_lock)
CH_MIT_IVAL_WIFI CH_MIT_IVAL_DEFAULT
CH_MIT_IVAL_CELLULAR CH_MIT_IVAL_DEFAULT
CH_MIT_IVAL_ETHERNET CH_MIT_IVAL_DEFAULT
SLOT_DESC_KSD(_sdp) __unsafe_forge_single(struct __kern_slot_desc *, 	((struct __kern_slot_desc *)((uintptr_t)&(_sdp)->_sd_private)))
CHANF_ATTACHED 0x1
CHANF_PLATFORM 0x2
CHANF_KERNEL 0x4
CHANF_RXONLY 0x8
CHANF_USER_PACKET_POOL 0x10
CHANF_EXCLUSIVE 0x20
CHANF_NONXREF 0x40
CHANF_HOST 0x80
CHANF_EXT_SKIP 0x100
CHANF_EXT_PRECONNECT 0x200
CHANF_EXT_CONNECTED 0x400
CHANF_EVENT_RING 0x1000
CHANF_IF_ADV 0x2000
CHANF_DEFUNCT_SKIP 0x4000
CHANF_BITS "\020\01ATTACHED\02PLATFORM\03KERNEL\04RXONLY\05USER_PKT_POOL"  	"\06EXCLUSIVE\07NONXREF\010HOST\011EXT_SKIP\012EXT_PRECONNECT"  	"\013EXT_CONNECTED\015EVENT\016ADVISORY"            	"\017DEFUNCT_SKIP\037CLOSING\040DEFUNCT"
CHAN_FILT_HINT_FLOW_ADV_UPD 0x1
CHAN_FILT_HINT_CHANNEL_EVENT 0x2
CHAN_FILT_HINT_IF_ADV_UPD 0x4
CHAN_FILT_HINT_BITS "\020\01FLOW_ADV\02CHANNEL_EVENT\03IF_ADV"
CHREQ_NAMELEN 64
CKR_TBR_TOKEN_INVALID INT64_MAX
KR_LOCK(_kr) lck_mtx_lock(&(_kr)->ckr_qlock)
KR_LOCK_SPIN(_kr) lck_mtx_lock_spin(&(_kr)->ckr_qlock)
KR_LOCK_TRY(_kr) lck_mtx_try_lock(&(_kr)->ckr_qlock)
KR_LOCK_ASSERT_HELD(_kr) LCK_MTX_ASSERT(&(_kr)->ckr_qlock, LCK_MTX_ASSERT_OWNED)
KR_LOCK_ASSERT_NOTHELD(_kr) LCK_MTX_ASSERT(&(_kr)->ckr_qlock, LCK_MTX_ASSERT_NOTOWNED)
KR_UNLOCK(_kr) lck_mtx_unlock(&(_kr)->ckr_qlock)
CKRF_EXCLUSIVE 0x1
CKRF_DROP 0x2
CKRF_HOST 0x4
CKRF_MEM_RING_INITED 0x8
CKRF_MEM_SD_INITED 0x10
CKRF_EXT_RING_INITED 0x20
CKRF_EXT_SLOTS_INITED 0x40
CKRF_SLOT_CONTEXT 0x80
CKRF_MITIGATION 0x100
CKRF_DEFUNCT 0x200
CKRF_BITS "\020\01EXCLUSIVE\02DROP\03HOST\04MEM_RING_INITED"              	"\05MEM_SD_INITED\06EXT_RING_INITED\07EXT_SLOTS_INITED"         	"\010SLOT_CONTEXT\011MITIGATION\012DEFUNCT\040KERNEL_ONLY"
KR_KSD(_kring, _slot_idx)       	(SLOT_DESC_KSD(&(_kring)->ckr_ksds[_slot_idx]))
KR_USD(_kring, _slot_idx)       	(SLOT_DESC_USD(&(_kring)->ckr_usds[_slot_idx]))
KSD_INIT(_ksd) do {                                             	(_ksd)->sd_md = NULL;                                           } while (0)
KSD_ATTACH_METADATA(_ksd, _md_addr) do {                        	ASSERT((_ksd) != NULL);                                         	ASSERT((_ksd)->sd_md == NULL);                                  	(_ksd)->sd_md = (_md_addr);                                     } while (0)
KSD_DETACH_METADATA(_ksd) do {                                  	ASSERT((_ksd) != NULL);                                         	ASSERT((_ksd)->sd_md != NULL);                                  	(_ksd)->sd_md = NULL;                                           } while (0)
KSD_RESET(_ksd) KSD_INIT(_ksd)
USD_INIT(_usd) do {                                             	(_usd)->sd_md_idx = OBJ_IDX_NONE;                               	(_usd)->sd_flags = 0;                                           	(_usd)->sd_len = 0;                                             } while (0)
USD_ATTACH_METADATA(_usd, _md_idx) do {                         	ASSERT((_usd) != NULL);                                         	ASSERT((_usd)->sd_md_idx == OBJ_IDX_NONE);                      	ASSERT(((_usd)->sd_flags & SD_IDX_VALID) == 0);                 	(_usd)->sd_md_idx = (_md_idx);                                  	(_usd)->sd_flags |= SD_IDX_VALID;                               	                                   	(_usd)->sd_flags &= SD_FLAGS_USER;                              } while (0);
USD_DETACH_METADATA(_usd) do {                                  	ASSERT((_usd) != NULL);                                         	(_usd)->sd_md_idx = OBJ_IDX_NONE;                               	                                   	(_usd)->sd_flags &= SD_FLAGS_USER;                              	(_usd)->sd_flags &= ~SD_IDX_VALID;                              } while (0)
USD_RESET(_usd) USD_INIT(_usd)
USD_SET_LENGTH(_usd, _md_len) do {                              	ASSERT((_usd) != NULL);                                         	(_usd)->sd_len = _md_len;                                       } while (0)
_USD_COPY(_src, _dst) do {                                      	_CASSERT(sizeof (struct __user_slot_desc) == 8);                	sk_copy64_8((uint64_t *)(void *)_src, (uint64_t *)(void *)_dst); } while (0)
_USD_SWAP(_usd1, _usd2) do {                                    	struct __user_slot_desc _tusd                                   	    __attribute((aligned(sizeof (uint64_t))));                  	_USD_COPY(_usd1, &_tusd);                                       	_USD_COPY(_usd2, _usd1);                                        	_USD_COPY(&_tusd, _usd2);                                       } while (0)
_KSD_COPY(_src, _dst) do {                                      	_CASSERT(sizeof (struct __kern_slot_desc) == 8);                	sk_copy64_8((uint64_t *)(void *)_src, (uint64_t *)(void *)_dst); } while (0)
_KSD_SWAP(_ksd1, _ksd2) do {                                    	struct __kern_slot_desc _tksd                                   	    __attribute((aligned(sizeof (uint64_t))));                  	_KSD_COPY(_ksd1, &_tksd);                                       	_KSD_COPY(_ksd2, _ksd1);                                        	_KSD_COPY(&_tksd, _ksd2);                                       } while (0)
SD_SWAP(_ksd1, _usd1, _ksd2, _usd2) do {                        	_USD_SWAP(_usd1, _usd2);                                        	_KSD_SWAP(_ksd1, _ksd2);                                        	                                    	*(struct __kern_slot_desc **)(uintptr_t)&(_ksd1)->sd_qum->qum_ksd = 	    (_ksd1); 	*(struct __kern_slot_desc **)(uintptr_t)&(_ksd2)->sd_qum->qum_ksd = 	    (_ksd2); } while (0)
_MD_BUFLET_ADDROFF(_md, _addr, _objaddr, _doff, _dlen, _dlim) do { 	struct __kern_quantum *_q = SK_PTR_ADDR_KQUM(_md);              	switch (METADATA_TYPE(_q)) {                                    	case NEXUS_META_TYPE_PACKET: {                                  	        struct __kern_packet *_p =                              	            (struct __kern_packet *)(void *)(_md);              	        struct __kern_buflet *_kbft;                            	        PKT_GET_FIRST_BUFLET(_p, _p->pkt_bufs_cnt, _kbft);      	        (_addr) = __unsafe_forge_bidi_indexable(void *,         	            __DECONST(void *, _kbft->buf_addr), _kbft->buf_dlim); 	        (_objaddr) = __unsafe_forge_bidi_indexable(void *,      	            _kbft->buf_objaddr, _kbft->buf_dlim);               	        (_doff) = _kbft->buf_doff;                              	        (_dlen) = _kbft->buf_dlen;                              	        (_dlim) = _kbft->buf_dlim;                              	        break;                                                  	}                                                               	default:                                                        	        (_addr) = __unsafe_forge_bidi_indexable(void *,         	            __DECONST(void *, _q->qum_buf[0].buf_addr),         	            _q->qum_buf[0].buf_dlim);                           	        (_objaddr) = __unsafe_forge_bidi_indexable(void *,      	            _q->qum_buf[0].buf_objaddr,                         	            _q->qum_buf[0].buf_dlim);                           	        (_doff) = _q->qum_buf[0].buf_doff;                      	        (_dlen) = _q->qum_buf[0].buf_dlen;                      	        (_dlim) = _q->qum_buf[0].buf_dlim;                      	        break;                                                  	}                                                               	ASSERT((_addr) != NULL);                                        	ASSERT((_objaddr) != NULL);                                     } while (0)
_MD_BUFLET_ADDR_PKT(_md, _addr) do { 	ASSERT(METADATA_TYPE(SK_PTR_ADDR_KQUM(_md)) ==                  	    NEXUS_META_TYPE_PACKET);                                    	struct __kern_packet *_p = (struct __kern_packet *)(void *)(_md); 	struct __kern_buflet *_kbft;                                    	PKT_GET_FIRST_BUFLET(_p, _p->pkt_bufs_cnt, _kbft);              	(_addr) = __unsafe_forge_bidi_indexable(void *,                 	    __DECONST(void *, _kbft->buf_addr), _kbft->buf_dlim);       	ASSERT((_addr) != NULL);                                        } while (0)
MD_BUFLET_ADDR(_md, _val) do {                                  	void *_addr, *_objaddr;                                         	uint32_t _doff, _dlen, _dlim;                                   	_MD_BUFLET_ADDROFF(_md, _addr, _objaddr, _doff, _dlen, _dlim);  	                              	(_val) = (void *)((uint8_t *)_addr + _doff);                    } while (0)
MD_BUFLET_ADDR_ABS(_md, _val) do {                              	void *_addr, *_objaddr;                                         	uint32_t _doff, _dlen, _dlim;                                   	_MD_BUFLET_ADDROFF(_md, _addr, _objaddr, _doff, _dlen, _dlim);  	(_val) = (void *)_addr;                                         } while (0)
MD_BUFLET_ADDR_ABS_PKT(_md, _val) do {                          	void *_addr;                                                    	_MD_BUFLET_ADDR_PKT(_md, _addr);                                	(_val) = (void *)_addr;                                         } while (0)
MD_BUFLET_ADDR_ABS_DLEN(_md, _val, _dlen, _dlim, _doff) do {    	void *_addr, *_objaddr;   	_MD_BUFLET_ADDROFF(_md, _addr, _objaddr, _doff, _dlen, _dlim);  	(_val) = (void *)_addr;                                         } while (0)
MD_BUFLET_OBJADDR(_md, _val) do {                               	void *_addr, *_objaddr;                                         	uint32_t _doff, _dlen, _dlim;                                   	_MD_BUFLET_ADDROFF(_md, _addr, _objaddr, _doff, _dlen, _dlim);  	(_val) = (void *)_objaddr;                                      } while (0)
MD_BUFLET_ADDR_DLEN(_md, _val, _dlen) do {                      	void *_addr, *_objaddr;                                         	uint32_t _doff, _dlim;                                          	_MD_BUFLET_ADDROFF(_md, _addr, _objaddr, _doff, _dlen, _dlim);  	                                  (_val) = (void *)(__unsafe_forge_bidi_indexable(uint8_t *, _addr, _dlim) + _doff); } while (0)
__NOTIF_DEST_NONE 0
__NOTIF_DEST_FSW 1
__NOTIF_DEST_NETIF 2
_SKYWALK_OS_CHANNEL_H_ None
OS_CHANNEL_HAS_NUM_BUFFERS_ATTR 1
OS_CHANNEL_HAS_LARGE_PACKET 1
CHANNEL_SYNCF_ALLOC 0x1
CHANNEL_SYNCF_FREE 0x2
CHANNEL_SYNCF_PURGE 0x4
CHANNEL_SYNCF_ALLOC_BUF 0x8
CHANNEL_SYNCF_LARGE_ALLOC 0x10
CHANNEL_NEXUS_CHECKSUM_PARTIAL 0x1
_SKYWALK_OS_CHANNEL_EVENT_H_ None
CHANNEL_EVENT_FLAG_MORE_EVENT 0x1
_SKYWALK_OS_CHANNEL_PRIVATE_H_ None
CHANNEL_SCHEMA_KERN_NAME _SYS_NAMELEN
CSM_CURRENT_VERSION 18
CSM_PRIV_MEM 0x1
CSM_BITS "\020\01PRIV_MEM\040ACTIVE"
CHANNEL_SCHEMA_SIZE(n) __builtin_offsetof(struct __user_channel_schema, csm_ring_ofs[(n)])
CHANNEL_CACHE_ALIGN_MAX 128
CR_KIND_RX 0
CR_KIND_TX 1
CR_KIND_ALLOC 2
CR_KIND_FREE 3
CR_KIND_EVENT 4
CR_KIND_LARGE_BUF_ALLOC 5
SD_IDX_VALID 0x1
SD_LEN_VALID 0x2
fae_token fae_flowid
FLOWADVF_VALID 0x1
FLOWADVF_SUSPENDED 0x2
cinfo_ch_token cinfo_ch_id_32[0]
CHANNEL_INIT_VERSION_1 1
CHANNEL_INIT_CURRENT_VERSION CHANNEL_INIT_VERSION_1
CHMODE_MONITOR_TX 0x00000001
CHMODE_MONITOR_RX 0x00000002
CHMODE_MONITOR_NO_COPY 0x00000004
CHMODE_USER_PACKET_POOL 0x00000008
CHMODE_DEFUNCT_OK 0x00000010
CHMODE_FILTER 0x00000020
CHMODE_EVENT_RING 0x00000040
CHMODE_LOW_LATENCY 0x00000080
CHMODE_EXCLUSIVE 0x00000200
CHMODE_KERNEL 0x00001000
CHMODE_NO_NXREF 0x00002000
CHMODE_CONFIG 0x00004000
CHMODE_HOST 0x00008000
CHMODE_BITS "\020\01MON_TX\02MON_RX\03NO_COPY\04USER_PKT_POOL"                	"\05DEFUNCT_OK\06FILTER\07EVENT_RING\010LOW_LATENCY\012EXCLUSIVE" 	"\015KERNEL\016NO_NXREF\017CONFIG\020HOST"
CHOPT_TX_LOWAT_THRESH 1
CHOPT_RX_LOWAT_THRESH 2
CHOPT_IF_ADV_CONF 3
SK_GUARD_MIN 1
SK_GUARD_MAX 4
SK_NETIF_DIRECT_MAX 8
SK_NETIF_COMPAT_AUX_CELL_TX_RING_SZ 64
SK_NETIF_COMPAT_AUX_CELL_RX_RING_SZ 64
SK_NETIF_COMPAT_WAP_TX_RING_SZ 128
SK_NETIF_COMPAT_WAP_RX_RING_SZ 128
SK_NETIF_COMPAT_AWDL_TX_RING_SZ 128
SK_NETIF_COMPAT_AWDL_RX_RING_SZ 128
SK_NETIF_COMPAT_WIF_TX_RING_SZ 128
SK_NETIF_COMPAT_WIF_RX_RING_SZ 128
SK_NETIF_COMPAT_USB_ETH_TX_RING_SZ 128
SK_NETIF_COMPAT_USB_ETH_RX_RING_SZ 128
SK_NETIF_COMPAT_RX_MBQ_LIMIT 8192
SKMEM_TAG_SYSCTL_BUF "com.apple.skywalk.sysctl_buf"
SKMEM_TAG_OID "com.apple.skywalk.skoid"
GUARD_CH_SIG 0x4348
GUARD_NX_SIG 0x4e58
_SKYWALK_COMMON_H_ None
container_of(ptr, type, member) 	((type*)(((uintptr_t)ptr) - offsetof(type, member)))
SK_PREFETCH(a, n) 	__builtin_prefetch((const void *)((uintptr_t)(a) + (n)), 0, 3)
SK_PREFETCHW(a, n) 	__builtin_prefetch((const void *)((uintptr_t)(a) + (n)), 1, 3)
SK_ROUNDUP(x, align)    	((((x) % (align)) == 0) ? (x) : ((x) + ((align) - ((x) % (align)))))
_CASSERT(x) _Static_assert(x, "compile-time assertion failed")
IS_P2ALIGNED(v, a)      	((((uintptr_t)(v)) & ((uintptr_t)(a) - 1)) == 0)
__sk_aligned(a) __attribute__((__aligned__(a)))
__sk_packed __attribute__((__packed__))
__sk_unused __attribute__((__unused__))
_sk_alloc_type(probename, type, flags, name)                    ({                                                                      	                	__auto_type ret = kalloc_type_tag(type, Z_ZERO | (flags),       	    (name)->tag);                                               	DTRACE_SKYWALK3(probename, char *, #type, int, (flags),         	    void *, ret);                                               	ret;                                                            })
_sk_alloc_type_array(probename, type, count, flags, name)       ({                                                                      	__auto_type ret = kalloc_type_tag(type, (count),                	    Z_ZERO | (flags), (name)->tag);                             	DTRACE_SKYWALK4(probename, char *, #type, size_t, (count),      	    int, (flags), void *, ret);                                 	ret;                                                            })
_sk_alloc_type_hash(probename, heap, size, flags, name)         ({                                                                      	__auto_type ret = kalloc_type_var_impl((heap), (size),          	    __zone_flags_mix_tag((flags) | Z_ZERO, (name)->tag), NULL); 	DTRACE_SKYWALK4(probename, char *, (heap)->kt_name + 5,         	    size_t, (size), int, (flags), void *, ret);                 	ret;                                                            })
_sk_realloc_type_array(probename, type, oldcount, newcount, elem, flags, name) ({                                                                      	__auto_type ret = krealloc_type_tag(type, (oldcount),           	    (newcount), (elem), Z_ZERO | (flags), (name)->tag);         	DTRACE_SKYWALK5(probename, void *, (elem), size_t, (oldcount),  	    size_t, (newcount), int, (flags), void *, ret);             	ret;                                                            })
_sk_alloc_type_header_array(probename, htype, type, count, flags, name) ({                                                                      	__auto_type ret = kalloc_type_tag(htype, type, (count),         	    Z_ZERO | (flags), (name)->tag);                             	DTRACE_SKYWALK5(probename, char *, #htype, char *, #type,       	    size_t, (count), int, (flags), void *, ret);                	ret;                                                            })
_sk_free_type(probename, type, elem)                            {                                                                       	DTRACE_SKYWALK2(probename, char *, #type, void *, (elem));      	kfree_type(type, (elem));                                       }
_sk_free_type_array(probename, type, count, elem)               {                                                                       	DTRACE_SKYWALK3(probename, char *, #type, size_t, (count),      	    void *, (elem));                                            	kfree_type(type, (count), (elem));                              }
_sk_free_type_array_counted_by(probename, type, count, elem)    {                                                                       	DTRACE_SKYWALK3(probename, char *, #type, size_t, (count),      	    void *, (elem));                                            	kfree_type_counted_by(type, (count), (elem));                   }
_sk_free_type_hash(probename, heap, size, elem)                 {                                                                       	DTRACE_SKYWALK3(probename, char *, (heap)->kt_name + 5,         	    size_t, (size), void *, (elem));                            	kfree_type_var_impl((heap), (elem), (size));                    }
_sk_free_type_header_array(probename, htype, type, count, elem) {                                                                       	DTRACE_SKYWALK4(probename, char *, #htype, char *, #type,       	    size_t, (count), void *, (elem));                           	kfree_type(htype, type, (count), (elem));                       }
_sk_alloc_data(probename, size, flags, name)                    ({                                                                      	void *ret;                                                                                                                              	ret = kalloc_data_tag((size), Z_ZERO | (flags), (name)->tag);   	DTRACE_SKYWALK3(probename, size_t, (size), int, (flags),        	    void *, ret);                                               	ret;                                                            })
_sk_realloc_data(probename, elem, oldsize, newsize, flags, name) ({                                                                      	void *ret;                                                                                                                              	ret = krealloc_data_tag((elem), (oldsize), (newsize),           	    Z_ZERO | (flags), (name)->tag);                             	DTRACE_SKYWALK5(probename, void *, (elem), size_t, (oldsize),   	    size_t, (newsize), int, (flags), void *, ret);              	ret;                                                            })
_sk_free_data(probename, elem, size)                            {                                                                       	DTRACE_SKYWALK2(probename, void *, (elem), size_t, (size));     	kfree_data((elem), (size));                                     }
_sk_free_data_sized_by(probename, elem, size)                   {                                                                       	DTRACE_SKYWALK2(probename, void *, (elem), size_t, (size));     	kfree_data_sized_by((elem), (size));                            }
sk_alloc_type(type, flags, tag)                                 	_sk_alloc_type(sk_alloc_type, type, flags, tag)
sk_alloc_type_array(type, count, flags, tag)                    	_sk_alloc_type_array(sk_alloc_type_array, type, count, flags, tag)
sk_alloc_type_hash(heap, size, flags, tag)                      	_sk_alloc_type_hash(sk_alloc_type_hash, heap, size, flags, tag)
sk_alloc_type_header_array(htype, type, count, flags, tag)      	_sk_alloc_type_header_array(sk_alloc_type_header_array, htype,  	type, count, flags, tag)
sk_realloc_type_array(type, oldsize, newsize, elem, flags, tag) 	_sk_realloc_type_array(sk_realloc_type_array, type,             	oldsize, newsize, elem, flags, tag)
sk_free_type(type, elem)                                        	_sk_free_type(sk_free_type, type, elem)
sk_free_type_array(type, count, elem)                           	_sk_free_type_array(sk_free_type_array, type, count, elem)
sk_free_type_array_counted_by(type, count, elem)                	_sk_free_type_array_counted_by(sk_free_type_array_counted_by, type, count, elem)
sk_free_type_hash(heap, size, elem)                             	_sk_free_type_hash(sk_free_type_hash, heap, size, elem)
sk_free_type_header_array(htype, type, count, elem)             	_sk_free_type_header_array(sk_free_type_header_array, htype,    	type, count, elem)
sk_alloc_data(size, flags, tag)                                 	_sk_alloc_data(sk_alloc_data, size, flags, tag)
sk_realloc_data(elem, oldsize, newsize, flags, tag)             	_sk_realloc_data(sk_realloc_data, elem, oldsize, newsize,       	flags, tag)
sk_free_data(elem, size)                                        	_sk_free_data(sk_free_data, elem, size)
sk_free_data_sized_by(elem, size)                               	_sk_free_data_sized_by(sk_free_data_sized_by, elem, size)
skn_realloc(name, elem, oldsize, newsize, flags, tag)           	_sk_realloc(sk_realloc_ ## name, elem, oldsize, newsize, flags, 	tag)
skn_alloc_type(name, type, flags, tag)                          	_sk_alloc_type(sk_alloc_type_ ## name, type, flags, tag)
skn_alloc_type_array(name, type, count, flags, tag)             	_sk_alloc_type_array(sk_alloc_type_array_ ## name, type, count, 	flags, tag)
skn_alloc_type_hash(name, heap, size, flags, tag)               	_sk_alloc_type_hash(sk_alloc_type_hash_ ## name, heap, size,    	flags, tag)
skn_alloc_type_header_array(name, htype, type, count, flags, tag) 	_sk_alloc_type_header_array(sk_alloc_type_header_array_ ## name, 	htype, type, count, flags, tag)
skn_free_type(name, type, elem)                                 	_sk_free_type(sk_free_type_ ## name, type, elem)
skn_free_type_array(name, type, count, elem)                    	_sk_free_type_array(sk_free_type_array_ ## name, type, count,   	elem)
skn_free_type_array_counted_by(name, type, count, elem)         	_sk_free_type_array_counted_by(sk_free_type_array_ ## name, type, count,   	elem)
skn_free_type_hash(name, heap, size, elem)                      	_sk_free_type_hash(sk_free_type_hash_ ## name, heap, size, elem)
skn_free_type_header_array(name, htype, type, count, elem)      	_sk_free_type_header_array(sk_free_type_header_array_ ## name,  	htype, type, count, elem)
skn_alloc_data(name, size, flags, tag)                          	_sk_alloc_data(sk_alloc_data_ ## name, size, flags, tag)
skn_realloc_data(name, elem, oldsize, newsize, flags, tag)      	_sk_realloc_data(sk_realloc_data_ ## name, elem, oldsize, newsize,	flags, tag)
skn_free_data(name, elem, size)                                 	_sk_free_data(sk_free_data_ ## name, elem, size)
SKMEM_TAG_DEFINE(var, name) 	SECURITY_READ_ONLY_LATE(kern_allocation_name_t) var;            	__startup_data struct sk_tag_spec __sktag_##var = {             	    .skt_var = &var, .skt_name = name,                          	};                                                              	STARTUP_ARG(ZALLOC, STARTUP_RANK_LAST, __sk_tag_make, &__sktag_##var)
sk_memcmp_mask __sk_memcmp_mask
sk_memcmp_mask_16B os_memcmp_mask_16B
sk_memcmp_mask_32B os_memcmp_mask_32B
sk_memcmp_mask_48B os_memcmp_mask_48B
sk_memcmp_mask_64B os_memcmp_mask_64B
sk_memcmp_mask_80B os_memcmp_mask_80B
sk_memcmp_mask_scalar __sk_memcmp_mask_scalar
sk_memcmp_mask_16B_scalar __sk_memcmp_mask_16B_scalar
sk_memcmp_mask_32B_scalar __sk_memcmp_mask_32B_scalar
sk_memcmp_mask_48B_scalar __sk_memcmp_mask_48B_scalar
sk_memcmp_mask_64B_scalar __sk_memcmp_mask_64B_scalar
sk_memcmp_mask_80B_scalar __sk_memcmp_mask_80B_scalar
_SKYWALK_VAR_H_ None
bswap16(x) OSSwapInt16(x)
bswap32(x) OSSwapInt32(x)
bswap64(x) OSSwapInt64(x)
SK_ATOMIC_CLEAR(p) os_atomic_store((p), 0, release)
SK_LOCK() lck_mtx_lock(&sk_lock)
SK_LOCK_TRY() lck_mtx_try_lock(&sk_lock)
SK_LOCK_ASSERT_HELD() LCK_MTX_ASSERT(&sk_lock, LCK_MTX_ASSERT_OWNED)
SK_LOCK_ASSERT_NOTHELD() LCK_MTX_ASSERT(&sk_lock, LCK_MTX_ASSERT_NOTOWNED)
SK_UNLOCK() lck_mtx_unlock(&sk_lock)
for_rx_tx(t) for ((t) = 0; (t) < NR_TXRX; (t)++)
for_a_f(t) for ((t) = NR_A; (t) <= NR_F; (t)++)
for_all_rings(t) for ((t) = 0; (t) < NR_ALL; (t)++)
NX_METADATA_OBJ_MAX_SZ 512
NX_METADATA_USR_MIN_SZ 0
NX_STATS_MIN_SZ 0
NX_FLOWADV_DEFAULT 512
FO_FLOWADV_CHUNK 64
NX_MIN_NUM_RING_PAIR 1
NX_MAX_NUM_RING_PAIR 8
NX_MIN_NUM_SLOT_PER_RING 2
NX_MIN_BUF_OBJ_SIZE 64
NX_PBUF_FRAGS_MIN 1
NX_PBUF_FRAGS_DEFAULT NX_PBUF_FRAGS_MIN
NX_PBUF_FRAGS_MAX 64
NX_MAX_AGGR_PKT_SIZE IP_MAXPACKET
NETIF_COMPAT_TXMODEL_DEFAULT 0
NETIF_COMPAT_TXMODEL_ENQUEUE_MULTI 1
NETIF_NATIVE_TXMODEL_DEFAULT 0
NETIF_NATIVE_TXMODEL_ENQUEUE_MULTI 1
_timersub(tvp, uvp, vvp) do {                                   	        (vvp)->tv_sec = (tvp)->tv_sec - (uvp)->tv_sec;          	        (vvp)->tv_nsec = (tvp)->tv_nsec - (uvp)->tv_nsec;       	        if ((vvp)->tv_nsec < 0) {                               	                (vvp)->tv_sec--;                                	                (vvp)->tv_nsec += NSEC_PER_SEC;                 	        }                                                       } while (0)
_timernsec(tvp, nsp) do {                                       	        *(nsp) = (tvp)->tv_nsec;                                	        if ((tvp)->tv_sec > 0)                                  	                *(nsp) += ((tvp)->tv_sec * NSEC_PER_SEC);       } while (0)
sk_sync_unprotect sk_unprotect
sk_cache_update_unprotect sk_unprotect
sk_region_update_unprotect sk_unprotect
sk_tx_notify_unprotect sk_unprotect
sk_async_transmit_unprotect sk_unprotect
SKYWALK_KILL_REASON_TX_SYNC 0x0000000000000000ULL
SKYWALK_KILL_REASON_EVENT_SYNC 0x1000000000000000ULL
SKYWALK_KILL_REASON_FREE_SYNC 0x2000000000000000ULL
SKYWALK_KILL_REASON_ALLOC_SYNC 0x4000000000000000ULL
SKYWALK_KILL_REASON_RX_SYNC 0x8000000000000000ULL
SKOID_NAME_SIZE 32
SKOID_PROC_CALL_GUARD do {                      	if (req->newptr == USER_ADDR_NULL)              	        return (0);                             } while (0)
CUCKOO_TAG "com.apple.skywalk.libcuckoo"
cht_err(_fmt, ...) cht_log(CHTV_ERR, _fmt, ##__VA_ARGS__)
cht_warn(_fmt, ...) cht_log(CHTV_WARN, _fmt, ##__VA_ARGS__)
cht_info(_fmt, ...) cht_log(CHTV_INFO, _fmt, ##__VA_ARGS__)
cht_debug(_fmt, ...) cht_log(CHTV_DEBUG, _fmt, ##__VA_ARGS__)
_CHT_MAX_LOAD_SHRINK 40
_CHT_MIN_LOAD_EXPAND 85
_CHT_CACHELINE_CHUNK 128
_CHT_SLOT_INVAL UINT8_MAX
_CHT_ALT_HASH_MIX 0x5bd1e995
__lock_bucket(b) lck_mtx_lock(&b->_lock)
__unlock_bucket(b) lck_mtx_unlock(&b->_lock)
_CHT_DEADLOCK_THRESHOLD 20
__rlock_table(h) lck_rw_lock_shared(&h->_resize_lock)
__unrlock_table(h) lck_rw_unlock_shared(&h->_resize_lock)
__r2wlock_table(h) lck_rw_lock_shared_to_exclusive(&h->_resize_lock)
__wlock_table(h) lck_rw_lock_exclusive(&h->_resize_lock)
__unwlock_table(h) lck_rw_unlock_exclusive(&h->_resize_lock)
_CHT_BFS_QUEUE_LEN UINT8_MAX
_CUCKOO_HASHTABLE_H_ None
container_of(ptr, type, member) 	((type*)(((uintptr_t)ptr) - offsetof(type, member)))
SKMEM_DUMP_BUF_SIZE 2048
SKMEM_WDT_DUMP_BUF_CHK() do {                           	clen -= k;                                              	if (clen < 1)                                           	        goto done;                                      	c += k;                                                 } while (0)
skmem_snprintf(str, size, format, ...)  ({ 	_Pragma("clang diagnostic push")                                   	_Pragma("clang diagnostic ignored \"-Wformat-invalid-specifier\"") 	_Pragma("clang diagnostic ignored \"-Wformat-extra-args\"")        	_Pragma("clang diagnostic ignored \"-Wformat\"")                   	snprintf(str, size, format, ## __VA_ARGS__)                        	_Pragma("clang diagnostic pop");                                   })
SKMEM_ARENA_LOCK() lck_mtx_lock(&skmem_arena_lock)
SKMEM_ARENA_LOCK_ASSERT_HELD() LCK_MTX_ASSERT(&skmem_arena_lock, LCK_MTX_ASSERT_OWNED)
SKMEM_ARENA_LOCK_ASSERT_NOTHELD() LCK_MTX_ASSERT(&skmem_arena_lock, LCK_MTX_ASSERT_NOTOWNED)
SKMEM_ARENA_UNLOCK() lck_mtx_unlock(&skmem_arena_lock)
AR_NEXUS_SIZE sizeof(struct skmem_arena_nexus)
AR_NECP_SIZE sizeof(struct skmem_arena_necp)
AR_SYSTEM_SIZE sizeof(struct skmem_arena_system)
SKMEM_TAG_ARENA_MIB "com.apple.skywalk.arena.mib"
_SKYWALK_MEM_SKMEMARENAVAR_H None
ARF_ACTIVE 0x1
ARF_BITS "\020\01ACTIVE\040DEFUNCT"
AR_LOCK(_ar) lck_mtx_lock(&(_ar)->ar_lock)
AR_LOCK_ASSERT_HELD(_ar) LCK_MTX_ASSERT(&(_ar)->ar_lock, LCK_MTX_ASSERT_OWNED)
AR_LOCK_ASSERT_NOTHELD(_ar) LCK_MTX_ASSERT(&(_ar)->ar_lock, LCK_MTX_ASSERT_NOTOWNED)
AR_UNLOCK(_ar) lck_mtx_unlock(&(_ar)->ar_lock)
AR_MEM_TOTAL(_ar, _id)          	((_ar)->ar_regions[_id]->skr_memtotal)
AR_MEM_INUSE(_ar, _id)          	((_ar)->ar_regions[_id]->skr_meminuse)
AR_MEM_WIRED_INUSE(_ar, _id)    	((_ar)->ar_regions[_id]->skr_w_meminuse)
AR_MEM_SEGSIZE(_ar, _id)        	((_ar)->ar_regions[_id]->skr_seg_size)
AR_MEM_SEGCNT(_ar, _id)         	((_ar)->ar_regions[_id]->skr_seg_max_cnt)
AR_MEM_OBJCNT_R(_ar, _id)       	((_ar)->ar_regions[_id]->skr_r_obj_cnt)
AR_MEM_OBJCNT_C(_ar, _id)       	((_ar)->ar_regions[_id]->skr_c_obj_cnt)
AR_MEM_OBJSIZE_R(_ar, _id)      	((_ar)->ar_regions[_id]->skr_r_obj_size)
AR_MEM_OBJSIZE_C(_ar, _id)      	((_ar)->ar_regions[_id]->skr_c_obj_size)
AR_NEXUS_MODE_EXTERNAL_PPOOL 0x1
_FN_KPRINTF None
SKMEM_CACHE_LOCK() do {                 	lck_mtx_lock(&skmem_cache_lock);        	skmem_lock_owner = current_thread();    } while (0)
SKMEM_CACHE_UNLOCK() do {               	skmem_lock_owner = THREAD_NULL;         	lck_mtx_unlock(&skmem_cache_lock);      } while (0)
SKMEM_CACHE_LOCK_ASSERT_HELD() LCK_MTX_ASSERT(&skmem_cache_lock, LCK_MTX_ASSERT_OWNED)
SKMEM_CACHE_LOCK_ASSERT_NOTHELD() LCK_MTX_ASSERT(&skmem_cache_lock, LCK_MTX_ASSERT_NOTOWNED)
SKM_DEPOT_LOCK(_skm) lck_mtx_lock(&(_skm)->skm_dp_lock)
SKM_DEPOT_LOCK_SPIN(_skm) lck_mtx_lock_spin(&(_skm)->skm_dp_lock)
SKM_DEPOT_CONVERT_LOCK(_skm) lck_mtx_convert_spin(&(_skm)->skm_dp_lock)
SKM_DEPOT_LOCK_TRY(_skm) lck_mtx_try_lock(&(_skm)->skm_dp_lock)
SKM_DEPOT_LOCK_ASSERT_HELD(_skm) LCK_MTX_ASSERT(&(_skm)->skm_dp_lock, LCK_MTX_ASSERT_OWNED)
SKM_DEPOT_LOCK_ASSERT_NOTHELD(_skm) LCK_MTX_ASSERT(&(_skm)->skm_dp_lock, LCK_MTX_ASSERT_NOTOWNED)
SKM_DEPOT_UNLOCK(_skm) lck_mtx_unlock(&(_skm)->skm_dp_lock)
SKM_RESIZE_LOCK(_skm) lck_mtx_lock(&(_skm)->skm_rs_lock)
SKM_RESIZE_LOCK_ASSERT_HELD(_skm) LCK_MTX_ASSERT(&(_skm)->skm_rs_lock, LCK_MTX_ASSERT_OWNED)
SKM_RESIZE_LOCK_ASSERT_NOTHELD(_skm) LCK_MTX_ASSERT(&(_skm)->skm_rs_lock, LCK_MTX_ASSERT_NOTOWNED)
SKM_RESIZE_UNLOCK(_skm) lck_mtx_unlock(&(_skm)->skm_rs_lock)
SKM_CPU_LOCK(_cp) lck_mtx_lock(&(_cp)->cp_lock)
SKM_CPU_LOCK_SPIN(_cp) lck_mtx_lock_spin(&(_cp)->cp_lock)
SKM_CPU_CONVERT_LOCK(_cp) lck_mtx_convert_spin(&(_cp)->cp_lock)
SKM_CPU_LOCK_ASSERT_HELD(_cp) LCK_MTX_ASSERT(&(_cp)->cp_lock, LCK_MTX_ASSERT_OWNED)
SKM_CPU_LOCK_ASSERT_NOTHELD(_cp) LCK_MTX_ASSERT(&(_cp)->cp_lock, LCK_MTX_ASSERT_NOTOWNED)
SKM_CPU_UNLOCK(_cp) lck_mtx_unlock(&(_cp)->cp_lock)
SKM_ZONE_MAX 256
SKMEM_CACHE_HASH_INITIAL 64
SKMEM_CACHE_HASH_LIMIT 8192
SKMEM_CACHE_FREE_NOCACHE 0x1
SKMEM_DEBUG_NOMAGAZINES 0x1
SKMEM_DEBUG_AUDIT 0x2
SKMEM_CACHE_UPDATE_INTERVAL 11
SKMEM_DEPOT_CONTENTION 3
SKMEM_TAG_BUFCTL_HASH "com.apple.skywalk.bufctl.hash"
SKMEM_TAG_CACHE_MIB "com.apple.skywalk.cache.mib"
_SKYWALK_MEM_SKMEMCACHEVAR_H None
SKMEM_BUFCTL_SHAREOK 0x1
SKMEM_STACK_DEPTH 16
SKMEM_CACHE_ALIGN 8
SKMEM_MEMTAG_STRIP_TAG(addr, size)                             	__unsafe_forge_bidi_indexable(void *,                          	    vm_memtag_canonicalize_kernel((vm_offset_t)addr), size)
SKMEM_COMPARE_CANONICAL_ADDR(addr1, addr2, size)               	SKMEM_MEMTAG_STRIP_TAG(addr1, size) == SKMEM_MEMTAG_STRIP_TAG(addr2, size)
SKMEM_SLAB_MEMBER(sl, buf)      	(((size_t)(buf) - (size_t)vm_memtag_canonicalize_kernel((vm_offset_t)(sl)->sl_base)) 	     < (sl)->sl_cache->skm_slabsize)
SKMEM_MAG_SIZE(n) offsetof(struct skmem_mag, mg_round[n])
SKMEM_CACHE_SIZE(n) offsetof(struct skmem_cache, skm_cpu_cache[n])
SKM_MODE_NOMAGAZINES 0x00000001
SKM_MODE_AUDIT 0x00000002
SKM_MODE_NOREDIRECT 0x00000004
SKM_MODE_BATCH 0x00000008
SKM_MODE_DYNAMIC 0x00000010
SKM_MODE_CLEARONFREE 0x00000020
SKM_MODE_PSEUDO 0x00000040
SKM_MODE_RECLAIM 0x00000080
SKM_MODE_BITS "\020\01NOMAGAZINES\02AUDIT\03NOREDIRECT\04BATCH\05DYNAMIC"     	"\06CLEARONFREE\07PSEUDO\10RECLAIM"
SKMEM_SLEEP 0x0
SKMEM_NOSLEEP 0x1
SKMEM_PANIC 0x2
SKMEM_FAILOK 0x4
SKMEM_CR_NOMAGAZINES 0x1
SKMEM_CR_BATCH 0x2
SKMEM_CR_DYNAMIC 0x4
SKMEM_CR_CLEARONFREE 0x8
SKMEM_CR_RECLAIM 0x10
SKM_SLAB_LOCK(_skm) lck_mtx_lock(&(_skm)->skm_sl_lock)
SKM_SLAB_LOCK_ASSERT_HELD(_skm) LCK_MTX_ASSERT(&(_skm)->skm_sl_lock, LCK_MTX_ASSERT_OWNED)
SKM_SLAB_LOCK_ASSERT_NOTHELD(_skm) LCK_MTX_ASSERT(&(_skm)->skm_sl_lock, LCK_MTX_ASSERT_NOTOWNED)
SKM_SLAB_UNLOCK(_skm) lck_mtx_unlock(&(_skm)->skm_sl_lock)
SKMEM_CACHE_HASH_INDEX(_a, _s, _m)      (((_a) >> (_s)) & (_m))
SKMEM_CACHE_HASH(_skm, _buf)                                     	(&(_skm)->skm_hash_table[SKMEM_CACHE_HASH_INDEX((uintptr_t)_buf, 	(_skm)->skm_hash_shift, (_skm)->skm_hash_mask)])
_FN_KPRINTF None
SKMEM_REGION_UPDATE_INTERVAL 13
SKMEM_WDT_MAXTIME 30
SKMEM_WDT_PURGE 3
SKMEM_REGION_LOCK() lck_mtx_lock(&skmem_region_lock)
SKMEM_REGION_LOCK_ASSERT_HELD() LCK_MTX_ASSERT(&skmem_region_lock, LCK_MTX_ASSERT_OWNED)
SKMEM_REGION_LOCK_ASSERT_NOTHELD() LCK_MTX_ASSERT(&skmem_region_lock, LCK_MTX_ASSERT_NOTOWNED)
SKMEM_REGION_UNLOCK() lck_mtx_unlock(&skmem_region_lock)
SKMEM_REGION_HASH_INITIAL 32
SKMEM_REGION_HASH_LIMIT 4096
SKMEM_REGION_HASH_INDEX(_a, _s, _m)     	(((_a) + ((_a) >> (_s)) + ((_a) >> ((_s) << 1))) & (_m))
SKMEM_REGION_HASH(_skr, _addr)                                     	(&(_skr)->skr_hash_table[SKMEM_REGION_HASH_INDEX((uintptr_t)_addr, 	    (_skr)->skr_hash_shift, (_skr)->skr_hash_mask)])
SKMEM_TAG_SEGMENT_BMAP "com.apple.skywalk.segment.bmap"
SKMEM_TAG_SEGMENT_HASH "com.apple.skywalk.segment.hash"
SKMEM_TAG_REGION_MIB "com.apple.skywalk.region.mib"
BMAPSZ 64
BMASK64(_beg, _end)     	((((uint64_t)-1) >> ((BMAPSZ - 1) - (_end))) & ~((1ULL << (_beg)) - 1))
_SKYWALK_MEM_SKMEMREGIONVAR_H None
SKMEM_PP_REGIONS 14
SKR_MAX_CACHES 2
skr_id skr_params.srp_id
skr_cflags skr_params.srp_cflags
skr_r_obj_size skr_params.srp_r_obj_size
skr_r_obj_cnt skr_params.srp_r_obj_cnt
skr_c_obj_size skr_params.srp_c_obj_size
skr_c_obj_cnt skr_params.srp_c_obj_cnt
skr_align skr_params.srp_align
skr_md_type skr_params.srp_md_type
skr_md_subtype skr_params.srp_md_subtype
skr_max_frags skr_params.srp_max_frags
skr_seg_size skr_params.srp_c_seg_size
skr_seg_max_cnt skr_params.srp_seg_cnt
SKR_LOCK(_skr) lck_mtx_lock(&(_skr)->skr_lock)
SKR_LOCK_ASSERT_HELD(_skr) LCK_MTX_ASSERT(&(_skr)->skr_lock, LCK_MTX_ASSERT_OWNED)
SKR_LOCK_ASSERT_NOTHELD(_skr) LCK_MTX_ASSERT(&(_skr)->skr_lock, LCK_MTX_ASSERT_NOTOWNED)
SKR_UNLOCK(_skr) lck_mtx_unlock(&(_skr)->skr_lock)
SKR_MODE_NOREDIRECT 0x1
SKR_MODE_MMAPOK 0x2
SKR_MODE_KREADONLY 0x4
SKR_MODE_UREADONLY 0x8
SKR_MODE_PERSISTENT 0x10
SKR_MODE_MONOLITHIC 0x20
SKR_MODE_NOMAGAZINES 0x40
SKR_MODE_NOCACHE 0x80
SKR_MODE_SEGPHYSCONTIG 0x100
SKR_MODE_SHAREOK 0x200
SKR_MODE_IODIR_IN 0x400
SKR_MODE_IODIR_OUT 0x800
SKR_MODE_GUARD 0x1000
SKR_MODE_PUREDATA 0x2000
SKR_MODE_PSEUDO 0x4000
SKR_MODE_THREADSAFE 0x8000
SKR_MODE_MEMTAG 0x10000
SKR_MODE_BITS "\020\01NOREDIRECT\02MMAPOK\03KREADONLY\04UREADONLY"    	"\05PERSISTENT\06MONOLITHIC\07NOMAGAZINES\10NOCACHE"    	"\11SEGPHYSCONTIG\012SHAREOK\013IODIR_IN\014IODIR_OUT"  	"\015GUARD\016PUREDATA\017PSEUDO\020THREADSAFE\021MEMTAG\037SLAB" 	"\040MIRRORED"
SKMEM_REGION_CR_NOREDIRECT 0x1
SKMEM_REGION_CR_MMAPOK 0x2
SKMEM_REGION_CR_KREADONLY 0x4
SKMEM_REGION_CR_UREADONLY 0x8
SKMEM_REGION_CR_PERSISTENT 0x10
SKMEM_REGION_CR_MONOLITHIC 0x20
SKMEM_REGION_CR_NOMAGAZINES 0x40
SKMEM_REGION_CR_NOCACHE 0x80
SKMEM_REGION_CR_SEGPHYSCONTIG 0x100
SKMEM_REGION_CR_SHAREOK 0x200
SKMEM_REGION_CR_IODIR_IN 0x400
SKMEM_REGION_CR_IODIR_OUT 0x800
SKMEM_REGION_CR_GUARD 0x1000
SKMEM_REGION_CR_PUREDATA 0x2000
SKMEM_REGION_CR_PSEUDO 0x4000
SKMEM_REGION_CR_THREADSAFE 0x8000
SKMEM_REGION_CR_MEMTAG 0x10000
SKMEM_REGION_CR_BITS "\021\01NOREDIRECT\02MMAPOK\03KREADONLY\04UREADONLY"    	"\05PERSISTENT\06MONOLITHIC\07NOMAGAZINES\10NOCACHE"    	"\11SEGPHYSCONTIG\012SHAREOK\013IODIR_IN\014IODIR_OUT"  	"\015GUARD\016PUREDATA\017PSEUDO\020THREADSAFE\021MEMTAG"
_FN_KPRINTF None
SKMEM_SLAB_BACKOFF_THRES 1024
SKMEM_SLAB_BACKOFF_RANDOM 4
_SKYWALK_MEM_SKMEMVAR_H None
SKMEM_PAGE_SIZE PAGE_MAX_SIZE
SKMEM_SEG_SIZE SKMEM_MIN_SEG_SIZE
SKMEM_DRV_BUF_SEG_MULTIPLIER 2
SKMEM_ARENA_PREFIX "ska"
SKMEM_REGION_PREFIX "skr"
SKMEM_CACHE_PREFIX "skc"
SKMEM_ZONE_PREFIX "skywalk"
SKMEM_TYPE_DEFINE(var, type) 	KALLOC_TYPE_DEFINE(var, type, SMKEM_KT_DEFAULT)
FLOWIDNS_MAX_FLOWID_GEN_RETRY 5
FLOWIDNS_FLOWID_DOMAIN_SHIFT 30
FLOWIDNS_FLOWID_SET_DOMAIN(_dom, _fid)    do {         	(_fid) &= ~FLOWIDNS_FLOWID_DOMAIN_MASK;                	(_fid) |= ((_dom) << FLOWIDNS_FLOWID_DOMAIN_SHIFT);    } while (0)
FLOWIDNS_FLOWID_GET_DOMAIN(_dom, _fid)    do {    	(_dom) = (_fid) >> FLOWIDNS_FLOWID_DOMAIN_SHIFT;  } while (0)
FLOWIDNS_DOM_LOCK(_dom) lck_mtx_lock(&(flowidns_domain_array[(_dom)].fd_mtx))
FLOWIDNS_DOM_UNLOCK(_dom) lck_mtx_unlock(&(flowidns_domain_array[(_dom)].fd_mtx))
_SKYWALK_NAMESPACE_FLOWIDNS_H_ None
ffk_laddr_v4 ffk_laddr._v4
ffk_laddr_v6 ffk_laddr._v6
ffk_raddr_v4 ffk_raddr._v4
ffk_raddr_v6 ffk_raddr._v6
ffk_lport ffk_ports._lport
ffk_rport ffk_ports._rport
NETNS_LOCK() lck_mtx_lock(&netns_lock)
NETNS_LOCK_SPIN() lck_mtx_lock_spin(&netns_lock)
NETNS_LOCK_CONVERT() do {       	NETNS_LOCK_ASSERT_HELD();       	lck_mtx_convert_spin(&netns_lock); } while (0)
NETNS_UNLOCK() lck_mtx_unlock(&netns_lock)
NETNS_LOCK_ASSERT_HELD() LCK_MTX_ASSERT(&netns_lock, LCK_MTX_ASSERT_OWNED)
NETNS_LOCK_ASSERT_NOTHELD() LCK_MTX_ASSERT(&netns_lock, LCK_MTX_ASSERT_NOTOWNED)
NETNS_REF_COUNT(nsr, flags)     	(nsr)->nsr_refs[((flags) & NETNS_OWNER_MASK)]
NETNS_N_GLOBAL 4
NETNS_NS_TCP 0
NETNS_NS_UDP 1
NETNS_NS_V4 0
NETNS_NS_V6 2
NETNS_NS_GLOBAL_IDX(proto, addrlen)     	((((proto) == IPPROTO_TCP) ? NETNS_NS_TCP : NETNS_NS_UDP) | 	(((addrlen) == NETNS_ADDRLEN_V4) ? NETNS_NS_V4 : NETNS_NS_V6))
NETNS_NS_UDP_EPHEMERAL_RESERVE 4096
NETNS_STATE_HALFCLOSED 0x1
NETNS_STATE_WITHDRAWN 0x2
NETNS_STATE_BITS "\020\01HALFCLOSED\02WITHDRAWN"
NETNS_NS_TOKEN_ZONE_NAME "netns.ns_token"
NETNS_NS_FLOW_INFO_ZONE_NAME "netns.ns_flow_info"
NETNS_NS_RESERVATION_ZONE_NAME "netns.ns_reservation"
NSR_COMPARE(r1, r2)     ((int)(r1)->nsr_port - (int)(r2)->nsr_port)
_SKYWALK_NAMESPACE_NETNS_H_ None
NETNS_LISTENER 0x00
NETNS_SKYWALK 0x01
NETNS_BSD 0x02
NETNS_PF 0x03
NETNS_OWNER_MAX NETNS_PF
NETNS_OWNER_MASK 0x07
NETNS_PRERESERVED 0x10
NETNS_NOWAKEFROMSLEEP 0x20
NETNS_RECVANYIF 0x40
NETNS_EXTBGIDLE 0x80
NETNS_REUSEPORT 0x100
PROTONS_LOCK() lck_mtx_lock(&protons_lock)
PROTONS_UNLOCK() lck_mtx_unlock(&protons_lock)
PROTONS_LOCK_ASSERT_HELD() LCK_MTX_ASSERT(&protons_lock, LCK_MTX_ASSERT_OWNED)
PROTONS_LOCK_ASSERT_NOTHELD() LCK_MTX_ASSERT(&protons_lock, LCK_MTX_ASSERT_NOTOWNED)
_SKYWALK_NAMESPACE_PROTONS_H_ None
SKMEM_TAG_NX_KEY "com.apple.skywalk.nexus.key"
SKMEM_TAG_NX_MIB "com.apple.skywalk.nexus.mib"
SKMEM_TAG_NX_PORT "com.apple.skywalk.nexus.port"
SKMEM_TAG_NX_PORT_INFO "com.apple.skywalk.nexus.port.info"
MAX_NUM_REG_ENTRIES 256
MAX_NUM_NX_UUIDS 4096
MAX_NUM_CH_UUIDS 4096
BMASK64(_beg, _end)     	((NX_PORT_CHUNK_FREE >> (63 - (_end))) & ~((1ULL << (_beg)) - 1))
NA_NUM_WMM_CLASSES 4
NAKR_WMM_SC2RINGID(_s) PKT_SC2TC(_s)
NAKR_SET_SVC_LUT(_n, _s)                                        	(_n)->na_kring_svc_lut[MBUF_SCIDX(_s)] = NAKR_WMM_SC2RINGID(_s)
NAKR_SET_KR_SVC(_n, _s)                                         	NAKR((_n), NR_TX)[NAKR_WMM_SC2RINGID(_s)].ckr_svc = (_s)
NA_UPP_ALLOC_LOWAT 8
NA_UPP_REAP_INTERVAL 10
NA_UPP_WS_HOLD_TIME 2
NA_UPP_REAP_MIN_PKTS 0
NA_UPP_ALLOC_BUF_LOWAT 64
SKMEM_TAG_NX_RINGS "com.apple.skywalk.nexus.rings"
SKMEM_TAG_NX_CONTEXTS "com.apple.skywalk.nexus.contexts"
SKMEM_TAG_NX_SCRATCH "com.apple.skywalk.nexus.scratch"
ASSERT_COUNT_TYPES_MATCH(FIELD_NAME) _Static_assert(__builtin_types_compatible_p( 	                typeof(ring_counts . FIELD_NAME), 	                typeof(((struct __user_channel_schema*)0)->csm_ ## FIELD_NAME)), 	        "type for " # FIELD_NAME "doesn't match")
MAX_BUFLETS 64
_SKYWALK_NEXUS_ADAPTER_H_ None
NEXUS_ADAPTER_NAMELEN 64
NA_SYNCF_MONITOR 0x1
NA_SYNCF_FORCE_READ 0x2
NA_SYNCF_FORCE_RECLAIM 0x4
NA_SYNCF_NETIF 0x8
NA_SYNCF_NETIF_ASYNC 0x10
NA_SYNCF_NETIF_DOORBELL 0x20
NA_SYNCF_NETIF_IFSTART 0x40
NA_SYNCF_FORCE_UPP_SYNC 0x80
NA_SYNCF_UPP_PURGE 0x100
NA_SYNCF_SYNC_ONLY 0x200
NA_NOTEF_MONITOR 0x1
NA_NOTEF_IN_KEVENT 0x2
NA_NOTEF_CAN_SLEEP 0x4
NA_NOTEF_NETIF 0x8
NA_NOTEF_PUSH 0x100
NAF_ACTIVE 0x1
NAF_HOST_ONLY 0x2
NAF_SPEC_INIT 0x4
NAF_NATIVE 0x8
NAF_MEM_NO_INIT 0x10
NAF_SLOT_CONTEXT 0x20
NAF_USER_PKT_POOL 0x40
NAF_TX_MITIGATION 0x80
NAF_RX_MITIGATION 0x100
NAF_DEFUNCT 0x200
NAF_MEM_LOANED 0x400
NAF_REJECT 0x800
NAF_EVENT_RING 0x1000
NAF_CHANNEL_EVENT_ATTACHED 0x2000
NAF_VIRTUAL_DEVICE 0x8000
NAF_MODE_FSW 0x10000
NAF_MODE_LLW 0x20000
NAF_LOW_LATENCY 0x40000
NAF_DRAINING 0x80000
NAF_DEFUNCT_OK 0x100000
NAF_BITS "\020\01ACTIVE\02HOST_ONLY\03SPEC_INIT\04NATIVE"                 	"\05MEM_NO_INIT\06SLOT_CONTEXT\07USER_PKT_POOL"                  	"\010TX_MITIGATION\011RX_MITIGATION\012DEFUNCT\013MEM_LOANED"    	"\014REJECT\015EVENT_RING\016EVENT_ATTACH"                       	"\020VIRTUAL\021MODE_FSW\022MODE_LLW\023LOW_LATENCY\024DRAINING" 	"\025DEFUNCT_OK\040KERNEL_ONLY"
NA_FREE(na) do {                                                 	(na)->na_free(na);                                               } while (0)
_SKYWALK_NEXUS_COMMON_H_ None
_SKYWALK_NEXUS_IOCTL_H_ None
NXIOC_ADD_TRAFFIC_RULE_FLAG_PERSIST 0x0001
NXIOC_ADD_TRAFFIC_RULE_INET _IOWR('n', 1, struct nxctl_add_traffic_rule_inet_iocargs)
NXIOC_REMOVE_TRAFFIC_RULE _IOW('n', 2, struct nxctl_remove_traffic_rule_iocargs)
NTR_PROCNAME_SZ 64
NXIOC_GET_TRAFFIC_RULES _IOWR('n', 3, struct nxctl_get_traffic_rules_iocargs)
NXCTL_TRAFFIC_RULE_READ_ENTITLEMENT "com.apple.private.skywalk.traffic_rule.read"
NXCTL_TRAFFIC_RULE_WRITE_ENTITLEMENT "com.apple.private.skywalk.traffic_rule.write"
ASSERT_NXDOM_PARAMS(_dom, _var) do {                            	ASSERT(NXDOM_MIN(_dom, _var) <= NXDOM_MAX(_dom, _var));         	ASSERT(NXDOM_DEF(_dom, _var) >= NXDOM_MIN(_dom, _var));         	ASSERT(NXDOM_DEF(_dom, _var) <= NXDOM_MAX(_dom, _var));         } while (0)
NXPI_INVALID_CB_PAIRS(cb1, cb2)                                 	(!(init->nxpi_##cb1 == NULL && init->nxpi_##cb2 == NULL) &&     	((init->nxpi_##cb1 == NULL) ^ (init->nxpi_##cb2 == NULL)))
NXPROV_PARAMS_ADJUST(flag, param) do {                          	uint32_t _v0, _v;                                               	if (req & (flag))                                               	        _v = nxp0->nxp_##param;                                 	else                                                            	        _v = NXDOM_DEF(nxdom_def, param);                       	_v0 = _v;                                                       	if (nxprov_bound_var(&_v, NXDOM_DEF(nxdom_def, param),          	    NXDOM_MIN(nxdom_min, param), NXDOM_MAX(nxdom_max, param),   	    "nxp_" #param) < _v0) {                                     	        err = ENOMEM;                                           	        goto error;                                             	}                                                               	nxp->nxp_##param = _v;                                          } while (0)
MUL(x, y, z) do {                                               	if (__builtin_mul_overflow((x), (y), (z))) {                    	        overflowline = __LINE__;                                	        goto error;                                             	}                                                               } while (0)
ADD(x, y, z) do {                                               	if (__builtin_add_overflow((x), (y), (z))) {                    	        overflowline = __LINE__;                                	        goto error;                                             	}                                                               } while (0)
_SKYWALK_NEXUS_MBQ_H_ None
_SKYWALK_NEXUS_PKTQ_H_ None
NTR_FIND_FLAG_EXACT 0x0001
NTR_NOTIFY_FLAG_ADD 0x0001
NTR_NOTIFY_FLAG_REMOVE 0x0002
NTR_FLAG_PERSIST 0x0001
NTR_FLAG_ON_NXCTL_LIST 0x0002
ITDBIT(set, bit) (((set) != 0) ? (bit) : 0)
ITRM(proto, laddr, raddr, lport, rport) 	(IFNET_TRAFFIC_DESCRIPTOR_INET_IPVER | 	ITDBIT(proto, IFNET_TRAFFIC_DESCRIPTOR_INET_PROTO) | 	ITDBIT(laddr, IFNET_TRAFFIC_DESCRIPTOR_INET_LADDR) | 	ITDBIT(raddr, IFNET_TRAFFIC_DESCRIPTOR_INET_RADDR) | 	ITDBIT(lport, IFNET_TRAFFIC_DESCRIPTOR_INET_LPORT) | 	ITDBIT(rport, IFNET_TRAFFIC_DESCRIPTOR_INET_RPORT))
NXTR_WLOCK() lck_rw_lock_exclusive(&nxctl_traffic_rule_lock)
NXTR_WUNLOCK() lck_rw_unlock_exclusive(&nxctl_traffic_rule_lock)
NXTR_RLOCK() lck_rw_lock_shared(&nxctl_traffic_rule_lock)
NXTR_RUNLOCK() lck_rw_unlock_shared(&nxctl_traffic_rule_lock)
NXCTL_TRAFFIC_RULE_TAG "com.apple.skywalk.nexus.traffic_rule"
iph _l3._iph
ip6 _l3._ip6
tcph _l4._tcph
udph _l4._udph
_SKYWALK_NEXUS_NEXUSVAR_H_ None
NEXUSCTLF_ATTACHED 0x1
NEXUSCTLF_NOFDREF 0x2
NEXUSCTLF_KERNEL 0x4
NEXUSCTLF_BITS "\020\01ATTACHED\02NOFDREF\03KERNEL"
NXBF_MATCH_UNIQUEID 0x1
NXBF_MATCH_EXEC_UUID 0x2
NXBF_MATCH_KEY 0x4
NXBF_BITS "\020\01UNIQUEID\02EXEC_UUID\03KEY"
NX_PORT_CHUNK 64
NX_PORT_CHUNK_FREE 0xffffffffffffffff
NPI_NA_ENCODE(_p, _s)   (NPI_NA_ADDR_ENC(_p) | NPI_NA_STATE_ENC(_s))
NXF_ATTACHED 0x1
NXF_CLOSED 0x2
NXF_INVALIDATED 0x4
NXF_BITS "\020\01ATTACHED\02CLOSED\040REJECT"
NXPROVF_ATTACHED 0x1
NXPROVF_CLOSED 0x2
NXPROVF_EXTERNAL 0x4
NXPROVF_VIRTUAL_DEVICE 0x8
NXPROVF_BITS "\020\01ATTACHED\02CLOSED\03EXTERNAL\04VIRTUALDEV"
NX_LLINK_PROV(_nx) NXPROV_LLINK(NX_PROV(_nx))
nxdom_prov_init nxdom_prov_cb.dp_cb_init
nxdom_prov_fini nxdom_prov_cb.dp_cb_fini
nxdom_prov_params nxdom_prov_cb.dp_cb_params
nxdom_prov_mem_new nxdom_prov_cb.dp_cb_mem_new
nxdom_prov_config nxdom_prov_cb.dp_cb_config
nxdom_prov_nx_ctor nxdom_prov_cb.dp_cb_nx_ctor
nxdom_prov_nx_dtor nxdom_prov_cb.dp_cb_nx_dtor
nxdom_prov_nx_mem_info nxdom_prov_cb.dp_cb_nx_mem_info
nxdom_prov_nx_mib_get nxdom_prov_cb.dp_cb_nx_mib_get
nxdom_prov_nx_stop nxdom_prov_cb.dp_cb_nx_stop
NXDOMPROVF_INITIALIZED 0x1
NXDOMPROVF_ATTACHED 0x2
NXDOMPROVF_DETACHING 0x4
NXDOMPROVF_EXT 0x8
NXDOMPROVF_EXT_INITED 0x10
NXDOMPROVF_DEFAULT 0x20
NEXUSDOMF_INITIALIZED 0x1
NEXUSDOMF_ATTACHED 0x2
NEXUSDOMF_TERMINATED 0x4
NXDOM_DEF(_dom, var)    ((_dom)->nxdom_##var.nb_def)
NXDOM_MIN(_dom, var)    ((_dom)->nxdom_##var.nb_min)
NXDOM_MAX(_dom, var)    ((_dom)->nxdom_##var.nb_max)
NXCTL_LOCK(_nxctl) do {                    	if (!NX_SHARED_NXCTL_INSTANCE((_nxctl))) {      	        lck_mtx_lock(&((_nxctl)->nxctl_lock));  	} else {                                        	        LCK_MTX_ASSERT(&((_nxctl)->nxctl_lock), 	            LCK_MTX_ASSERT_NOTOWNED);           	}                                               } while (0)
NXCTL_UNLOCK(_nxctl) do {                    	if (!NX_SHARED_NXCTL_INSTANCE((_nxctl))) {      	        lck_mtx_unlock(&((_nxctl)->nxctl_lock));	}                                               	LCK_MTX_ASSERT(&((_nxctl)->nxctl_lock),         	    LCK_MTX_ASSERT_NOTOWNED);                   } while (0)
NXCTL_LOCK_ASSERT_HELD(_nxctl) do {            	if (!NX_SHARED_NXCTL_INSTANCE((_nxctl))) {      	        LCK_MTX_ASSERT(&((_nxctl)->nxctl_lock), 	            LCK_MTX_ASSERT_OWNED);              	} else {                                        	        LCK_MTX_ASSERT(&((_nxctl)->nxctl_lock), 	            LCK_MTX_ASSERT_NOTOWNED);           	}                                               } while (0)
_SKYWALK_OS_NEXUS_H_ None
NEXUS_PORT_USER_PIPE_CLIENT 0
NEXUS_PORT_USER_PIPE_SERVER 1
NEXUS_PORT_KERNEL_PIPE_CLIENT 0
NEXUS_PORT_NET_IF_DEV 0
NEXUS_PORT_NET_IF_HOST 1
NEXUS_PORT_NET_IF_CLIENT 2
NEXUS_PORT_FLOW_SWITCH_CLIENT 2
OS_NEXUS_HAS_USER_PACKET_POOL 1
NEXUS_MHINTS_NORMAL 0x0
NEXUS_MHINTS_WILLNEED 0x1
NEXUS_MHINTS_LOWLATENCY 0x2
NEXUS_MHINTS_HIUSE 0x4
NEXUS_NUM_WMM_QUEUES 4
nm_flowid_uuid __flowid_u.__uuid
nm_flowid_val8 __flowid_u.__val8
nm_flowid_val16 __flowid_u.__val16
nm_flowid_val32 __flowid_u.__val32
nm_flowid_val64 __flowid_u.__val64
NEXUS_BIND_PID 0x1
NEXUS_BIND_EXEC_UUID 0x2
NEXUS_BIND_KEY 0x4
NEXUS_MAX_KEY_LEN 1024
_SKYWALK_OS_NEXUS_PRIVATE_H_ None
NEXUSCTL_INIT_VERSION_1 1
NEXUSCTL_INIT_CURRENT_VERSION NEXUSCTL_INIT_VERSION_1
NXPF_ANONYMOUS 0x1
NXPF_USER_CHANNEL 0x2
NXPF_NETIF_LLINK 0x4
NXPF_BITS "\020\01ANONYMOUS\02USER_CHANNEL"
NXPCAP_CHECKSUM_PARTIAL 0x1
NXPCAP_USER_PACKET_POOL 0x2
NXPCAP_USER_CHANNEL 0x4
NXPCAP_BITS "\020\01CHECKSUM_PARTIAL\02USER_PKT_POOL\03USER_CHANNEL"
NXPROV_REG_VERSION_1 1
NXPROV_REG_CURRENT_VERSION NXPROV_REG_VERSION_1
NXPREQ_BITS "\020\01TX_RINGS\02RX_RINGS\03TX_SLOTS\04RX_SLOTS\05BUF_SIZE"   	"\06META_SIZE\07STATS_SIZE\010ANONYMOUS\011EXTRA_BUFS\012PIPES" 	"\013EXTENSIONS\014MHINTS\015FLOWADV_MAX\016QMAP"               	"\017CKSUM_OFFLOAD\020USER_PKT_POOL\021CAPABS\022NEXUSADV_SIZE" 	"\023IFINDEX\024USER_CHANNEL\025MAX_FRAGS\026REJ_CLOSE\027LBUF_SIZE"
NXOPT_NEXUS_PROV_LIST 1
NXOPT_NEXUS_PROV_ENTRY 2
NXOPT_NEXUS_LIST 20
NXOPT_NEXUS_BIND 21
NXOPT_NEXUS_UNBIND 22
NXOPT_CHANNEL_LIST 30
NXOPT_NEXUS_CONFIG 40
NBR_MATCH_PID 0x1
NBR_MATCH_EXEC_UUID 0x2
NBR_MATCH_KEY 0x4
NX_SPEC_IF_NAMELEN 64
nsr_name nsr_u.nsru_name
nsr_uuid nsr_u.nsru_uuid
nsr_ifp nsr_u.nsru_ifp
NXSPECREQ_UUID 0x1
NXSPECREQ_HOST 0x2
NXSPECREQ_IFP 0x1000
FLOW_DEMUX_MAX_LEN 32
MAX_FLOW_DEMUX_PATTERN 4
NXFLOWREQF_TRACK 0x0001
NXFLOWREQF_QOS_MARKING 0x0002
NXFLOWREQF_FILTER 0x0004
NXFLOWREQF_CUSTOM_ETHER 0x0008
NXFLOWREQF_IPV6_ULA 0x0010
NXFLOWREQF_LISTENER 0x0020
NXFLOWREQF_OVERRIDE_ADDRESS_SELECTION 0x0040
NXFLOWREQF_USE_STABLE_ADDRESS 0x0080
NXFLOWREQF_FLOWADV 0x0100
NXFLOWREQF_ASIS 0x0200
NXFLOWREQF_LOW_LATENCY 0x0400
NXFLOWREQF_NOWAKEFROMSLEEP 0x0800
NXFLOWREQF_REUSEPORT 0x1000
NXFLOWREQF_PARENT 0x4000
NXFLOWREQF_BITS "\020\01TRACK\02QOS_MARKING\03FILTER\04CUSTOM_ETHER\05IPV6_ULA" 	"\06LISTENER\07OVERRIDE_ADDRESS_SELECTION\010USE_STABLE_ADDRESS" 	"\011ALLOC_FLOWADV\012ASIS\013LOW_LATENCY\014NOWAKEUPFROMSLEEP" 	"\015REUSEPORT\017PARENT"
fk_src4 fk_src._v4
fk_dst4 fk_dst._v4
fk_src6 fk_src._v6
fk_dst6 fk_dst._v6
FLOW_KEY_LEN sizeof(struct flow_key)
FK_HASH_SEED 0xabcd
FKMASK_IPFLOW1 FKMASK_PROTO
FKMASK_IDX_MAX 7
FLOW_KEY_CLEAR(_fk) do {                                        	_CASSERT(FLOW_KEY_LEN == 48);                                   	_CASSERT(FLOW_KEY_LEN == sizeof(struct flow_key));              	sk_zero_48(_fk);                                                } while (0)
NXFLOWREQF_EXT_PORT_RSV 0x1000
NXFLOWREQF_EXT_PROTO_RSV 0x2000
NETIF_LLINK_MAX_QSETS 256
NETIF_LLINK_INFO_VERSION 0x01
_SKYWALK_OS_PACKET_H_ None
PKT_SCVAL_BK_SYS PKT_SCVAL(PKT_SC_BK_SYS)
PKT_SCVAL_BK PKT_SCVAL(PKT_SC_BK)
PKT_SCVAL_BE PKT_SCVAL(PKT_SC_BE)
PKT_SCVAL_RD PKT_SCVAL(PKT_SC_RD)
PKT_SCVAL_OAM PKT_SCVAL(PKT_SC_OAM)
PKT_SCVAL_AV PKT_SCVAL(PKT_SC_AV)
PKT_SCVAL_RV PKT_SCVAL(PKT_SC_RV)
PKT_SCVAL_VI PKT_SCVAL(PKT_SC_VI)
PKT_SCVAL_SIG PKT_SCVAL(PKT_SC_SIG)
PKT_SCVAL_VO PKT_SCVAL(PKT_SC_VO)
PKT_SCVAL_CTL PKT_SCVAL(PKT_SC_CTL)
PACKET_CSUM_PARTIAL 0x01
PACKET_CSUM_ZERO_INVERT 0x02
PACKET_CSUM_IP 0x0004
PACKET_CSUM_TCP 0x0008
PACKET_CSUM_UDP 0x0010
PACKET_CSUM_TCPIPV6 0x0020
PACKET_CSUM_UDPIPV6 0x0040
PACKET_CSUM_IP_CHECKED 0x0100
PACKET_CSUM_IP_VALID 0x0200
PACKET_CSUM_DATA_VALID 0x0400
PACKET_CSUM_PSEUDO_HDR 0x0800
PACKET_CSUM_TSO_IPV4 0x00100000
PACKET_CSUM_TSO_IPV6 0x00200000
OS_PACKET_HAS_CHECKSUM_API 1
OS_PACKET_HAS_SEGMENT_COUNT 1
OS_PACKET_HAS_TRACING_API 1
OS_PACKET_HAS_SEGMENT_SIZE 1
PKT_AGGR_NONE 0x00
PKT_AGGR_IP_CHAIN 0x01
PKT_AGGR_SINGLE_IP 0x02
PKT_AGGR_SINGLE_IP_PACKED 0x03
OS_PACKET_PKTID_VERSION_1 1
OS_PACKET_PKTID_VERSION_CURRENT OS_PACKET_PKTID_VERSION_1
_SKYWALK_OS_PACKET_PRIVATE_H_ None
flow_l3 flow_init.__l3
flow_classq flow_init.__classq
flow_ulen flow_init.__ulen
flow_ulp_encap flow_init.__ulp_encap
flow_source flow_init.__source
flow_policy flow_init.__policy
flow_ipv4_addrs flow_l3._l3_ipv4
flow_ipv4_src flow_l3._l3_ipv4._src
flow_ipv4_dst flow_l3._l3_ipv4._dst
flow_ipv6_addrs flow_l3._l3_ipv6
flow_ipv6_src flow_l3._l3_ipv6._src
flow_ipv6_dst flow_l3._l3_ipv6._dst
flow_ip_ver flow_l3._l3_ip_ver
flow_ip_proto flow_l3._l3_proto
flow_ip_hlen flow_l3._l3_hlen
flow_ip_hdr flow_l3._l3_ptr
flow_ip_frag_id flow_l3._l3_frag_id
flow_ip_is_frag flow_l3._l3_is_frag
flow_ip_is_first_frag flow_l3._l3_is_first_frag
flow_classq_hash flow_classq._fcq_hash
flow_classq_flags flow_classq._fcq_flags
flow_src_token flow_source._fsrc_id_32[0]
flow_src_id flow_source._fsrc_id
flow_src_fidx flow_source._fsrc_fidx
flow_src_type flow_source._fsrc_type
flow_policy_id flow_policy._fpc_id
flow_skip_policy_id flow_policy._fpc_skip_id
flow_policy_euuid flow_policy._fpc_euuid
flow_tcp flow_l4._l4_tcp
flow_tcp_src flow_l4._l4_tcp._src
flow_tcp_dst flow_l4._l4_tcp._dst
flow_tcp_seq flow_l4._l4_tcp._seq
flow_tcp_ack flow_l4._l4_tcp._ack
flow_tcp_off flow_l4._l4_tcp._off
flow_tcp_flags flow_l4._l4_tcp._flags
flow_tcp_win flow_l4._l4_tcp._win
flow_tcp_hlen flow_l4._l4_hlen
flow_tcp_hdr flow_l4._l4_ptr
flow_tcp_agg_fast flow_l4._l4_agg_fast
flow_udp flow_l4._l4_udp
flow_udp_src flow_l4._l4_udp._src
flow_udp_dst flow_l4._l4_udp._dst
flow_udp_hlen flow_l4._l4_hlen
flow_udp_hdr flow_l4._l4_ptr
flow_esp_spi flow_l4._l4_esp._spi
PKT_MAX_PROTO_HEADER_SIZE 256
BUFLETS_MIN 1
BUFLETS_9K_JUMBO 5
BUFLETS_GSO 46
BUFLET_FLAG_EXTERNAL 0x0001
BUFLET_FLAG_LARGE_BUF 0x0002
buf_addr buf_com.__baddr
buf_nbft_addr buf_com.__nbft_addr
buf_idx buf_com.__bidx
buf_nbft_idx buf_com.__nbft_idx
buf_dlim buf_com.__dlim
buf_dlen buf_com.__dlen
buf_doff buf_com.__doff
buf_flag buf_com.__flag
buf_bft_idx_reg buf_com.__bft_idx
BUF_BADDR(_buf, _addr)                                              	*__DECONST(mach_vm_address_t *, &(_buf)->buf_addr) =                	(mach_vm_address_t)(_addr)
BUF_BIDX(_buf, _idx)                                                	*__DECONST(obj_idx_t *, &(_buf)->buf_idx) = (obj_idx_t)(_idx)
BUF_NBFT_ADDR(_buf, _addr)                                          	*__DECONST(mach_vm_address_t *, &(_buf)->buf_nbft_addr) =           	(mach_vm_address_t)(_addr)
BUF_NBFT_IDX(_buf, _idx)                                            	*__DECONST(obj_idx_t *, &(_buf)->buf_nbft_idx) = (obj_idx_t)(_idx)
BUF_BFT_IDX_REG(_buf, _idx)    	*__DECONST(obj_idx_t *, &(_buf)->buf_bft_idx_reg) = (_idx)
UBUF_LINK(_pubft, _ubft) do {                                   	ASSERT((_ubft) != NULL);                                        	BUF_NBFT_ADDR(_pubft, _ubft);                                   	BUF_NBFT_IDX(_pubft, (_ubft)->buf_bft_idx_reg);                 } while (0)
BUF_CTOR(_buf, _baddr, _bidx, _dlim, _dlen, _doff, _nbaddr, _nbidx, _bflag) do {  	_CASSERT(sizeof ((_buf)->buf_addr) == sizeof (mach_vm_address_t)); 	_CASSERT(sizeof ((_buf)->buf_idx) == sizeof (obj_idx_t));       	_CASSERT(sizeof ((_buf)->buf_dlim) == sizeof (uint32_t));       	BUF_BADDR(_buf, _baddr);                                        	BUF_NBFT_ADDR(_buf, _nbaddr);                                   	BUF_BIDX(_buf, _bidx);                                          	BUF_NBFT_IDX(_buf, _nbidx);                                     	*(uint32_t *)(uintptr_t)&(_buf)->buf_dlim = (_dlim);            	(_buf)->buf_dlen = (_dlen);                                     	(_buf)->buf_doff = (_doff);                                     	*(uint16_t *)(uintptr_t)&(_buf)->buf_flag = (_bflag);           } while (0)
BUF_INIT(_buf, _dlen, _doff) do {                               	(_buf)->buf_dlen = (_dlen);                                     	(_buf)->buf_doff = (_doff);                                     } while (0)
__q_flow_id __flow_id_u.__uuid
__q_flow_id_val8 __flow_id_u.__val8
__q_flow_id_val16 __flow_id_u.__val16
__q_flow_id_val32 __flow_id_u.__val32
__q_flow_id_val64 __flow_id_u.__val64
qum_flow_id qum_com.__q_flow_id
qum_flow_id_val8 qum_com.__q_flow_id_val8
qum_flow_id_val16 qum_com.__q_flow_id_val16
qum_flow_id_val32 qum_com.__q_flow_id_val32
qum_flow_id_val64 qum_com.__q_flow_id_val64
qum_len qum_com.__q_len
qum_qflags qum_com.__q_flags
qum_svc_class qum_com.__q_svc_class
QUM_F_FINALIZED 0x0001
QUM_F_DROPPED 0x0002
QUM_F_FLOW_CLASSIFIED 0x0010
QUM_F_INTERNALIZED 0x1000
QUM_F_KERNEL_ONLY 0x8000
_KQUM_CTOR(_kqum, _flags, _len, _baddr, _bidx, _dlim, _qidx) do {    	(_kqum)->qum_flow_id_val64[0] = 0;                                   	(_kqum)->qum_flow_id_val64[1] = 0;                                   	(_kqum)->qum_qflags = (_flags);                                      	(_kqum)->qum_len = (_len);                                           	_CASSERT(sizeof(METADATA_IDX(_kqum)) == sizeof(obj_idx_t));          	*(obj_idx_t *)(uintptr_t)&METADATA_IDX(_kqum) = (_qidx);             	BUF_CTOR(&(_kqum)->qum_buf[0], (_baddr), (_bidx), (_dlim), 0, 0, 0,  	    OBJ_IDX_NONE, 0);                                                } while (0)
_KQUM_INIT(_kqum, _flags, _len, _qidx) do {                          	(_kqum)->qum_flow_id_val64[0] = 0;                                   	(_kqum)->qum_flow_id_val64[1] = 0;                                   	(_kqum)->qum_qflags = (_flags);                                      	(_kqum)->qum_len = (_len);                                           	BUF_INIT(&(_kqum)->qum_buf[0], 0, 0);                                } while (0)
__p_link_flags __pkt_com.__link_flags
__p_headroom __pkt_com.__headroom
__p_l2_len __pkt_com.__l2_len
__p_csum_flags __pkt_com.__csum_flags
__p_csum_rx __pkt_com.__csum_rx
__p_csum_tx __pkt_com.__csum_tx
__p_csum_data __pkt_com.__csum_data
__p_comp_gencnt __pkt_com.__comp_gencnt
__p_aggr_type __pkt_com.__aggr_type
__p_seg_cnt __pkt_com.__seg_cnt
__p_proto_seg_sz __pkt_com.__proto_seg_sz
__p_trace_id __pkt_com.__trace_id
__p_flags32 __pkt_com.__flags32
__p_flags __pkt_com.__flags
PKT_OPT_TOKEN_TYPE_OPAQUE 1
PKT_OPT_TOKEN_TYPE_PACKET_ID 2
PKT_OPT_MAX_TOKEN_SIZE 16
__po_token_type __pkt_opt_com.__token_type
__po_token_len __pkt_opt_com.__token_len
__po_vlan_tag __pkt_opt_com.__vlan_tag
__po_token_data __pkt_opt_com.__token_data
__po_token __pkt_opt_com.__token
__po_expire_ts __pkt_opt_com.__expire_ts
__po_expiry_action __pkt_opt_com.__expiry_action
__po_app_type __pkt_opt_com.__app_type
__po_app_metadata __pkt_opt_com.__app_metadata
__po_pkt_tx_time __pkt_opt_com.__pkt_tx_time
pkt_flow_id pkt_qum.qum_flow_id
pkt_flow_id_64 pkt_qum.qum_flow_id_val64
pkt_qum_qflags pkt_qum.qum_qflags
pkt_length pkt_qum.qum_len
pkt_qum_buf pkt_qum.qum_buf[0]
pkt_svc_class pkt_qum.qum_svc_class
pkt_flow_token pkt_qum.qum_flow_id_val32[0]
pkt_link_flags pkt_com.__p_link_flags
pkt_headroom pkt_com.__p_headroom
pkt_l2_len pkt_com.__p_l2_len
pkt_csum_flags pkt_com.__p_csum_flags
pkt_csum_rx_start_off pkt_com.__p_csum_rx.__csum_start_off
pkt_csum_rx_value pkt_com.__p_csum_rx.__csum_value
pkt_csum_tx_start_off pkt_com.__p_csum_tx.__csum_start_off
pkt_csum_tx_stuff_off pkt_com.__p_csum_tx.__csum_stuff_off
pkt_csum_data pkt_com.__p_csum_data
pkt_comp_gencnt pkt_com.__p_comp_gencnt
pkt_aggr_type pkt_com.__p_aggr_type
pkt_seg_cnt pkt_com.__p_seg_cnt
pkt_proto_seg_sz pkt_com.__p_proto_seg_sz
pkt_trace_id pkt_com.__p_trace_id
pkt_pflags32 pkt_com.__p_flags32[0]
pkt_pflags pkt_com.__p_flags
_USER_PACKET_SIZE(n) sizeof(struct __user_packet)
PKT_LINKF_BCAST 0x0001
PKT_LINKF_MCAST 0x0002
PKT_LINKF_ETHFCS 0x0004
__PKT_F_FLOW_ID 0x0000000000000001ULL
__PKT_F_FLOW_ADV 0x0000000000000002ULL
PKT_F_WAKE_PKT 0x0000000000000400ULL
PKT_F_BACKGROUND 0x0000000000008000ULL
PKT_F_KEEPALIVE 0x0000000000040000ULL
PKT_F_REALTIME 0x0000000000080000ULL
PKT_F_REXMT 0x0000000000200000ULL
__PKT_F_TX_COMPL_TS_REQ 0x0000000000800000ULL
__PKT_F_TS_VALID 0x0000000001000000ULL
__PKT_F_NEW_FLOW 0x0000000004000000ULL
__PKT_F_START_SEQ 0x0000000008000000ULL
PKT_F_LAST_PKT 0x0000000010000000ULL
PKT_F_OPT_GROUP_START 0x0000000100000000ULL
PKT_F_OPT_GROUP_END 0x0000000200000000ULL
PKT_F_OPT_EXPIRE_TS 0x0000000400000000ULL
PKT_F_OPT_TOKEN 0x0000000800000000ULL
__PKT_F_FLOW_DATA 0x0000001000000000ULL
__PKT_F_TX_COMPL_DATA 0x0000002000000000ULL
__PKT_F_MBUF_DATA 0x0000004000000000ULL
PKT_F_TRUNCATED 0x0000008000000000ULL
__PKT_F_PKT_DATA 0x0000010000000000ULL
PKT_F_PROMISC 0x0000020000000000ULL
PKT_F_OPT_VLTAG 0x0000040000000000ULL
PKT_F_OPT_VLTAG_IN_PKT 0x0000080000000000ULL
__PKT_F_TX_PORT_DATA 0x0000100000000000ULL
PKT_F_OPT_EXP_ACTION 0x0000200000000000ULL
PKT_F_OPT_APP_METADATA 0x0000400000000000ULL
PKT_F_L4S 0x0000800000000000ULL
PKT_F_OPT_TX_TIMESTAMP 0x0001000000000000ULL
__PKT_F_OPT_ALLOC 0x0100000000000000ULL
__PKT_F_FLOW_ALLOC 0x0200000000000000ULL
__PKT_F_TX_COMPL_ALLOC 0x0400000000000000ULL
PKT_F_FLOW_ID __PKT_F_FLOW_ID
PKT_F_FLOW_ADV __PKT_F_FLOW_ADV
PKT_F_TX_COMPL_TS_REQ __PKT_F_TX_COMPL_TS_REQ
PKT_F_TS_VALID __PKT_F_TS_VALID
PKT_F_NEW_FLOW __PKT_F_NEW_FLOW
PKT_F_START_SEQ __PKT_F_START_SEQ
PKT_F_FLOW_DATA __PKT_F_FLOW_DATA
PKT_F_TX_COMPL_DATA __PKT_F_TX_COMPL_DATA
PKT_F_MBUF_DATA __PKT_F_MBUF_DATA
PKT_F_PKT_DATA __PKT_F_PKT_DATA
PKT_F_OPT_ALLOC __PKT_F_OPT_ALLOC
PKT_F_FLOW_ALLOC __PKT_F_FLOW_ALLOC
PKT_F_TX_COMPL_ALLOC __PKT_F_TX_COMPL_ALLOC
PKT_F_TX_PORT_DATA __PKT_F_TX_PORT_DATA
SK_PTR_ENCODE(_p, _t, _s)       	(SK_PTR_ADDR_ENC(_p) | SK_PTR_TYPE_ENC(_t) | SK_PTR_SUBTYPE_ENC(_s))
_SKYWALK_PACKET_COMMON_H_ None
QUM_GET_NEXT_BUFLET(_qum, _pbuf, _buf) do {                     	ASSERT((_pbuf) == NULL || (_pbuf) == (_qum)->qum_buf);          	(_buf) = (((_pbuf) == NULL) ? (_qum)->qum_buf : NULL);          } while (0)
PKT_GET_FIRST_BUFLET(_pkt, _bcnt, _buf) do {                    	if (__improbable((_bcnt) == 0)) {                               	        (_buf) = NULL;                                          	        break;                                                  	}                                                               	if (__probable((_pkt)->pkt_qum_buf.buf_addr != 0)) {            	        (_buf) = &(_pkt)->pkt_qum_buf;                          	} else {                                                        	        (_buf) = __unsafe_forge_single(struct __kern_buflet *,  	            __DECONST(void *, (_pkt)->pkt_qum_buf.buf_nbft_addr));	}                                                               } while (0)
_PKT_GET_NEXT_BUFLET(_pkt, _bcnt, _pbuf, _buf) do {             	if ((_pbuf) == NULL) {                                          	        PKT_GET_FIRST_BUFLET(_pkt, _bcnt, _buf);                	} else {                                                        	        (_buf) = __unsafe_forge_single(struct __kern_buflet *,  	            __DECONST(void *, (_pbuf)->buf_nbft_addr));         	}                                                               } while (0)
PKT_COMPOSE_NX_PORT_ID(_nx_port, _gencnt)    	((uint32_t)((_gencnt & 0xffff) << 16) | (_nx_port & 0xffff))
PKT_DECOMPOSE_NX_PORT_ID(_nx_port_id, _nx_port, _gencnt) do {   	_nx_port = _nx_port_id & 0xffff;                                	_gencnt = (_nx_port_id >> 16) & 0xffff;                         } while (0)
_SKYWALK_PACKET_PACKETQUEUE_H_ None
KPKTQ_HEAD(name) struct name {                                                   	struct __kern_packet *kq_first;               	struct __kern_packet **kq_last;   	uint32_t kq_len;        }
KPKTQ_INIT(q) do {                            	KPKTQ_FIRST(q) = NULL;                                  	(q)->kq_last = &KPKTQ_FIRST(q);                         	(q)->kq_len = 0;                                        } while (0)
KPKTQ_FINI(q) do {                            	ASSERT(KPKTQ_EMPTY(q));                                 	ASSERT(KPKTQ_LEN(q) == 0);                              	KPKTQ_INIT(q);                                          } while (0)
KPKTQ_DISPOSE(q) KPKTQ_INIT(q)
KPKTQ_CONCAT(q1, q2)    do {                            	if (!KPKTQ_EMPTY(q2)) {                                 	        *(q1)->kq_last = KPKTQ_FIRST(q2);               	        (q1)->kq_last = (q2)->kq_last;                  	        (q1)->kq_len += (q2)->kq_len;                   	        KPKTQ_DISPOSE((q2));                            	}                                                       } while (0)
KPKTQ_PREPEND(q, p)     do {                            	if ((KPKTQ_NEXT(p) = KPKTQ_FIRST(q)) == NULL) {         	        ASSERT((q)->kq_len == 0);                       	        (q)->kq_last = &KPKTQ_NEXT(p);                 	}                                                       	KPKTQ_FIRST(q) = (p);                                   	(q)->kq_len++;                                          } while (0)
KPKTQ_ENQUEUE(q, p)     do {                            	ASSERT(KPKTQ_NEXT(p) == NULL);                          	*(q)->kq_last = (p);                                    	(q)->kq_last = &KPKTQ_NEXT(p);                          	(q)->kq_len++;                                          } while (0)
KPKTQ_ENQUEUE_MULTI(q, p, n, c)    do {                 	KPKTQ_NEXT(n) = NULL;                                   	*(q)->kq_last = (p);                                    	(q)->kq_last = &KPKTQ_NEXT(n);                          	(q)->kq_len += c;                                       } while (0)
KPKTQ_ENQUEUE_LIST(q, p)           do {                 	uint32_t _c = 1;                                        	struct __kern_packet *_n = (p);                         	while (__improbable(KPKTQ_NEXT(_n) != NULL)) {          	        _c++;                                           	        _n = KPKTQ_NEXT(_n);                            	}                                                       	KPKTQ_ENQUEUE_MULTI(q, p, _n, _c);                      } while (0)
KPKTQ_DEQUEUE(q, p)     do {                            	if (((p) = KPKTQ_FIRST(q)) != NULL) {                   	        (q)->kq_len--;                                  	        if ((KPKTQ_FIRST(q) = KPKTQ_NEXT(p)) == NULL) { 	                ASSERT((q)->kq_len == 0);               	                (q)->kq_last = &KPKTQ_FIRST(q);         	        } else {                                        	                KPKTQ_NEXT(p) = NULL;                   	        }                                               	}                                                       } while (0)
KPKTQ_REMOVE(q, p)      do {                            	if (KPKTQ_FIRST(q) == (p)) {                            	        KPKTQ_DEQUEUE(q, p);                            	} else {                                                	        struct __kern_packet *_p = KPKTQ_FIRST(q);      	        while (KPKTQ_NEXT(_p) != (p))                   	                _p = KPKTQ_NEXT(_p);                    	        if ((KPKTQ_NEXT(_p) =                           	            KPKTQ_NEXT(KPKTQ_NEXT(_p))) == NULL) {      	                (q)->kq_last = &KPKTQ_NEXT(_p);         	        }                                               	        (q)->kq_len--;                                  	        KPKTQ_NEXT(p) = NULL;                           	}                                                       } while (0)
KPKTQ_FOREACH(p, q)                                     	for ((p) = KPKTQ_FIRST(q);                              	    (p);                                                	    (p) = KPKTQ_NEXT(p))
KPKTQ_FOREACH_SAFE(p, q, tvar)                          	for ((p) = KPKTQ_FIRST(q);                              	    (p) && ((tvar) = KPKTQ_NEXT(p), 1);                 	    (p) = (tvar))
_SKYWALK_PACKET_PACKETVAR_H_ None
buf_objaddr buf_ctl->bc_addr
buf_objlim buf_ctl->bc_lim
KBUF_CTOR(_kbuf, _baddr, _bidxreg, _bc, _pp, _large) do {       	_CASSERT(sizeof ((_kbuf)->buf_addr) == sizeof (mach_vm_address_t));	                                  	BUF_CTOR(_kbuf, _baddr, _bidxreg, (_large) ? PP_BUF_SIZE_LARGE(_pp) :	    PP_BUF_SIZE_DEF(_pp), 0, 0, (_kbuf)->buf_nbft_addr,         	    (_kbuf)->buf_nbft_idx, (_kbuf)->buf_flag);                  	*(struct skmem_bufctl **)(uintptr_t)&(_kbuf)->buf_ctl = (_bc);  	           	if (__probable((_bc) != NULL)) {                                	        skmem_bufctl_use(_bc);                                  	}                                                               	 } while (0)
KBUF_EXT_CTOR(_kbuf, _ubuf, _baddr, _bidxreg, _bc,              	    _bft_idx_reg, _pp, _large) do {                             	ASSERT(_bft_idx_reg != OBJ_IDX_NONE);                           	_CASSERT(sizeof((_kbuf)->buf_flag) == sizeof(uint16_t));        	 	 	*__DECONST(uint16_t *, &(_kbuf)->buf_flag) = BUFLET_FLAG_EXTERNAL;	if (_large) {                                                   	        *__DECONST(uint16_t *, &(_kbuf)->buf_flag) |=           	            BUFLET_FLAG_LARGE_BUF;                              	}                                                               	BUF_NBFT_IDX(_kbuf, OBJ_IDX_NONE);                              	BUF_BFT_IDX_REG(_kbuf, _bft_idx_reg);                           	*__DECONST(struct __user_buflet **,                             	&((struct __kern_buflet_ext *)(_kbuf))->kbe_buf_user) = (_ubuf);	KBUF_CTOR(_kbuf, _baddr, _bidxreg, _bc, _pp, _large);           } while (0)
KBUF_INIT(_kbuf) do {                                           	ASSERT((_kbuf)->buf_ctl != NULL);                               	ASSERT((_kbuf)->buf_addr != 0);                                 	ASSERT((_kbuf)->buf_dlim != 0);                                 	                                  	BUF_INIT(_kbuf, 0, 0);                                          } while (0)
KBUF_EXT_INIT(_kbuf, _pp) do {                                  	ASSERT((_kbuf)->buf_ctl != NULL);                               	ASSERT((_kbuf)->buf_flag & BUFLET_FLAG_EXTERNAL);               	ASSERT((_kbuf)->buf_bft_idx_reg != OBJ_IDX_NONE);               	BUF_BADDR(_kbuf, (_kbuf)->buf_ctl->bc_addr);                    	BUF_NBFT_ADDR(_kbuf, 0);                                        	BUF_NBFT_IDX(_kbuf, OBJ_IDX_NONE);                              	*__DECONST(uint32_t *, &(_kbuf)->buf_dlim) =                    	BUFLET_HAS_LARGE_BUF(_kbuf) ? PP_BUF_SIZE_LARGE((_pp)) :        	PP_BUF_SIZE_DEF((_pp));                                         	(_kbuf)->buf_dlen = 0;                                          	(_kbuf)->buf_doff = 0;                                          	((struct __kern_buflet_ext *__unsafe_indexable)(_kbuf))->kbe_buf_pid = (pid_t)-1; 	((struct __kern_buflet_ext *__unsafe_indexable)(_kbuf))->kbe_buf_upp_link.sle_next = NULL;} while (0)
UBUF_INIT(_kbuf, _ubuf) do {                                    	BUF_CTOR(_ubuf, 0, (_kbuf)->buf_idx, (_kbuf)->buf_dlim,         	    (_kbuf)->buf_dlen, (_kbuf)->buf_doff, (_kbuf)->buf_nbft_addr,	    (_kbuf)->buf_nbft_idx, (_kbuf)->buf_flag);                  	BUF_BFT_IDX_REG(_ubuf, (_kbuf)->buf_bft_idx_reg);              } while (0)
KBUF_EXTERNALIZE(_kbuf, _ubuf, _pp) do {                       	ASSERT((_kbuf)->buf_dlim == BUFLET_HAS_LARGE_BUF(_kbuf) ?      	    PP_BUF_SIZE_LARGE((_pp)) : PP_BUF_SIZE_DEF((_pp)));        	ASSERT((_kbuf)->buf_addr != 0);                                	        	        	        	ASSERT((_kbuf)->buf_addr == (mach_vm_address_t)(_kbuf)->buf_objaddr);	       	UBUF_INIT(_kbuf, _ubuf);                                       } while (0)
KBUF_LINK(_pkbuf, _kbuf) do {                                   	ASSERT(__DECONST(void *, (_pkbuf)->buf_nbft_addr) == NULL);     	ASSERT(__DECONST(obj_idx_t, (_pkbuf)->buf_nbft_idx) == OBJ_IDX_NONE); 	ASSERT((_kbuf) != NULL);                                        	ASSERT((_kbuf)->buf_bft_idx_reg != OBJ_IDX_NONE);               	BUF_NBFT_ADDR(_pkbuf, _kbuf);                                   	BUF_NBFT_IDX(_pkbuf, (_kbuf)->buf_bft_idx_reg);                 } while (0)
KBUF_DTOR(_kbuf, _usecnt) do {                                  	if (__probable((_kbuf)->buf_ctl != NULL)) {                     	        (_usecnt) = skmem_bufctl_unuse(                         	            __DECONST(struct skmem_bufctl *, (_kbuf)->buf_ctl));	        *(struct skmem_bufctl **)                               	            (uintptr_t)&(_kbuf)->buf_ctl = NULL;                	}                                                               	BUF_BADDR(_kbuf, 0);                                            	BUF_BIDX(_kbuf, OBJ_IDX_NONE);                                  } while (0)
_KBUF_COPY(_skb, _dkb) do {                                     	ASSERT((_skb)->buf_nbft_addr == 0);                             	ASSERT((_skb)->buf_nbft_idx == OBJ_IDX_NONE);                   	ASSERT(!((_dkb)->buf_flag & BUFLET_FLAG_EXTERNAL));             	_CASSERT(sizeof(struct __kern_buflet) == 50);                   	                      	sk_copy64_40((uint64_t *)(void *)(_skb), (uint64_t *)(void *)(_dkb));	((uint64_t *)(void *)(_dkb))[5] = ((uint64_t *)(void *)(_skb))[5];   	((uint16_t *)(void *)(_dkb))[24] = ((uint16_t *)(void *)(_skb))[24]; 	ASSERT((_dkb)->buf_ctl == (_skb)->buf_ctl);                     	_CASSERT(sizeof((_dkb)->buf_flag) == sizeof(uint16_t));         	*__DECONST(uint16_t *, &(_dkb)->buf_flag) &= ~BUFLET_FLAG_EXTERNAL;	if (__probable((_dkb)->buf_ctl != NULL)) {                      	        skmem_bufctl_use(__DECONST(struct skmem_bufctl *,       	            (_dkb)->buf_ctl));                                  	}                                                               } while (0)
KQUM_CTOR(_kqum, _midx, _uqum, _pp, _qflags) do {               	ASSERT((uintptr_t)(_kqum) != (uintptr_t)(_uqum));               	_CASSERT(sizeof(METADATA_IDX(_kqum)) == sizeof(obj_idx_t));     	                                  	_KQUM_CTOR(_kqum, (PP_KERNEL_ONLY(_pp) ?                        	    QUM_F_KERNEL_ONLY : 0) | _qflags, 0, 0, OBJ_IDX_NONE,       	    PP_BUF_SIZE_DEF((_pp)), _midx);                             	_CASSERT(NEXUS_META_TYPE_MAX <= UINT16_MAX);                    	METADATA_TYPE(_kqum) = (uint16_t)(_pp)->pp_md_type;             	_CASSERT(NEXUS_META_SUBTYPE_MAX <= UINT16_MAX);                 	METADATA_SUBTYPE(_kqum) = (uint16_t)(_pp)->pp_md_subtype;       	*(struct kern_pbufpool **)(uintptr_t)&(_kqum)->qum_pp = (_pp);  	*(struct __user_quantum **)(uintptr_t)&(_kqum)->qum_user = (_uqum); 	*(obj_idx_t *)(uintptr_t)&METADATA_IDX(_kqum) = (_midx);        	(_kqum)->qum_pid = (pid_t)-1;                                   	*(struct __kern_slot_desc **)(uintptr_t)&(_kqum)->qum_ksd = NULL;	 } while (0)
KQUM_INIT(_kqum, _flags) do {                                   	ASSERT((_kqum)->qum_ksd == NULL);                               	ASSERT((_kqum)->qum_pid == (pid_t)-1);                          	                                  	_KQUM_INIT(_kqum, (PP_KERNEL_ONLY((_kqum)->qum_pp) ?            	    QUM_F_KERNEL_ONLY : 0) | _flags, 0, METADATA_IDX(_kqum));   	 } while (0)
_UUID_COPY(_dst, _src) do {                                     	_CASSERT(sizeof (uuid_t) == 16);                                	sk_copy64_16((uint64_t *)(void *)_src, (uint64_t *)(void *)_dst); } while (0)
_UUID_CLEAR(_u) do {                            	uint64_t *__dst = (uint64_t *)(void *)(_u);     	_CASSERT(sizeof (uuid_t) == 16);                	*(__dst++) = 0;                      	*(__dst)   = 0;                      } while (0)
_QUM_COPY(_skq, _dkq) do {                                          	volatile uint16_t _sf = ((_dkq)->qum_qflags & QUM_F_SAVE_MASK);     	_CASSERT(sizeof (_sf) == sizeof ((_dkq)->qum_qflags));              	_CASSERT(offsetof(struct __quantum, __q_flags) == 24);              	               	sk_copy64_24((uint64_t *)(void *)&(_skq)->qum_com,                  	    (uint64_t *)(void *)&(_dkq)->qum_com);                          	                         	(_dkq)->qum_qflags = ((_skq)->qum_qflags & ~QUM_F_SAVE_MASK) | _sf; } while (0)
_QUM_INTERNALIZE(_uq, _kq) do {                                 	_QUM_COPY(_uq, _kq);                                            	                              	(_kq)->qum_qflags &= QUM_F_SAVE_MASK;                           } while (0)
_QUM_EXTERNALIZE(_kq, _uq) do {                                  	_CASSERT(offsetof(struct __quantum, __q_flags) == 24);           	_CASSERT(sizeof(METADATA_IDX(_uq)) == sizeof(obj_idx_t));        	                        	sk_copy64_24((uint64_t *)(void *)&(_kq)->qum_com,                	    (uint64_t *)(void *)&(_uq)->qum_com);                        	                       	(_uq)->qum_qflags = ((_kq)->qum_qflags & ~QUM_F_KERNEL_FLAGS);   	                                	*(obj_idx_t *)(uintptr_t)&METADATA_IDX(_uq) = METADATA_IDX(_kq); 	METADATA_TYPE(_uq) = METADATA_TYPE(_kq);                         	METADATA_SUBTYPE(_uq) = METADATA_SUBTYPE(_kq);                   	(_uq)->qum_usecnt = 0;                                           } while (0)
pkt_user pkt_qum.qum_user
pkt_flow_ipv4_addrs pkt_flow->flow_ipv4_addrs
pkt_flow_ipv4_src pkt_flow->flow_ipv4_src
pkt_flow_ipv4_dst pkt_flow->flow_ipv4_dst
pkt_flow_ipv6_addrs pkt_flow->flow_ipv6_addrs
pkt_flow_ipv6_src pkt_flow->flow_ipv6_src
pkt_flow_ipv6_dst pkt_flow->flow_ipv6_dst
pkt_flow_ip_ver pkt_flow->flow_ip_ver
pkt_flow_ip_proto pkt_flow->flow_ip_proto
pkt_flow_ip_hdr pkt_flow->flow_ip_hdr
pkt_flow_tcp pkt_flow->flow_tcp
pkt_flow_tcp_src pkt_flow->flow_tcp_src
pkt_flow_tcp_dst pkt_flow->flow_tcp_dst
pkt_flow_tcp_seq pkt_flow->flow_tcp_seq
pkt_flow_tcp_ack pkt_flow->flow_tcp_ack
pkt_flow_tcp_off pkt_flow->flow_tcp_off
pkt_flow_tcp_flags pkt_flow->flow_tcp_flags
pkt_flow_tcp_win pkt_flow->flow_tcp_win
pkt_flow_tcp_hlen pkt_flow->flow_tcp_hlen
pkt_flow_tcp_hdr pkt_flow->flow_tcp_hdr
pkt_flow_tcp_agg_fast pkt_flow->flow_tcp_agg_fast
pkt_flow_udp pkt_flow->flow_udp
pkt_flow_udp_src pkt_flow->flow_udp_src
pkt_flow_udp_dst pkt_flow->flow_udp_dst
pkt_flow_udp_hlen pkt_flow->flow_udp_hlen
pkt_flow_udp_hdr pkt_flow->flow_udp_hdr
pkt_flow_esp_spi pkt_flow->flow_esp_spi
pkt_transport_protocol pkt_flow->flow_ulp_encap
pkt_flow_ip_hlen pkt_flow->flow_ip_hlen
pkt_flow_ulen pkt_flow->flow_ulen
pkt_flow_ip_frag_id pkt_flow->flow_ip_frag_id
pkt_flow_ip_is_frag pkt_flow->flow_ip_is_frag
pkt_flow_ip_is_first_frag pkt_flow->flow_ip_is_first_frag
pkt_flowsrc_token pkt_flow->flow_src_token
pkt_flowsrc_id pkt_flow->flow_src_id
pkt_flowsrc_fidx pkt_flow->flow_src_fidx
pkt_flowsrc_type pkt_flow->flow_src_type
pkt_classq_hash pkt_flow->flow_classq_hash
pkt_classq_flags pkt_flow->flow_classq_flags
pkt_policy_id pkt_flow->flow_policy_id
pkt_skip_policy_id pkt_flow->flow_skip_policy_id
pkt_policy_euuid pkt_flow->flow_policy_euuid
pkt_tx_compl_data pkt_tx_compl->compl_data
pkt_tx_compl_data64 pkt_tx_compl->compl_data64
pkt_tx_compl_cb_arg pkt_tx_compl->compl_data._cb_arg
pkt_tx_compl_cb_data pkt_tx_compl->compl_data._cb_data
pkt_tx_compl_status pkt_tx_compl->compl_data._tx_status
pkt_tx_compl_callbacks pkt_tx_compl->compl_callbacks
pkt_tx_compl_context pkt_tx_compl->compl_context
_KERN_PACKET_SIZE(n) sizeof(struct __kern_packet)
_PKT_COM_INIT(_p, _pflags) do {                                 	             	volatile uint64_t __pflags = (_pflags);                         	                                       	_CASSERT(sizeof(struct __packet_com) == 32);                    	_CASSERT(sizeof(struct __packet) == 32);                        	sk_zero_32(&(_p)->pkt_com.__pkt_data[0]);                       	                                           	(_p)->pkt_pflags = (__pflags);                                  	(_p)->pkt_svc_class = KPKT_SC_UNSPEC;                           } while (0)
_PKT_CTOR(_p, _pflags, _bufcnt, _maxfrags) do {                 	_PKT_COM_INIT(_p, _pflags);                                     	_CASSERT(sizeof ((_p)->pkt_bufs_max) == sizeof (uint16_t));     	_CASSERT(sizeof ((_p)->pkt_bufs_cnt) == sizeof (uint16_t));     	                                                   	*(uint16_t *)(uintptr_t)&(_p)->pkt_bufs_max = (_maxfrags);      	*(uint16_t *)(uintptr_t)&(_p)->pkt_bufs_cnt = (_bufcnt);        } while (0)
KPKT_CLEAR_MBUF_PKT_DATA(_pk) do {                              	_CASSERT(offsetof(struct __kern_packet, pkt_mbuf) ==            	    offsetof(struct __kern_packet, pkt_pkt));                   	(_pk)->pkt_pflags &= ~(PKT_F_MBUF_MASK|PKT_F_PKT_MASK);         	                         	(_pk)->pkt_mbuf = NULL;                                         } while (0)
KPKT_CLEAR_MBUF_DATA(_pk) do {                                  	(_pk)->pkt_pflags &= ~PKT_F_MBUF_MASK;                          	(_pk)->pkt_mbuf = NULL;                                         } while (0)
KPKT_CLEAR_PKT_DATA(_pk) do {                                   	(_pk)->pkt_pflags &= ~PKT_F_PKT_MASK;                           	(_pk)->pkt_pkt = NULL;                                          } while (0)
KPKT_CLEAR_FLOW_INIT(_fl) do {                                  	_CASSERT(sizeof ((_fl)->flow_init_data) == 128);                	sk_zero_128(&(_fl)->flow_init_data[0]);                         } while (0)
KPKT_CLEAR_FLOW_ALL(_fl) do {                                   	bzero(_fl, sizeof(struct __flow));                              } while (0)
_KPKT_CTOR_PRIV_VARS(_p, _opt, _flow, _txcomp) do {             	(_p)->pkt_com_opt = (_opt);                                     	(_p)->pkt_flow = (_flow);                                       	(_p)->pkt_tx_compl = (_txcomp);                                 } while (0)
_KPKT_INIT_FPD_VARS(_p) None
_KPKT_INIT_PRIV_VARS(_p) do {                                   	struct __flow *__fl = (_p)->pkt_flow;                           	(_p)->pkt_timestamp = 0;                                        	(_p)->pkt_nextpkt = NULL;                                       	(_p)->pkt_priv = NULL;                                          	_KPKT_INIT_FPD_VARS(_p);                                        	KPKT_CLEAR_MBUF_PKT_DATA(_p);                                   	if (__probable(__fl != NULL)) {                                 	        KPKT_CLEAR_FLOW_INIT(__fl);                             	}                                                               	(_p)->pkt_chain_count = (_p)->pkt_chain_bytes = 0;              	(_p)->pkt_nx_port = NEXUS_PORT_ANY;                             	(_p)->pkt_vpna_gencnt = 0;                                      	(_p)->pkt_trace_tag = 0;                                        	(_p)->pkt_qset_idx = 0;                                         } while (0)
KPKT_CTOR(_pk, _pflags, _opt, _flow, _txcomp, _midx, _pu, _pp,  	    _bufcnt, _maxfrags, _qflags) do {                           	ASSERT((uintptr_t)(_pk) != (uintptr_t)(_pu));                   	             	                                 	KQUM_CTOR(&(_pk)->pkt_qum, _midx,                               	    (((_pu) == NULL) ? NULL : &(_pu)->pkt_qum), _pp, _qflags);  	                                     	_PKT_CTOR(_pk, _pflags, _bufcnt, _maxfrags);                    	_KPKT_CTOR_PRIV_VARS(_pk, _opt, _flow, _txcomp);                	 } while (0)
KPKT_INIT(_pk, _flags) do {                                     	KQUM_INIT(&(_pk)->pkt_qum, _flags);                             	_PKT_COM_INIT(_pk, (_pk)->pkt_pflags);                          	_KPKT_INIT_PRIV_VARS(_pk);                                      	 } while (0)
_KPKT_INIT_TX_COMPL_DATA(_p) do {                               	if (((_p)->pkt_pflags & PKT_F_TX_COMPL_DATA) == 0) {            	        ASSERT((_p)->pkt_pflags & PKT_F_TX_COMPL_ALLOC);        	        (_p)->pkt_pflags |= PKT_F_TX_COMPL_DATA;                	        _CASSERT(sizeof((_p)->pkt_tx_compl_data64) == 24);      	          	        _CASSERT(sizeof((_p)->pkt_tx_compl_data) <= 24);        	        (_p)->pkt_tx_compl_data64[0] = 0;                       	        (_p)->pkt_tx_compl_data64[1] = 0;                       	        (_p)->pkt_tx_compl_data64[2] = 0;                       	}                                                               } while (0)
_PKT_COPY_OPT_DATA(_skp, _dkp) do {                             	if (__improbable(((_skp)->pkt_pflags & PKT_F_OPT_DATA) != 0)) { 	        _CASSERT(sizeof(struct __packet_opt) == 40);            	        ASSERT((_skp)->pkt_pflags & PKT_F_OPT_ALLOC);           	        sk_copy64_40((uint64_t *)(struct __packet_opt *__header_bidi_indexable)(_skp)->pkt_com_opt,   	            (uint64_t *)(struct __packet_opt *__header_bidi_indexable)(_dkp)->pkt_com_opt);           	}                                                               } while (0)
_PKT_COPY(_skp, _dkp) do {                                      	_CASSERT(sizeof(struct __packet) == 32);                        	_CASSERT(sizeof(struct __packet_com) == 32);                    	_CASSERT(offsetof(struct __packet, __p_flags) == 24);           	                        	sk_copy64_24((uint64_t *)(struct __packet *__header_bidi_indexable)&(_skp)->pkt_com,    	    (uint64_t *)(struct __packet *__header_bidi_indexable)&(_dkp)->pkt_com);            	                             	(_dkp)->pkt_pflags = ((_skp)->pkt_pflags & PKT_F_COPY_MASK);    	                           	_PKT_COPY_OPT_DATA((_skp), (_dkp));                             } while (0)
_PKT_COPY_TX_PORT_DATA(_skp, _dkp) do {                         (_dkp)->pkt_nx_port = (_skp)->pkt_nx_port;                    (_dkp)->pkt_vpna_gencnt = (_skp)->pkt_vpna_gencnt;            (_dkp)->pkt_pflags |= ((_skp)->pkt_pflags & PKT_F_TX_PORT_DATA);} while (0)
_PKT_INTERNALIZE(_up, _kp) do {                                 	volatile uint64_t _kf = ((_kp)->pkt_pflags & ~PKT_F_USER_MASK); 	_CASSERT(sizeof(struct __packet) == 32);                        	_CASSERT(sizeof(struct __packet_com) == 32);                    	_CASSERT(offsetof(struct __packet, __p_flags) == 24);           	                        	sk_copy64_24((uint64_t *)(void *)&(_up)->pkt_com,               	    (uint64_t *)(void *)&(_kp)->pkt_com);                       	                   	(_kp)->pkt_pflags = ((_up)->pkt_pflags & PKT_F_USER_MASK) | _kf;	             	if (__improbable(((_kp)->pkt_pflags & PKT_F_OPT_DATA) != 0)) {  	        _CASSERT(sizeof(struct __packet_opt) == 40);            	        ASSERT((_kp)->pkt_pflags & PKT_F_OPT_ALLOC);            	        sk_copy64_40((uint64_t *)(void *)&(_up)->pkt_com_opt,   	            (uint64_t *)(struct __packet_opt *__header_bidi_indexable)(_kp)->pkt_com_opt); 	}                                                               } while (0)
_PKT_EXTERNALIZE(_kp, _up) do {                                 	_CASSERT(sizeof(struct __packet) == 32);                        	_CASSERT(sizeof(struct __packet_com) == 32);                    	_CASSERT(offsetof(struct __packet, __p_flags) == 24);           	                        	sk_copy64_24((uint64_t *)(void *)&(_kp)->pkt_com,               	    (uint64_t *)(void *)&(_up)->pkt_com);                       	                     	(_up)->pkt_pflags = ((_kp)->pkt_pflags & PKT_F_USER_MASK);      	             	if (__improbable(((_kp)->pkt_pflags & PKT_F_OPT_DATA) != 0)) {  	        _CASSERT(sizeof(struct __packet_opt) == 40);            	        ASSERT((_kp)->pkt_pflags & PKT_F_OPT_ALLOC);            	        sk_copy64_40((uint64_t *)(struct __packet_opt *__header_bidi_indexable)(_kp)->pkt_com_opt, 	            (uint64_t *)(void *)&(_up)->pkt_com_opt);           	}                                                               } while (0)
SK_PTR_ADDR_KQUM(_ph) __unsafe_forge_single(struct __kern_quantum *, 	                            (SK_PTR_ADDR(_ph)))
SK_PTR_ADDR_KPKT(_ph) __unsafe_forge_single(struct __kern_packet *, 	                            (SK_PTR_ADDR(_ph)))
METADATA_SET_LEN(_md, _len, _doff) do {                         	struct __kern_quantum *_q =                                     	    (struct __kern_quantum *)(void *)(_md);                     	_q->qum_len = (_len);                                           	switch (METADATA_TYPE(_q)) {                                    	case NEXUS_META_TYPE_PACKET: {                                  	        struct __kern_packet *_p =                              	            (struct __kern_packet *)(void *)(_md);              	        struct __kern_buflet *_kbft;                            	        PKT_GET_FIRST_BUFLET(_p, _p->pkt_bufs_cnt, _kbft);      	        _kbft->buf_dlen = (_len);                               	        _kbft->buf_doff = (_doff);                              	        break;                                                  	}                                                               	default:                                                        	        ASSERT(METADATA_TYPE(_q) == NEXUS_META_TYPE_QUANTUM);   	        _q->qum_buf[0].buf_dlen = (_len);                       	        _q->qum_buf[0].buf_doff = (_doff);                      	        break;                                                  	}                                                               } while (0)
METADATA_ADJUST_LEN(_md, _len, _doff) do {                      	struct __kern_quantum *_q =                                     	    (struct __kern_quantum *)(void *)(_md);                     	switch (METADATA_TYPE(_q)) {                                    	case NEXUS_META_TYPE_PACKET: {                                  	        struct __kern_packet *_p =                              	            (struct __kern_packet *)(void *)(_md);              	        struct __kern_buflet *_kbft;                            	        PKT_GET_FIRST_BUFLET(_p, _p->pkt_bufs_cnt, _kbft);      	        _kbft->buf_dlen += (_len);                               	        _kbft->buf_doff = (_doff);                              	        break;                                                  	}                                                               	default:                                                        	        ASSERT(METADATA_TYPE(_q) == NEXUS_META_TYPE_QUANTUM);   	        _q->qum_buf[0].buf_dlen += (_len);                      	        _q->qum_buf[0].buf_doff = (_doff);                      	        break;                                                  	}                                                               } while (0)
KERN_PBUFPOOL_U_HASH_SIZE 64
KERN_BUF_MIN_STRIDING_SIZE 32 * 1024
KERN_PBUFPOOL_U_HASH_INDEX(_i, _m)                      	(((_i) * 2654435761U) & (_m))
KERN_PBUFPOOL_U_HASH(_pp, _i)                           	(&(_pp)->pp_u_hash_table[KERN_PBUFPOOL_U_HASH_INDEX(_i, 	KERN_PBUFPOOL_U_HASH_SIZE - 1)])
KERN_PBUFPOOL_U_BFT_HASH(_pp, _i)                           	(&(_pp)->pp_u_bft_hash_table[KERN_PBUFPOOL_U_HASH_INDEX(_i, 	KERN_PBUFPOOL_U_HASH_SIZE - 1)])
SKMEM_TAG_PBUFPOOL_HASH "com.apple.skywalk.pbufpool.hash"
SKMEM_TAG_PBUFPOOL_BFT_HASH "com.apple.skywalk.pbufpool.bft.hash"
PP_U_HTBL_SIZE sizeof(struct kern_pbufpool_u_htbl)
KBI_INVALID_CB_PAIRS(cb1, cb2)                                  	(!(init->kbi_##cb1 == NULL && init->kbi_##cb2 == NULL) &&       	((init->kbi_##cb1 == NULL) ^ (init->kbi_##cb2 == NULL)))
_SKYWALK_PACKET_PBUFPOOLVAR_H_ None
PBUFPOOL_MAX_BUF_REGIONS 2
PBUFPOOL_BUF_IDX_DEF 0
PBUFPOOL_BUF_IDX_LARGE 1
PPF_EXTERNAL 0x1
PPF_CLOSED 0x2
PPF_MONOLITHIC 0x4
PPF_TRUNCATED_BUF 0x8
PPF_KERNEL 0x10
PPF_BUFFER_ON_DEMAND 0x20
PPF_BATCH 0x40
PPF_DYNAMIC 0x80
PPF_LARGE_BUF 0x100
PP_LOCK(_pp) lck_mtx_lock(&_pp->pp_lock)
PP_LOCK_ASSERT_HELD(_pp) LCK_MTX_ASSERT(&_pp->pp_lock, LCK_MTX_ASSERT_OWNED)
PP_LOCK_ASSERT_NOTHELD(_pp) LCK_MTX_ASSERT(&_pp->pp_lock, LCK_MTX_ASSERT_NOTOWNED)
PP_UNLOCK(_pp) lck_mtx_unlock(&_pp->pp_lock)
PPCREATEF_EXTERNAL 0x1
PPCREATEF_KERNEL_ONLY 0x2
PPCREATEF_TRUNCATED_BUF 0x4
PPCREATEF_ONDEMAND_BUF 0x8
PPCREATEF_DYNAMIC 0x10
PP_REGION_CONFIG_BUF_IODIR_IN 0x00000001
PP_REGION_CONFIG_BUF_IODIR_OUT 0x00000002
PP_REGION_CONFIG_MD_PERSISTENT 0x00000004
PP_REGION_CONFIG_BUF_PERSISTENT 0x00000008
PP_REGION_CONFIG_MD_MAGAZINE_ENABLE 0x00000010
PP_REGION_CONFIG_KERNEL_ONLY 0x00000020
PP_REGION_CONFIG_BUFLET 0x00000040
PP_REGION_CONFIG_BUF_UREADONLY 0x00000080
PP_REGION_CONFIG_BUF_KREADONLY 0x00000100
PP_REGION_CONFIG_BUF_MONOLITHIC 0x00000200
PP_REGION_CONFIG_BUF_SEGPHYSCONTIG 0x00000400
PP_REGION_CONFIG_BUF_NOCACHE 0x00000800
PP_REGION_CONFIG_BUF_THREADSAFE 0x00002000
SKMEM_TAG_FSW_PORTS "com.apple.skywalk.fsw.ports"
SKMEM_TAG_FSW_FOB_HASH "com.apple.skywalk.fsw.fsw.fob.hash"
SKMEM_TAG_FSW_FRB_HASH "com.apple.skywalk.fsw.fsw.frb.hash"
SKMEM_TAG_FSW_FRIB_HASH "com.apple.skywalk.fsw.fsw.frib.hash"
SKMEM_TAG_FSW_FRAG_MGR "com.apple.skywalk.fsw.fsw.frag.mgr"
BMASK64(_beg, _end)     	((NX_FSW_CHUNK_FREE >> (63 - (_end))) & ~((1ULL << (_beg)) - 1))
fsw_INPUT_NETEM_THREADNAME "if_input_netem_%s@fsw"
fsw_INPUT_NETEM_THREADNAME_LEN 32
FSW_ZONE_MAX 256
FSW_ZONE_NAME "skywalk.nx.fsw"
NX_FSW_FE_TABLESZ 256
NX_FSW_FOB_HASHSZ 31
NX_FSW_FRB_HASHSZ 128
NX_FSW_FRIB_HASHSZ 13
NX_FSW_FLOW_REAP_INTERVAL 1
NX_FSW_RX_STALL_THRES 10
NX_FSW_RX_STALL_DEFUNCT 1
NX_FSW_FLOW_PURGE_THRES 0
FSW_IFSTATS_THRES 1
NX_FSW_CHANNEL_REAP_THRES 1000
RX_BUFLET_BATCH_COUNT 64
FSW_IP_REASS_FORCE_OFF 0
FSW_IP_REASS_FORCE_ON 1
FSW_IP_REASS_NO_FORCE 2
dp_drop_pktq(fsw, pktq, outgoing, _reason, line, _flags) do {         	uint32_t _len = KPKTQ_LEN(pktq);                                      	if (KPKTQ_EMPTY(pktq)) {                                              	        ASSERT(_len == 0);                                            	        return;                                                       	}                                                                     	SK_DF(SK_VERB_FSW_DP | SK_VERB_DROP, "drop %d packets", _len);        	FSW_STATS_ADD(FSW_STATS_DROP, _len);                                  	DTRACE_SKYWALK1(fsw__dp__drop, int, _len);                            	if (__probable(droptap_total_tap_count == 0)) {                       	        dp_free_pktq(fsw, pktq);                                      	        break;                                                        	}                                                                     	drop_func_t dropfunc;                                                 	dropfunc = (outgoing) ? droptap_output_packet : droptap_input_packet; 	struct __kern_packet *kpkt = KPKTQ_FIRST(pktq);                       	struct __kern_packet *next_pkt;                                       	for (; kpkt != NULL; kpkt = next_pkt) {                               	        next_pkt = kpkt->pkt_nextpkt;                                 	        dropfunc(SK_PKT2PH(kpkt), _reason, __func__, line, _flags,    	            fsw->fsw_ifp, kpkt->pkt_qum.qum_pid, NULL, -1, NULL,      	            0, 0);                                                    	}                                                                     	dp_free_pktq(fsw, pktq);                                              } while (0)
dp_drop_pkt_single(fsw, pkt, outgoing, _reason, _flags) do {          	SK_DF(SK_VERB_FSW_DP | SK_VERB_DROP, "drop 1 packet");                	FSW_STATS_ADD(FSW_STATS_DROP, 1);                                     	if (__probable(droptap_total_tap_count == 0)) {                       	        pp_free_packet_single(pkt);                                   	        break;                                                        	}                                                                     	drop_func_t dropfunc;                                                 	dropfunc = (outgoing) ? droptap_output_packet : droptap_input_packet; 	dropfunc(SK_PKT2PH(pkt), _reason, __func__, __LINE__, _flags,         	    fsw->fsw_ifp, (pkt)->pkt_qum.qum_pid, NULL, -1, NULL, 0, 0);      	pp_free_packet_single(pkt);                                           } while (0)
dp_drop_pkt_chain(pkt, outgoing, _reason, _flags) do {                	if (__probable(droptap_total_tap_count == 0)) {                       	        pp_free_packet_chain(pkt, NULL);                              	        break;                                                        	}                                                                     	drop_func_t dropfunc;                                                 	dropfunc = (outgoing) ? droptap_output_packet : droptap_input_packet; 	struct __kern_packet *next_pkt;                                       	for (; pkt != NULL; pkt = next_pkt) {                                 	        next_pkt = pkt->pkt_nextpkt;                                  	        dropfunc(SK_PKT2PH(pkt), _reason, __func__, __LINE__, _flags, 	            NULL, pkt->pkt_qum.qum_pid, NULL, -1, NULL,               	            0, 0);                                                    	}                                                                     	pp_free_packet_chain(pkt, NULL);                                      } while (0)
FSW_ETHER_LEN_PADDED 16
FSW_ETHER_FRAME_HEADROOM FSW_ETHER_LEN_PADDED
IPFM_MAX_FRAGS_PER_QUEUE 128
IPFM_MAX_QUEUES 1024
IPFM_FRAG_TTL 60
IPFM_TIMEOUT_TCALL_INTERVAL 1
_SKYWALK_NEXUS_FLOWSWITCH_FSWVAR_H_ None
FSW_VP_DEV 0
FSW_VP_HOST 1
FSW_VP_USER_MIN 2
FSW_VP_USER_MAX NX_FSW_VP_MAX
FSW_REAP_THREADNAME "skywalk_fsw_reap_%s%s"
FSW_DETACHF_DETACHING 0x10000000
FSW_DETACHF_DETACHED 0x20000000
FSW_REAPF_RUNNING 0x00000001
FSW_REAPF_TERMINATEBLOCK 0x20000000
FSW_REAPF_TERMINATING 0x40000000
FSW_REAPF_TERMINATED 0x80000000
FSW_STATS_VAL(x) STATS_VAL(&fsw->fsw_stats, x)
FSW_STATS_INC(x) STATS_INC(&fsw->fsw_stats, x)
FSW_STATS_ADD(x, n)     STATS_ADD(&fsw->fsw_stats, x, n)
_SKYWALK_NEXUS_FLOWSWITCH_H_ None
NX_FSW_NAME "fsw"
NX_FSW_MAXRINGS NX_MAX_NUM_RING_PAIR
NX_FSW_TXRINGSIZE 256
NX_FSW_RXRINGSIZE 1024
NX_FSW_AFRINGSIZE 256
NX_FSW_CHUNK 64
NX_FSW_CHUNK_FREE 0xffffffffffffffff
NX_FSW_VP_MIN NX_FSW_CHUNK
NX_FSW_VP_MAX 4096
NX_FSW_VP_BROADCAST NX_FSW_VP_MAX
NX_FSW_MINSLOTS 2
NX_FSW_MAXSLOTS NX_MAX_NUM_SLOT_PER_RING
NX_FSW_TXBATCH 64
NX_FSW_RXBATCH 32
NX_FSW_MINBUFSIZE 512
NX_FSW_MIN_LARGE_BUFSIZE 0
NX_FSW_UMD_SIZE _USER_PACKET_SIZE(BUFLETS_MIN)
NX_FSW_KMD_SIZE _KERN_PACKET_SIZE(BUFLETS_MIN)
NX_FSW_EVENT_RING_NUM 1
NX_FSW_EVENT_RING_SIZE 32
VPNA(_na) __unsafe_forge_single(struct nexus_vp_adapter *,    	                    ((struct nexus_vp_adapter *)(_na)))
NEXUS_PROVIDER_FLOW_SWITCH "com.apple.nexus.flowswitch"
FSW_STATEF_QUIESCED 0x0001
FSW_STATEF_NETAGENT_ADDED 0x0002
FSW_STATEF_NETAGENT_ENABLED 0x0004
fsw_slla __fsw_slladdr._buf
fsw_ether_shost __fsw_slladdr._eth_src
FSW_RWINIT(_fsw) lck_rw_init(&(_fsw)->fsw_lock, &nexus_lock_group, &nexus_lock_attr)
FSW_WLOCK(_fsw) lck_rw_lock_exclusive(&(_fsw)->fsw_lock)
FSW_WUNLOCK(_fsw) lck_rw_unlock_exclusive(&(_fsw)->fsw_lock)
FSW_WLOCKTORLOCK(_fsw) lck_rw_lock_exclusive_to_shared(&(_fsw)->fsw_lock)
FSW_RLOCK(_fsw) lck_rw_lock_shared(&(_fsw)->fsw_lock)
FSW_RLOCKTOWLOCK(_fsw) lck_rw_lock_shared_to_exclusive(&(_fsw)->fsw_lock)
FSW_RTRYLOCK(_fsw) lck_rw_try_lock(&(_fsw)->fsw_lock, LCK_RW_TYPE_SHARED)
FSW_RUNLOCK(_fsw) lck_rw_unlock_shared(&(_fsw)->fsw_lock)
FSW_UNLOCK(_fsw) lck_rw_done(&(_fsw)->fsw_lock)
FSW_RWDESTROY(_fsw) lck_rw_destroy(&(_fsw)->fsw_lock, &nexus_lock_group)
FSW_WLOCK_ASSERT_HELD(_fsw) LCK_RW_ASSERT(&(_fsw)->fsw_lock, LCK_RW_ASSERT_EXCLUSIVE)
FSW_RLOCK_ASSERT_HELD(_fsw) LCK_RW_ASSERT(&(_fsw)->fsw_lock, LCK_RW_ASSERT_SHARED)
FSW_LOCK_ASSERT_HELD(_fsw) LCK_RW_ASSERT(&(_fsw)->fsw_lock, LCK_RW_ASSERT_HELD)
NX_KPIPE_RINGSIZE 128
NX_KPIPE_MINSLOTS 2
NX_KPIPE_MAXSLOTS 4096
NX_KPIPE_MAXRINGS NX_MAX_NUM_RING_PAIR
NX_KPIPE_MINBUFSIZE 64
_SKYWALK_NEXUS_KERNEL_PIPE_H_ None
SKMEM_TAG_MONITORS "com.apple.skywalk.monitors"
_SKYWALK_NEXUS_MONITOR_H_ None
NX_NETIF_MAXRINGS NX_MAX_NUM_RING_PAIR
NX_NETIF_MINSLOTS 2
NX_NETIF_MAXSLOTS NX_MAX_NUM_SLOT_PER_RING
NX_NETIF_TXRINGSIZE 512
NX_NETIF_RXRINGSIZE 1024
NX_NETIF_UMD_SIZE _USER_PACKET_SIZE(BUFLETS_MIN)
NX_NETIF_KMD_SIZE _KERN_PACKET_SIZE(BUFLETS_MIN)
NX_NETIF_DOORBELL_MAX_DEQUEUE 64
NQ_TRANSFER_DECAY 2
NQ_ACCUMULATE_INTERVAL 2
SKMEM_TAG_NETIF_MIT "com.apple.skywalk.netif.mit"
SKMEM_TAG_NETIF_FILTER "com.apple.skywalk.netif.filter"
SKMEM_TAG_NETIF_FLOW "com.apple.skywalk.netif.flow"
SKMEM_TAG_NETIF_AGENT_FLOW "com.apple.skywalk.netif.agent_flow"
SKMEM_TAG_NETIF_LLINK "com.apple.skywalk.netif.llink"
SKMEM_TAG_NETIF_QSET "com.apple.skywalk.netif.qset"
SKMEM_TAG_NETIF_LLINK_INFO "com.apple.skywalk.netif.llink_info"
SKMEM_TAG_NETIF_TEMP "com.apple.skywalk.netif.temp"
NQ_EWMA(old, new, decay) do {                               	u_int64_t _avg;                                                 	if (__probable((_avg = (old)) > 0))                             	        _avg = (((_avg << (decay)) - _avg) + (new)) >> (decay); 	else                                                            	        _avg = (new);                                           	(old) = _avg;                                                   } while (0)
_SKYWALK_NEXUS_NETIF_H_ None
NMB_PROPF_TX_NOTIFY 0x1
NMB_FLAGS_MASK 0x0000ffff
NMB_INDEX_MASK 0xffff0000
NMB_SET_FLAGS(p, f)     (((uint32_t)(p) & ~NMB_FLAGS_MASK) | (f))
NMB_SET_INDEX(p, i)     (((uint32_t)(p) & ~NMB_INDEX_MASK) | (i << 16))
SKMEM_TAG_NETIF_COMPAT_MIT "com.apple.skywalk.netif.compat.mit"
SKMEM_TAG_NETIF_COMPAT_POOL "com.apple.skywalk.netif.compat.pool"
_SKYWALK_NEXUS_NETIF_COMPAT_H_ None
NETIF_COMPAT_BUF_SIZE 128
NETIF_COMPAT_MAX_MBUF_DATA_COPY NETIF_COMPAT_BUF_SIZE
DEFAULT_DROP_ENTITLEMENT "com.apple.private.skywalk.default-drop"
NETIF_FILTER_RX_RINGS 2
NETIF_FILTER_TX_RINGS 2
NETIF_FILTER_ALLOC_SLOTS 128
NETIF_FILTER_RING_INBOUND 0
NETIF_FILTER_RING_OUTBOUND 1
CSUM_GSO_MASK 0x00300000
CSUM_GSO_OFFSET 20
_IP_VHL None
DBG_FUNC_NX_NETIF_HOST_ENQUEUE SKYWALKDBG_CODE(DBG_SKYWALK_NETIF, 2)
_SKYWALK_NEXUS_NETIF_HOST_H_ None
NX_NETIF_TAG_QSET "com.apple.skywalk.netif.qset"
NX_NETIF_TAG_LLINK_CFG "com.apple.skywalk.netif.llink.cfg"
_NETIF_QSET_MAX_TXQS 4
MIT_EWMA(old, new, gdecay, sdecay) do {                         	uint32_t _avg;                                                  	if ((_avg = (old)) > 0) {                                       	        uint32_t _d = ((new) > _avg) ? gdecay : sdecay;         	        _avg = (((_avg << (_d)) - _avg) + (new)) >> (_d);       	} else {                                                        	        _avg = (new);                                           	}                                                               	(old) = _avg;                                                   } while (0)
NETIF_AD_MIT_GDECAY 3
NETIF_AD_MIT_SDECAY 2
NETIF_AGENT_FLOW_MAX 16
NETIF_POLL_EWMA(old, new, decay) do {                                 	uint32_t _avg;                                                 	if ((_avg = (old)) > 0)                                         	        _avg = (((_avg << (decay)) - _avg) + (new)) >> (decay); 	else                                                            	        _avg = (new);                                           	(old) = _avg;                                                   } while (0)
NETIF_DEMUX_ALLOC_SLOTS 128
OUTBOUND_CHECK_OFF 0
OUTBOUND_CHECK_ON 1
OUTBOUND_CHECK_FORCED 2
NX_UPIPE_RINGSIZE 128
NX_UPIPE_MAXRINGS NX_MAX_NUM_RING_PAIR
NX_UPIPE_MINSLOTS 2
NX_UPIPE_MAXSLOTS 4096
NX_UPIPE_MINBUFSIZE 1024
NX_UPIPE_MHINTS NEXUS_MHINTS_NORMAL
SKMEM_TAG_PIPES "com.apple.skywalk.pipes"
_SKYWALK_NEXUS_USER_PIPE_H_ None
SK_FO_ZONE_MAX 256
SK_FO_ZONE_NAME "flow.owner"
SK_FE_ZONE_NAME "flow.entry"
SK_FAB_ZONE_NAME "flow.adv.bmap"
SKMEM_TAG_FLOW_DEMUX "com.apple.skywalk.fsw.flow_demux"
MAX_AGG_IP_LEN() MIN(sk_fsw_rx_agg_tcp, IP_MAXPACKET)
fa_sobj __flow_agg._fa_sobj
fa_smbuf __flow_agg._fa_smbuf
fa_spkt __flow_agg._fa_spkt
fa_sptr __flow_agg._fa_sptr
fa_sobj_is_pkt __flow_agg._fa_sobj_is_pkt
fa_sobj_is_short __flow_agg._fa_sobj_is_short
fa_tcp_seq __flow_agg._fa_tcp_seq
fa_ulen __flow_agg._fa_ulen
fa_total __flow_agg._fa_total
fa_fix_pkt_sum __flow_agg._fa_fix_pkt_sum
MASK_SIZE 80
__RX_AGG_CHAN_DROP_SOURCE_PACKET(_pkt, _reason, _flags)    do {    	pp_drop_packet_single(_pkt, fsw->fsw_ifp, _flags, _reason, __func__, __LINE__); 	(_pkt) = NULL;                                                     	FLOW_AGG_CLEAR(&fa);                                               	prev_csum_ok = false;                                              } while (0)
__RX_AGG_HOST_DROP_SOURCE_PACKET(_pkt, _reason, _flags)    do {   	drop_packets++;                                                   	drop_bytes += (_pkt)->pkt_length;                                 	pp_drop_packet_single(_pkt, fsw->fsw_ifp, _flags, _reason, __func__, __LINE__); 	(_pkt) = NULL;                                                    	FLOW_AGG_CLEAR(&fa);                                              	prev_csum_ok = false;                                             } while (0)
CL_SKIP_ON(t) if (__improbable(t)) {                  	        SK_ERR("%d: skip " #t, __LINE__); 	        SK_ERR("%s %s", if_name(ifp), sk_dump("buf", 	            pkt_buf + pkt->pkt_headroom, __packet_get_real_data_length(pkt), 	            MIN(128, bdlen), NULL, 0)); 	        error = ENOTSUP;                	        goto done;                      	}
CL_SKIP_L4() do {                                    	        pkt->pkt_flow_ip_hlen = l3hlen; 	        pkt->pkt_flow_tcp_src = 0;      	        pkt->pkt_flow_tcp_dst = 0;      	        error = 0;                      	        goto done;                      	} while (0);
iph _l3._iph
ip6 _l3._ip6
tcph _l4._tcph
udph _l4._udph
SKMEM_TAG_FSW_FLOW_MGR "com.apple.skywalk.fsw.flow_mgr"
FO_BMASK64(_beg, _end)  	((((uint64_t)0xffffffffffffffff) >>     	    (63 - (_end))) & ~((1ULL << (_beg)) - 1))
FR_ZONE_NAME "flow.route"
FLOW_ROUTE_EXPIRE 600
FS_ZONE_NAME "flow.stats"
FLOWTRACK_LINGER_MIN 1
FLOWTRACK_LINGER_MAX 120
FLOWTRACK_SYN_RATE 20
FTF_HALFCLOSED 0x1
FTF_WAITCLOSE 0x2
FTF_CLOSENOTIFY 0x4
FTF_WITHDRAWN 0x8
FTF_SYN_RLIM 0x10
FTF_RST_RLIM 0x20
_SKYWALK_NEXUS_FLOWSIWTCH_FLOW_FLOWVAR_H_ None
FOBF_OPEN_BUSY 0x1
FOBF_CLOSE_BUSY 0x2
FOBF_DEAD 0x4
FOB_LOCK(_fob) lck_mtx_lock(&(_fob)->fob_lock)
FOB_LOCK_SPIN(_fob) lck_mtx_lock_spin(&(_fob)->fob_lock)
FOB_LOCK_CONVERT(_fob) lck_mtx_convert_spin(&(_fob)->fob_lock)
FOB_TRY_LOCK(_fob) lck_mtx_try_lock(&(_fob)->fob_lock)
FOB_LOCK_ASSERT_HELD(_fob) LCK_MTX_ASSERT(&(_fob)->fob_lock, LCK_MTX_ASSERT_OWNED)
FOB_LOCK_ASSERT_NOTHELD(_fob) LCK_MTX_ASSERT(&(_fob)->fob_lock, LCK_MTX_ASSERT_NOTOWNED)
FOB_UNLOCK(_fob) lck_mtx_unlock(&(_fob)->fob_lock)
FLOW_PROCESS_NAME_LENGTH 24
FO_BUCKET(_fo) __DECONST(struct flow_owner_bucket *, (_fo)->fo_bucket)
FLOWTRACK_RTT_SAMPLE_INTERVAL 2
fse_rtt_usec fse_rtt.frtt_usec
FLOWSTATEF_WSCALE 0x1
flh_eth_padded _flh._eth_padded
flh_eth _flh._eth_padded._eth
MAX_PKT_DEMUX_LIMIT 1000
FLOW_PROC_FLAG_GSO 0x0001
FLOW_PROC_FLAG_FRAGMENTS 0x0001
FLOWENTF_INITED 0x00000001
FLOWENTF_TRACK 0x00000010
FLOWENTF_CONNECTED 0x00000020
FLOWENTF_LISTENER 0x00000040
FLOWENTF_QOS_MARKING 0x00000100
FLOWENTF_LOW_LATENCY 0x00000200
FLOWENTF_WAIT_CLOSE 0x00001000
FLOWENTF_CLOSE_NOTIFY 0x00002000
FLOWENTF_EXTRL_PORT 0x00004000
FLOWENTF_EXTRL_PROTO 0x00008000
FLOWENTF_EXTRL_FLOWID 0x00010000
FLOWENTF_CHILD 0x00020000
FLOWENTF_PARENT 0x00040000
FLOWENTF_NOWAKEFROMSLEEP 0x00080000
FLOWENTF_ABORTED 0x01000000
FLOWENTF_NONVIABLE 0x02000000
FLOWENTF_WITHDRAWN 0x04000000
FLOWENTF_TORN_DOWN 0x08000000
FLOWENTF_HALF_CLOSED 0x10000000
FLOWENTF_DESTROYED 0x40000000
FLOWENTF_LINGERING 0x80000000
FLOWENTF_BITS "\020\01INITED\05TRACK\06CONNECTED\07LISTNER\011QOS_MARKING"     "\012LOW_LATENCY\015WAIT_CLOSE\016CLOSE_NOTIFY\017EXT_PORT"      "\020EXT_PROTO\021EXT_FLOWID\031ABORTED\032NONVIABLE\033WITHDRAWN"      "\034TORN_DOWN\035HALF_CLOSED\037DESTROYED\40LINGERING"
FLOW_ROUTE_MINREF 2
fr_af fr_faddr.sa.sa_family
fr_eth_padded fr_llhdr.flh_eth_padded
fr_eth fr_llhdr.flh_eth
FLOWRTF_ATTACHED 0x00000001
FLOWRTF_ONLINK 0x00000010
FLOWRTF_GATEWAY 0x00000020
FLOWRTF_RESOLVED 0x00000040
FLOWRTF_HAS_LLINFO 0x00000080
FLOWRTF_DELETED 0x00000100
FLOWRTF_DST_LL_MCAST 0x00000200
FLOWRTF_DST_LL_BCAST 0x00000400
FLOWRTF_STABLE_ADDR 0x00000800
FR_LOCK(_fr) lck_mtx_lock(&(_fr)->fr_lock)
FR_TRY_LOCK(_fr) lck_mtx_try_lock(&(_fr)->fr_lock)
FR_LOCK_ASSERT_HELD(_fr) LCK_MTX_ASSERT(&(_fr)->fr_lock, LCK_MTX_ASSERT_OWNED)
FR_LOCK_ASSERT_NOTHELD(_fr) LCK_MTX_ASSERT(&(_fr)->fr_lock, LCK_MTX_ASSERT_NOTOWNED)
FR_UNLOCK(_fr) lck_mtx_unlock(&(_fr)->fr_lock)
FLOWRT_UPD_ETH_DST(_fr, _addr)  do {                            	bcopy((_addr), (_fr)->fr_eth.ether_dhost, ETHER_ADDR_LEN);      	(_fr)->fr_flags &= ~(FLOWRTF_DST_LL_MCAST|FLOWRTF_DST_LL_BCAST);	if (ETHER_IS_MULTICAST(_addr)) {                                	        if (_ether_cmp(etherbroadcastaddr, (_addr)) == 0)       	                (_fr)->fr_flags |= FLOWRTF_DST_LL_BCAST;        	        else                                                    	                (_fr)->fr_flags |= FLOWRTF_DST_LL_MCAST;        	}                                                               } while (0)
FRB_WLOCK(_frb) lck_rw_lock_exclusive(&(_frb)->frb_lock)
FRB_WLOCKTORLOCK(_frb) lck_rw_lock_exclusive_to_shared(&(_frb)->frb_lock)
FRB_WTRYLOCK(_frb) lck_rw_try_lock_exclusive(&(_frb)->frb_lock)
FRB_WUNLOCK(_frb) lck_rw_unlock_exclusive(&(_frb)->frb_lock)
FRB_RLOCK(_frb) lck_rw_lock_shared(&(_frb)->frb_lock)
FRB_RLOCKTOWLOCK(_frb) lck_rw_lock_shared_to_exclusive(&(_frb)->frb_lock)
FRB_RTRYLOCK(_frb) lck_rw_try_lock_shared(&(_frb)->frb_lock)
FRB_RUNLOCK(_frb) lck_rw_unlock_shared(&(_frb)->frb_lock)
FRB_UNLOCK(_frb) lck_rw_done(&(_frb)->frb_lock)
FRB_WLOCK_ASSERT_HELD(_frb) LCK_RW_ASSERT(&(_frb)->frb_lock, LCK_RW_ASSERT_EXCLUSIVE)
FRB_RLOCK_ASSERT_HELD(_frb) LCK_RW_ASSERT(&(_frb)->frb_lock, LCK_RW_ASSERT_SHARED)
FRB_LOCK_ASSERT_HELD(_frb) LCK_RW_ASSERT(&(_frb)->frb_lock, LCK_RW_ASSERT_HELD)
FRIB_WLOCK(_frib) lck_rw_lock_exclusive(&(_frib)->frib_lock)
FRIB_WLOCKTORLOCK(_frib) lck_rw_lock_exclusive_to_shared(&(_frib)->frib_lock)
FRIB_WTRYLOCK(_frib) lck_rw_try_lock_exclusive(&(_frib)->frib_lock)
FRIB_WUNLOCK(_frib) lck_rw_unlock_exclusive(&(_frib)->frib_lock)
FRIB_RLOCK(_frib) lck_rw_lock_shared(&(_frib)->frib_lock)
FRIB_RLOCKTOWLOCK(_frib) lck_rw_lock_shared_to_exclusive(&(_frib)->frib_lock)
FRIB_RTRYLOCK(_frib) lck_rw_try_lock_shared(&(_frib)->frib_lock)
FRIB_RUNLOCK(_frib) lck_rw_unlock_shared(&(_frib)->frib_lock)
FRIB_UNLOCK(_frib) lck_rw_done(&(_frib)->frib_lock)
FRIB_WLOCK_ASSERT_HELD(_frib) LCK_RW_ASSERT(&(_frib)->frib_lock, LCK_RW_ASSERT_EXCLUSIVE)
FRIB_RLOCK_ASSERT_HELD(_frib) LCK_RW_ASSERT(&(_frib)->frib_lock, LCK_RW_ASSERT_SHARED)
FRIB_LOCK_ASSERT_HELD(_frib) LCK_RW_ASSERT(&(_frib)->frib_lock, LCK_RW_ASSERT_HELD)
FK_CMP(field, mask)     	if ((match->fk_mask & mask) != 0) {     	        if ((key->fk_mask & mask) == 0) {       	                return 1;       	        }       	        int d = memcmp(&match->field, &key->field, sizeof(match->field));       	        if (d != 0) {   	                return d;       	        }       	}
FK_HASH(field, mask)    	if ((key->fk_mask & mask) != 0) {       	        hash = net_flowhash(&key->field, sizeof(key->field), hash);     	}
KINFO_LOCK_INIT() rw_init(&audit_kinfo_lock,              	                                "audit_kinfo_lock")
KINFO_RLOCK() rw_rlock(&audit_kinfo_lock)
KINFO_WLOCK() rw_wlock(&audit_kinfo_lock)
KINFO_RUNLOCK() rw_runlock(&audit_kinfo_lock)
KINFO_WUNLOCK() rw_wunlock(&audit_kinfo_lock)
_SECURITY_AUDIT_AUDIT_H None
ARG_EUID 0x0000000000000001ULL
ARG_RUID 0x0000000000000002ULL
ARG_SUID 0x0000000000000004ULL
ARG_EGID 0x0000000000000008ULL
ARG_RGID 0x0000000000000010ULL
ARG_SGID 0x0000000000000020ULL
ARG_PID 0x0000000000000040ULL
ARG_UID 0x0000000000000080ULL
ARG_AUID 0x0000000000000100ULL
ARG_GID 0x0000000000000200ULL
ARG_FD 0x0000000000000400ULL
ARG_FD1 ARG_FD
ARG_POSIX_IPC_PERM 0x0000000000000800ULL
ARG_FFLAGS 0x0000000000001000ULL
ARG_MODE 0x0000000000002000ULL
ARG_VALUE32 0x0000000000004000ULL
ARG_ADDR32 0x0000000000008000ULL
ARG_ADDR ARG_ADDR32
ARG_LEN 0x0000000000010000ULL
ARG_MASK 0x0000000000020000ULL
ARG_SIGNUM 0x0000000000040000ULL
ARG_LOGIN 0x0000000000080000ULL
ARG_SADDRINET 0x0000000000100000ULL
ARG_SADDRINET6 0x0000000000200000ULL
ARG_SADDRUNIX 0x0000000000400000ULL
ARG_TERMID_ADDR ARG_SADDRUNIX
ARG_KPATH1 0x0000000000800000ULL
ARG_KPATH2 0x0000000001000000ULL
ARG_UPATH1 0x0000000002000000ULL
ARG_UPATH2 0x0000000004000000ULL
ARG_TEXT 0x0000000008000000ULL
ARG_VNODE1 0x0000000010000000ULL
ARG_VNODE2 0x0000000020000000ULL
ARG_SVIPC_CMD 0x0000000040000000ULL
ARG_SVIPC_PERM 0x0000000080000000ULL
ARG_SVIPC_ID 0x0000000100000000ULL
ARG_SVIPC_ADDR 0x0000000200000000ULL
ARG_GROUPSET 0x0000000400000000ULL
ARG_CMD 0x0000000800000000ULL
ARG_SOCKINFO 0x0000001000000000ULL
ARG_ASID 0x0000002000000000ULL
ARG_TERMID 0x0000004000000000ULL
ARG_AUDITON 0x0000008000000000ULL
ARG_VALUE64 0x0000010000000000ULL
ARG_AMASK 0x0000020000000000ULL
ARG_CTLNAME 0x0000040000000000ULL
ARG_PROCESS 0x0000080000000000ULL
ARG_MACHPORT1 0x0000100000000000ULL
ARG_MACHPORT2 0x0000200000000000ULL
ARG_MAC_STRING 0x0000400000000000ULL
ARG_EXIT 0x0000800000000000ULL
ARG_IOVECSTR 0x0001000000000000ULL
ARG_ARGV 0x0002000000000000ULL
ARG_ENVV 0x0004000000000000ULL
ARG_OPAQUE 0x0008000000000000ULL
ARG_DATA 0x0010000000000000ULL
ARG_ADDR64 0x0020000000000000ULL
ARG_FD2 0x0040000000000000ULL
ARG_IDENTITY 0x0080000000000000ULL
ARG_NONE 0x0000000000000000ULL
ARG_ALL 0xFFFFFFFFFFFFFFFFULL
MAC_AUDIT_LABEL_LEN 1024
MAC_AUDIT_DATA_TYPE 0
MAC_AUDIT_TEXT_TYPE 1
_KAUTH_CRED_T None
AUDIT_SESSION_REF(cred) audit_session_ref(cred)
AUDIT_SESSION_UNREF(cred) audit_session_unref(cred)
AUDIT_SESSION_PROCNEW(p) audit_session_procnew(p)
AUDIT_SESSION_PROCEXIT(p) audit_session_procexit(p)
AUDIT_USE_BUILTIN_EXPECT None
AUDIT_SYSCALLS() __builtin_expect(audit_syscalls, 0)
AUDIT_ENABLED() __builtin_expect(audit_syscalls &&      	                                audit_enabled, 0)
AUDIT_AUDITING(x) __builtin_expect(NULL != (x), 0)
AUDIT_ARG(op, args...)  do {                                    	if (AUDIT_SYSCALLS()) {                                         	        struct kaudit_record *__single __ar = AUDIT_RECORD();   	        if (AUDIT_AUDITING(__ar))                               	                audit_arg_ ## op (__ar, ## args);               	}                                                               } while (0)
AUDIT_SYSCALL_ENTER(args...) do {                            	if (AUDIT_ENABLED()) {                                  	        audit_syscall_enter(args);                              	}                                                               } while (0)
AUDIT_SYSCALL_EXIT(code, proc, uthread, error)  do {            	        if (AUDIT_AUDITING(uthread->uu_ar))                     	                audit_syscall_exit(code, error, proc, uthread); } while (0)
AUDIT_SUBCALL_ENTER(event, proc, uthread)  do {                 	if (AUDIT_ENABLED())                                            	        audit_subcall_enter(AUE_ ## event, proc, uthread);      } while (0)
AUDIT_SUBCALL_EXIT(uthread, error)  do {                        	        if (AUDIT_AUDITING(uthread->uu_ar))                     	                audit_subcall_exit(error, uthread);             } while (0)
AUDIT_MACH_SYSCALL_ENTER(args...) do {                    	if (AUDIT_ENABLED()) {                                  	        audit_mach_syscall_enter(args);                         	}                                                               } while (0)
AUDIT_MACH_SYSCALL_EXIT(retval) do {                    	if (AUDIT_SYSCALLS()) {                                         	        struct uthread *__uthread = current_uthread();          	        if (AUDIT_AUDITING(__uthread->uu_ar))                   	                audit_mach_syscall_exit(retval, __uthread);     	}                                                               } while (0)
AUDIT_SYSCLOSE(args...) do {                                    	if (AUDIT_SYSCALLS()) {                                         	        struct kaudit_record *__ar = AUDIT_RECORD();            	        if (AUDIT_AUDITING(__ar))                               	                audit_sysclose(__ar, args);                     	}                                                               } while (0)
AUDIT_MHMAGIC 0x4D656C53
timersub(tvp, uvp, vvp)                                         	do {                                                            	        (vvp)->tv_sec = (tvp)->tv_sec - (uvp)->tv_sec;          	        (vvp)->tv_usec = (tvp)->tv_usec - (uvp)->tv_usec;       	        if ((vvp)->tv_usec < 0) {                               	                (vvp)->tv_sec--;                                	                (vvp)->tv_usec += 1000000;                      	        }                                                       	} while (0)
_SECURITY_AUDIT_AUDIT_BSD_H None
AU_MAX_LCK_NAME 32
be16enc(p, d)   *(p) = (d)
be32enc(p, d)   *(p) = (d)
be64enc(p, d)   *(p) = (d)
AUDIT_MALLOC_DEBUG 0
M_AUDITUNKNOWN 0
M_AUDITDATA 1
M_AUDITPATH 2
M_AUDITTEXT 3
M_AUDITBSM 4
M_AUDITEVCLASS 5
M_AUDIT_PIPE 6
M_AUDIT_PIPE_ENTRY 7
M_AUDIT_PIPE_PRESELECT 8
M_AU_SESSION 9
M_AU_EV_PLIST 10
NUM_MALLOC_TYPES 11
M_NOWAIT 0x0001
M_ZERO 0x0004
M_MAGIC 877983977
MALLOC_DEFINE(type, shortdesc, longdesc)                	au_malloc_type_t  audit_##type[1] = {                   	        { 0, 0, 0, 0, (type < NUM_MALLOC_TYPES) ? type :	          M_AUDITUNKNOWN, M_MAGIC, shortdesc, NULL }    	}
MALLOC_DECLARE(type) extern au_malloc_type_t audit_##type[]
cv_init(cvp, desc)        _audit_cv_init(cvp, desc)
cv_destroy(cvp) _audit_cv_destroy(cvp)
cv_signal(cvp) _audit_cv_signal(cvp)
cv_broadcast(cvp) _audit_cv_broadcast(cvp)
cv_broadcastpri(cvp, pri) _audit_cv_broadcast(cvp)
cv_wait(cvp, mp)          _audit_cv_wait(cvp, (mp)->mtx_lock, #cvp)
cv_wait_sig(cvp, mp)      _audit_cv_wait_sig(cvp, (mp)->mtx_lock, #cvp)
cv_wait_continuation(cvp, mp, f)     _audit_cv_wait_continuation(cvp, (mp)->mtx_lock, f)
mtx_init(mp, name, type, opts) 	                        _audit_mtx_init(mp, name)
mtx_lock(mp) lck_mtx_lock((mp)->mtx_lock)
mtx_unlock(mp) lck_mtx_unlock((mp)->mtx_lock)
mtx_destroy(mp) _audit_mtx_destroy(mp)
mtx_yield(mp) lck_mtx_yield((mp)->mtx_lock)
slck_init(lp, name)     _audit_slck_init((lp), (name))
slck_lock(lp) _audit_slck_lock((lp), 0)
slck_unlock(lp) _audit_slck_unlock((lp))
slck_destroy(lp) _audit_slck_destroy((lp))
rlck_init(lp, name)     _audit_rlck_init((lp), (name))
rlck_lock(lp) _audit_rlck_lock((lp))
rlck_unlock(lp) _audit_rlck_unlock((lp))
rlck_destroy(lp) _audit_rlck_destroy((lp))
rw_init(lp, name)       _audit_rw_init(lp, name)
rw_rlock(lp) lck_rw_lock_shared((lp)->rw_lock)
rw_runlock(lp) lck_rw_unlock_shared((lp)->rw_lock)
rw_wlock(lp) lck_rw_lock_exclusive((lp)->rw_lock)
rw_wunlock(lp) lck_rw_unlock_exclusive((lp)->rw_lock)
rw_destroy(lp) _audit_rw_destroy(lp)
MA_OWNED LCK_MTX_ASSERT_OWNED
RA_LOCKED LCK_RW_ASSERT_HELD
RA_RLOCKED LCK_RW_ASSERT_SHARED
RA_WLOCKED LCK_RW_ASSERT_EXCLUSIVE
SA_LOCKED LCK_RW_ASSERT_HELD
SA_XLOCKED LCK_RW_ASSERT_EXCLUSIVE
SL_OWNED LCK_MTX_ASSERT_OWNED
SL_NOTOWNED LCK_MTX_ASSERT_NOTOWNED
ppsratecheck(tv, cr, mr)        _audit_ppsratecheck(tv, cr, mr)
MAC_VNODE1_LABEL_TOKEN do {                                     	if (ar->ar_vnode1_mac_labels != NULL &&                           	    strlen(ar->ar_vnode1_mac_labels) != 0) {                      	        tok = au_to_text(ar->ar_vnode1_mac_labels);               	        kau_write(rec, tok);                                      	}                                                                 } while (0)
MAC_VNODE2_LABEL_TOKEN do {                                      	if (ar->ar_vnode2_mac_labels != NULL &&                           	    strlen(ar->ar_vnode2_mac_labels) != 0) {                      	        tok = au_to_text(ar->ar_vnode2_mac_labels);               	        kau_write(rec, tok);                                      	}                                                                 } while (0)
UPATH1_TOKENS do {                                              	if (ARG_IS_VALID(kar, ARG_UPATH1)) {                            	        tok = au_to_path(ar->ar_arg_upath1);                    	        kau_write(rec, tok);                                    	}                                                               } while (0)
UPATH2_TOKENS do {                                              	if (ARG_IS_VALID(kar, ARG_UPATH2)) {                            	        tok = au_to_path(ar->ar_arg_upath2);                    	        kau_write(rec, tok);                                    	}                                                               } while (0)
KPATH2_TOKENS do {                                              	if (ARG_IS_VALID(kar, ARG_KPATH2)) {                            	        tok = au_to_path(ar->ar_arg_kpath2);                    	        kau_write(rec, tok);                                    	}                                                               } while (0)
VNODE1_TOKENS do {                                              	if (ARG_IS_VALID(kar, ARG_KPATH1)) {                            	        tok = au_to_path(ar->ar_arg_kpath1);                    	        kau_write(rec, tok);                                    	}                                                               	if (ARG_IS_VALID(kar, ARG_VNODE1)) {                            	        tok = au_to_attr32(&ar->ar_arg_vnode1);                 	        kau_write(rec, tok);                                    	        MAC_VNODE1_LABEL_TOKEN;                                 	}                                                               } while (0)
UPATH1_VNODE1_TOKENS do {                                       	if (ARG_IS_VALID(kar, ARG_UPATH1)) {                            	        tok = au_to_path(ar->ar_arg_upath1);                    	        kau_write(rec, tok);                                    	}                                                               	if (ARG_IS_VALID(kar, ARG_KPATH1)) {                            	        tok = au_to_path(ar->ar_arg_kpath1);                    	        kau_write(rec, tok);                                    	}                                                               	if (ARG_IS_VALID(kar, ARG_VNODE1)) {                            	        tok = au_to_attr32(&ar->ar_arg_vnode1);                 	        kau_write(rec, tok);                                    	        MAC_VNODE1_LABEL_TOKEN;                                 	}                                                               } while (0)
VNODE2_TOKENS do {                                              	if (ARG_IS_VALID(kar, ARG_VNODE2)) {                            	        tok = au_to_attr32(&ar->ar_arg_vnode2);                 	        kau_write(rec, tok);                                    	        MAC_VNODE2_LABEL_TOKEN;                                 	}                                                               } while (0)
VNODE2_PATH_TOKENS do {                                 	if (ARG_IS_VALID(kar, ARG_KPATH2)) {                            	        tok = au_to_path(ar->ar_arg_kpath2);                    	        kau_write(rec, tok);                                    	}                                                               	if (ARG_IS_VALID(kar, ARG_VNODE2)) {                            	        tok = au_to_attr32(&ar->ar_arg_vnode2);                 	        kau_write(rec, tok);                                    	        MAC_VNODE2_LABEL_TOKEN;                                 	}                                                               } while (0)
FD_VNODE1_TOKENS do {                                           	if (ARG_IS_VALID(kar, ARG_VNODE1)) {                            	        if (ARG_IS_VALID(kar, ARG_KPATH1)) {                    	                tok = au_to_path(ar->ar_arg_kpath1);            	                kau_write(rec, tok);                            	        }                                                       	        if (ARG_IS_VALID(kar, ARG_FD)) {                        	                tok = au_to_arg32(1, "fd", ar->ar_arg_fd);      	                kau_write(rec, tok);                            	                MAC_VNODE1_LABEL_TOKEN;                         	        }                                                       	        tok = au_to_attr32(&ar->ar_arg_vnode1);                 	        kau_write(rec, tok);                                    	} else {                                                        	        if (ARG_IS_VALID(kar, ARG_FD)) {                        	                tok = au_to_arg32(1, "fd",                      	                    ar->ar_arg_fd);                             	                kau_write(rec, tok);                            	                MAC_VNODE1_LABEL_TOKEN;                         	        }                                                       	}                                                               } while (0)
PROCESS_PID_TOKENS(argn) do {                                   	if ((ar->ar_arg_pid > 0)        	    && (ARG_IS_VALID(kar, ARG_PROCESS))) {                      	        tok = au_to_process32_ex(ar->ar_arg_auid,               	            ar->ar_arg_euid, ar->ar_arg_egid,                   	            ar->ar_arg_ruid, ar->ar_arg_rgid,                   	            ar->ar_arg_pid, ar->ar_arg_asid,                    	            &ar->ar_arg_termid_addr);                           	        kau_write(rec, tok);                                    	} else if (ARG_IS_VALID(kar, ARG_PID)) {                        	        tok = au_to_arg32(argn, "process", ar->ar_arg_pid);     	        kau_write(rec, tok);                                    	}                                                               } while (0)
EXTATTR_TOKENS do {                                             	if (ARG_IS_VALID(kar, ARG_VALUE32)) {                           	        switch (ar->ar_arg_value32) {                           	        case EXTATTR_NAMESPACE_USER:                            	                tok = au_to_text(EXTATTR_NAMESPACE_USER_STRING);	                break;                                          	        case EXTATTR_NAMESPACE_SYSTEM:                          	                tok = au_to_text(EXTATTR_NAMESPACE_SYSTEM_STRING);	                break;                                          	        default:                                                	                tok = au_to_arg32(3, "attrnamespace",           	                    ar->ar_arg_value32);                        	                break;                                          	        }                                                       	        kau_write(rec, tok);                                    	}                                                               	                             	if (ARG_IS_VALID(kar, ARG_TEXT)) {                              	        tok = au_to_text(ar->ar_arg_text);                      	        kau_write(rec, tok);                                    	}                                                               } while (0)
EXTENDED_TOKENS(n) do {                                         	                                          	        if (ARG_IS_VALID(kar, ARG_OPAQUE)) {                    	                tok = au_to_opaque(ar->ar_arg_opaque,           	                    ar->ar_arg_opq_size);                       	                kau_write(rec, tok);                            	        }                                                       	        if (ARG_IS_VALID(kar, ARG_MODE)) {                      	                tok = au_to_arg32(n+2, "mode", ar->ar_arg_mode);	                kau_write(rec, tok);                            	        }                                                       	        if (ARG_IS_VALID(kar, ARG_GID)) {                       	                tok = au_to_arg32(n+1, "gid", ar->ar_arg_gid);  	                kau_write(rec, tok);                            	        }                                                       	        if (ARG_IS_VALID(kar, ARG_UID)) {                       	                tok = au_to_arg32(n, "uid", ar->ar_arg_uid);    	                kau_write(rec, tok);                            	        }                                                       } while (0)
PROCESS_MAC_TOKENS do {                                         	if (ar->ar_valid_arg & ARG_MAC_STRING) {                        	        tok = au_to_text(ar->ar_arg_mac_string);                	        kau_write(rec, tok);                                    	}                                                               } while (0)
PF_NO_LOCAL_MAPPING -600
ERRNO_NO_LOCAL_MAPPING -600
EVCLASSMAP_HASH_TABLE_SIZE 251
EVCLASS_LOCK_INIT() rw_init(&evclass_lock, "evclass_lock")
EVCLASS_RLOCK() rw_rlock(&evclass_lock)
EVCLASS_RUNLOCK() rw_runlock(&evclass_lock)
EVCLASS_WLOCK() rw_wlock(&evclass_lock)
EVCLASS_WUNLOCK() rw_wunlock(&evclass_lock)
ST_NO_LOCAL_MAPPING -600
GET_TOKEN_AREA(t, dptr, length) do {                       	t = kalloc_type(token_t, Z_WAITOK | Z_NOFAIL);                 	t->t_data = kalloc_data(length, Z_WAITOK | Z_ZERO | Z_NOFAIL); 	t->len = length;                                               	dptr = t->t_data;                                              } while (0)
_SECURITY_AUDIT_AUDIT_IOCTL_H_ None
AUDITPIPE_IOBASE 'A'
AUDITSDEV_IOBASE 'S'
AUDITPIPE_PRESELECT_MODE_TRAIL 1
AUDITPIPE_PRESELECT_MODE_LOCAL 2
AUDITPIPE_GET_QLEN _IOR(AUDITPIPE_IOBASE, 1, u_int)
AUDITPIPE_GET_QLIMIT _IOR(AUDITPIPE_IOBASE, 2, u_int)
AUDITPIPE_SET_QLIMIT _IOW(AUDITPIPE_IOBASE, 3, u_int)
AUDITPIPE_GET_QLIMIT_MIN _IOR(AUDITPIPE_IOBASE, 4, u_int)
AUDITPIPE_GET_QLIMIT_MAX _IOR(AUDITPIPE_IOBASE, 5, u_int)
AUDITPIPE_GET_PRESELECT_FLAGS _IOR(AUDITPIPE_IOBASE, 6, au_mask_t)
AUDITPIPE_SET_PRESELECT_FLAGS _IOW(AUDITPIPE_IOBASE, 7, au_mask_t)
AUDITPIPE_GET_PRESELECT_NAFLAGS _IOR(AUDITPIPE_IOBASE, 8, au_mask_t)
AUDITPIPE_SET_PRESELECT_NAFLAGS _IOW(AUDITPIPE_IOBASE, 9, au_mask_t)
AUDITPIPE_GET_PRESELECT_AUID _IOR(AUDITPIPE_IOBASE, 10,      	                                    struct auditpipe_ioctl_preselect)
AUDITPIPE_SET_PRESELECT_AUID _IOW(AUDITPIPE_IOBASE, 11,      	                                    struct auditpipe_ioctl_preselect)
AUDITPIPE_DELETE_PRESELECT_AUID _IOW(AUDITPIPE_IOBASE, 12, au_id_t)
AUDITPIPE_FLUSH_PRESELECT_AUID _IO(AUDITPIPE_IOBASE, 13)
AUDITPIPE_GET_PRESELECT_MODE _IOR(AUDITPIPE_IOBASE, 14, int)
AUDITPIPE_SET_PRESELECT_MODE _IOW(AUDITPIPE_IOBASE, 15, int)
AUDITPIPE_FLUSH _IO(AUDITPIPE_IOBASE, 16)
AUDITPIPE_GET_MAXAUDITDATA _IOR(AUDITPIPE_IOBASE, 17, u_int)
AUDITPIPE_GET_INSERTS _IOR(AUDITPIPE_IOBASE, 100, u_int64_t)
AUDITPIPE_GET_READS _IOR(AUDITPIPE_IOBASE, 101, u_int64_t)
AUDITPIPE_GET_DROPS _IOR(AUDITPIPE_IOBASE, 102, u_int64_t)
AUDITPIPE_GET_TRUNCATES _IOR(AUDITPIPE_IOBASE, 103, u_int64_t)
AUDITSDEV_GET_QLEN _IOR(AUDITSDEV_IOBASE, 1, u_int)
AUDITSDEV_GET_QLIMIT _IOR(AUDITSDEV_IOBASE, 2, u_int)
AUDITSDEV_SET_QLIMIT _IOW(AUDITSDEV_IOBASE, 3, u_int)
AUDITSDEV_GET_QLIMIT_MIN _IOR(AUDITSDEV_IOBASE, 4, u_int)
AUDITSDEV_GET_QLIMIT_MAX _IOR(AUDITSDEV_IOBASE, 5, u_int)
AUDITSDEV_FLUSH _IO(AUDITSDEV_IOBASE, 6)
AUDITSDEV_GET_MAXDATA _IOR(AUDITSDEV_IOBASE, 7, u_int)
AUDITSDEV_GET_ALLSESSIONS _IOR(AUDITSDEV_IOBASE, 100, u_int)
AUDITSDEV_SET_ALLSESSIONS _IOW(AUDITSDEV_IOBASE, 101, u_int)
AUDITSDEV_GET_INSERTS _IOR(AUDITSDEV_IOBASE, 200, u_int64_t)
AUDITSDEV_GET_READS _IOR(AUDITSDEV_IOBASE, 201, u_int64_t)
AUDITSDEV_GET_DROPS _IOR(AUDITSDEV_IOBASE, 202, u_int64_t)
MAC_ARG_PREFIX "arg: "
MAC_ARG_PREFIX_LEN 5
AUDIT_PIPE_ASYNC 0x00000001
AUDIT_PIPE_NBIO 0x00000002
AUDIT_PIPE_LOCK(ap) mtx_lock(&(ap)->ap_mtx)
AUDIT_PIPE_LOCK_ASSERT(ap) mtx_assert(&(ap)->ap_mtx, MA_OWNED)
AUDIT_PIPE_LOCK_DESTROY(ap) mtx_destroy(&(ap)->ap_mtx)
AUDIT_PIPE_LOCK_INIT(ap) mtx_init(&(ap)->ap_mtx, 	                                    "audit_pipe_mtx", NULL, MTX_DEF)
AUDIT_PIPE_UNLOCK(ap) mtx_unlock(&(ap)->ap_mtx)
AUDIT_PIPE_SX_LOCK_DESTROY(ap) slck_destroy(&(ap)->ap_sx)
AUDIT_PIPE_SX_LOCK_INIT(ap) slck_init(&(ap)->ap_sx, "audit_pipe_sx")
AUDIT_PIPE_SX_XLOCK_ASSERT(ap) slck_assert(&(ap)->ap_sx, SA_XLOCKED)
AUDIT_PIPE_SX_XLOCK_SIG(ap) slck_lock_sig(&(ap)->ap_sx)
AUDIT_PIPE_SX_XUNLOCK(ap) slck_unlock(&(ap)->ap_sx)
AUDIT_PIPE_LIST_LOCK_INIT() rw_init(&audit_pipe_lock, 	                                    "audit_pipe_list_lock")
AUDIT_PIPE_LIST_RLOCK() rw_rlock(&audit_pipe_lock)
AUDIT_PIPE_LIST_RUNLOCK() rw_runlock(&audit_pipe_lock)
AUDIT_PIPE_LIST_WLOCK() rw_wlock(&audit_pipe_lock)
AUDIT_PIPE_LIST_WLOCK_ASSERT() rw_assert(&audit_pipe_lock, 	                                    RA_WLOCKED)
AUDIT_PIPE_LIST_WUNLOCK() rw_wunlock(&audit_pipe_lock)
AUDIT_PIPE_NAME "auditpipe"
MAX_AUDIT_PIPES 32
_SECURITY_AUDIT_PRIVATE_H_ None
AUDIT_CHECK_IF_KEVENTS_MASK(m) do {                             	if ((m).am_success || (m).am_failure)                           	        if (!audit_kevent_mask ||                               	            (audit_kevent_mask & (m).am_success) ||             	            (audit_kevent_mask & (m).am_failure))               	                audit_syscalls = 1;                             } while (0)
BSM_SUCCESS 0
BSM_FAILURE 1
BSM_NOAUDIT 2
AR_COMMIT_KERNEL 0x00000001U
AR_COMMIT_USER 0x00000010U
AR_PRESELECT_TRAIL 0x00001000U
AR_PRESELECT_PIPE 0x00002000U
AR_PRESELECT_USER_TRAIL 0x00004000U
AR_PRESELECT_USER_PIPE 0x00008000U
AR_PRESELECT_FILTER 0x00010000U
AR_DRAIN_QUEUE 0x80000000U
ARG_IS_VALID(kar, arg)  ((kar)->k_ar.ar_valid_arg & (arg))
ARG_SET_VALID(kar, arg) do {                                    	(kar)->k_ar.ar_valid_arg |= (arg);                              } while (0)
curthread() current_uthread()
AU_PRS_SUCCESS 1
AU_PRS_FAILURE 2
AU_CLASS_RESERVED_ENTITLEMENT "com.apple.private.dz.audit"
AU_AUDITCTL_RESERVED_ENTITLEMENT "com.apple.private.protected-audit-control"
AU_AUDIT_USER_ENTITLEMENT "com.apple.private.audit.user"
MAX_AU_IDENTITY_SIGNING_ID_LENGTH 129
MAX_AU_IDENTITY_TEAM_ID_LENGTH 17
se_asid se_auinfo.ai_asid
se_auid se_auinfo.ai_auid
se_mask se_auinfo.ai_mask
se_termid se_auinfo.ai_termid
se_flags se_auinfo.ai_flags
HASH_TABLE_SIZE 97
AU_HISTORY_LOGGING 0
AU_HISTORY_MAX_STACK_DEPTH 8
AUDIT_SDEV_QLIMIT_DEFAULT 128
AUDIT_SDEV_QLIMIT_MIN 1
AUDIT_SDEV_QLIMIT_MAX 1024
AUDIT_SDEV_ASYNC 0x00000001
AUDIT_SDEV_NBIO 0x00000002
AUDIT_SDEV_ALLSESSIONS 0x00010000
AUDIT_SDEV_LOCK(asdev) mtx_lock(&(asdev)->asdev_mtx)
AUDIT_SDEV_LOCK_ASSERT(asdev) mtx_assert(&(asdev)->asdev_mtx, 	                                    MA_OWNED)
AUDIT_SDEV_LOCK_DESTROY(asdev) mtx_destroy(&(asdev)->asdev_mtx)
AUDIT_SDEV_LOCK_INIT(asdev) mtx_init(&(asdev)->asdev_mtx, 	                                    "audit_sdev_mtx", NULL, MTX_DEF)
AUDIT_SDEV_UNLOCK(asdev) mtx_unlock(&(asdev)->asdev_mtx)
AUDIT_SDEV_SX_LOCK_DESTROY(asd) slck_destroy(&(asd)->asdev_sx)
AUDIT_SDEV_SX_LOCK_INIT(asd) slck_init(&(asd)->asdev_sx, 	                                    "audit_sdev_sx")
AUDIT_SDEV_SX_XLOCK_ASSERT(asd) slck_assert(&(asd)->asdev_sx, 	                                    SA_XLOCKED)
AUDIT_SDEV_SX_XLOCK_SIG(asd) slck_lock_sig(&(asd)->asdev_sx)
AUDIT_SDEV_SX_XUNLOCK(asd) slck_unlock(&(asd)->asdev_sx)
AUDIT_SDEV_NAME "auditsessions"
MAX_AUDIT_SDEVS 32
AUDIT_SDEV_LIST_LOCK_INIT() rw_init(&audit_sdev_lock, 	                                    "audit_sdev_list_lock")
AUDIT_SDEV_LIST_RLOCK() rw_rlock(&audit_sdev_lock)
AUDIT_SDEV_LIST_RUNLOCK() rw_runlock(&audit_sdev_lock)
AUDIT_SDEV_LIST_WLOCK() rw_wlock(&audit_sdev_lock)
AUDIT_SDEV_LIST_WLOCK_ASSERT() rw_assert(&audit_sdev_lock, 	                                    RA_WLOCKED)
AUDIT_SDEV_LIST_WUNLOCK() rw_wunlock(&audit_sdev_lock)
AUDIT_SENTRY_RWLOCK_INIT() rw_init(&se_entry_lck, 	                                    "se_entry_lck")
AUDIT_SENTRY_RLOCK() rw_rlock(&se_entry_lck)
AUDIT_SENTRY_WLOCK() rw_wlock(&se_entry_lck)
AUDIT_SENTRY_RWLOCK_ASSERT() rw_assert(&se_entry_lck, RA_LOCKED)
AUDIT_SENTRY_RUNLOCK() rw_runlock(&se_entry_lck)
AUDIT_SENTRY_WUNLOCK() rw_wunlock(&se_entry_lck)
AUDIT_SESSION_DEBUG 0
AUDIT_WORKER_SX_INIT() slck_init(&audit_worker_sl,     	                                    "audit_worker_sl")
AUDIT_WORKER_SX_XLOCK() slck_lock(&audit_worker_sl)
AUDIT_WORKER_SX_XUNLOCK() slck_unlock(&audit_worker_sl)
AUDIT_WORKER_SX_ASSERT() slck_assert(&audit_worker_sl, SL_OWNED)
AUDIT_WORKER_SX_DESTROY() slck_destroy(&audit_worker_sl)
GSS_KRB5_NOT_INITIALIZED 0
GSS_KRB5_INITIALIZING 1
GSS_KRB5_INITIALIZED 2
GSS_S_COMPLETE 0
GSS_C_CALLING_ERROR_OFFSET 24
GSS_C_ROUTINE_ERROR_OFFSET 16
GSS_C_SUPPLEMENTARY_OFFSET 0
GSS_C_QOP_DEFAULT 0
KRB5_USAGE_ACCEPTOR_SEAL 22
KRB5_USAGE_ACCEPTOR_SIGN 23
KRB5_USAGE_INITIATOR_SEAL 24
KRB5_USAGE_INITIATOR_SIGN 25
KRB5_USAGE_LEN 5
GSS_SND 0
GSS_RCV 1
GSS_C_QOP_REVERSE 0x80000000
CRYPTO_KS_ALLOCED 0x00001
CRYPTO_CTS_ENABLE 0x00002
CRYPTO_MAX_DIGSET_SIZE 20
_ALTQ_ALTQ_H_ None
ALTQT_NONE PKTSCHEDT_NONE
ALTQT_CBQ PKTSCHEDT_CBQ
ALTQT_HFSC PKTSCHEDT_HFSC
ALTQT_PRIQ PKTSCHEDT_PRIQ
ALTQT_FAIRQ PKTSCHEDT_FAIRQ
ALTQT_QFQ PKTSCHEDT_QFQ
ALTQT_MAX PKTSCHEDT_MAX
_NET_ALTQ_ALTQ_CBQ_H_ None
_NET_ALTQ_ALTQ_FAIRQ_H_ None
_NET_ALTQ_ALTQ_HFSC_H_ None
_NET_ALTQ_ALTQ_PRIQ_H_ None
_NET_ALTQ_ALTQ_QFQ_H_ None
_NET_CLASSQ_CLASSQ_H_ None
CLASSQ_PKT_INIT(_p) do {    	(_p)->cp_ptype = QP_INVALID;   	(_p)->cp_mbuf = NULL;          } while (0)
CLASSQ_PKT_INIT_MBUF(_p, _m)    do {    	(_p)->cp_ptype = QP_MBUF;               	(_p)->cp_mbuf = (_m);                   } while (0)
DEFAULT_QLIMIT 128
CLASSQ_DEQUEUE_MAX_PKT_LIMIT 2048
PKTCNTR_ADD(_cntr, _pkt, _len) do {                             	(_cntr)->packets += (_pkt);                                     	(_cntr)->bytes += (_len);                                       } while (0)
PKTCNTR_CLEAR(_cntr) do {                                       	(_cntr)->packets = 0;                                           	(_cntr)->bytes = 0;                                             } while (0)
CLASSQF_ECN4 0x01
CLASSQF_ECN6 0x02
_NET_CLASSQ_CLASSQ_BLUE_H_ None
DTYPE_NODROP 0
DTYPE_FORCED 1
DTYPE_EARLY 2
_NET_CLASSQ_CLASSQ_FQ_CODEL_H None
AQM_KTRACE_AON_FLOW_HIGH_DELAY AQMDBG_CODE(DBG_AQM_ALWAYSON, 0x001)
AQM_KTRACE_AON_THROTTLE AQMDBG_CODE(DBG_AQM_ALWAYSON, 0x002)
AQM_KTRACE_AON_FLOW_OVERWHELMING AQMDBG_CODE(DBG_AQM_ALWAYSON, 0x003)
AQM_KTRACE_AON_FLOW_DQ_STALL AQMDBG_CODE(DBG_AQM_ALWAYSON, 0x004)
AQM_KTRACE_STATS_FLOW_ENQUEUE AQMDBG_CODE(DBG_AQM_STATS, 0x001)
AQM_KTRACE_STATS_FLOW_DEQUEUE AQMDBG_CODE(DBG_AQM_STATS, 0x002)
AQM_KTRACE_STATS_FLOW_CTL AQMDBG_CODE(DBG_AQM_STATS, 0x003)
AQM_KTRACE_STATS_FLOW_ALLOC AQMDBG_CODE(DBG_AQM_STATS, 0x004)
AQM_KTRACE_STATS_FLOW_DESTROY AQMDBG_CODE(DBG_AQM_STATS, 0x005)
AQM_KTRACE_STATS_FLOW_REPORT_CE AQMDBG_CODE(DBG_AQM_STATS, 0x006)
AQM_KTRACE_STATS_GET_QLEN AQMDBG_CODE(DBG_AQM_STATS, 0x007)
AQM_KTRACE_TX_NOT_READY AQMDBG_CODE(DBG_AQM_STATS, 0x008)
AQM_KTRACE_TX_PACEMAKER AQMDBG_CODE(DBG_AQM_STATS, 0x009)
FQ_MIN_FC_THRESHOLD_BYTES 7500
FQ_SET_DELAY_HIGH(_fq_) do {                              if (!FQ_IS_DELAY_HIGH(_fq_)) {                              	KDBG(AQM_KTRACE_AON_FLOW_HIGH_DELAY | DBG_FUNC_START, 	    (_fq_)->fq_flowhash, AQM_KTRACE_FQ_GRP_SC_IDX((_fq_)),    	    (_fq_)->fq_bytes, (_fq_)->fq_min_qdelay);                     }                                                                     (_fq_)->fq_flags |= FQF_DELAY_HIGH;     } while (0)
FQ_CLEAR_DELAY_HIGH(_fq_) do {     if (FQ_IS_DELAY_HIGH(_fq_)) {        	    KDBG(AQM_KTRACE_AON_FLOW_HIGH_DELAY | DBG_FUNC_END, 	            (_fq_)->fq_flowhash, AQM_KTRACE_FQ_GRP_SC_IDX((_fq_)),  	            (_fq_)->fq_bytes, (_fq_)->fq_min_qdelay);                   }                                                           (_fq_)->fq_flags &= ~FQF_DELAY_HIGH;                    } while (0)
FQ_SET_OVERWHELMING(_fq_) do { 	if (!FQ_IS_OVERWHELMING(_fq_)) {                              	        KDBG(AQM_KTRACE_AON_FLOW_OVERWHELMING | DBG_FUNC_START, 	                        (_fq_)->fq_flowhash, AQM_KTRACE_FQ_GRP_SC_IDX((_fq_)),    	                        (_fq_)->fq_bytes, (_fq_)->fq_min_qdelay);                 	}                                                                                                                                         	(_fq_)->fq_flags |= FQF_OVERWHELMING; } while (0)
FQ_CLEAR_OVERWHELMING(_fq_) do { 	if (FQ_IS_OVERWHELMING(_fq_)) {                              	        KDBG(AQM_KTRACE_AON_FLOW_OVERWHELMING | DBG_FUNC_END,  	                        (_fq_)->fq_flowhash, AQM_KTRACE_FQ_GRP_SC_IDX((_fq_)),    	                        (_fq_)->fq_bytes, (_fq_)->fq_min_qdelay);                 	}                                                                                     	(_fq_)->fq_flags &= ~FQF_OVERWHELMING; } while (0)
FQ_EMPTY_PURGE_MAX 4
FQ_INVALID_TX_TS UINT64_MAX
FQF_FLOWCTL_CAPABLE 0x01
FQF_DELAY_HIGH 0x02
FQF_NEW_FLOW 0x04
FQF_OLD_FLOW 0x08
FQF_FLOWCTL_ON 0x10
FQF_EMPTY_FLOW 0x20
FQF_OVERWHELMING 0x40
FQF_FRESH_FLOW 0x80
fq_mbufq __fq_pktq_u.__mbufq
_NET_CLASSQ_CLASSQ_RED_H_ None
_NET_CLASSQ_CLASSQ_RIO_H_ None
RIO_NDROPPREC 3
_NET_CLASSQ_CLASSQ_SFB_H_ None
SFB_FP_SHIFT 14
SFB_LEVELS 2
SFB_BINS_SHIFT 5
SFBF_ECN4 0x01
SFBF_ECN6 0x02
SFBF_FLOWCTL 0x04
SFBF_DELAYBASED 0x08
SFBF_DELAYHIGH 0x10
SFBF_LAST_PKT_DROPPED 0x20
SFBF_SUSPENDED 0x1000
TBR_SHIFT 32
_NET_CLASSQ_IF_CLASSQ_H_ None
IFCQ_SC_MAX 10
IFCQ_DEFAULT_PKT_DROP_LIMIT 2048
IFCQF_READY 0x01
IFCQF_ENABLED 0x02
IFCQF_TBR 0x04
IFCQF_DESTROYED 0x08
CLASSQEQ_SUCCESS 0
CLASSQEQ_SUCCESS_FC 1
CLASSQEQ_DROP_FC 2
CLASSQEQ_DROP_SP 3
CLASSQEQ_COMPRESSED 4
IF_CLASSQ_DEF 0x0
IF_CLASSQ_LOW_LATENCY 0x1
IF_CLASSQ_L4S 0x2
IF_DEFAULT_GRP 0x4
IF_CLASSQ_ALL_GRPS UINT8_MAX
IFCQ_LOCK_ASSERT_HELD(_ifcq) LCK_MTX_ASSERT(&(_ifcq)->ifcq_lock, LCK_MTX_ASSERT_OWNED)
IFCQ_LOCK_ASSERT_NOTHELD(_ifcq) LCK_MTX_ASSERT(&(_ifcq)->ifcq_lock, LCK_MTX_ASSERT_NOTOWNED)
IFCQ_LOCK(_ifcq) lck_mtx_lock(&(_ifcq)->ifcq_lock)
IFCQ_LOCK_SPIN(_ifcq) lck_mtx_lock_spin(&(_ifcq)->ifcq_lock)
IFCQ_CONVERT_LOCK(_ifcq) do {                                   	IFCQ_LOCK_ASSERT_HELD(_ifcq);                                   	lck_mtx_convert_spin(&(_ifcq)->ifcq_lock);                      } while (0)
IFCQ_UNLOCK(_ifcq) lck_mtx_unlock(&(_ifcq)->ifcq_lock)
IFCQ_TBR_DEQUEUE(_ifcq, _p, _idx) do {                      	ifclassq_tbr_dequeue(_ifcq, _p, _idx);                          } while (0)
IFCQ_TBR_DEQUEUE_SC(_ifcq, _sc, _p, _idx) do {                        	ifclassq_tbr_dequeue_sc(_ifcq, _sc, _p, _idx);                        } while (0)
IFCQ_ADD_LEN(_ifcq, _len) (IFCQ_LEN(_ifcq) += (_len))
IFCQ_SUB_LEN(_ifcq, _len) (IFCQ_LEN(_ifcq) -= (_len))
IFCQ_SET_MAXLEN(_ifcq, _len) ((_ifcq)->ifcq_maxlen = (_len))
IFCQ_INC_BYTES(_ifcq, _len)         ((_ifcq)->ifcq_bytes = (_ifcq)->ifcq_bytes + (_len))
IFCQ_DEC_BYTES(_ifcq, _len)         ((_ifcq)->ifcq_bytes = (_ifcq)->ifcq_bytes - (_len))
IFCQ_XMIT_ADD(_ifcq, _pkt, _len) do {                           	PKTCNTR_ADD(&(_ifcq)->ifcq_xmitcnt, _pkt, _len);                } while (0)
IFCQ_DROP_ADD(_ifcq, _pkt, _len) do {                           	PKTCNTR_ADD(&(_ifcq)->ifcq_dropcnt, _pkt, _len);                } while (0)
_IP_VHL None
_PKTSCHED_PKTSCHED_H_ None
PKTSCHEDT_NONE 0
PKTSCHEDT_CBQ 1
PKTSCHEDT_HFSC 2
PKTSCHEDT_PRIQ 3
PKTSCHEDT_FAIRQ 4
PKTSCHEDT_TCQ 5
PKTSCHEDT_QFQ 6
PKTSCHEDT_FQ_CODEL 7
PKTSCHEDT_MAX 8
PKTSCHEDF_QALG_ECN 0x01
PKTSCHEDF_QALG_FLOWCTL 0x02
PKTSCHEDF_QALG_DELAYBASED 0x04
PKTSCHEDF_QALG_DRIVER_MANAGED 0x08
pktsched_ptype __pkt.cp_ptype
pktsched_plen __plen
pktsched_pcnt __pcnt
pktsched_pkt __pkt
pktsched_pkt_mbuf __pkt.cp_mbuf
pktsched_pkt_kpkt __pkt.cp_kpkt
pktsched_tail __tail
pktsched_tail_mbuf __tail.cp_mbuf
pktsched_tail_kpkt __tail.cp_kpkt
_PKTSCHED_PKT_INIT(_p) do {                                    	(_p)->pktsched_pkt = CLASSQ_PKT_INITIALIZER((_p)->pktsched_pkt);	(_p)->pktsched_tail = CLASSQ_PKT_INITIALIZER((_p)->pktsched_tail);	(_p)->pktsched_plen = 0;                                        	(_p)->pktsched_pcnt = 0;                                        } while (0)
CALLOUT_INIT(c) do {                                    	(void) memset((c), 0, sizeof (*(c)));                   } while (  0)
CALLOUT_RESET(c, t, f, a) do {                          	(c)->c_arg = (a);                                       	(c)->c_func = (f);                                      	timeout((f), (a), (t));                                 } while (  0)
CALLOUT_STOP(c) untimeout((c)->c_func, (c)->c_arg)
CALLOUT_INITIALIZER { NULL, NULL }
read_machclk() mach_absolute_time()
_NET_PKTSCHED_PKTSCHED_CBQ_H_ None
CBQCLF_RED RMCF_RED
CBQCLF_ECN RMCF_ECN
CBQCLF_RIO RMCF_RIO
CBQCLF_FLOWVALVE RMCF_FLOWVALVE
CBQCLF_CLEARDSCP RMCF_CLEARDSCP
CBQCLF_BORROW 0x0020
CBQCLF_WRR RMCF_WRR
CBQCLF_EFFICIENT RMCF_EFFICIENT
CBQCLF_ROOTCLASS 0x1000
CBQCLF_DEFCLASS 0x2000
CBQCLF_CLASSMASK 0xf000
CBQCLF_BLUE RMCF_BLUE
CBQCLF_SFB RMCF_SFB
CBQCLF_FLOWCTL RMCF_FLOWCTL
CBQCLF_LAZY 0x10000000
CBQCLF_BITS "\020\1RED\2ECN\3RIO\4FLOWVALVE\5CLEARDSCP\6BORROW" 	"\11WRR\12EFFICIENT\15ROOT\16DEFAULT\21BLUE\22SFB\23FLOWCTL\35LAZY"
CBQ_MAXQSIZE 200
CBQ_MAXPRI RM_MAXPRIO
_NET_PKTSCHED_PKTSCHED_FAIRQ_H_ None
FAIRQ_MAX_BUCKETS 2048
FAIRQ_MAXPRI RM_MAXPRIO
FARF_RED 0x0001
FARF_ECN 0x0002
FARF_RIO 0x0004
FARF_CLEARDSCP 0x0010
FARF_BLUE 0x0100
FARF_SFB 0x0200
FARF_FLOWCTL 0x0400
FARF_DEFAULTCLASS 0x1000
FARF_HAS_PACKETS 0x2000
FARF_LAZY 0x10000000
FARF_BITS "\020\1RED\2ECN\3RIO\5CLEARDSCP\11BLUE\12SFB\13FLOWCTL\15DEFAULT" 	"\16HASPKTS\35LAZY"
FQ_CODEL_DEFAULT_QUANTUM 1500
FQ_CODEL_DRR_MAX(_s) fq_codel_drr_max_values[FQ_IF_##_s##_INDEX]
_FQ_CLASSQ_UPDATE_QUANTUM(_grp, _s, _q)                     	(_grp)->fqg_classq[FQ_IF_ ## _s ## _INDEX].fcl_quantum =        	    FQ_CODEL_QUANTUM_ ## _s(_q)
_FQ_CLASSQ_INIT(_grp, _s, _q)                          fq_if_classq_init(_grp, FQ_IF_ ## _s ##_INDEX,         	FQ_CODEL_QUANTUM_ ## _s(_q), FQ_CODEL_DRR_MAX(_s),     	MBUF_SC_ ## _s );
_NET_PKTSCHED_FQ_CODEL_H_ None
FQ_IF_DEFAULT_QUANTUM 1500
FQ_IF_MAX_CLASSES 10
FQ_IF_LARGE_FLOW_BYTE_LIMIT 15000
FQ_IF_MAX_GROUPS 16
FQ_IF_BK_SYS_INDEX 9
FQ_IF_BK_INDEX 8
FQ_IF_BE_INDEX 7
FQ_IF_RD_INDEX 6
FQ_IF_OAM_INDEX 5
FQ_IF_AV_INDEX 4
FQ_IF_RV_INDEX 3
FQ_IF_VI_INDEX 2
FQ_IF_SIG_INDEX 2
FQ_IF_VO_INDEX 1
FQ_IF_CTL_INDEX 0
FCL_PACED 0x1
FQ_IF_DEFAULT_GRP 0x1
FQG_ADD_LEN(_fqg, _len) (FQG_LEN(_fqg) += (_len))
FQG_SUB_LEN(_fqg, _len) (FQG_LEN(_fqg) -= (_len))
FQG_INC_BYTES(_fqg, _len)         ((_fqg)->fqg_bytes = (_fqg)->fqg_bytes + (_len))
FQG_DEC_BYTES(_fqg, _len)         ((_fqg)->fqg_bytes = (_fqg)->fqg_bytes - (_len))
FQS_DRIVER_MANAGED 0x1
grp_bitmaps_ffs fqs_bm_ops->ffs
grp_bitmaps_zeros fqs_bm_ops->zeros
grp_bitmaps_cpy fqs_bm_ops->cpy
grp_bitmaps_clr fqs_bm_ops->clr
grp_bitmaps_move fqs_bm_ops->move
FQS_GROUP(_fqs, _group_idx)                                      	(fq_if_find_grp((_fqs), (_group_idx)))
FQS_CLASSQ(_fqs, _group_idx, _sc_idx)                                (FQS_GROUP((_fqs), (_group_idx))->fqg_classq[_sc_idx])
FQ_GRP_ADD_LEN(_fq, _len)                          	(FQ_GRP_LEN((_fq)) += (_len))
FQ_GRP_SUB_LEN(_fq, _len)                          	(FQ_GRP_LEN((_fq)) -= (_len))
FQS_GRP_ADD_LEN(_fqs, _grp_idx, _len)              	(FQS_GROUP(_fqs, grp_idx)->fqg_len += (_len))
FQ_GRP_INC_BYTES(_fq, _len)               (FQ_GRP_BYTES((_fq)) += (_len))
FQ_GRP_DEC_BYTES(_fq, _len)               (FQ_GRP_BYTES((_fq)) -= (_len))
FQS_GRP_INC_BYTES(_fqs, grp_idx, _len)           	(FQS_GROUP(_fqs, grp_idx)->fqg_bytes += (_len))
FQ_FLOWSTATS_OLD_FLOW 0x1
FQ_FLOWSTATS_NEW_FLOW 0x2
FQ_FLOWSTATS_LARGE_FLOW 0x4
FQ_FLOWSTATS_DELAY_HIGH 0x8
FQ_FLOWSTATS_FLOWCTL_ON 0x10
FQ_IF_MAX_FLOWSTATS 20
FQ_IF_STATS_MAX_GROUPS 16
_NET_PKTSCHED_PKTSCHED_HFSC_H_ None
HFSCF_M1_PCT 0x1
HFSCF_M2_PCT 0x10
HFSC_NULLCLASS_HANDLE 0
HFSC_MAX_CLASSES 64
HFCF_RED 0x0001
HFCF_ECN 0x0002
HFCF_RIO 0x0004
HFCF_CLEARDSCP 0x0010
HFCF_BLUE 0x0100
HFCF_SFB 0x0200
HFCF_FLOWCTL 0x0400
HFCF_DEFAULTCLASS 0x1000
HFCF_RSC 0x10000
HFCF_FSC 0x20000
HFCF_USC 0x40000
HFCF_LAZY 0x10000000
HFCF_BITS "\020\1RED\2ECN\3RIO\5CLEARDSCP\11BLUE\12SFB\13FLOWCTL\15DEFAULT" 	"\21RSC\22FSC\23USC\35LAZY"
HFSC_REALTIMESC 1
HFSC_LINKSHARINGSC 2
HFSC_UPPERLIMITSC 4
NETEM_STUB int netem_config(__unused struct netem **ne, __unused const char *__null_terminated name,     __unused struct ifnet *ifp, __unused const struct if_netem_params *p,    __unused void *output_handle, __unused netem_output_func_t *output_func,     __unused uint32_t output_max_batch_size) { 	printf("%s error: unavailable on this platform\n", __func__); 	return ENOTSUP; } void __attribute__((noreturn)) netem_get_params(__unused struct netem *ne,     __unused struct if_netem_params *p) { 	panic("unexpected netem call"); } void __attribute__((noreturn)) netem_destroy(__unused struct netem *ne) { 	panic("unexpected netem call"); } int netem_enqueue(__unused struct netem *ne, __unused classq_pkt_t *p,     __unused bool *pdrop) { 	panic("unexpected netem call"); 	return 0; }
NETEM_MAX_BATCH_SIZE 32
_NET_PKTSCHED_PKTSCHED_PRIQ_H_ None
PRIQ_MAXPRI 16
PRCF_RED 0x0001
PRCF_ECN 0x0002
PRCF_RIO 0x0004
PRCF_CLEARDSCP 0x0010
PRCF_BLUE 0x0100
PRCF_SFB 0x0200
PRCF_FLOWCTL 0x0400
PRCF_DEFAULTCLASS 0x1000
PRCF_LAZY 0x10000000
PRCF_BITS "\020\1RED\2ECN\3RIO\5CLEARDSCP\11BLUE\12SFB\13FLOWCTL\15DEFAULT" 	"\35LAZY"
_NET_PKTSCHED_PKTSCHED_RMCLASS_H_ None
RM_MAXPRIO 8
RMCF_RED 0x0001
RMCF_ECN 0x0002
RMCF_RIO 0x0004
RMCF_FLOWVALVE 0x0008
RMCF_CLEARDSCP 0x0010
RMCF_WRR 0x0100
RMCF_EFFICIENT 0x0200
RMCF_BLUE 0x10000
RMCF_SFB 0x20000
RMCF_FLOWCTL 0x40000
FS_BIND_H None
BINDM_CACHE 0x0001
BINDM_CASEINSENSITIVE 0x0000000000000002
BIND_FLAG_HASHED 0x000000001
BINDV_NOUNLOCK 0x0001
BINDV_DROP 0x0002
BINDFSERROR(format, args...) printf("ERROR: BindFS %s: " format, __FUNCTION__, ##args)
BINDFS_ENTITLEMENT "com.apple.private.bindfs-allow"
SIZEOF_MEMBER(type, member) (sizeof(((type *)0)->member))
BIND_ROOT_INO 2
VOPFUNC int (*)(void *)
_MISCFS_DEVFS_DEVFS_H_ None
DEVFS_CHAR 0
DEVFS_BLOCK 1
DEVFS_CLONE_ALLOC 1
DEVFS_CLONE_FREE 0
__DEVFS_DEVFSDEFS_H__ None
FDL_WANT 0x01
FDL_LOCKED 0x02
NFDCACHE 3
UIO_MX 16
VOPFUNC int (*)(void *)
fdesc_revoke nop_revoke
__DEVFS_DEVFS_PROTO_H__ None
SPLIT_DEVS 1
BSD_KERNEL_PRIVATE 1
NUM_STACK_ENTRIES 5
DEVFS_NOCREATE FALSE
DEVFS_CREATE TRUE
VOPFUNC int (*)(void *)
__FDESC_FDESC_H__ None
__FIFOFS_FOFO_H__ None
FIFO_INCREATE 1
FIFO_CREATEWAIT 2
FIFO_CREATED 4
fifo_revoke nop_revoke
VOPFUNC int (*)(void *)
MOCKFS_H None
MOCKFS_FSNODE_H None
VOPFUNC int (*)(void *)
MOCKFS_VNOPS_H None
FS_NULL_H None
NULLM_CACHE 0x0001
NULLM_CASEINSENSITIVE 0x0000000000000002
NULLM_UNVEIL 0x1ULL << 2
NULL_FLAG_HASHED 0x000000001
NULLV_NOUNLOCK 0x0001
NULLV_DROP 0x0002
NULLFS_ENTITLEMENT "com.apple.private.nullfs_allow"
SIZEOF_MEMBER(type, member) (sizeof(((type *)0)->member))
NULL_ROOT_INO 2
NULL_SECOND_INO 3
NULL_THIRD_INO 4
_MISCFS_ROUTEFS_DEVFS_H_ None
ROUTEFS_LOCK() lck_mtx_lock(&routefs_mutex)
ROUTEFS_UNLOCK() lck_mtx_unlock(&routefs_mutex)
MOBILE_DIR_PATH "/private/var/mobile"
VOPFUNC int (*)(void *)
_MISCFS_SPECFS_SPECDEV_H_ None
VOPFUNC int (*)(void *)
LOWPRI_TIER1_WINDOW_MSECS 25
LOWPRI_TIER2_WINDOW_MSECS 100
LOWPRI_TIER3_WINDOW_MSECS 500
LOWPRI_TIER1_IO_PERIOD_MSECS 40
LOWPRI_TIER2_IO_PERIOD_MSECS 85
LOWPRI_TIER3_IO_PERIOD_MSECS 200
LOWPRI_TIER1_IO_PERIOD_SSD_MSECS 5
LOWPRI_TIER2_IO_PERIOD_SSD_MSECS 15
LOWPRI_TIER3_IO_PERIOD_SSD_MSECS 25
SPEC_INIT_BSDUNIT(vp, ctx) spec_init_bsdunit((vp), (ctx), __FUNCTION__)
__UNION_UNION_H__ None
save_r0 r[0]
save_r1 r[1]
save_r2 r[2]
save_r3 r[3]
save_r4 r[4]
save_r5 r[5]
save_r6 r[6]
save_r7 r[7]
save_r8 r[8]
save_r9 r[9]
save_r10 r[10]
save_r11 r[11]
save_r12 r[12]
save_r13 r[13]
unix_syscall_kprintf(x...) None
unix_syscall_return_kprintf(x...) None
UC_TRAD 1
UC_FLAVOR 30
UC_SET_ALT_STACK 0x40000000
UC_RESET_ALT_STACK 0x80000000
C_64_REDZONE_LEN 128
mmmmap eno_mmap
ARM64_FP 29
ARM64_LR 30
ARM64_SP 31
ARM64_PC 32
ARM64_CPSR 33
RETURN_OFFSET64 8
proc_t struct proc
DTRACE_INVOP_PUSH_FRAME 11
DTRACE_INVOP_NOP_SKIP 4
DTRACE_INVOP_ADD_FP_SP_SKIP 4
DTRACE_INVOP_POP_PC_SKIP 2
FBT_B_MASK 0xff000000
FBT_B_IMM_MASK 0x00ffffff
FBT_B_INSTR 0x14000000
FBT_PATCHVAL 0xe7eeee7e
FBT_AFRAMES_ENTRY 7
FBT_AFRAMES_RETURN 7
FBT_ENTRY "entry"
FBT_RETURN "return"
T_INVALID_OPCODE EXC_BAD_INSTRUCTION
FBT_EXCEPTION_CODE T_INVALID_OPCODE
BSD_HOST 1
_SYS_BLIST_H_ None
BLIST_META_RADIX 16
BLIST_META_RADIX_SHIFT LOG2(BLIST_META_RADIX)
BLIST_BMAP_RADIX_SHIFT LOG2(BLIST_BMAP_RADIX)
BLIST_MAX_ALLOC BLIST_BMAP_RADIX
proc_t struct proc
t_predcache t_dtrace_predcache
DTRACEHIOC_ADDDOF_U32 _IOW('h', 4, user32_addr_t)
DTRACEHIOC_ADDDOF_U64 _IOW('h', 4, user64_addr_t)
DTRACE_GETSTR(hash, elm)		(hash->dth_getstr(elm, hash->dth_stroffs))
DTRACE_HASHSTR(hash, elm)		dtrace_hash_str(DTRACE_GETSTR(hash, elm))
DTRACE_HASHNEXT(hash, elm)		(void**)((uintptr_t)(elm) + (hash)->dth_nextoffs)
DTRACE_HASHPREV(hash, elm)		(void**)((uintptr_t)(elm) + (hash)->dth_prevoffs)
DTRACE_HASHEQ(hash, lhs, rhs)		(strcmp(DTRACE_GETSTR(hash, lhs), 	    DTRACE_GETSTR(hash, rhs)) == 0)
DTRACE_AGGHASHSIZE_SLEW 17
DTRACE_TLS_THRKEY(where) {                                           	uint_t intr = ml_at_interrupt_context();  	uint64_t thr = thread_tid(current_thread());                             	ASSERT(intr < 2);                                                        	(where) = ((thr + DIF_VARIABLE_MAX) & (~((uint64_t)1 << 63))) |          		((uint64_t)intr << 63);                                              }
DT_MASK_LO 0x00000000FFFFFFFFULL
DTRACE_STORE(type, tomax, offset, what) 	*((type *)((uintptr_t)(tomax) + (uintptr_t)offset)) = (type)(what);
DTRACE_ALIGNCHECK(addr, size, flags)					if (addr & (MIN(size,4) - 1)) {							*flags |= CPU_DTRACE_BADALIGN;						cpu_core[CPU->cpu_id].cpuc_dtrace_illval = addr;			return (0);							}
DTRACE_RANGE_REMAIN(remp, addr, baseaddr, basesz)		do {										if ((remp) != NULL) {								*(remp) = (uintptr_t)(baseaddr) + (basesz) - (addr);		}								} while (0)
DTRACE_INRANGE(testaddr, testsz, baseaddr, basesz) 	((testaddr) - (baseaddr) < (basesz) && 	(testaddr) + (testsz) - (baseaddr) <= (basesz) && 	(testaddr) + (testsz) >= (testaddr))
DTRACE_INSCRATCH(mstate, alloc_sz) 	((mstate)->dtms_scratch_base + (mstate)->dtms_scratch_size - 	(mstate)->dtms_scratch_ptr >= (alloc_sz))
DTRACE_LOADFUNC(bits) uint##bits##_t dtrace_load##bits(uintptr_t addr);												extern int dtrace_nofault_copy##bits(uintptr_t, uint##bits##_t *);										uint##bits##_t								dtrace_load##bits(uintptr_t addr)					{										size_t size = bits / NBBY;														uint##bits##_t rval = 0;						int i;									volatile uint16_t *flags = (volatile uint16_t *)			    &cpu_core[CPU->cpu_id].cpuc_dtrace_flags;				uintptr_t caddr = vm_memtag_canonicalize_kernel(addr);												DTRACE_ALIGNCHECK(addr, size, flags);														for (i = 0; i < dtrace_toxranges; i++) {					if (caddr >= dtrace_toxrange[i].dtt_limit)					continue;																if (caddr + size <= dtrace_toxrange[i].dtt_base)				continue;																									*flags |= CPU_DTRACE_BADADDR;						cpu_core[CPU->cpu_id].cpuc_dtrace_illval = addr;			return (0);							}																		{									*flags |= CPU_DTRACE_NOFAULT;																							if (!pmap_valid_page(pmap_find_phys(kernel_pmap, addr)) ||		    dtrace_nofault_copy##bits(addr, &rval)) {					*flags |= CPU_DTRACE_BADADDR;						cpu_core[CPU->cpu_id].cpuc_dtrace_illval = addr;			return (0);							}																		*flags &= ~CPU_DTRACE_NOFAULT;						}																		return (rval);							}
dtrace_loadptr dtrace_load64
DTRACE_DYNHASH_FREE 0
DTRACE_DYNHASH_SINK 1
DTRACE_DYNHASH_VALID 2
DTRACE_MATCH_FAIL -1
DTRACE_MATCH_NEXT 0
DTRACE_MATCH_DONE 1
DTRACE_STATE_ALIGN 64
_S6_un __u6_addr
_S6_u8 __u6_addr8
DTRACE_LAZY_DOFS_DUPLICATED 1
HELPER_MAJOR -24
DTRACE_MAJOR -24
proc_t struct proc
WAKEUP_REAPER 0x7FFFFFFFFFFFFFFFLL
NEARLY_FOREVER 0x7FFFFFFFFFFFFFFELL
TOTTY 0x02
proc_t struct proc
_DTRACE_XOROSHIRO128_PLUS_H None
proc_t struct proc
FASTTRAP_CLEANUP_PROVIDER 0x1
FASTTRAP_CLEANUP_TRACEPOINT 0x2
FASTTRAP_TPOINTS_DEFAULT_SIZE 0x4000
FASTTRAP_PROVIDERS_DEFAULT_SIZE 0x100
FASTTRAP_PROCS_DEFAULT_SIZE 0x100
FASTTRAP_ENABLE_FAIL 1
FASTTRAP_ENABLE_PARTIAL 2
FASTTRAP_PROVS_INDEX(pid, name) 	((fasttrap_hash_str(name) + (pid)) & fasttrap_provs.fth_mask)
FASTTRAP_PROBE_T_ZONE_MAX_TRACEPOINTS 4
DEFAULT_RETIRED_SIZE 256
FASTTRAP_MAJOR -24
FBT_PROBETAB_SIZE 0x8000
FBT_MAJOR -24
CLOSURE(s) #s,
CRITICAL(s) #s,
ARM_ONLY(s) #s,
PROBE_ARGS0(a, b, c, d, e) "\000"
PROBE_ARGS1(a, b, c, d, e) a "\000"
PROBE_ARGS2(a, b, c, d, e) a "\000" b "\000"
PROBE_ARGS3(a, b, c, d, e) a "\000" b "\000" c "\000"
PROBE_ARGS4(a, b, c, d, e) a "\000" b "\000" c "\000" d "\000"
PROBE_ARGS5(a, b, c, d, e) a "\000" b "\000" c "\000" d "\000" e "\000"
PROBE_ARGS_(a, b, c, d, e, n, ...) PROBE_ARGS##n(a, b, c, d, e)
PROBE_ARGS(...) PROBE_ARGS_(__VA_ARGS__, 5, 4, 3, 2, 1, 0)
LOCKSTAT_PROBE(func, name, probe, ...) 	{func, name, probe, DTRACE_IDNONE, PROBE_ARGS(__VA_ARGS__)}
PROF_NAMELEN 15
PROF_PROFILE 0
PROF_TICK 1
PROF_PREFIX_PROFILE "profile-"
PROF_PREFIX_TICK "tick-"
PROFILE_MAX_DEFAULT 1000
PROFILE_MAJOR -24
SDT_PATCHVAL 0xe7eeee7e
SDT_AFRAMES 7
SDT_PROBETAB_SIZE 0x1000
SDT_UNKNOWN_FUNCNAME "."
SDT_MAJOR -24
sy_callc sy_call
NSYSCALL nsysent
casptr dtrace_casptr
membar_enter dtrace_membar_producer
LOADABLE_SYSCALL(a) 0
LOADED_SYSCALL(a) 1
SYSTRACE_SHIFT 16
systrace_init _systrace_init
MACH_TRAP_TABLE_COUNT 128
NSYSCALL mach_trap_count
SYSTRACE_MAJOR -24
_SYS_SYSTRACE_H None
mmmmap eno_mmap
TERM 0
VEX_2bytes 0xC5
VEX_3bytes 0xC4
FILL 0x90
EAX_REGNO 0
ECX_REGNO 1
EDX_REGNO 2
EBX_REGNO 3
ESP_REGNO 4
EBP_REGNO 5
ESI_REGNO 6
EDI_REGNO 7
MODE_NONE 0
MODE_IPREL 1
MODE_SIGNED 2
MODE_IMPLIED 3
MODE_OFFSET 4
MODE_RIPREL 5
REX_W 0x08
REX_R 0x04
REX_X 0x02
REX_B 0x01
VEX_R 0x08
VEX_X 0x04
VEX_B 0x02
VEX_L 0x04
VEX_W 0x08
VEX_m 0x1F
VEX_v 0x78
VEX_p 0x03
VEX_m_0F 0x01
VEX_m_0F38 0x02
VEX_m_0F3A 0x03
VEX_p_66 0x01
VEX_p_F3 0x02
VEX_p_F2 0x03
OPSIZE(osize, wbit) ((wbit) ? isize[osize] : 1)
OPSIZE64(osize, wbit) ((wbit) ? isize64[osize] : 1)
REG_ONLY 3
BYTE_OPND 0
LONG_OPND 1
MM_OPND 2
XMM_OPND 3
SEG_OPND 4
CONTROL_OPND 5
DEBUG_OPND 6
TEST_OPND 7
WORD_OPND 8
YMM_OPND 9
STANDARD_MODRM(x, mode, reg, r_m, rex_prefix, wbit, vbit)  {			dtrace_get_modrm(x, &mode, &reg, &r_m);					dtrace_rex_adjust(rex_prefix, mode, &reg, &r_m);			dtrace_get_operand(x, mode, r_m, wbit, vbit);				dtrace_get_operand(x, REG_ONLY, reg, wbit, 1 - vbit);	}
MIXED_MM(x, mode, reg, r_m, rex_prefix, wbit, w2, vbit)	{			dtrace_get_modrm(x, &mode, &reg, &r_m);					dtrace_rex_adjust(rex_prefix, mode, &reg, &r_m);			dtrace_get_operand(x, mode, r_m, wbit, vbit);				dtrace_get_operand(x, REG_ONLY, reg, w2, 1 - vbit);	}
THREEOPERAND(x, mode, reg, r_m, rex_prefix, wbit, w2, immsize, vbit) { 		dtrace_get_modrm(x, &mode, &reg, &r_m);					dtrace_rex_adjust(rex_prefix, mode, &reg, &r_m);			dtrace_get_operand(x, mode, r_m, wbit, 2-vbit);				dtrace_get_operand(x, REG_ONLY, reg, w2, 1+vbit);			dtrace_imm_opnd(x, wbit, immsize, 0);			}
FOUROPERAND(x, mode, reg, r_m, rex_prefix, wbit, w2, immsize) { 		dtrace_get_modrm(x, &mode, &reg, &r_m);					dtrace_rex_adjust(rex_prefix, mode, &reg, &r_m);			dtrace_get_operand(x, mode, r_m, wbit, 2);				dtrace_get_operand(x, REG_ONLY, reg, w2, 3);				dtrace_imm_opnd(x, wbit, immsize, 1);					dtrace_imm_opnd(x, wbit, immsize, 0);			}
ONEOPERAND_TWOIMM(x, mode, reg, r_m, rex_prefix, wbit, immsize) { 		dtrace_get_modrm(x, &mode, &reg, &r_m);					dtrace_rex_adjust(rex_prefix, mode, &reg, &r_m);			dtrace_get_operand(x, mode, r_m, wbit, 2);				dtrace_imm_opnd(x, wbit, immsize, 1);					dtrace_imm_opnd(x, wbit, immsize, 0);			}
RETURN_OFFSET 4
RETURN_OFFSET64 8
T_INT3 3
proc_t struct proc
FASTTRAP_MODRM(mod, reg, rm)	(((mod) << 6) | ((reg) << 3) | (rm))
FASTTRAP_REX(w, r, x, b)		(0x40 | ((w) << 3) | ((r) << 2) | ((x) << 1) | (b))
FASTTRAP_PUSHL_EBP 0x55
FASTTRAP_JO 0x70
FASTTRAP_JNO 0x71
FASTTRAP_JB 0x72
FASTTRAP_JAE 0x73
FASTTRAP_JE 0x74
FASTTRAP_JNE 0x75
FASTTRAP_JBE 0x76
FASTTRAP_JA 0x77
FASTTRAP_JS 0x78
FASTTRAP_JNS 0x79
FASTTRAP_JP 0x7a
FASTTRAP_JNP 0x7b
FASTTRAP_JL 0x7c
FASTTRAP_JGE 0x7d
FASTTRAP_JLE 0x7e
FASTTRAP_JG 0x7f
FASTTRAP_NOP 0x90
FASTTRAP_MOV_EAX 0xb8
FASTTRAP_MOV_ECX 0xb9
FASTTRAP_RET16 0xc2
FASTTRAP_RET 0xc3
FASTTRAP_LOOPNZ 0xe0
FASTTRAP_LOOPZ 0xe1
FASTTRAP_LOOP 0xe2
FASTTRAP_JCXZ 0xe3
FASTTRAP_CALL 0xe8
FASTTRAP_JMP32 0xe9
FASTTRAP_JMP8 0xeb
FASTTRAP_INT3 0xcc
FASTTRAP_INT 0xcd
FASTTRAP_2_BYTE_OP 0x0f
FASTTRAP_GROUP5_OP 0xff
FASTTRAP_0F_JO 0x80
FASTTRAP_0F_JNO 0x81
FASTTRAP_0F_JB 0x82
FASTTRAP_0F_JAE 0x83
FASTTRAP_0F_JE 0x84
FASTTRAP_0F_JNE 0x85
FASTTRAP_0F_JBE 0x86
FASTTRAP_0F_JA 0x87
FASTTRAP_0F_JS 0x88
FASTTRAP_0F_JNS 0x89
FASTTRAP_0F_JP 0x8a
FASTTRAP_0F_JNP 0x8b
FASTTRAP_0F_JL 0x8c
FASTTRAP_0F_JGE 0x8d
FASTTRAP_0F_JLE 0x8e
FASTTRAP_0F_JG 0x8f
FASTTRAP_EFLAGS_OF 0x800
FASTTRAP_EFLAGS_DF 0x400
FASTTRAP_EFLAGS_SF 0x080
FASTTRAP_EFLAGS_ZF 0x040
FASTTRAP_EFLAGS_AF 0x010
FASTTRAP_EFLAGS_PF 0x004
FASTTRAP_EFLAGS_CF 0x001
FASTTRAP_PREFIX_OPERAND 0x66
FASTTRAP_PREFIX_ADDRESS 0x67
FASTTRAP_PREFIX_CS 0x2E
FASTTRAP_PREFIX_DS 0x3E
FASTTRAP_PREFIX_ES 0x26
FASTTRAP_PREFIX_FS 0x64
FASTTRAP_PREFIX_GS 0x65
FASTTRAP_PREFIX_SS 0x36
FASTTRAP_PREFIX_LOCK 0xF0
FASTTRAP_PREFIX_REP 0xF3
FASTTRAP_PREFIX_REPNE 0xF2
FASTTRAP_NOREG 0xff
_FASTTRAP_REGSET_H None
REG_GSBASE 27
REG_FSBASE 26
REG_DS 25
REG_ES 24
REG_GS 23
REG_FS 22
REG_SS 21
REG_RSP 20
REG_RFL 19
REG_CS 18
REG_RIP 17
REG_ERR 16
REG_TRAPNO 15
REG_RAX 14
REG_RCX 13
REG_RDX 12
REG_RBX 11
REG_RBP 10
REG_RSI 9
REG_RDI 8
REG_R8 7
REG_R9 6
REG_R10 5
REG_R11 4
REG_R12 3
REG_R13 2
REG_R14 1
REG_R15 0
SS 18
UESP 17
EFL 16
CS 15
EIP 14
ERR 13
TRAPNO 12
EAX 11
ECX 10
EDX 9
EBX 8
ESP 7
EBP 6
ESI 5
EDI 4
DS 3
ES 2
FS 1
GS 0
REG_PC EIP
REG_FP EBP
REG_SP UESP
REG_PS EFL
REG_R0 EAX
REG_R1 EDX
DTRACE_INVOP_NOP_SKIP 1
DTRACE_INVOP_MOVL_ESP_EBP 10
DTRACE_INVOP_MOVL_ESP_EBP_SKIP 2
DTRACE_INVOP_MOV_RSP_RBP 11
DTRACE_INVOP_MOV_RSP_RBP_SKIP 3
DTRACE_INVOP_POP_RBP 12
DTRACE_INVOP_POP_RBP_SKIP 1
DTRACE_INVOP_LEAVE_SKIP 1
FBT_PUSHL_EBP 0x55
FBT_MOVL_ESP_EBP0_V0 0x8b
FBT_MOVL_ESP_EBP1_V0 0xec
FBT_MOVL_ESP_EBP0_V1 0x89
FBT_MOVL_ESP_EBP1_V1 0xe5
FBT_PUSH_RBP 0x55
FBT_REX_RSP_RBP 0x48
FBT_MOV_RSP_RBP0 0x89
FBT_MOV_RSP_RBP1 0xe5
FBT_POP_RBP 0x5d
FBT_POPL_EBP 0x5d
FBT_RET 0xc3
FBT_RET_IMM16 0xc2
FBT_LEAVE 0xc9
FBT_JMP_SHORT_REL 0xeb
FBT_JMP_NEAR_REL 0xe9
FBT_JMP_FAR_ABS 0xea
FBT_RET_LEN 1
FBT_RET_IMM16_LEN 3
FBT_JMP_SHORT_REL_LEN 2
FBT_JMP_NEAR_REL_LEN 5
FBT_JMP_FAR_ABS_LEN 5
FBT_PATCHVAL 0xf0
FBT_AFRAMES_ENTRY 7
FBT_AFRAMES_RETURN 6
FBT_ENTRY "entry"
FBT_RETURN "return"
FBT_EXCEPTION_CODE T_INVALID_OPCODE
UC_TRAD 1
UC_FLAVOR 30
UC_SET_ALT_STACK 0x40000000
UC_RESET_ALT_STACK 0x80000000
C_32_STK_ALIGN 16
C_64_STK_ALIGN 16
C_64_REDZONE_LEN 128
TRUNC_DOWN32(a, c)       ((((uint32_t)a)-(c)) & ((uint32_t)(-(c))))
TRUNC_DOWN64(a, c)       ((((uint64_t)a)-(c)) & ((uint64_t)(-(c))))
FP_IE 0
FP_DE 1
FP_ZE 2
FP_OE 3
FP_UE 4
FP_PE 5
RANDOM_MAJOR -1
RANDOM_MINOR 0
URANDOM_MINOR 1
__DEV_RANDOMDEV_H__ None
